
obj/net/ns:     file format elf64-x86-64


Disassembly of section .text:

0000000000800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	movabs $USTACKTOP, %rax
  800020:	48 b8 00 e0 7f ef 00 	movabs $0xef7fe000,%rax
  800027:	00 00 00 
	cmpq %rax,%rsp
  80002a:	48 39 c4             	cmp    %rax,%rsp
	jne args_exist
  80002d:	75 04                	jne    800033 <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushq $0
  80002f:	6a 00                	pushq  $0x0
	pushq $0
  800031:	6a 00                	pushq  $0x0

0000000000800033 <args_exist>:

args_exist:
	movq 8(%rsp), %rsi
  800033:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
	movq (%rsp), %rdi
  800038:	48 8b 3c 24          	mov    (%rsp),%rdi
	call libmain
  80003c:	e8 0f 10 00 00       	callq  801050 <libmain>
1:	jmp 1b
  800041:	eb fe                	jmp    800041 <args_exist+0xe>

0000000000800043 <next_i>:
static envid_t timer_envid;
static envid_t input_envid;
static envid_t output_envid;

static bool buse[QUEUE_SIZE];
static int next_i(int i) { return (i+1) % QUEUE_SIZE; }
  800043:	55                   	push   %rbp
  800044:	48 89 e5             	mov    %rsp,%rbp
  800047:	48 83 ec 08          	sub    $0x8,%rsp
  80004b:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80004e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800051:	8d 48 01             	lea    0x1(%rax),%ecx
  800054:	ba 67 66 66 66       	mov    $0x66666667,%edx
  800059:	89 c8                	mov    %ecx,%eax
  80005b:	f7 ea                	imul   %edx
  80005d:	c1 fa 03             	sar    $0x3,%edx
  800060:	89 c8                	mov    %ecx,%eax
  800062:	c1 f8 1f             	sar    $0x1f,%eax
  800065:	29 c2                	sub    %eax,%edx
  800067:	89 d0                	mov    %edx,%eax
  800069:	c1 e0 02             	shl    $0x2,%eax
  80006c:	01 d0                	add    %edx,%eax
  80006e:	c1 e0 02             	shl    $0x2,%eax
  800071:	29 c1                	sub    %eax,%ecx
  800073:	89 ca                	mov    %ecx,%edx
  800075:	89 d0                	mov    %edx,%eax
  800077:	c9                   	leaveq 
  800078:	c3                   	retq   

0000000000800079 <prev_i>:
static int prev_i(int i) { return (i ? i-1 : QUEUE_SIZE-1); }
  800079:	55                   	push   %rbp
  80007a:	48 89 e5             	mov    %rsp,%rbp
  80007d:	48 83 ec 08          	sub    $0x8,%rsp
  800081:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800084:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800088:	74 08                	je     800092 <prev_i+0x19>
  80008a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80008d:	83 e8 01             	sub    $0x1,%eax
  800090:	eb 05                	jmp    800097 <prev_i+0x1e>
  800092:	b8 13 00 00 00       	mov    $0x13,%eax
  800097:	c9                   	leaveq 
  800098:	c3                   	retq   

0000000000800099 <get_buffer>:

static void *
get_buffer(void) {
  800099:	55                   	push   %rbp
  80009a:	48 89 e5             	mov    %rsp,%rbp
  80009d:	48 83 ec 10          	sub    $0x10,%rsp
    void *va;

    int64_t i;
    for (i = 0; i < QUEUE_SIZE; i++)
  8000a1:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8000a8:	00 
  8000a9:	eb 20                	jmp    8000cb <get_buffer+0x32>
        if (!buse[i]) break;
  8000ab:	48 ba 70 90 82 00 00 	movabs $0x829070,%rdx
  8000b2:	00 00 00 
  8000b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8000b9:	48 01 d0             	add    %rdx,%rax
  8000bc:	0f b6 00             	movzbl (%rax),%eax
  8000bf:	83 f0 01             	xor    $0x1,%eax
  8000c2:	84 c0                	test   %al,%al
  8000c4:	75 0e                	jne    8000d4 <get_buffer+0x3b>
static void *
get_buffer(void) {
    void *va;

    int64_t i;
    for (i = 0; i < QUEUE_SIZE; i++)
  8000c6:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8000cb:	48 83 7d f8 13       	cmpq   $0x13,-0x8(%rbp)
  8000d0:	7e d9                	jle    8000ab <get_buffer+0x12>
  8000d2:	eb 01                	jmp    8000d5 <get_buffer+0x3c>
        if (!buse[i]) break;
  8000d4:	90                   	nop

    if (i == QUEUE_SIZE) {
  8000d5:	48 83 7d f8 14       	cmpq   $0x14,-0x8(%rbp)
  8000da:	75 2a                	jne    800106 <get_buffer+0x6d>
        panic("NS: buffer overflow");
  8000dc:	48 ba 40 0c 82 00 00 	movabs $0x820c40,%rdx
  8000e3:	00 00 00 
  8000e6:	be 40 00 00 00       	mov    $0x40,%esi
  8000eb:	48 bf 54 0c 82 00 00 	movabs $0x820c54,%rdi
  8000f2:	00 00 00 
  8000f5:	b8 00 00 00 00       	mov    $0x0,%eax
  8000fa:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  800101:	00 00 00 
  800104:	ff d1                	callq  *%rcx
        return 0;
    }

    va = (void *)(REQVA + i * PGSIZE);
  800106:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80010a:	48 05 eb ff 00 00    	add    $0xffeb,%rax
  800110:	48 c1 e0 0c          	shl    $0xc,%rax
  800114:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    buse[i] = 1;
  800118:	48 ba 70 90 82 00 00 	movabs $0x829070,%rdx
  80011f:	00 00 00 
  800122:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800126:	48 01 d0             	add    %rdx,%rax
  800129:	c6 00 01             	movb   $0x1,(%rax)

    return va;
  80012c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800130:	c9                   	leaveq 
  800131:	c3                   	retq   

0000000000800132 <put_buffer>:

static void
put_buffer(void *va) {
  800132:	55                   	push   %rbp
  800133:	48 89 e5             	mov    %rsp,%rbp
  800136:	48 83 ec 18          	sub    $0x18,%rsp
  80013a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    int64_t i = ((uint64_t)va - REQVA) / PGSIZE;
  80013e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800142:	48 2d 00 b0 fe 0f    	sub    $0xffeb000,%rax
  800148:	48 c1 e8 0c          	shr    $0xc,%rax
  80014c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    buse[i] = 0;
  800150:	48 ba 70 90 82 00 00 	movabs $0x829070,%rdx
  800157:	00 00 00 
  80015a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80015e:	48 01 d0             	add    %rdx,%rax
  800161:	c6 00 00             	movb   $0x0,(%rax)
}
  800164:	90                   	nop
  800165:	c9                   	leaveq 
  800166:	c3                   	retq   

0000000000800167 <lwip_init>:

    static void
lwip_init(struct netif *nif, void *if_state,
        uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
  800167:	55                   	push   %rbp
  800168:	48 89 e5             	mov    %rsp,%rbp
  80016b:	48 83 ec 50          	sub    $0x50,%rsp
  80016f:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800173:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800177:	89 55 bc             	mov    %edx,-0x44(%rbp)
  80017a:	89 4d b8             	mov    %ecx,-0x48(%rbp)
  80017d:	44 89 45 b4          	mov    %r8d,-0x4c(%rbp)
    struct ip_addr ipaddr, netmask, gateway;
    ipaddr.addr  = init_addr;
  800181:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800184:	89 45 f0             	mov    %eax,-0x10(%rbp)
    netmask.addr = init_mask;
  800187:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80018a:	89 45 e0             	mov    %eax,-0x20(%rbp)
    gateway.addr = init_gw;
  80018d:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800190:	89 45 d0             	mov    %eax,-0x30(%rbp)

    if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  800193:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  800197:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80019b:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  80019f:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8001a3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8001a7:	48 83 ec 08          	sub    $0x8,%rsp
  8001ab:	49 ba bf 0e 81 00 00 	movabs $0x810ebf,%r10
  8001b2:	00 00 00 
  8001b5:	41 52                	push   %r10
  8001b7:	49 b9 87 9a 81 00 00 	movabs $0x819a87,%r9
  8001be:	00 00 00 
  8001c1:	49 89 f8             	mov    %rdi,%r8
  8001c4:	48 89 c7             	mov    %rax,%rdi
  8001c7:	48 b8 85 cf 80 00 00 	movabs $0x80cf85,%rax
  8001ce:	00 00 00 
  8001d1:	ff d0                	callq  *%rax
  8001d3:	48 83 c4 10          	add    $0x10,%rsp
  8001d7:	48 85 c0             	test   %rax,%rax
  8001da:	75 2a                	jne    800206 <lwip_init+0x9f>
                if_state,
                jif_init,
                ip_input))
        panic("lwip_init: error in netif_add\n");
  8001dc:	48 ba 60 0c 82 00 00 	movabs $0x820c60,%rdx
  8001e3:	00 00 00 
  8001e6:	be 5d 00 00 00       	mov    $0x5d,%esi
  8001eb:	48 bf 54 0c 82 00 00 	movabs $0x820c54,%rdi
  8001f2:	00 00 00 
  8001f5:	b8 00 00 00 00       	mov    $0x0,%eax
  8001fa:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  800201:	00 00 00 
  800204:	ff d1                	callq  *%rcx

    netif_set_default(nif);
  800206:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80020a:	48 89 c7             	mov    %rax,%rdi
  80020d:	48 b8 8c d3 80 00 00 	movabs $0x80d38c,%rax
  800214:	00 00 00 
  800217:	ff d0                	callq  *%rax
    netif_set_up(nif);
  800219:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80021d:	48 89 c7             	mov    %rax,%rdi
  800220:	48 b8 ac d3 80 00 00 	movabs $0x80d3ac,%rax
  800227:	00 00 00 
  80022a:	ff d0                	callq  *%rax
}
  80022c:	90                   	nop
  80022d:	c9                   	leaveq 
  80022e:	c3                   	retq   

000000000080022f <net_timer>:

    static void __attribute__((noreturn))
net_timer(uint64_t arg)
{
  80022f:	55                   	push   %rbp
  800230:	48 89 e5             	mov    %rsp,%rbp
  800233:	48 83 ec 20          	sub    $0x20,%rsp
  800237:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct timer_thread *t = (struct timer_thread *) arg;
  80023b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80023f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    for (;;) {
        uint32_t cur = sys_time_msec();
  800243:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  80024a:	00 00 00 
  80024d:	ff d0                	callq  *%rax
  80024f:	89 45 f4             	mov    %eax,-0xc(%rbp)

        lwip_core_lock();
  800252:	48 b8 e3 8b 81 00 00 	movabs $0x818be3,%rax
  800259:	00 00 00 
  80025c:	ff d0                	callq  *%rax
        t->func();
  80025e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800262:	48 8b 40 08          	mov    0x8(%rax),%rax
  800266:	ff d0                	callq  *%rax
        lwip_core_unlock();
  800268:	48 b8 ea 8b 81 00 00 	movabs $0x818bea,%rax
  80026f:	00 00 00 
  800272:	ff d0                	callq  *%rax

        thread_wait(0, 0, cur + t->msec);
  800274:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800278:	8b 10                	mov    (%rax),%edx
  80027a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80027d:	01 d0                	add    %edx,%eax
  80027f:	89 c2                	mov    %eax,%edx
  800281:	be 00 00 00 00       	mov    $0x0,%esi
  800286:	bf 00 00 00 00       	mov    $0x0,%edi
  80028b:	48 b8 64 8d 81 00 00 	movabs $0x818d64,%rax
  800292:	00 00 00 
  800295:	ff d0                	callq  *%rax
    }
  800297:	eb aa                	jmp    800243 <net_timer+0x14>

0000000000800299 <start_timer>:
}

    static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800299:	55                   	push   %rbp
  80029a:	48 89 e5             	mov    %rsp,%rbp
  80029d:	48 83 ec 30          	sub    $0x30,%rsp
  8002a1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8002a5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8002a9:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8002ad:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
    t->msec = msec;
  8002b0:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8002b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002b7:	89 10                	mov    %edx,(%rax)
    t->func = func;
  8002b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002bd:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8002c1:	48 89 50 08          	mov    %rdx,0x8(%rax)
    t->name = name;
  8002c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002c9:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8002cd:	48 89 50 10          	mov    %rdx,0x10(%rax)
    int r = thread_create(0, name, &net_timer, (uint64_t)t);
  8002d1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8002d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8002d9:	48 89 d1             	mov    %rdx,%rcx
  8002dc:	48 ba 2f 02 80 00 00 	movabs $0x80022f,%rdx
  8002e3:	00 00 00 
  8002e6:	48 89 c6             	mov    %rax,%rsi
  8002e9:	bf 00 00 00 00       	mov    $0x0,%edi
  8002ee:	48 b8 df 8f 81 00 00 	movabs $0x818fdf,%rax
  8002f5:	00 00 00 
  8002f8:	ff d0                	callq  *%rax
  8002fa:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (r < 0)
  8002fd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800301:	79 3f                	jns    800342 <start_timer+0xa9>
        panic("cannot create timer thread: %s", e2s(r));
  800303:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800306:	89 c7                	mov    %eax,%edi
  800308:	48 b8 76 96 81 00 00 	movabs $0x819676,%rax
  80030f:	00 00 00 
  800312:	ff d0                	callq  *%rax
  800314:	48 89 c1             	mov    %rax,%rcx
  800317:	48 ba 80 0c 82 00 00 	movabs $0x820c80,%rdx
  80031e:	00 00 00 
  800321:	be 7b 00 00 00       	mov    $0x7b,%esi
  800326:	48 bf 54 0c 82 00 00 	movabs $0x820c54,%rdi
  80032d:	00 00 00 
  800330:	b8 00 00 00 00       	mov    $0x0,%eax
  800335:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  80033c:	00 00 00 
  80033f:	41 ff d0             	callq  *%r8
}
  800342:	90                   	nop
  800343:	c9                   	leaveq 
  800344:	c3                   	retq   

0000000000800345 <tcpip_init_done>:

    static void
tcpip_init_done(void *arg)
{
  800345:	55                   	push   %rbp
  800346:	48 89 e5             	mov    %rsp,%rbp
  800349:	48 83 ec 20          	sub    $0x20,%rsp
  80034d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    uint32_t *done = arg;
  800351:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800355:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    *done = 1;
  800359:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80035d:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    thread_wakeup(done);
  800363:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800367:	48 89 c7             	mov    %rax,%rdi
  80036a:	48 b8 10 8d 81 00 00 	movabs $0x818d10,%rax
  800371:	00 00 00 
  800374:	ff d0                	callq  *%rax
}
  800376:	90                   	nop
  800377:	c9                   	leaveq 
  800378:	c3                   	retq   

0000000000800379 <serve_init>:

    void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  800379:	55                   	push   %rbp
  80037a:	48 89 e5             	mov    %rsp,%rbp
  80037d:	48 83 ec 20          	sub    $0x20,%rsp
  800381:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800384:	89 75 e8             	mov    %esi,-0x18(%rbp)
  800387:	89 55 e4             	mov    %edx,-0x1c(%rbp)
    int r;
    lwip_core_lock();
  80038a:	48 b8 e3 8b 81 00 00 	movabs $0x818be3,%rax
  800391:	00 00 00 
  800394:	ff d0                	callq  *%rax

    uint32_t done = 0;
  800396:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    tcpip_init(&tcpip_init_done, &done);
  80039d:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8003a1:	48 89 c6             	mov    %rax,%rsi
  8003a4:	48 bf 45 03 80 00 00 	movabs $0x800345,%rdi
  8003ab:	00 00 00 
  8003ae:	48 b8 ee 8c 80 00 00 	movabs $0x808cee,%rax
  8003b5:	00 00 00 
  8003b8:	ff d0                	callq  *%rax
    lwip_core_unlock();
  8003ba:	48 b8 ea 8b 81 00 00 	movabs $0x818bea,%rax
  8003c1:	00 00 00 
  8003c4:	ff d0                	callq  *%rax
    thread_wait(&done, 0, (uint32_t)~0);
  8003c6:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8003ca:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8003cf:	be 00 00 00 00       	mov    $0x0,%esi
  8003d4:	48 89 c7             	mov    %rax,%rdi
  8003d7:	48 b8 64 8d 81 00 00 	movabs $0x818d64,%rax
  8003de:	00 00 00 
  8003e1:	ff d0                	callq  *%rax
    lwip_core_lock();
  8003e3:	48 b8 e3 8b 81 00 00 	movabs $0x818be3,%rax
  8003ea:	00 00 00 
  8003ed:	ff d0                	callq  *%rax

    lwip_init(&nif, &output_envid, ipaddr, netmask, gw);
  8003ef:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8003f2:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8003f5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8003f8:	41 89 c8             	mov    %ecx,%r8d
  8003fb:	89 d1                	mov    %edx,%ecx
  8003fd:	89 c2                	mov    %eax,%edx
  8003ff:	48 be 60 90 82 00 00 	movabs $0x829060,%rsi
  800406:	00 00 00 
  800409:	48 bf 20 75 b5 00 00 	movabs $0xb57520,%rdi
  800410:	00 00 00 
  800413:	48 b8 67 01 80 00 00 	movabs $0x800167,%rax
  80041a:	00 00 00 
  80041d:	ff d0                	callq  *%rax

    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  80041f:	b9 88 13 00 00       	mov    $0x1388,%ecx
  800424:	48 ba 9f 0c 82 00 00 	movabs $0x820c9f,%rdx
  80042b:	00 00 00 
  80042e:	48 be 9f 5b 81 00 00 	movabs $0x815b9f,%rsi
  800435:	00 00 00 
  800438:	48 bf 00 90 82 00 00 	movabs $0x829000,%rdi
  80043f:	00 00 00 
  800442:	48 b8 99 02 80 00 00 	movabs $0x800299,%rax
  800449:	00 00 00 
  80044c:	ff d0                	callq  *%rax
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  80044e:	b9 fa 00 00 00       	mov    $0xfa,%ecx
  800453:	48 ba a9 0c 82 00 00 	movabs $0x820ca9,%rdx
  80045a:	00 00 00 
  80045d:	48 be 3e 03 81 00 00 	movabs $0x81033e,%rsi
  800464:	00 00 00 
  800467:	48 bf 20 90 82 00 00 	movabs $0x829020,%rdi
  80046e:	00 00 00 
  800471:	48 b8 99 02 80 00 00 	movabs $0x800299,%rax
  800478:	00 00 00 
  80047b:	ff d0                	callq  *%rax
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  80047d:	b9 f4 01 00 00       	mov    $0x1f4,%ecx
  800482:	48 ba b5 0c 82 00 00 	movabs $0x820cb5,%rdx
  800489:	00 00 00 
  80048c:	48 be ff fa 80 00 00 	movabs $0x80faff,%rsi
  800493:	00 00 00 
  800496:	48 bf 40 90 82 00 00 	movabs $0x829040,%rdi
  80049d:	00 00 00 
  8004a0:	48 b8 99 02 80 00 00 	movabs $0x800299,%rax
  8004a7:	00 00 00 
  8004aa:	ff d0                	callq  *%rax

    struct in_addr ia = {ipaddr};
  8004ac:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004af:	89 45 f0             	mov    %eax,-0x10(%rbp)
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004b2:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004b5:	89 c7                	mov    %eax,%edi
  8004b7:	48 b8 6b 2f 81 00 00 	movabs $0x812f6b,%rax
  8004be:	00 00 00 
  8004c1:	ff d0                	callq  *%rax
  8004c3:	49 89 c1             	mov    %rax,%r9
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004c6:	48 b8 20 75 b5 00 00 	movabs $0xb57520,%rax
  8004cd:	00 00 00 
  8004d0:	0f b6 40 46          	movzbl 0x46(%rax),%eax
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004d4:	0f b6 f0             	movzbl %al,%esi
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004d7:	48 b8 20 75 b5 00 00 	movabs $0xb57520,%rax
  8004de:	00 00 00 
  8004e1:	0f b6 40 45          	movzbl 0x45(%rax),%eax
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004e5:	44 0f b6 c0          	movzbl %al,%r8d
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004e9:	48 b8 20 75 b5 00 00 	movabs $0xb57520,%rax
  8004f0:	00 00 00 
  8004f3:	0f b6 40 44          	movzbl 0x44(%rax),%eax
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004f7:	0f b6 f8             	movzbl %al,%edi
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  8004fa:	48 b8 20 75 b5 00 00 	movabs $0xb57520,%rax
  800501:	00 00 00 
  800504:	0f b6 40 43          	movzbl 0x43(%rax),%eax
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800508:	0f b6 c8             	movzbl %al,%ecx
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  80050b:	48 b8 20 75 b5 00 00 	movabs $0xb57520,%rax
  800512:	00 00 00 
  800515:	0f b6 40 42          	movzbl 0x42(%rax),%eax
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800519:	0f b6 d0             	movzbl %al,%edx
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  80051c:	48 b8 20 75 b5 00 00 	movabs $0xb57520,%rax
  800523:	00 00 00 
  800526:	0f b6 40 41          	movzbl 0x41(%rax),%eax
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  80052a:	0f b6 c0             	movzbl %al,%eax
  80052d:	41 51                	push   %r9
  80052f:	56                   	push   %rsi
  800530:	45 89 c1             	mov    %r8d,%r9d
  800533:	41 89 f8             	mov    %edi,%r8d
  800536:	89 c6                	mov    %eax,%esi
  800538:	48 bf c8 0c 82 00 00 	movabs $0x820cc8,%rdi
  80053f:	00 00 00 
  800542:	b8 00 00 00 00       	mov    $0x0,%eax
  800547:	49 ba 32 13 80 00 00 	movabs $0x801332,%r10
  80054e:	00 00 00 
  800551:	41 ff d2             	callq  *%r10
  800554:	48 83 c4 10          	add    $0x10,%rsp
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
            inet_ntoa(ia));

    lwip_core_unlock();
  800558:	48 b8 ea 8b 81 00 00 	movabs $0x818bea,%rax
  80055f:	00 00 00 
  800562:	ff d0                	callq  *%rax

    cprintf("NS: TCP/IP initialized.\n");
  800564:	48 bf 01 0d 82 00 00 	movabs $0x820d01,%rdi
  80056b:	00 00 00 
  80056e:	b8 00 00 00 00       	mov    $0x0,%eax
  800573:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  80057a:	00 00 00 
  80057d:	ff d2                	callq  *%rdx
}
  80057f:	90                   	nop
  800580:	c9                   	leaveq 
  800581:	c3                   	retq   

0000000000800582 <process_timer>:

static void
process_timer(envid_t envid) {
  800582:	55                   	push   %rbp
  800583:	48 89 e5             	mov    %rsp,%rbp
  800586:	48 83 ec 20          	sub    $0x20,%rsp
  80058a:	89 7d ec             	mov    %edi,-0x14(%rbp)
    uint32_t start, now, to;

    if (envid != timer_envid) {
  80058d:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800594:	00 00 00 
  800597:	8b 00                	mov    (%rax),%eax
  800599:	39 45 ec             	cmp    %eax,-0x14(%rbp)
  80059c:	74 22                	je     8005c0 <process_timer+0x3e>
        cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  80059e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8005a1:	89 c6                	mov    %eax,%esi
  8005a3:	48 bf 20 0d 82 00 00 	movabs $0x820d20,%rdi
  8005aa:	00 00 00 
  8005ad:	b8 00 00 00 00       	mov    $0x0,%eax
  8005b2:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8005b9:	00 00 00 
  8005bc:	ff d2                	callq  *%rdx
        return;
  8005be:	eb 56                	jmp    800616 <process_timer+0x94>
    }

    start = sys_time_msec();
  8005c0:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  8005c7:	00 00 00 
  8005ca:	ff d0                	callq  *%rax
  8005cc:	89 45 fc             	mov    %eax,-0x4(%rbp)
    thread_yield();
  8005cf:	48 b8 66 92 81 00 00 	movabs $0x819266,%rax
  8005d6:	00 00 00 
  8005d9:	ff d0                	callq  *%rax
    now = sys_time_msec();
  8005db:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  8005e2:	00 00 00 
  8005e5:	ff d0                	callq  *%rax
  8005e7:	89 45 f8             	mov    %eax,-0x8(%rbp)

    to = TIMER_INTERVAL - (now - start);
  8005ea:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8005ed:	2b 45 f8             	sub    -0x8(%rbp),%eax
  8005f0:	05 fa 00 00 00       	add    $0xfa,%eax
  8005f5:	89 45 f4             	mov    %eax,-0xc(%rbp)
    ipc_send(envid, to, 0, 0);
  8005f8:	8b 75 f4             	mov    -0xc(%rbp),%esi
  8005fb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8005fe:	b9 00 00 00 00       	mov    $0x0,%ecx
  800603:	ba 00 00 00 00       	mov    $0x0,%edx
  800608:	89 c7                	mov    %eax,%edi
  80060a:	48 b8 c9 33 80 00 00 	movabs $0x8033c9,%rax
  800611:	00 00 00 
  800614:	ff d0                	callq  *%rax
}
  800616:	c9                   	leaveq 
  800617:	c3                   	retq   

0000000000800618 <serve_thread>:
    uint32_t whom;
    union Nsipc *req;
};

static void
serve_thread(uint64_t a) {
  800618:	55                   	push   %rbp
  800619:	48 89 e5             	mov    %rsp,%rbp
  80061c:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  800623:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
    struct st_args *args = (struct st_args *)a;
  80062a:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800631:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    union Nsipc *req = args->req;
  800635:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800639:	48 8b 40 08          	mov    0x8(%rax),%rax
  80063d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    int r;

    switch (args->reqno) {
  800641:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800645:	8b 00                	mov    (%rax),%eax
  800647:	83 f8 0a             	cmp    $0xa,%eax
  80064a:	0f 87 d8 01 00 00    	ja     800828 <serve_thread+0x210>
  800650:	89 c0                	mov    %eax,%eax
  800652:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800659:	00 
  80065a:	48 b8 98 0d 82 00 00 	movabs $0x820d98,%rax
  800661:	00 00 00 
  800664:	48 01 d0             	add    %rdx,%rax
  800667:	48 8b 00             	mov    (%rax),%rax
  80066a:	ff e0                	jmpq   *%rax
        case NSREQ_ACCEPT:
            {
                struct Nsret_accept ret;
                r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  80066c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800670:	8b 00                	mov    (%rax),%eax
  800672:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800676:	48 83 c2 10          	add    $0x10,%rdx
  80067a:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80067e:	48 89 ce             	mov    %rcx,%rsi
  800681:	89 c7                	mov    %eax,%edi
  800683:	48 b8 ee 5e 80 00 00 	movabs $0x805eee,%rax
  80068a:	00 00 00 
  80068d:	ff d0                	callq  *%rax
  80068f:	89 45 fc             	mov    %eax,-0x4(%rbp)
                        &ret.ret_addrlen);
                memmove(req, &ret, sizeof ret);
  800692:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800696:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80069a:	ba 14 00 00 00       	mov    $0x14,%edx
  80069f:	48 89 ce             	mov    %rcx,%rsi
  8006a2:	48 89 c7             	mov    %rax,%rdi
  8006a5:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  8006ac:	00 00 00 
  8006af:	ff d0                	callq  *%rax
                break;
  8006b1:	90                   	nop
  8006b2:	e9 a5 01 00 00       	jmpq   80085c <serve_thread+0x244>
            }
        case NSREQ_BIND:
            r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  8006b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006bb:	8b 50 14             	mov    0x14(%rax),%edx
  8006be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006c2:	48 8d 48 04          	lea    0x4(%rax),%rcx
  8006c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006ca:	8b 00                	mov    (%rax),%eax
  8006cc:	48 89 ce             	mov    %rcx,%rsi
  8006cf:	89 c7                	mov    %eax,%edi
  8006d1:	48 b8 1b 62 80 00 00 	movabs $0x80621b,%rax
  8006d8:	00 00 00 
  8006db:	ff d0                	callq  *%rax
  8006dd:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->bind.req_namelen);
            break;
  8006e0:	e9 77 01 00 00       	jmpq   80085c <serve_thread+0x244>
        case NSREQ_SHUTDOWN:
            r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  8006e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006e9:	8b 50 04             	mov    0x4(%rax),%edx
  8006ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006f0:	8b 00                	mov    (%rax),%eax
  8006f2:	89 d6                	mov    %edx,%esi
  8006f4:	89 c7                	mov    %eax,%edi
  8006f6:	48 b8 8c 79 80 00 00 	movabs $0x80798c,%rax
  8006fd:	00 00 00 
  800700:	ff d0                	callq  *%rax
  800702:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  800705:	e9 52 01 00 00       	jmpq   80085c <serve_thread+0x244>
        case NSREQ_CLOSE:
            r = lwip_close(req->close.req_s);
  80070a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80070e:	8b 00                	mov    (%rax),%eax
  800710:	89 c7                	mov    %eax,%edi
  800712:	48 b8 50 63 80 00 00 	movabs $0x806350,%rax
  800719:	00 00 00 
  80071c:	ff d0                	callq  *%rax
  80071e:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  800721:	e9 36 01 00 00       	jmpq   80085c <serve_thread+0x244>
        case NSREQ_CONNECT:
            r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  800726:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80072a:	8b 50 14             	mov    0x14(%rax),%edx
  80072d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800731:	48 8d 48 04          	lea    0x4(%rax),%rcx
  800735:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800739:	8b 00                	mov    (%rax),%eax
  80073b:	48 89 ce             	mov    %rcx,%rsi
  80073e:	89 c7                	mov    %eax,%edi
  800740:	48 b8 35 64 80 00 00 	movabs $0x806435,%rax
  800747:	00 00 00 
  80074a:	ff d0                	callq  *%rax
  80074c:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->connect.req_namelen);
            break;
  80074f:	e9 08 01 00 00       	jmpq   80085c <serve_thread+0x244>
        case NSREQ_LISTEN:
            r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  800754:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800758:	8b 50 04             	mov    0x4(%rax),%edx
  80075b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80075f:	8b 00                	mov    (%rax),%eax
  800761:	89 d6                	mov    %edx,%esi
  800763:	89 c7                	mov    %eax,%edi
  800765:	48 b8 91 65 80 00 00 	movabs $0x806591,%rax
  80076c:	00 00 00 
  80076f:	ff d0                	callq  *%rax
  800771:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  800774:	e9 e3 00 00 00       	jmpq   80085c <serve_thread+0x244>
        case NSREQ_RECV:
            // Note that we read the request fields before we
            // overwrite it with the response data.
            r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  800779:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80077d:	8b 48 08             	mov    0x8(%rax),%ecx
  800780:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800784:	8b 50 04             	mov    0x4(%rax),%edx
  800787:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  80078b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80078f:	8b 00                	mov    (%rax),%eax
  800791:	89 c7                	mov    %eax,%edi
  800793:	48 b8 8f 6a 80 00 00 	movabs $0x806a8f,%rax
  80079a:	00 00 00 
  80079d:	ff d0                	callq  *%rax
  80079f:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->recv.req_len, req->recv.req_flags);
            break;
  8007a2:	e9 b5 00 00 00       	jmpq   80085c <serve_thread+0x244>
        case NSREQ_SEND:
            r = lwip_send(req->send.req_s, &req->send.req_buf,
  8007a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007ab:	8b 48 08             	mov    0x8(%rax),%ecx
  8007ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007b2:	8b 50 04             	mov    0x4(%rax),%edx
  8007b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007b9:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  8007bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007c1:	8b 00                	mov    (%rax),%eax
  8007c3:	89 c7                	mov    %eax,%edi
  8007c5:	48 b8 cd 6a 80 00 00 	movabs $0x806acd,%rax
  8007cc:	00 00 00 
  8007cf:	ff d0                	callq  *%rax
  8007d1:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->send.req_size, req->send.req_flags);
            break;
  8007d4:	e9 83 00 00 00       	jmpq   80085c <serve_thread+0x244>
        case NSREQ_SOCKET:
            r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  8007d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007dd:	8b 50 08             	mov    0x8(%rax),%edx
  8007e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007e4:	8b 48 04             	mov    0x4(%rax),%ecx
  8007e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007eb:	8b 00                	mov    (%rax),%eax
  8007ed:	89 ce                	mov    %ecx,%esi
  8007ef:	89 c7                	mov    %eax,%edi
  8007f1:	48 b8 ed 6d 80 00 00 	movabs $0x806ded,%rax
  8007f8:	00 00 00 
  8007fb:	ff d0                	callq  *%rax
  8007fd:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->socket.req_protocol);
            break;
  800800:	eb 5a                	jmp    80085c <serve_thread+0x244>
        case NSREQ_INPUT:
            jif_input(&nif, (void *)&req->pkt);
  800802:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800806:	48 89 c6             	mov    %rax,%rsi
  800809:	48 bf 20 75 b5 00 00 	movabs $0xb57520,%rdi
  800810:	00 00 00 
  800813:	48 b8 8a 99 81 00 00 	movabs $0x81998a,%rax
  80081a:	00 00 00 
  80081d:	ff d0                	callq  *%rax
            r = 0;
  80081f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
            break;
  800826:	eb 34                	jmp    80085c <serve_thread+0x244>
        default:
            cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  800828:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80082c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800830:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800834:	8b 40 04             	mov    0x4(%rax),%eax
  800837:	89 c6                	mov    %eax,%esi
  800839:	48 bf 60 0d 82 00 00 	movabs $0x820d60,%rdi
  800840:	00 00 00 
  800843:	b8 00 00 00 00       	mov    $0x0,%eax
  800848:	48 b9 32 13 80 00 00 	movabs $0x801332,%rcx
  80084f:	00 00 00 
  800852:	ff d1                	callq  *%rcx
            r = -E_INVAL;
  800854:	c7 45 fc fd ff ff ff 	movl   $0xfffffffd,-0x4(%rbp)
            break;
  80085b:	90                   	nop
    }

    if (r == -1) {
  80085c:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800860:	75 49                	jne    8008ab <serve_thread+0x293>
        char buf[100];
        snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800862:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800866:	8b 10                	mov    (%rax),%edx
  800868:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
  80086f:	89 d1                	mov    %edx,%ecx
  800871:	48 ba 83 0d 82 00 00 	movabs $0x820d83,%rdx
  800878:	00 00 00 
  80087b:	be 64 00 00 00       	mov    $0x64,%esi
  800880:	48 89 c7             	mov    %rax,%rdi
  800883:	b8 00 00 00 00       	mov    $0x0,%eax
  800888:	49 b8 75 1d 80 00 00 	movabs $0x801d75,%r8
  80088f:	00 00 00 
  800892:	41 ff d0             	callq  *%r8
        perror(buf);
  800895:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
  80089c:	48 89 c7             	mov    %rax,%rdi
  80089f:	48 b8 22 96 81 00 00 	movabs $0x819622,%rax
  8008a6:	00 00 00 
  8008a9:	ff d0                	callq  *%rax
    }

    if (args->reqno != NSREQ_INPUT)
  8008ab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008af:	8b 00                	mov    (%rax),%eax
  8008b1:	83 f8 0a             	cmp    $0xa,%eax
  8008b4:	74 24                	je     8008da <serve_thread+0x2c2>
        ipc_send(args->whom, r, 0, 0);
  8008b6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8008b9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8008bd:	8b 52 04             	mov    0x4(%rdx),%edx
  8008c0:	89 d7                	mov    %edx,%edi
  8008c2:	b9 00 00 00 00       	mov    $0x0,%ecx
  8008c7:	ba 00 00 00 00       	mov    $0x0,%edx
  8008cc:	89 c6                	mov    %eax,%esi
  8008ce:	48 b8 c9 33 80 00 00 	movabs $0x8033c9,%rax
  8008d5:	00 00 00 
  8008d8:	ff d0                	callq  *%rax

    put_buffer(args->req);
  8008da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008de:	48 8b 40 08          	mov    0x8(%rax),%rax
  8008e2:	48 89 c7             	mov    %rax,%rdi
  8008e5:	48 b8 32 01 80 00 00 	movabs $0x800132,%rax
  8008ec:	00 00 00 
  8008ef:	ff d0                	callq  *%rax
    sys_page_unmap(0, (void*) args->req);
  8008f1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008f5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8008f9:	48 89 c6             	mov    %rax,%rsi
  8008fc:	bf 00 00 00 00       	mov    $0x0,%edi
  800901:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  800908:	00 00 00 
  80090b:	ff d0                	callq  *%rax
    free(args);
  80090d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800911:	48 89 c7             	mov    %rax,%rdi
  800914:	48 b8 1f 51 80 00 00 	movabs $0x80511f,%rax
  80091b:	00 00 00 
  80091e:	ff d0                	callq  *%rax
}
  800920:	90                   	nop
  800921:	c9                   	leaveq 
  800922:	c3                   	retq   

0000000000800923 <serve>:

void
serve(void) {
  800923:	55                   	push   %rbp
  800924:	48 89 e5             	mov    %rsp,%rbp
  800927:	48 83 ec 30          	sub    $0x30,%rsp

    while (1) {
        // ipc_recv will block the entire process, so we flush
        // all pending work from other threads.  We limit the
        // number of yields in case there's a rogue thread.
        for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80092b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800932:	eb 10                	jmp    800944 <serve+0x21>
            thread_yield();
  800934:	48 b8 66 92 81 00 00 	movabs $0x819266,%rax
  80093b:	00 00 00 
  80093e:	ff d0                	callq  *%rax

    while (1) {
        // ipc_recv will block the entire process, so we flush
        // all pending work from other threads.  We limit the
        // number of yields in case there's a rogue thread.
        for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800940:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800944:	48 b8 46 8e 81 00 00 	movabs $0x818e46,%rax
  80094b:	00 00 00 
  80094e:	ff d0                	callq  *%rax
  800950:	85 c0                	test   %eax,%eax
  800952:	74 06                	je     80095a <serve+0x37>
  800954:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  800958:	7e da                	jle    800934 <serve+0x11>
            thread_yield();

        perm = 0;
  80095a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
        va = get_buffer();
  800961:	48 b8 99 00 80 00 00 	movabs $0x800099,%rax
  800968:	00 00 00 
  80096b:	ff d0                	callq  *%rax
  80096d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800971:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  800975:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800979:	48 8d 45 dc          	lea    -0x24(%rbp),%rax
  80097d:	48 89 ce             	mov    %rcx,%rsi
  800980:	48 89 c7             	mov    %rax,%rdi
  800983:	48 b8 08 33 80 00 00 	movabs $0x803308,%rax
  80098a:	00 00 00 
  80098d:	ff d0                	callq  *%rax
  80098f:	89 45 ec             	mov    %eax,-0x14(%rbp)
        if (debug) {
            cprintf("ns req %d from %08x\n", reqno, whom);
        }

        // first take care of requests that do not contain an argument page
        if (reqno == NSREQ_TIMER) {
  800992:	83 7d ec 0c          	cmpl   $0xc,-0x14(%rbp)
  800996:	75 29                	jne    8009c1 <serve+0x9e>
            process_timer(whom);
  800998:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80099b:	89 c7                	mov    %eax,%edi
  80099d:	48 b8 82 05 80 00 00 	movabs $0x800582,%rax
  8009a4:	00 00 00 
  8009a7:	ff d0                	callq  *%rax
            put_buffer(va);
  8009a9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8009ad:	48 89 c7             	mov    %rax,%rdi
  8009b0:	48 b8 32 01 80 00 00 	movabs $0x800132,%rax
  8009b7:	00 00 00 
  8009ba:	ff d0                	callq  *%rax
            continue;
  8009bc:	e9 cc 00 00 00       	jmpq   800a8d <serve+0x16a>
        }

        // All remaining requests must contain an argument page
        if (!(perm & PTE_P)) {
  8009c1:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8009c4:	83 e0 01             	and    $0x1,%eax
  8009c7:	85 c0                	test   %eax,%eax
  8009c9:	75 25                	jne    8009f0 <serve+0xcd>
            cprintf("Invalid request from %08x: no argument page\n", whom);
  8009cb:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8009ce:	89 c6                	mov    %eax,%esi
  8009d0:	48 bf f0 0d 82 00 00 	movabs $0x820df0,%rdi
  8009d7:	00 00 00 
  8009da:	b8 00 00 00 00       	mov    $0x0,%eax
  8009df:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8009e6:	00 00 00 
  8009e9:	ff d2                	callq  *%rdx
            continue; // just leave it hanging...
  8009eb:	e9 9d 00 00 00       	jmpq   800a8d <serve+0x16a>
        }

        // Since some lwIP socket calls will block, create a thread and
        // process the rest of the request in the thread.
        struct st_args *args = malloc(sizeof(struct st_args));
  8009f0:	bf 10 00 00 00       	mov    $0x10,%edi
  8009f5:	48 b8 ae 4d 80 00 00 	movabs $0x804dae,%rax
  8009fc:	00 00 00 
  8009ff:	ff d0                	callq  *%rax
  800a01:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        if (!args)
  800a05:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800a0a:	75 2a                	jne    800a36 <serve+0x113>
            panic("could not allocate thread args structure");
  800a0c:	48 ba 20 0e 82 00 00 	movabs $0x820e20,%rdx
  800a13:	00 00 00 
  800a16:	be 27 01 00 00       	mov    $0x127,%esi
  800a1b:	48 bf 54 0c 82 00 00 	movabs $0x820c54,%rdi
  800a22:	00 00 00 
  800a25:	b8 00 00 00 00       	mov    $0x0,%eax
  800a2a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  800a31:	00 00 00 
  800a34:	ff d1                	callq  *%rcx

        args->reqno = reqno;
  800a36:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a3a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800a3d:	89 10                	mov    %edx,(%rax)
        args->whom = whom;
  800a3f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800a42:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a46:	89 50 04             	mov    %edx,0x4(%rax)
        args->req = va;
  800a49:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a4d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800a51:	48 89 50 08          	mov    %rdx,0x8(%rax)

        thread_create(0, "serve_thread", serve_thread, (uint64_t)args);
  800a55:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a59:	48 89 c1             	mov    %rax,%rcx
  800a5c:	48 ba 18 06 80 00 00 	movabs $0x800618,%rdx
  800a63:	00 00 00 
  800a66:	48 be 49 0e 82 00 00 	movabs $0x820e49,%rsi
  800a6d:	00 00 00 
  800a70:	bf 00 00 00 00       	mov    $0x0,%edi
  800a75:	48 b8 df 8f 81 00 00 	movabs $0x818fdf,%rax
  800a7c:	00 00 00 
  800a7f:	ff d0                	callq  *%rax
        thread_yield(); // let the thread created run
  800a81:	48 b8 66 92 81 00 00 	movabs $0x819266,%rax
  800a88:	00 00 00 
  800a8b:	ff d0                	callq  *%rax
    }
  800a8d:	e9 99 fe ff ff       	jmpq   80092b <serve+0x8>

0000000000800a92 <tmain>:
}

static void
tmain(uint64_t arg) {
  800a92:	55                   	push   %rbp
  800a93:	48 89 e5             	mov    %rsp,%rbp
  800a96:	41 54                	push   %r12
  800a98:	53                   	push   %rbx
  800a99:	48 83 ec 10          	sub    $0x10,%rsp
  800a9d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    serve_init(inet_addr(IP),
  800aa1:	48 bf 56 0e 82 00 00 	movabs $0x820e56,%rdi
  800aa8:	00 00 00 
  800aab:	48 b8 4d 2c 81 00 00 	movabs $0x812c4d,%rax
  800ab2:	00 00 00 
  800ab5:	ff d0                	callq  *%rax
  800ab7:	41 89 c4             	mov    %eax,%r12d
  800aba:	48 bf 5f 0e 82 00 00 	movabs $0x820e5f,%rdi
  800ac1:	00 00 00 
  800ac4:	48 b8 4d 2c 81 00 00 	movabs $0x812c4d,%rax
  800acb:	00 00 00 
  800ace:	ff d0                	callq  *%rax
  800ad0:	89 c3                	mov    %eax,%ebx
  800ad2:	48 bf 6d 0e 82 00 00 	movabs $0x820e6d,%rdi
  800ad9:	00 00 00 
  800adc:	48 b8 4d 2c 81 00 00 	movabs $0x812c4d,%rax
  800ae3:	00 00 00 
  800ae6:	ff d0                	callq  *%rax
  800ae8:	44 89 e2             	mov    %r12d,%edx
  800aeb:	89 de                	mov    %ebx,%esi
  800aed:	89 c7                	mov    %eax,%edi
  800aef:	48 b8 79 03 80 00 00 	movabs $0x800379,%rax
  800af6:	00 00 00 
  800af9:	ff d0                	callq  *%rax
            inet_addr(MASK),
            inet_addr(DEFAULT));
    serve();
  800afb:	48 b8 23 09 80 00 00 	movabs $0x800923,%rax
  800b02:	00 00 00 
  800b05:	ff d0                	callq  *%rax
}
  800b07:	90                   	nop
  800b08:	48 83 c4 10          	add    $0x10,%rsp
  800b0c:	5b                   	pop    %rbx
  800b0d:	41 5c                	pop    %r12
  800b0f:	5d                   	pop    %rbp
  800b10:	c3                   	retq   

0000000000800b11 <umain>:

    void
umain(int argc, char **argv)
{
  800b11:	55                   	push   %rbp
  800b12:	48 89 e5             	mov    %rsp,%rbp
  800b15:	48 83 ec 20          	sub    $0x20,%rsp
  800b19:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800b1c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    envid_t ns_envid = sys_getenvid();
  800b20:	48 b8 7f 27 80 00 00 	movabs $0x80277f,%rax
  800b27:	00 00 00 
  800b2a:	ff d0                	callq  *%rax
  800b2c:	89 45 fc             	mov    %eax,-0x4(%rbp)

    binaryname = "ns";
  800b2f:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800b36:	00 00 00 
  800b39:	48 be 77 0e 82 00 00 	movabs $0x820e77,%rsi
  800b40:	00 00 00 
  800b43:	48 89 30             	mov    %rsi,(%rax)

    // fork off the timer thread which will send us periodic messages
    timer_envid = fork();
  800b46:	48 b8 91 30 80 00 00 	movabs $0x803091,%rax
  800b4d:	00 00 00 
  800b50:	ff d0                	callq  *%rax
  800b52:	89 c2                	mov    %eax,%edx
  800b54:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800b5b:	00 00 00 
  800b5e:	89 10                	mov    %edx,(%rax)
    if (timer_envid < 0)
  800b60:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800b67:	00 00 00 
  800b6a:	8b 00                	mov    (%rax),%eax
  800b6c:	85 c0                	test   %eax,%eax
  800b6e:	79 2a                	jns    800b9a <umain+0x89>
        panic("error forking");
  800b70:	48 ba 7a 0e 82 00 00 	movabs $0x820e7a,%rdx
  800b77:	00 00 00 
  800b7a:	be 44 01 00 00       	mov    $0x144,%esi
  800b7f:	48 bf 54 0c 82 00 00 	movabs $0x820c54,%rdi
  800b86:	00 00 00 
  800b89:	b8 00 00 00 00       	mov    $0x0,%eax
  800b8e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  800b95:	00 00 00 
  800b98:	ff d1                	callq  *%rcx
    else if (timer_envid == 0) {
  800b9a:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800ba1:	00 00 00 
  800ba4:	8b 00                	mov    (%rax),%eax
  800ba6:	85 c0                	test   %eax,%eax
  800ba8:	75 1b                	jne    800bc5 <umain+0xb4>
        timer(ns_envid, TIMER_INTERVAL);
  800baa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800bad:	be fa 00 00 00       	mov    $0xfa,%esi
  800bb2:	89 c7                	mov    %eax,%edi
  800bb4:	48 b8 fa 0c 80 00 00 	movabs $0x800cfa,%rax
  800bbb:	00 00 00 
  800bbe:	ff d0                	callq  *%rax
        return;
  800bc0:	e9 33 01 00 00       	jmpq   800cf8 <umain+0x1e7>
    }

    // fork off the input thread which will poll the NIC driver for input
    // packets
    input_envid = fork();
  800bc5:	48 b8 91 30 80 00 00 	movabs $0x803091,%rax
  800bcc:	00 00 00 
  800bcf:	ff d0                	callq  *%rax
  800bd1:	89 c2                	mov    %eax,%edx
  800bd3:	48 b8 5c 90 82 00 00 	movabs $0x82905c,%rax
  800bda:	00 00 00 
  800bdd:	89 10                	mov    %edx,(%rax)
    if (input_envid < 0)
  800bdf:	48 b8 5c 90 82 00 00 	movabs $0x82905c,%rax
  800be6:	00 00 00 
  800be9:	8b 00                	mov    (%rax),%eax
  800beb:	85 c0                	test   %eax,%eax
  800bed:	79 2a                	jns    800c19 <umain+0x108>
        panic("error forking");
  800bef:	48 ba 7a 0e 82 00 00 	movabs $0x820e7a,%rdx
  800bf6:	00 00 00 
  800bf9:	be 4e 01 00 00       	mov    $0x14e,%esi
  800bfe:	48 bf 54 0c 82 00 00 	movabs $0x820c54,%rdi
  800c05:	00 00 00 
  800c08:	b8 00 00 00 00       	mov    $0x0,%eax
  800c0d:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  800c14:	00 00 00 
  800c17:	ff d1                	callq  *%rcx
    else if (input_envid == 0) {
  800c19:	48 b8 5c 90 82 00 00 	movabs $0x82905c,%rax
  800c20:	00 00 00 
  800c23:	8b 00                	mov    (%rax),%eax
  800c25:	85 c0                	test   %eax,%eax
  800c27:	75 16                	jne    800c3f <umain+0x12e>
        input(ns_envid);
  800c29:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800c2c:	89 c7                	mov    %eax,%edi
  800c2e:	48 b8 1d 0e 80 00 00 	movabs $0x800e1d,%rax
  800c35:	00 00 00 
  800c38:	ff d0                	callq  *%rax
        return;
  800c3a:	e9 b9 00 00 00       	jmpq   800cf8 <umain+0x1e7>
    }

    // fork off the output thread that will send the packets to the NIC
    // driver
    output_envid = fork();
  800c3f:	48 b8 91 30 80 00 00 	movabs $0x803091,%rax
  800c46:	00 00 00 
  800c49:	ff d0                	callq  *%rax
  800c4b:	89 c2                	mov    %eax,%edx
  800c4d:	48 b8 60 90 82 00 00 	movabs $0x829060,%rax
  800c54:	00 00 00 
  800c57:	89 10                	mov    %edx,(%rax)
    if (output_envid < 0)
  800c59:	48 b8 60 90 82 00 00 	movabs $0x829060,%rax
  800c60:	00 00 00 
  800c63:	8b 00                	mov    (%rax),%eax
  800c65:	85 c0                	test   %eax,%eax
  800c67:	79 2a                	jns    800c93 <umain+0x182>
        panic("error forking");
  800c69:	48 ba 7a 0e 82 00 00 	movabs $0x820e7a,%rdx
  800c70:	00 00 00 
  800c73:	be 58 01 00 00       	mov    $0x158,%esi
  800c78:	48 bf 54 0c 82 00 00 	movabs $0x820c54,%rdi
  800c7f:	00 00 00 
  800c82:	b8 00 00 00 00       	mov    $0x0,%eax
  800c87:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  800c8e:	00 00 00 
  800c91:	ff d1                	callq  *%rcx
    else if (output_envid == 0) {
  800c93:	48 b8 60 90 82 00 00 	movabs $0x829060,%rax
  800c9a:	00 00 00 
  800c9d:	8b 00                	mov    (%rax),%eax
  800c9f:	85 c0                	test   %eax,%eax
  800ca1:	75 13                	jne    800cb6 <umain+0x1a5>
        output(ns_envid);
  800ca3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800ca6:	89 c7                	mov    %eax,%edi
  800ca8:	48 b8 3b 0f 80 00 00 	movabs $0x800f3b,%rax
  800caf:	00 00 00 
  800cb2:	ff d0                	callq  *%rax
        return;
  800cb4:	eb 42                	jmp    800cf8 <umain+0x1e7>
    }

    // lwIP requires a user threading library; start the library and jump
    // into a thread to continue initialization.
    thread_init();
  800cb6:	48 b8 ce 8c 81 00 00 	movabs $0x818cce,%rax
  800cbd:	00 00 00 
  800cc0:	ff d0                	callq  *%rax
    thread_create(0, "main", tmain, 0);
  800cc2:	b9 00 00 00 00       	mov    $0x0,%ecx
  800cc7:	48 ba 92 0a 80 00 00 	movabs $0x800a92,%rdx
  800cce:	00 00 00 
  800cd1:	48 be 88 0e 82 00 00 	movabs $0x820e88,%rsi
  800cd8:	00 00 00 
  800cdb:	bf 00 00 00 00       	mov    $0x0,%edi
  800ce0:	48 b8 df 8f 81 00 00 	movabs $0x818fdf,%rax
  800ce7:	00 00 00 
  800cea:	ff d0                	callq  *%rax
    thread_yield();
  800cec:	48 b8 66 92 81 00 00 	movabs $0x819266,%rax
  800cf3:	00 00 00 
  800cf6:	ff d0                	callq  *%rax
    // never coming here!
}
  800cf8:	c9                   	leaveq 
  800cf9:	c3                   	retq   

0000000000800cfa <timer>:

#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800cfa:	55                   	push   %rbp
  800cfb:	48 89 e5             	mov    %rsp,%rbp
  800cfe:	48 83 ec 20          	sub    $0x20,%rsp
  800d02:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800d05:	89 75 e8             	mov    %esi,-0x18(%rbp)
    int r;
    uint32_t stop = sys_time_msec() + initial_to;
  800d08:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  800d0f:	00 00 00 
  800d12:	ff d0                	callq  *%rax
  800d14:	89 c2                	mov    %eax,%edx
  800d16:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800d19:	01 d0                	add    %edx,%eax
  800d1b:	89 45 fc             	mov    %eax,-0x4(%rbp)

    binaryname = "ns_timer";
  800d1e:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800d25:	00 00 00 
  800d28:	48 b9 90 0e 82 00 00 	movabs $0x820e90,%rcx
  800d2f:	00 00 00 
  800d32:	48 89 08             	mov    %rcx,(%rax)

    while (1) {
        while((r = sys_time_msec()) < stop && r >= 0) {
  800d35:	eb 0c                	jmp    800d43 <timer+0x49>
            sys_yield();
  800d37:	48 b8 bb 27 80 00 00 	movabs $0x8027bb,%rax
  800d3e:	00 00 00 
  800d41:	ff d0                	callq  *%rax
    uint32_t stop = sys_time_msec() + initial_to;

    binaryname = "ns_timer";

    while (1) {
        while((r = sys_time_msec()) < stop && r >= 0) {
  800d43:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  800d4a:	00 00 00 
  800d4d:	ff d0                	callq  *%rax
  800d4f:	89 45 f8             	mov    %eax,-0x8(%rbp)
  800d52:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800d55:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800d58:	73 06                	jae    800d60 <timer+0x66>
  800d5a:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800d5e:	79 d7                	jns    800d37 <timer+0x3d>
            sys_yield();
        }
        if (r < 0)
  800d60:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800d64:	79 30                	jns    800d96 <timer+0x9c>
            panic("sys_time_msec: %e", r);
  800d66:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800d69:	89 c1                	mov    %eax,%ecx
  800d6b:	48 ba 99 0e 82 00 00 	movabs $0x820e99,%rdx
  800d72:	00 00 00 
  800d75:	be 10 00 00 00       	mov    $0x10,%esi
  800d7a:	48 bf ab 0e 82 00 00 	movabs $0x820eab,%rdi
  800d81:	00 00 00 
  800d84:	b8 00 00 00 00       	mov    $0x0,%eax
  800d89:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  800d90:	00 00 00 
  800d93:	41 ff d0             	callq  *%r8

        ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  800d96:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800d99:	b9 00 00 00 00       	mov    $0x0,%ecx
  800d9e:	ba 00 00 00 00       	mov    $0x0,%edx
  800da3:	be 0c 00 00 00       	mov    $0xc,%esi
  800da8:	89 c7                	mov    %eax,%edi
  800daa:	48 b8 c9 33 80 00 00 	movabs $0x8033c9,%rax
  800db1:	00 00 00 
  800db4:	ff d0                	callq  *%rax

        while (1) {
            uint32_t to, whom;
            to = ipc_recv((int32_t *) &whom, 0, 0);
  800db6:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  800dba:	ba 00 00 00 00       	mov    $0x0,%edx
  800dbf:	be 00 00 00 00       	mov    $0x0,%esi
  800dc4:	48 89 c7             	mov    %rax,%rdi
  800dc7:	48 b8 08 33 80 00 00 	movabs $0x803308,%rax
  800dce:	00 00 00 
  800dd1:	ff d0                	callq  *%rax
  800dd3:	89 45 f4             	mov    %eax,-0xc(%rbp)

            if (whom != ns_envid) {
  800dd6:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800dd9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800ddc:	39 c2                	cmp    %eax,%edx
  800dde:	74 22                	je     800e02 <timer+0x108>
                cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  800de0:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800de3:	89 c6                	mov    %eax,%esi
  800de5:	48 bf b8 0e 82 00 00 	movabs $0x820eb8,%rdi
  800dec:	00 00 00 
  800def:	b8 00 00 00 00       	mov    $0x0,%eax
  800df4:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  800dfb:	00 00 00 
  800dfe:	ff d2                	callq  *%rdx
                continue;
            }

            stop = sys_time_msec() + to;
            break;
        }
  800e00:	eb b4                	jmp    800db6 <timer+0xbc>
            if (whom != ns_envid) {
                cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
                continue;
            }

            stop = sys_time_msec() + to;
  800e02:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  800e09:	00 00 00 
  800e0c:	ff d0                	callq  *%rax
  800e0e:	89 c2                	mov    %eax,%edx
  800e10:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800e13:	01 d0                	add    %edx,%eax
  800e15:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
        }
    }
  800e18:	e9 18 ff ff ff       	jmpq   800d35 <timer+0x3b>

0000000000800e1d <input>:

extern union Nsipc nsipcbuf;

    void
input(envid_t ns_envid)
{
  800e1d:	55                   	push   %rbp
  800e1e:	48 89 e5             	mov    %rsp,%rbp
  800e21:	48 83 ec 20          	sub    $0x20,%rsp
  800e25:	89 7d ec             	mov    %edi,-0x14(%rbp)
    binaryname = "ns_input";
  800e28:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800e2f:	00 00 00 
  800e32:	48 b9 f3 0e 82 00 00 	movabs $0x820ef3,%rcx
  800e39:	00 00 00 
  800e3c:	48 89 08             	mov    %rcx,(%rax)

    while (1) {
        int r;
        if ((r = sys_page_alloc(0, &nsipcbuf, PTE_P|PTE_U|PTE_W)) < 0)
  800e3f:	ba 07 00 00 00       	mov    $0x7,%edx
  800e44:	48 be 00 a0 b5 00 00 	movabs $0xb5a000,%rsi
  800e4b:	00 00 00 
  800e4e:	bf 00 00 00 00       	mov    $0x0,%edi
  800e53:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  800e5a:	00 00 00 
  800e5d:	ff d0                	callq  *%rax
  800e5f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800e62:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800e66:	79 30                	jns    800e98 <input+0x7b>
            panic("sys_page_alloc: %e", r);
  800e68:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800e6b:	89 c1                	mov    %eax,%ecx
  800e6d:	48 ba fc 0e 82 00 00 	movabs $0x820efc,%rdx
  800e74:	00 00 00 
  800e77:	be 0e 00 00 00       	mov    $0xe,%esi
  800e7c:	48 bf 0f 0f 82 00 00 	movabs $0x820f0f,%rdi
  800e83:	00 00 00 
  800e86:	b8 00 00 00 00       	mov    $0x0,%eax
  800e8b:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  800e92:	00 00 00 
  800e95:	41 ff d0             	callq  *%r8
        r = sys_net_receive(nsipcbuf.pkt.jp_data, 1518);
  800e98:	be ee 05 00 00       	mov    $0x5ee,%esi
  800e9d:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  800ea4:	00 00 00 
  800ea7:	48 b8 fe 2a 80 00 00 	movabs $0x802afe,%rax
  800eae:	00 00 00 
  800eb1:	ff d0                	callq  *%rax
  800eb3:	89 45 fc             	mov    %eax,-0x4(%rbp)
        if (r == 0) {
  800eb6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800eba:	75 11                	jne    800ecd <input+0xb0>
            sys_yield();
  800ebc:	48 b8 bb 27 80 00 00 	movabs $0x8027bb,%rax
  800ec3:	00 00 00 
  800ec6:	ff d0                	callq  *%rax
  800ec8:	e9 72 ff ff ff       	jmpq   800e3f <input+0x22>
        } else if (r < 0) {
  800ecd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800ed1:	79 25                	jns    800ef8 <input+0xdb>
            cprintf("Failed to receive packet: %e\n", r);
  800ed3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800ed6:	89 c6                	mov    %eax,%esi
  800ed8:	48 bf 1b 0f 82 00 00 	movabs $0x820f1b,%rdi
  800edf:	00 00 00 
  800ee2:	b8 00 00 00 00       	mov    $0x0,%eax
  800ee7:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  800eee:	00 00 00 
  800ef1:	ff d2                	callq  *%rdx
  800ef3:	e9 47 ff ff ff       	jmpq   800e3f <input+0x22>
        } else if (r > 0) {
  800ef8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800efc:	0f 8e 3d ff ff ff    	jle    800e3f <input+0x22>
            nsipcbuf.pkt.jp_len = r;
  800f02:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  800f09:	00 00 00 
  800f0c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800f0f:	89 10                	mov    %edx,(%rax)
            ipc_send(ns_envid, NSREQ_INPUT, &nsipcbuf, PTE_U|PTE_P);
  800f11:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800f14:	b9 05 00 00 00       	mov    $0x5,%ecx
  800f19:	48 ba 00 a0 b5 00 00 	movabs $0xb5a000,%rdx
  800f20:	00 00 00 
  800f23:	be 0a 00 00 00       	mov    $0xa,%esi
  800f28:	89 c7                	mov    %eax,%edi
  800f2a:	48 b8 c9 33 80 00 00 	movabs $0x8033c9,%rax
  800f31:	00 00 00 
  800f34:	ff d0                	callq  *%rax
        }
    }
  800f36:	e9 04 ff ff ff       	jmpq   800e3f <input+0x22>

0000000000800f3b <output>:

extern union Nsipc nsipcbuf;

    void
output(envid_t ns_envid)
{
  800f3b:	55                   	push   %rbp
  800f3c:	48 89 e5             	mov    %rsp,%rbp
  800f3f:	48 83 ec 20          	sub    $0x20,%rsp
  800f43:	89 7d ec             	mov    %edi,-0x14(%rbp)
    binaryname = "ns_output";
  800f46:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800f4d:	00 00 00 
  800f50:	48 b9 40 0f 82 00 00 	movabs $0x820f40,%rcx
  800f57:	00 00 00 
  800f5a:	48 89 08             	mov    %rcx,(%rax)

    int r;

    while (1) {
        int32_t req, whom;
        req = ipc_recv(&whom, &nsipcbuf, NULL);
  800f5d:	48 8d 45 f4          	lea    -0xc(%rbp),%rax
  800f61:	ba 00 00 00 00       	mov    $0x0,%edx
  800f66:	48 be 00 a0 b5 00 00 	movabs $0xb5a000,%rsi
  800f6d:	00 00 00 
  800f70:	48 89 c7             	mov    %rax,%rdi
  800f73:	48 b8 08 33 80 00 00 	movabs $0x803308,%rax
  800f7a:	00 00 00 
  800f7d:	ff d0                	callq  *%rax
  800f7f:	89 45 fc             	mov    %eax,-0x4(%rbp)
        assert(whom == ns_envid);
  800f82:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800f85:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800f88:	74 35                	je     800fbf <output+0x84>
  800f8a:	48 b9 4a 0f 82 00 00 	movabs $0x820f4a,%rcx
  800f91:	00 00 00 
  800f94:	48 ba 5b 0f 82 00 00 	movabs $0x820f5b,%rdx
  800f9b:	00 00 00 
  800f9e:	be 11 00 00 00       	mov    $0x11,%esi
  800fa3:	48 bf 70 0f 82 00 00 	movabs $0x820f70,%rdi
  800faa:	00 00 00 
  800fad:	b8 00 00 00 00       	mov    $0x0,%eax
  800fb2:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  800fb9:	00 00 00 
  800fbc:	41 ff d0             	callq  *%r8
        assert(req == NSREQ_OUTPUT);
  800fbf:	83 7d fc 0b          	cmpl   $0xb,-0x4(%rbp)
  800fc3:	74 35                	je     800ffa <output+0xbf>
  800fc5:	48 b9 7d 0f 82 00 00 	movabs $0x820f7d,%rcx
  800fcc:	00 00 00 
  800fcf:	48 ba 5b 0f 82 00 00 	movabs $0x820f5b,%rdx
  800fd6:	00 00 00 
  800fd9:	be 12 00 00 00       	mov    $0x12,%esi
  800fde:	48 bf 70 0f 82 00 00 	movabs $0x820f70,%rdi
  800fe5:	00 00 00 
  800fe8:	b8 00 00 00 00       	mov    $0x0,%eax
  800fed:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  800ff4:	00 00 00 
  800ff7:	41 ff d0             	callq  *%r8
        if ((r = sys_net_transmit(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len)) < 0)
  800ffa:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  801001:	00 00 00 
  801004:	8b 00                	mov    (%rax),%eax
  801006:	89 c6                	mov    %eax,%esi
  801008:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  80100f:	00 00 00 
  801012:	48 b8 b4 2a 80 00 00 	movabs $0x802ab4,%rax
  801019:	00 00 00 
  80101c:	ff d0                	callq  *%rax
  80101e:	89 45 f8             	mov    %eax,-0x8(%rbp)
  801021:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  801025:	0f 89 32 ff ff ff    	jns    800f5d <output+0x22>
            cprintf("Failed to transmit packet: %e\n", r);
  80102b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80102e:	89 c6                	mov    %eax,%esi
  801030:	48 bf 98 0f 82 00 00 	movabs $0x820f98,%rdi
  801037:	00 00 00 
  80103a:	b8 00 00 00 00       	mov    $0x0,%eax
  80103f:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  801046:	00 00 00 
  801049:	ff d2                	callq  *%rdx
    }
  80104b:	e9 0d ff ff ff       	jmpq   800f5d <output+0x22>

0000000000801050 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  801050:	55                   	push   %rbp
  801051:	48 89 e5             	mov    %rsp,%rbp
  801054:	48 83 ec 10          	sub    $0x10,%rsp
  801058:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80105b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// set thisenv to point at our Env structure in envs[].

	thisenv = &envs[ENVX(sys_getenvid())];
  80105f:	48 b8 7f 27 80 00 00 	movabs $0x80277f,%rax
  801066:	00 00 00 
  801069:	ff d0                	callq  *%rax
  80106b:	25 ff 03 00 00       	and    $0x3ff,%eax
  801070:	48 98                	cltq   
  801072:	48 69 d0 68 01 00 00 	imul   $0x168,%rax,%rdx
  801079:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  801080:	00 00 00 
  801083:	48 01 c2             	add    %rax,%rdx
  801086:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  80108d:	00 00 00 
  801090:	48 89 10             	mov    %rdx,(%rax)


	// save the name of the program so that panic() can use it
	if (argc > 0)
  801093:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  801097:	7e 14                	jle    8010ad <libmain+0x5d>
		binaryname = argv[0];
  801099:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80109d:	48 8b 10             	mov    (%rax),%rdx
  8010a0:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  8010a7:	00 00 00 
  8010aa:	48 89 10             	mov    %rdx,(%rax)

	// call user main routine
	umain(argc, argv);
  8010ad:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8010b1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8010b4:	48 89 d6             	mov    %rdx,%rsi
  8010b7:	89 c7                	mov    %eax,%edi
  8010b9:	48 b8 11 0b 80 00 00 	movabs $0x800b11,%rax
  8010c0:	00 00 00 
  8010c3:	ff d0                	callq  *%rax

	// exit gracefully
	exit();
  8010c5:	48 b8 d4 10 80 00 00 	movabs $0x8010d4,%rax
  8010cc:	00 00 00 
  8010cf:	ff d0                	callq  *%rax
}
  8010d1:	90                   	nop
  8010d2:	c9                   	leaveq 
  8010d3:	c3                   	retq   

00000000008010d4 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  8010d4:	55                   	push   %rbp
  8010d5:	48 89 e5             	mov    %rsp,%rbp

	close_all();
  8010d8:	48 b8 12 38 80 00 00 	movabs $0x803812,%rax
  8010df:	00 00 00 
  8010e2:	ff d0                	callq  *%rax

	sys_env_destroy(0);
  8010e4:	bf 00 00 00 00       	mov    $0x0,%edi
  8010e9:	48 b8 39 27 80 00 00 	movabs $0x802739,%rax
  8010f0:	00 00 00 
  8010f3:	ff d0                	callq  *%rax
}
  8010f5:	90                   	nop
  8010f6:	5d                   	pop    %rbp
  8010f7:	c3                   	retq   

00000000008010f8 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  8010f8:	55                   	push   %rbp
  8010f9:	48 89 e5             	mov    %rsp,%rbp
  8010fc:	53                   	push   %rbx
  8010fd:	48 81 ec f8 00 00 00 	sub    $0xf8,%rsp
  801104:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  80110b:	89 b5 14 ff ff ff    	mov    %esi,-0xec(%rbp)
  801111:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  801118:	48 89 8d 58 ff ff ff 	mov    %rcx,-0xa8(%rbp)
  80111f:	4c 89 85 60 ff ff ff 	mov    %r8,-0xa0(%rbp)
  801126:	4c 89 8d 68 ff ff ff 	mov    %r9,-0x98(%rbp)
  80112d:	84 c0                	test   %al,%al
  80112f:	74 23                	je     801154 <_panic+0x5c>
  801131:	0f 29 85 70 ff ff ff 	movaps %xmm0,-0x90(%rbp)
  801138:	0f 29 4d 80          	movaps %xmm1,-0x80(%rbp)
  80113c:	0f 29 55 90          	movaps %xmm2,-0x70(%rbp)
  801140:	0f 29 5d a0          	movaps %xmm3,-0x60(%rbp)
  801144:	0f 29 65 b0          	movaps %xmm4,-0x50(%rbp)
  801148:	0f 29 6d c0          	movaps %xmm5,-0x40(%rbp)
  80114c:	0f 29 75 d0          	movaps %xmm6,-0x30(%rbp)
  801150:	0f 29 7d e0          	movaps %xmm7,-0x20(%rbp)
	va_list ap;

	va_start(ap, fmt);
  801154:	c7 85 28 ff ff ff 18 	movl   $0x18,-0xd8(%rbp)
  80115b:	00 00 00 
  80115e:	c7 85 2c ff ff ff 30 	movl   $0x30,-0xd4(%rbp)
  801165:	00 00 00 
  801168:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80116c:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  801173:	48 8d 85 40 ff ff ff 	lea    -0xc0(%rbp),%rax
  80117a:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  801181:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  801188:	00 00 00 
  80118b:	48 8b 18             	mov    (%rax),%rbx
  80118e:	48 b8 7f 27 80 00 00 	movabs $0x80277f,%rax
  801195:	00 00 00 
  801198:	ff d0                	callq  *%rax
  80119a:	89 c6                	mov    %eax,%esi
  80119c:	8b 95 14 ff ff ff    	mov    -0xec(%rbp),%edx
  8011a2:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8011a9:	41 89 d0             	mov    %edx,%r8d
  8011ac:	48 89 c1             	mov    %rax,%rcx
  8011af:	48 89 da             	mov    %rbx,%rdx
  8011b2:	48 bf c8 0f 82 00 00 	movabs $0x820fc8,%rdi
  8011b9:	00 00 00 
  8011bc:	b8 00 00 00 00       	mov    $0x0,%eax
  8011c1:	49 b9 32 13 80 00 00 	movabs $0x801332,%r9
  8011c8:	00 00 00 
  8011cb:	41 ff d1             	callq  *%r9
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  8011ce:	48 8d 95 28 ff ff ff 	lea    -0xd8(%rbp),%rdx
  8011d5:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8011dc:	48 89 d6             	mov    %rdx,%rsi
  8011df:	48 89 c7             	mov    %rax,%rdi
  8011e2:	48 b8 86 12 80 00 00 	movabs $0x801286,%rax
  8011e9:	00 00 00 
  8011ec:	ff d0                	callq  *%rax
	cprintf("\n");
  8011ee:	48 bf eb 0f 82 00 00 	movabs $0x820feb,%rdi
  8011f5:	00 00 00 
  8011f8:	b8 00 00 00 00       	mov    $0x0,%eax
  8011fd:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  801204:	00 00 00 
  801207:	ff d2                	callq  *%rdx

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  801209:	cc                   	int3   
  80120a:	eb fd                	jmp    801209 <_panic+0x111>

000000000080120c <putch>:
};


    static void
putch(int ch, struct printbuf *b)
{
  80120c:	55                   	push   %rbp
  80120d:	48 89 e5             	mov    %rsp,%rbp
  801210:	48 83 ec 10          	sub    $0x10,%rsp
  801214:	89 7d fc             	mov    %edi,-0x4(%rbp)
  801217:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    b->buf[b->idx++] = ch;
  80121b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80121f:	8b 00                	mov    (%rax),%eax
  801221:	8d 48 01             	lea    0x1(%rax),%ecx
  801224:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801228:	89 0a                	mov    %ecx,(%rdx)
  80122a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80122d:	89 d1                	mov    %edx,%ecx
  80122f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801233:	48 98                	cltq   
  801235:	88 4c 02 08          	mov    %cl,0x8(%rdx,%rax,1)
    if (b->idx == 256-1) {
  801239:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80123d:	8b 00                	mov    (%rax),%eax
  80123f:	3d ff 00 00 00       	cmp    $0xff,%eax
  801244:	75 2c                	jne    801272 <putch+0x66>
        sys_cputs(b->buf, b->idx);
  801246:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80124a:	8b 00                	mov    (%rax),%eax
  80124c:	48 98                	cltq   
  80124e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801252:	48 83 c2 08          	add    $0x8,%rdx
  801256:	48 89 c6             	mov    %rax,%rsi
  801259:	48 89 d7             	mov    %rdx,%rdi
  80125c:	48 b8 b0 26 80 00 00 	movabs $0x8026b0,%rax
  801263:	00 00 00 
  801266:	ff d0                	callq  *%rax
        b->idx = 0;
  801268:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80126c:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
    }
    b->cnt++;
  801272:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801276:	8b 40 04             	mov    0x4(%rax),%eax
  801279:	8d 50 01             	lea    0x1(%rax),%edx
  80127c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801280:	89 50 04             	mov    %edx,0x4(%rax)
}
  801283:	90                   	nop
  801284:	c9                   	leaveq 
  801285:	c3                   	retq   

0000000000801286 <vcprintf>:

    int
vcprintf(const char *fmt, va_list ap)
{
  801286:	55                   	push   %rbp
  801287:	48 89 e5             	mov    %rsp,%rbp
  80128a:	48 81 ec 40 01 00 00 	sub    $0x140,%rsp
  801291:	48 89 bd c8 fe ff ff 	mov    %rdi,-0x138(%rbp)
  801298:	48 89 b5 c0 fe ff ff 	mov    %rsi,-0x140(%rbp)
    struct printbuf b;
    va_list aq;
    va_copy(aq,ap);
  80129f:	48 8d 85 d8 fe ff ff 	lea    -0x128(%rbp),%rax
  8012a6:	48 8b 95 c0 fe ff ff 	mov    -0x140(%rbp),%rdx
  8012ad:	48 8b 0a             	mov    (%rdx),%rcx
  8012b0:	48 89 08             	mov    %rcx,(%rax)
  8012b3:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8012b7:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8012bb:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8012bf:	48 89 50 10          	mov    %rdx,0x10(%rax)
    b.idx = 0;
  8012c3:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%rbp)
  8012ca:	00 00 00 
    b.cnt = 0;
  8012cd:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%rbp)
  8012d4:	00 00 00 
    vprintfmt((void*)putch, &b, fmt, aq);
  8012d7:	48 8d 8d d8 fe ff ff 	lea    -0x128(%rbp),%rcx
  8012de:	48 8b 95 c8 fe ff ff 	mov    -0x138(%rbp),%rdx
  8012e5:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  8012ec:	48 89 c6             	mov    %rax,%rsi
  8012ef:	48 bf 0c 12 80 00 00 	movabs $0x80120c,%rdi
  8012f6:	00 00 00 
  8012f9:	48 b8 d0 16 80 00 00 	movabs $0x8016d0,%rax
  801300:	00 00 00 
  801303:	ff d0                	callq  *%rax
    sys_cputs(b.buf, b.idx);
  801305:	8b 85 f0 fe ff ff    	mov    -0x110(%rbp),%eax
  80130b:	48 98                	cltq   
  80130d:	48 8d 95 f0 fe ff ff 	lea    -0x110(%rbp),%rdx
  801314:	48 83 c2 08          	add    $0x8,%rdx
  801318:	48 89 c6             	mov    %rax,%rsi
  80131b:	48 89 d7             	mov    %rdx,%rdi
  80131e:	48 b8 b0 26 80 00 00 	movabs $0x8026b0,%rax
  801325:	00 00 00 
  801328:	ff d0                	callq  *%rax
    va_end(aq);

    return b.cnt;
  80132a:	8b 85 f4 fe ff ff    	mov    -0x10c(%rbp),%eax
}
  801330:	c9                   	leaveq 
  801331:	c3                   	retq   

0000000000801332 <cprintf>:

    int
cprintf(const char *fmt, ...)
{
  801332:	55                   	push   %rbp
  801333:	48 89 e5             	mov    %rsp,%rbp
  801336:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  80133d:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  801344:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  80134b:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  801352:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801359:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801360:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801367:	84 c0                	test   %al,%al
  801369:	74 20                	je     80138b <cprintf+0x59>
  80136b:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80136f:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801373:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801377:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80137b:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80137f:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801383:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801387:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
    va_list ap;
    int cnt;
    va_list aq;
    va_start(ap, fmt);
  80138b:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  801392:	00 00 00 
  801395:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  80139c:	00 00 00 
  80139f:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8013a3:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8013aa:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8013b1:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    va_copy(aq,ap);
  8013b8:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  8013bf:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8013c6:	48 8b 0a             	mov    (%rdx),%rcx
  8013c9:	48 89 08             	mov    %rcx,(%rax)
  8013cc:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8013d0:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8013d4:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8013d8:	48 89 50 10          	mov    %rdx,0x10(%rax)
    cnt = vcprintf(fmt, aq);
  8013dc:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  8013e3:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8013ea:	48 89 d6             	mov    %rdx,%rsi
  8013ed:	48 89 c7             	mov    %rax,%rdi
  8013f0:	48 b8 86 12 80 00 00 	movabs $0x801286,%rax
  8013f7:	00 00 00 
  8013fa:	ff d0                	callq  *%rax
  8013fc:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
    va_end(aq);

    return cnt;
  801402:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  801408:	c9                   	leaveq 
  801409:	c3                   	retq   

000000000080140a <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80140a:	55                   	push   %rbp
  80140b:	48 89 e5             	mov    %rsp,%rbp
  80140e:	48 83 ec 30          	sub    $0x30,%rsp
  801412:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  801416:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80141a:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80141e:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
  801421:	44 89 45 e0          	mov    %r8d,-0x20(%rbp)
  801425:	44 89 4d dc          	mov    %r9d,-0x24(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  801429:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80142c:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  801430:	77 54                	ja     801486 <printnum+0x7c>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  801432:	8b 45 e0             	mov    -0x20(%rbp),%eax
  801435:	8d 78 ff             	lea    -0x1(%rax),%edi
  801438:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  80143b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80143f:	ba 00 00 00 00       	mov    $0x0,%edx
  801444:	48 f7 f6             	div    %rsi
  801447:	49 89 c2             	mov    %rax,%r10
  80144a:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  80144d:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  801450:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  801454:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801458:	41 89 c9             	mov    %ecx,%r9d
  80145b:	41 89 f8             	mov    %edi,%r8d
  80145e:	89 d1                	mov    %edx,%ecx
  801460:	4c 89 d2             	mov    %r10,%rdx
  801463:	48 89 c7             	mov    %rax,%rdi
  801466:	48 b8 0a 14 80 00 00 	movabs $0x80140a,%rax
  80146d:	00 00 00 
  801470:	ff d0                	callq  *%rax
  801472:	eb 1c                	jmp    801490 <printnum+0x86>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  801474:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  801478:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80147b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80147f:	48 89 ce             	mov    %rcx,%rsi
  801482:	89 d7                	mov    %edx,%edi
  801484:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  801486:	83 6d e0 01          	subl   $0x1,-0x20(%rbp)
  80148a:	83 7d e0 00          	cmpl   $0x0,-0x20(%rbp)
  80148e:	7f e4                	jg     801474 <printnum+0x6a>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  801490:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  801493:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801497:	ba 00 00 00 00       	mov    $0x0,%edx
  80149c:	48 f7 f1             	div    %rcx
  80149f:	48 b8 f0 11 82 00 00 	movabs $0x8211f0,%rax
  8014a6:	00 00 00 
  8014a9:	0f b6 04 10          	movzbl (%rax,%rdx,1),%eax
  8014ad:	0f be d0             	movsbl %al,%edx
  8014b0:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8014b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8014b8:	48 89 ce             	mov    %rcx,%rsi
  8014bb:	89 d7                	mov    %edx,%edi
  8014bd:	ff d0                	callq  *%rax
}
  8014bf:	90                   	nop
  8014c0:	c9                   	leaveq 
  8014c1:	c3                   	retq   

00000000008014c2 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  8014c2:	55                   	push   %rbp
  8014c3:	48 89 e5             	mov    %rsp,%rbp
  8014c6:	48 83 ec 20          	sub    $0x20,%rsp
  8014ca:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8014ce:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  8014d1:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  8014d5:	7e 4f                	jle    801526 <getuint+0x64>
		x= va_arg(*ap, unsigned long long);
  8014d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014db:	8b 00                	mov    (%rax),%eax
  8014dd:	83 f8 30             	cmp    $0x30,%eax
  8014e0:	73 24                	jae    801506 <getuint+0x44>
  8014e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014e6:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8014ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014ee:	8b 00                	mov    (%rax),%eax
  8014f0:	89 c0                	mov    %eax,%eax
  8014f2:	48 01 d0             	add    %rdx,%rax
  8014f5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8014f9:	8b 12                	mov    (%rdx),%edx
  8014fb:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8014fe:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801502:	89 0a                	mov    %ecx,(%rdx)
  801504:	eb 14                	jmp    80151a <getuint+0x58>
  801506:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80150a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80150e:	48 8d 48 08          	lea    0x8(%rax),%rcx
  801512:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801516:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  80151a:	48 8b 00             	mov    (%rax),%rax
  80151d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  801521:	e9 9d 00 00 00       	jmpq   8015c3 <getuint+0x101>
	else if (lflag)
  801526:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80152a:	74 4c                	je     801578 <getuint+0xb6>
		x= va_arg(*ap, unsigned long);
  80152c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801530:	8b 00                	mov    (%rax),%eax
  801532:	83 f8 30             	cmp    $0x30,%eax
  801535:	73 24                	jae    80155b <getuint+0x99>
  801537:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80153b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80153f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801543:	8b 00                	mov    (%rax),%eax
  801545:	89 c0                	mov    %eax,%eax
  801547:	48 01 d0             	add    %rdx,%rax
  80154a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80154e:	8b 12                	mov    (%rdx),%edx
  801550:	8d 4a 08             	lea    0x8(%rdx),%ecx
  801553:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801557:	89 0a                	mov    %ecx,(%rdx)
  801559:	eb 14                	jmp    80156f <getuint+0xad>
  80155b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80155f:	48 8b 40 08          	mov    0x8(%rax),%rax
  801563:	48 8d 48 08          	lea    0x8(%rax),%rcx
  801567:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80156b:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  80156f:	48 8b 00             	mov    (%rax),%rax
  801572:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  801576:	eb 4b                	jmp    8015c3 <getuint+0x101>
	else
		x= va_arg(*ap, unsigned int);
  801578:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80157c:	8b 00                	mov    (%rax),%eax
  80157e:	83 f8 30             	cmp    $0x30,%eax
  801581:	73 24                	jae    8015a7 <getuint+0xe5>
  801583:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801587:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80158b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80158f:	8b 00                	mov    (%rax),%eax
  801591:	89 c0                	mov    %eax,%eax
  801593:	48 01 d0             	add    %rdx,%rax
  801596:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80159a:	8b 12                	mov    (%rdx),%edx
  80159c:	8d 4a 08             	lea    0x8(%rdx),%ecx
  80159f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8015a3:	89 0a                	mov    %ecx,(%rdx)
  8015a5:	eb 14                	jmp    8015bb <getuint+0xf9>
  8015a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015ab:	48 8b 40 08          	mov    0x8(%rax),%rax
  8015af:	48 8d 48 08          	lea    0x8(%rax),%rcx
  8015b3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8015b7:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8015bb:	8b 00                	mov    (%rax),%eax
  8015bd:	89 c0                	mov    %eax,%eax
  8015bf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  8015c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8015c7:	c9                   	leaveq 
  8015c8:	c3                   	retq   

00000000008015c9 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  8015c9:	55                   	push   %rbp
  8015ca:	48 89 e5             	mov    %rsp,%rbp
  8015cd:	48 83 ec 20          	sub    $0x20,%rsp
  8015d1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8015d5:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  8015d8:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  8015dc:	7e 4f                	jle    80162d <getint+0x64>
		x=va_arg(*ap, long long);
  8015de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015e2:	8b 00                	mov    (%rax),%eax
  8015e4:	83 f8 30             	cmp    $0x30,%eax
  8015e7:	73 24                	jae    80160d <getint+0x44>
  8015e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015ed:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8015f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015f5:	8b 00                	mov    (%rax),%eax
  8015f7:	89 c0                	mov    %eax,%eax
  8015f9:	48 01 d0             	add    %rdx,%rax
  8015fc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801600:	8b 12                	mov    (%rdx),%edx
  801602:	8d 4a 08             	lea    0x8(%rdx),%ecx
  801605:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801609:	89 0a                	mov    %ecx,(%rdx)
  80160b:	eb 14                	jmp    801621 <getint+0x58>
  80160d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801611:	48 8b 40 08          	mov    0x8(%rax),%rax
  801615:	48 8d 48 08          	lea    0x8(%rax),%rcx
  801619:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80161d:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  801621:	48 8b 00             	mov    (%rax),%rax
  801624:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  801628:	e9 9d 00 00 00       	jmpq   8016ca <getint+0x101>
	else if (lflag)
  80162d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  801631:	74 4c                	je     80167f <getint+0xb6>
		x=va_arg(*ap, long);
  801633:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801637:	8b 00                	mov    (%rax),%eax
  801639:	83 f8 30             	cmp    $0x30,%eax
  80163c:	73 24                	jae    801662 <getint+0x99>
  80163e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801642:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801646:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80164a:	8b 00                	mov    (%rax),%eax
  80164c:	89 c0                	mov    %eax,%eax
  80164e:	48 01 d0             	add    %rdx,%rax
  801651:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801655:	8b 12                	mov    (%rdx),%edx
  801657:	8d 4a 08             	lea    0x8(%rdx),%ecx
  80165a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80165e:	89 0a                	mov    %ecx,(%rdx)
  801660:	eb 14                	jmp    801676 <getint+0xad>
  801662:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801666:	48 8b 40 08          	mov    0x8(%rax),%rax
  80166a:	48 8d 48 08          	lea    0x8(%rax),%rcx
  80166e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801672:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  801676:	48 8b 00             	mov    (%rax),%rax
  801679:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80167d:	eb 4b                	jmp    8016ca <getint+0x101>
	else
		x=va_arg(*ap, int);
  80167f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801683:	8b 00                	mov    (%rax),%eax
  801685:	83 f8 30             	cmp    $0x30,%eax
  801688:	73 24                	jae    8016ae <getint+0xe5>
  80168a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80168e:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801692:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801696:	8b 00                	mov    (%rax),%eax
  801698:	89 c0                	mov    %eax,%eax
  80169a:	48 01 d0             	add    %rdx,%rax
  80169d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8016a1:	8b 12                	mov    (%rdx),%edx
  8016a3:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8016a6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8016aa:	89 0a                	mov    %ecx,(%rdx)
  8016ac:	eb 14                	jmp    8016c2 <getint+0xf9>
  8016ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8016b2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8016b6:	48 8d 48 08          	lea    0x8(%rax),%rcx
  8016ba:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8016be:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8016c2:	8b 00                	mov    (%rax),%eax
  8016c4:	48 98                	cltq   
  8016c6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  8016ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8016ce:	c9                   	leaveq 
  8016cf:	c3                   	retq   

00000000008016d0 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  8016d0:	55                   	push   %rbp
  8016d1:	48 89 e5             	mov    %rsp,%rbp
  8016d4:	41 54                	push   %r12
  8016d6:	53                   	push   %rbx
  8016d7:	48 83 ec 60          	sub    $0x60,%rsp
  8016db:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8016df:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8016e3:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  8016e7:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  8016eb:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8016ef:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8016f3:	48 8b 0a             	mov    (%rdx),%rcx
  8016f6:	48 89 08             	mov    %rcx,(%rax)
  8016f9:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8016fd:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801701:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801705:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  801709:	eb 17                	jmp    801722 <vprintfmt+0x52>
			if (ch == '\0')
  80170b:	85 db                	test   %ebx,%ebx
  80170d:	0f 84 b9 04 00 00    	je     801bcc <vprintfmt+0x4fc>
				return;
			putch(ch, putdat);
  801713:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801717:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80171b:	48 89 d6             	mov    %rdx,%rsi
  80171e:	89 df                	mov    %ebx,%edi
  801720:	ff d0                	callq  *%rax
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  801722:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  801726:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80172a:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  80172e:	0f b6 00             	movzbl (%rax),%eax
  801731:	0f b6 d8             	movzbl %al,%ebx
  801734:	83 fb 25             	cmp    $0x25,%ebx
  801737:	75 d2                	jne    80170b <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  801739:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  80173d:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  801744:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  80174b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  801752:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  801759:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80175d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801761:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  801765:	0f b6 00             	movzbl (%rax),%eax
  801768:	0f b6 d8             	movzbl %al,%ebx
  80176b:	8d 43 dd             	lea    -0x23(%rbx),%eax
  80176e:	83 f8 55             	cmp    $0x55,%eax
  801771:	0f 87 22 04 00 00    	ja     801b99 <vprintfmt+0x4c9>
  801777:	89 c0                	mov    %eax,%eax
  801779:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  801780:	00 
  801781:	48 b8 18 12 82 00 00 	movabs $0x821218,%rax
  801788:	00 00 00 
  80178b:	48 01 d0             	add    %rdx,%rax
  80178e:	48 8b 00             	mov    (%rax),%rax
  801791:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  801793:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  801797:	eb c0                	jmp    801759 <vprintfmt+0x89>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  801799:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  80179d:	eb ba                	jmp    801759 <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  80179f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  8017a6:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8017a9:	89 d0                	mov    %edx,%eax
  8017ab:	c1 e0 02             	shl    $0x2,%eax
  8017ae:	01 d0                	add    %edx,%eax
  8017b0:	01 c0                	add    %eax,%eax
  8017b2:	01 d8                	add    %ebx,%eax
  8017b4:	83 e8 30             	sub    $0x30,%eax
  8017b7:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  8017ba:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8017be:	0f b6 00             	movzbl (%rax),%eax
  8017c1:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  8017c4:	83 fb 2f             	cmp    $0x2f,%ebx
  8017c7:	7e 60                	jle    801829 <vprintfmt+0x159>
  8017c9:	83 fb 39             	cmp    $0x39,%ebx
  8017cc:	7f 5b                	jg     801829 <vprintfmt+0x159>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  8017ce:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  8017d3:	eb d1                	jmp    8017a6 <vprintfmt+0xd6>
			goto process_precision;

		case '*':
			precision = va_arg(aq, int);
  8017d5:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8017d8:	83 f8 30             	cmp    $0x30,%eax
  8017db:	73 17                	jae    8017f4 <vprintfmt+0x124>
  8017dd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8017e1:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8017e4:	89 d2                	mov    %edx,%edx
  8017e6:	48 01 d0             	add    %rdx,%rax
  8017e9:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8017ec:	83 c2 08             	add    $0x8,%edx
  8017ef:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8017f2:	eb 0c                	jmp    801800 <vprintfmt+0x130>
  8017f4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8017f8:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8017fc:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  801800:	8b 00                	mov    (%rax),%eax
  801802:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  801805:	eb 23                	jmp    80182a <vprintfmt+0x15a>

		case '.':
			if (width < 0)
  801807:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80180b:	0f 89 48 ff ff ff    	jns    801759 <vprintfmt+0x89>
				width = 0;
  801811:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  801818:	e9 3c ff ff ff       	jmpq   801759 <vprintfmt+0x89>

		case '#':
			altflag = 1;
  80181d:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  801824:	e9 30 ff ff ff       	jmpq   801759 <vprintfmt+0x89>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
  801829:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
  80182a:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80182e:	0f 89 25 ff ff ff    	jns    801759 <vprintfmt+0x89>
				width = precision, precision = -1;
  801834:	8b 45 d8             	mov    -0x28(%rbp),%eax
  801837:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80183a:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  801841:	e9 13 ff ff ff       	jmpq   801759 <vprintfmt+0x89>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  801846:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  80184a:	e9 0a ff ff ff       	jmpq   801759 <vprintfmt+0x89>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  80184f:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801852:	83 f8 30             	cmp    $0x30,%eax
  801855:	73 17                	jae    80186e <vprintfmt+0x19e>
  801857:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80185b:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80185e:	89 d2                	mov    %edx,%edx
  801860:	48 01 d0             	add    %rdx,%rax
  801863:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801866:	83 c2 08             	add    $0x8,%edx
  801869:	89 55 b8             	mov    %edx,-0x48(%rbp)
  80186c:	eb 0c                	jmp    80187a <vprintfmt+0x1aa>
  80186e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  801872:	48 8d 50 08          	lea    0x8(%rax),%rdx
  801876:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  80187a:	8b 10                	mov    (%rax),%edx
  80187c:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  801880:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801884:	48 89 ce             	mov    %rcx,%rsi
  801887:	89 d7                	mov    %edx,%edi
  801889:	ff d0                	callq  *%rax
			break;
  80188b:	e9 37 03 00 00       	jmpq   801bc7 <vprintfmt+0x4f7>

			// error message
		case 'e':
			err = va_arg(aq, int);
  801890:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801893:	83 f8 30             	cmp    $0x30,%eax
  801896:	73 17                	jae    8018af <vprintfmt+0x1df>
  801898:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80189c:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80189f:	89 d2                	mov    %edx,%edx
  8018a1:	48 01 d0             	add    %rdx,%rax
  8018a4:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8018a7:	83 c2 08             	add    $0x8,%edx
  8018aa:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8018ad:	eb 0c                	jmp    8018bb <vprintfmt+0x1eb>
  8018af:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8018b3:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8018b7:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8018bb:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  8018bd:	85 db                	test   %ebx,%ebx
  8018bf:	79 02                	jns    8018c3 <vprintfmt+0x1f3>
				err = -err;
  8018c1:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  8018c3:	83 fb 15             	cmp    $0x15,%ebx
  8018c6:	7f 16                	jg     8018de <vprintfmt+0x20e>
  8018c8:	48 b8 40 11 82 00 00 	movabs $0x821140,%rax
  8018cf:	00 00 00 
  8018d2:	48 63 d3             	movslq %ebx,%rdx
  8018d5:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  8018d9:	4d 85 e4             	test   %r12,%r12
  8018dc:	75 2e                	jne    80190c <vprintfmt+0x23c>
				printfmt(putch, putdat, "error %d", err);
  8018de:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  8018e2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8018e6:	89 d9                	mov    %ebx,%ecx
  8018e8:	48 ba 01 12 82 00 00 	movabs $0x821201,%rdx
  8018ef:	00 00 00 
  8018f2:	48 89 c7             	mov    %rax,%rdi
  8018f5:	b8 00 00 00 00       	mov    $0x0,%eax
  8018fa:	49 b8 d6 1b 80 00 00 	movabs $0x801bd6,%r8
  801901:	00 00 00 
  801904:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  801907:	e9 bb 02 00 00       	jmpq   801bc7 <vprintfmt+0x4f7>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  80190c:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  801910:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801914:	4c 89 e1             	mov    %r12,%rcx
  801917:	48 ba 0a 12 82 00 00 	movabs $0x82120a,%rdx
  80191e:	00 00 00 
  801921:	48 89 c7             	mov    %rax,%rdi
  801924:	b8 00 00 00 00       	mov    $0x0,%eax
  801929:	49 b8 d6 1b 80 00 00 	movabs $0x801bd6,%r8
  801930:	00 00 00 
  801933:	41 ff d0             	callq  *%r8
			break;
  801936:	e9 8c 02 00 00       	jmpq   801bc7 <vprintfmt+0x4f7>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  80193b:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80193e:	83 f8 30             	cmp    $0x30,%eax
  801941:	73 17                	jae    80195a <vprintfmt+0x28a>
  801943:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  801947:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80194a:	89 d2                	mov    %edx,%edx
  80194c:	48 01 d0             	add    %rdx,%rax
  80194f:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801952:	83 c2 08             	add    $0x8,%edx
  801955:	89 55 b8             	mov    %edx,-0x48(%rbp)
  801958:	eb 0c                	jmp    801966 <vprintfmt+0x296>
  80195a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80195e:	48 8d 50 08          	lea    0x8(%rax),%rdx
  801962:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  801966:	4c 8b 20             	mov    (%rax),%r12
  801969:	4d 85 e4             	test   %r12,%r12
  80196c:	75 0a                	jne    801978 <vprintfmt+0x2a8>
				p = "(null)";
  80196e:	49 bc 0d 12 82 00 00 	movabs $0x82120d,%r12
  801975:	00 00 00 
			if (width > 0 && padc != '-')
  801978:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80197c:	7e 78                	jle    8019f6 <vprintfmt+0x326>
  80197e:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  801982:	74 72                	je     8019f6 <vprintfmt+0x326>
				for (width -= strnlen(p, precision); width > 0; width--)
  801984:	8b 45 d8             	mov    -0x28(%rbp),%eax
  801987:	48 98                	cltq   
  801989:	48 89 c6             	mov    %rax,%rsi
  80198c:	4c 89 e7             	mov    %r12,%rdi
  80198f:	48 b8 84 1e 80 00 00 	movabs $0x801e84,%rax
  801996:	00 00 00 
  801999:	ff d0                	callq  *%rax
  80199b:	29 45 dc             	sub    %eax,-0x24(%rbp)
  80199e:	eb 17                	jmp    8019b7 <vprintfmt+0x2e7>
					putch(padc, putdat);
  8019a0:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  8019a4:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8019a8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8019ac:	48 89 ce             	mov    %rcx,%rsi
  8019af:	89 d7                	mov    %edx,%edi
  8019b1:	ff d0                	callq  *%rax
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  8019b3:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  8019b7:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8019bb:	7f e3                	jg     8019a0 <vprintfmt+0x2d0>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  8019bd:	eb 37                	jmp    8019f6 <vprintfmt+0x326>
				if (altflag && (ch < ' ' || ch > '~'))
  8019bf:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  8019c3:	74 1e                	je     8019e3 <vprintfmt+0x313>
  8019c5:	83 fb 1f             	cmp    $0x1f,%ebx
  8019c8:	7e 05                	jle    8019cf <vprintfmt+0x2ff>
  8019ca:	83 fb 7e             	cmp    $0x7e,%ebx
  8019cd:	7e 14                	jle    8019e3 <vprintfmt+0x313>
					putch('?', putdat);
  8019cf:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8019d3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8019d7:	48 89 d6             	mov    %rdx,%rsi
  8019da:	bf 3f 00 00 00       	mov    $0x3f,%edi
  8019df:	ff d0                	callq  *%rax
  8019e1:	eb 0f                	jmp    8019f2 <vprintfmt+0x322>
				else
					putch(ch, putdat);
  8019e3:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8019e7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8019eb:	48 89 d6             	mov    %rdx,%rsi
  8019ee:	89 df                	mov    %ebx,%edi
  8019f0:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  8019f2:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  8019f6:	4c 89 e0             	mov    %r12,%rax
  8019f9:	4c 8d 60 01          	lea    0x1(%rax),%r12
  8019fd:	0f b6 00             	movzbl (%rax),%eax
  801a00:	0f be d8             	movsbl %al,%ebx
  801a03:	85 db                	test   %ebx,%ebx
  801a05:	74 28                	je     801a2f <vprintfmt+0x35f>
  801a07:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  801a0b:	78 b2                	js     8019bf <vprintfmt+0x2ef>
  801a0d:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  801a11:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  801a15:	79 a8                	jns    8019bf <vprintfmt+0x2ef>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  801a17:	eb 16                	jmp    801a2f <vprintfmt+0x35f>
				putch(' ', putdat);
  801a19:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801a1d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801a21:	48 89 d6             	mov    %rdx,%rsi
  801a24:	bf 20 00 00 00       	mov    $0x20,%edi
  801a29:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  801a2b:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  801a2f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  801a33:	7f e4                	jg     801a19 <vprintfmt+0x349>
				putch(' ', putdat);
			break;
  801a35:	e9 8d 01 00 00       	jmpq   801bc7 <vprintfmt+0x4f7>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  801a3a:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801a3e:	be 03 00 00 00       	mov    $0x3,%esi
  801a43:	48 89 c7             	mov    %rax,%rdi
  801a46:	48 b8 c9 15 80 00 00 	movabs $0x8015c9,%rax
  801a4d:	00 00 00 
  801a50:	ff d0                	callq  *%rax
  801a52:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  801a56:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801a5a:	48 85 c0             	test   %rax,%rax
  801a5d:	79 1d                	jns    801a7c <vprintfmt+0x3ac>
				putch('-', putdat);
  801a5f:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801a63:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801a67:	48 89 d6             	mov    %rdx,%rsi
  801a6a:	bf 2d 00 00 00       	mov    $0x2d,%edi
  801a6f:	ff d0                	callq  *%rax
				num = -(long long) num;
  801a71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801a75:	48 f7 d8             	neg    %rax
  801a78:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  801a7c:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  801a83:	e9 d2 00 00 00       	jmpq   801b5a <vprintfmt+0x48a>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  801a88:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801a8c:	be 03 00 00 00       	mov    $0x3,%esi
  801a91:	48 89 c7             	mov    %rax,%rdi
  801a94:	48 b8 c2 14 80 00 00 	movabs $0x8014c2,%rax
  801a9b:	00 00 00 
  801a9e:	ff d0                	callq  *%rax
  801aa0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  801aa4:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  801aab:	e9 aa 00 00 00       	jmpq   801b5a <vprintfmt+0x48a>

			// (unsigned) octal
		case 'o':

			num = getuint(&aq, 3);
  801ab0:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801ab4:	be 03 00 00 00       	mov    $0x3,%esi
  801ab9:	48 89 c7             	mov    %rax,%rdi
  801abc:	48 b8 c2 14 80 00 00 	movabs $0x8014c2,%rax
  801ac3:	00 00 00 
  801ac6:	ff d0                	callq  *%rax
  801ac8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 8;
  801acc:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
			goto number;
  801ad3:	e9 82 00 00 00       	jmpq   801b5a <vprintfmt+0x48a>


			// pointer
		case 'p':
			putch('0', putdat);
  801ad8:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801adc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801ae0:	48 89 d6             	mov    %rdx,%rsi
  801ae3:	bf 30 00 00 00       	mov    $0x30,%edi
  801ae8:	ff d0                	callq  *%rax
			putch('x', putdat);
  801aea:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801aee:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801af2:	48 89 d6             	mov    %rdx,%rsi
  801af5:	bf 78 00 00 00       	mov    $0x78,%edi
  801afa:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  801afc:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801aff:	83 f8 30             	cmp    $0x30,%eax
  801b02:	73 17                	jae    801b1b <vprintfmt+0x44b>
  801b04:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  801b08:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801b0b:	89 d2                	mov    %edx,%edx
  801b0d:	48 01 d0             	add    %rdx,%rax
  801b10:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801b13:	83 c2 08             	add    $0x8,%edx
  801b16:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  801b19:	eb 0c                	jmp    801b27 <vprintfmt+0x457>
				(uintptr_t) va_arg(aq, void *);
  801b1b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  801b1f:	48 8d 50 08          	lea    0x8(%rax),%rdx
  801b23:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  801b27:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  801b2a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  801b2e:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  801b35:	eb 23                	jmp    801b5a <vprintfmt+0x48a>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  801b37:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801b3b:	be 03 00 00 00       	mov    $0x3,%esi
  801b40:	48 89 c7             	mov    %rax,%rdi
  801b43:	48 b8 c2 14 80 00 00 	movabs $0x8014c2,%rax
  801b4a:	00 00 00 
  801b4d:	ff d0                	callq  *%rax
  801b4f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  801b53:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  801b5a:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  801b5f:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  801b62:	8b 7d dc             	mov    -0x24(%rbp),%edi
  801b65:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801b69:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  801b6d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801b71:	45 89 c1             	mov    %r8d,%r9d
  801b74:	41 89 f8             	mov    %edi,%r8d
  801b77:	48 89 c7             	mov    %rax,%rdi
  801b7a:	48 b8 0a 14 80 00 00 	movabs $0x80140a,%rax
  801b81:	00 00 00 
  801b84:	ff d0                	callq  *%rax
			break;
  801b86:	eb 3f                	jmp    801bc7 <vprintfmt+0x4f7>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  801b88:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801b8c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801b90:	48 89 d6             	mov    %rdx,%rsi
  801b93:	89 df                	mov    %ebx,%edi
  801b95:	ff d0                	callq  *%rax
			break;
  801b97:	eb 2e                	jmp    801bc7 <vprintfmt+0x4f7>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  801b99:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801b9d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801ba1:	48 89 d6             	mov    %rdx,%rsi
  801ba4:	bf 25 00 00 00       	mov    $0x25,%edi
  801ba9:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  801bab:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  801bb0:	eb 05                	jmp    801bb7 <vprintfmt+0x4e7>
  801bb2:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  801bb7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  801bbb:	48 83 e8 01          	sub    $0x1,%rax
  801bbf:	0f b6 00             	movzbl (%rax),%eax
  801bc2:	3c 25                	cmp    $0x25,%al
  801bc4:	75 ec                	jne    801bb2 <vprintfmt+0x4e2>
				/* do nothing */;
			break;
  801bc6:	90                   	nop
		}
	}
  801bc7:	e9 3d fb ff ff       	jmpq   801709 <vprintfmt+0x39>
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
  801bcc:	90                   	nop
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  801bcd:	48 83 c4 60          	add    $0x60,%rsp
  801bd1:	5b                   	pop    %rbx
  801bd2:	41 5c                	pop    %r12
  801bd4:	5d                   	pop    %rbp
  801bd5:	c3                   	retq   

0000000000801bd6 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  801bd6:	55                   	push   %rbp
  801bd7:	48 89 e5             	mov    %rsp,%rbp
  801bda:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  801be1:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  801be8:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  801bef:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
  801bf6:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801bfd:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801c04:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801c0b:	84 c0                	test   %al,%al
  801c0d:	74 20                	je     801c2f <printfmt+0x59>
  801c0f:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  801c13:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801c17:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801c1b:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  801c1f:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  801c23:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801c27:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801c2b:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;

	va_start(ap, fmt);
  801c2f:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  801c36:	00 00 00 
  801c39:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  801c40:	00 00 00 
  801c43:	48 8d 45 10          	lea    0x10(%rbp),%rax
  801c47:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  801c4e:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  801c55:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  801c5c:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  801c63:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  801c6a:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  801c71:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  801c78:	48 89 c7             	mov    %rax,%rdi
  801c7b:	48 b8 d0 16 80 00 00 	movabs $0x8016d0,%rax
  801c82:	00 00 00 
  801c85:	ff d0                	callq  *%rax
	va_end(ap);
}
  801c87:	90                   	nop
  801c88:	c9                   	leaveq 
  801c89:	c3                   	retq   

0000000000801c8a <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  801c8a:	55                   	push   %rbp
  801c8b:	48 89 e5             	mov    %rsp,%rbp
  801c8e:	48 83 ec 10          	sub    $0x10,%rsp
  801c92:	89 7d fc             	mov    %edi,-0x4(%rbp)
  801c95:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  801c99:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801c9d:	8b 40 10             	mov    0x10(%rax),%eax
  801ca0:	8d 50 01             	lea    0x1(%rax),%edx
  801ca3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801ca7:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  801caa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801cae:	48 8b 10             	mov    (%rax),%rdx
  801cb1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801cb5:	48 8b 40 08          	mov    0x8(%rax),%rax
  801cb9:	48 39 c2             	cmp    %rax,%rdx
  801cbc:	73 17                	jae    801cd5 <sprintputch+0x4b>
		*b->buf++ = ch;
  801cbe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801cc2:	48 8b 00             	mov    (%rax),%rax
  801cc5:	48 8d 48 01          	lea    0x1(%rax),%rcx
  801cc9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801ccd:	48 89 0a             	mov    %rcx,(%rdx)
  801cd0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  801cd3:	88 10                	mov    %dl,(%rax)
}
  801cd5:	90                   	nop
  801cd6:	c9                   	leaveq 
  801cd7:	c3                   	retq   

0000000000801cd8 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  801cd8:	55                   	push   %rbp
  801cd9:	48 89 e5             	mov    %rsp,%rbp
  801cdc:	48 83 ec 50          	sub    $0x50,%rsp
  801ce0:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  801ce4:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  801ce7:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  801ceb:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  801cef:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  801cf3:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  801cf7:	48 8b 0a             	mov    (%rdx),%rcx
  801cfa:	48 89 08             	mov    %rcx,(%rax)
  801cfd:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801d01:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801d05:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801d09:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  801d0d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  801d11:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  801d15:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  801d18:	48 98                	cltq   
  801d1a:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  801d1e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  801d22:	48 01 d0             	add    %rdx,%rax
  801d25:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  801d29:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  801d30:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  801d35:	74 06                	je     801d3d <vsnprintf+0x65>
  801d37:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  801d3b:	7f 07                	jg     801d44 <vsnprintf+0x6c>
		return -E_INVAL;
  801d3d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  801d42:	eb 2f                	jmp    801d73 <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  801d44:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  801d48:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  801d4c:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  801d50:	48 89 c6             	mov    %rax,%rsi
  801d53:	48 bf 8a 1c 80 00 00 	movabs $0x801c8a,%rdi
  801d5a:	00 00 00 
  801d5d:	48 b8 d0 16 80 00 00 	movabs $0x8016d0,%rax
  801d64:	00 00 00 
  801d67:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  801d69:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  801d6d:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  801d70:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  801d73:	c9                   	leaveq 
  801d74:	c3                   	retq   

0000000000801d75 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  801d75:	55                   	push   %rbp
  801d76:	48 89 e5             	mov    %rsp,%rbp
  801d79:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  801d80:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  801d87:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  801d8d:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
  801d94:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801d9b:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801da2:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801da9:	84 c0                	test   %al,%al
  801dab:	74 20                	je     801dcd <snprintf+0x58>
  801dad:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  801db1:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801db5:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801db9:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  801dbd:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  801dc1:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801dc5:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801dc9:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  801dcd:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  801dd4:	00 00 00 
  801dd7:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  801dde:	00 00 00 
  801de1:	48 8d 45 10          	lea    0x10(%rbp),%rax
  801de5:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  801dec:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  801df3:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  801dfa:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  801e01:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  801e08:	48 8b 0a             	mov    (%rdx),%rcx
  801e0b:	48 89 08             	mov    %rcx,(%rax)
  801e0e:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801e12:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801e16:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801e1a:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  801e1e:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  801e25:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  801e2c:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  801e32:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  801e39:	48 89 c7             	mov    %rax,%rdi
  801e3c:	48 b8 d8 1c 80 00 00 	movabs $0x801cd8,%rax
  801e43:	00 00 00 
  801e46:	ff d0                	callq  *%rax
  801e48:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  801e4e:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  801e54:	c9                   	leaveq 
  801e55:	c3                   	retq   

0000000000801e56 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  801e56:	55                   	push   %rbp
  801e57:	48 89 e5             	mov    %rsp,%rbp
  801e5a:	48 83 ec 18          	sub    $0x18,%rsp
  801e5e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  801e62:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  801e69:	eb 09                	jmp    801e74 <strlen+0x1e>
		n++;
  801e6b:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  801e6f:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801e74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801e78:	0f b6 00             	movzbl (%rax),%eax
  801e7b:	84 c0                	test   %al,%al
  801e7d:	75 ec                	jne    801e6b <strlen+0x15>
		n++;
	return n;
  801e7f:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  801e82:	c9                   	leaveq 
  801e83:	c3                   	retq   

0000000000801e84 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  801e84:	55                   	push   %rbp
  801e85:	48 89 e5             	mov    %rsp,%rbp
  801e88:	48 83 ec 20          	sub    $0x20,%rsp
  801e8c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801e90:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  801e94:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  801e9b:	eb 0e                	jmp    801eab <strnlen+0x27>
		n++;
  801e9d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  801ea1:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801ea6:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  801eab:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  801eb0:	74 0b                	je     801ebd <strnlen+0x39>
  801eb2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801eb6:	0f b6 00             	movzbl (%rax),%eax
  801eb9:	84 c0                	test   %al,%al
  801ebb:	75 e0                	jne    801e9d <strnlen+0x19>
		n++;
	return n;
  801ebd:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  801ec0:	c9                   	leaveq 
  801ec1:	c3                   	retq   

0000000000801ec2 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  801ec2:	55                   	push   %rbp
  801ec3:	48 89 e5             	mov    %rsp,%rbp
  801ec6:	48 83 ec 20          	sub    $0x20,%rsp
  801eca:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801ece:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  801ed2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801ed6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  801eda:	90                   	nop
  801edb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801edf:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801ee3:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  801ee7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  801eeb:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  801eef:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  801ef3:	0f b6 12             	movzbl (%rdx),%edx
  801ef6:	88 10                	mov    %dl,(%rax)
  801ef8:	0f b6 00             	movzbl (%rax),%eax
  801efb:	84 c0                	test   %al,%al
  801efd:	75 dc                	jne    801edb <strcpy+0x19>
		/* do nothing */;
	return ret;
  801eff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  801f03:	c9                   	leaveq 
  801f04:	c3                   	retq   

0000000000801f05 <strcat>:

char *
strcat(char *dst, const char *src)
{
  801f05:	55                   	push   %rbp
  801f06:	48 89 e5             	mov    %rsp,%rbp
  801f09:	48 83 ec 20          	sub    $0x20,%rsp
  801f0d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801f11:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  801f15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f19:	48 89 c7             	mov    %rax,%rdi
  801f1c:	48 b8 56 1e 80 00 00 	movabs $0x801e56,%rax
  801f23:	00 00 00 
  801f26:	ff d0                	callq  *%rax
  801f28:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  801f2b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  801f2e:	48 63 d0             	movslq %eax,%rdx
  801f31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f35:	48 01 c2             	add    %rax,%rdx
  801f38:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801f3c:	48 89 c6             	mov    %rax,%rsi
  801f3f:	48 89 d7             	mov    %rdx,%rdi
  801f42:	48 b8 c2 1e 80 00 00 	movabs $0x801ec2,%rax
  801f49:	00 00 00 
  801f4c:	ff d0                	callq  *%rax
	return dst;
  801f4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  801f52:	c9                   	leaveq 
  801f53:	c3                   	retq   

0000000000801f54 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  801f54:	55                   	push   %rbp
  801f55:	48 89 e5             	mov    %rsp,%rbp
  801f58:	48 83 ec 28          	sub    $0x28,%rsp
  801f5c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801f60:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  801f64:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  801f68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f6c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  801f70:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  801f77:	00 
  801f78:	eb 2a                	jmp    801fa4 <strncpy+0x50>
		*dst++ = *src;
  801f7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f7e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801f82:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  801f86:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  801f8a:	0f b6 12             	movzbl (%rdx),%edx
  801f8d:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  801f8f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801f93:	0f b6 00             	movzbl (%rax),%eax
  801f96:	84 c0                	test   %al,%al
  801f98:	74 05                	je     801f9f <strncpy+0x4b>
			src++;
  801f9a:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  801f9f:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  801fa4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801fa8:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  801fac:	72 cc                	jb     801f7a <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  801fae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  801fb2:	c9                   	leaveq 
  801fb3:	c3                   	retq   

0000000000801fb4 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  801fb4:	55                   	push   %rbp
  801fb5:	48 89 e5             	mov    %rsp,%rbp
  801fb8:	48 83 ec 28          	sub    $0x28,%rsp
  801fbc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801fc0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  801fc4:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  801fc8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801fcc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  801fd0:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  801fd5:	74 3d                	je     802014 <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  801fd7:	eb 1d                	jmp    801ff6 <strlcpy+0x42>
			*dst++ = *src++;
  801fd9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801fdd:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801fe1:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  801fe5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  801fe9:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  801fed:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  801ff1:	0f b6 12             	movzbl (%rdx),%edx
  801ff4:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  801ff6:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  801ffb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  802000:	74 0b                	je     80200d <strlcpy+0x59>
  802002:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802006:	0f b6 00             	movzbl (%rax),%eax
  802009:	84 c0                	test   %al,%al
  80200b:	75 cc                	jne    801fd9 <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  80200d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802011:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  802014:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  802018:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80201c:	48 29 c2             	sub    %rax,%rdx
  80201f:	48 89 d0             	mov    %rdx,%rax
}
  802022:	c9                   	leaveq 
  802023:	c3                   	retq   

0000000000802024 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  802024:	55                   	push   %rbp
  802025:	48 89 e5             	mov    %rsp,%rbp
  802028:	48 83 ec 10          	sub    $0x10,%rsp
  80202c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802030:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  802034:	eb 0a                	jmp    802040 <strcmp+0x1c>
		p++, q++;
  802036:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80203b:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  802040:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802044:	0f b6 00             	movzbl (%rax),%eax
  802047:	84 c0                	test   %al,%al
  802049:	74 12                	je     80205d <strcmp+0x39>
  80204b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80204f:	0f b6 10             	movzbl (%rax),%edx
  802052:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802056:	0f b6 00             	movzbl (%rax),%eax
  802059:	38 c2                	cmp    %al,%dl
  80205b:	74 d9                	je     802036 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80205d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802061:	0f b6 00             	movzbl (%rax),%eax
  802064:	0f b6 d0             	movzbl %al,%edx
  802067:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80206b:	0f b6 00             	movzbl (%rax),%eax
  80206e:	0f b6 c0             	movzbl %al,%eax
  802071:	29 c2                	sub    %eax,%edx
  802073:	89 d0                	mov    %edx,%eax
}
  802075:	c9                   	leaveq 
  802076:	c3                   	retq   

0000000000802077 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  802077:	55                   	push   %rbp
  802078:	48 89 e5             	mov    %rsp,%rbp
  80207b:	48 83 ec 18          	sub    $0x18,%rsp
  80207f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802083:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802087:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  80208b:	eb 0f                	jmp    80209c <strncmp+0x25>
		n--, p++, q++;
  80208d:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  802092:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  802097:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  80209c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8020a1:	74 1d                	je     8020c0 <strncmp+0x49>
  8020a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020a7:	0f b6 00             	movzbl (%rax),%eax
  8020aa:	84 c0                	test   %al,%al
  8020ac:	74 12                	je     8020c0 <strncmp+0x49>
  8020ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020b2:	0f b6 10             	movzbl (%rax),%edx
  8020b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8020b9:	0f b6 00             	movzbl (%rax),%eax
  8020bc:	38 c2                	cmp    %al,%dl
  8020be:	74 cd                	je     80208d <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  8020c0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8020c5:	75 07                	jne    8020ce <strncmp+0x57>
		return 0;
  8020c7:	b8 00 00 00 00       	mov    $0x0,%eax
  8020cc:	eb 18                	jmp    8020e6 <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  8020ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020d2:	0f b6 00             	movzbl (%rax),%eax
  8020d5:	0f b6 d0             	movzbl %al,%edx
  8020d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8020dc:	0f b6 00             	movzbl (%rax),%eax
  8020df:	0f b6 c0             	movzbl %al,%eax
  8020e2:	29 c2                	sub    %eax,%edx
  8020e4:	89 d0                	mov    %edx,%eax
}
  8020e6:	c9                   	leaveq 
  8020e7:	c3                   	retq   

00000000008020e8 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  8020e8:	55                   	push   %rbp
  8020e9:	48 89 e5             	mov    %rsp,%rbp
  8020ec:	48 83 ec 10          	sub    $0x10,%rsp
  8020f0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8020f4:	89 f0                	mov    %esi,%eax
  8020f6:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  8020f9:	eb 17                	jmp    802112 <strchr+0x2a>
		if (*s == c)
  8020fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020ff:	0f b6 00             	movzbl (%rax),%eax
  802102:	3a 45 f4             	cmp    -0xc(%rbp),%al
  802105:	75 06                	jne    80210d <strchr+0x25>
			return (char *) s;
  802107:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80210b:	eb 15                	jmp    802122 <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80210d:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  802112:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802116:	0f b6 00             	movzbl (%rax),%eax
  802119:	84 c0                	test   %al,%al
  80211b:	75 de                	jne    8020fb <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  80211d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802122:	c9                   	leaveq 
  802123:	c3                   	retq   

0000000000802124 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  802124:	55                   	push   %rbp
  802125:	48 89 e5             	mov    %rsp,%rbp
  802128:	48 83 ec 10          	sub    $0x10,%rsp
  80212c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802130:	89 f0                	mov    %esi,%eax
  802132:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  802135:	eb 11                	jmp    802148 <strfind+0x24>
		if (*s == c)
  802137:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80213b:	0f b6 00             	movzbl (%rax),%eax
  80213e:	3a 45 f4             	cmp    -0xc(%rbp),%al
  802141:	74 12                	je     802155 <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  802143:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  802148:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80214c:	0f b6 00             	movzbl (%rax),%eax
  80214f:	84 c0                	test   %al,%al
  802151:	75 e4                	jne    802137 <strfind+0x13>
  802153:	eb 01                	jmp    802156 <strfind+0x32>
		if (*s == c)
			break;
  802155:	90                   	nop
	return (char *) s;
  802156:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80215a:	c9                   	leaveq 
  80215b:	c3                   	retq   

000000000080215c <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80215c:	55                   	push   %rbp
  80215d:	48 89 e5             	mov    %rsp,%rbp
  802160:	48 83 ec 18          	sub    $0x18,%rsp
  802164:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802168:	89 75 f4             	mov    %esi,-0xc(%rbp)
  80216b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  80216f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  802174:	75 06                	jne    80217c <memset+0x20>
		return v;
  802176:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80217a:	eb 69                	jmp    8021e5 <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  80217c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802180:	83 e0 03             	and    $0x3,%eax
  802183:	48 85 c0             	test   %rax,%rax
  802186:	75 48                	jne    8021d0 <memset+0x74>
  802188:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80218c:	83 e0 03             	and    $0x3,%eax
  80218f:	48 85 c0             	test   %rax,%rax
  802192:	75 3c                	jne    8021d0 <memset+0x74>
		c &= 0xFF;
  802194:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80219b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80219e:	c1 e0 18             	shl    $0x18,%eax
  8021a1:	89 c2                	mov    %eax,%edx
  8021a3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8021a6:	c1 e0 10             	shl    $0x10,%eax
  8021a9:	09 c2                	or     %eax,%edx
  8021ab:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8021ae:	c1 e0 08             	shl    $0x8,%eax
  8021b1:	09 d0                	or     %edx,%eax
  8021b3:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  8021b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8021ba:	48 c1 e8 02          	shr    $0x2,%rax
  8021be:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  8021c1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8021c5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8021c8:	48 89 d7             	mov    %rdx,%rdi
  8021cb:	fc                   	cld    
  8021cc:	f3 ab                	rep stos %eax,%es:(%rdi)
  8021ce:	eb 11                	jmp    8021e1 <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  8021d0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8021d4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8021d7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8021db:	48 89 d7             	mov    %rdx,%rdi
  8021de:	fc                   	cld    
  8021df:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  8021e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8021e5:	c9                   	leaveq 
  8021e6:	c3                   	retq   

00000000008021e7 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  8021e7:	55                   	push   %rbp
  8021e8:	48 89 e5             	mov    %rsp,%rbp
  8021eb:	48 83 ec 28          	sub    $0x28,%rsp
  8021ef:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8021f3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8021f7:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  8021fb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8021ff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  802203:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802207:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  80220b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80220f:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  802213:	0f 83 88 00 00 00    	jae    8022a1 <memmove+0xba>
  802219:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80221d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802221:	48 01 d0             	add    %rdx,%rax
  802224:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  802228:	76 77                	jbe    8022a1 <memmove+0xba>
		s += n;
  80222a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80222e:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  802232:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802236:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  80223a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80223e:	83 e0 03             	and    $0x3,%eax
  802241:	48 85 c0             	test   %rax,%rax
  802244:	75 3b                	jne    802281 <memmove+0x9a>
  802246:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80224a:	83 e0 03             	and    $0x3,%eax
  80224d:	48 85 c0             	test   %rax,%rax
  802250:	75 2f                	jne    802281 <memmove+0x9a>
  802252:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802256:	83 e0 03             	and    $0x3,%eax
  802259:	48 85 c0             	test   %rax,%rax
  80225c:	75 23                	jne    802281 <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80225e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802262:	48 83 e8 04          	sub    $0x4,%rax
  802266:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80226a:	48 83 ea 04          	sub    $0x4,%rdx
  80226e:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  802272:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  802276:	48 89 c7             	mov    %rax,%rdi
  802279:	48 89 d6             	mov    %rdx,%rsi
  80227c:	fd                   	std    
  80227d:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  80227f:	eb 1d                	jmp    80229e <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  802281:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802285:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  802289:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80228d:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  802291:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802295:	48 89 d7             	mov    %rdx,%rdi
  802298:	48 89 c1             	mov    %rax,%rcx
  80229b:	fd                   	std    
  80229c:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80229e:	fc                   	cld    
  80229f:	eb 57                	jmp    8022f8 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  8022a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8022a5:	83 e0 03             	and    $0x3,%eax
  8022a8:	48 85 c0             	test   %rax,%rax
  8022ab:	75 36                	jne    8022e3 <memmove+0xfc>
  8022ad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8022b1:	83 e0 03             	and    $0x3,%eax
  8022b4:	48 85 c0             	test   %rax,%rax
  8022b7:	75 2a                	jne    8022e3 <memmove+0xfc>
  8022b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022bd:	83 e0 03             	and    $0x3,%eax
  8022c0:	48 85 c0             	test   %rax,%rax
  8022c3:	75 1e                	jne    8022e3 <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  8022c5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022c9:	48 c1 e8 02          	shr    $0x2,%rax
  8022cd:	48 89 c1             	mov    %rax,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  8022d0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8022d4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8022d8:	48 89 c7             	mov    %rax,%rdi
  8022db:	48 89 d6             	mov    %rdx,%rsi
  8022de:	fc                   	cld    
  8022df:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  8022e1:	eb 15                	jmp    8022f8 <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  8022e3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8022e7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8022eb:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8022ef:	48 89 c7             	mov    %rax,%rdi
  8022f2:	48 89 d6             	mov    %rdx,%rsi
  8022f5:	fc                   	cld    
  8022f6:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  8022f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8022fc:	c9                   	leaveq 
  8022fd:	c3                   	retq   

00000000008022fe <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  8022fe:	55                   	push   %rbp
  8022ff:	48 89 e5             	mov    %rsp,%rbp
  802302:	48 83 ec 18          	sub    $0x18,%rsp
  802306:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80230a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80230e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  802312:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  802316:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80231a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80231e:	48 89 ce             	mov    %rcx,%rsi
  802321:	48 89 c7             	mov    %rax,%rdi
  802324:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  80232b:	00 00 00 
  80232e:	ff d0                	callq  *%rax
}
  802330:	c9                   	leaveq 
  802331:	c3                   	retq   

0000000000802332 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  802332:	55                   	push   %rbp
  802333:	48 89 e5             	mov    %rsp,%rbp
  802336:	48 83 ec 28          	sub    $0x28,%rsp
  80233a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80233e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  802342:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  802346:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80234a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  80234e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802352:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  802356:	eb 36                	jmp    80238e <memcmp+0x5c>
		if (*s1 != *s2)
  802358:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80235c:	0f b6 10             	movzbl (%rax),%edx
  80235f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802363:	0f b6 00             	movzbl (%rax),%eax
  802366:	38 c2                	cmp    %al,%dl
  802368:	74 1a                	je     802384 <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  80236a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80236e:	0f b6 00             	movzbl (%rax),%eax
  802371:	0f b6 d0             	movzbl %al,%edx
  802374:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802378:	0f b6 00             	movzbl (%rax),%eax
  80237b:	0f b6 c0             	movzbl %al,%eax
  80237e:	29 c2                	sub    %eax,%edx
  802380:	89 d0                	mov    %edx,%eax
  802382:	eb 20                	jmp    8023a4 <memcmp+0x72>
		s1++, s2++;
  802384:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  802389:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80238e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802392:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  802396:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80239a:	48 85 c0             	test   %rax,%rax
  80239d:	75 b9                	jne    802358 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  80239f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8023a4:	c9                   	leaveq 
  8023a5:	c3                   	retq   

00000000008023a6 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  8023a6:	55                   	push   %rbp
  8023a7:	48 89 e5             	mov    %rsp,%rbp
  8023aa:	48 83 ec 28          	sub    $0x28,%rsp
  8023ae:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8023b2:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  8023b5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  8023b9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8023bd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8023c1:	48 01 d0             	add    %rdx,%rax
  8023c4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  8023c8:	eb 19                	jmp    8023e3 <memfind+0x3d>
		if (*(const unsigned char *) s == (unsigned char) c)
  8023ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8023ce:	0f b6 00             	movzbl (%rax),%eax
  8023d1:	0f b6 d0             	movzbl %al,%edx
  8023d4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8023d7:	0f b6 c0             	movzbl %al,%eax
  8023da:	39 c2                	cmp    %eax,%edx
  8023dc:	74 11                	je     8023ef <memfind+0x49>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  8023de:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8023e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8023e7:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8023eb:	72 dd                	jb     8023ca <memfind+0x24>
  8023ed:	eb 01                	jmp    8023f0 <memfind+0x4a>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
  8023ef:	90                   	nop
	return (void *) s;
  8023f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8023f4:	c9                   	leaveq 
  8023f5:	c3                   	retq   

00000000008023f6 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  8023f6:	55                   	push   %rbp
  8023f7:	48 89 e5             	mov    %rsp,%rbp
  8023fa:	48 83 ec 38          	sub    $0x38,%rsp
  8023fe:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  802402:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  802406:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  802409:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  802410:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  802417:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  802418:	eb 05                	jmp    80241f <strtol+0x29>
		s++;
  80241a:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80241f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802423:	0f b6 00             	movzbl (%rax),%eax
  802426:	3c 20                	cmp    $0x20,%al
  802428:	74 f0                	je     80241a <strtol+0x24>
  80242a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80242e:	0f b6 00             	movzbl (%rax),%eax
  802431:	3c 09                	cmp    $0x9,%al
  802433:	74 e5                	je     80241a <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  802435:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802439:	0f b6 00             	movzbl (%rax),%eax
  80243c:	3c 2b                	cmp    $0x2b,%al
  80243e:	75 07                	jne    802447 <strtol+0x51>
		s++;
  802440:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  802445:	eb 17                	jmp    80245e <strtol+0x68>
	else if (*s == '-')
  802447:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80244b:	0f b6 00             	movzbl (%rax),%eax
  80244e:	3c 2d                	cmp    $0x2d,%al
  802450:	75 0c                	jne    80245e <strtol+0x68>
		s++, neg = 1;
  802452:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  802457:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80245e:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  802462:	74 06                	je     80246a <strtol+0x74>
  802464:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  802468:	75 28                	jne    802492 <strtol+0x9c>
  80246a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80246e:	0f b6 00             	movzbl (%rax),%eax
  802471:	3c 30                	cmp    $0x30,%al
  802473:	75 1d                	jne    802492 <strtol+0x9c>
  802475:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802479:	48 83 c0 01          	add    $0x1,%rax
  80247d:	0f b6 00             	movzbl (%rax),%eax
  802480:	3c 78                	cmp    $0x78,%al
  802482:	75 0e                	jne    802492 <strtol+0x9c>
		s += 2, base = 16;
  802484:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  802489:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  802490:	eb 2c                	jmp    8024be <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  802492:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  802496:	75 19                	jne    8024b1 <strtol+0xbb>
  802498:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80249c:	0f b6 00             	movzbl (%rax),%eax
  80249f:	3c 30                	cmp    $0x30,%al
  8024a1:	75 0e                	jne    8024b1 <strtol+0xbb>
		s++, base = 8;
  8024a3:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8024a8:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  8024af:	eb 0d                	jmp    8024be <strtol+0xc8>
	else if (base == 0)
  8024b1:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8024b5:	75 07                	jne    8024be <strtol+0xc8>
		base = 10;
  8024b7:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  8024be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024c2:	0f b6 00             	movzbl (%rax),%eax
  8024c5:	3c 2f                	cmp    $0x2f,%al
  8024c7:	7e 1d                	jle    8024e6 <strtol+0xf0>
  8024c9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024cd:	0f b6 00             	movzbl (%rax),%eax
  8024d0:	3c 39                	cmp    $0x39,%al
  8024d2:	7f 12                	jg     8024e6 <strtol+0xf0>
			dig = *s - '0';
  8024d4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024d8:	0f b6 00             	movzbl (%rax),%eax
  8024db:	0f be c0             	movsbl %al,%eax
  8024de:	83 e8 30             	sub    $0x30,%eax
  8024e1:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8024e4:	eb 4e                	jmp    802534 <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  8024e6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024ea:	0f b6 00             	movzbl (%rax),%eax
  8024ed:	3c 60                	cmp    $0x60,%al
  8024ef:	7e 1d                	jle    80250e <strtol+0x118>
  8024f1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024f5:	0f b6 00             	movzbl (%rax),%eax
  8024f8:	3c 7a                	cmp    $0x7a,%al
  8024fa:	7f 12                	jg     80250e <strtol+0x118>
			dig = *s - 'a' + 10;
  8024fc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802500:	0f b6 00             	movzbl (%rax),%eax
  802503:	0f be c0             	movsbl %al,%eax
  802506:	83 e8 57             	sub    $0x57,%eax
  802509:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80250c:	eb 26                	jmp    802534 <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  80250e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802512:	0f b6 00             	movzbl (%rax),%eax
  802515:	3c 40                	cmp    $0x40,%al
  802517:	7e 47                	jle    802560 <strtol+0x16a>
  802519:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80251d:	0f b6 00             	movzbl (%rax),%eax
  802520:	3c 5a                	cmp    $0x5a,%al
  802522:	7f 3c                	jg     802560 <strtol+0x16a>
			dig = *s - 'A' + 10;
  802524:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802528:	0f b6 00             	movzbl (%rax),%eax
  80252b:	0f be c0             	movsbl %al,%eax
  80252e:	83 e8 37             	sub    $0x37,%eax
  802531:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  802534:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802537:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  80253a:	7d 23                	jge    80255f <strtol+0x169>
			break;
		s++, val = (val * base) + dig;
  80253c:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  802541:	8b 45 cc             	mov    -0x34(%rbp),%eax
  802544:	48 98                	cltq   
  802546:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  80254b:	48 89 c2             	mov    %rax,%rdx
  80254e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802551:	48 98                	cltq   
  802553:	48 01 d0             	add    %rdx,%rax
  802556:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  80255a:	e9 5f ff ff ff       	jmpq   8024be <strtol+0xc8>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
  80255f:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
  802560:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  802565:	74 0b                	je     802572 <strtol+0x17c>
		*endptr = (char *) s;
  802567:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80256b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80256f:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  802572:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  802576:	74 09                	je     802581 <strtol+0x18b>
  802578:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80257c:	48 f7 d8             	neg    %rax
  80257f:	eb 04                	jmp    802585 <strtol+0x18f>
  802581:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  802585:	c9                   	leaveq 
  802586:	c3                   	retq   

0000000000802587 <strstr>:

char * strstr(const char *in, const char *str)
{
  802587:	55                   	push   %rbp
  802588:	48 89 e5             	mov    %rsp,%rbp
  80258b:	48 83 ec 30          	sub    $0x30,%rsp
  80258f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  802593:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  802597:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80259b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80259f:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8025a3:	0f b6 00             	movzbl (%rax),%eax
  8025a6:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  8025a9:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  8025ad:	75 06                	jne    8025b5 <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  8025af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8025b3:	eb 6b                	jmp    802620 <strstr+0x99>

	len = strlen(str);
  8025b5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8025b9:	48 89 c7             	mov    %rax,%rdi
  8025bc:	48 b8 56 1e 80 00 00 	movabs $0x801e56,%rax
  8025c3:	00 00 00 
  8025c6:	ff d0                	callq  *%rax
  8025c8:	48 98                	cltq   
  8025ca:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  8025ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8025d2:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8025d6:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8025da:	0f b6 00             	movzbl (%rax),%eax
  8025dd:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  8025e0:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  8025e4:	75 07                	jne    8025ed <strstr+0x66>
				return (char *) 0;
  8025e6:	b8 00 00 00 00       	mov    $0x0,%eax
  8025eb:	eb 33                	jmp    802620 <strstr+0x99>
		} while (sc != c);
  8025ed:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8025f1:	3a 45 ff             	cmp    -0x1(%rbp),%al
  8025f4:	75 d8                	jne    8025ce <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  8025f6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8025fa:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8025fe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802602:	48 89 ce             	mov    %rcx,%rsi
  802605:	48 89 c7             	mov    %rax,%rdi
  802608:	48 b8 77 20 80 00 00 	movabs $0x802077,%rax
  80260f:	00 00 00 
  802612:	ff d0                	callq  *%rax
  802614:	85 c0                	test   %eax,%eax
  802616:	75 b6                	jne    8025ce <strstr+0x47>

	return (char *) (in - 1);
  802618:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80261c:	48 83 e8 01          	sub    $0x1,%rax
}
  802620:	c9                   	leaveq 
  802621:	c3                   	retq   

0000000000802622 <syscall>:
#include <inc/syscall.h>
#include <inc/lib.h>

static inline int64_t
syscall(int num, int check, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  802622:	55                   	push   %rbp
  802623:	48 89 e5             	mov    %rsp,%rbp
  802626:	53                   	push   %rbx
  802627:	48 83 ec 48          	sub    $0x48,%rsp
  80262b:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80262e:	89 75 d8             	mov    %esi,-0x28(%rbp)
  802631:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  802635:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  802639:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
  80263d:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  802641:	8b 45 dc             	mov    -0x24(%rbp),%eax
  802644:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  802648:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80264c:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
  802650:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  802654:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  802658:	4c 89 c3             	mov    %r8,%rbx
  80265b:	cd 30                	int    $0x30
  80265d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  802661:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  802665:	74 3e                	je     8026a5 <syscall+0x83>
  802667:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80266c:	7e 37                	jle    8026a5 <syscall+0x83>
		panic("syscall %d returned %d (> 0)", num, ret);
  80266e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  802672:	8b 45 dc             	mov    -0x24(%rbp),%eax
  802675:	49 89 d0             	mov    %rdx,%r8
  802678:	89 c1                	mov    %eax,%ecx
  80267a:	48 ba c8 14 82 00 00 	movabs $0x8214c8,%rdx
  802681:	00 00 00 
  802684:	be 24 00 00 00       	mov    $0x24,%esi
  802689:	48 bf e5 14 82 00 00 	movabs $0x8214e5,%rdi
  802690:	00 00 00 
  802693:	b8 00 00 00 00       	mov    $0x0,%eax
  802698:	49 b9 f8 10 80 00 00 	movabs $0x8010f8,%r9
  80269f:	00 00 00 
  8026a2:	41 ff d1             	callq  *%r9

	return ret;
  8026a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8026a9:	48 83 c4 48          	add    $0x48,%rsp
  8026ad:	5b                   	pop    %rbx
  8026ae:	5d                   	pop    %rbp
  8026af:	c3                   	retq   

00000000008026b0 <sys_cputs>:

void
sys_cputs(const char *s, size_t len)
{
  8026b0:	55                   	push   %rbp
  8026b1:	48 89 e5             	mov    %rsp,%rbp
  8026b4:	48 83 ec 10          	sub    $0x10,%rsp
  8026b8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8026bc:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	syscall(SYS_cputs, 0, (uint64_t)s, len, 0, 0, 0);
  8026c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8026c4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8026c8:	48 83 ec 08          	sub    $0x8,%rsp
  8026cc:	6a 00                	pushq  $0x0
  8026ce:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8026d4:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8026da:	48 89 d1             	mov    %rdx,%rcx
  8026dd:	48 89 c2             	mov    %rax,%rdx
  8026e0:	be 00 00 00 00       	mov    $0x0,%esi
  8026e5:	bf 00 00 00 00       	mov    $0x0,%edi
  8026ea:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  8026f1:	00 00 00 
  8026f4:	ff d0                	callq  *%rax
  8026f6:	48 83 c4 10          	add    $0x10,%rsp
}
  8026fa:	90                   	nop
  8026fb:	c9                   	leaveq 
  8026fc:	c3                   	retq   

00000000008026fd <sys_cgetc>:

int
sys_cgetc(void)
{
  8026fd:	55                   	push   %rbp
  8026fe:	48 89 e5             	mov    %rsp,%rbp
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
  802701:	48 83 ec 08          	sub    $0x8,%rsp
  802705:	6a 00                	pushq  $0x0
  802707:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80270d:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802713:	b9 00 00 00 00       	mov    $0x0,%ecx
  802718:	ba 00 00 00 00       	mov    $0x0,%edx
  80271d:	be 00 00 00 00       	mov    $0x0,%esi
  802722:	bf 01 00 00 00       	mov    $0x1,%edi
  802727:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  80272e:	00 00 00 
  802731:	ff d0                	callq  *%rax
  802733:	48 83 c4 10          	add    $0x10,%rsp
}
  802737:	c9                   	leaveq 
  802738:	c3                   	retq   

0000000000802739 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  802739:	55                   	push   %rbp
  80273a:	48 89 e5             	mov    %rsp,%rbp
  80273d:	48 83 ec 10          	sub    $0x10,%rsp
  802741:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
  802744:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802747:	48 98                	cltq   
  802749:	48 83 ec 08          	sub    $0x8,%rsp
  80274d:	6a 00                	pushq  $0x0
  80274f:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802755:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80275b:	b9 00 00 00 00       	mov    $0x0,%ecx
  802760:	48 89 c2             	mov    %rax,%rdx
  802763:	be 01 00 00 00       	mov    $0x1,%esi
  802768:	bf 03 00 00 00       	mov    $0x3,%edi
  80276d:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802774:	00 00 00 
  802777:	ff d0                	callq  *%rax
  802779:	48 83 c4 10          	add    $0x10,%rsp
}
  80277d:	c9                   	leaveq 
  80277e:	c3                   	retq   

000000000080277f <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80277f:	55                   	push   %rbp
  802780:	48 89 e5             	mov    %rsp,%rbp
	return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
  802783:	48 83 ec 08          	sub    $0x8,%rsp
  802787:	6a 00                	pushq  $0x0
  802789:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80278f:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802795:	b9 00 00 00 00       	mov    $0x0,%ecx
  80279a:	ba 00 00 00 00       	mov    $0x0,%edx
  80279f:	be 00 00 00 00       	mov    $0x0,%esi
  8027a4:	bf 02 00 00 00       	mov    $0x2,%edi
  8027a9:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  8027b0:	00 00 00 
  8027b3:	ff d0                	callq  *%rax
  8027b5:	48 83 c4 10          	add    $0x10,%rsp
}
  8027b9:	c9                   	leaveq 
  8027ba:	c3                   	retq   

00000000008027bb <sys_yield>:


void
sys_yield(void)
{
  8027bb:	55                   	push   %rbp
  8027bc:	48 89 e5             	mov    %rsp,%rbp
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
  8027bf:	48 83 ec 08          	sub    $0x8,%rsp
  8027c3:	6a 00                	pushq  $0x0
  8027c5:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8027cb:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8027d1:	b9 00 00 00 00       	mov    $0x0,%ecx
  8027d6:	ba 00 00 00 00       	mov    $0x0,%edx
  8027db:	be 00 00 00 00       	mov    $0x0,%esi
  8027e0:	bf 0b 00 00 00       	mov    $0xb,%edi
  8027e5:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  8027ec:	00 00 00 
  8027ef:	ff d0                	callq  *%rax
  8027f1:	48 83 c4 10          	add    $0x10,%rsp
}
  8027f5:	90                   	nop
  8027f6:	c9                   	leaveq 
  8027f7:	c3                   	retq   

00000000008027f8 <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  8027f8:	55                   	push   %rbp
  8027f9:	48 89 e5             	mov    %rsp,%rbp
  8027fc:	48 83 ec 10          	sub    $0x10,%rsp
  802800:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802803:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802807:	89 55 f8             	mov    %edx,-0x8(%rbp)
	return syscall(SYS_page_alloc, 1, envid, (uint64_t) va, perm, 0, 0);
  80280a:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80280d:	48 63 c8             	movslq %eax,%rcx
  802810:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802814:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802817:	48 98                	cltq   
  802819:	48 83 ec 08          	sub    $0x8,%rsp
  80281d:	6a 00                	pushq  $0x0
  80281f:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802825:	49 89 c8             	mov    %rcx,%r8
  802828:	48 89 d1             	mov    %rdx,%rcx
  80282b:	48 89 c2             	mov    %rax,%rdx
  80282e:	be 01 00 00 00       	mov    $0x1,%esi
  802833:	bf 04 00 00 00       	mov    $0x4,%edi
  802838:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  80283f:	00 00 00 
  802842:	ff d0                	callq  *%rax
  802844:	48 83 c4 10          	add    $0x10,%rsp
}
  802848:	c9                   	leaveq 
  802849:	c3                   	retq   

000000000080284a <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80284a:	55                   	push   %rbp
  80284b:	48 89 e5             	mov    %rsp,%rbp
  80284e:	48 83 ec 20          	sub    $0x20,%rsp
  802852:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802855:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802859:	89 55 f8             	mov    %edx,-0x8(%rbp)
  80285c:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  802860:	44 89 45 e4          	mov    %r8d,-0x1c(%rbp)
	return syscall(SYS_page_map, 1, srcenv, (uint64_t) srcva, dstenv, (uint64_t) dstva, perm);
  802864:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  802867:	48 63 c8             	movslq %eax,%rcx
  80286a:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  80286e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802871:	48 63 f0             	movslq %eax,%rsi
  802874:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802878:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80287b:	48 98                	cltq   
  80287d:	48 83 ec 08          	sub    $0x8,%rsp
  802881:	51                   	push   %rcx
  802882:	49 89 f9             	mov    %rdi,%r9
  802885:	49 89 f0             	mov    %rsi,%r8
  802888:	48 89 d1             	mov    %rdx,%rcx
  80288b:	48 89 c2             	mov    %rax,%rdx
  80288e:	be 01 00 00 00       	mov    $0x1,%esi
  802893:	bf 05 00 00 00       	mov    $0x5,%edi
  802898:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  80289f:	00 00 00 
  8028a2:	ff d0                	callq  *%rax
  8028a4:	48 83 c4 10          	add    $0x10,%rsp
}
  8028a8:	c9                   	leaveq 
  8028a9:	c3                   	retq   

00000000008028aa <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  8028aa:	55                   	push   %rbp
  8028ab:	48 89 e5             	mov    %rsp,%rbp
  8028ae:	48 83 ec 10          	sub    $0x10,%rsp
  8028b2:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8028b5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_page_unmap, 1, envid, (uint64_t) va, 0, 0, 0);
  8028b9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8028bd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8028c0:	48 98                	cltq   
  8028c2:	48 83 ec 08          	sub    $0x8,%rsp
  8028c6:	6a 00                	pushq  $0x0
  8028c8:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8028ce:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8028d4:	48 89 d1             	mov    %rdx,%rcx
  8028d7:	48 89 c2             	mov    %rax,%rdx
  8028da:	be 01 00 00 00       	mov    $0x1,%esi
  8028df:	bf 06 00 00 00       	mov    $0x6,%edi
  8028e4:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  8028eb:	00 00 00 
  8028ee:	ff d0                	callq  *%rax
  8028f0:	48 83 c4 10          	add    $0x10,%rsp
}
  8028f4:	c9                   	leaveq 
  8028f5:	c3                   	retq   

00000000008028f6 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  8028f6:	55                   	push   %rbp
  8028f7:	48 89 e5             	mov    %rsp,%rbp
  8028fa:	48 83 ec 10          	sub    $0x10,%rsp
  8028fe:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802901:	89 75 f8             	mov    %esi,-0x8(%rbp)
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
  802904:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802907:	48 63 d0             	movslq %eax,%rdx
  80290a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80290d:	48 98                	cltq   
  80290f:	48 83 ec 08          	sub    $0x8,%rsp
  802913:	6a 00                	pushq  $0x0
  802915:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80291b:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802921:	48 89 d1             	mov    %rdx,%rcx
  802924:	48 89 c2             	mov    %rax,%rdx
  802927:	be 01 00 00 00       	mov    $0x1,%esi
  80292c:	bf 08 00 00 00       	mov    $0x8,%edi
  802931:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802938:	00 00 00 
  80293b:	ff d0                	callq  *%rax
  80293d:	48 83 c4 10          	add    $0x10,%rsp
}
  802941:	c9                   	leaveq 
  802942:	c3                   	retq   

0000000000802943 <sys_env_set_trapframe>:


int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  802943:	55                   	push   %rbp
  802944:	48 89 e5             	mov    %rsp,%rbp
  802947:	48 83 ec 10          	sub    $0x10,%rsp
  80294b:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80294e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_env_set_trapframe, 1, envid, (uint64_t) tf, 0, 0, 0);
  802952:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802956:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802959:	48 98                	cltq   
  80295b:	48 83 ec 08          	sub    $0x8,%rsp
  80295f:	6a 00                	pushq  $0x0
  802961:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802967:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80296d:	48 89 d1             	mov    %rdx,%rcx
  802970:	48 89 c2             	mov    %rax,%rdx
  802973:	be 01 00 00 00       	mov    $0x1,%esi
  802978:	bf 09 00 00 00       	mov    $0x9,%edi
  80297d:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802984:	00 00 00 
  802987:	ff d0                	callq  *%rax
  802989:	48 83 c4 10          	add    $0x10,%rsp
}
  80298d:	c9                   	leaveq 
  80298e:	c3                   	retq   

000000000080298f <sys_env_set_pgfault_upcall>:


int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80298f:	55                   	push   %rbp
  802990:	48 89 e5             	mov    %rsp,%rbp
  802993:	48 83 ec 10          	sub    $0x10,%rsp
  802997:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80299a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint64_t) upcall, 0, 0, 0);
  80299e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8029a2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8029a5:	48 98                	cltq   
  8029a7:	48 83 ec 08          	sub    $0x8,%rsp
  8029ab:	6a 00                	pushq  $0x0
  8029ad:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8029b3:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8029b9:	48 89 d1             	mov    %rdx,%rcx
  8029bc:	48 89 c2             	mov    %rax,%rdx
  8029bf:	be 01 00 00 00       	mov    $0x1,%esi
  8029c4:	bf 0a 00 00 00       	mov    $0xa,%edi
  8029c9:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  8029d0:	00 00 00 
  8029d3:	ff d0                	callq  *%rax
  8029d5:	48 83 c4 10          	add    $0x10,%rsp
}
  8029d9:	c9                   	leaveq 
  8029da:	c3                   	retq   

00000000008029db <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint64_t value, void *srcva, int perm)
{
  8029db:	55                   	push   %rbp
  8029dc:	48 89 e5             	mov    %rsp,%rbp
  8029df:	48 83 ec 20          	sub    $0x20,%rsp
  8029e3:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8029e6:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8029ea:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8029ee:	89 4d f8             	mov    %ecx,-0x8(%rbp)
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint64_t) srcva, perm, 0);
  8029f1:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8029f4:	48 63 f0             	movslq %eax,%rsi
  8029f7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8029fb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8029fe:	48 98                	cltq   
  802a00:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802a04:	48 83 ec 08          	sub    $0x8,%rsp
  802a08:	6a 00                	pushq  $0x0
  802a0a:	49 89 f1             	mov    %rsi,%r9
  802a0d:	49 89 c8             	mov    %rcx,%r8
  802a10:	48 89 d1             	mov    %rdx,%rcx
  802a13:	48 89 c2             	mov    %rax,%rdx
  802a16:	be 00 00 00 00       	mov    $0x0,%esi
  802a1b:	bf 0c 00 00 00       	mov    $0xc,%edi
  802a20:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802a27:	00 00 00 
  802a2a:	ff d0                	callq  *%rax
  802a2c:	48 83 c4 10          	add    $0x10,%rsp
}
  802a30:	c9                   	leaveq 
  802a31:	c3                   	retq   

0000000000802a32 <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  802a32:	55                   	push   %rbp
  802a33:	48 89 e5             	mov    %rsp,%rbp
  802a36:	48 83 ec 10          	sub    $0x10,%rsp
  802a3a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return syscall(SYS_ipc_recv, 1, (uint64_t)dstva, 0, 0, 0, 0);
  802a3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802a42:	48 83 ec 08          	sub    $0x8,%rsp
  802a46:	6a 00                	pushq  $0x0
  802a48:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802a4e:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802a54:	b9 00 00 00 00       	mov    $0x0,%ecx
  802a59:	48 89 c2             	mov    %rax,%rdx
  802a5c:	be 01 00 00 00       	mov    $0x1,%esi
  802a61:	bf 0d 00 00 00       	mov    $0xd,%edi
  802a66:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802a6d:	00 00 00 
  802a70:	ff d0                	callq  *%rax
  802a72:	48 83 c4 10          	add    $0x10,%rsp
}
  802a76:	c9                   	leaveq 
  802a77:	c3                   	retq   

0000000000802a78 <sys_time_msec>:


unsigned int
sys_time_msec(void)
{
  802a78:	55                   	push   %rbp
  802a79:	48 89 e5             	mov    %rsp,%rbp
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
  802a7c:	48 83 ec 08          	sub    $0x8,%rsp
  802a80:	6a 00                	pushq  $0x0
  802a82:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802a88:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802a8e:	b9 00 00 00 00       	mov    $0x0,%ecx
  802a93:	ba 00 00 00 00       	mov    $0x0,%edx
  802a98:	be 00 00 00 00       	mov    $0x0,%esi
  802a9d:	bf 0e 00 00 00       	mov    $0xe,%edi
  802aa2:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802aa9:	00 00 00 
  802aac:	ff d0                	callq  *%rax
  802aae:	48 83 c4 10          	add    $0x10,%rsp
}
  802ab2:	c9                   	leaveq 
  802ab3:	c3                   	retq   

0000000000802ab4 <sys_net_transmit>:


int
sys_net_transmit(const char *data, unsigned int len)
{
  802ab4:	55                   	push   %rbp
  802ab5:	48 89 e5             	mov    %rsp,%rbp
  802ab8:	48 83 ec 10          	sub    $0x10,%rsp
  802abc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802ac0:	89 75 f4             	mov    %esi,-0xc(%rbp)
	return syscall(SYS_net_transmit, 0, (uint64_t)data, len, 0, 0, 0);
  802ac3:	8b 55 f4             	mov    -0xc(%rbp),%edx
  802ac6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802aca:	48 83 ec 08          	sub    $0x8,%rsp
  802ace:	6a 00                	pushq  $0x0
  802ad0:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802ad6:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802adc:	48 89 d1             	mov    %rdx,%rcx
  802adf:	48 89 c2             	mov    %rax,%rdx
  802ae2:	be 00 00 00 00       	mov    $0x0,%esi
  802ae7:	bf 0f 00 00 00       	mov    $0xf,%edi
  802aec:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802af3:	00 00 00 
  802af6:	ff d0                	callq  *%rax
  802af8:	48 83 c4 10          	add    $0x10,%rsp
}
  802afc:	c9                   	leaveq 
  802afd:	c3                   	retq   

0000000000802afe <sys_net_receive>:

int
sys_net_receive(char *buf, unsigned int len)
{
  802afe:	55                   	push   %rbp
  802aff:	48 89 e5             	mov    %rsp,%rbp
  802b02:	48 83 ec 10          	sub    $0x10,%rsp
  802b06:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802b0a:	89 75 f4             	mov    %esi,-0xc(%rbp)
	return syscall(SYS_net_receive, 0, (uint64_t)buf, len, 0, 0, 0);
  802b0d:	8b 55 f4             	mov    -0xc(%rbp),%edx
  802b10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802b14:	48 83 ec 08          	sub    $0x8,%rsp
  802b18:	6a 00                	pushq  $0x0
  802b1a:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802b20:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802b26:	48 89 d1             	mov    %rdx,%rcx
  802b29:	48 89 c2             	mov    %rax,%rdx
  802b2c:	be 00 00 00 00       	mov    $0x0,%esi
  802b31:	bf 10 00 00 00       	mov    $0x10,%edi
  802b36:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802b3d:	00 00 00 
  802b40:	ff d0                	callq  *%rax
  802b42:	48 83 c4 10          	add    $0x10,%rsp
}
  802b46:	c9                   	leaveq 
  802b47:	c3                   	retq   

0000000000802b48 <sys_ept_map>:



int
sys_ept_map(envid_t srcenvid, void *srcva, envid_t guest, void* guest_pa, int perm) 
{
  802b48:	55                   	push   %rbp
  802b49:	48 89 e5             	mov    %rsp,%rbp
  802b4c:	48 83 ec 20          	sub    $0x20,%rsp
  802b50:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802b53:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802b57:	89 55 f8             	mov    %edx,-0x8(%rbp)
  802b5a:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  802b5e:	44 89 45 e4          	mov    %r8d,-0x1c(%rbp)
	return syscall(SYS_ept_map, 0, srcenvid, 
  802b62:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  802b65:	48 63 c8             	movslq %eax,%rcx
  802b68:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  802b6c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802b6f:	48 63 f0             	movslq %eax,%rsi
  802b72:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802b76:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802b79:	48 98                	cltq   
  802b7b:	48 83 ec 08          	sub    $0x8,%rsp
  802b7f:	51                   	push   %rcx
  802b80:	49 89 f9             	mov    %rdi,%r9
  802b83:	49 89 f0             	mov    %rsi,%r8
  802b86:	48 89 d1             	mov    %rdx,%rcx
  802b89:	48 89 c2             	mov    %rax,%rdx
  802b8c:	be 00 00 00 00       	mov    $0x0,%esi
  802b91:	bf 11 00 00 00       	mov    $0x11,%edi
  802b96:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802b9d:	00 00 00 
  802ba0:	ff d0                	callq  *%rax
  802ba2:	48 83 c4 10          	add    $0x10,%rsp
		       (uint64_t)srcva, guest, (uint64_t)guest_pa, perm);
}
  802ba6:	c9                   	leaveq 
  802ba7:	c3                   	retq   

0000000000802ba8 <sys_env_mkguest>:

envid_t
sys_env_mkguest(uint64_t gphysz, uint64_t gRIP) {
  802ba8:	55                   	push   %rbp
  802ba9:	48 89 e5             	mov    %rsp,%rbp
  802bac:	48 83 ec 10          	sub    $0x10,%rsp
  802bb0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802bb4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return (envid_t) syscall(SYS_env_mkguest, 0, gphysz, gRIP, 0, 0, 0);
  802bb8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802bbc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802bc0:	48 83 ec 08          	sub    $0x8,%rsp
  802bc4:	6a 00                	pushq  $0x0
  802bc6:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802bcc:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802bd2:	48 89 d1             	mov    %rdx,%rcx
  802bd5:	48 89 c2             	mov    %rax,%rdx
  802bd8:	be 00 00 00 00       	mov    $0x0,%esi
  802bdd:	bf 12 00 00 00       	mov    $0x12,%edi
  802be2:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802be9:	00 00 00 
  802bec:	ff d0                	callq  *%rax
  802bee:	48 83 c4 10          	add    $0x10,%rsp
}
  802bf2:	c9                   	leaveq 
  802bf3:	c3                   	retq   

0000000000802bf4 <sys_vmx_list_vms>:
#ifndef VMM_GUEST
void
sys_vmx_list_vms() {
  802bf4:	55                   	push   %rbp
  802bf5:	48 89 e5             	mov    %rsp,%rbp
	syscall(SYS_vmx_list_vms, 0, 0, 
  802bf8:	48 83 ec 08          	sub    $0x8,%rsp
  802bfc:	6a 00                	pushq  $0x0
  802bfe:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802c04:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802c0a:	b9 00 00 00 00       	mov    $0x0,%ecx
  802c0f:	ba 00 00 00 00       	mov    $0x0,%edx
  802c14:	be 00 00 00 00       	mov    $0x0,%esi
  802c19:	bf 13 00 00 00       	mov    $0x13,%edi
  802c1e:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802c25:	00 00 00 
  802c28:	ff d0                	callq  *%rax
  802c2a:	48 83 c4 10          	add    $0x10,%rsp
		       0, 0, 0, 0);
}
  802c2e:	90                   	nop
  802c2f:	c9                   	leaveq 
  802c30:	c3                   	retq   

0000000000802c31 <sys_vmx_sel_resume>:

int
sys_vmx_sel_resume(int i) {
  802c31:	55                   	push   %rbp
  802c32:	48 89 e5             	mov    %rsp,%rbp
  802c35:	48 83 ec 10          	sub    $0x10,%rsp
  802c39:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return syscall(SYS_vmx_sel_resume, 0, i, 0, 0, 0, 0);
  802c3c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802c3f:	48 98                	cltq   
  802c41:	48 83 ec 08          	sub    $0x8,%rsp
  802c45:	6a 00                	pushq  $0x0
  802c47:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802c4d:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802c53:	b9 00 00 00 00       	mov    $0x0,%ecx
  802c58:	48 89 c2             	mov    %rax,%rdx
  802c5b:	be 00 00 00 00       	mov    $0x0,%esi
  802c60:	bf 14 00 00 00       	mov    $0x14,%edi
  802c65:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802c6c:	00 00 00 
  802c6f:	ff d0                	callq  *%rax
  802c71:	48 83 c4 10          	add    $0x10,%rsp
}
  802c75:	c9                   	leaveq 
  802c76:	c3                   	retq   

0000000000802c77 <sys_vmx_get_vmdisk_number>:
int
sys_vmx_get_vmdisk_number() {
  802c77:	55                   	push   %rbp
  802c78:	48 89 e5             	mov    %rsp,%rbp
	return syscall(SYS_vmx_get_vmdisk_number, 0, 0, 0, 0, 0, 0);
  802c7b:	48 83 ec 08          	sub    $0x8,%rsp
  802c7f:	6a 00                	pushq  $0x0
  802c81:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802c87:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802c8d:	b9 00 00 00 00       	mov    $0x0,%ecx
  802c92:	ba 00 00 00 00       	mov    $0x0,%edx
  802c97:	be 00 00 00 00       	mov    $0x0,%esi
  802c9c:	bf 15 00 00 00       	mov    $0x15,%edi
  802ca1:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802ca8:	00 00 00 
  802cab:	ff d0                	callq  *%rax
  802cad:	48 83 c4 10          	add    $0x10,%rsp
}
  802cb1:	c9                   	leaveq 
  802cb2:	c3                   	retq   

0000000000802cb3 <sys_vmx_incr_vmdisk_number>:

void
sys_vmx_incr_vmdisk_number() {
  802cb3:	55                   	push   %rbp
  802cb4:	48 89 e5             	mov    %rsp,%rbp
	syscall(SYS_vmx_incr_vmdisk_number, 0, 0, 0, 0, 0, 0);
  802cb7:	48 83 ec 08          	sub    $0x8,%rsp
  802cbb:	6a 00                	pushq  $0x0
  802cbd:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802cc3:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802cc9:	b9 00 00 00 00       	mov    $0x0,%ecx
  802cce:	ba 00 00 00 00       	mov    $0x0,%edx
  802cd3:	be 00 00 00 00       	mov    $0x0,%esi
  802cd8:	bf 16 00 00 00       	mov    $0x16,%edi
  802cdd:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802ce4:	00 00 00 
  802ce7:	ff d0                	callq  *%rax
  802ce9:	48 83 c4 10          	add    $0x10,%rsp
}
  802ced:	90                   	nop
  802cee:	c9                   	leaveq 
  802cef:	c3                   	retq   

0000000000802cf0 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  802cf0:	55                   	push   %rbp
  802cf1:	48 89 e5             	mov    %rsp,%rbp
  802cf4:	48 83 ec 30          	sub    $0x30,%rsp
  802cf8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	void *addr = (void *) utf->utf_fault_va;
  802cfc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802d00:	48 8b 00             	mov    (%rax),%rax
  802d03:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	uint32_t err = utf->utf_err;
  802d07:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802d0b:	48 8b 40 08          	mov    0x8(%rax),%rax
  802d0f:	89 45 fc             	mov    %eax,-0x4(%rbp)


	if (debug)
		cprintf("fault %08x %08x %d from %08x\n", addr, &uvpt[PGNUM(addr)], err & 7, (&addr)[4]);

	if (!(err & FEC_WR))
  802d12:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802d15:	83 e0 02             	and    $0x2,%eax
  802d18:	85 c0                	test   %eax,%eax
  802d1a:	75 40                	jne    802d5c <pgfault+0x6c>
		panic("read fault at %x, rip %x", addr, utf->utf_rip);
  802d1c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802d20:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  802d27:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802d2b:	49 89 d0             	mov    %rdx,%r8
  802d2e:	48 89 c1             	mov    %rax,%rcx
  802d31:	48 ba f8 14 82 00 00 	movabs $0x8214f8,%rdx
  802d38:	00 00 00 
  802d3b:	be 1f 00 00 00       	mov    $0x1f,%esi
  802d40:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  802d47:	00 00 00 
  802d4a:	b8 00 00 00 00       	mov    $0x0,%eax
  802d4f:	49 b9 f8 10 80 00 00 	movabs $0x8010f8,%r9
  802d56:	00 00 00 
  802d59:	41 ff d1             	callq  *%r9
	if ((uvpt[PGNUM(addr)] & (PTE_P|PTE_U|PTE_W|PTE_COW)) != (PTE_P|PTE_U|PTE_COW))
  802d5c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802d60:	48 c1 e8 0c          	shr    $0xc,%rax
  802d64:	48 89 c2             	mov    %rax,%rdx
  802d67:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802d6e:	01 00 00 
  802d71:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802d75:	25 07 08 00 00       	and    $0x807,%eax
  802d7a:	48 3d 05 08 00 00    	cmp    $0x805,%rax
  802d80:	74 4e                	je     802dd0 <pgfault+0xe0>
		panic("fault at %x with pte %x, not copy-on-write",
  802d82:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802d86:	48 c1 e8 0c          	shr    $0xc,%rax
  802d8a:	48 89 c2             	mov    %rax,%rdx
  802d8d:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802d94:	01 00 00 
  802d97:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  802d9b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802d9f:	49 89 d0             	mov    %rdx,%r8
  802da2:	48 89 c1             	mov    %rax,%rcx
  802da5:	48 ba 20 15 82 00 00 	movabs $0x821520,%rdx
  802dac:	00 00 00 
  802daf:	be 22 00 00 00       	mov    $0x22,%esi
  802db4:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  802dbb:	00 00 00 
  802dbe:	b8 00 00 00 00       	mov    $0x0,%eax
  802dc3:	49 b9 f8 10 80 00 00 	movabs $0x8010f8,%r9
  802dca:	00 00 00 
  802dcd:	41 ff d1             	callq  *%r9
		      addr, uvpt[PGNUM(addr)]);



	// copy page
	if ((r = sys_page_alloc(0, (void*) PFTEMP, PTE_P|PTE_U|PTE_W)) < 0)
  802dd0:	ba 07 00 00 00       	mov    $0x7,%edx
  802dd5:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802dda:	bf 00 00 00 00       	mov    $0x0,%edi
  802ddf:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  802de6:	00 00 00 
  802de9:	ff d0                	callq  *%rax
  802deb:	89 45 f8             	mov    %eax,-0x8(%rbp)
  802dee:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  802df2:	79 30                	jns    802e24 <pgfault+0x134>
		panic("sys_page_alloc: %e", r);
  802df4:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802df7:	89 c1                	mov    %eax,%ecx
  802df9:	48 ba 4b 15 82 00 00 	movabs $0x82154b,%rdx
  802e00:	00 00 00 
  802e03:	be 28 00 00 00       	mov    $0x28,%esi
  802e08:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  802e0f:	00 00 00 
  802e12:	b8 00 00 00 00       	mov    $0x0,%eax
  802e17:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  802e1e:	00 00 00 
  802e21:	41 ff d0             	callq  *%r8
	memmove((void*) PFTEMP, ROUNDDOWN(addr, PGSIZE), PGSIZE);
  802e24:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802e28:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  802e2c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802e30:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  802e36:	ba 00 10 00 00       	mov    $0x1000,%edx
  802e3b:	48 89 c6             	mov    %rax,%rsi
  802e3e:	bf 00 f0 5f 00       	mov    $0x5ff000,%edi
  802e43:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  802e4a:	00 00 00 
  802e4d:	ff d0                	callq  *%rax

	// remap over faulting page
	if ((r = sys_page_map(0, (void*) PFTEMP, 0, ROUNDDOWN(addr, PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
  802e4f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802e53:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  802e57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802e5b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  802e61:	41 b8 07 00 00 00    	mov    $0x7,%r8d
  802e67:	48 89 c1             	mov    %rax,%rcx
  802e6a:	ba 00 00 00 00       	mov    $0x0,%edx
  802e6f:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802e74:	bf 00 00 00 00       	mov    $0x0,%edi
  802e79:	48 b8 4a 28 80 00 00 	movabs $0x80284a,%rax
  802e80:	00 00 00 
  802e83:	ff d0                	callq  *%rax
  802e85:	89 45 f8             	mov    %eax,-0x8(%rbp)
  802e88:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  802e8c:	79 30                	jns    802ebe <pgfault+0x1ce>
		panic("sys_page_map: %e", r);
  802e8e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802e91:	89 c1                	mov    %eax,%ecx
  802e93:	48 ba 5e 15 82 00 00 	movabs $0x82155e,%rdx
  802e9a:	00 00 00 
  802e9d:	be 2d 00 00 00       	mov    $0x2d,%esi
  802ea2:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  802ea9:	00 00 00 
  802eac:	b8 00 00 00 00       	mov    $0x0,%eax
  802eb1:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  802eb8:	00 00 00 
  802ebb:	41 ff d0             	callq  *%r8

	// unmap our work space
	if ((r = sys_page_unmap(0, (void*) PFTEMP)) < 0)
  802ebe:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802ec3:	bf 00 00 00 00       	mov    $0x0,%edi
  802ec8:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  802ecf:	00 00 00 
  802ed2:	ff d0                	callq  *%rax
  802ed4:	89 45 f8             	mov    %eax,-0x8(%rbp)
  802ed7:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  802edb:	79 30                	jns    802f0d <pgfault+0x21d>
		panic("sys_page_unmap: %e", r);
  802edd:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802ee0:	89 c1                	mov    %eax,%ecx
  802ee2:	48 ba 6f 15 82 00 00 	movabs $0x82156f,%rdx
  802ee9:	00 00 00 
  802eec:	be 31 00 00 00       	mov    $0x31,%esi
  802ef1:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  802ef8:	00 00 00 
  802efb:	b8 00 00 00 00       	mov    $0x0,%eax
  802f00:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  802f07:	00 00 00 
  802f0a:	41 ff d0             	callq  *%r8

}
  802f0d:	90                   	nop
  802f0e:	c9                   	leaveq 
  802f0f:	c3                   	retq   

0000000000802f10 <duppage>:
// Returns: 0 on success, < 0 on error.
// It is also OK to panic on error.
//
static int
duppage(envid_t envid, unsigned pn)
{
  802f10:	55                   	push   %rbp
  802f11:	48 89 e5             	mov    %rsp,%rbp
  802f14:	48 83 ec 30          	sub    $0x30,%rsp
  802f18:	89 7d dc             	mov    %edi,-0x24(%rbp)
  802f1b:	89 75 d8             	mov    %esi,-0x28(%rbp)


	void *addr;
	pte_t pte;

	addr = (void*) (uint64_t)(pn << PGSHIFT);
  802f1e:	8b 45 d8             	mov    -0x28(%rbp),%eax
  802f21:	c1 e0 0c             	shl    $0xc,%eax
  802f24:	89 c0                	mov    %eax,%eax
  802f26:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	pte = uvpt[pn];
  802f2a:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802f31:	01 00 00 
  802f34:	8b 55 d8             	mov    -0x28(%rbp),%edx
  802f37:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802f3b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	

	// if the page is just read-only or is library-shared, map it directly.
	if (!(pte & (PTE_W|PTE_COW)) || (pte & PTE_SHARE)) {
  802f3f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802f43:	25 02 08 00 00       	and    $0x802,%eax
  802f48:	48 85 c0             	test   %rax,%rax
  802f4b:	74 0e                	je     802f5b <duppage+0x4b>
  802f4d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802f51:	25 00 04 00 00       	and    $0x400,%eax
  802f56:	48 85 c0             	test   %rax,%rax
  802f59:	74 70                	je     802fcb <duppage+0xbb>
		if ((r = sys_page_map(0, addr, envid, addr, pte & PTE_SYSCALL)) < 0)
  802f5b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802f5f:	25 07 0e 00 00       	and    $0xe07,%eax
  802f64:	89 c6                	mov    %eax,%esi
  802f66:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  802f6a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  802f6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802f71:	41 89 f0             	mov    %esi,%r8d
  802f74:	48 89 c6             	mov    %rax,%rsi
  802f77:	bf 00 00 00 00       	mov    $0x0,%edi
  802f7c:	48 b8 4a 28 80 00 00 	movabs $0x80284a,%rax
  802f83:	00 00 00 
  802f86:	ff d0                	callq  *%rax
  802f88:	89 45 ec             	mov    %eax,-0x14(%rbp)
  802f8b:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  802f8f:	79 30                	jns    802fc1 <duppage+0xb1>
			panic("sys_page_map: %e", r);
  802f91:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802f94:	89 c1                	mov    %eax,%ecx
  802f96:	48 ba 5e 15 82 00 00 	movabs $0x82155e,%rdx
  802f9d:	00 00 00 
  802fa0:	be 50 00 00 00       	mov    $0x50,%esi
  802fa5:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  802fac:	00 00 00 
  802faf:	b8 00 00 00 00       	mov    $0x0,%eax
  802fb4:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  802fbb:	00 00 00 
  802fbe:	41 ff d0             	callq  *%r8
		return 0;
  802fc1:	b8 00 00 00 00       	mov    $0x0,%eax
  802fc6:	e9 c4 00 00 00       	jmpq   80308f <duppage+0x17f>
	// Even if we think the page is already copy-on-write in our
	// address space, we need to mark it copy-on-write again after
	// the first sys_page_map, just in case a page fault has caused
	// us to copy the page in the interim.

	if ((r = sys_page_map(0, addr, envid, addr, PTE_P|PTE_U|PTE_COW)) < 0)
  802fcb:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  802fcf:	8b 55 dc             	mov    -0x24(%rbp),%edx
  802fd2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802fd6:	41 b8 05 08 00 00    	mov    $0x805,%r8d
  802fdc:	48 89 c6             	mov    %rax,%rsi
  802fdf:	bf 00 00 00 00       	mov    $0x0,%edi
  802fe4:	48 b8 4a 28 80 00 00 	movabs $0x80284a,%rax
  802feb:	00 00 00 
  802fee:	ff d0                	callq  *%rax
  802ff0:	89 45 ec             	mov    %eax,-0x14(%rbp)
  802ff3:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  802ff7:	79 30                	jns    803029 <duppage+0x119>
		panic("sys_page_map: %e", r);
  802ff9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802ffc:	89 c1                	mov    %eax,%ecx
  802ffe:	48 ba 5e 15 82 00 00 	movabs $0x82155e,%rdx
  803005:	00 00 00 
  803008:	be 64 00 00 00       	mov    $0x64,%esi
  80300d:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  803014:	00 00 00 
  803017:	b8 00 00 00 00       	mov    $0x0,%eax
  80301c:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  803023:	00 00 00 
  803026:	41 ff d0             	callq  *%r8
	if ((r = sys_page_map(0, addr, 0, addr, PTE_P|PTE_U|PTE_COW)) < 0)
  803029:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80302d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803031:	41 b8 05 08 00 00    	mov    $0x805,%r8d
  803037:	48 89 d1             	mov    %rdx,%rcx
  80303a:	ba 00 00 00 00       	mov    $0x0,%edx
  80303f:	48 89 c6             	mov    %rax,%rsi
  803042:	bf 00 00 00 00       	mov    $0x0,%edi
  803047:	48 b8 4a 28 80 00 00 	movabs $0x80284a,%rax
  80304e:	00 00 00 
  803051:	ff d0                	callq  *%rax
  803053:	89 45 ec             	mov    %eax,-0x14(%rbp)
  803056:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80305a:	79 30                	jns    80308c <duppage+0x17c>
		panic("sys_page_map: %e", r);
  80305c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80305f:	89 c1                	mov    %eax,%ecx
  803061:	48 ba 5e 15 82 00 00 	movabs $0x82155e,%rdx
  803068:	00 00 00 
  80306b:	be 66 00 00 00       	mov    $0x66,%esi
  803070:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  803077:	00 00 00 
  80307a:	b8 00 00 00 00       	mov    $0x0,%eax
  80307f:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  803086:	00 00 00 
  803089:	41 ff d0             	callq  *%r8
	return r;
  80308c:	8b 45 ec             	mov    -0x14(%rbp),%eax

}
  80308f:	c9                   	leaveq 
  803090:	c3                   	retq   

0000000000803091 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  803091:	55                   	push   %rbp
  803092:	48 89 e5             	mov    %rsp,%rbp
  803095:	48 83 ec 20          	sub    $0x20,%rsp

	envid_t envid;
	int pn, end_pn, r;

	set_pgfault_handler(pgfault);
  803099:	48 bf f0 2c 80 00 00 	movabs $0x802cf0,%rdi
  8030a0:	00 00 00 
  8030a3:	48 b8 fc 5a 80 00 00 	movabs $0x805afc,%rax
  8030aa:	00 00 00 
  8030ad:	ff d0                	callq  *%rax
// This must be inlined.  Exercise for reader: why?
static __inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	__asm __volatile("int %2"
  8030af:	b8 07 00 00 00       	mov    $0x7,%eax
  8030b4:	cd 30                	int    $0x30
  8030b6:	89 45 ec             	mov    %eax,-0x14(%rbp)
		: "=a" (ret)
		: "a" (SYS_exofork),
		  "i" (T_SYSCALL)
	);
	return ret;
  8030b9:	8b 45 ec             	mov    -0x14(%rbp),%eax

	// Create a child.
	envid = sys_exofork();
  8030bc:	89 45 f8             	mov    %eax,-0x8(%rbp)
	if (envid < 0)
  8030bf:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8030c3:	79 08                	jns    8030cd <fork+0x3c>
		return envid;
  8030c5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8030c8:	e9 0b 02 00 00       	jmpq   8032d8 <fork+0x247>
	if (envid == 0) {
  8030cd:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8030d1:	75 3e                	jne    803111 <fork+0x80>
		thisenv = &envs[ENVX(sys_getenvid())];
  8030d3:	48 b8 7f 27 80 00 00 	movabs $0x80277f,%rax
  8030da:	00 00 00 
  8030dd:	ff d0                	callq  *%rax
  8030df:	25 ff 03 00 00       	and    $0x3ff,%eax
  8030e4:	48 98                	cltq   
  8030e6:	48 69 d0 68 01 00 00 	imul   $0x168,%rax,%rdx
  8030ed:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  8030f4:	00 00 00 
  8030f7:	48 01 c2             	add    %rax,%rdx
  8030fa:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803101:	00 00 00 
  803104:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  803107:	b8 00 00 00 00       	mov    $0x0,%eax
  80310c:	e9 c7 01 00 00       	jmpq   8032d8 <fork+0x247>
	}

	// Copy the address space.
	for (pn = 0; pn < PGNUM(UTOP); ) {
  803111:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  803118:	e9 a6 00 00 00       	jmpq   8031c3 <fork+0x132>
		if (!(uvpde[pn >> 18] & PTE_P && uvpd[pn >> 9] & PTE_P)) {
  80311d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803120:	c1 f8 12             	sar    $0x12,%eax
  803123:	89 c2                	mov    %eax,%edx
  803125:	48 b8 00 00 40 80 00 	movabs $0x10080400000,%rax
  80312c:	01 00 00 
  80312f:	48 63 d2             	movslq %edx,%rdx
  803132:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803136:	83 e0 01             	and    $0x1,%eax
  803139:	48 85 c0             	test   %rax,%rax
  80313c:	74 21                	je     80315f <fork+0xce>
  80313e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803141:	c1 f8 09             	sar    $0x9,%eax
  803144:	89 c2                	mov    %eax,%edx
  803146:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  80314d:	01 00 00 
  803150:	48 63 d2             	movslq %edx,%rdx
  803153:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803157:	83 e0 01             	and    $0x1,%eax
  80315a:	48 85 c0             	test   %rax,%rax
  80315d:	75 09                	jne    803168 <fork+0xd7>
			pn += NPTENTRIES;
  80315f:	81 45 fc 00 02 00 00 	addl   $0x200,-0x4(%rbp)
			continue;
  803166:	eb 5b                	jmp    8031c3 <fork+0x132>
		}
		for (end_pn = pn + NPTENTRIES; pn < end_pn; pn++) {
  803168:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80316b:	05 00 02 00 00       	add    $0x200,%eax
  803170:	89 45 f4             	mov    %eax,-0xc(%rbp)
  803173:	eb 46                	jmp    8031bb <fork+0x12a>
			if ((uvpt[pn] & (PTE_P|PTE_U)) != (PTE_P|PTE_U))
  803175:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  80317c:	01 00 00 
  80317f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  803182:	48 63 d2             	movslq %edx,%rdx
  803185:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803189:	83 e0 05             	and    $0x5,%eax
  80318c:	48 83 f8 05          	cmp    $0x5,%rax
  803190:	75 21                	jne    8031b3 <fork+0x122>
				continue;
			if (pn == PPN(UXSTACKTOP - 1))
  803192:	81 7d fc ff f7 0e 00 	cmpl   $0xef7ff,-0x4(%rbp)
  803199:	74 1b                	je     8031b6 <fork+0x125>
				continue;
			duppage(envid, pn);
  80319b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80319e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8031a1:	89 d6                	mov    %edx,%esi
  8031a3:	89 c7                	mov    %eax,%edi
  8031a5:	48 b8 10 2f 80 00 00 	movabs $0x802f10,%rax
  8031ac:	00 00 00 
  8031af:	ff d0                	callq  *%rax
  8031b1:	eb 04                	jmp    8031b7 <fork+0x126>
			pn += NPTENTRIES;
			continue;
		}
		for (end_pn = pn + NPTENTRIES; pn < end_pn; pn++) {
			if ((uvpt[pn] & (PTE_P|PTE_U)) != (PTE_P|PTE_U))
				continue;
  8031b3:	90                   	nop
  8031b4:	eb 01                	jmp    8031b7 <fork+0x126>
			if (pn == PPN(UXSTACKTOP - 1))
				continue;
  8031b6:	90                   	nop
	for (pn = 0; pn < PGNUM(UTOP); ) {
		if (!(uvpde[pn >> 18] & PTE_P && uvpd[pn >> 9] & PTE_P)) {
			pn += NPTENTRIES;
			continue;
		}
		for (end_pn = pn + NPTENTRIES; pn < end_pn; pn++) {
  8031b7:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8031bb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8031be:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8031c1:	7c b2                	jl     803175 <fork+0xe4>
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}

	// Copy the address space.
	for (pn = 0; pn < PGNUM(UTOP); ) {
  8031c3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8031c6:	3d ff 07 00 08       	cmp    $0x80007ff,%eax
  8031cb:	0f 86 4c ff ff ff    	jbe    80311d <fork+0x8c>
			duppage(envid, pn);
		}
	}

	// The child needs to start out with a valid exception stack.
	if ((r = sys_page_alloc(envid, (void*) (UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
  8031d1:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8031d4:	ba 07 00 00 00       	mov    $0x7,%edx
  8031d9:	be 00 f0 7f ef       	mov    $0xef7ff000,%esi
  8031de:	89 c7                	mov    %eax,%edi
  8031e0:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  8031e7:	00 00 00 
  8031ea:	ff d0                	callq  *%rax
  8031ec:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8031ef:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8031f3:	79 30                	jns    803225 <fork+0x194>
		panic("allocating exception stack: %e", r);
  8031f5:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8031f8:	89 c1                	mov    %eax,%ecx
  8031fa:	48 ba 88 15 82 00 00 	movabs $0x821588,%rdx
  803201:	00 00 00 
  803204:	be 9e 00 00 00       	mov    $0x9e,%esi
  803209:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  803210:	00 00 00 
  803213:	b8 00 00 00 00       	mov    $0x0,%eax
  803218:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  80321f:	00 00 00 
  803222:	41 ff d0             	callq  *%r8

	// Copy the user-mode exception entrypoint.
	if ((r = sys_env_set_pgfault_upcall(envid, thisenv->env_pgfault_upcall)) < 0)
  803225:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  80322c:	00 00 00 
  80322f:	48 8b 00             	mov    (%rax),%rax
  803232:	48 8b 90 f0 00 00 00 	mov    0xf0(%rax),%rdx
  803239:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80323c:	48 89 d6             	mov    %rdx,%rsi
  80323f:	89 c7                	mov    %eax,%edi
  803241:	48 b8 8f 29 80 00 00 	movabs $0x80298f,%rax
  803248:	00 00 00 
  80324b:	ff d0                	callq  *%rax
  80324d:	89 45 f0             	mov    %eax,-0x10(%rbp)
  803250:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  803254:	79 30                	jns    803286 <fork+0x1f5>
		panic("sys_env_set_pgfault_upcall: %e", r);
  803256:	8b 45 f0             	mov    -0x10(%rbp),%eax
  803259:	89 c1                	mov    %eax,%ecx
  80325b:	48 ba a8 15 82 00 00 	movabs $0x8215a8,%rdx
  803262:	00 00 00 
  803265:	be a2 00 00 00       	mov    $0xa2,%esi
  80326a:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  803271:	00 00 00 
  803274:	b8 00 00 00 00       	mov    $0x0,%eax
  803279:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  803280:	00 00 00 
  803283:	41 ff d0             	callq  *%r8


	// Okay, the child is ready for life on its own.
	if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) < 0)
  803286:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803289:	be 02 00 00 00       	mov    $0x2,%esi
  80328e:	89 c7                	mov    %eax,%edi
  803290:	48 b8 f6 28 80 00 00 	movabs $0x8028f6,%rax
  803297:	00 00 00 
  80329a:	ff d0                	callq  *%rax
  80329c:	89 45 f0             	mov    %eax,-0x10(%rbp)
  80329f:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8032a3:	79 30                	jns    8032d5 <fork+0x244>
		panic("sys_env_set_status: %e", r);
  8032a5:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8032a8:	89 c1                	mov    %eax,%ecx
  8032aa:	48 ba c7 15 82 00 00 	movabs $0x8215c7,%rdx
  8032b1:	00 00 00 
  8032b4:	be a7 00 00 00       	mov    $0xa7,%esi
  8032b9:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  8032c0:	00 00 00 
  8032c3:	b8 00 00 00 00       	mov    $0x0,%eax
  8032c8:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  8032cf:	00 00 00 
  8032d2:	41 ff d0             	callq  *%r8

	return envid;
  8032d5:	8b 45 f8             	mov    -0x8(%rbp),%eax

}
  8032d8:	c9                   	leaveq 
  8032d9:	c3                   	retq   

00000000008032da <sfork>:

// Challenge!
int
sfork(void)
{
  8032da:	55                   	push   %rbp
  8032db:	48 89 e5             	mov    %rsp,%rbp
	panic("sfork not implemented");
  8032de:	48 ba de 15 82 00 00 	movabs $0x8215de,%rdx
  8032e5:	00 00 00 
  8032e8:	be b1 00 00 00       	mov    $0xb1,%esi
  8032ed:	48 bf 11 15 82 00 00 	movabs $0x821511,%rdi
  8032f4:	00 00 00 
  8032f7:	b8 00 00 00 00       	mov    $0x0,%eax
  8032fc:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  803303:	00 00 00 
  803306:	ff d1                	callq  *%rcx

0000000000803308 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  803308:	55                   	push   %rbp
  803309:	48 89 e5             	mov    %rsp,%rbp
  80330c:	48 83 ec 30          	sub    $0x30,%rsp
  803310:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803314:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803318:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	int r;

	if (!pg)
  80331c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  803321:	75 0e                	jne    803331 <ipc_recv+0x29>
		pg = (void*) UTOP;
  803323:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  80332a:	00 00 00 
  80332d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if ((r = sys_ipc_recv(pg)) < 0) {
  803331:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803335:	48 89 c7             	mov    %rax,%rdi
  803338:	48 b8 32 2a 80 00 00 	movabs $0x802a32,%rax
  80333f:	00 00 00 
  803342:	ff d0                	callq  *%rax
  803344:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803347:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80334b:	79 27                	jns    803374 <ipc_recv+0x6c>
		if (from_env_store)
  80334d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  803352:	74 0a                	je     80335e <ipc_recv+0x56>
			*from_env_store = 0;
  803354:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803358:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
		if (perm_store)
  80335e:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  803363:	74 0a                	je     80336f <ipc_recv+0x67>
			*perm_store = 0;
  803365:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803369:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
		return r;
  80336f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803372:	eb 53                	jmp    8033c7 <ipc_recv+0xbf>
	}
	if (from_env_store)
  803374:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  803379:	74 19                	je     803394 <ipc_recv+0x8c>
		*from_env_store = thisenv->env_ipc_from;
  80337b:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803382:	00 00 00 
  803385:	48 8b 00             	mov    (%rax),%rax
  803388:	8b 90 0c 01 00 00    	mov    0x10c(%rax),%edx
  80338e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803392:	89 10                	mov    %edx,(%rax)
	if (perm_store)
  803394:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  803399:	74 19                	je     8033b4 <ipc_recv+0xac>
		*perm_store = thisenv->env_ipc_perm;
  80339b:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8033a2:	00 00 00 
  8033a5:	48 8b 00             	mov    (%rax),%rax
  8033a8:	8b 90 10 01 00 00    	mov    0x110(%rax),%edx
  8033ae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8033b2:	89 10                	mov    %edx,(%rax)
	return thisenv->env_ipc_value;
  8033b4:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8033bb:	00 00 00 
  8033be:	48 8b 00             	mov    (%rax),%rax
  8033c1:	8b 80 08 01 00 00    	mov    0x108(%rax),%eax

}
  8033c7:	c9                   	leaveq 
  8033c8:	c3                   	retq   

00000000008033c9 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  8033c9:	55                   	push   %rbp
  8033ca:	48 89 e5             	mov    %rsp,%rbp
  8033cd:	48 83 ec 30          	sub    $0x30,%rsp
  8033d1:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8033d4:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8033d7:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  8033db:	89 4d dc             	mov    %ecx,-0x24(%rbp)

	int r;

	if (!pg)
  8033de:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8033e3:	75 1c                	jne    803401 <ipc_send+0x38>
		pg = (void*) UTOP;
  8033e5:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  8033ec:	00 00 00 
  8033ef:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while ((r = sys_ipc_try_send(to_env, val, pg, perm)) == -E_IPC_NOT_RECV) {
  8033f3:	eb 0c                	jmp    803401 <ipc_send+0x38>
		sys_yield();
  8033f5:	48 b8 bb 27 80 00 00 	movabs $0x8027bb,%rax
  8033fc:	00 00 00 
  8033ff:	ff d0                	callq  *%rax

	int r;

	if (!pg)
		pg = (void*) UTOP;
	while ((r = sys_ipc_try_send(to_env, val, pg, perm)) == -E_IPC_NOT_RECV) {
  803401:	8b 75 e8             	mov    -0x18(%rbp),%esi
  803404:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  803407:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80340b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80340e:	89 c7                	mov    %eax,%edi
  803410:	48 b8 db 29 80 00 00 	movabs $0x8029db,%rax
  803417:	00 00 00 
  80341a:	ff d0                	callq  *%rax
  80341c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80341f:	83 7d fc f8          	cmpl   $0xfffffff8,-0x4(%rbp)
  803423:	74 d0                	je     8033f5 <ipc_send+0x2c>
		sys_yield();
	}
	if (r < 0)
  803425:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803429:	79 30                	jns    80345b <ipc_send+0x92>
		panic("error in ipc_send: %e", r);
  80342b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80342e:	89 c1                	mov    %eax,%ecx
  803430:	48 ba f4 15 82 00 00 	movabs $0x8215f4,%rdx
  803437:	00 00 00 
  80343a:	be 47 00 00 00       	mov    $0x47,%esi
  80343f:	48 bf 0a 16 82 00 00 	movabs $0x82160a,%rdi
  803446:	00 00 00 
  803449:	b8 00 00 00 00       	mov    $0x0,%eax
  80344e:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  803455:	00 00 00 
  803458:	41 ff d0             	callq  *%r8

}
  80345b:	90                   	nop
  80345c:	c9                   	leaveq 
  80345d:	c3                   	retq   

000000000080345e <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  80345e:	55                   	push   %rbp
  80345f:	48 89 e5             	mov    %rsp,%rbp
  803462:	48 83 ec 18          	sub    $0x18,%rsp
  803466:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int i;
	for (i = 0; i < NENV; i++) {
  803469:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  803470:	eb 4d                	jmp    8034bf <ipc_find_env+0x61>
		if (envs[i].env_type == type)
  803472:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  803479:	00 00 00 
  80347c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80347f:	48 98                	cltq   
  803481:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  803488:	48 01 d0             	add    %rdx,%rax
  80348b:	48 05 d0 00 00 00    	add    $0xd0,%rax
  803491:	8b 00                	mov    (%rax),%eax
  803493:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  803496:	75 23                	jne    8034bb <ipc_find_env+0x5d>
			return envs[i].env_id;
  803498:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  80349f:	00 00 00 
  8034a2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8034a5:	48 98                	cltq   
  8034a7:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8034ae:	48 01 d0             	add    %rdx,%rax
  8034b1:	48 05 c8 00 00 00    	add    $0xc8,%rax
  8034b7:	8b 00                	mov    (%rax),%eax
  8034b9:	eb 12                	jmp    8034cd <ipc_find_env+0x6f>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++) {
  8034bb:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8034bf:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  8034c6:	7e aa                	jle    803472 <ipc_find_env+0x14>
		if (envs[i].env_type == type)
			return envs[i].env_id;
	}
	return 0;
  8034c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8034cd:	c9                   	leaveq 
  8034ce:	c3                   	retq   

00000000008034cf <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

uint64_t
fd2num(struct Fd *fd)
{
  8034cf:	55                   	push   %rbp
  8034d0:	48 89 e5             	mov    %rsp,%rbp
  8034d3:	48 83 ec 08          	sub    $0x8,%rsp
  8034d7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  8034db:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8034df:	48 b8 00 00 00 30 ff 	movabs $0xffffffff30000000,%rax
  8034e6:	ff ff ff 
  8034e9:	48 01 d0             	add    %rdx,%rax
  8034ec:	48 c1 e8 0c          	shr    $0xc,%rax
}
  8034f0:	c9                   	leaveq 
  8034f1:	c3                   	retq   

00000000008034f2 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  8034f2:	55                   	push   %rbp
  8034f3:	48 89 e5             	mov    %rsp,%rbp
  8034f6:	48 83 ec 08          	sub    $0x8,%rsp
  8034fa:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return INDEX2DATA(fd2num(fd));
  8034fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803502:	48 89 c7             	mov    %rax,%rdi
  803505:	48 b8 cf 34 80 00 00 	movabs $0x8034cf,%rax
  80350c:	00 00 00 
  80350f:	ff d0                	callq  *%rax
  803511:	48 05 20 00 0d 00    	add    $0xd0020,%rax
  803517:	48 c1 e0 0c          	shl    $0xc,%rax
}
  80351b:	c9                   	leaveq 
  80351c:	c3                   	retq   

000000000080351d <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  80351d:	55                   	push   %rbp
  80351e:	48 89 e5             	mov    %rsp,%rbp
  803521:	48 83 ec 18          	sub    $0x18,%rsp
  803525:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  803529:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  803530:	eb 6b                	jmp    80359d <fd_alloc+0x80>
		fd = INDEX2FD(i);
  803532:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803535:	48 98                	cltq   
  803537:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  80353d:	48 c1 e0 0c          	shl    $0xc,%rax
  803541:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if ((uvpd[VPD(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  803545:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803549:	48 c1 e8 15          	shr    $0x15,%rax
  80354d:	48 89 c2             	mov    %rax,%rdx
  803550:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  803557:	01 00 00 
  80355a:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80355e:	83 e0 01             	and    $0x1,%eax
  803561:	48 85 c0             	test   %rax,%rax
  803564:	74 21                	je     803587 <fd_alloc+0x6a>
  803566:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80356a:	48 c1 e8 0c          	shr    $0xc,%rax
  80356e:	48 89 c2             	mov    %rax,%rdx
  803571:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803578:	01 00 00 
  80357b:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80357f:	83 e0 01             	and    $0x1,%eax
  803582:	48 85 c0             	test   %rax,%rax
  803585:	75 12                	jne    803599 <fd_alloc+0x7c>
			*fd_store = fd;
  803587:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80358b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80358f:	48 89 10             	mov    %rdx,(%rax)
			return 0;
  803592:	b8 00 00 00 00       	mov    $0x0,%eax
  803597:	eb 1a                	jmp    8035b3 <fd_alloc+0x96>
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  803599:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80359d:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  8035a1:	7e 8f                	jle    803532 <fd_alloc+0x15>
		if ((uvpd[VPD(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  8035a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8035a7:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	return -E_MAX_OPEN;
  8035ae:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  8035b3:	c9                   	leaveq 
  8035b4:	c3                   	retq   

00000000008035b5 <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  8035b5:	55                   	push   %rbp
  8035b6:	48 89 e5             	mov    %rsp,%rbp
  8035b9:	48 83 ec 20          	sub    $0x20,%rsp
  8035bd:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8035c0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  8035c4:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8035c8:	78 06                	js     8035d0 <fd_lookup+0x1b>
  8035ca:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  8035ce:	7e 07                	jle    8035d7 <fd_lookup+0x22>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  8035d0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8035d5:	eb 6c                	jmp    803643 <fd_lookup+0x8e>
	}
	fd = INDEX2FD(fdnum);
  8035d7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8035da:	48 98                	cltq   
  8035dc:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  8035e2:	48 c1 e0 0c          	shl    $0xc,%rax
  8035e6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!(uvpd[VPD(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  8035ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8035ee:	48 c1 e8 15          	shr    $0x15,%rax
  8035f2:	48 89 c2             	mov    %rax,%rdx
  8035f5:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  8035fc:	01 00 00 
  8035ff:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803603:	83 e0 01             	and    $0x1,%eax
  803606:	48 85 c0             	test   %rax,%rax
  803609:	74 21                	je     80362c <fd_lookup+0x77>
  80360b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80360f:	48 c1 e8 0c          	shr    $0xc,%rax
  803613:	48 89 c2             	mov    %rax,%rdx
  803616:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  80361d:	01 00 00 
  803620:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803624:	83 e0 01             	and    $0x1,%eax
  803627:	48 85 c0             	test   %rax,%rax
  80362a:	75 07                	jne    803633 <fd_lookup+0x7e>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  80362c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803631:	eb 10                	jmp    803643 <fd_lookup+0x8e>
	}
	*fd_store = fd;
  803633:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803637:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80363b:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  80363e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803643:	c9                   	leaveq 
  803644:	c3                   	retq   

0000000000803645 <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  803645:	55                   	push   %rbp
  803646:	48 89 e5             	mov    %rsp,%rbp
  803649:	48 83 ec 30          	sub    $0x30,%rsp
  80364d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  803651:	89 f0                	mov    %esi,%eax
  803653:	88 45 d4             	mov    %al,-0x2c(%rbp)
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  803656:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80365a:	48 89 c7             	mov    %rax,%rdi
  80365d:	48 b8 cf 34 80 00 00 	movabs $0x8034cf,%rax
  803664:	00 00 00 
  803667:	ff d0                	callq  *%rax
  803669:	89 c2                	mov    %eax,%edx
  80366b:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  80366f:	48 89 c6             	mov    %rax,%rsi
  803672:	89 d7                	mov    %edx,%edi
  803674:	48 b8 b5 35 80 00 00 	movabs $0x8035b5,%rax
  80367b:	00 00 00 
  80367e:	ff d0                	callq  *%rax
  803680:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803683:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803687:	78 0a                	js     803693 <fd_close+0x4e>
	    || fd != fd2)
  803689:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80368d:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  803691:	74 12                	je     8036a5 <fd_close+0x60>
		return (must_exist ? r : 0);
  803693:	80 7d d4 00          	cmpb   $0x0,-0x2c(%rbp)
  803697:	74 05                	je     80369e <fd_close+0x59>
  803699:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80369c:	eb 70                	jmp    80370e <fd_close+0xc9>
  80369e:	b8 00 00 00 00       	mov    $0x0,%eax
  8036a3:	eb 69                	jmp    80370e <fd_close+0xc9>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  8036a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8036a9:	8b 00                	mov    (%rax),%eax
  8036ab:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  8036af:	48 89 d6             	mov    %rdx,%rsi
  8036b2:	89 c7                	mov    %eax,%edi
  8036b4:	48 b8 10 37 80 00 00 	movabs $0x803710,%rax
  8036bb:	00 00 00 
  8036be:	ff d0                	callq  *%rax
  8036c0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8036c3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8036c7:	78 2a                	js     8036f3 <fd_close+0xae>
		if (dev->dev_close)
  8036c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8036cd:	48 8b 40 20          	mov    0x20(%rax),%rax
  8036d1:	48 85 c0             	test   %rax,%rax
  8036d4:	74 16                	je     8036ec <fd_close+0xa7>
			r = (*dev->dev_close)(fd);
  8036d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8036da:	48 8b 40 20          	mov    0x20(%rax),%rax
  8036de:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8036e2:	48 89 d7             	mov    %rdx,%rdi
  8036e5:	ff d0                	callq  *%rax
  8036e7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8036ea:	eb 07                	jmp    8036f3 <fd_close+0xae>
		else
			r = 0;
  8036ec:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  8036f3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8036f7:	48 89 c6             	mov    %rax,%rsi
  8036fa:	bf 00 00 00 00       	mov    $0x0,%edi
  8036ff:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  803706:	00 00 00 
  803709:	ff d0                	callq  *%rax
	return r;
  80370b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80370e:	c9                   	leaveq 
  80370f:	c3                   	retq   

0000000000803710 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  803710:	55                   	push   %rbp
  803711:	48 89 e5             	mov    %rsp,%rbp
  803714:	48 83 ec 20          	sub    $0x20,%rsp
  803718:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80371b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int i;
	for (i = 0; devtab[i]; i++)
  80371f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  803726:	eb 41                	jmp    803769 <dev_lookup+0x59>
		if (devtab[i]->dev_id == dev_id) {
  803728:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  80372f:	00 00 00 
  803732:	8b 55 fc             	mov    -0x4(%rbp),%edx
  803735:	48 63 d2             	movslq %edx,%rdx
  803738:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80373c:	8b 00                	mov    (%rax),%eax
  80373e:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  803741:	75 22                	jne    803765 <dev_lookup+0x55>
			*dev = devtab[i];
  803743:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  80374a:	00 00 00 
  80374d:	8b 55 fc             	mov    -0x4(%rbp),%edx
  803750:	48 63 d2             	movslq %edx,%rdx
  803753:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  803757:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80375b:	48 89 10             	mov    %rdx,(%rax)
			return 0;
  80375e:	b8 00 00 00 00       	mov    $0x0,%eax
  803763:	eb 60                	jmp    8037c5 <dev_lookup+0xb5>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  803765:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  803769:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  803770:	00 00 00 
  803773:	8b 55 fc             	mov    -0x4(%rbp),%edx
  803776:	48 63 d2             	movslq %edx,%rdx
  803779:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80377d:	48 85 c0             	test   %rax,%rax
  803780:	75 a6                	jne    803728 <dev_lookup+0x18>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  803782:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803789:	00 00 00 
  80378c:	48 8b 00             	mov    (%rax),%rax
  80378f:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803795:	8b 55 ec             	mov    -0x14(%rbp),%edx
  803798:	89 c6                	mov    %eax,%esi
  80379a:	48 bf 18 16 82 00 00 	movabs $0x821618,%rdi
  8037a1:	00 00 00 
  8037a4:	b8 00 00 00 00       	mov    $0x0,%eax
  8037a9:	48 b9 32 13 80 00 00 	movabs $0x801332,%rcx
  8037b0:	00 00 00 
  8037b3:	ff d1                	callq  *%rcx
	*dev = 0;
  8037b5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8037b9:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	return -E_INVAL;
  8037c0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  8037c5:	c9                   	leaveq 
  8037c6:	c3                   	retq   

00000000008037c7 <close>:

int
close(int fdnum)
{
  8037c7:	55                   	push   %rbp
  8037c8:	48 89 e5             	mov    %rsp,%rbp
  8037cb:	48 83 ec 20          	sub    $0x20,%rsp
  8037cf:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8037d2:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8037d6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8037d9:	48 89 d6             	mov    %rdx,%rsi
  8037dc:	89 c7                	mov    %eax,%edi
  8037de:	48 b8 b5 35 80 00 00 	movabs $0x8035b5,%rax
  8037e5:	00 00 00 
  8037e8:	ff d0                	callq  *%rax
  8037ea:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8037ed:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8037f1:	79 05                	jns    8037f8 <close+0x31>
		return r;
  8037f3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8037f6:	eb 18                	jmp    803810 <close+0x49>
	else
		return fd_close(fd, 1);
  8037f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8037fc:	be 01 00 00 00       	mov    $0x1,%esi
  803801:	48 89 c7             	mov    %rax,%rdi
  803804:	48 b8 45 36 80 00 00 	movabs $0x803645,%rax
  80380b:	00 00 00 
  80380e:	ff d0                	callq  *%rax
}
  803810:	c9                   	leaveq 
  803811:	c3                   	retq   

0000000000803812 <close_all>:

void
close_all(void)
{
  803812:	55                   	push   %rbp
  803813:	48 89 e5             	mov    %rsp,%rbp
  803816:	48 83 ec 10          	sub    $0x10,%rsp
	int i;
	for (i = 0; i < MAXFD; i++)
  80381a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  803821:	eb 15                	jmp    803838 <close_all+0x26>
		close(i);
  803823:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803826:	89 c7                	mov    %eax,%edi
  803828:	48 b8 c7 37 80 00 00 	movabs $0x8037c7,%rax
  80382f:	00 00 00 
  803832:	ff d0                	callq  *%rax

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  803834:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  803838:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  80383c:	7e e5                	jle    803823 <close_all+0x11>
		close(i);
}
  80383e:	90                   	nop
  80383f:	c9                   	leaveq 
  803840:	c3                   	retq   

0000000000803841 <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  803841:	55                   	push   %rbp
  803842:	48 89 e5             	mov    %rsp,%rbp
  803845:	48 83 ec 40          	sub    $0x40,%rsp
  803849:	89 7d cc             	mov    %edi,-0x34(%rbp)
  80384c:	89 75 c8             	mov    %esi,-0x38(%rbp)
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  80384f:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  803853:	8b 45 cc             	mov    -0x34(%rbp),%eax
  803856:	48 89 d6             	mov    %rdx,%rsi
  803859:	89 c7                	mov    %eax,%edi
  80385b:	48 b8 b5 35 80 00 00 	movabs $0x8035b5,%rax
  803862:	00 00 00 
  803865:	ff d0                	callq  *%rax
  803867:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80386a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80386e:	79 08                	jns    803878 <dup+0x37>
		return r;
  803870:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803873:	e9 70 01 00 00       	jmpq   8039e8 <dup+0x1a7>
	close(newfdnum);
  803878:	8b 45 c8             	mov    -0x38(%rbp),%eax
  80387b:	89 c7                	mov    %eax,%edi
  80387d:	48 b8 c7 37 80 00 00 	movabs $0x8037c7,%rax
  803884:	00 00 00 
  803887:	ff d0                	callq  *%rax

	newfd = INDEX2FD(newfdnum);
  803889:	8b 45 c8             	mov    -0x38(%rbp),%eax
  80388c:	48 98                	cltq   
  80388e:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  803894:	48 c1 e0 0c          	shl    $0xc,%rax
  803898:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	ova = fd2data(oldfd);
  80389c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8038a0:	48 89 c7             	mov    %rax,%rdi
  8038a3:	48 b8 f2 34 80 00 00 	movabs $0x8034f2,%rax
  8038aa:	00 00 00 
  8038ad:	ff d0                	callq  *%rax
  8038af:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	nva = fd2data(newfd);
  8038b3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8038b7:	48 89 c7             	mov    %rax,%rdi
  8038ba:	48 b8 f2 34 80 00 00 	movabs $0x8034f2,%rax
  8038c1:	00 00 00 
  8038c4:	ff d0                	callq  *%rax
  8038c6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	if ((uvpd[VPD(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  8038ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8038ce:	48 c1 e8 15          	shr    $0x15,%rax
  8038d2:	48 89 c2             	mov    %rax,%rdx
  8038d5:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  8038dc:	01 00 00 
  8038df:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8038e3:	83 e0 01             	and    $0x1,%eax
  8038e6:	48 85 c0             	test   %rax,%rax
  8038e9:	74 71                	je     80395c <dup+0x11b>
  8038eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8038ef:	48 c1 e8 0c          	shr    $0xc,%rax
  8038f3:	48 89 c2             	mov    %rax,%rdx
  8038f6:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8038fd:	01 00 00 
  803900:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803904:	83 e0 01             	and    $0x1,%eax
  803907:	48 85 c0             	test   %rax,%rax
  80390a:	74 50                	je     80395c <dup+0x11b>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  80390c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803910:	48 c1 e8 0c          	shr    $0xc,%rax
  803914:	48 89 c2             	mov    %rax,%rdx
  803917:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  80391e:	01 00 00 
  803921:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803925:	25 07 0e 00 00       	and    $0xe07,%eax
  80392a:	89 c1                	mov    %eax,%ecx
  80392c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  803930:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803934:	41 89 c8             	mov    %ecx,%r8d
  803937:	48 89 d1             	mov    %rdx,%rcx
  80393a:	ba 00 00 00 00       	mov    $0x0,%edx
  80393f:	48 89 c6             	mov    %rax,%rsi
  803942:	bf 00 00 00 00       	mov    $0x0,%edi
  803947:	48 b8 4a 28 80 00 00 	movabs $0x80284a,%rax
  80394e:	00 00 00 
  803951:	ff d0                	callq  *%rax
  803953:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803956:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80395a:	78 55                	js     8039b1 <dup+0x170>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80395c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803960:	48 c1 e8 0c          	shr    $0xc,%rax
  803964:	48 89 c2             	mov    %rax,%rdx
  803967:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  80396e:	01 00 00 
  803971:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803975:	25 07 0e 00 00       	and    $0xe07,%eax
  80397a:	89 c1                	mov    %eax,%ecx
  80397c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803980:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  803984:	41 89 c8             	mov    %ecx,%r8d
  803987:	48 89 d1             	mov    %rdx,%rcx
  80398a:	ba 00 00 00 00       	mov    $0x0,%edx
  80398f:	48 89 c6             	mov    %rax,%rsi
  803992:	bf 00 00 00 00       	mov    $0x0,%edi
  803997:	48 b8 4a 28 80 00 00 	movabs $0x80284a,%rax
  80399e:	00 00 00 
  8039a1:	ff d0                	callq  *%rax
  8039a3:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8039a6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8039aa:	78 08                	js     8039b4 <dup+0x173>
		goto err;

	return newfdnum;
  8039ac:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8039af:	eb 37                	jmp    8039e8 <dup+0x1a7>
	ova = fd2data(oldfd);
	nva = fd2data(newfd);

	if ((uvpd[VPD(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
  8039b1:	90                   	nop
  8039b2:	eb 01                	jmp    8039b5 <dup+0x174>
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
		goto err;
  8039b4:	90                   	nop

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  8039b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8039b9:	48 89 c6             	mov    %rax,%rsi
  8039bc:	bf 00 00 00 00       	mov    $0x0,%edi
  8039c1:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  8039c8:	00 00 00 
  8039cb:	ff d0                	callq  *%rax
	sys_page_unmap(0, nva);
  8039cd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8039d1:	48 89 c6             	mov    %rax,%rsi
  8039d4:	bf 00 00 00 00       	mov    $0x0,%edi
  8039d9:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  8039e0:	00 00 00 
  8039e3:	ff d0                	callq  *%rax
	return r;
  8039e5:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8039e8:	c9                   	leaveq 
  8039e9:	c3                   	retq   

00000000008039ea <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  8039ea:	55                   	push   %rbp
  8039eb:	48 89 e5             	mov    %rsp,%rbp
  8039ee:	48 83 ec 40          	sub    $0x40,%rsp
  8039f2:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8039f5:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8039f9:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  8039fd:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803a01:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803a04:	48 89 d6             	mov    %rdx,%rsi
  803a07:	89 c7                	mov    %eax,%edi
  803a09:	48 b8 b5 35 80 00 00 	movabs $0x8035b5,%rax
  803a10:	00 00 00 
  803a13:	ff d0                	callq  *%rax
  803a15:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803a18:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803a1c:	78 24                	js     803a42 <read+0x58>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803a1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803a22:	8b 00                	mov    (%rax),%eax
  803a24:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803a28:	48 89 d6             	mov    %rdx,%rsi
  803a2b:	89 c7                	mov    %eax,%edi
  803a2d:	48 b8 10 37 80 00 00 	movabs $0x803710,%rax
  803a34:	00 00 00 
  803a37:	ff d0                	callq  *%rax
  803a39:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803a3c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803a40:	79 05                	jns    803a47 <read+0x5d>
		return r;
  803a42:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803a45:	eb 76                	jmp    803abd <read+0xd3>
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  803a47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803a4b:	8b 40 08             	mov    0x8(%rax),%eax
  803a4e:	83 e0 03             	and    $0x3,%eax
  803a51:	83 f8 01             	cmp    $0x1,%eax
  803a54:	75 3a                	jne    803a90 <read+0xa6>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  803a56:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803a5d:	00 00 00 
  803a60:	48 8b 00             	mov    (%rax),%rax
  803a63:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803a69:	8b 55 dc             	mov    -0x24(%rbp),%edx
  803a6c:	89 c6                	mov    %eax,%esi
  803a6e:	48 bf 37 16 82 00 00 	movabs $0x821637,%rdi
  803a75:	00 00 00 
  803a78:	b8 00 00 00 00       	mov    $0x0,%eax
  803a7d:	48 b9 32 13 80 00 00 	movabs $0x801332,%rcx
  803a84:	00 00 00 
  803a87:	ff d1                	callq  *%rcx
		return -E_INVAL;
  803a89:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803a8e:	eb 2d                	jmp    803abd <read+0xd3>
	}
	if (!dev->dev_read)
  803a90:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803a94:	48 8b 40 10          	mov    0x10(%rax),%rax
  803a98:	48 85 c0             	test   %rax,%rax
  803a9b:	75 07                	jne    803aa4 <read+0xba>
		return -E_NOT_SUPP;
  803a9d:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803aa2:	eb 19                	jmp    803abd <read+0xd3>
	return (*dev->dev_read)(fd, buf, n);
  803aa4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803aa8:	48 8b 40 10          	mov    0x10(%rax),%rax
  803aac:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  803ab0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  803ab4:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  803ab8:	48 89 cf             	mov    %rcx,%rdi
  803abb:	ff d0                	callq  *%rax
}
  803abd:	c9                   	leaveq 
  803abe:	c3                   	retq   

0000000000803abf <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  803abf:	55                   	push   %rbp
  803ac0:	48 89 e5             	mov    %rsp,%rbp
  803ac3:	48 83 ec 30          	sub    $0x30,%rsp
  803ac7:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803aca:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803ace:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  803ad2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  803ad9:	eb 47                	jmp    803b22 <readn+0x63>
		m = read(fdnum, (char*)buf + tot, n - tot);
  803adb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803ade:	48 98                	cltq   
  803ae0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  803ae4:	48 29 c2             	sub    %rax,%rdx
  803ae7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803aea:	48 63 c8             	movslq %eax,%rcx
  803aed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803af1:	48 01 c1             	add    %rax,%rcx
  803af4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803af7:	48 89 ce             	mov    %rcx,%rsi
  803afa:	89 c7                	mov    %eax,%edi
  803afc:	48 b8 ea 39 80 00 00 	movabs $0x8039ea,%rax
  803b03:	00 00 00 
  803b06:	ff d0                	callq  *%rax
  803b08:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (m < 0)
  803b0b:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  803b0f:	79 05                	jns    803b16 <readn+0x57>
			return m;
  803b11:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803b14:	eb 1d                	jmp    803b33 <readn+0x74>
		if (m == 0)
  803b16:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  803b1a:	74 13                	je     803b2f <readn+0x70>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  803b1c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803b1f:	01 45 fc             	add    %eax,-0x4(%rbp)
  803b22:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803b25:	48 98                	cltq   
  803b27:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  803b2b:	72 ae                	jb     803adb <readn+0x1c>
  803b2d:	eb 01                	jmp    803b30 <readn+0x71>
		m = read(fdnum, (char*)buf + tot, n - tot);
		if (m < 0)
			return m;
		if (m == 0)
			break;
  803b2f:	90                   	nop
	}
	return tot;
  803b30:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  803b33:	c9                   	leaveq 
  803b34:	c3                   	retq   

0000000000803b35 <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  803b35:	55                   	push   %rbp
  803b36:	48 89 e5             	mov    %rsp,%rbp
  803b39:	48 83 ec 40          	sub    $0x40,%rsp
  803b3d:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803b40:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  803b44:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  803b48:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803b4c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803b4f:	48 89 d6             	mov    %rdx,%rsi
  803b52:	89 c7                	mov    %eax,%edi
  803b54:	48 b8 b5 35 80 00 00 	movabs $0x8035b5,%rax
  803b5b:	00 00 00 
  803b5e:	ff d0                	callq  *%rax
  803b60:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803b63:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803b67:	78 24                	js     803b8d <write+0x58>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803b69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803b6d:	8b 00                	mov    (%rax),%eax
  803b6f:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803b73:	48 89 d6             	mov    %rdx,%rsi
  803b76:	89 c7                	mov    %eax,%edi
  803b78:	48 b8 10 37 80 00 00 	movabs $0x803710,%rax
  803b7f:	00 00 00 
  803b82:	ff d0                	callq  *%rax
  803b84:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803b87:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803b8b:	79 05                	jns    803b92 <write+0x5d>
		return r;
  803b8d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803b90:	eb 75                	jmp    803c07 <write+0xd2>
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  803b92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803b96:	8b 40 08             	mov    0x8(%rax),%eax
  803b99:	83 e0 03             	and    $0x3,%eax
  803b9c:	85 c0                	test   %eax,%eax
  803b9e:	75 3a                	jne    803bda <write+0xa5>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  803ba0:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803ba7:	00 00 00 
  803baa:	48 8b 00             	mov    (%rax),%rax
  803bad:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803bb3:	8b 55 dc             	mov    -0x24(%rbp),%edx
  803bb6:	89 c6                	mov    %eax,%esi
  803bb8:	48 bf 53 16 82 00 00 	movabs $0x821653,%rdi
  803bbf:	00 00 00 
  803bc2:	b8 00 00 00 00       	mov    $0x0,%eax
  803bc7:	48 b9 32 13 80 00 00 	movabs $0x801332,%rcx
  803bce:	00 00 00 
  803bd1:	ff d1                	callq  *%rcx
		return -E_INVAL;
  803bd3:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803bd8:	eb 2d                	jmp    803c07 <write+0xd2>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  803bda:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803bde:	48 8b 40 18          	mov    0x18(%rax),%rax
  803be2:	48 85 c0             	test   %rax,%rax
  803be5:	75 07                	jne    803bee <write+0xb9>
		return -E_NOT_SUPP;
  803be7:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803bec:	eb 19                	jmp    803c07 <write+0xd2>
	return (*dev->dev_write)(fd, buf, n);
  803bee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803bf2:	48 8b 40 18          	mov    0x18(%rax),%rax
  803bf6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  803bfa:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  803bfe:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  803c02:	48 89 cf             	mov    %rcx,%rdi
  803c05:	ff d0                	callq  *%rax
}
  803c07:	c9                   	leaveq 
  803c08:	c3                   	retq   

0000000000803c09 <seek>:

int
seek(int fdnum, off_t offset)
{
  803c09:	55                   	push   %rbp
  803c0a:	48 89 e5             	mov    %rsp,%rbp
  803c0d:	48 83 ec 18          	sub    $0x18,%rsp
  803c11:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803c14:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  803c17:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803c1b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803c1e:	48 89 d6             	mov    %rdx,%rsi
  803c21:	89 c7                	mov    %eax,%edi
  803c23:	48 b8 b5 35 80 00 00 	movabs $0x8035b5,%rax
  803c2a:	00 00 00 
  803c2d:	ff d0                	callq  *%rax
  803c2f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803c32:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803c36:	79 05                	jns    803c3d <seek+0x34>
		return r;
  803c38:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803c3b:	eb 0f                	jmp    803c4c <seek+0x43>
	fd->fd_offset = offset;
  803c3d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803c41:	8b 55 e8             	mov    -0x18(%rbp),%edx
  803c44:	89 50 04             	mov    %edx,0x4(%rax)
	return 0;
  803c47:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803c4c:	c9                   	leaveq 
  803c4d:	c3                   	retq   

0000000000803c4e <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  803c4e:	55                   	push   %rbp
  803c4f:	48 89 e5             	mov    %rsp,%rbp
  803c52:	48 83 ec 30          	sub    $0x30,%rsp
  803c56:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803c59:	89 75 d8             	mov    %esi,-0x28(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  803c5c:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803c60:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803c63:	48 89 d6             	mov    %rdx,%rsi
  803c66:	89 c7                	mov    %eax,%edi
  803c68:	48 b8 b5 35 80 00 00 	movabs $0x8035b5,%rax
  803c6f:	00 00 00 
  803c72:	ff d0                	callq  *%rax
  803c74:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803c77:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803c7b:	78 24                	js     803ca1 <ftruncate+0x53>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803c7d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803c81:	8b 00                	mov    (%rax),%eax
  803c83:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803c87:	48 89 d6             	mov    %rdx,%rsi
  803c8a:	89 c7                	mov    %eax,%edi
  803c8c:	48 b8 10 37 80 00 00 	movabs $0x803710,%rax
  803c93:	00 00 00 
  803c96:	ff d0                	callq  *%rax
  803c98:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803c9b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803c9f:	79 05                	jns    803ca6 <ftruncate+0x58>
		return r;
  803ca1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803ca4:	eb 72                	jmp    803d18 <ftruncate+0xca>
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  803ca6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803caa:	8b 40 08             	mov    0x8(%rax),%eax
  803cad:	83 e0 03             	and    $0x3,%eax
  803cb0:	85 c0                	test   %eax,%eax
  803cb2:	75 3a                	jne    803cee <ftruncate+0xa0>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  803cb4:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803cbb:	00 00 00 
  803cbe:	48 8b 00             	mov    (%rax),%rax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  803cc1:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803cc7:	8b 55 dc             	mov    -0x24(%rbp),%edx
  803cca:	89 c6                	mov    %eax,%esi
  803ccc:	48 bf 70 16 82 00 00 	movabs $0x821670,%rdi
  803cd3:	00 00 00 
  803cd6:	b8 00 00 00 00       	mov    $0x0,%eax
  803cdb:	48 b9 32 13 80 00 00 	movabs $0x801332,%rcx
  803ce2:	00 00 00 
  803ce5:	ff d1                	callq  *%rcx
			thisenv->env_id, fdnum);
		return -E_INVAL;
  803ce7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803cec:	eb 2a                	jmp    803d18 <ftruncate+0xca>
	}
	if (!dev->dev_trunc)
  803cee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803cf2:	48 8b 40 30          	mov    0x30(%rax),%rax
  803cf6:	48 85 c0             	test   %rax,%rax
  803cf9:	75 07                	jne    803d02 <ftruncate+0xb4>
		return -E_NOT_SUPP;
  803cfb:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803d00:	eb 16                	jmp    803d18 <ftruncate+0xca>
	return (*dev->dev_trunc)(fd, newsize);
  803d02:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803d06:	48 8b 40 30          	mov    0x30(%rax),%rax
  803d0a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  803d0e:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  803d11:	89 ce                	mov    %ecx,%esi
  803d13:	48 89 d7             	mov    %rdx,%rdi
  803d16:	ff d0                	callq  *%rax
}
  803d18:	c9                   	leaveq 
  803d19:	c3                   	retq   

0000000000803d1a <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  803d1a:	55                   	push   %rbp
  803d1b:	48 89 e5             	mov    %rsp,%rbp
  803d1e:	48 83 ec 30          	sub    $0x30,%rsp
  803d22:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803d25:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  803d29:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803d2d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803d30:	48 89 d6             	mov    %rdx,%rsi
  803d33:	89 c7                	mov    %eax,%edi
  803d35:	48 b8 b5 35 80 00 00 	movabs $0x8035b5,%rax
  803d3c:	00 00 00 
  803d3f:	ff d0                	callq  *%rax
  803d41:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803d44:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803d48:	78 24                	js     803d6e <fstat+0x54>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803d4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803d4e:	8b 00                	mov    (%rax),%eax
  803d50:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803d54:	48 89 d6             	mov    %rdx,%rsi
  803d57:	89 c7                	mov    %eax,%edi
  803d59:	48 b8 10 37 80 00 00 	movabs $0x803710,%rax
  803d60:	00 00 00 
  803d63:	ff d0                	callq  *%rax
  803d65:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803d68:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803d6c:	79 05                	jns    803d73 <fstat+0x59>
		return r;
  803d6e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803d71:	eb 5e                	jmp    803dd1 <fstat+0xb7>
	if (!dev->dev_stat)
  803d73:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803d77:	48 8b 40 28          	mov    0x28(%rax),%rax
  803d7b:	48 85 c0             	test   %rax,%rax
  803d7e:	75 07                	jne    803d87 <fstat+0x6d>
		return -E_NOT_SUPP;
  803d80:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803d85:	eb 4a                	jmp    803dd1 <fstat+0xb7>
	stat->st_name[0] = 0;
  803d87:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803d8b:	c6 00 00             	movb   $0x0,(%rax)
	stat->st_size = 0;
  803d8e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803d92:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%rax)
  803d99:	00 00 00 
	stat->st_isdir = 0;
  803d9c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803da0:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%rax)
  803da7:	00 00 00 
	stat->st_dev = dev;
  803daa:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  803dae:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803db2:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
	return (*dev->dev_stat)(fd, stat);
  803db9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803dbd:	48 8b 40 28          	mov    0x28(%rax),%rax
  803dc1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  803dc5:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  803dc9:	48 89 ce             	mov    %rcx,%rsi
  803dcc:	48 89 d7             	mov    %rdx,%rdi
  803dcf:	ff d0                	callq  *%rax
}
  803dd1:	c9                   	leaveq 
  803dd2:	c3                   	retq   

0000000000803dd3 <stat>:

int
stat(const char *path, struct Stat *stat)
{
  803dd3:	55                   	push   %rbp
  803dd4:	48 89 e5             	mov    %rsp,%rbp
  803dd7:	48 83 ec 20          	sub    $0x20,%rsp
  803ddb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803ddf:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  803de3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803de7:	be 00 00 00 00       	mov    $0x0,%esi
  803dec:	48 89 c7             	mov    %rax,%rdi
  803def:	48 b8 c3 3e 80 00 00 	movabs $0x803ec3,%rax
  803df6:	00 00 00 
  803df9:	ff d0                	callq  *%rax
  803dfb:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803dfe:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803e02:	79 05                	jns    803e09 <stat+0x36>
		return fd;
  803e04:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803e07:	eb 2f                	jmp    803e38 <stat+0x65>
	r = fstat(fd, stat);
  803e09:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  803e0d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803e10:	48 89 d6             	mov    %rdx,%rsi
  803e13:	89 c7                	mov    %eax,%edi
  803e15:	48 b8 1a 3d 80 00 00 	movabs $0x803d1a,%rax
  803e1c:	00 00 00 
  803e1f:	ff d0                	callq  *%rax
  803e21:	89 45 f8             	mov    %eax,-0x8(%rbp)
	close(fd);
  803e24:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803e27:	89 c7                	mov    %eax,%edi
  803e29:	48 b8 c7 37 80 00 00 	movabs $0x8037c7,%rax
  803e30:	00 00 00 
  803e33:	ff d0                	callq  *%rax
	return r;
  803e35:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  803e38:	c9                   	leaveq 
  803e39:	c3                   	retq   

0000000000803e3a <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  803e3a:	55                   	push   %rbp
  803e3b:	48 89 e5             	mov    %rsp,%rbp
  803e3e:	48 83 ec 10          	sub    $0x10,%rsp
  803e42:	89 7d fc             	mov    %edi,-0x4(%rbp)
  803e45:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	static envid_t fsenv;
	if (fsenv == 0)
  803e49:	48 b8 84 90 82 00 00 	movabs $0x829084,%rax
  803e50:	00 00 00 
  803e53:	8b 00                	mov    (%rax),%eax
  803e55:	85 c0                	test   %eax,%eax
  803e57:	75 1f                	jne    803e78 <fsipc+0x3e>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  803e59:	bf 01 00 00 00       	mov    $0x1,%edi
  803e5e:	48 b8 5e 34 80 00 00 	movabs $0x80345e,%rax
  803e65:	00 00 00 
  803e68:	ff d0                	callq  *%rax
  803e6a:	89 c2                	mov    %eax,%edx
  803e6c:	48 b8 84 90 82 00 00 	movabs $0x829084,%rax
  803e73:	00 00 00 
  803e76:	89 10                	mov    %edx,(%rax)
	//static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  803e78:	48 b8 84 90 82 00 00 	movabs $0x829084,%rax
  803e7f:	00 00 00 
  803e82:	8b 00                	mov    (%rax),%eax
  803e84:	8b 75 fc             	mov    -0x4(%rbp),%esi
  803e87:	b9 07 00 00 00       	mov    $0x7,%ecx
  803e8c:	48 ba 00 80 b5 00 00 	movabs $0xb58000,%rdx
  803e93:	00 00 00 
  803e96:	89 c7                	mov    %eax,%edi
  803e98:	48 b8 c9 33 80 00 00 	movabs $0x8033c9,%rax
  803e9f:	00 00 00 
  803ea2:	ff d0                	callq  *%rax
	return ipc_recv(NULL, dstva, NULL);
  803ea4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803ea8:	ba 00 00 00 00       	mov    $0x0,%edx
  803ead:	48 89 c6             	mov    %rax,%rsi
  803eb0:	bf 00 00 00 00       	mov    $0x0,%edi
  803eb5:	48 b8 08 33 80 00 00 	movabs $0x803308,%rax
  803ebc:	00 00 00 
  803ebf:	ff d0                	callq  *%rax
}
  803ec1:	c9                   	leaveq 
  803ec2:	c3                   	retq   

0000000000803ec3 <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  803ec3:	55                   	push   %rbp
  803ec4:	48 89 e5             	mov    %rsp,%rbp
  803ec7:	48 83 ec 20          	sub    $0x20,%rsp
  803ecb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803ecf:	89 75 e4             	mov    %esi,-0x1c(%rbp)


	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
  803ed2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803ed6:	48 89 c7             	mov    %rax,%rdi
  803ed9:	48 b8 56 1e 80 00 00 	movabs $0x801e56,%rax
  803ee0:	00 00 00 
  803ee3:	ff d0                	callq  *%rax
  803ee5:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  803eea:	7e 0a                	jle    803ef6 <open+0x33>
		return -E_BAD_PATH;
  803eec:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
  803ef1:	e9 a5 00 00 00       	jmpq   803f9b <open+0xd8>

	if ((r = fd_alloc(&fd)) < 0)
  803ef6:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  803efa:	48 89 c7             	mov    %rax,%rdi
  803efd:	48 b8 1d 35 80 00 00 	movabs $0x80351d,%rax
  803f04:	00 00 00 
  803f07:	ff d0                	callq  *%rax
  803f09:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803f0c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803f10:	79 08                	jns    803f1a <open+0x57>
		return r;
  803f12:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803f15:	e9 81 00 00 00       	jmpq   803f9b <open+0xd8>

	strcpy(fsipcbuf.open.req_path, path);
  803f1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803f1e:	48 89 c6             	mov    %rax,%rsi
  803f21:	48 bf 00 80 b5 00 00 	movabs $0xb58000,%rdi
  803f28:	00 00 00 
  803f2b:	48 b8 c2 1e 80 00 00 	movabs $0x801ec2,%rax
  803f32:	00 00 00 
  803f35:	ff d0                	callq  *%rax
	fsipcbuf.open.req_omode = mode;
  803f37:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803f3e:	00 00 00 
  803f41:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  803f44:	89 90 00 04 00 00    	mov    %edx,0x400(%rax)

	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  803f4a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803f4e:	48 89 c6             	mov    %rax,%rsi
  803f51:	bf 01 00 00 00       	mov    $0x1,%edi
  803f56:	48 b8 3a 3e 80 00 00 	movabs $0x803e3a,%rax
  803f5d:	00 00 00 
  803f60:	ff d0                	callq  *%rax
  803f62:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803f65:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803f69:	79 1d                	jns    803f88 <open+0xc5>
		fd_close(fd, 0);
  803f6b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803f6f:	be 00 00 00 00       	mov    $0x0,%esi
  803f74:	48 89 c7             	mov    %rax,%rdi
  803f77:	48 b8 45 36 80 00 00 	movabs $0x803645,%rax
  803f7e:	00 00 00 
  803f81:	ff d0                	callq  *%rax
		return r;
  803f83:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803f86:	eb 13                	jmp    803f9b <open+0xd8>
	}

	return fd2num(fd);
  803f88:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803f8c:	48 89 c7             	mov    %rax,%rdi
  803f8f:	48 b8 cf 34 80 00 00 	movabs $0x8034cf,%rax
  803f96:	00 00 00 
  803f99:	ff d0                	callq  *%rax

}
  803f9b:	c9                   	leaveq 
  803f9c:	c3                   	retq   

0000000000803f9d <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  803f9d:	55                   	push   %rbp
  803f9e:	48 89 e5             	mov    %rsp,%rbp
  803fa1:	48 83 ec 10          	sub    $0x10,%rsp
  803fa5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  803fa9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803fad:	8b 50 0c             	mov    0xc(%rax),%edx
  803fb0:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803fb7:	00 00 00 
  803fba:	89 10                	mov    %edx,(%rax)
	return fsipc(FSREQ_FLUSH, NULL);
  803fbc:	be 00 00 00 00       	mov    $0x0,%esi
  803fc1:	bf 06 00 00 00       	mov    $0x6,%edi
  803fc6:	48 b8 3a 3e 80 00 00 	movabs $0x803e3a,%rax
  803fcd:	00 00 00 
  803fd0:	ff d0                	callq  *%rax
}
  803fd2:	c9                   	leaveq 
  803fd3:	c3                   	retq   

0000000000803fd4 <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  803fd4:	55                   	push   %rbp
  803fd5:	48 89 e5             	mov    %rsp,%rbp
  803fd8:	48 83 ec 30          	sub    $0x30,%rsp
  803fdc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803fe0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803fe4:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// bytes read will be written back to fsipcbuf by the file
	// system server.

	int r;

	fsipcbuf.read.req_fileid = fd->fd_file.id;
  803fe8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803fec:	8b 50 0c             	mov    0xc(%rax),%edx
  803fef:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803ff6:	00 00 00 
  803ff9:	89 10                	mov    %edx,(%rax)
	fsipcbuf.read.req_n = n;
  803ffb:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  804002:	00 00 00 
  804005:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  804009:	48 89 50 08          	mov    %rdx,0x8(%rax)
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  80400d:	be 00 00 00 00       	mov    $0x0,%esi
  804012:	bf 03 00 00 00       	mov    $0x3,%edi
  804017:	48 b8 3a 3e 80 00 00 	movabs $0x803e3a,%rax
  80401e:	00 00 00 
  804021:	ff d0                	callq  *%rax
  804023:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804026:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80402a:	79 08                	jns    804034 <devfile_read+0x60>
		return r;
  80402c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80402f:	e9 a4 00 00 00       	jmpq   8040d8 <devfile_read+0x104>
	assert(r <= n);
  804034:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804037:	48 98                	cltq   
  804039:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80403d:	76 35                	jbe    804074 <devfile_read+0xa0>
  80403f:	48 b9 96 16 82 00 00 	movabs $0x821696,%rcx
  804046:	00 00 00 
  804049:	48 ba 9d 16 82 00 00 	movabs $0x82169d,%rdx
  804050:	00 00 00 
  804053:	be 86 00 00 00       	mov    $0x86,%esi
  804058:	48 bf b2 16 82 00 00 	movabs $0x8216b2,%rdi
  80405f:	00 00 00 
  804062:	b8 00 00 00 00       	mov    $0x0,%eax
  804067:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  80406e:	00 00 00 
  804071:	41 ff d0             	callq  *%r8
	assert(r <= PGSIZE);
  804074:	81 7d fc 00 10 00 00 	cmpl   $0x1000,-0x4(%rbp)
  80407b:	7e 35                	jle    8040b2 <devfile_read+0xde>
  80407d:	48 b9 bd 16 82 00 00 	movabs $0x8216bd,%rcx
  804084:	00 00 00 
  804087:	48 ba 9d 16 82 00 00 	movabs $0x82169d,%rdx
  80408e:	00 00 00 
  804091:	be 87 00 00 00       	mov    $0x87,%esi
  804096:	48 bf b2 16 82 00 00 	movabs $0x8216b2,%rdi
  80409d:	00 00 00 
  8040a0:	b8 00 00 00 00       	mov    $0x0,%eax
  8040a5:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  8040ac:	00 00 00 
  8040af:	41 ff d0             	callq  *%r8
	memmove(buf, &fsipcbuf, r);
  8040b2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8040b5:	48 63 d0             	movslq %eax,%rdx
  8040b8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8040bc:	48 be 00 80 b5 00 00 	movabs $0xb58000,%rsi
  8040c3:	00 00 00 
  8040c6:	48 89 c7             	mov    %rax,%rdi
  8040c9:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  8040d0:	00 00 00 
  8040d3:	ff d0                	callq  *%rax
	return r;
  8040d5:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  8040d8:	c9                   	leaveq 
  8040d9:	c3                   	retq   

00000000008040da <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  8040da:	55                   	push   %rbp
  8040db:	48 89 e5             	mov    %rsp,%rbp
  8040de:	48 83 ec 40          	sub    $0x40,%rsp
  8040e2:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8040e6:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8040ea:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	// remember that write is always allowed to write *fewer*
	// bytes than requested.

	int r;

	n = MIN(n, sizeof(fsipcbuf.write.req_buf));
  8040ee:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8040f2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8040f6:	48 c7 45 f0 f4 0f 00 	movq   $0xff4,-0x10(%rbp)
  8040fd:	00 
  8040fe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804102:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  804106:	48 0f 46 45 f8       	cmovbe -0x8(%rbp),%rax
  80410b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	fsipcbuf.write.req_fileid = fd->fd_file.id;
  80410f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804113:	8b 50 0c             	mov    0xc(%rax),%edx
  804116:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  80411d:	00 00 00 
  804120:	89 10                	mov    %edx,(%rax)
	fsipcbuf.write.req_n = n;
  804122:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  804129:	00 00 00 
  80412c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804130:	48 89 50 08          	mov    %rdx,0x8(%rax)
	memmove(fsipcbuf.write.req_buf, buf, n);
  804134:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  804138:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80413c:	48 89 c6             	mov    %rax,%rsi
  80413f:	48 bf 10 80 b5 00 00 	movabs $0xb58010,%rdi
  804146:	00 00 00 
  804149:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  804150:	00 00 00 
  804153:	ff d0                	callq  *%rax
	if ((r = fsipc(FSREQ_WRITE, NULL)) < 0)
  804155:	be 00 00 00 00       	mov    $0x0,%esi
  80415a:	bf 04 00 00 00       	mov    $0x4,%edi
  80415f:	48 b8 3a 3e 80 00 00 	movabs $0x803e3a,%rax
  804166:	00 00 00 
  804169:	ff d0                	callq  *%rax
  80416b:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80416e:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  804172:	79 05                	jns    804179 <devfile_write+0x9f>
		return r;
  804174:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804177:	eb 43                	jmp    8041bc <devfile_write+0xe2>
	assert(r <= n);
  804179:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80417c:	48 98                	cltq   
  80417e:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  804182:	76 35                	jbe    8041b9 <devfile_write+0xdf>
  804184:	48 b9 96 16 82 00 00 	movabs $0x821696,%rcx
  80418b:	00 00 00 
  80418e:	48 ba 9d 16 82 00 00 	movabs $0x82169d,%rdx
  804195:	00 00 00 
  804198:	be a2 00 00 00       	mov    $0xa2,%esi
  80419d:	48 bf b2 16 82 00 00 	movabs $0x8216b2,%rdi
  8041a4:	00 00 00 
  8041a7:	b8 00 00 00 00       	mov    $0x0,%eax
  8041ac:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  8041b3:	00 00 00 
  8041b6:	41 ff d0             	callq  *%r8
	return r;
  8041b9:	8b 45 ec             	mov    -0x14(%rbp),%eax

}
  8041bc:	c9                   	leaveq 
  8041bd:	c3                   	retq   

00000000008041be <devfile_stat>:

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  8041be:	55                   	push   %rbp
  8041bf:	48 89 e5             	mov    %rsp,%rbp
  8041c2:	48 83 ec 20          	sub    $0x20,%rsp
  8041c6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8041ca:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  8041ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8041d2:	8b 50 0c             	mov    0xc(%rax),%edx
  8041d5:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  8041dc:	00 00 00 
  8041df:	89 10                	mov    %edx,(%rax)
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  8041e1:	be 00 00 00 00       	mov    $0x0,%esi
  8041e6:	bf 05 00 00 00       	mov    $0x5,%edi
  8041eb:	48 b8 3a 3e 80 00 00 	movabs $0x803e3a,%rax
  8041f2:	00 00 00 
  8041f5:	ff d0                	callq  *%rax
  8041f7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8041fa:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8041fe:	79 05                	jns    804205 <devfile_stat+0x47>
		return r;
  804200:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804203:	eb 56                	jmp    80425b <devfile_stat+0x9d>
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  804205:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804209:	48 be 00 80 b5 00 00 	movabs $0xb58000,%rsi
  804210:	00 00 00 
  804213:	48 89 c7             	mov    %rax,%rdi
  804216:	48 b8 c2 1e 80 00 00 	movabs $0x801ec2,%rax
  80421d:	00 00 00 
  804220:	ff d0                	callq  *%rax
	st->st_size = fsipcbuf.statRet.ret_size;
  804222:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  804229:	00 00 00 
  80422c:	8b 90 80 00 00 00    	mov    0x80(%rax),%edx
  804232:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804236:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  80423c:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  804243:	00 00 00 
  804246:	8b 90 84 00 00 00    	mov    0x84(%rax),%edx
  80424c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804250:	89 90 84 00 00 00    	mov    %edx,0x84(%rax)
	return 0;
  804256:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80425b:	c9                   	leaveq 
  80425c:	c3                   	retq   

000000000080425d <devfile_trunc>:

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  80425d:	55                   	push   %rbp
  80425e:	48 89 e5             	mov    %rsp,%rbp
  804261:	48 83 ec 10          	sub    $0x10,%rsp
  804265:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  804269:	89 75 f4             	mov    %esi,-0xc(%rbp)
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  80426c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804270:	8b 50 0c             	mov    0xc(%rax),%edx
  804273:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  80427a:	00 00 00 
  80427d:	89 10                	mov    %edx,(%rax)
	fsipcbuf.set_size.req_size = newsize;
  80427f:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  804286:	00 00 00 
  804289:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80428c:	89 50 04             	mov    %edx,0x4(%rax)
	return fsipc(FSREQ_SET_SIZE, NULL);
  80428f:	be 00 00 00 00       	mov    $0x0,%esi
  804294:	bf 02 00 00 00       	mov    $0x2,%edi
  804299:	48 b8 3a 3e 80 00 00 	movabs $0x803e3a,%rax
  8042a0:	00 00 00 
  8042a3:	ff d0                	callq  *%rax
}
  8042a5:	c9                   	leaveq 
  8042a6:	c3                   	retq   

00000000008042a7 <remove>:

// Delete a file
int
remove(const char *path)
{
  8042a7:	55                   	push   %rbp
  8042a8:	48 89 e5             	mov    %rsp,%rbp
  8042ab:	48 83 ec 10          	sub    $0x10,%rsp
  8042af:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (strlen(path) >= MAXPATHLEN)
  8042b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8042b7:	48 89 c7             	mov    %rax,%rdi
  8042ba:	48 b8 56 1e 80 00 00 	movabs $0x801e56,%rax
  8042c1:	00 00 00 
  8042c4:	ff d0                	callq  *%rax
  8042c6:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  8042cb:	7e 07                	jle    8042d4 <remove+0x2d>
		return -E_BAD_PATH;
  8042cd:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
  8042d2:	eb 33                	jmp    804307 <remove+0x60>
	strcpy(fsipcbuf.remove.req_path, path);
  8042d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8042d8:	48 89 c6             	mov    %rax,%rsi
  8042db:	48 bf 00 80 b5 00 00 	movabs $0xb58000,%rdi
  8042e2:	00 00 00 
  8042e5:	48 b8 c2 1e 80 00 00 	movabs $0x801ec2,%rax
  8042ec:	00 00 00 
  8042ef:	ff d0                	callq  *%rax
	return fsipc(FSREQ_REMOVE, NULL);
  8042f1:	be 00 00 00 00       	mov    $0x0,%esi
  8042f6:	bf 07 00 00 00       	mov    $0x7,%edi
  8042fb:	48 b8 3a 3e 80 00 00 	movabs $0x803e3a,%rax
  804302:	00 00 00 
  804305:	ff d0                	callq  *%rax
}
  804307:	c9                   	leaveq 
  804308:	c3                   	retq   

0000000000804309 <sync>:

// Synchronize disk with buffer cache
int
sync(void)
{
  804309:	55                   	push   %rbp
  80430a:	48 89 e5             	mov    %rsp,%rbp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  80430d:	be 00 00 00 00       	mov    $0x0,%esi
  804312:	bf 08 00 00 00       	mov    $0x8,%edi
  804317:	48 b8 3a 3e 80 00 00 	movabs $0x803e3a,%rax
  80431e:	00 00 00 
  804321:	ff d0                	callq  *%rax
}
  804323:	5d                   	pop    %rbp
  804324:	c3                   	retq   

0000000000804325 <copy>:

//Copy a file from src to dest
int
copy(char *src, char *dest)
{
  804325:	55                   	push   %rbp
  804326:	48 89 e5             	mov    %rsp,%rbp
  804329:	48 81 ec 20 02 00 00 	sub    $0x220,%rsp
  804330:	48 89 bd e8 fd ff ff 	mov    %rdi,-0x218(%rbp)
  804337:	48 89 b5 e0 fd ff ff 	mov    %rsi,-0x220(%rbp)
	int r;
	int fd_src, fd_dest;
	char buffer[512];	//keep this small
	ssize_t read_size;
	ssize_t write_size;
	fd_src = open(src, O_RDONLY);
  80433e:	48 8b 85 e8 fd ff ff 	mov    -0x218(%rbp),%rax
  804345:	be 00 00 00 00       	mov    $0x0,%esi
  80434a:	48 89 c7             	mov    %rax,%rdi
  80434d:	48 b8 c3 3e 80 00 00 	movabs $0x803ec3,%rax
  804354:	00 00 00 
  804357:	ff d0                	callq  *%rax
  804359:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (fd_src < 0) {	//error
  80435c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804360:	79 28                	jns    80438a <copy+0x65>
		cprintf("cp open src error:%e\n", fd_src);
  804362:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804365:	89 c6                	mov    %eax,%esi
  804367:	48 bf c9 16 82 00 00 	movabs $0x8216c9,%rdi
  80436e:	00 00 00 
  804371:	b8 00 00 00 00       	mov    $0x0,%eax
  804376:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  80437d:	00 00 00 
  804380:	ff d2                	callq  *%rdx
		return fd_src;
  804382:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804385:	e9 76 01 00 00       	jmpq   804500 <copy+0x1db>
	}
	
	fd_dest = open(dest, O_CREAT | O_WRONLY);
  80438a:	48 8b 85 e0 fd ff ff 	mov    -0x220(%rbp),%rax
  804391:	be 01 01 00 00       	mov    $0x101,%esi
  804396:	48 89 c7             	mov    %rax,%rdi
  804399:	48 b8 c3 3e 80 00 00 	movabs $0x803ec3,%rax
  8043a0:	00 00 00 
  8043a3:	ff d0                	callq  *%rax
  8043a5:	89 45 f8             	mov    %eax,-0x8(%rbp)
	if (fd_dest < 0) {	//error
  8043a8:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8043ac:	0f 89 ad 00 00 00    	jns    80445f <copy+0x13a>
		cprintf("cp create dest  error:%e\n", fd_dest);
  8043b2:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8043b5:	89 c6                	mov    %eax,%esi
  8043b7:	48 bf df 16 82 00 00 	movabs $0x8216df,%rdi
  8043be:	00 00 00 
  8043c1:	b8 00 00 00 00       	mov    $0x0,%eax
  8043c6:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8043cd:	00 00 00 
  8043d0:	ff d2                	callq  *%rdx
		close(fd_src);
  8043d2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8043d5:	89 c7                	mov    %eax,%edi
  8043d7:	48 b8 c7 37 80 00 00 	movabs $0x8037c7,%rax
  8043de:	00 00 00 
  8043e1:	ff d0                	callq  *%rax
		return fd_dest;
  8043e3:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8043e6:	e9 15 01 00 00       	jmpq   804500 <copy+0x1db>
	}
	
	while ((read_size = read(fd_src, buffer, 512)) > 0) {
		write_size = write(fd_dest, buffer, read_size);
  8043eb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8043ee:	48 63 d0             	movslq %eax,%rdx
  8043f1:	48 8d 8d f0 fd ff ff 	lea    -0x210(%rbp),%rcx
  8043f8:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8043fb:	48 89 ce             	mov    %rcx,%rsi
  8043fe:	89 c7                	mov    %eax,%edi
  804400:	48 b8 35 3b 80 00 00 	movabs $0x803b35,%rax
  804407:	00 00 00 
  80440a:	ff d0                	callq  *%rax
  80440c:	89 45 f0             	mov    %eax,-0x10(%rbp)
		if (write_size < 0) {
  80440f:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  804413:	79 4a                	jns    80445f <copy+0x13a>
			cprintf("cp write error:%e\n", write_size);
  804415:	8b 45 f0             	mov    -0x10(%rbp),%eax
  804418:	89 c6                	mov    %eax,%esi
  80441a:	48 bf f9 16 82 00 00 	movabs $0x8216f9,%rdi
  804421:	00 00 00 
  804424:	b8 00 00 00 00       	mov    $0x0,%eax
  804429:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  804430:	00 00 00 
  804433:	ff d2                	callq  *%rdx
			close(fd_src);
  804435:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804438:	89 c7                	mov    %eax,%edi
  80443a:	48 b8 c7 37 80 00 00 	movabs $0x8037c7,%rax
  804441:	00 00 00 
  804444:	ff d0                	callq  *%rax
			close(fd_dest);
  804446:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804449:	89 c7                	mov    %eax,%edi
  80444b:	48 b8 c7 37 80 00 00 	movabs $0x8037c7,%rax
  804452:	00 00 00 
  804455:	ff d0                	callq  *%rax
			return write_size;
  804457:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80445a:	e9 a1 00 00 00       	jmpq   804500 <copy+0x1db>
		cprintf("cp create dest  error:%e\n", fd_dest);
		close(fd_src);
		return fd_dest;
	}
	
	while ((read_size = read(fd_src, buffer, 512)) > 0) {
  80445f:	48 8d 8d f0 fd ff ff 	lea    -0x210(%rbp),%rcx
  804466:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804469:	ba 00 02 00 00       	mov    $0x200,%edx
  80446e:	48 89 ce             	mov    %rcx,%rsi
  804471:	89 c7                	mov    %eax,%edi
  804473:	48 b8 ea 39 80 00 00 	movabs $0x8039ea,%rax
  80447a:	00 00 00 
  80447d:	ff d0                	callq  *%rax
  80447f:	89 45 f4             	mov    %eax,-0xc(%rbp)
  804482:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  804486:	0f 8f 5f ff ff ff    	jg     8043eb <copy+0xc6>
			close(fd_src);
			close(fd_dest);
			return write_size;
		}		
	}
	if (read_size < 0) {
  80448c:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  804490:	79 47                	jns    8044d9 <copy+0x1b4>
		cprintf("cp read src error:%e\n", read_size);
  804492:	8b 45 f4             	mov    -0xc(%rbp),%eax
  804495:	89 c6                	mov    %eax,%esi
  804497:	48 bf 0c 17 82 00 00 	movabs $0x82170c,%rdi
  80449e:	00 00 00 
  8044a1:	b8 00 00 00 00       	mov    $0x0,%eax
  8044a6:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8044ad:	00 00 00 
  8044b0:	ff d2                	callq  *%rdx
		close(fd_src);
  8044b2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8044b5:	89 c7                	mov    %eax,%edi
  8044b7:	48 b8 c7 37 80 00 00 	movabs $0x8037c7,%rax
  8044be:	00 00 00 
  8044c1:	ff d0                	callq  *%rax
		close(fd_dest);
  8044c3:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8044c6:	89 c7                	mov    %eax,%edi
  8044c8:	48 b8 c7 37 80 00 00 	movabs $0x8037c7,%rax
  8044cf:	00 00 00 
  8044d2:	ff d0                	callq  *%rax
		return read_size;
  8044d4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8044d7:	eb 27                	jmp    804500 <copy+0x1db>
	}
	close(fd_src);
  8044d9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8044dc:	89 c7                	mov    %eax,%edi
  8044de:	48 b8 c7 37 80 00 00 	movabs $0x8037c7,%rax
  8044e5:	00 00 00 
  8044e8:	ff d0                	callq  *%rax
	close(fd_dest);
  8044ea:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8044ed:	89 c7                	mov    %eax,%edi
  8044ef:	48 b8 c7 37 80 00 00 	movabs $0x8037c7,%rax
  8044f6:	00 00 00 
  8044f9:	ff d0                	callq  *%rax
	return 0;
  8044fb:	b8 00 00 00 00       	mov    $0x0,%eax
	
}
  804500:	c9                   	leaveq 
  804501:	c3                   	retq   

0000000000804502 <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  804502:	55                   	push   %rbp
  804503:	48 89 e5             	mov    %rsp,%rbp
  804506:	48 83 ec 20          	sub    $0x20,%rsp
  80450a:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  80450d:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  804511:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804514:	48 89 d6             	mov    %rdx,%rsi
  804517:	89 c7                	mov    %eax,%edi
  804519:	48 b8 b5 35 80 00 00 	movabs $0x8035b5,%rax
  804520:	00 00 00 
  804523:	ff d0                	callq  *%rax
  804525:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804528:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80452c:	79 05                	jns    804533 <fd2sockid+0x31>
		return r;
  80452e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804531:	eb 24                	jmp    804557 <fd2sockid+0x55>
	if (sfd->fd_dev_id != devsock.dev_id)
  804533:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804537:	8b 10                	mov    (%rax),%edx
  804539:	48 b8 a0 80 82 00 00 	movabs $0x8280a0,%rax
  804540:	00 00 00 
  804543:	8b 00                	mov    (%rax),%eax
  804545:	39 c2                	cmp    %eax,%edx
  804547:	74 07                	je     804550 <fd2sockid+0x4e>
		return -E_NOT_SUPP;
  804549:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  80454e:	eb 07                	jmp    804557 <fd2sockid+0x55>
	return sfd->fd_sock.sockid;
  804550:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804554:	8b 40 0c             	mov    0xc(%rax),%eax
}
  804557:	c9                   	leaveq 
  804558:	c3                   	retq   

0000000000804559 <alloc_sockfd>:

static int
alloc_sockfd(int sockid)
{
  804559:	55                   	push   %rbp
  80455a:	48 89 e5             	mov    %rsp,%rbp
  80455d:	48 83 ec 20          	sub    $0x20,%rsp
  804561:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  804564:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  804568:	48 89 c7             	mov    %rax,%rdi
  80456b:	48 b8 1d 35 80 00 00 	movabs $0x80351d,%rax
  804572:	00 00 00 
  804575:	ff d0                	callq  *%rax
  804577:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80457a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80457e:	78 26                	js     8045a6 <alloc_sockfd+0x4d>
            || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  804580:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804584:	ba 07 04 00 00       	mov    $0x407,%edx
  804589:	48 89 c6             	mov    %rax,%rsi
  80458c:	bf 00 00 00 00       	mov    $0x0,%edi
  804591:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  804598:	00 00 00 
  80459b:	ff d0                	callq  *%rax
  80459d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8045a0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8045a4:	79 16                	jns    8045bc <alloc_sockfd+0x63>
		nsipc_close(sockid);
  8045a6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8045a9:	89 c7                	mov    %eax,%edi
  8045ab:	48 b8 68 4a 80 00 00 	movabs $0x804a68,%rax
  8045b2:	00 00 00 
  8045b5:	ff d0                	callq  *%rax
		return r;
  8045b7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8045ba:	eb 3a                	jmp    8045f6 <alloc_sockfd+0x9d>
	}

	sfd->fd_dev_id = devsock.dev_id;
  8045bc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8045c0:	48 ba a0 80 82 00 00 	movabs $0x8280a0,%rdx
  8045c7:	00 00 00 
  8045ca:	8b 12                	mov    (%rdx),%edx
  8045cc:	89 10                	mov    %edx,(%rax)
	sfd->fd_omode = O_RDWR;
  8045ce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8045d2:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%rax)
	sfd->fd_sock.sockid = sockid;
  8045d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8045dd:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8045e0:	89 50 0c             	mov    %edx,0xc(%rax)
	return fd2num(sfd);
  8045e3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8045e7:	48 89 c7             	mov    %rax,%rdi
  8045ea:	48 b8 cf 34 80 00 00 	movabs $0x8034cf,%rax
  8045f1:	00 00 00 
  8045f4:	ff d0                	callq  *%rax
}
  8045f6:	c9                   	leaveq 
  8045f7:	c3                   	retq   

00000000008045f8 <accept>:

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  8045f8:	55                   	push   %rbp
  8045f9:	48 89 e5             	mov    %rsp,%rbp
  8045fc:	48 83 ec 30          	sub    $0x30,%rsp
  804600:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804603:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804607:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  80460b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80460e:	89 c7                	mov    %eax,%edi
  804610:	48 b8 02 45 80 00 00 	movabs $0x804502,%rax
  804617:	00 00 00 
  80461a:	ff d0                	callq  *%rax
  80461c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80461f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804623:	79 05                	jns    80462a <accept+0x32>
		return r;
  804625:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804628:	eb 3b                	jmp    804665 <accept+0x6d>
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  80462a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80462e:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  804632:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804635:	48 89 ce             	mov    %rcx,%rsi
  804638:	89 c7                	mov    %eax,%edi
  80463a:	48 b8 45 49 80 00 00 	movabs $0x804945,%rax
  804641:	00 00 00 
  804644:	ff d0                	callq  *%rax
  804646:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804649:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80464d:	79 05                	jns    804654 <accept+0x5c>
		return r;
  80464f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804652:	eb 11                	jmp    804665 <accept+0x6d>
	return alloc_sockfd(r);
  804654:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804657:	89 c7                	mov    %eax,%edi
  804659:	48 b8 59 45 80 00 00 	movabs $0x804559,%rax
  804660:	00 00 00 
  804663:	ff d0                	callq  *%rax
}
  804665:	c9                   	leaveq 
  804666:	c3                   	retq   

0000000000804667 <bind>:

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  804667:	55                   	push   %rbp
  804668:	48 89 e5             	mov    %rsp,%rbp
  80466b:	48 83 ec 20          	sub    $0x20,%rsp
  80466f:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804672:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804676:	89 55 e8             	mov    %edx,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  804679:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80467c:	89 c7                	mov    %eax,%edi
  80467e:	48 b8 02 45 80 00 00 	movabs $0x804502,%rax
  804685:	00 00 00 
  804688:	ff d0                	callq  *%rax
  80468a:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80468d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804691:	79 05                	jns    804698 <bind+0x31>
		return r;
  804693:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804696:	eb 1b                	jmp    8046b3 <bind+0x4c>
	return nsipc_bind(r, name, namelen);
  804698:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80469b:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80469f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8046a2:	48 89 ce             	mov    %rcx,%rsi
  8046a5:	89 c7                	mov    %eax,%edi
  8046a7:	48 b8 c4 49 80 00 00 	movabs $0x8049c4,%rax
  8046ae:	00 00 00 
  8046b1:	ff d0                	callq  *%rax
}
  8046b3:	c9                   	leaveq 
  8046b4:	c3                   	retq   

00000000008046b5 <shutdown>:

int
shutdown(int s, int how)
{
  8046b5:	55                   	push   %rbp
  8046b6:	48 89 e5             	mov    %rsp,%rbp
  8046b9:	48 83 ec 20          	sub    $0x20,%rsp
  8046bd:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8046c0:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  8046c3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8046c6:	89 c7                	mov    %eax,%edi
  8046c8:	48 b8 02 45 80 00 00 	movabs $0x804502,%rax
  8046cf:	00 00 00 
  8046d2:	ff d0                	callq  *%rax
  8046d4:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8046d7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8046db:	79 05                	jns    8046e2 <shutdown+0x2d>
		return r;
  8046dd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8046e0:	eb 16                	jmp    8046f8 <shutdown+0x43>
	return nsipc_shutdown(r, how);
  8046e2:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8046e5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8046e8:	89 d6                	mov    %edx,%esi
  8046ea:	89 c7                	mov    %eax,%edi
  8046ec:	48 b8 28 4a 80 00 00 	movabs $0x804a28,%rax
  8046f3:	00 00 00 
  8046f6:	ff d0                	callq  *%rax
}
  8046f8:	c9                   	leaveq 
  8046f9:	c3                   	retq   

00000000008046fa <devsock_close>:

static int
devsock_close(struct Fd *fd)
{
  8046fa:	55                   	push   %rbp
  8046fb:	48 89 e5             	mov    %rsp,%rbp
  8046fe:	48 83 ec 10          	sub    $0x10,%rsp
  804702:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (pageref(fd) == 1)
  804706:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80470a:	48 89 c7             	mov    %rax,%rdi
  80470d:	48 b8 25 5c 80 00 00 	movabs $0x805c25,%rax
  804714:	00 00 00 
  804717:	ff d0                	callq  *%rax
  804719:	83 f8 01             	cmp    $0x1,%eax
  80471c:	75 17                	jne    804735 <devsock_close+0x3b>
		return nsipc_close(fd->fd_sock.sockid);
  80471e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804722:	8b 40 0c             	mov    0xc(%rax),%eax
  804725:	89 c7                	mov    %eax,%edi
  804727:	48 b8 68 4a 80 00 00 	movabs $0x804a68,%rax
  80472e:	00 00 00 
  804731:	ff d0                	callq  *%rax
  804733:	eb 05                	jmp    80473a <devsock_close+0x40>
	else
		return 0;
  804735:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80473a:	c9                   	leaveq 
  80473b:	c3                   	retq   

000000000080473c <connect>:

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  80473c:	55                   	push   %rbp
  80473d:	48 89 e5             	mov    %rsp,%rbp
  804740:	48 83 ec 20          	sub    $0x20,%rsp
  804744:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804747:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80474b:	89 55 e8             	mov    %edx,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  80474e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804751:	89 c7                	mov    %eax,%edi
  804753:	48 b8 02 45 80 00 00 	movabs $0x804502,%rax
  80475a:	00 00 00 
  80475d:	ff d0                	callq  *%rax
  80475f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804762:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804766:	79 05                	jns    80476d <connect+0x31>
		return r;
  804768:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80476b:	eb 1b                	jmp    804788 <connect+0x4c>
	return nsipc_connect(r, name, namelen);
  80476d:	8b 55 e8             	mov    -0x18(%rbp),%edx
  804770:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  804774:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804777:	48 89 ce             	mov    %rcx,%rsi
  80477a:	89 c7                	mov    %eax,%edi
  80477c:	48 b8 95 4a 80 00 00 	movabs $0x804a95,%rax
  804783:	00 00 00 
  804786:	ff d0                	callq  *%rax
}
  804788:	c9                   	leaveq 
  804789:	c3                   	retq   

000000000080478a <listen>:

int
listen(int s, int backlog)
{
  80478a:	55                   	push   %rbp
  80478b:	48 89 e5             	mov    %rsp,%rbp
  80478e:	48 83 ec 20          	sub    $0x20,%rsp
  804792:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804795:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  804798:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80479b:	89 c7                	mov    %eax,%edi
  80479d:	48 b8 02 45 80 00 00 	movabs $0x804502,%rax
  8047a4:	00 00 00 
  8047a7:	ff d0                	callq  *%rax
  8047a9:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8047ac:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8047b0:	79 05                	jns    8047b7 <listen+0x2d>
		return r;
  8047b2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8047b5:	eb 16                	jmp    8047cd <listen+0x43>
	return nsipc_listen(r, backlog);
  8047b7:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8047ba:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8047bd:	89 d6                	mov    %edx,%esi
  8047bf:	89 c7                	mov    %eax,%edi
  8047c1:	48 b8 f9 4a 80 00 00 	movabs $0x804af9,%rax
  8047c8:	00 00 00 
  8047cb:	ff d0                	callq  *%rax
}
  8047cd:	c9                   	leaveq 
  8047ce:	c3                   	retq   

00000000008047cf <devsock_read>:

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  8047cf:	55                   	push   %rbp
  8047d0:	48 89 e5             	mov    %rsp,%rbp
  8047d3:	48 83 ec 20          	sub    $0x20,%rsp
  8047d7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8047db:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8047df:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  8047e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8047e7:	89 c2                	mov    %eax,%edx
  8047e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8047ed:	8b 40 0c             	mov    0xc(%rax),%eax
  8047f0:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8047f4:	b9 00 00 00 00       	mov    $0x0,%ecx
  8047f9:	89 c7                	mov    %eax,%edi
  8047fb:	48 b8 39 4b 80 00 00 	movabs $0x804b39,%rax
  804802:	00 00 00 
  804805:	ff d0                	callq  *%rax
}
  804807:	c9                   	leaveq 
  804808:	c3                   	retq   

0000000000804809 <devsock_write>:

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  804809:	55                   	push   %rbp
  80480a:	48 89 e5             	mov    %rsp,%rbp
  80480d:	48 83 ec 20          	sub    $0x20,%rsp
  804811:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  804815:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804819:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  80481d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804821:	89 c2                	mov    %eax,%edx
  804823:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804827:	8b 40 0c             	mov    0xc(%rax),%eax
  80482a:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80482e:	b9 00 00 00 00       	mov    $0x0,%ecx
  804833:	89 c7                	mov    %eax,%edi
  804835:	48 b8 05 4c 80 00 00 	movabs $0x804c05,%rax
  80483c:	00 00 00 
  80483f:	ff d0                	callq  *%rax
}
  804841:	c9                   	leaveq 
  804842:	c3                   	retq   

0000000000804843 <devsock_stat>:

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  804843:	55                   	push   %rbp
  804844:	48 89 e5             	mov    %rsp,%rbp
  804847:	48 83 ec 10          	sub    $0x10,%rsp
  80484b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80484f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	strcpy(stat->st_name, "<sock>");
  804853:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804857:	48 be 27 17 82 00 00 	movabs $0x821727,%rsi
  80485e:	00 00 00 
  804861:	48 89 c7             	mov    %rax,%rdi
  804864:	48 b8 c2 1e 80 00 00 	movabs $0x801ec2,%rax
  80486b:	00 00 00 
  80486e:	ff d0                	callq  *%rax
	return 0;
  804870:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804875:	c9                   	leaveq 
  804876:	c3                   	retq   

0000000000804877 <socket>:

int
socket(int domain, int type, int protocol)
{
  804877:	55                   	push   %rbp
  804878:	48 89 e5             	mov    %rsp,%rbp
  80487b:	48 83 ec 20          	sub    $0x20,%rsp
  80487f:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804882:	89 75 e8             	mov    %esi,-0x18(%rbp)
  804885:	89 55 e4             	mov    %edx,-0x1c(%rbp)
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  804888:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80488b:	8b 4d e8             	mov    -0x18(%rbp),%ecx
  80488e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804891:	89 ce                	mov    %ecx,%esi
  804893:	89 c7                	mov    %eax,%edi
  804895:	48 b8 bd 4c 80 00 00 	movabs $0x804cbd,%rax
  80489c:	00 00 00 
  80489f:	ff d0                	callq  *%rax
  8048a1:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8048a4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8048a8:	79 05                	jns    8048af <socket+0x38>
		return r;
  8048aa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8048ad:	eb 11                	jmp    8048c0 <socket+0x49>
	return alloc_sockfd(r);
  8048af:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8048b2:	89 c7                	mov    %eax,%edi
  8048b4:	48 b8 59 45 80 00 00 	movabs $0x804559,%rax
  8048bb:	00 00 00 
  8048be:	ff d0                	callq  *%rax
}
  8048c0:	c9                   	leaveq 
  8048c1:	c3                   	retq   

00000000008048c2 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  8048c2:	55                   	push   %rbp
  8048c3:	48 89 e5             	mov    %rsp,%rbp
  8048c6:	48 83 ec 10          	sub    $0x10,%rsp
  8048ca:	89 7d fc             	mov    %edi,-0x4(%rbp)
	static envid_t nsenv;
	if (nsenv == 0)
  8048cd:	48 b8 88 90 82 00 00 	movabs $0x829088,%rax
  8048d4:	00 00 00 
  8048d7:	8b 00                	mov    (%rax),%eax
  8048d9:	85 c0                	test   %eax,%eax
  8048db:	75 1f                	jne    8048fc <nsipc+0x3a>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  8048dd:	bf 02 00 00 00       	mov    $0x2,%edi
  8048e2:	48 b8 5e 34 80 00 00 	movabs $0x80345e,%rax
  8048e9:	00 00 00 
  8048ec:	ff d0                	callq  *%rax
  8048ee:	89 c2                	mov    %eax,%edx
  8048f0:	48 b8 88 90 82 00 00 	movabs $0x829088,%rax
  8048f7:	00 00 00 
  8048fa:	89 10                	mov    %edx,(%rax)
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  8048fc:	48 b8 88 90 82 00 00 	movabs $0x829088,%rax
  804903:	00 00 00 
  804906:	8b 00                	mov    (%rax),%eax
  804908:	8b 75 fc             	mov    -0x4(%rbp),%esi
  80490b:	b9 07 00 00 00       	mov    $0x7,%ecx
  804910:	48 ba 00 a0 b5 00 00 	movabs $0xb5a000,%rdx
  804917:	00 00 00 
  80491a:	89 c7                	mov    %eax,%edi
  80491c:	48 b8 c9 33 80 00 00 	movabs $0x8033c9,%rax
  804923:	00 00 00 
  804926:	ff d0                	callq  *%rax
	return ipc_recv(NULL, NULL, NULL);
  804928:	ba 00 00 00 00       	mov    $0x0,%edx
  80492d:	be 00 00 00 00       	mov    $0x0,%esi
  804932:	bf 00 00 00 00       	mov    $0x0,%edi
  804937:	48 b8 08 33 80 00 00 	movabs $0x803308,%rax
  80493e:	00 00 00 
  804941:	ff d0                	callq  *%rax
}
  804943:	c9                   	leaveq 
  804944:	c3                   	retq   

0000000000804945 <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  804945:	55                   	push   %rbp
  804946:	48 89 e5             	mov    %rsp,%rbp
  804949:	48 83 ec 30          	sub    $0x30,%rsp
  80494d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804950:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804954:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int r;

	nsipcbuf.accept.req_s = s;
  804958:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80495f:	00 00 00 
  804962:	8b 55 ec             	mov    -0x14(%rbp),%edx
  804965:	89 10                	mov    %edx,(%rax)
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  804967:	bf 01 00 00 00       	mov    $0x1,%edi
  80496c:	48 b8 c2 48 80 00 00 	movabs $0x8048c2,%rax
  804973:	00 00 00 
  804976:	ff d0                	callq  *%rax
  804978:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80497b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80497f:	78 3e                	js     8049bf <nsipc_accept+0x7a>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
  804981:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804988:	00 00 00 
  80498b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  80498f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804993:	8b 40 10             	mov    0x10(%rax),%eax
  804996:	89 c2                	mov    %eax,%edx
  804998:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80499c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8049a0:	48 89 ce             	mov    %rcx,%rsi
  8049a3:	48 89 c7             	mov    %rax,%rdi
  8049a6:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  8049ad:	00 00 00 
  8049b0:	ff d0                	callq  *%rax
		*addrlen = ret->ret_addrlen;
  8049b2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8049b6:	8b 50 10             	mov    0x10(%rax),%edx
  8049b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8049bd:	89 10                	mov    %edx,(%rax)
	}
	return r;
  8049bf:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8049c2:	c9                   	leaveq 
  8049c3:	c3                   	retq   

00000000008049c4 <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  8049c4:	55                   	push   %rbp
  8049c5:	48 89 e5             	mov    %rsp,%rbp
  8049c8:	48 83 ec 10          	sub    $0x10,%rsp
  8049cc:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8049cf:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8049d3:	89 55 f8             	mov    %edx,-0x8(%rbp)
	nsipcbuf.bind.req_s = s;
  8049d6:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8049dd:	00 00 00 
  8049e0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8049e3:	89 10                	mov    %edx,(%rax)
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  8049e5:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8049e8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8049ec:	48 89 c6             	mov    %rax,%rsi
  8049ef:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  8049f6:	00 00 00 
  8049f9:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  804a00:	00 00 00 
  804a03:	ff d0                	callq  *%rax
	nsipcbuf.bind.req_namelen = namelen;
  804a05:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804a0c:	00 00 00 
  804a0f:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804a12:	89 50 14             	mov    %edx,0x14(%rax)
	return nsipc(NSREQ_BIND);
  804a15:	bf 02 00 00 00       	mov    $0x2,%edi
  804a1a:	48 b8 c2 48 80 00 00 	movabs $0x8048c2,%rax
  804a21:	00 00 00 
  804a24:	ff d0                	callq  *%rax
}
  804a26:	c9                   	leaveq 
  804a27:	c3                   	retq   

0000000000804a28 <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  804a28:	55                   	push   %rbp
  804a29:	48 89 e5             	mov    %rsp,%rbp
  804a2c:	48 83 ec 10          	sub    $0x10,%rsp
  804a30:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804a33:	89 75 f8             	mov    %esi,-0x8(%rbp)
	nsipcbuf.shutdown.req_s = s;
  804a36:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804a3d:	00 00 00 
  804a40:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804a43:	89 10                	mov    %edx,(%rax)
	nsipcbuf.shutdown.req_how = how;
  804a45:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804a4c:	00 00 00 
  804a4f:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804a52:	89 50 04             	mov    %edx,0x4(%rax)
	return nsipc(NSREQ_SHUTDOWN);
  804a55:	bf 03 00 00 00       	mov    $0x3,%edi
  804a5a:	48 b8 c2 48 80 00 00 	movabs $0x8048c2,%rax
  804a61:	00 00 00 
  804a64:	ff d0                	callq  *%rax
}
  804a66:	c9                   	leaveq 
  804a67:	c3                   	retq   

0000000000804a68 <nsipc_close>:

int
nsipc_close(int s)
{
  804a68:	55                   	push   %rbp
  804a69:	48 89 e5             	mov    %rsp,%rbp
  804a6c:	48 83 ec 10          	sub    $0x10,%rsp
  804a70:	89 7d fc             	mov    %edi,-0x4(%rbp)
	nsipcbuf.close.req_s = s;
  804a73:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804a7a:	00 00 00 
  804a7d:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804a80:	89 10                	mov    %edx,(%rax)
	return nsipc(NSREQ_CLOSE);
  804a82:	bf 04 00 00 00       	mov    $0x4,%edi
  804a87:	48 b8 c2 48 80 00 00 	movabs $0x8048c2,%rax
  804a8e:	00 00 00 
  804a91:	ff d0                	callq  *%rax
}
  804a93:	c9                   	leaveq 
  804a94:	c3                   	retq   

0000000000804a95 <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  804a95:	55                   	push   %rbp
  804a96:	48 89 e5             	mov    %rsp,%rbp
  804a99:	48 83 ec 10          	sub    $0x10,%rsp
  804a9d:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804aa0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804aa4:	89 55 f8             	mov    %edx,-0x8(%rbp)
	nsipcbuf.connect.req_s = s;
  804aa7:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804aae:	00 00 00 
  804ab1:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804ab4:	89 10                	mov    %edx,(%rax)
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  804ab6:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804ab9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804abd:	48 89 c6             	mov    %rax,%rsi
  804ac0:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  804ac7:	00 00 00 
  804aca:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  804ad1:	00 00 00 
  804ad4:	ff d0                	callq  *%rax
	nsipcbuf.connect.req_namelen = namelen;
  804ad6:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804add:	00 00 00 
  804ae0:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804ae3:	89 50 14             	mov    %edx,0x14(%rax)
	return nsipc(NSREQ_CONNECT);
  804ae6:	bf 05 00 00 00       	mov    $0x5,%edi
  804aeb:	48 b8 c2 48 80 00 00 	movabs $0x8048c2,%rax
  804af2:	00 00 00 
  804af5:	ff d0                	callq  *%rax
}
  804af7:	c9                   	leaveq 
  804af8:	c3                   	retq   

0000000000804af9 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  804af9:	55                   	push   %rbp
  804afa:	48 89 e5             	mov    %rsp,%rbp
  804afd:	48 83 ec 10          	sub    $0x10,%rsp
  804b01:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804b04:	89 75 f8             	mov    %esi,-0x8(%rbp)
	nsipcbuf.listen.req_s = s;
  804b07:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804b0e:	00 00 00 
  804b11:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804b14:	89 10                	mov    %edx,(%rax)
	nsipcbuf.listen.req_backlog = backlog;
  804b16:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804b1d:	00 00 00 
  804b20:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804b23:	89 50 04             	mov    %edx,0x4(%rax)
	return nsipc(NSREQ_LISTEN);
  804b26:	bf 06 00 00 00       	mov    $0x6,%edi
  804b2b:	48 b8 c2 48 80 00 00 	movabs $0x8048c2,%rax
  804b32:	00 00 00 
  804b35:	ff d0                	callq  *%rax
}
  804b37:	c9                   	leaveq 
  804b38:	c3                   	retq   

0000000000804b39 <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  804b39:	55                   	push   %rbp
  804b3a:	48 89 e5             	mov    %rsp,%rbp
  804b3d:	48 83 ec 30          	sub    $0x30,%rsp
  804b41:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804b44:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804b48:	89 55 e8             	mov    %edx,-0x18(%rbp)
  804b4b:	89 4d dc             	mov    %ecx,-0x24(%rbp)
	int r;

	nsipcbuf.recv.req_s = s;
  804b4e:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804b55:	00 00 00 
  804b58:	8b 55 ec             	mov    -0x14(%rbp),%edx
  804b5b:	89 10                	mov    %edx,(%rax)
	nsipcbuf.recv.req_len = len;
  804b5d:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804b64:	00 00 00 
  804b67:	8b 55 e8             	mov    -0x18(%rbp),%edx
  804b6a:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.recv.req_flags = flags;
  804b6d:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804b74:	00 00 00 
  804b77:	8b 55 dc             	mov    -0x24(%rbp),%edx
  804b7a:	89 50 08             	mov    %edx,0x8(%rax)

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  804b7d:	bf 07 00 00 00       	mov    $0x7,%edi
  804b82:	48 b8 c2 48 80 00 00 	movabs $0x8048c2,%rax
  804b89:	00 00 00 
  804b8c:	ff d0                	callq  *%rax
  804b8e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804b91:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804b95:	78 69                	js     804c00 <nsipc_recv+0xc7>
		assert(r < 1600 && r <= len);
  804b97:	81 7d fc 3f 06 00 00 	cmpl   $0x63f,-0x4(%rbp)
  804b9e:	7f 08                	jg     804ba8 <nsipc_recv+0x6f>
  804ba0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804ba3:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  804ba6:	7e 35                	jle    804bdd <nsipc_recv+0xa4>
  804ba8:	48 b9 2e 17 82 00 00 	movabs $0x82172e,%rcx
  804baf:	00 00 00 
  804bb2:	48 ba 43 17 82 00 00 	movabs $0x821743,%rdx
  804bb9:	00 00 00 
  804bbc:	be 62 00 00 00       	mov    $0x62,%esi
  804bc1:	48 bf 58 17 82 00 00 	movabs $0x821758,%rdi
  804bc8:	00 00 00 
  804bcb:	b8 00 00 00 00       	mov    $0x0,%eax
  804bd0:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  804bd7:	00 00 00 
  804bda:	41 ff d0             	callq  *%r8
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  804bdd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804be0:	48 63 d0             	movslq %eax,%rdx
  804be3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804be7:	48 be 00 a0 b5 00 00 	movabs $0xb5a000,%rsi
  804bee:	00 00 00 
  804bf1:	48 89 c7             	mov    %rax,%rdi
  804bf4:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  804bfb:	00 00 00 
  804bfe:	ff d0                	callq  *%rax
	}

	return r;
  804c00:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  804c03:	c9                   	leaveq 
  804c04:	c3                   	retq   

0000000000804c05 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  804c05:	55                   	push   %rbp
  804c06:	48 89 e5             	mov    %rsp,%rbp
  804c09:	48 83 ec 20          	sub    $0x20,%rsp
  804c0d:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804c10:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804c14:	89 55 f8             	mov    %edx,-0x8(%rbp)
  804c17:	89 4d ec             	mov    %ecx,-0x14(%rbp)
	nsipcbuf.send.req_s = s;
  804c1a:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804c21:	00 00 00 
  804c24:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804c27:	89 10                	mov    %edx,(%rax)
	assert(size < 1600);
  804c29:	81 7d f8 3f 06 00 00 	cmpl   $0x63f,-0x8(%rbp)
  804c30:	7e 35                	jle    804c67 <nsipc_send+0x62>
  804c32:	48 b9 64 17 82 00 00 	movabs $0x821764,%rcx
  804c39:	00 00 00 
  804c3c:	48 ba 43 17 82 00 00 	movabs $0x821743,%rdx
  804c43:	00 00 00 
  804c46:	be 6d 00 00 00       	mov    $0x6d,%esi
  804c4b:	48 bf 58 17 82 00 00 	movabs $0x821758,%rdi
  804c52:	00 00 00 
  804c55:	b8 00 00 00 00       	mov    $0x0,%eax
  804c5a:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  804c61:	00 00 00 
  804c64:	41 ff d0             	callq  *%r8
	memmove(&nsipcbuf.send.req_buf, buf, size);
  804c67:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804c6a:	48 63 d0             	movslq %eax,%rdx
  804c6d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804c71:	48 89 c6             	mov    %rax,%rsi
  804c74:	48 bf 0c a0 b5 00 00 	movabs $0xb5a00c,%rdi
  804c7b:	00 00 00 
  804c7e:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  804c85:	00 00 00 
  804c88:	ff d0                	callq  *%rax
	nsipcbuf.send.req_size = size;
  804c8a:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804c91:	00 00 00 
  804c94:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804c97:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.send.req_flags = flags;
  804c9a:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804ca1:	00 00 00 
  804ca4:	8b 55 ec             	mov    -0x14(%rbp),%edx
  804ca7:	89 50 08             	mov    %edx,0x8(%rax)
	return nsipc(NSREQ_SEND);
  804caa:	bf 08 00 00 00       	mov    $0x8,%edi
  804caf:	48 b8 c2 48 80 00 00 	movabs $0x8048c2,%rax
  804cb6:	00 00 00 
  804cb9:	ff d0                	callq  *%rax
}
  804cbb:	c9                   	leaveq 
  804cbc:	c3                   	retq   

0000000000804cbd <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  804cbd:	55                   	push   %rbp
  804cbe:	48 89 e5             	mov    %rsp,%rbp
  804cc1:	48 83 ec 10          	sub    $0x10,%rsp
  804cc5:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804cc8:	89 75 f8             	mov    %esi,-0x8(%rbp)
  804ccb:	89 55 f4             	mov    %edx,-0xc(%rbp)
	nsipcbuf.socket.req_domain = domain;
  804cce:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804cd5:	00 00 00 
  804cd8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804cdb:	89 10                	mov    %edx,(%rax)
	nsipcbuf.socket.req_type = type;
  804cdd:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804ce4:	00 00 00 
  804ce7:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804cea:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.socket.req_protocol = protocol;
  804ced:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804cf4:	00 00 00 
  804cf7:	8b 55 f4             	mov    -0xc(%rbp),%edx
  804cfa:	89 50 08             	mov    %edx,0x8(%rax)
	return nsipc(NSREQ_SOCKET);
  804cfd:	bf 09 00 00 00       	mov    $0x9,%edi
  804d02:	48 b8 c2 48 80 00 00 	movabs $0x8048c2,%rax
  804d09:	00 00 00 
  804d0c:	ff d0                	callq  *%rax
}
  804d0e:	c9                   	leaveq 
  804d0f:	c3                   	retq   

0000000000804d10 <isfree>:
static uint8_t *mend   = (uint8_t*) 0x10000000;
static uint8_t *mptr;

static int
isfree(void *v, size_t n)
{
  804d10:	55                   	push   %rbp
  804d11:	48 89 e5             	mov    %rsp,%rbp
  804d14:	48 83 ec 20          	sub    $0x20,%rsp
  804d18:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  804d1c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uintptr_t va, end_va = (uintptr_t) v + n;
  804d20:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  804d24:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804d28:	48 01 d0             	add    %rdx,%rax
  804d2b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  804d2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804d33:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  804d37:	eb 64                	jmp    804d9d <isfree+0x8d>
		if (va >= (uintptr_t) mend
  804d39:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  804d40:	00 00 00 
  804d43:	48 8b 00             	mov    (%rax),%rax
  804d46:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  804d4a:	73 42                	jae    804d8e <isfree+0x7e>
		    || ((uvpd[VPD(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  804d4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804d50:	48 c1 e8 15          	shr    $0x15,%rax
  804d54:	48 89 c2             	mov    %rax,%rdx
  804d57:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  804d5e:	01 00 00 
  804d61:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  804d65:	83 e0 01             	and    $0x1,%eax
  804d68:	48 85 c0             	test   %rax,%rax
  804d6b:	74 28                	je     804d95 <isfree+0x85>
  804d6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804d71:	48 c1 e8 0c          	shr    $0xc,%rax
  804d75:	48 89 c2             	mov    %rax,%rdx
  804d78:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  804d7f:	01 00 00 
  804d82:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  804d86:	83 e0 01             	and    $0x1,%eax
  804d89:	48 85 c0             	test   %rax,%rax
  804d8c:	74 07                	je     804d95 <isfree+0x85>
			return 0;
  804d8e:	b8 00 00 00 00       	mov    $0x0,%eax
  804d93:	eb 17                	jmp    804dac <isfree+0x9c>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  804d95:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  804d9c:	00 
  804d9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804da1:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  804da5:	72 92                	jb     804d39 <isfree+0x29>
		if (va >= (uintptr_t) mend
		    || ((uvpd[VPD(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
			return 0;
	return 1;
  804da7:	b8 01 00 00 00       	mov    $0x1,%eax
}
  804dac:	c9                   	leaveq 
  804dad:	c3                   	retq   

0000000000804dae <malloc>:

void*
malloc(size_t n)
{
  804dae:	55                   	push   %rbp
  804daf:	48 89 e5             	mov    %rsp,%rbp
  804db2:	48 83 ec 60          	sub    $0x60,%rsp
  804db6:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  804dba:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804dc1:	00 00 00 
  804dc4:	48 8b 00             	mov    (%rax),%rax
  804dc7:	48 85 c0             	test   %rax,%rax
  804dca:	75 1a                	jne    804de6 <malloc+0x38>
		mptr = mbegin;
  804dcc:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  804dd3:	00 00 00 
  804dd6:	48 8b 10             	mov    (%rax),%rdx
  804dd9:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804de0:	00 00 00 
  804de3:	48 89 10             	mov    %rdx,(%rax)

	n = ROUNDUP(n, 4);
  804de6:	48 c7 45 f0 04 00 00 	movq   $0x4,-0x10(%rbp)
  804ded:	00 
  804dee:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804df2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804df6:	48 01 d0             	add    %rdx,%rax
  804df9:	48 83 e8 01          	sub    $0x1,%rax
  804dfd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  804e01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804e05:	ba 00 00 00 00       	mov    $0x0,%edx
  804e0a:	48 f7 75 f0          	divq   -0x10(%rbp)
  804e0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804e12:	48 29 d0             	sub    %rdx,%rax
  804e15:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	
	if (n >= MAXMALLOC)
  804e19:	48 81 7d a8 ff ff 0f 	cmpq   $0xfffff,-0x58(%rbp)
  804e20:	00 
  804e21:	76 0a                	jbe    804e2d <malloc+0x7f>
		return 0;
  804e23:	b8 00 00 00 00       	mov    $0x0,%eax
  804e28:	e9 f0 02 00 00       	jmpq   80511d <malloc+0x36f>
	
	if ((uintptr_t) mptr % PGSIZE){
  804e2d:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804e34:	00 00 00 
  804e37:	48 8b 00             	mov    (%rax),%rax
  804e3a:	25 ff 0f 00 00       	and    $0xfff,%eax
  804e3f:	48 85 c0             	test   %rax,%rax
  804e42:	0f 84 0f 01 00 00    	je     804f57 <malloc+0x1a9>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  804e48:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  804e4f:	00 
  804e50:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804e57:	00 00 00 
  804e5a:	48 8b 00             	mov    (%rax),%rax
  804e5d:	48 89 c2             	mov    %rax,%rdx
  804e60:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804e64:	48 01 d0             	add    %rdx,%rax
  804e67:	48 83 e8 01          	sub    $0x1,%rax
  804e6b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  804e6f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804e73:	ba 00 00 00 00       	mov    $0x0,%edx
  804e78:	48 f7 75 e0          	divq   -0x20(%rbp)
  804e7c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804e80:	48 29 d0             	sub    %rdx,%rax
  804e83:	48 83 e8 04          	sub    $0x4,%rax
  804e87:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  804e8b:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804e92:	00 00 00 
  804e95:	48 8b 00             	mov    (%rax),%rax
  804e98:	48 c1 e8 0c          	shr    $0xc,%rax
  804e9c:	48 89 c1             	mov    %rax,%rcx
  804e9f:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804ea6:	00 00 00 
  804ea9:	48 8b 00             	mov    (%rax),%rax
  804eac:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804eb0:	48 83 c2 03          	add    $0x3,%rdx
  804eb4:	48 01 d0             	add    %rdx,%rax
  804eb7:	48 c1 e8 0c          	shr    $0xc,%rax
  804ebb:	48 39 c1             	cmp    %rax,%rcx
  804ebe:	75 4a                	jne    804f0a <malloc+0x15c>
			(*ref)++;
  804ec0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804ec4:	8b 00                	mov    (%rax),%eax
  804ec6:	8d 50 01             	lea    0x1(%rax),%edx
  804ec9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804ecd:	89 10                	mov    %edx,(%rax)
			v = mptr;
  804ecf:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804ed6:	00 00 00 
  804ed9:	48 8b 00             	mov    (%rax),%rax
  804edc:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			mptr += n;
  804ee0:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804ee7:	00 00 00 
  804eea:	48 8b 10             	mov    (%rax),%rdx
  804eed:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804ef1:	48 01 c2             	add    %rax,%rdx
  804ef4:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804efb:	00 00 00 
  804efe:	48 89 10             	mov    %rdx,(%rax)
			return v;
  804f01:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804f05:	e9 13 02 00 00       	jmpq   80511d <malloc+0x36f>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  804f0a:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804f11:	00 00 00 
  804f14:	48 8b 00             	mov    (%rax),%rax
  804f17:	48 89 c7             	mov    %rax,%rdi
  804f1a:	48 b8 1f 51 80 00 00 	movabs $0x80511f,%rax
  804f21:	00 00 00 
  804f24:	ff d0                	callq  *%rax
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  804f26:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804f2d:	00 00 00 
  804f30:	48 8b 00             	mov    (%rax),%rax
  804f33:	48 05 00 10 00 00    	add    $0x1000,%rax
  804f39:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804f3d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804f41:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  804f47:	48 89 c2             	mov    %rax,%rdx
  804f4a:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804f51:	00 00 00 
  804f54:	48 89 10             	mov    %rdx,(%rax)
	 * now we need to find some address space for this chunk.
	 * if it's less than a page we leave it open for allocation.
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
  804f57:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	while (1) {
		if (isfree(mptr, n + 4))
  804f5e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804f62:	48 8d 50 04          	lea    0x4(%rax),%rdx
  804f66:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804f6d:	00 00 00 
  804f70:	48 8b 00             	mov    (%rax),%rax
  804f73:	48 89 d6             	mov    %rdx,%rsi
  804f76:	48 89 c7             	mov    %rax,%rdi
  804f79:	48 b8 10 4d 80 00 00 	movabs $0x804d10,%rax
  804f80:	00 00 00 
  804f83:	ff d0                	callq  *%rax
  804f85:	85 c0                	test   %eax,%eax
  804f87:	75 72                	jne    804ffb <malloc+0x24d>
			break;
		mptr += PGSIZE;
  804f89:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804f90:	00 00 00 
  804f93:	48 8b 00             	mov    (%rax),%rax
  804f96:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  804f9d:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804fa4:	00 00 00 
  804fa7:	48 89 10             	mov    %rdx,(%rax)
		if (mptr == mend) {
  804faa:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804fb1:	00 00 00 
  804fb4:	48 8b 10             	mov    (%rax),%rdx
  804fb7:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  804fbe:	00 00 00 
  804fc1:	48 8b 00             	mov    (%rax),%rax
  804fc4:	48 39 c2             	cmp    %rax,%rdx
  804fc7:	75 95                	jne    804f5e <malloc+0x1b0>
			mptr = mbegin;
  804fc9:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  804fd0:	00 00 00 
  804fd3:	48 8b 10             	mov    (%rax),%rdx
  804fd6:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804fdd:	00 00 00 
  804fe0:	48 89 10             	mov    %rdx,(%rax)
			if (++nwrap == 2)
  804fe3:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  804fe7:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  804feb:	0f 85 6d ff ff ff    	jne    804f5e <malloc+0x1b0>
				return 0;	/* out of address space */
  804ff1:	b8 00 00 00 00       	mov    $0x0,%eax
  804ff6:	e9 22 01 00 00       	jmpq   80511d <malloc+0x36f>
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
  804ffb:	90                   	nop
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  804ffc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  805003:	e9 a1 00 00 00       	jmpq   8050a9 <malloc+0x2fb>
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  805008:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80500b:	05 00 10 00 00       	add    $0x1000,%eax
  805010:	48 98                	cltq   
  805012:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  805016:	48 83 c2 04          	add    $0x4,%rdx
  80501a:	48 39 d0             	cmp    %rdx,%rax
  80501d:	73 07                	jae    805026 <malloc+0x278>
  80501f:	b8 00 04 00 00       	mov    $0x400,%eax
  805024:	eb 05                	jmp    80502b <malloc+0x27d>
  805026:	b8 00 00 00 00       	mov    $0x0,%eax
  80502b:	89 45 bc             	mov    %eax,-0x44(%rbp)
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  80502e:	8b 45 bc             	mov    -0x44(%rbp),%eax
  805031:	83 c8 07             	or     $0x7,%eax
  805034:	89 c2                	mov    %eax,%edx
  805036:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  80503d:	00 00 00 
  805040:	48 8b 08             	mov    (%rax),%rcx
  805043:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805046:	48 98                	cltq   
  805048:	48 01 c8             	add    %rcx,%rax
  80504b:	48 89 c6             	mov    %rax,%rsi
  80504e:	bf 00 00 00 00       	mov    $0x0,%edi
  805053:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  80505a:	00 00 00 
  80505d:	ff d0                	callq  *%rax
  80505f:	85 c0                	test   %eax,%eax
  805061:	79 3f                	jns    8050a2 <malloc+0x2f4>
			for (; i >= 0; i -= PGSIZE)
  805063:	eb 30                	jmp    805095 <malloc+0x2e7>
				sys_page_unmap(0, mptr + i);
  805065:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  80506c:	00 00 00 
  80506f:	48 8b 10             	mov    (%rax),%rdx
  805072:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805075:	48 98                	cltq   
  805077:	48 01 d0             	add    %rdx,%rax
  80507a:	48 89 c6             	mov    %rax,%rsi
  80507d:	bf 00 00 00 00       	mov    $0x0,%edi
  805082:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  805089:	00 00 00 
  80508c:	ff d0                	callq  *%rax
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  80508e:	81 6d fc 00 10 00 00 	subl   $0x1000,-0x4(%rbp)
  805095:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805099:	79 ca                	jns    805065 <malloc+0x2b7>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
  80509b:	b8 00 00 00 00       	mov    $0x0,%eax
  8050a0:	eb 7b                	jmp    80511d <malloc+0x36f>
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  8050a2:	81 45 fc 00 10 00 00 	addl   $0x1000,-0x4(%rbp)
  8050a9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8050ac:	48 98                	cltq   
  8050ae:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8050b2:	48 83 c2 04          	add    $0x4,%rdx
  8050b6:	48 39 d0             	cmp    %rdx,%rax
  8050b9:	0f 82 49 ff ff ff    	jb     805008 <malloc+0x25a>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  8050bf:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  8050c6:	00 00 00 
  8050c9:	48 8b 00             	mov    (%rax),%rax
  8050cc:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8050cf:	48 63 d2             	movslq %edx,%rdx
  8050d2:	48 83 ea 04          	sub    $0x4,%rdx
  8050d6:	48 01 d0             	add    %rdx,%rax
  8050d9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	*ref = 2;	/* reference for mptr, reference for returned block */
  8050dd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8050e1:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
	v = mptr;
  8050e7:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  8050ee:	00 00 00 
  8050f1:	48 8b 00             	mov    (%rax),%rax
  8050f4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	mptr += n;
  8050f8:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  8050ff:	00 00 00 
  805102:	48 8b 10             	mov    (%rax),%rdx
  805105:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  805109:	48 01 c2             	add    %rax,%rdx
  80510c:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  805113:	00 00 00 
  805116:	48 89 10             	mov    %rdx,(%rax)
	return v;
  805119:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  80511d:	c9                   	leaveq 
  80511e:	c3                   	retq   

000000000080511f <free>:

void
free(void *v)
{
  80511f:	55                   	push   %rbp
  805120:	48 89 e5             	mov    %rsp,%rbp
  805123:	48 83 ec 30          	sub    $0x30,%rsp
  805127:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  80512b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  805130:	0f 84 56 01 00 00    	je     80528c <free+0x16d>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  805136:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  80513d:	00 00 00 
  805140:	48 8b 00             	mov    (%rax),%rax
  805143:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  805147:	77 13                	ja     80515c <free+0x3d>
  805149:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  805150:	00 00 00 
  805153:	48 8b 00             	mov    (%rax),%rax
  805156:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80515a:	72 35                	jb     805191 <free+0x72>
  80515c:	48 b9 70 17 82 00 00 	movabs $0x821770,%rcx
  805163:	00 00 00 
  805166:	48 ba 9e 17 82 00 00 	movabs $0x82179e,%rdx
  80516d:	00 00 00 
  805170:	be 7b 00 00 00       	mov    $0x7b,%esi
  805175:	48 bf b3 17 82 00 00 	movabs $0x8217b3,%rdi
  80517c:	00 00 00 
  80517f:	b8 00 00 00 00       	mov    $0x0,%eax
  805184:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  80518b:	00 00 00 
  80518e:	41 ff d0             	callq  *%r8

	c = ROUNDDOWN(v, PGSIZE);
  805191:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805195:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  805199:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80519d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8051a3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  8051a7:	eb 7b                	jmp    805224 <free+0x105>
		sys_page_unmap(0, c);
  8051a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8051ad:	48 89 c6             	mov    %rax,%rsi
  8051b0:	bf 00 00 00 00       	mov    $0x0,%edi
  8051b5:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  8051bc:	00 00 00 
  8051bf:	ff d0                	callq  *%rax
		c += PGSIZE;
  8051c1:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8051c8:	00 
		assert(mbegin <= c && c < mend);
  8051c9:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  8051d0:	00 00 00 
  8051d3:	48 8b 00             	mov    (%rax),%rax
  8051d6:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8051da:	77 13                	ja     8051ef <free+0xd0>
  8051dc:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  8051e3:	00 00 00 
  8051e6:	48 8b 00             	mov    (%rax),%rax
  8051e9:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8051ed:	72 35                	jb     805224 <free+0x105>
  8051ef:	48 b9 c0 17 82 00 00 	movabs $0x8217c0,%rcx
  8051f6:	00 00 00 
  8051f9:	48 ba 9e 17 82 00 00 	movabs $0x82179e,%rdx
  805200:	00 00 00 
  805203:	be 82 00 00 00       	mov    $0x82,%esi
  805208:	48 bf b3 17 82 00 00 	movabs $0x8217b3,%rdi
  80520f:	00 00 00 
  805212:	b8 00 00 00 00       	mov    $0x0,%eax
  805217:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  80521e:	00 00 00 
  805221:	41 ff d0             	callq  *%r8
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  805224:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805228:	48 c1 e8 0c          	shr    $0xc,%rax
  80522c:	48 89 c2             	mov    %rax,%rdx
  80522f:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  805236:	01 00 00 
  805239:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80523d:	25 00 04 00 00       	and    $0x400,%eax
  805242:	48 85 c0             	test   %rax,%rax
  805245:	0f 85 5e ff ff ff    	jne    8051a9 <free+0x8a>

	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
  80524b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80524f:	48 05 fc 0f 00 00    	add    $0xffc,%rax
  805255:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (--(*ref) == 0)
  805259:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80525d:	8b 00                	mov    (%rax),%eax
  80525f:	8d 50 ff             	lea    -0x1(%rax),%edx
  805262:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805266:	89 10                	mov    %edx,(%rax)
  805268:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80526c:	8b 00                	mov    (%rax),%eax
  80526e:	85 c0                	test   %eax,%eax
  805270:	75 1b                	jne    80528d <free+0x16e>
		sys_page_unmap(0, c);
  805272:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805276:	48 89 c6             	mov    %rax,%rsi
  805279:	bf 00 00 00 00       	mov    $0x0,%edi
  80527e:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  805285:	00 00 00 
  805288:	ff d0                	callq  *%rax
  80528a:	eb 01                	jmp    80528d <free+0x16e>
{
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
		return;
  80528c:	90                   	nop
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
		sys_page_unmap(0, c);
}
  80528d:	c9                   	leaveq 
  80528e:	c3                   	retq   

000000000080528f <pipe>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  80528f:	55                   	push   %rbp
  805290:	48 89 e5             	mov    %rsp,%rbp
  805293:	53                   	push   %rbx
  805294:	48 83 ec 38          	sub    $0x38,%rsp
  805298:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  80529c:	48 8d 45 d8          	lea    -0x28(%rbp),%rax
  8052a0:	48 89 c7             	mov    %rax,%rdi
  8052a3:	48 b8 1d 35 80 00 00 	movabs $0x80351d,%rax
  8052aa:	00 00 00 
  8052ad:	ff d0                	callq  *%rax
  8052af:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8052b2:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8052b6:	0f 88 bf 01 00 00    	js     80547b <pipe+0x1ec>
            || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8052bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8052c0:	ba 07 04 00 00       	mov    $0x407,%edx
  8052c5:	48 89 c6             	mov    %rax,%rsi
  8052c8:	bf 00 00 00 00       	mov    $0x0,%edi
  8052cd:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  8052d4:	00 00 00 
  8052d7:	ff d0                	callq  *%rax
  8052d9:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8052dc:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8052e0:	0f 88 95 01 00 00    	js     80547b <pipe+0x1ec>
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  8052e6:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8052ea:	48 89 c7             	mov    %rax,%rdi
  8052ed:	48 b8 1d 35 80 00 00 	movabs $0x80351d,%rax
  8052f4:	00 00 00 
  8052f7:	ff d0                	callq  *%rax
  8052f9:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8052fc:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  805300:	0f 88 5d 01 00 00    	js     805463 <pipe+0x1d4>
            || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  805306:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80530a:	ba 07 04 00 00       	mov    $0x407,%edx
  80530f:	48 89 c6             	mov    %rax,%rsi
  805312:	bf 00 00 00 00       	mov    $0x0,%edi
  805317:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  80531e:	00 00 00 
  805321:	ff d0                	callq  *%rax
  805323:	89 45 ec             	mov    %eax,-0x14(%rbp)
  805326:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80532a:	0f 88 33 01 00 00    	js     805463 <pipe+0x1d4>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  805330:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805334:	48 89 c7             	mov    %rax,%rdi
  805337:	48 b8 f2 34 80 00 00 	movabs $0x8034f2,%rax
  80533e:	00 00 00 
  805341:	ff d0                	callq  *%rax
  805343:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  805347:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80534b:	ba 07 04 00 00       	mov    $0x407,%edx
  805350:	48 89 c6             	mov    %rax,%rsi
  805353:	bf 00 00 00 00       	mov    $0x0,%edi
  805358:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  80535f:	00 00 00 
  805362:	ff d0                	callq  *%rax
  805364:	89 45 ec             	mov    %eax,-0x14(%rbp)
  805367:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80536b:	0f 88 d9 00 00 00    	js     80544a <pipe+0x1bb>
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  805371:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805375:	48 89 c7             	mov    %rax,%rdi
  805378:	48 b8 f2 34 80 00 00 	movabs $0x8034f2,%rax
  80537f:	00 00 00 
  805382:	ff d0                	callq  *%rax
  805384:	48 89 c2             	mov    %rax,%rdx
  805387:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80538b:	41 b8 07 04 00 00    	mov    $0x407,%r8d
  805391:	48 89 d1             	mov    %rdx,%rcx
  805394:	ba 00 00 00 00       	mov    $0x0,%edx
  805399:	48 89 c6             	mov    %rax,%rsi
  80539c:	bf 00 00 00 00       	mov    $0x0,%edi
  8053a1:	48 b8 4a 28 80 00 00 	movabs $0x80284a,%rax
  8053a8:	00 00 00 
  8053ab:	ff d0                	callq  *%rax
  8053ad:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8053b0:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8053b4:	78 79                	js     80542f <pipe+0x1a0>
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  8053b6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8053ba:	48 ba 00 81 82 00 00 	movabs $0x828100,%rdx
  8053c1:	00 00 00 
  8053c4:	8b 12                	mov    (%rdx),%edx
  8053c6:	89 10                	mov    %edx,(%rax)
	fd0->fd_omode = O_RDONLY;
  8053c8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8053cc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)

	fd1->fd_dev_id = devpipe.dev_id;
  8053d3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8053d7:	48 ba 00 81 82 00 00 	movabs $0x828100,%rdx
  8053de:	00 00 00 
  8053e1:	8b 12                	mov    (%rdx),%edx
  8053e3:	89 10                	mov    %edx,(%rax)
	fd1->fd_omode = O_WRONLY;
  8053e5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8053e9:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%rax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", thisenv->env_id, uvpt[PGNUM(va)]);

	pfd[0] = fd2num(fd0);
  8053f0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8053f4:	48 89 c7             	mov    %rax,%rdi
  8053f7:	48 b8 cf 34 80 00 00 	movabs $0x8034cf,%rax
  8053fe:	00 00 00 
  805401:	ff d0                	callq  *%rax
  805403:	89 c2                	mov    %eax,%edx
  805405:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  805409:	89 10                	mov    %edx,(%rax)
	pfd[1] = fd2num(fd1);
  80540b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80540f:	48 8d 58 04          	lea    0x4(%rax),%rbx
  805413:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805417:	48 89 c7             	mov    %rax,%rdi
  80541a:	48 b8 cf 34 80 00 00 	movabs $0x8034cf,%rax
  805421:	00 00 00 
  805424:	ff d0                	callq  *%rax
  805426:	89 03                	mov    %eax,(%rbx)
	return 0;
  805428:	b8 00 00 00 00       	mov    $0x0,%eax
  80542d:	eb 4f                	jmp    80547e <pipe+0x1ef>
	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err3;
  80542f:	90                   	nop
	pfd[0] = fd2num(fd0);
	pfd[1] = fd2num(fd1);
	return 0;

err3:
	sys_page_unmap(0, va);
  805430:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805434:	48 89 c6             	mov    %rax,%rsi
  805437:	bf 00 00 00 00       	mov    $0x0,%edi
  80543c:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  805443:	00 00 00 
  805446:	ff d0                	callq  *%rax
  805448:	eb 01                	jmp    80544b <pipe+0x1bc>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err2;
  80544a:	90                   	nop
	return 0;

err3:
	sys_page_unmap(0, va);
err2:
	sys_page_unmap(0, fd1);
  80544b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80544f:	48 89 c6             	mov    %rax,%rsi
  805452:	bf 00 00 00 00       	mov    $0x0,%edi
  805457:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  80545e:	00 00 00 
  805461:	ff d0                	callq  *%rax
err1:
	sys_page_unmap(0, fd0);
  805463:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805467:	48 89 c6             	mov    %rax,%rsi
  80546a:	bf 00 00 00 00       	mov    $0x0,%edi
  80546f:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  805476:	00 00 00 
  805479:	ff d0                	callq  *%rax
err:
	return r;
  80547b:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  80547e:	48 83 c4 38          	add    $0x38,%rsp
  805482:	5b                   	pop    %rbx
  805483:	5d                   	pop    %rbp
  805484:	c3                   	retq   

0000000000805485 <_pipeisclosed>:

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  805485:	55                   	push   %rbp
  805486:	48 89 e5             	mov    %rsp,%rbp
  805489:	53                   	push   %rbx
  80548a:	48 83 ec 28          	sub    $0x28,%rsp
  80548e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  805492:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)

	int n, nn, ret;

	while (1) {
		n = thisenv->env_runs;
  805496:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  80549d:	00 00 00 
  8054a0:	48 8b 00             	mov    (%rax),%rax
  8054a3:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  8054a9:	89 45 ec             	mov    %eax,-0x14(%rbp)
		ret = pageref(fd) == pageref(p);
  8054ac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8054b0:	48 89 c7             	mov    %rax,%rdi
  8054b3:	48 b8 25 5c 80 00 00 	movabs $0x805c25,%rax
  8054ba:	00 00 00 
  8054bd:	ff d0                	callq  *%rax
  8054bf:	89 c3                	mov    %eax,%ebx
  8054c1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8054c5:	48 89 c7             	mov    %rax,%rdi
  8054c8:	48 b8 25 5c 80 00 00 	movabs $0x805c25,%rax
  8054cf:	00 00 00 
  8054d2:	ff d0                	callq  *%rax
  8054d4:	39 c3                	cmp    %eax,%ebx
  8054d6:	0f 94 c0             	sete   %al
  8054d9:	0f b6 c0             	movzbl %al,%eax
  8054dc:	89 45 e8             	mov    %eax,-0x18(%rbp)
		nn = thisenv->env_runs;
  8054df:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8054e6:	00 00 00 
  8054e9:	48 8b 00             	mov    (%rax),%rax
  8054ec:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  8054f2:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if (n == nn)
  8054f5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8054f8:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8054fb:	75 05                	jne    805502 <_pipeisclosed+0x7d>
			return ret;
  8054fd:	8b 45 e8             	mov    -0x18(%rbp),%eax
  805500:	eb 4a                	jmp    80554c <_pipeisclosed+0xc7>
		if (n != nn && ret == 1)
  805502:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805505:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  805508:	74 8c                	je     805496 <_pipeisclosed+0x11>
  80550a:	83 7d e8 01          	cmpl   $0x1,-0x18(%rbp)
  80550e:	75 86                	jne    805496 <_pipeisclosed+0x11>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  805510:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  805517:	00 00 00 
  80551a:	48 8b 00             	mov    (%rax),%rax
  80551d:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  805523:	8b 4d e8             	mov    -0x18(%rbp),%ecx
  805526:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805529:	89 c6                	mov    %eax,%esi
  80552b:	48 bf dd 17 82 00 00 	movabs $0x8217dd,%rdi
  805532:	00 00 00 
  805535:	b8 00 00 00 00       	mov    $0x0,%eax
  80553a:	49 b8 32 13 80 00 00 	movabs $0x801332,%r8
  805541:	00 00 00 
  805544:	41 ff d0             	callq  *%r8
	}
  805547:	e9 4a ff ff ff       	jmpq   805496 <_pipeisclosed+0x11>

}
  80554c:	48 83 c4 28          	add    $0x28,%rsp
  805550:	5b                   	pop    %rbx
  805551:	5d                   	pop    %rbp
  805552:	c3                   	retq   

0000000000805553 <pipeisclosed>:

int
pipeisclosed(int fdnum)
{
  805553:	55                   	push   %rbp
  805554:	48 89 e5             	mov    %rsp,%rbp
  805557:	48 83 ec 30          	sub    $0x30,%rsp
  80555b:	89 7d dc             	mov    %edi,-0x24(%rbp)
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80555e:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  805562:	8b 45 dc             	mov    -0x24(%rbp),%eax
  805565:	48 89 d6             	mov    %rdx,%rsi
  805568:	89 c7                	mov    %eax,%edi
  80556a:	48 b8 b5 35 80 00 00 	movabs $0x8035b5,%rax
  805571:	00 00 00 
  805574:	ff d0                	callq  *%rax
  805576:	89 45 fc             	mov    %eax,-0x4(%rbp)
  805579:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80557d:	79 05                	jns    805584 <pipeisclosed+0x31>
		return r;
  80557f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805582:	eb 31                	jmp    8055b5 <pipeisclosed+0x62>
	p = (struct Pipe*) fd2data(fd);
  805584:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805588:	48 89 c7             	mov    %rax,%rdi
  80558b:	48 b8 f2 34 80 00 00 	movabs $0x8034f2,%rax
  805592:	00 00 00 
  805595:	ff d0                	callq  *%rax
  805597:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	return _pipeisclosed(fd, p);
  80559b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80559f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8055a3:	48 89 d6             	mov    %rdx,%rsi
  8055a6:	48 89 c7             	mov    %rax,%rdi
  8055a9:	48 b8 85 54 80 00 00 	movabs $0x805485,%rax
  8055b0:	00 00 00 
  8055b3:	ff d0                	callq  *%rax
}
  8055b5:	c9                   	leaveq 
  8055b6:	c3                   	retq   

00000000008055b7 <devpipe_read>:

static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  8055b7:	55                   	push   %rbp
  8055b8:	48 89 e5             	mov    %rsp,%rbp
  8055bb:	48 83 ec 40          	sub    $0x40,%rsp
  8055bf:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8055c3:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8055c7:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)

	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*)fd2data(fd);
  8055cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8055cf:	48 89 c7             	mov    %rax,%rdi
  8055d2:	48 b8 f2 34 80 00 00 	movabs $0x8034f2,%rax
  8055d9:	00 00 00 
  8055dc:	ff d0                	callq  *%rax
  8055de:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
  8055e2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8055e6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for (i = 0; i < n; i++) {
  8055ea:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8055f1:	00 
  8055f2:	e9 90 00 00 00       	jmpq   805687 <devpipe_read+0xd0>
		while (p->p_rpos == p->p_wpos) {
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
  8055f7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8055fc:	74 09                	je     805607 <devpipe_read+0x50>
				return i;
  8055fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805602:	e9 8e 00 00 00       	jmpq   805695 <devpipe_read+0xde>
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
  805607:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80560b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80560f:	48 89 d6             	mov    %rdx,%rsi
  805612:	48 89 c7             	mov    %rax,%rdi
  805615:	48 b8 85 54 80 00 00 	movabs $0x805485,%rax
  80561c:	00 00 00 
  80561f:	ff d0                	callq  *%rax
  805621:	85 c0                	test   %eax,%eax
  805623:	74 07                	je     80562c <devpipe_read+0x75>
				return 0;
  805625:	b8 00 00 00 00       	mov    $0x0,%eax
  80562a:	eb 69                	jmp    805695 <devpipe_read+0xde>
			// yield and see what happens
			if (debug)
				cprintf("devpipe_read yield\n");
			sys_yield();
  80562c:	48 b8 bb 27 80 00 00 	movabs $0x8027bb,%rax
  805633:	00 00 00 
  805636:	ff d0                	callq  *%rax
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_rpos == p->p_wpos) {
  805638:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80563c:	8b 10                	mov    (%rax),%edx
  80563e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805642:	8b 40 04             	mov    0x4(%rax),%eax
  805645:	39 c2                	cmp    %eax,%edx
  805647:	74 ae                	je     8055f7 <devpipe_read+0x40>
				cprintf("devpipe_read yield\n");
			sys_yield();
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  805649:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80564d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805651:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  805655:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805659:	8b 00                	mov    (%rax),%eax
  80565b:	99                   	cltd   
  80565c:	c1 ea 1b             	shr    $0x1b,%edx
  80565f:	01 d0                	add    %edx,%eax
  805661:	83 e0 1f             	and    $0x1f,%eax
  805664:	29 d0                	sub    %edx,%eax
  805666:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80566a:	48 98                	cltq   
  80566c:	0f b6 44 02 08       	movzbl 0x8(%rdx,%rax,1),%eax
  805671:	88 01                	mov    %al,(%rcx)
		p->p_rpos++;
  805673:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805677:	8b 00                	mov    (%rax),%eax
  805679:	8d 50 01             	lea    0x1(%rax),%edx
  80567c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805680:	89 10                	mov    %edx,(%rax)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  805682:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  805687:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80568b:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80568f:	72 a7                	jb     805638 <devpipe_read+0x81>
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
  805691:	48 8b 45 f8          	mov    -0x8(%rbp),%rax

}
  805695:	c9                   	leaveq 
  805696:	c3                   	retq   

0000000000805697 <devpipe_write>:

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  805697:	55                   	push   %rbp
  805698:	48 89 e5             	mov    %rsp,%rbp
  80569b:	48 83 ec 40          	sub    $0x40,%rsp
  80569f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8056a3:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8056a7:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)

	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*) fd2data(fd);
  8056ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8056af:	48 89 c7             	mov    %rax,%rdi
  8056b2:	48 b8 f2 34 80 00 00 	movabs $0x8034f2,%rax
  8056b9:	00 00 00 
  8056bc:	ff d0                	callq  *%rax
  8056be:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
  8056c2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8056c6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for (i = 0; i < n; i++) {
  8056ca:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8056d1:	00 
  8056d2:	e9 8f 00 00 00       	jmpq   805766 <devpipe_write+0xcf>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
  8056d7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8056db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8056df:	48 89 d6             	mov    %rdx,%rsi
  8056e2:	48 89 c7             	mov    %rax,%rdi
  8056e5:	48 b8 85 54 80 00 00 	movabs $0x805485,%rax
  8056ec:	00 00 00 
  8056ef:	ff d0                	callq  *%rax
  8056f1:	85 c0                	test   %eax,%eax
  8056f3:	74 07                	je     8056fc <devpipe_write+0x65>
				return 0;
  8056f5:	b8 00 00 00 00       	mov    $0x0,%eax
  8056fa:	eb 78                	jmp    805774 <devpipe_write+0xdd>
			// yield and see what happens
			if (debug)
				cprintf("devpipe_write yield\n");
			sys_yield();
  8056fc:	48 b8 bb 27 80 00 00 	movabs $0x8027bb,%rax
  805703:	00 00 00 
  805706:	ff d0                	callq  *%rax
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  805708:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80570c:	8b 40 04             	mov    0x4(%rax),%eax
  80570f:	48 63 d0             	movslq %eax,%rdx
  805712:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805716:	8b 00                	mov    (%rax),%eax
  805718:	48 98                	cltq   
  80571a:	48 83 c0 20          	add    $0x20,%rax
  80571e:	48 39 c2             	cmp    %rax,%rdx
  805721:	73 b4                	jae    8056d7 <devpipe_write+0x40>
				cprintf("devpipe_write yield\n");
			sys_yield();
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  805723:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805727:	8b 40 04             	mov    0x4(%rax),%eax
  80572a:	99                   	cltd   
  80572b:	c1 ea 1b             	shr    $0x1b,%edx
  80572e:	01 d0                	add    %edx,%eax
  805730:	83 e0 1f             	and    $0x1f,%eax
  805733:	29 d0                	sub    %edx,%eax
  805735:	89 c6                	mov    %eax,%esi
  805737:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80573b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80573f:	48 01 d0             	add    %rdx,%rax
  805742:	0f b6 08             	movzbl (%rax),%ecx
  805745:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  805749:	48 63 c6             	movslq %esi,%rax
  80574c:	88 4c 02 08          	mov    %cl,0x8(%rdx,%rax,1)
		p->p_wpos++;
  805750:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805754:	8b 40 04             	mov    0x4(%rax),%eax
  805757:	8d 50 01             	lea    0x1(%rax),%edx
  80575a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80575e:	89 50 04             	mov    %edx,0x4(%rax)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  805761:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  805766:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80576a:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80576e:	72 98                	jb     805708 <devpipe_write+0x71>
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
  805770:	48 8b 45 f8          	mov    -0x8(%rbp),%rax

}
  805774:	c9                   	leaveq 
  805775:	c3                   	retq   

0000000000805776 <devpipe_stat>:

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  805776:	55                   	push   %rbp
  805777:	48 89 e5             	mov    %rsp,%rbp
  80577a:	48 83 ec 20          	sub    $0x20,%rsp
  80577e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  805782:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  805786:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80578a:	48 89 c7             	mov    %rax,%rdi
  80578d:	48 b8 f2 34 80 00 00 	movabs $0x8034f2,%rax
  805794:	00 00 00 
  805797:	ff d0                	callq  *%rax
  805799:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	strcpy(stat->st_name, "<pipe>");
  80579d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8057a1:	48 be f0 17 82 00 00 	movabs $0x8217f0,%rsi
  8057a8:	00 00 00 
  8057ab:	48 89 c7             	mov    %rax,%rdi
  8057ae:	48 b8 c2 1e 80 00 00 	movabs $0x801ec2,%rax
  8057b5:	00 00 00 
  8057b8:	ff d0                	callq  *%rax
	stat->st_size = p->p_wpos - p->p_rpos;
  8057ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8057be:	8b 50 04             	mov    0x4(%rax),%edx
  8057c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8057c5:	8b 00                	mov    (%rax),%eax
  8057c7:	29 c2                	sub    %eax,%edx
  8057c9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8057cd:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)
	stat->st_isdir = 0;
  8057d3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8057d7:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%rax)
  8057de:	00 00 00 
	stat->st_dev = &devpipe;
  8057e1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8057e5:	48 b9 00 81 82 00 00 	movabs $0x828100,%rcx
  8057ec:	00 00 00 
  8057ef:	48 89 88 88 00 00 00 	mov    %rcx,0x88(%rax)
	return 0;
  8057f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8057fb:	c9                   	leaveq 
  8057fc:	c3                   	retq   

00000000008057fd <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  8057fd:	55                   	push   %rbp
  8057fe:	48 89 e5             	mov    %rsp,%rbp
  805801:	48 83 ec 10          	sub    $0x10,%rsp
  805805:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

	(void) sys_page_unmap(0, fd);
  805809:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80580d:	48 89 c6             	mov    %rax,%rsi
  805810:	bf 00 00 00 00       	mov    $0x0,%edi
  805815:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  80581c:	00 00 00 
  80581f:	ff d0                	callq  *%rax

	return sys_page_unmap(0, fd2data(fd));
  805821:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805825:	48 89 c7             	mov    %rax,%rdi
  805828:	48 b8 f2 34 80 00 00 	movabs $0x8034f2,%rax
  80582f:	00 00 00 
  805832:	ff d0                	callq  *%rax
  805834:	48 89 c6             	mov    %rax,%rsi
  805837:	bf 00 00 00 00       	mov    $0x0,%edi
  80583c:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  805843:	00 00 00 
  805846:	ff d0                	callq  *%rax
}
  805848:	c9                   	leaveq 
  805849:	c3                   	retq   

000000000080584a <cputchar>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  80584a:	55                   	push   %rbp
  80584b:	48 89 e5             	mov    %rsp,%rbp
  80584e:	48 83 ec 20          	sub    $0x20,%rsp
  805852:	89 7d ec             	mov    %edi,-0x14(%rbp)
	char c = ch;
  805855:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805858:	88 45 ff             	mov    %al,-0x1(%rbp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  80585b:	48 8d 45 ff          	lea    -0x1(%rbp),%rax
  80585f:	be 01 00 00 00       	mov    $0x1,%esi
  805864:	48 89 c7             	mov    %rax,%rdi
  805867:	48 b8 b0 26 80 00 00 	movabs $0x8026b0,%rax
  80586e:	00 00 00 
  805871:	ff d0                	callq  *%rax
}
  805873:	90                   	nop
  805874:	c9                   	leaveq 
  805875:	c3                   	retq   

0000000000805876 <getchar>:

int
getchar(void)
{
  805876:	55                   	push   %rbp
  805877:	48 89 e5             	mov    %rsp,%rbp
  80587a:	48 83 ec 10          	sub    $0x10,%rsp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  80587e:	48 8d 45 fb          	lea    -0x5(%rbp),%rax
  805882:	ba 01 00 00 00       	mov    $0x1,%edx
  805887:	48 89 c6             	mov    %rax,%rsi
  80588a:	bf 00 00 00 00       	mov    $0x0,%edi
  80588f:	48 b8 ea 39 80 00 00 	movabs $0x8039ea,%rax
  805896:	00 00 00 
  805899:	ff d0                	callq  *%rax
  80589b:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (r < 0)
  80589e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8058a2:	79 05                	jns    8058a9 <getchar+0x33>
		return r;
  8058a4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8058a7:	eb 14                	jmp    8058bd <getchar+0x47>
	if (r < 1)
  8058a9:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8058ad:	7f 07                	jg     8058b6 <getchar+0x40>
		return -E_EOF;
  8058af:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8058b4:	eb 07                	jmp    8058bd <getchar+0x47>
	return c;
  8058b6:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8058ba:	0f b6 c0             	movzbl %al,%eax

}
  8058bd:	c9                   	leaveq 
  8058be:	c3                   	retq   

00000000008058bf <iscons>:
	.dev_stat =	devcons_stat
};

int
iscons(int fdnum)
{
  8058bf:	55                   	push   %rbp
  8058c0:	48 89 e5             	mov    %rsp,%rbp
  8058c3:	48 83 ec 20          	sub    $0x20,%rsp
  8058c7:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8058ca:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8058ce:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8058d1:	48 89 d6             	mov    %rdx,%rsi
  8058d4:	89 c7                	mov    %eax,%edi
  8058d6:	48 b8 b5 35 80 00 00 	movabs $0x8035b5,%rax
  8058dd:	00 00 00 
  8058e0:	ff d0                	callq  *%rax
  8058e2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8058e5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8058e9:	79 05                	jns    8058f0 <iscons+0x31>
		return r;
  8058eb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8058ee:	eb 1a                	jmp    80590a <iscons+0x4b>
	return fd->fd_dev_id == devcons.dev_id;
  8058f0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8058f4:	8b 10                	mov    (%rax),%edx
  8058f6:	48 b8 40 81 82 00 00 	movabs $0x828140,%rax
  8058fd:	00 00 00 
  805900:	8b 00                	mov    (%rax),%eax
  805902:	39 c2                	cmp    %eax,%edx
  805904:	0f 94 c0             	sete   %al
  805907:	0f b6 c0             	movzbl %al,%eax
}
  80590a:	c9                   	leaveq 
  80590b:	c3                   	retq   

000000000080590c <opencons>:

int
opencons(void)
{
  80590c:	55                   	push   %rbp
  80590d:	48 89 e5             	mov    %rsp,%rbp
  805910:	48 83 ec 10          	sub    $0x10,%rsp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  805914:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  805918:	48 89 c7             	mov    %rax,%rdi
  80591b:	48 b8 1d 35 80 00 00 	movabs $0x80351d,%rax
  805922:	00 00 00 
  805925:	ff d0                	callq  *%rax
  805927:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80592a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80592e:	79 05                	jns    805935 <opencons+0x29>
		return r;
  805930:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805933:	eb 5b                	jmp    805990 <opencons+0x84>
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  805935:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805939:	ba 07 04 00 00       	mov    $0x407,%edx
  80593e:	48 89 c6             	mov    %rax,%rsi
  805941:	bf 00 00 00 00       	mov    $0x0,%edi
  805946:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  80594d:	00 00 00 
  805950:	ff d0                	callq  *%rax
  805952:	89 45 fc             	mov    %eax,-0x4(%rbp)
  805955:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805959:	79 05                	jns    805960 <opencons+0x54>
		return r;
  80595b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80595e:	eb 30                	jmp    805990 <opencons+0x84>
	fd->fd_dev_id = devcons.dev_id;
  805960:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805964:	48 ba 40 81 82 00 00 	movabs $0x828140,%rdx
  80596b:	00 00 00 
  80596e:	8b 12                	mov    (%rdx),%edx
  805970:	89 10                	mov    %edx,(%rax)
	fd->fd_omode = O_RDWR;
  805972:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805976:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%rax)
	return fd2num(fd);
  80597d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805981:	48 89 c7             	mov    %rax,%rdi
  805984:	48 b8 cf 34 80 00 00 	movabs $0x8034cf,%rax
  80598b:	00 00 00 
  80598e:	ff d0                	callq  *%rax
}
  805990:	c9                   	leaveq 
  805991:	c3                   	retq   

0000000000805992 <devcons_read>:

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  805992:	55                   	push   %rbp
  805993:	48 89 e5             	mov    %rsp,%rbp
  805996:	48 83 ec 30          	sub    $0x30,%rsp
  80599a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80599e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8059a2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int c;

	if (n == 0)
  8059a6:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8059ab:	75 13                	jne    8059c0 <devcons_read+0x2e>
		return 0;
  8059ad:	b8 00 00 00 00       	mov    $0x0,%eax
  8059b2:	eb 49                	jmp    8059fd <devcons_read+0x6b>

	while ((c = sys_cgetc()) == 0)
		sys_yield();
  8059b4:	48 b8 bb 27 80 00 00 	movabs $0x8027bb,%rax
  8059bb:	00 00 00 
  8059be:	ff d0                	callq  *%rax
	int c;

	if (n == 0)
		return 0;

	while ((c = sys_cgetc()) == 0)
  8059c0:	48 b8 fd 26 80 00 00 	movabs $0x8026fd,%rax
  8059c7:	00 00 00 
  8059ca:	ff d0                	callq  *%rax
  8059cc:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8059cf:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8059d3:	74 df                	je     8059b4 <devcons_read+0x22>
		sys_yield();
	if (c < 0)
  8059d5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8059d9:	79 05                	jns    8059e0 <devcons_read+0x4e>
		return c;
  8059db:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8059de:	eb 1d                	jmp    8059fd <devcons_read+0x6b>
	if (c == 0x04)	// ctl-d is eof
  8059e0:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8059e4:	75 07                	jne    8059ed <devcons_read+0x5b>
		return 0;
  8059e6:	b8 00 00 00 00       	mov    $0x0,%eax
  8059eb:	eb 10                	jmp    8059fd <devcons_read+0x6b>
	*(char*)vbuf = c;
  8059ed:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8059f0:	89 c2                	mov    %eax,%edx
  8059f2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8059f6:	88 10                	mov    %dl,(%rax)
	return 1;
  8059f8:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8059fd:	c9                   	leaveq 
  8059fe:	c3                   	retq   

00000000008059ff <devcons_write>:

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  8059ff:	55                   	push   %rbp
  805a00:	48 89 e5             	mov    %rsp,%rbp
  805a03:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  805a0a:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  805a11:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  805a18:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  805a1f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  805a26:	eb 76                	jmp    805a9e <devcons_write+0x9f>
		m = n - tot;
  805a28:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  805a2f:	89 c2                	mov    %eax,%edx
  805a31:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805a34:	29 c2                	sub    %eax,%edx
  805a36:	89 d0                	mov    %edx,%eax
  805a38:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (m > sizeof(buf) - 1)
  805a3b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  805a3e:	83 f8 7f             	cmp    $0x7f,%eax
  805a41:	76 07                	jbe    805a4a <devcons_write+0x4b>
			m = sizeof(buf) - 1;
  805a43:	c7 45 f8 7f 00 00 00 	movl   $0x7f,-0x8(%rbp)
		memmove(buf, (char*)vbuf + tot, m);
  805a4a:	8b 45 f8             	mov    -0x8(%rbp),%eax
  805a4d:	48 63 d0             	movslq %eax,%rdx
  805a50:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805a53:	48 63 c8             	movslq %eax,%rcx
  805a56:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  805a5d:	48 01 c1             	add    %rax,%rcx
  805a60:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  805a67:	48 89 ce             	mov    %rcx,%rsi
  805a6a:	48 89 c7             	mov    %rax,%rdi
  805a6d:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  805a74:	00 00 00 
  805a77:	ff d0                	callq  *%rax
		sys_cputs(buf, m);
  805a79:	8b 45 f8             	mov    -0x8(%rbp),%eax
  805a7c:	48 63 d0             	movslq %eax,%rdx
  805a7f:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  805a86:	48 89 d6             	mov    %rdx,%rsi
  805a89:	48 89 c7             	mov    %rax,%rdi
  805a8c:	48 b8 b0 26 80 00 00 	movabs $0x8026b0,%rax
  805a93:	00 00 00 
  805a96:	ff d0                	callq  *%rax
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  805a98:	8b 45 f8             	mov    -0x8(%rbp),%eax
  805a9b:	01 45 fc             	add    %eax,-0x4(%rbp)
  805a9e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805aa1:	48 98                	cltq   
  805aa3:	48 3b 85 58 ff ff ff 	cmp    -0xa8(%rbp),%rax
  805aaa:	0f 82 78 ff ff ff    	jb     805a28 <devcons_write+0x29>
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
		sys_cputs(buf, m);
	}
	return tot;
  805ab0:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  805ab3:	c9                   	leaveq 
  805ab4:	c3                   	retq   

0000000000805ab5 <devcons_close>:

static int
devcons_close(struct Fd *fd)
{
  805ab5:	55                   	push   %rbp
  805ab6:	48 89 e5             	mov    %rsp,%rbp
  805ab9:	48 83 ec 08          	sub    $0x8,%rsp
  805abd:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	USED(fd);

	return 0;
  805ac1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805ac6:	c9                   	leaveq 
  805ac7:	c3                   	retq   

0000000000805ac8 <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  805ac8:	55                   	push   %rbp
  805ac9:	48 89 e5             	mov    %rsp,%rbp
  805acc:	48 83 ec 10          	sub    $0x10,%rsp
  805ad0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  805ad4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	strcpy(stat->st_name, "<cons>");
  805ad8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805adc:	48 be fc 17 82 00 00 	movabs $0x8217fc,%rsi
  805ae3:	00 00 00 
  805ae6:	48 89 c7             	mov    %rax,%rdi
  805ae9:	48 b8 c2 1e 80 00 00 	movabs $0x801ec2,%rax
  805af0:	00 00 00 
  805af3:	ff d0                	callq  *%rax
	return 0;
  805af5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805afa:	c9                   	leaveq 
  805afb:	c3                   	retq   

0000000000805afc <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  805afc:	55                   	push   %rbp
  805afd:	48 89 e5             	mov    %rsp,%rbp
  805b00:	48 83 ec 20          	sub    $0x20,%rsp
  805b04:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;

	if (_pgfault_handler == 0) {
  805b08:	48 b8 00 b0 b5 00 00 	movabs $0xb5b000,%rax
  805b0f:	00 00 00 
  805b12:	48 8b 00             	mov    (%rax),%rax
  805b15:	48 85 c0             	test   %rax,%rax
  805b18:	75 6f                	jne    805b89 <set_pgfault_handler+0x8d>

		// map exception stack
		if ((r = sys_page_alloc(0, (void*) (UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
  805b1a:	ba 07 00 00 00       	mov    $0x7,%edx
  805b1f:	be 00 f0 7f ef       	mov    $0xef7ff000,%esi
  805b24:	bf 00 00 00 00       	mov    $0x0,%edi
  805b29:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  805b30:	00 00 00 
  805b33:	ff d0                	callq  *%rax
  805b35:	89 45 fc             	mov    %eax,-0x4(%rbp)
  805b38:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805b3c:	79 30                	jns    805b6e <set_pgfault_handler+0x72>
			panic("allocating exception stack: %e", r);
  805b3e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805b41:	89 c1                	mov    %eax,%ecx
  805b43:	48 ba 08 18 82 00 00 	movabs $0x821808,%rdx
  805b4a:	00 00 00 
  805b4d:	be 22 00 00 00       	mov    $0x22,%esi
  805b52:	48 bf 27 18 82 00 00 	movabs $0x821827,%rdi
  805b59:	00 00 00 
  805b5c:	b8 00 00 00 00       	mov    $0x0,%eax
  805b61:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  805b68:	00 00 00 
  805b6b:	41 ff d0             	callq  *%r8

		// register assembly pgfault entrypoint with JOS kernel
		sys_env_set_pgfault_upcall(0, (void*) _pgfault_upcall);
  805b6e:	48 be 9d 5b 80 00 00 	movabs $0x805b9d,%rsi
  805b75:	00 00 00 
  805b78:	bf 00 00 00 00       	mov    $0x0,%edi
  805b7d:	48 b8 8f 29 80 00 00 	movabs $0x80298f,%rax
  805b84:	00 00 00 
  805b87:	ff d0                	callq  *%rax

	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  805b89:	48 b8 00 b0 b5 00 00 	movabs $0xb5b000,%rax
  805b90:	00 00 00 
  805b93:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  805b97:	48 89 10             	mov    %rdx,(%rax)
}
  805b9a:	90                   	nop
  805b9b:	c9                   	leaveq 
  805b9c:	c3                   	retq   

0000000000805b9d <_pgfault_upcall>:
.globl _pgfault_upcall
_pgfault_upcall:
// Call the C page fault handler.
// function argument: pointer to UTF

movq  %rsp,%rdi                // passing the function argument in rdi
  805b9d:	48 89 e7             	mov    %rsp,%rdi
movabs _pgfault_handler, %rax
  805ba0:	48 a1 00 b0 b5 00 00 	movabs 0xb5b000,%rax
  805ba7:	00 00 00 
call *%rax
  805baa:	ff d0                	callq  *%rax
// registers are available for intermediate calculations.  You
// may find that you have to rearrange your code in non-obvious
// ways as registers become unavailable as scratch space.
//
// LAB 4: Your code here.
subq $8, 152(%rsp)
  805bac:	48 83 ac 24 98 00 00 	subq   $0x8,0x98(%rsp)
  805bb3:	00 08 
    movq 152(%rsp), %rax
  805bb5:	48 8b 84 24 98 00 00 	mov    0x98(%rsp),%rax
  805bbc:	00 
    movq 136(%rsp), %rbx
  805bbd:	48 8b 9c 24 88 00 00 	mov    0x88(%rsp),%rbx
  805bc4:	00 
movq %rbx, (%rax)
  805bc5:	48 89 18             	mov    %rbx,(%rax)

    // Restore the trap-time registers.  After you do this, you
    // can no longer modify any general-purpose registers.
    // LAB 4: Your code here.
    addq $16, %rsp
  805bc8:	48 83 c4 10          	add    $0x10,%rsp
    POPA_
  805bcc:	4c 8b 3c 24          	mov    (%rsp),%r15
  805bd0:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  805bd5:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  805bda:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  805bdf:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  805be4:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  805be9:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  805bee:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  805bf3:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  805bf8:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  805bfd:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  805c02:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  805c07:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  805c0c:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  805c11:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  805c16:	48 83 c4 78          	add    $0x78,%rsp

    // Restore eflags from the stack.  After you do this, you can
    // no longer use arithmetic operations or anything else that
    // modifies eflags.
    // LAB 4: Your code here.
pushq 8(%rsp)
  805c1a:	ff 74 24 08          	pushq  0x8(%rsp)
    popfq
  805c1e:	9d                   	popfq  

    // Switch back to the adjusted trap-time stack.
    // LAB 4: Your code here.
    movq 16(%rsp), %rsp
  805c1f:	48 8b 64 24 10       	mov    0x10(%rsp),%rsp

    // Return to re-execute the instruction that faulted.
    // LAB 4: Your code here.
    retq
  805c24:	c3                   	retq   

0000000000805c25 <pageref>:

#include <inc/lib.h>

int
pageref(void *v)
{
  805c25:	55                   	push   %rbp
  805c26:	48 89 e5             	mov    %rsp,%rbp
  805c29:	48 83 ec 18          	sub    $0x18,%rsp
  805c2d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	pte_t pte;

	if (!(uvpd[VPD(v)] & PTE_P))
  805c31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805c35:	48 c1 e8 15          	shr    $0x15,%rax
  805c39:	48 89 c2             	mov    %rax,%rdx
  805c3c:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  805c43:	01 00 00 
  805c46:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  805c4a:	83 e0 01             	and    $0x1,%eax
  805c4d:	48 85 c0             	test   %rax,%rax
  805c50:	75 07                	jne    805c59 <pageref+0x34>
		return 0;
  805c52:	b8 00 00 00 00       	mov    $0x0,%eax
  805c57:	eb 56                	jmp    805caf <pageref+0x8a>
	pte = uvpt[PGNUM(v)];
  805c59:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805c5d:	48 c1 e8 0c          	shr    $0xc,%rax
  805c61:	48 89 c2             	mov    %rax,%rdx
  805c64:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  805c6b:	01 00 00 
  805c6e:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  805c72:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!(pte & PTE_P))
  805c76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805c7a:	83 e0 01             	and    $0x1,%eax
  805c7d:	48 85 c0             	test   %rax,%rax
  805c80:	75 07                	jne    805c89 <pageref+0x64>
		return 0;
  805c82:	b8 00 00 00 00       	mov    $0x0,%eax
  805c87:	eb 26                	jmp    805caf <pageref+0x8a>
	return pages[PPN(pte)].pp_ref;
  805c89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805c8d:	48 c1 e8 0c          	shr    $0xc,%rax
  805c91:	48 89 c2             	mov    %rax,%rdx
  805c94:	48 b8 00 00 a0 00 80 	movabs $0x8000a00000,%rax
  805c9b:	00 00 00 
  805c9e:	48 c1 e2 04          	shl    $0x4,%rdx
  805ca2:	48 01 d0             	add    %rdx,%rax
  805ca5:	48 83 c0 08          	add    $0x8,%rax
  805ca9:	0f b7 00             	movzwl (%rax),%eax
  805cac:	0f b7 c0             	movzwl %ax,%eax
}
  805caf:	c9                   	leaveq 
  805cb0:	c3                   	retq   

0000000000805cb1 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  805cb1:	55                   	push   %rbp
  805cb2:	48 89 e5             	mov    %rsp,%rbp
  socksem   = sys_sem_new(1);
  805cb5:	bf 01 00 00 00       	mov    $0x1,%edi
  805cba:	48 b8 e1 7e 81 00 00 	movabs $0x817ee1,%rax
  805cc1:	00 00 00 
  805cc4:	ff d0                	callq  *%rax
  805cc6:	89 c2                	mov    %eax,%edx
  805cc8:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805ccf:	00 00 00 
  805cd2:	89 10                	mov    %edx,(%rax)
  selectsem = sys_sem_new(1);
  805cd4:	bf 01 00 00 00       	mov    $0x1,%edi
  805cd9:	48 b8 e1 7e 81 00 00 	movabs $0x817ee1,%rax
  805ce0:	00 00 00 
  805ce3:	ff d0                	callq  *%rax
  805ce5:	89 c2                	mov    %eax,%edx
  805ce7:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  805cee:	00 00 00 
  805cf1:	89 10                	mov    %edx,(%rax)
}
  805cf3:	90                   	nop
  805cf4:	5d                   	pop    %rbp
  805cf5:	c3                   	retq   

0000000000805cf6 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  805cf6:	55                   	push   %rbp
  805cf7:	48 89 e5             	mov    %rsp,%rbp
  805cfa:	48 83 ec 18          	sub    $0x18,%rsp
  805cfe:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  805d01:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  805d05:	78 06                	js     805d0d <get_socket+0x17>
  805d07:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  805d0b:	7e 17                	jle    805d24 <get_socket+0x2e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  805d0d:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805d14:	00 00 00 
  805d17:	c7 00 09 00 00 00    	movl   $0x9,(%rax)
    return NULL;
  805d1d:	b8 00 00 00 00       	mov    $0x0,%eax
  805d22:	eb 44                	jmp    805d68 <get_socket+0x72>
  }

  sock = &sockets[s];
  805d24:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805d27:	48 98                	cltq   
  805d29:	48 c1 e0 05          	shl    $0x5,%rax
  805d2d:	48 89 c2             	mov    %rax,%rdx
  805d30:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805d37:	00 00 00 
  805d3a:	48 01 d0             	add    %rdx,%rax
  805d3d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if (!sock->conn) {
  805d41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805d45:	48 8b 00             	mov    (%rax),%rax
  805d48:	48 85 c0             	test   %rax,%rax
  805d4b:	75 17                	jne    805d64 <get_socket+0x6e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  805d4d:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805d54:	00 00 00 
  805d57:	c7 00 09 00 00 00    	movl   $0x9,(%rax)
    return NULL;
  805d5d:	b8 00 00 00 00       	mov    $0x0,%eax
  805d62:	eb 04                	jmp    805d68 <get_socket+0x72>
  }

  return sock;
  805d64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  805d68:	c9                   	leaveq 
  805d69:	c3                   	retq   

0000000000805d6a <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  805d6a:	55                   	push   %rbp
  805d6b:	48 89 e5             	mov    %rsp,%rbp
  805d6e:	48 83 ec 20          	sub    $0x20,%rsp
  805d72:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  805d76:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805d7d:	00 00 00 
  805d80:	8b 00                	mov    (%rax),%eax
  805d82:	89 c7                	mov    %eax,%edi
  805d84:	48 b8 fc e6 80 00 00 	movabs $0x80e6fc,%rax
  805d8b:	00 00 00 
  805d8e:	ff d0                	callq  *%rax

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  805d90:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  805d97:	e9 27 01 00 00       	jmpq   805ec3 <alloc_socket+0x159>
    if (!sockets[i].conn) {
  805d9c:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805da3:	00 00 00 
  805da6:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805da9:	48 63 d2             	movslq %edx,%rdx
  805dac:	48 c1 e2 05          	shl    $0x5,%rdx
  805db0:	48 01 d0             	add    %rdx,%rax
  805db3:	48 8b 00             	mov    (%rax),%rax
  805db6:	48 85 c0             	test   %rax,%rax
  805db9:	0f 85 00 01 00 00    	jne    805ebf <alloc_socket+0x155>
      sockets[i].conn       = newconn;
  805dbf:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805dc6:	00 00 00 
  805dc9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805dcc:	48 63 d2             	movslq %edx,%rdx
  805dcf:	48 c1 e2 05          	shl    $0x5,%rdx
  805dd3:	48 01 c2             	add    %rax,%rdx
  805dd6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805dda:	48 89 02             	mov    %rax,(%rdx)
      sockets[i].lastdata   = NULL;
  805ddd:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805de4:	00 00 00 
  805de7:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805dea:	48 63 d2             	movslq %edx,%rdx
  805ded:	48 c1 e2 05          	shl    $0x5,%rdx
  805df1:	48 01 d0             	add    %rdx,%rax
  805df4:	48 83 c0 08          	add    $0x8,%rax
  805df8:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      sockets[i].lastoffset = 0;
  805dff:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805e06:	00 00 00 
  805e09:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805e0c:	48 63 d2             	movslq %edx,%rdx
  805e0f:	48 c1 e2 05          	shl    $0x5,%rdx
  805e13:	48 01 d0             	add    %rdx,%rax
  805e16:	48 83 c0 10          	add    $0x10,%rax
  805e1a:	66 c7 00 00 00       	movw   $0x0,(%rax)
      sockets[i].rcvevent   = 0;
  805e1f:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805e26:	00 00 00 
  805e29:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805e2c:	48 63 d2             	movslq %edx,%rdx
  805e2f:	48 c1 e2 05          	shl    $0x5,%rdx
  805e33:	48 01 d0             	add    %rdx,%rax
  805e36:	48 83 c0 12          	add    $0x12,%rax
  805e3a:	66 c7 00 00 00       	movw   $0x0,(%rax)
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  805e3f:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805e46:	00 00 00 
  805e49:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805e4c:	48 63 d2             	movslq %edx,%rdx
  805e4f:	48 c1 e2 05          	shl    $0x5,%rdx
  805e53:	48 01 d0             	add    %rdx,%rax
  805e56:	48 83 c0 14          	add    $0x14,%rax
  805e5a:	66 c7 00 01 00       	movw   $0x1,(%rax)
      sockets[i].flags      = 0;
  805e5f:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805e66:	00 00 00 
  805e69:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805e6c:	48 63 d2             	movslq %edx,%rdx
  805e6f:	48 c1 e2 05          	shl    $0x5,%rdx
  805e73:	48 01 d0             	add    %rdx,%rax
  805e76:	48 83 c0 16          	add    $0x16,%rax
  805e7a:	66 c7 00 00 00       	movw   $0x0,(%rax)
      sockets[i].err        = 0;
  805e7f:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805e86:	00 00 00 
  805e89:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805e8c:	48 63 d2             	movslq %edx,%rdx
  805e8f:	48 c1 e2 05          	shl    $0x5,%rdx
  805e93:	48 01 d0             	add    %rdx,%rax
  805e96:	48 83 c0 18          	add    $0x18,%rax
  805e9a:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
      sys_sem_signal(socksem);
  805ea0:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805ea7:	00 00 00 
  805eaa:	8b 00                	mov    (%rax),%eax
  805eac:	89 c7                	mov    %eax,%edi
  805eae:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  805eb5:	00 00 00 
  805eb8:	ff d0                	callq  *%rax
      return i;
  805eba:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805ebd:	eb 2d                	jmp    805eec <alloc_socket+0x182>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  805ebf:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  805ec3:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  805ec7:	0f 8e cf fe ff ff    	jle    805d9c <alloc_socket+0x32>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  805ecd:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805ed4:	00 00 00 
  805ed7:	8b 00                	mov    (%rax),%eax
  805ed9:	89 c7                	mov    %eax,%edi
  805edb:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  805ee2:	00 00 00 
  805ee5:	ff d0                	callq  *%rax
  return -1;
  805ee7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  805eec:	c9                   	leaveq 
  805eed:	c3                   	retq   

0000000000805eee <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  805eee:	55                   	push   %rbp
  805eef:	48 89 e5             	mov    %rsp,%rbp
  805ef2:	48 83 ec 70          	sub    $0x70,%rsp
  805ef6:	89 7d ac             	mov    %edi,-0x54(%rbp)
  805ef9:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  805efd:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  805f01:	8b 45 ac             	mov    -0x54(%rbp),%eax
  805f04:	89 c7                	mov    %eax,%edi
  805f06:	48 b8 f6 5c 80 00 00 	movabs $0x805cf6,%rax
  805f0d:	00 00 00 
  805f10:	ff d0                	callq  *%rax
  805f12:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  805f16:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  805f1b:	75 0a                	jne    805f27 <lwip_accept+0x39>
    return -1;
  805f1d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805f22:	e9 f2 02 00 00       	jmpq   806219 <lwip_accept+0x32b>

  newconn = netconn_accept(sock->conn);
  805f27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805f2b:	48 8b 00             	mov    (%rax),%rax
  805f2e:	48 89 c7             	mov    %rax,%rdi
  805f31:	48 b8 c9 a0 81 00 00 	movabs $0x81a0c9,%rax
  805f38:	00 00 00 
  805f3b:	ff d0                	callq  *%rax
  805f3d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!newconn) {
  805f41:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  805f46:	75 62                	jne    805faa <lwip_accept+0xbc>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  805f48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805f4c:	48 8b 00             	mov    (%rax),%rax
  805f4f:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  805f53:	0f be c0             	movsbl %al,%eax
  805f56:	f7 d8                	neg    %eax
  805f58:	83 f8 0e             	cmp    $0xe,%eax
  805f5b:	77 24                	ja     805f81 <lwip_accept+0x93>
  805f5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805f61:	48 8b 00             	mov    (%rax),%rax
  805f64:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  805f68:	0f be c0             	movsbl %al,%eax
  805f6b:	f7 d8                	neg    %eax
  805f6d:	89 c2                	mov    %eax,%edx
  805f6f:	48 b8 40 18 82 00 00 	movabs $0x821840,%rax
  805f76:	00 00 00 
  805f79:	48 63 d2             	movslq %edx,%rdx
  805f7c:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  805f7f:	eb 05                	jmp    805f86 <lwip_accept+0x98>
  805f81:	b8 05 00 00 00       	mov    $0x5,%eax
  805f86:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  805f8a:	89 42 18             	mov    %eax,0x18(%rdx)
  805f8d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805f91:	8b 50 18             	mov    0x18(%rax),%edx
  805f94:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805f9b:	00 00 00 
  805f9e:	89 10                	mov    %edx,(%rax)
    return -1;
  805fa0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805fa5:	e9 6f 02 00 00       	jmpq   806219 <lwip_accept+0x32b>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  805faa:	48 8d 55 ce          	lea    -0x32(%rbp),%rdx
  805fae:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  805fb2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805fb6:	b9 00 00 00 00       	mov    $0x0,%ecx
  805fbb:	48 89 c7             	mov    %rax,%rdi
  805fbe:	48 b8 da 9d 81 00 00 	movabs $0x819dda,%rax
  805fc5:	00 00 00 
  805fc8:	ff d0                	callq  *%rax
  805fca:	88 45 ef             	mov    %al,-0x11(%rbp)
  if (err != ERR_OK) {
  805fcd:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  805fd1:	74 61                	je     806034 <lwip_accept+0x146>
    netconn_delete(newconn);
  805fd3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805fd7:	48 89 c7             	mov    %rax,%rdi
  805fda:	48 b8 2c 9d 81 00 00 	movabs $0x819d2c,%rax
  805fe1:	00 00 00 
  805fe4:	ff d0                	callq  *%rax
    sock_set_errno(sock, err_to_errno(err));
  805fe6:	0f be 45 ef          	movsbl -0x11(%rbp),%eax
  805fea:	f7 d8                	neg    %eax
  805fec:	83 f8 0e             	cmp    $0xe,%eax
  805fef:	77 1a                	ja     80600b <lwip_accept+0x11d>
  805ff1:	0f be 45 ef          	movsbl -0x11(%rbp),%eax
  805ff5:	f7 d8                	neg    %eax
  805ff7:	89 c2                	mov    %eax,%edx
  805ff9:	48 b8 40 18 82 00 00 	movabs $0x821840,%rax
  806000:	00 00 00 
  806003:	48 63 d2             	movslq %edx,%rdx
  806006:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806009:	eb 05                	jmp    806010 <lwip_accept+0x122>
  80600b:	b8 05 00 00 00       	mov    $0x5,%eax
  806010:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  806014:	89 42 18             	mov    %eax,0x18(%rdx)
  806017:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80601b:	8b 50 18             	mov    0x18(%rax),%edx
  80601e:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806025:	00 00 00 
  806028:	89 10                	mov    %edx,(%rax)
    return -1;
  80602a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80602f:	e9 e5 01 00 00       	jmpq   806219 <lwip_accept+0x32b>
  }

  memset(&sin, 0, sizeof(sin));
  806034:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  806038:	ba 10 00 00 00       	mov    $0x10,%edx
  80603d:	be 00 00 00 00       	mov    $0x0,%esi
  806042:	48 89 c7             	mov    %rax,%rdi
  806045:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  80604c:	00 00 00 
  80604f:	ff d0                	callq  *%rax
  sin.sin_len = sizeof(sin);
  806051:	c6 45 b0 10          	movb   $0x10,-0x50(%rbp)
  sin.sin_family = AF_INET;
  806055:	c6 45 b1 02          	movb   $0x2,-0x4f(%rbp)
  sin.sin_port = htons(port);
  806059:	0f b7 45 ce          	movzwl -0x32(%rbp),%eax
  80605d:	0f b7 c0             	movzwl %ax,%eax
  806060:	89 c7                	mov    %eax,%edi
  806062:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  806069:	00 00 00 
  80606c:	ff d0                	callq  *%rax
  80606e:	66 89 45 b2          	mov    %ax,-0x4e(%rbp)
  sin.sin_addr.s_addr = naddr.addr;
  806072:	8b 45 d0             	mov    -0x30(%rbp),%eax
  806075:	89 45 b4             	mov    %eax,-0x4c(%rbp)

  if (*addrlen > sizeof(sin))
  806078:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80607c:	8b 00                	mov    (%rax),%eax
  80607e:	83 f8 10             	cmp    $0x10,%eax
  806081:	76 0a                	jbe    80608d <lwip_accept+0x19f>
    *addrlen = sizeof(sin);
  806083:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806087:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

  SMEMCPY(addr, &sin, *addrlen);
  80608d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806091:	8b 00                	mov    (%rax),%eax
  806093:	89 c2                	mov    %eax,%edx
  806095:	48 8d 4d b0          	lea    -0x50(%rbp),%rcx
  806099:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80609d:	48 89 ce             	mov    %rcx,%rsi
  8060a0:	48 89 c7             	mov    %rax,%rdi
  8060a3:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  8060aa:	00 00 00 
  8060ad:	ff d0                	callq  *%rax

  newsock = alloc_socket(newconn);
  8060af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8060b3:	48 89 c7             	mov    %rax,%rdi
  8060b6:	48 b8 6a 5d 80 00 00 	movabs $0x805d6a,%rax
  8060bd:	00 00 00 
  8060c0:	ff d0                	callq  *%rax
  8060c2:	89 45 e8             	mov    %eax,-0x18(%rbp)
  if (newsock == -1) {
  8060c5:	83 7d e8 ff          	cmpl   $0xffffffff,-0x18(%rbp)
  8060c9:	75 3b                	jne    806106 <lwip_accept+0x218>
    netconn_delete(newconn);
  8060cb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8060cf:	48 89 c7             	mov    %rax,%rdi
  8060d2:	48 b8 2c 9d 81 00 00 	movabs $0x819d2c,%rax
  8060d9:	00 00 00 
  8060dc:	ff d0                	callq  *%rax
    sock_set_errno(sock, ENFILE);
  8060de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8060e2:	c7 40 18 17 00 00 00 	movl   $0x17,0x18(%rax)
  8060e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8060ed:	8b 50 18             	mov    0x18(%rax),%edx
  8060f0:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8060f7:	00 00 00 
  8060fa:	89 10                	mov    %edx,(%rax)
    return -1;
  8060fc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806101:	e9 13 01 00 00       	jmpq   806219 <lwip_accept+0x32b>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  806106:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80610a:	78 06                	js     806112 <lwip_accept+0x224>
  80610c:	83 7d e8 1f          	cmpl   $0x1f,-0x18(%rbp)
  806110:	7e 2a                	jle    80613c <lwip_accept+0x24e>
  806112:	48 ba 7c 18 82 00 00 	movabs $0x82187c,%rdx
  806119:	00 00 00 
  80611c:	be 26 01 00 00       	mov    $0x126,%esi
  806121:	48 bf 91 18 82 00 00 	movabs $0x821891,%rdi
  806128:	00 00 00 
  80612b:	b8 00 00 00 00       	mov    $0x0,%eax
  806130:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  806137:	00 00 00 
  80613a:	ff d1                	callq  *%rcx
  newconn->callback = event_callback;
  80613c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806140:	48 b9 b3 76 80 00 00 	movabs $0x8076b3,%rcx
  806147:	00 00 00 
  80614a:	48 89 48 38          	mov    %rcx,0x38(%rax)
  nsock = &sockets[newsock];
  80614e:	8b 45 e8             	mov    -0x18(%rbp),%eax
  806151:	48 98                	cltq   
  806153:	48 c1 e0 05          	shl    $0x5,%rax
  806157:	48 89 c2             	mov    %rax,%rdx
  80615a:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  806161:	00 00 00 
  806164:	48 01 d0             	add    %rdx,%rax
  806167:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);
  80616b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  806170:	75 2a                	jne    80619c <lwip_accept+0x2ae>
  806172:	48 ba a8 18 82 00 00 	movabs $0x8218a8,%rdx
  806179:	00 00 00 
  80617c:	be 29 01 00 00       	mov    $0x129,%esi
  806181:	48 bf 91 18 82 00 00 	movabs $0x821891,%rdi
  806188:	00 00 00 
  80618b:	b8 00 00 00 00       	mov    $0x0,%eax
  806190:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  806197:	00 00 00 
  80619a:	ff d1                	callq  *%rcx

  sys_sem_wait(socksem);
  80619c:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  8061a3:	00 00 00 
  8061a6:	8b 00                	mov    (%rax),%eax
  8061a8:	89 c7                	mov    %eax,%edi
  8061aa:	48 b8 fc e6 80 00 00 	movabs $0x80e6fc,%rax
  8061b1:	00 00 00 
  8061b4:	ff d0                	callq  *%rax
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  8061b6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8061ba:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  8061be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8061c2:	8b 40 20             	mov    0x20(%rax),%eax
  8061c5:	29 c2                	sub    %eax,%edx
  8061c7:	89 d0                	mov    %edx,%eax
  8061c9:	8d 50 ff             	lea    -0x1(%rax),%edx
  8061cc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8061d0:	66 89 50 12          	mov    %dx,0x12(%rax)
  newconn->socket = newsock;
  8061d4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8061d8:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8061db:	89 50 20             	mov    %edx,0x20(%rax)
  sys_sem_signal(socksem);
  8061de:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  8061e5:	00 00 00 
  8061e8:	8b 00                	mov    (%rax),%eax
  8061ea:	89 c7                	mov    %eax,%edi
  8061ec:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  8061f3:	00 00 00 
  8061f6:	ff d0                	callq  *%rax

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  8061f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8061fc:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  806203:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806207:	8b 50 18             	mov    0x18(%rax),%edx
  80620a:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806211:	00 00 00 
  806214:	89 10                	mov    %edx,(%rax)
  return newsock;
  806216:	8b 45 e8             	mov    -0x18(%rbp),%eax
}
  806219:	c9                   	leaveq 
  80621a:	c3                   	retq   

000000000080621b <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  80621b:	55                   	push   %rbp
  80621c:	48 89 e5             	mov    %rsp,%rbp
  80621f:	48 83 ec 20          	sub    $0x20,%rsp
  806223:	89 7d ec             	mov    %edi,-0x14(%rbp)
  806226:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80622a:	89 55 e8             	mov    %edx,-0x18(%rbp)
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  80622d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806230:	89 c7                	mov    %eax,%edi
  806232:	48 b8 f6 5c 80 00 00 	movabs $0x805cf6,%rax
  806239:	00 00 00 
  80623c:	ff d0                	callq  *%rax
  80623e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  806242:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806247:	75 0a                	jne    806253 <lwip_bind+0x38>
    return -1;
  806249:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80624e:	e9 fb 00 00 00       	jmpq   80634e <lwip_bind+0x133>

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  806253:	83 7d e8 10          	cmpl   $0x10,-0x18(%rbp)
  806257:	75 0c                	jne    806265 <lwip_bind+0x4a>
  806259:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80625d:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  806261:	3c 02                	cmp    $0x2,%al
  806263:	74 2a                	je     80628f <lwip_bind+0x74>
  806265:	48 ba bf 18 82 00 00 	movabs $0x8218bf,%rdx
  80626c:	00 00 00 
  80626f:	be 4b 01 00 00       	mov    $0x14b,%esi
  806274:	48 bf 91 18 82 00 00 	movabs $0x821891,%rdi
  80627b:	00 00 00 
  80627e:	b8 00 00 00 00       	mov    $0x0,%eax
  806283:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80628a:	00 00 00 
  80628d:	ff d1                	callq  *%rcx
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  80628f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  806293:	8b 40 04             	mov    0x4(%rax),%eax
  806296:	89 45 f0             	mov    %eax,-0x10(%rbp)
  local_port = ((struct sockaddr_in *)name)->sin_port;
  806299:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80629d:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8062a1:	66 89 45 f6          	mov    %ax,-0xa(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  8062a5:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8062a9:	89 c7                	mov    %eax,%edi
  8062ab:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  8062b2:	00 00 00 
  8062b5:	ff d0                	callq  *%rax
  8062b7:	0f b7 d0             	movzwl %ax,%edx
  8062ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8062be:	48 8b 00             	mov    (%rax),%rax
  8062c1:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  8062c5:	48 89 ce             	mov    %rcx,%rsi
  8062c8:	48 89 c7             	mov    %rax,%rdi
  8062cb:	48 b8 d0 9e 81 00 00 	movabs $0x819ed0,%rax
  8062d2:	00 00 00 
  8062d5:	ff d0                	callq  *%rax
  8062d7:	88 45 f5             	mov    %al,-0xb(%rbp)

  if (err != ERR_OK) {
  8062da:	80 7d f5 00          	cmpb   $0x0,-0xb(%rbp)
  8062de:	74 4b                	je     80632b <lwip_bind+0x110>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  8062e0:	0f be 45 f5          	movsbl -0xb(%rbp),%eax
  8062e4:	f7 d8                	neg    %eax
  8062e6:	83 f8 0e             	cmp    $0xe,%eax
  8062e9:	77 1a                	ja     806305 <lwip_bind+0xea>
  8062eb:	0f be 45 f5          	movsbl -0xb(%rbp),%eax
  8062ef:	f7 d8                	neg    %eax
  8062f1:	89 c2                	mov    %eax,%edx
  8062f3:	48 b8 40 18 82 00 00 	movabs $0x821840,%rax
  8062fa:	00 00 00 
  8062fd:	48 63 d2             	movslq %edx,%rdx
  806300:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806303:	eb 05                	jmp    80630a <lwip_bind+0xef>
  806305:	b8 05 00 00 00       	mov    $0x5,%eax
  80630a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80630e:	89 42 18             	mov    %eax,0x18(%rdx)
  806311:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806315:	8b 50 18             	mov    0x18(%rax),%edx
  806318:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80631f:	00 00 00 
  806322:	89 10                	mov    %edx,(%rax)
    return -1;
  806324:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806329:	eb 23                	jmp    80634e <lwip_bind+0x133>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  80632b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80632f:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  806336:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80633a:	8b 50 18             	mov    0x18(%rax),%edx
  80633d:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806344:	00 00 00 
  806347:	89 10                	mov    %edx,(%rax)
  return 0;
  806349:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80634e:	c9                   	leaveq 
  80634f:	c3                   	retq   

0000000000806350 <lwip_close>:

int
lwip_close(int s)
{
  806350:	55                   	push   %rbp
  806351:	48 89 e5             	mov    %rsp,%rbp
  806354:	48 83 ec 20          	sub    $0x20,%rsp
  806358:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  80635b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80635e:	89 c7                	mov    %eax,%edi
  806360:	48 b8 f6 5c 80 00 00 	movabs $0x805cf6,%rax
  806367:	00 00 00 
  80636a:	ff d0                	callq  *%rax
  80636c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock) {
  806370:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806375:	75 0a                	jne    806381 <lwip_close+0x31>
    return -1;
  806377:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80637c:	e9 b2 00 00 00       	jmpq   806433 <lwip_close+0xe3>
  }

  netconn_delete(sock->conn);
  806381:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806385:	48 8b 00             	mov    (%rax),%rax
  806388:	48 89 c7             	mov    %rax,%rdi
  80638b:	48 b8 2c 9d 81 00 00 	movabs $0x819d2c,%rax
  806392:	00 00 00 
  806395:	ff d0                	callq  *%rax

  sys_sem_wait(socksem);
  806397:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  80639e:	00 00 00 
  8063a1:	8b 00                	mov    (%rax),%eax
  8063a3:	89 c7                	mov    %eax,%edi
  8063a5:	48 b8 fc e6 80 00 00 	movabs $0x80e6fc,%rax
  8063ac:	00 00 00 
  8063af:	ff d0                	callq  *%rax
  if (sock->lastdata) {
  8063b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8063b5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8063b9:	48 85 c0             	test   %rax,%rax
  8063bc:	74 17                	je     8063d5 <lwip_close+0x85>
    netbuf_delete(sock->lastdata);
  8063be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8063c2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8063c6:	48 89 c7             	mov    %rax,%rdi
  8063c9:	48 b8 5c 8e 80 00 00 	movabs $0x808e5c,%rax
  8063d0:	00 00 00 
  8063d3:	ff d0                	callq  *%rax
  }
  sock->lastdata   = NULL;
  8063d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8063d9:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8063e0:	00 
  sock->lastoffset = 0;
  8063e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8063e5:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
  sock->conn       = NULL;
  8063eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8063ef:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  sock_set_errno(sock, 0);
  8063f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8063fa:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  806401:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806405:	8b 50 18             	mov    0x18(%rax),%edx
  806408:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80640f:	00 00 00 
  806412:	89 10                	mov    %edx,(%rax)
  sys_sem_signal(socksem);
  806414:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  80641b:	00 00 00 
  80641e:	8b 00                	mov    (%rax),%eax
  806420:	89 c7                	mov    %eax,%edi
  806422:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  806429:	00 00 00 
  80642c:	ff d0                	callq  *%rax
  return 0;
  80642e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  806433:	c9                   	leaveq 
  806434:	c3                   	retq   

0000000000806435 <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  806435:	55                   	push   %rbp
  806436:	48 89 e5             	mov    %rsp,%rbp
  806439:	48 83 ec 30          	sub    $0x30,%rsp
  80643d:	89 7d dc             	mov    %edi,-0x24(%rbp)
  806440:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  806444:	89 55 d8             	mov    %edx,-0x28(%rbp)
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  806447:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80644a:	89 c7                	mov    %eax,%edi
  80644c:	48 b8 f6 5c 80 00 00 	movabs $0x805cf6,%rax
  806453:	00 00 00 
  806456:	ff d0                	callq  *%rax
  806458:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!sock)
  80645c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  806461:	75 0a                	jne    80646d <lwip_connect+0x38>
    return -1;
  806463:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806468:	e9 22 01 00 00       	jmpq   80658f <lwip_connect+0x15a>

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80646d:	83 7d d8 10          	cmpl   $0x10,-0x28(%rbp)
  806471:	75 0c                	jne    80647f <lwip_connect+0x4a>
  806473:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  806477:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80647b:	3c 02                	cmp    $0x2,%al
  80647d:	74 2a                	je     8064a9 <lwip_connect+0x74>
  80647f:	48 ba da 18 82 00 00 	movabs $0x8218da,%rdx
  806486:	00 00 00 
  806489:	be 87 01 00 00       	mov    $0x187,%esi
  80648e:	48 bf 91 18 82 00 00 	movabs $0x821891,%rdi
  806495:	00 00 00 
  806498:	b8 00 00 00 00       	mov    $0x0,%eax
  80649d:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8064a4:	00 00 00 
  8064a7:	ff d1                	callq  *%rcx
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  if (((struct sockaddr_in *)name)->sin_family == AF_UNSPEC) {
  8064a9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8064ad:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8064b1:	84 c0                	test   %al,%al
  8064b3:	75 1b                	jne    8064d0 <lwip_connect+0x9b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
    err = netconn_disconnect(sock->conn);
  8064b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8064b9:	48 8b 00             	mov    (%rax),%rax
  8064bc:	48 89 c7             	mov    %rax,%rdi
  8064bf:	48 b8 e4 9f 81 00 00 	movabs $0x819fe4,%rax
  8064c6:	00 00 00 
  8064c9:	ff d0                	callq  *%rax
  8064cb:	88 45 ff             	mov    %al,-0x1(%rbp)
  8064ce:	eb 4b                	jmp    80651b <lwip_connect+0xe6>
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  8064d0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8064d4:	8b 40 04             	mov    0x4(%rax),%eax
  8064d7:	89 45 e0             	mov    %eax,-0x20(%rbp)
    remote_port = ((struct sockaddr_in *)name)->sin_port;
  8064da:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8064de:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8064e2:	66 89 45 ee          	mov    %ax,-0x12(%rbp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  8064e6:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  8064ea:	89 c7                	mov    %eax,%edi
  8064ec:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  8064f3:	00 00 00 
  8064f6:	ff d0                	callq  *%rax
  8064f8:	0f b7 d0             	movzwl %ax,%edx
  8064fb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8064ff:	48 8b 00             	mov    (%rax),%rax
  806502:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  806506:	48 89 ce             	mov    %rcx,%rsi
  806509:	48 89 c7             	mov    %rax,%rdi
  80650c:	48 b8 5a 9f 81 00 00 	movabs $0x819f5a,%rax
  806513:	00 00 00 
  806516:	ff d0                	callq  *%rax
  806518:	88 45 ff             	mov    %al,-0x1(%rbp)
  }

  if (err != ERR_OK) {
  80651b:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80651f:	74 4b                	je     80656c <lwip_connect+0x137>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  806521:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  806525:	f7 d8                	neg    %eax
  806527:	83 f8 0e             	cmp    $0xe,%eax
  80652a:	77 1a                	ja     806546 <lwip_connect+0x111>
  80652c:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  806530:	f7 d8                	neg    %eax
  806532:	89 c2                	mov    %eax,%edx
  806534:	48 b8 40 18 82 00 00 	movabs $0x821840,%rax
  80653b:	00 00 00 
  80653e:	48 63 d2             	movslq %edx,%rdx
  806541:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806544:	eb 05                	jmp    80654b <lwip_connect+0x116>
  806546:	b8 05 00 00 00       	mov    $0x5,%eax
  80654b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80654f:	89 42 18             	mov    %eax,0x18(%rdx)
  806552:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806556:	8b 50 18             	mov    0x18(%rax),%edx
  806559:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806560:	00 00 00 
  806563:	89 10                	mov    %edx,(%rax)
    return -1;
  806565:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80656a:	eb 23                	jmp    80658f <lwip_connect+0x15a>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  80656c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806570:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  806577:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80657b:	8b 50 18             	mov    0x18(%rax),%edx
  80657e:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806585:	00 00 00 
  806588:	89 10                	mov    %edx,(%rax)
  return 0;
  80658a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80658f:	c9                   	leaveq 
  806590:	c3                   	retq   

0000000000806591 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  806591:	55                   	push   %rbp
  806592:	48 89 e5             	mov    %rsp,%rbp
  806595:	48 83 ec 20          	sub    $0x20,%rsp
  806599:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80659c:	89 75 e8             	mov    %esi,-0x18(%rbp)
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  80659f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8065a2:	89 c7                	mov    %eax,%edi
  8065a4:	48 b8 f6 5c 80 00 00 	movabs $0x805cf6,%rax
  8065ab:	00 00 00 
  8065ae:	ff d0                	callq  *%rax
  8065b0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  8065b4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8065b9:	75 0a                	jne    8065c5 <lwip_listen+0x34>
    return -1;
  8065bb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8065c0:	e9 b2 00 00 00       	jmpq   806677 <lwip_listen+0xe6>

  /* limit the "backlog" parameter to fit in an u8_t */
  if (backlog < 0) {
  8065c5:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  8065c9:	79 07                	jns    8065d2 <lwip_listen+0x41>
    backlog = 0;
  8065cb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
  }
  if (backlog > 0xff) {
  8065d2:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%rbp)
  8065d9:	7e 07                	jle    8065e2 <lwip_listen+0x51>
    backlog = 0xff;
  8065db:	c7 45 e8 ff 00 00 00 	movl   $0xff,-0x18(%rbp)
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  8065e2:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8065e5:	0f b6 d0             	movzbl %al,%edx
  8065e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8065ec:	48 8b 00             	mov    (%rax),%rax
  8065ef:	89 d6                	mov    %edx,%esi
  8065f1:	48 89 c7             	mov    %rax,%rdi
  8065f4:	48 b8 54 a0 81 00 00 	movabs $0x81a054,%rax
  8065fb:	00 00 00 
  8065fe:	ff d0                	callq  *%rax
  806600:	88 45 f7             	mov    %al,-0x9(%rbp)

  if (err != ERR_OK) {
  806603:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  806607:	74 4b                	je     806654 <lwip_listen+0xc3>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  806609:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  80660d:	f7 d8                	neg    %eax
  80660f:	83 f8 0e             	cmp    $0xe,%eax
  806612:	77 1a                	ja     80662e <lwip_listen+0x9d>
  806614:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806618:	f7 d8                	neg    %eax
  80661a:	89 c2                	mov    %eax,%edx
  80661c:	48 b8 40 18 82 00 00 	movabs $0x821840,%rax
  806623:	00 00 00 
  806626:	48 63 d2             	movslq %edx,%rdx
  806629:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  80662c:	eb 05                	jmp    806633 <lwip_listen+0xa2>
  80662e:	b8 05 00 00 00       	mov    $0x5,%eax
  806633:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  806637:	89 42 18             	mov    %eax,0x18(%rdx)
  80663a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80663e:	8b 50 18             	mov    0x18(%rax),%edx
  806641:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806648:	00 00 00 
  80664b:	89 10                	mov    %edx,(%rax)
    return -1;
  80664d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806652:	eb 23                	jmp    806677 <lwip_listen+0xe6>
  }

  sock_set_errno(sock, 0);
  806654:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806658:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  80665f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806663:	8b 50 18             	mov    0x18(%rax),%edx
  806666:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80666d:	00 00 00 
  806670:	89 10                	mov    %edx,(%rax)
  return 0;
  806672:	b8 00 00 00 00       	mov    $0x0,%eax
}
  806677:	c9                   	leaveq 
  806678:	c3                   	retq   

0000000000806679 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  806679:	55                   	push   %rbp
  80667a:	48 89 e5             	mov    %rsp,%rbp
  80667d:	48 83 ec 70          	sub    $0x70,%rsp
  806681:	89 7d bc             	mov    %edi,-0x44(%rbp)
  806684:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  806688:	89 55 b8             	mov    %edx,-0x48(%rbp)
  80668b:	89 4d ac             	mov    %ecx,-0x54(%rbp)
  80668e:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  806692:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
  struct lwip_socket *sock;
  struct netbuf      *buf;
  u16_t               buflen, copylen, off = 0;
  806696:	66 c7 45 f4 00 00    	movw   $0x0,-0xc(%rbp)
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;
  80669c:	c6 45 e7 00          	movb   $0x0,-0x19(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  8066a0:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8066a3:	89 c7                	mov    %eax,%edi
  8066a5:	48 b8 f6 5c 80 00 00 	movabs $0x805cf6,%rax
  8066ac:	00 00 00 
  8066af:	ff d0                	callq  *%rax
  8066b1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (!sock)
  8066b5:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8066ba:	75 0a                	jne    8066c6 <lwip_recvfrom+0x4d>
    return -1;
  8066bc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8066c1:	e9 8a 03 00 00       	jmpq   806a50 <lwip_recvfrom+0x3d7>

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  8066c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8066ca:	48 8b 40 08          	mov    0x8(%rax),%rax
  8066ce:	48 85 c0             	test   %rax,%rax
  8066d1:	74 11                	je     8066e4 <lwip_recvfrom+0x6b>
      buf = sock->lastdata;
  8066d3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8066d7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8066db:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8066df:	e9 0c 01 00 00       	jmpq   8067f0 <lwip_recvfrom+0x177>
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8066e4:	8b 45 ac             	mov    -0x54(%rbp),%eax
  8066e7:	83 e0 08             	and    $0x8,%eax
  8066ea:	85 c0                	test   %eax,%eax
  8066ec:	75 14                	jne    806702 <lwip_recvfrom+0x89>
  8066ee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8066f2:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  8066f6:	0f b7 c0             	movzwl %ax,%eax
  8066f9:	25 00 08 00 00       	and    $0x800,%eax
  8066fe:	85 c0                	test   %eax,%eax
  806700:	74 35                	je     806737 <lwip_recvfrom+0xbe>
  806702:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806706:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80670a:	66 85 c0             	test   %ax,%ax
  80670d:	75 28                	jne    806737 <lwip_recvfrom+0xbe>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  80670f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806713:	c7 40 18 0b 00 00 00 	movl   $0xb,0x18(%rax)
  80671a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80671e:	8b 50 18             	mov    0x18(%rax),%edx
  806721:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806728:	00 00 00 
  80672b:	89 10                	mov    %edx,(%rax)
        return -1;
  80672d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806732:	e9 19 03 00 00       	jmpq   806a50 <lwip_recvfrom+0x3d7>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  806737:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80673b:	48 8b 00             	mov    (%rax),%rax
  80673e:	48 89 c7             	mov    %rax,%rdi
  806741:	48 b8 8b a1 81 00 00 	movabs $0x81a18b,%rax
  806748:	00 00 00 
  80674b:	ff d0                	callq  *%rax
  80674d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  806751:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806755:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  806759:	48 89 50 08          	mov    %rdx,0x8(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  80675d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806762:	0f 85 88 00 00 00    	jne    8067f0 <lwip_recvfrom+0x177>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  806768:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80676c:	48 8b 00             	mov    (%rax),%rax
  80676f:	48 8b 40 08          	mov    0x8(%rax),%rax
  806773:	48 85 c0             	test   %rax,%rax
  806776:	74 0f                	je     806787 <lwip_recvfrom+0x10e>
  806778:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80677c:	48 8b 00             	mov    (%rax),%rax
  80677f:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  806783:	84 c0                	test   %al,%al
  806785:	74 40                	je     8067c7 <lwip_recvfrom+0x14e>
  806787:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80678b:	48 8b 00             	mov    (%rax),%rax
  80678e:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  806792:	0f be c0             	movsbl %al,%eax
  806795:	f7 d8                	neg    %eax
  806797:	83 f8 0e             	cmp    $0xe,%eax
  80679a:	77 24                	ja     8067c0 <lwip_recvfrom+0x147>
  80679c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8067a0:	48 8b 00             	mov    (%rax),%rax
  8067a3:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8067a7:	0f be c0             	movsbl %al,%eax
  8067aa:	f7 d8                	neg    %eax
  8067ac:	89 c2                	mov    %eax,%edx
  8067ae:	48 b8 40 18 82 00 00 	movabs $0x821840,%rax
  8067b5:	00 00 00 
  8067b8:	48 63 d2             	movslq %edx,%rdx
  8067bb:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  8067be:	eb 0c                	jmp    8067cc <lwip_recvfrom+0x153>
  8067c0:	b8 05 00 00 00       	mov    $0x5,%eax
  8067c5:	eb 05                	jmp    8067cc <lwip_recvfrom+0x153>
  8067c7:	b8 6e 00 00 00       	mov    $0x6e,%eax
  8067cc:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8067d0:	89 42 18             	mov    %eax,0x18(%rdx)
  8067d3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8067d7:	8b 50 18             	mov    0x18(%rax),%edx
  8067da:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8067e1:	00 00 00 
  8067e4:	89 10                	mov    %edx,(%rax)
        return 0;
  8067e6:	b8 00 00 00 00       	mov    $0x0,%eax
  8067eb:	e9 60 02 00 00       	jmpq   806a50 <lwip_recvfrom+0x3d7>
      }
    }

    buflen = netbuf_len(buf);
  8067f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8067f4:	48 8b 00             	mov    (%rax),%rax
  8067f7:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8067fb:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  8067ff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806803:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  806807:	66 29 45 d6          	sub    %ax,-0x2a(%rbp)

    if (len > buflen) {
  80680b:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
  80680f:	3b 45 b8             	cmp    -0x48(%rbp),%eax
  806812:	7d 0a                	jge    80681e <lwip_recvfrom+0x1a5>
      copylen = buflen;
  806814:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
  806818:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  80681c:	eb 07                	jmp    806825 <lwip_recvfrom+0x1ac>
    } else {
      copylen = len;
  80681e:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806821:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  806825:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806829:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80682d:	0f b7 c8             	movzwl %ax,%ecx
  806830:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  806834:	0f b7 75 f4          	movzwl -0xc(%rbp),%esi
  806838:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80683c:	48 01 c6             	add    %rax,%rsi
  80683f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806843:	48 8b 00             	mov    (%rax),%rax
  806846:	48 89 c7             	mov    %rax,%rdi
  806849:	48 b8 5e e4 80 00 00 	movabs $0x80e45e,%rax
  806850:	00 00 00 
  806853:	ff d0                	callq  *%rax

    off += copylen;
  806855:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  806859:	66 01 45 f4          	add    %ax,-0xc(%rbp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80685d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806861:	48 8b 00             	mov    (%rax),%rax
  806864:	48 89 c7             	mov    %rax,%rdi
  806867:	48 b8 95 9d 81 00 00 	movabs $0x819d95,%rax
  80686e:	00 00 00 
  806871:	ff d0                	callq  *%rax
  806873:	83 f8 10             	cmp    $0x10,%eax
  806876:	75 35                	jne    8068ad <lwip_recvfrom+0x234>
      len -= copylen;
  806878:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80687c:	29 45 b8             	sub    %eax,-0x48(%rbp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  80687f:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  806883:	7e 22                	jle    8068a7 <lwip_recvfrom+0x22e>
  806885:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806889:	48 8b 00             	mov    (%rax),%rax
  80688c:	0f b6 40 15          	movzbl 0x15(%rax),%eax
  806890:	0f b6 c0             	movzbl %al,%eax
  806893:	83 e0 01             	and    $0x1,%eax
  806896:	85 c0                	test   %eax,%eax
  806898:	75 0d                	jne    8068a7 <lwip_recvfrom+0x22e>
  80689a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80689e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8068a2:	66 85 c0             	test   %ax,%ax
  8068a5:	75 0a                	jne    8068b1 <lwip_recvfrom+0x238>
        done = 1;
  8068a7:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
  8068ab:	eb 04                	jmp    8068b1 <lwip_recvfrom+0x238>
      }
    } else {
      done = 1;
  8068ad:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8068b1:	8b 45 ac             	mov    -0x54(%rbp),%eax
  8068b4:	83 e0 01             	and    $0x1,%eax
  8068b7:	85 c0                	test   %eax,%eax
  8068b9:	75 6d                	jne    806928 <lwip_recvfrom+0x2af>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8068bb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8068bf:	48 8b 00             	mov    (%rax),%rax
  8068c2:	8b 00                	mov    (%rax),%eax
  8068c4:	83 f8 10             	cmp    $0x10,%eax
  8068c7:	75 34                	jne    8068fd <lwip_recvfrom+0x284>
  8068c9:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  8068cd:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8068d1:	29 c2                	sub    %eax,%edx
  8068d3:	89 d0                	mov    %edx,%eax
  8068d5:	85 c0                	test   %eax,%eax
  8068d7:	7e 24                	jle    8068fd <lwip_recvfrom+0x284>
        sock->lastdata = buf;
  8068d9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8068dd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8068e1:	48 89 50 08          	mov    %rdx,0x8(%rax)
        sock->lastoffset += copylen;
  8068e5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8068e9:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  8068ed:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8068f1:	01 c2                	add    %eax,%edx
  8068f3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8068f7:	66 89 50 10          	mov    %dx,0x10(%rax)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  8068fb:	eb 2f                	jmp    80692c <lwip_recvfrom+0x2b3>
      } else {
        sock->lastdata = NULL;
  8068fd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806901:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  806908:	00 
        sock->lastoffset = 0;
  806909:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80690d:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  806913:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806917:	48 89 c7             	mov    %rax,%rdi
  80691a:	48 b8 5c 8e 80 00 00 	movabs $0x808e5c,%rax
  806921:	00 00 00 
  806924:	ff d0                	callq  *%rax
  806926:	eb 04                	jmp    80692c <lwip_recvfrom+0x2b3>
      }
    } else {
      done = 1;
  806928:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
    }
  } while (!done);
  80692c:	80 7d e7 00          	cmpb   $0x0,-0x19(%rbp)
  806930:	0f 84 90 fd ff ff    	je     8066c6 <lwip_recvfrom+0x4d>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  806936:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  80693b:	0f 84 ed 00 00 00    	je     806a2e <lwip_recvfrom+0x3b5>
  806941:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  806946:	0f 84 e2 00 00 00    	je     806a2e <lwip_recvfrom+0x3b5>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80694c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806950:	48 8b 00             	mov    (%rax),%rax
  806953:	48 89 c7             	mov    %rax,%rdi
  806956:	48 b8 95 9d 81 00 00 	movabs $0x819d95,%rax
  80695d:	00 00 00 
  806960:	ff d0                	callq  *%rax
  806962:	83 f8 10             	cmp    $0x10,%eax
  806965:	75 31                	jne    806998 <lwip_recvfrom+0x31f>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  806967:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  80696b:	48 83 c0 04          	add    $0x4,%rax
  80696f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      netconn_getaddr(sock->conn, addr, &port, 0);
  806973:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806977:	48 8b 00             	mov    (%rax),%rax
  80697a:	48 8d 55 d4          	lea    -0x2c(%rbp),%rdx
  80697e:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  806982:	b9 00 00 00 00       	mov    $0x0,%ecx
  806987:	48 89 c7             	mov    %rax,%rdi
  80698a:	48 b8 da 9d 81 00 00 	movabs $0x819dda,%rax
  806991:	00 00 00 
  806994:	ff d0                	callq  *%rax
  806996:	eb 18                	jmp    8069b0 <lwip_recvfrom+0x337>
    } else {
      addr = netbuf_fromaddr(buf);
  806998:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80699c:	48 8b 40 10          	mov    0x10(%rax),%rax
  8069a0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      port = netbuf_fromport(buf);
  8069a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8069a8:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8069ac:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)
    }

    memset(&sin, 0, sizeof(sin));
  8069b0:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8069b4:	ba 10 00 00 00       	mov    $0x10,%edx
  8069b9:	be 00 00 00 00       	mov    $0x0,%esi
  8069be:	48 89 c7             	mov    %rax,%rdi
  8069c1:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  8069c8:	00 00 00 
  8069cb:	ff d0                	callq  *%rax
    sin.sin_len = sizeof(sin);
  8069cd:	c6 45 c0 10          	movb   $0x10,-0x40(%rbp)
    sin.sin_family = AF_INET;
  8069d1:	c6 45 c1 02          	movb   $0x2,-0x3f(%rbp)
    sin.sin_port = htons(port);
  8069d5:	0f b7 45 d4          	movzwl -0x2c(%rbp),%eax
  8069d9:	0f b7 c0             	movzwl %ax,%eax
  8069dc:	89 c7                	mov    %eax,%edi
  8069de:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  8069e5:	00 00 00 
  8069e8:	ff d0                	callq  *%rax
  8069ea:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
    sin.sin_addr.s_addr = addr->addr;
  8069ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8069f2:	8b 00                	mov    (%rax),%eax
  8069f4:	89 45 c4             	mov    %eax,-0x3c(%rbp)

    if (*fromlen > sizeof(sin))
  8069f7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8069fb:	8b 00                	mov    (%rax),%eax
  8069fd:	83 f8 10             	cmp    $0x10,%eax
  806a00:	76 0a                	jbe    806a0c <lwip_recvfrom+0x393>
      *fromlen = sizeof(sin);
  806a02:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806a06:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

    SMEMCPY(from, &sin, *fromlen);
  806a0c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806a10:	8b 00                	mov    (%rax),%eax
  806a12:	89 c2                	mov    %eax,%edx
  806a14:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  806a18:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806a1c:	48 89 ce             	mov    %rcx,%rsi
  806a1f:	48 89 c7             	mov    %rax,%rdi
  806a22:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  806a29:	00 00 00 
  806a2c:	ff d0                	callq  *%rax
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  806a2e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806a32:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  806a39:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806a3d:	8b 50 18             	mov    0x18(%rax),%edx
  806a40:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806a47:	00 00 00 
  806a4a:	89 10                	mov    %edx,(%rax)
  return off;
  806a4c:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
}
  806a50:	c9                   	leaveq 
  806a51:	c3                   	retq   

0000000000806a52 <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  806a52:	55                   	push   %rbp
  806a53:	48 89 e5             	mov    %rsp,%rbp
  806a56:	48 83 ec 10          	sub    $0x10,%rsp
  806a5a:	89 7d fc             	mov    %edi,-0x4(%rbp)
  806a5d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  806a61:	89 55 f8             	mov    %edx,-0x8(%rbp)
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  806a64:	8b 55 f8             	mov    -0x8(%rbp),%edx
  806a67:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  806a6b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806a6e:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  806a74:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  806a7a:	b9 00 00 00 00       	mov    $0x0,%ecx
  806a7f:	89 c7                	mov    %eax,%edi
  806a81:	48 b8 79 66 80 00 00 	movabs $0x806679,%rax
  806a88:	00 00 00 
  806a8b:	ff d0                	callq  *%rax
}
  806a8d:	c9                   	leaveq 
  806a8e:	c3                   	retq   

0000000000806a8f <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  806a8f:	55                   	push   %rbp
  806a90:	48 89 e5             	mov    %rsp,%rbp
  806a93:	48 83 ec 20          	sub    $0x20,%rsp
  806a97:	89 7d fc             	mov    %edi,-0x4(%rbp)
  806a9a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  806a9e:	89 55 f8             	mov    %edx,-0x8(%rbp)
  806aa1:	89 4d ec             	mov    %ecx,-0x14(%rbp)
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  806aa4:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  806aa7:	8b 55 f8             	mov    -0x8(%rbp),%edx
  806aaa:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  806aae:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806ab1:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  806ab7:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  806abd:	89 c7                	mov    %eax,%edi
  806abf:	48 b8 79 66 80 00 00 	movabs $0x806679,%rax
  806ac6:	00 00 00 
  806ac9:	ff d0                	callq  *%rax
}
  806acb:	c9                   	leaveq 
  806acc:	c3                   	retq   

0000000000806acd <lwip_send>:

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  806acd:	55                   	push   %rbp
  806ace:	48 89 e5             	mov    %rsp,%rbp
  806ad1:	48 83 ec 30          	sub    $0x30,%rsp
  806ad5:	89 7d ec             	mov    %edi,-0x14(%rbp)
  806ad8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  806adc:	89 55 e8             	mov    %edx,-0x18(%rbp)
  806adf:	89 4d dc             	mov    %ecx,-0x24(%rbp)
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  806ae2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806ae5:	89 c7                	mov    %eax,%edi
  806ae7:	48 b8 f6 5c 80 00 00 	movabs $0x805cf6,%rax
  806aee:	00 00 00 
  806af1:	ff d0                	callq  *%rax
  806af3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  806af7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806afc:	75 0a                	jne    806b08 <lwip_send+0x3b>
    return -1;
  806afe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806b03:	e9 c5 00 00 00       	jmpq   806bcd <lwip_send+0x100>

  if (sock->conn->type!=NETCONN_TCP) {
  806b08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806b0c:	48 8b 00             	mov    (%rax),%rax
  806b0f:	8b 00                	mov    (%rax),%eax
  806b11:	83 f8 10             	cmp    $0x10,%eax
  806b14:	74 2c                	je     806b42 <lwip_send+0x75>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  806b16:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  806b19:	8b 55 e8             	mov    -0x18(%rbp),%edx
  806b1c:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  806b20:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806b23:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  806b29:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  806b2f:	89 c7                	mov    %eax,%edi
  806b31:	48 b8 cf 6b 80 00 00 	movabs $0x806bcf,%rax
  806b38:	00 00 00 
  806b3b:	ff d0                	callq  *%rax
  806b3d:	e9 8b 00 00 00       	jmpq   806bcd <lwip_send+0x100>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  806b42:	8b 45 dc             	mov    -0x24(%rbp),%eax
  806b45:	83 e0 10             	and    $0x10,%eax
  806b48:	85 c0                	test   %eax,%eax
  806b4a:	74 07                	je     806b53 <lwip_send+0x86>
  806b4c:	b9 03 00 00 00       	mov    $0x3,%ecx
  806b51:	eb 05                	jmp    806b58 <lwip_send+0x8b>
  806b53:	b9 01 00 00 00       	mov    $0x1,%ecx
  806b58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806b5c:	48 8b 00             	mov    (%rax),%rax
  806b5f:	8b 55 e8             	mov    -0x18(%rbp),%edx
  806b62:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  806b66:	48 89 c7             	mov    %rax,%rdi
  806b69:	48 b8 e9 a4 81 00 00 	movabs $0x81a4e9,%rax
  806b70:	00 00 00 
  806b73:	ff d0                	callq  *%rax
  806b75:	88 45 f7             	mov    %al,-0x9(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  806b78:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806b7c:	f7 d8                	neg    %eax
  806b7e:	83 f8 0e             	cmp    $0xe,%eax
  806b81:	77 1a                	ja     806b9d <lwip_send+0xd0>
  806b83:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806b87:	f7 d8                	neg    %eax
  806b89:	89 c2                	mov    %eax,%edx
  806b8b:	48 b8 40 18 82 00 00 	movabs $0x821840,%rax
  806b92:	00 00 00 
  806b95:	48 63 d2             	movslq %edx,%rdx
  806b98:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806b9b:	eb 05                	jmp    806ba2 <lwip_send+0xd5>
  806b9d:	b8 05 00 00 00       	mov    $0x5,%eax
  806ba2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  806ba6:	89 42 18             	mov    %eax,0x18(%rdx)
  806ba9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806bad:	8b 50 18             	mov    0x18(%rax),%edx
  806bb0:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806bb7:	00 00 00 
  806bba:	89 10                	mov    %edx,(%rax)
  return (err==ERR_OK?size:-1);
  806bbc:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  806bc0:	75 05                	jne    806bc7 <lwip_send+0xfa>
  806bc2:	8b 45 e8             	mov    -0x18(%rbp),%eax
  806bc5:	eb 05                	jmp    806bcc <lwip_send+0xff>
  806bc7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806bcc:	90                   	nop
}
  806bcd:	c9                   	leaveq 
  806bce:	c3                   	retq   

0000000000806bcf <lwip_sendto>:

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  806bcf:	55                   	push   %rbp
  806bd0:	48 89 e5             	mov    %rsp,%rbp
  806bd3:	48 83 ec 60          	sub    $0x60,%rsp
  806bd7:	89 7d bc             	mov    %edi,-0x44(%rbp)
  806bda:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  806bde:	89 55 b8             	mov    %edx,-0x48(%rbp)
  806be1:	89 4d ac             	mov    %ecx,-0x54(%rbp)
  806be4:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  806be8:	44 89 4d a8          	mov    %r9d,-0x58(%rbp)
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  806bec:	8b 45 bc             	mov    -0x44(%rbp),%eax
  806bef:	89 c7                	mov    %eax,%edi
  806bf1:	48 b8 f6 5c 80 00 00 	movabs $0x805cf6,%rax
  806bf8:	00 00 00 
  806bfb:	ff d0                	callq  *%rax
  806bfd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!sock)
  806c01:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  806c06:	75 0a                	jne    806c12 <lwip_sendto+0x43>
    return -1;
  806c08:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806c0d:	e9 d9 01 00 00       	jmpq   806deb <lwip_sendto+0x21c>

  if (sock->conn->type==NETCONN_TCP) {
  806c12:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806c16:	48 8b 00             	mov    (%rax),%rax
  806c19:	8b 00                	mov    (%rax),%eax
  806c1b:	83 f8 10             	cmp    $0x10,%eax
  806c1e:	75 20                	jne    806c40 <lwip_sendto+0x71>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  806c20:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  806c23:	8b 55 b8             	mov    -0x48(%rbp),%edx
  806c26:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  806c2a:	8b 45 bc             	mov    -0x44(%rbp),%eax
  806c2d:	89 c7                	mov    %eax,%edi
  806c2f:	48 b8 cd 6a 80 00 00 	movabs $0x806acd,%rax
  806c36:	00 00 00 
  806c39:	ff d0                	callq  *%rax
  806c3b:	e9 ab 01 00 00       	jmpq   806deb <lwip_sendto+0x21c>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  806c40:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  806c44:	78 09                	js     806c4f <lwip_sendto+0x80>
  806c46:	81 7d b8 ff ff 00 00 	cmpl   $0xffff,-0x48(%rbp)
  806c4d:	7e 2a                	jle    806c79 <lwip_sendto+0xaa>
  806c4f:	48 ba f8 18 82 00 00 	movabs $0x8218f8,%rdx
  806c56:	00 00 00 
  806c59:	be 98 02 00 00       	mov    $0x298,%esi
  806c5e:	48 bf 91 18 82 00 00 	movabs $0x821891,%rdi
  806c65:	00 00 00 
  806c68:	b8 00 00 00 00       	mov    $0x0,%eax
  806c6d:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  806c74:	00 00 00 
  806c77:	ff d1                	callq  *%rcx
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  806c79:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  806c7e:	75 06                	jne    806c86 <lwip_sendto+0xb7>
  806c80:	83 7d a8 00          	cmpl   $0x0,-0x58(%rbp)
  806c84:	74 3c                	je     806cc2 <lwip_sendto+0xf3>
  806c86:	83 7d a8 10          	cmpl   $0x10,-0x58(%rbp)
  806c8a:	75 0c                	jne    806c98 <lwip_sendto+0xc9>
  806c8c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806c90:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  806c94:	3c 02                	cmp    $0x2,%al
  806c96:	74 2a                	je     806cc2 <lwip_sendto+0xf3>
  806c98:	48 ba 1c 19 82 00 00 	movabs $0x82191c,%rdx
  806c9f:	00 00 00 
  806ca2:	be 9c 02 00 00       	mov    $0x29c,%esi
  806ca7:	48 bf 91 18 82 00 00 	movabs $0x821891,%rdi
  806cae:	00 00 00 
  806cb1:	b8 00 00 00 00       	mov    $0x0,%eax
  806cb6:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  806cbd:	00 00 00 
  806cc0:	ff d1                	callq  *%rcx
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  806cc2:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  806cc9:	00 
  806cca:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  806cce:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  if (to) {
  806cd2:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  806cd7:	74 39                	je     806d12 <lwip_sendto+0x143>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  806cd9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806cdd:	8b 40 04             	mov    0x4(%rax),%eax
  806ce0:	89 45 e0             	mov    %eax,-0x20(%rbp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  806ce3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806ce7:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  806ceb:	0f b7 c0             	movzwl %ax,%eax
  806cee:	89 c7                	mov    %eax,%edi
  806cf0:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  806cf7:	00 00 00 
  806cfa:	ff d0                	callq  *%rax
  806cfc:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    buf.addr         = &remote_addr;
  806d00:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  806d04:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    buf.port         = remote_port;
  806d08:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  806d0c:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  806d10:	eb 1b                	jmp    806d2d <lwip_sendto+0x15e>
  } else {
    remote_addr.addr = 0;
  806d12:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    remote_port      = 0;
  806d19:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
    buf.addr         = NULL;
  806d1f:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  806d26:	00 
    buf.port         = 0;
  806d27:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%rbp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  806d2d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806d30:	0f b7 d0             	movzwl %ax,%edx
  806d33:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  806d37:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  806d3b:	48 89 ce             	mov    %rcx,%rsi
  806d3e:	48 89 c7             	mov    %rax,%rdi
  806d41:	48 b8 39 90 80 00 00 	movabs $0x809039,%rax
  806d48:	00 00 00 
  806d4b:	ff d0                	callq  *%rax
  806d4d:	0f be c0             	movsbl %al,%eax
  806d50:	89 45 fc             	mov    %eax,-0x4(%rbp)
  806d53:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  806d57:	75 23                	jne    806d7c <lwip_sendto+0x1ad>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  806d59:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806d5d:	48 8b 00             	mov    (%rax),%rax
  806d60:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  806d64:	48 89 d6             	mov    %rdx,%rsi
  806d67:	48 89 c7             	mov    %rax,%rdi
  806d6a:	48 b8 6d a4 81 00 00 	movabs $0x81a46d,%rax
  806d71:	00 00 00 
  806d74:	ff d0                	callq  *%rax
  806d76:	0f be c0             	movsbl %al,%eax
  806d79:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  806d7c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  806d80:	48 85 c0             	test   %rax,%rax
  806d83:	74 13                	je     806d98 <lwip_sendto+0x1c9>
    pbuf_free(buf.p);
  806d85:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  806d89:	48 89 c7             	mov    %rax,%rdi
  806d8c:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  806d93:	00 00 00 
  806d96:	ff d0                	callq  *%rax
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  806d98:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806d9b:	f7 d8                	neg    %eax
  806d9d:	83 f8 0e             	cmp    $0xe,%eax
  806da0:	77 19                	ja     806dbb <lwip_sendto+0x1ec>
  806da2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806da5:	f7 d8                	neg    %eax
  806da7:	89 c2                	mov    %eax,%edx
  806da9:	48 b8 40 18 82 00 00 	movabs $0x821840,%rax
  806db0:	00 00 00 
  806db3:	48 63 d2             	movslq %edx,%rdx
  806db6:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806db9:	eb 05                	jmp    806dc0 <lwip_sendto+0x1f1>
  806dbb:	b8 05 00 00 00       	mov    $0x5,%eax
  806dc0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  806dc4:	89 42 18             	mov    %eax,0x18(%rdx)
  806dc7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806dcb:	8b 50 18             	mov    0x18(%rax),%edx
  806dce:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806dd5:	00 00 00 
  806dd8:	89 10                	mov    %edx,(%rax)
  return (err==ERR_OK?size:-1);
  806dda:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  806dde:	75 05                	jne    806de5 <lwip_sendto+0x216>
  806de0:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806de3:	eb 06                	jmp    806deb <lwip_sendto+0x21c>
  806de5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806dea:	90                   	nop
}
  806deb:	c9                   	leaveq 
  806dec:	c3                   	retq   

0000000000806ded <lwip_socket>:

int
lwip_socket(int domain, int type, int protocol)
{
  806ded:	55                   	push   %rbp
  806dee:	48 89 e5             	mov    %rsp,%rbp
  806df1:	48 83 ec 20          	sub    $0x20,%rsp
  806df5:	89 7d ec             	mov    %edi,-0x14(%rbp)
  806df8:	89 75 e8             	mov    %esi,-0x18(%rbp)
  806dfb:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  806dfe:	8b 45 e8             	mov    -0x18(%rbp),%eax
  806e01:	83 f8 02             	cmp    $0x2,%eax
  806e04:	74 38                	je     806e3e <lwip_socket+0x51>
  806e06:	83 f8 03             	cmp    $0x3,%eax
  806e09:	74 0a                	je     806e15 <lwip_socket+0x28>
  806e0b:	83 f8 01             	cmp    $0x1,%eax
  806e0e:	74 66                	je     806e76 <lwip_socket+0x89>
  806e10:	e9 87 00 00 00       	jmpq   806e9c <lwip_socket+0xaf>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  806e15:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  806e18:	0f b6 c0             	movzbl %al,%eax
  806e1b:	48 ba b3 76 80 00 00 	movabs $0x8076b3,%rdx
  806e22:	00 00 00 
  806e25:	89 c6                	mov    %eax,%esi
  806e27:	bf 40 00 00 00       	mov    $0x40,%edi
  806e2c:	48 b8 89 9b 81 00 00 	movabs $0x819b89,%rax
  806e33:	00 00 00 
  806e36:	ff d0                	callq  *%rax
  806e38:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  806e3c:	eb 78                	jmp    806eb6 <lwip_socket+0xc9>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  806e3e:	81 7d e4 88 00 00 00 	cmpl   $0x88,-0x1c(%rbp)
  806e45:	75 07                	jne    806e4e <lwip_socket+0x61>
  806e47:	b8 21 00 00 00       	mov    $0x21,%eax
  806e4c:	eb 05                	jmp    806e53 <lwip_socket+0x66>
  806e4e:	b8 20 00 00 00       	mov    $0x20,%eax
  806e53:	48 ba b3 76 80 00 00 	movabs $0x8076b3,%rdx
  806e5a:	00 00 00 
  806e5d:	be 00 00 00 00       	mov    $0x0,%esi
  806e62:	89 c7                	mov    %eax,%edi
  806e64:	48 b8 89 9b 81 00 00 	movabs $0x819b89,%rax
  806e6b:	00 00 00 
  806e6e:	ff d0                	callq  *%rax
  806e70:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  806e74:	eb 40                	jmp    806eb6 <lwip_socket+0xc9>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  806e76:	48 ba b3 76 80 00 00 	movabs $0x8076b3,%rdx
  806e7d:	00 00 00 
  806e80:	be 00 00 00 00       	mov    $0x0,%esi
  806e85:	bf 10 00 00 00       	mov    $0x10,%edi
  806e8a:	48 b8 89 9b 81 00 00 	movabs $0x819b89,%rax
  806e91:	00 00 00 
  806e94:	ff d0                	callq  *%rax
  806e96:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  806e9a:	eb 1a                	jmp    806eb6 <lwip_socket+0xc9>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  806e9c:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806ea3:	00 00 00 
  806ea6:	c7 00 16 00 00 00    	movl   $0x16,(%rax)
    return -1;
  806eac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806eb1:	e9 81 00 00 00       	jmpq   806f37 <lwip_socket+0x14a>
  }

  if (!conn) {
  806eb6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806ebb:	75 17                	jne    806ed4 <lwip_socket+0xe7>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  806ebd:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806ec4:	00 00 00 
  806ec7:	c7 00 69 00 00 00    	movl   $0x69,(%rax)
    return -1;
  806ecd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806ed2:	eb 63                	jmp    806f37 <lwip_socket+0x14a>
  }

  i = alloc_socket(conn);
  806ed4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806ed8:	48 89 c7             	mov    %rax,%rdi
  806edb:	48 b8 6a 5d 80 00 00 	movabs $0x805d6a,%rax
  806ee2:	00 00 00 
  806ee5:	ff d0                	callq  *%rax
  806ee7:	89 45 f4             	mov    %eax,-0xc(%rbp)

  if (i == -1) {
  806eea:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%rbp)
  806eee:	75 2a                	jne    806f1a <lwip_socket+0x12d>
    netconn_delete(conn);
  806ef0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806ef4:	48 89 c7             	mov    %rax,%rdi
  806ef7:	48 b8 2c 9d 81 00 00 	movabs $0x819d2c,%rax
  806efe:	00 00 00 
  806f01:	ff d0                	callq  *%rax
    set_errno(ENFILE);
  806f03:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806f0a:	00 00 00 
  806f0d:	c7 00 17 00 00 00    	movl   $0x17,(%rax)
    return -1;
  806f13:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806f18:	eb 1d                	jmp    806f37 <lwip_socket+0x14a>
  }
  conn->socket = i;
  806f1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806f1e:	8b 55 f4             	mov    -0xc(%rbp),%edx
  806f21:	89 50 20             	mov    %edx,0x20(%rax)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  806f24:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806f2b:	00 00 00 
  806f2e:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  return i;
  806f34:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  806f37:	c9                   	leaveq 
  806f38:	c3                   	retq   

0000000000806f39 <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  806f39:	55                   	push   %rbp
  806f3a:	48 89 e5             	mov    %rsp,%rbp
  806f3d:	48 83 ec 10          	sub    $0x10,%rsp
  806f41:	89 7d fc             	mov    %edi,-0x4(%rbp)
  806f44:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  806f48:	89 55 f8             	mov    %edx,-0x8(%rbp)
  return lwip_send(s, data, size, 0);
  806f4b:	8b 55 f8             	mov    -0x8(%rbp),%edx
  806f4e:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  806f52:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806f55:	b9 00 00 00 00       	mov    $0x0,%ecx
  806f5a:	89 c7                	mov    %eax,%edi
  806f5c:	48 b8 cd 6a 80 00 00 	movabs $0x806acd,%rax
  806f63:	00 00 00 
  806f66:	ff d0                	callq  *%rax
}
  806f68:	c9                   	leaveq 
  806f69:	c3                   	retq   

0000000000806f6a <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  806f6a:	55                   	push   %rbp
  806f6b:	48 89 e5             	mov    %rsp,%rbp
  806f6e:	48 83 ec 60          	sub    $0x60,%rsp
  806f72:	89 7d bc             	mov    %edi,-0x44(%rbp)
  806f75:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  806f79:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  806f7d:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
  int i, nready = 0;
  806f81:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  806f88:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  806f8c:	ba 04 00 00 00       	mov    $0x4,%edx
  806f91:	be 00 00 00 00       	mov    $0x0,%esi
  806f96:	48 89 c7             	mov    %rax,%rdi
  806f99:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  806fa0:	00 00 00 
  806fa3:	ff d0                	callq  *%rax
  FD_ZERO(&lwriteset);
  806fa5:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  806fa9:	ba 04 00 00 00       	mov    $0x4,%edx
  806fae:	be 00 00 00 00       	mov    $0x0,%esi
  806fb3:	48 89 c7             	mov    %rax,%rdi
  806fb6:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  806fbd:	00 00 00 
  806fc0:	ff d0                	callq  *%rax
  FD_ZERO(&lexceptset);
  806fc2:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  806fc6:	ba 04 00 00 00       	mov    $0x4,%edx
  806fcb:	be 00 00 00 00       	mov    $0x0,%esi
  806fd0:	48 89 c7             	mov    %rax,%rdi
  806fd3:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  806fda:	00 00 00 
  806fdd:	ff d0                	callq  *%rax
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  806fdf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  806fe6:	e9 33 01 00 00       	jmpq   80711e <lwip_selscan+0x1b4>
    if (FD_ISSET(i, readset)) {
  806feb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806fee:	8d 50 07             	lea    0x7(%rax),%edx
  806ff1:	85 c0                	test   %eax,%eax
  806ff3:	0f 48 c2             	cmovs  %edx,%eax
  806ff6:	c1 f8 03             	sar    $0x3,%eax
  806ff9:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  806ffd:	48 98                	cltq   
  806fff:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  807003:	0f b6 d0             	movzbl %al,%edx
  807006:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807009:	83 e0 07             	and    $0x7,%eax
  80700c:	89 c1                	mov    %eax,%ecx
  80700e:	d3 fa                	sar    %cl,%edx
  807010:	89 d0                	mov    %edx,%eax
  807012:	83 e0 01             	and    $0x1,%eax
  807015:	85 c0                	test   %eax,%eax
  807017:	74 70                	je     807089 <lwip_selscan+0x11f>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  807019:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80701c:	89 c7                	mov    %eax,%edi
  80701e:	48 b8 f6 5c 80 00 00 	movabs $0x805cf6,%rax
  807025:	00 00 00 
  807028:	ff d0                	callq  *%rax
  80702a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  80702e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  807033:	74 54                	je     807089 <lwip_selscan+0x11f>
  807035:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807039:	48 8b 40 08          	mov    0x8(%rax),%rax
  80703d:	48 85 c0             	test   %rax,%rax
  807040:	75 0d                	jne    80704f <lwip_selscan+0xe5>
  807042:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807046:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80704a:	66 85 c0             	test   %ax,%ax
  80704d:	74 3a                	je     807089 <lwip_selscan+0x11f>
        FD_SET(i, &lreadset);
  80704f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807052:	8d 50 07             	lea    0x7(%rax),%edx
  807055:	85 c0                	test   %eax,%eax
  807057:	0f 48 c2             	cmovs  %edx,%eax
  80705a:	c1 f8 03             	sar    $0x3,%eax
  80705d:	89 c2                	mov    %eax,%edx
  80705f:	48 63 c2             	movslq %edx,%rax
  807062:	0f b6 44 05 e0       	movzbl -0x20(%rbp,%rax,1),%eax
  807067:	89 c7                	mov    %eax,%edi
  807069:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80706c:	83 e0 07             	and    $0x7,%eax
  80706f:	be 01 00 00 00       	mov    $0x1,%esi
  807074:	89 c1                	mov    %eax,%ecx
  807076:	d3 e6                	shl    %cl,%esi
  807078:	89 f0                	mov    %esi,%eax
  80707a:	09 f8                	or     %edi,%eax
  80707c:	89 c1                	mov    %eax,%ecx
  80707e:	48 63 c2             	movslq %edx,%rax
  807081:	88 4c 05 e0          	mov    %cl,-0x20(%rbp,%rax,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  807085:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  807089:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80708c:	8d 50 07             	lea    0x7(%rax),%edx
  80708f:	85 c0                	test   %eax,%eax
  807091:	0f 48 c2             	cmovs  %edx,%eax
  807094:	c1 f8 03             	sar    $0x3,%eax
  807097:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80709b:	48 98                	cltq   
  80709d:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8070a1:	0f b6 d0             	movzbl %al,%edx
  8070a4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8070a7:	83 e0 07             	and    $0x7,%eax
  8070aa:	89 c1                	mov    %eax,%ecx
  8070ac:	d3 fa                	sar    %cl,%edx
  8070ae:	89 d0                	mov    %edx,%eax
  8070b0:	83 e0 01             	and    $0x1,%eax
  8070b3:	85 c0                	test   %eax,%eax
  8070b5:	74 63                	je     80711a <lwip_selscan+0x1b0>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  8070b7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8070ba:	89 c7                	mov    %eax,%edi
  8070bc:	48 b8 f6 5c 80 00 00 	movabs $0x805cf6,%rax
  8070c3:	00 00 00 
  8070c6:	ff d0                	callq  *%rax
  8070c8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      if (p_sock && p_sock->sendevent) {
  8070cc:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8070d1:	74 47                	je     80711a <lwip_selscan+0x1b0>
  8070d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8070d7:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  8070db:	66 85 c0             	test   %ax,%ax
  8070de:	74 3a                	je     80711a <lwip_selscan+0x1b0>
        FD_SET(i, &lwriteset);
  8070e0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8070e3:	8d 50 07             	lea    0x7(%rax),%edx
  8070e6:	85 c0                	test   %eax,%eax
  8070e8:	0f 48 c2             	cmovs  %edx,%eax
  8070eb:	c1 f8 03             	sar    $0x3,%eax
  8070ee:	89 c2                	mov    %eax,%edx
  8070f0:	48 63 c2             	movslq %edx,%rax
  8070f3:	0f b6 44 05 d0       	movzbl -0x30(%rbp,%rax,1),%eax
  8070f8:	89 c7                	mov    %eax,%edi
  8070fa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8070fd:	83 e0 07             	and    $0x7,%eax
  807100:	be 01 00 00 00       	mov    $0x1,%esi
  807105:	89 c1                	mov    %eax,%ecx
  807107:	d3 e6                	shl    %cl,%esi
  807109:	89 f0                	mov    %esi,%eax
  80710b:	09 f8                	or     %edi,%eax
  80710d:	89 c1                	mov    %eax,%ecx
  80710f:	48 63 c2             	movslq %edx,%rax
  807112:	88 4c 05 d0          	mov    %cl,-0x30(%rbp,%rax,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  807116:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  80711a:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80711e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807121:	3b 45 bc             	cmp    -0x44(%rbp),%eax
  807124:	0f 8c c1 fe ff ff    	jl     806feb <lwip_selscan+0x81>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  80712a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80712e:	8b 55 e0             	mov    -0x20(%rbp),%edx
  807131:	89 10                	mov    %edx,(%rax)
  *writeset = lwriteset;
  807133:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  807137:	8b 55 d0             	mov    -0x30(%rbp),%edx
  80713a:	89 10                	mov    %edx,(%rax)
  FD_ZERO(exceptset);
  80713c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807140:	ba 04 00 00 00       	mov    $0x4,%edx
  807145:	be 00 00 00 00       	mov    $0x0,%esi
  80714a:	48 89 c7             	mov    %rax,%rdi
  80714d:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  807154:	00 00 00 
  807157:	ff d0                	callq  *%rax
  
  return nready;
  807159:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  80715c:	c9                   	leaveq 
  80715d:	c3                   	retq   

000000000080715e <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  80715e:	55                   	push   %rbp
  80715f:	48 89 e5             	mov    %rsp,%rbp
  807162:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  807169:	89 7d 8c             	mov    %edi,-0x74(%rbp)
  80716c:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  807170:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  807177:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  80717e:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  807185:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  80718c:	00 
  select_cb.readset = readset;
  80718d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  807191:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  select_cb.writeset = writeset;
  807195:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80719c:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  select_cb.exceptset = exceptset;
  8071a0:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8071a7:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  select_cb.sem_signalled = 0;
  8071ab:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  8071b2:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8071b9:	00 00 00 
  8071bc:	8b 00                	mov    (%rax),%eax
  8071be:	89 c7                	mov    %eax,%edi
  8071c0:	48 b8 fc e6 80 00 00 	movabs $0x80e6fc,%rax
  8071c7:	00 00 00 
  8071ca:	ff d0                	callq  *%rax

  if (readset)
  8071cc:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  8071d1:	74 0b                	je     8071de <lwip_select+0x80>
    lreadset = *readset;
  8071d3:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8071d7:	8b 00                	mov    (%rax),%eax
  8071d9:	89 45 e0             	mov    %eax,-0x20(%rbp)
  8071dc:	eb 1d                	jmp    8071fb <lwip_select+0x9d>
  else
    FD_ZERO(&lreadset);
  8071de:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8071e2:	ba 04 00 00 00       	mov    $0x4,%edx
  8071e7:	be 00 00 00 00       	mov    $0x0,%esi
  8071ec:	48 89 c7             	mov    %rax,%rdi
  8071ef:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  8071f6:	00 00 00 
  8071f9:	ff d0                	callq  *%rax
  if (writeset)
  8071fb:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  807202:	00 
  807203:	74 0e                	je     807213 <lwip_select+0xb5>
    lwriteset = *writeset;
  807205:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80720c:	8b 00                	mov    (%rax),%eax
  80720e:	89 45 d0             	mov    %eax,-0x30(%rbp)
  807211:	eb 1d                	jmp    807230 <lwip_select+0xd2>
  else
    FD_ZERO(&lwriteset);
  807213:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  807217:	ba 04 00 00 00       	mov    $0x4,%edx
  80721c:	be 00 00 00 00       	mov    $0x0,%esi
  807221:	48 89 c7             	mov    %rax,%rdi
  807224:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  80722b:	00 00 00 
  80722e:	ff d0                	callq  *%rax
  if (exceptset)
  807230:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  807237:	00 
  807238:	74 0e                	je     807248 <lwip_select+0xea>
    lexceptset = *exceptset;
  80723a:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  807241:	8b 00                	mov    (%rax),%eax
  807243:	89 45 c0             	mov    %eax,-0x40(%rbp)
  807246:	eb 1d                	jmp    807265 <lwip_select+0x107>
  else
    FD_ZERO(&lexceptset);
  807248:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  80724c:	ba 04 00 00 00       	mov    $0x4,%edx
  807251:	be 00 00 00 00       	mov    $0x0,%esi
  807256:	48 89 c7             	mov    %rax,%rdi
  807259:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  807260:	00 00 00 
  807263:	ff d0                	callq  *%rax

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  807265:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  807269:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80726d:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  807271:	8b 45 8c             	mov    -0x74(%rbp),%eax
  807274:	89 c7                	mov    %eax,%edi
  807276:	48 b8 6a 6f 80 00 00 	movabs $0x806f6a,%rax
  80727d:	00 00 00 
  807280:	ff d0                	callq  *%rax
  807282:	89 45 fc             	mov    %eax,-0x4(%rbp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  807285:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  807289:	0f 85 b9 03 00 00    	jne    807648 <lwip_select+0x4ea>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  80728f:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  807296:	00 
  807297:	0f 84 d3 00 00 00    	je     807370 <lwip_select+0x212>
  80729d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8072a4:	48 8b 00             	mov    (%rax),%rax
  8072a7:	48 85 c0             	test   %rax,%rax
  8072aa:	0f 85 c0 00 00 00    	jne    807370 <lwip_select+0x212>
  8072b0:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8072b7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8072bb:	48 85 c0             	test   %rax,%rax
  8072be:	0f 85 ac 00 00 00    	jne    807370 <lwip_select+0x212>
      sys_sem_signal(selectsem);
  8072c4:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8072cb:	00 00 00 
  8072ce:	8b 00                	mov    (%rax),%eax
  8072d0:	89 c7                	mov    %eax,%edi
  8072d2:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  8072d9:	00 00 00 
  8072dc:	ff d0                	callq  *%rax
      if (readset)
  8072de:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  8072e3:	74 1d                	je     807302 <lwip_select+0x1a4>
        FD_ZERO(readset);
  8072e5:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8072e9:	ba 04 00 00 00       	mov    $0x4,%edx
  8072ee:	be 00 00 00 00       	mov    $0x0,%esi
  8072f3:	48 89 c7             	mov    %rax,%rdi
  8072f6:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  8072fd:	00 00 00 
  807300:	ff d0                	callq  *%rax
      if (writeset)
  807302:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  807309:	00 
  80730a:	74 20                	je     80732c <lwip_select+0x1ce>
        FD_ZERO(writeset);
  80730c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  807313:	ba 04 00 00 00       	mov    $0x4,%edx
  807318:	be 00 00 00 00       	mov    $0x0,%esi
  80731d:	48 89 c7             	mov    %rax,%rdi
  807320:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  807327:	00 00 00 
  80732a:	ff d0                	callq  *%rax
      if (exceptset)
  80732c:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  807333:	00 
  807334:	74 20                	je     807356 <lwip_select+0x1f8>
        FD_ZERO(exceptset);
  807336:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80733d:	ba 04 00 00 00       	mov    $0x4,%edx
  807342:	be 00 00 00 00       	mov    $0x0,%esi
  807347:	48 89 c7             	mov    %rax,%rdi
  80734a:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  807351:	00 00 00 
  807354:	ff d0                	callq  *%rax
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  807356:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80735d:	00 00 00 
  807360:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
      return 0;
  807366:	b8 00 00 00 00       	mov    $0x0,%eax
  80736b:	e9 41 03 00 00       	jmpq   8076b1 <lwip_select+0x553>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  807370:	bf 00 00 00 00       	mov    $0x0,%edi
  807375:	48 b8 e1 7e 81 00 00 	movabs $0x817ee1,%rax
  80737c:	00 00 00 
  80737f:	ff d0                	callq  *%rax
  807381:	89 45 b4             	mov    %eax,-0x4c(%rbp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  807384:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  80738b:	00 00 00 
  80738e:	48 8b 00             	mov    (%rax),%rax
  807391:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    select_cb_list = &select_cb;
  807395:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  80739c:	00 00 00 
  80739f:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  8073a3:	48 89 10             	mov    %rdx,(%rax)
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  8073a6:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8073ad:	00 00 00 
  8073b0:	8b 00                	mov    (%rax),%eax
  8073b2:	89 c7                	mov    %eax,%edi
  8073b4:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  8073bb:	00 00 00 
  8073be:	ff d0                	callq  *%rax
    
    /* Now just wait to be woken */
    if (timeout == 0)
  8073c0:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  8073c7:	00 
  8073c8:	75 09                	jne    8073d3 <lwip_select+0x275>
      /* Wait forever */
      msectimeout = 0;
  8073ca:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8073d1:	eb 55                	jmp    807428 <lwip_select+0x2ca>
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  8073d3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8073da:	48 8b 00             	mov    (%rax),%rax
  8073dd:	69 f0 e8 03 00 00    	imul   $0x3e8,%eax,%esi
  8073e3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8073ea:	48 8b 40 08          	mov    0x8(%rax),%rax
  8073ee:	48 8d 88 f4 01 00 00 	lea    0x1f4(%rax),%rcx
  8073f5:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  8073fc:	9b c4 20 
  8073ff:	48 89 c8             	mov    %rcx,%rax
  807402:	48 f7 ea             	imul   %rdx
  807405:	48 c1 fa 07          	sar    $0x7,%rdx
  807409:	48 89 c8             	mov    %rcx,%rax
  80740c:	48 c1 f8 3f          	sar    $0x3f,%rax
  807410:	48 29 c2             	sub    %rax,%rdx
  807413:	48 89 d0             	mov    %rdx,%rax
  807416:	01 f0                	add    %esi,%eax
  807418:	89 45 f8             	mov    %eax,-0x8(%rbp)
      if(msectimeout == 0)
  80741b:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80741f:	75 07                	jne    807428 <lwip_select+0x2ca>
        msectimeout = 1;
  807421:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%rbp)
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  807428:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80742b:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80742e:	89 d6                	mov    %edx,%esi
  807430:	89 c7                	mov    %eax,%edi
  807432:	48 b8 73 eb 80 00 00 	movabs $0x80eb73,%rax
  807439:	00 00 00 
  80743c:	ff d0                	callq  *%rax
  80743e:	89 45 ec             	mov    %eax,-0x14(%rbp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  807441:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807448:	00 00 00 
  80744b:	8b 00                	mov    (%rax),%eax
  80744d:	89 c7                	mov    %eax,%edi
  80744f:	48 b8 fc e6 80 00 00 	movabs $0x80e6fc,%rax
  807456:	00 00 00 
  807459:	ff d0                	callq  *%rax
    if (select_cb_list == &select_cb)
  80745b:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  807462:	00 00 00 
  807465:	48 8b 10             	mov    (%rax),%rdx
  807468:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  80746c:	48 39 c2             	cmp    %rax,%rdx
  80746f:	75 13                	jne    807484 <lwip_select+0x326>
      select_cb_list = select_cb.next;
  807471:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  807475:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  80747c:	00 00 00 
  80747f:	48 89 10             	mov    %rdx,(%rax)
  807482:	eb 42                	jmp    8074c6 <lwip_select+0x368>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  807484:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  80748b:	00 00 00 
  80748e:	48 8b 00             	mov    (%rax),%rax
  807491:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  807495:	eb 28                	jmp    8074bf <lwip_select+0x361>
        if (p_selcb->next == &select_cb) {
  807497:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80749b:	48 8b 10             	mov    (%rax),%rdx
  80749e:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8074a2:	48 39 c2             	cmp    %rax,%rdx
  8074a5:	75 0d                	jne    8074b4 <lwip_select+0x356>
          p_selcb->next = select_cb.next;
  8074a7:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8074ab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8074af:	48 89 10             	mov    %rdx,(%rax)
          break;
  8074b2:	eb 12                	jmp    8074c6 <lwip_select+0x368>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  8074b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8074b8:	48 8b 00             	mov    (%rax),%rax
  8074bb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8074bf:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8074c4:	75 d1                	jne    807497 <lwip_select+0x339>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  8074c6:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8074cd:	00 00 00 
  8074d0:	8b 00                	mov    (%rax),%eax
  8074d2:	89 c7                	mov    %eax,%edi
  8074d4:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  8074db:	00 00 00 
  8074de:	ff d0                	callq  *%rax
    
    sys_sem_free(select_cb.sem);
  8074e0:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8074e3:	89 c7                	mov    %eax,%edi
  8074e5:	48 b8 df 7f 81 00 00 	movabs $0x817fdf,%rax
  8074ec:	00 00 00 
  8074ef:	ff d0                	callq  *%rax
    if (i == 0)  {
  8074f1:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8074f5:	0f 85 92 00 00 00    	jne    80758d <lwip_select+0x42f>
      /* Timeout */
      if (readset)
  8074fb:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  807500:	74 1d                	je     80751f <lwip_select+0x3c1>
        FD_ZERO(readset);
  807502:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  807506:	ba 04 00 00 00       	mov    $0x4,%edx
  80750b:	be 00 00 00 00       	mov    $0x0,%esi
  807510:	48 89 c7             	mov    %rax,%rdi
  807513:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  80751a:	00 00 00 
  80751d:	ff d0                	callq  *%rax
      if (writeset)
  80751f:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  807526:	00 
  807527:	74 20                	je     807549 <lwip_select+0x3eb>
        FD_ZERO(writeset);
  807529:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  807530:	ba 04 00 00 00       	mov    $0x4,%edx
  807535:	be 00 00 00 00       	mov    $0x0,%esi
  80753a:	48 89 c7             	mov    %rax,%rdi
  80753d:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  807544:	00 00 00 
  807547:	ff d0                	callq  *%rax
      if (exceptset)
  807549:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  807550:	00 
  807551:	74 20                	je     807573 <lwip_select+0x415>
        FD_ZERO(exceptset);
  807553:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80755a:	ba 04 00 00 00       	mov    $0x4,%edx
  80755f:	be 00 00 00 00       	mov    $0x0,%esi
  807564:	48 89 c7             	mov    %rax,%rdi
  807567:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  80756e:	00 00 00 
  807571:	ff d0                	callq  *%rax
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  807573:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80757a:	00 00 00 
  80757d:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
      return 0;
  807583:	b8 00 00 00 00       	mov    $0x0,%eax
  807588:	e9 24 01 00 00       	jmpq   8076b1 <lwip_select+0x553>
    }
    
    if (readset)
  80758d:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  807592:	74 0b                	je     80759f <lwip_select+0x441>
      lreadset = *readset;
  807594:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  807598:	8b 00                	mov    (%rax),%eax
  80759a:	89 45 e0             	mov    %eax,-0x20(%rbp)
  80759d:	eb 1d                	jmp    8075bc <lwip_select+0x45e>
    else
      FD_ZERO(&lreadset);
  80759f:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8075a3:	ba 04 00 00 00       	mov    $0x4,%edx
  8075a8:	be 00 00 00 00       	mov    $0x0,%esi
  8075ad:	48 89 c7             	mov    %rax,%rdi
  8075b0:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  8075b7:	00 00 00 
  8075ba:	ff d0                	callq  *%rax
    if (writeset)
  8075bc:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  8075c3:	00 
  8075c4:	74 0e                	je     8075d4 <lwip_select+0x476>
      lwriteset = *writeset;
  8075c6:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8075cd:	8b 00                	mov    (%rax),%eax
  8075cf:	89 45 d0             	mov    %eax,-0x30(%rbp)
  8075d2:	eb 1d                	jmp    8075f1 <lwip_select+0x493>
    else
      FD_ZERO(&lwriteset);
  8075d4:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8075d8:	ba 04 00 00 00       	mov    $0x4,%edx
  8075dd:	be 00 00 00 00       	mov    $0x0,%esi
  8075e2:	48 89 c7             	mov    %rax,%rdi
  8075e5:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  8075ec:	00 00 00 
  8075ef:	ff d0                	callq  *%rax
    if (exceptset)
  8075f1:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  8075f8:	00 
  8075f9:	74 0e                	je     807609 <lwip_select+0x4ab>
      lexceptset = *exceptset;
  8075fb:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  807602:	8b 00                	mov    (%rax),%eax
  807604:	89 45 c0             	mov    %eax,-0x40(%rbp)
  807607:	eb 1d                	jmp    807626 <lwip_select+0x4c8>
    else
      FD_ZERO(&lexceptset);
  807609:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  80760d:	ba 04 00 00 00       	mov    $0x4,%edx
  807612:	be 00 00 00 00       	mov    $0x0,%esi
  807617:	48 89 c7             	mov    %rax,%rdi
  80761a:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  807621:	00 00 00 
  807624:	ff d0                	callq  *%rax
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  807626:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  80762a:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80762e:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  807632:	8b 45 8c             	mov    -0x74(%rbp),%eax
  807635:	89 c7                	mov    %eax,%edi
  807637:	48 b8 6a 6f 80 00 00 	movabs $0x806f6a,%rax
  80763e:	00 00 00 
  807641:	ff d0                	callq  *%rax
  807643:	89 45 fc             	mov    %eax,-0x4(%rbp)
  807646:	eb 1a                	jmp    807662 <lwip_select+0x504>
  } else
    sys_sem_signal(selectsem);
  807648:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  80764f:	00 00 00 
  807652:	8b 00                	mov    (%rax),%eax
  807654:	89 c7                	mov    %eax,%edi
  807656:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  80765d:	00 00 00 
  807660:	ff d0                	callq  *%rax
  
  if (readset)
  807662:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  807667:	74 09                	je     807672 <lwip_select+0x514>
    *readset = lreadset;
  807669:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80766d:	8b 55 e0             	mov    -0x20(%rbp),%edx
  807670:	89 10                	mov    %edx,(%rax)
  if (writeset)
  807672:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  807679:	00 
  80767a:	74 0c                	je     807688 <lwip_select+0x52a>
    *writeset = lwriteset;
  80767c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  807683:	8b 55 d0             	mov    -0x30(%rbp),%edx
  807686:	89 10                	mov    %edx,(%rax)
  if (exceptset)
  807688:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  80768f:	00 
  807690:	74 0c                	je     80769e <lwip_select+0x540>
    *exceptset = lexceptset;
  807692:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  807699:	8b 55 c0             	mov    -0x40(%rbp),%edx
  80769c:	89 10                	mov    %edx,(%rax)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  80769e:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8076a5:	00 00 00 
  8076a8:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
  return nready;
  8076ae:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8076b1:	c9                   	leaveq 
  8076b2:	c3                   	retq   

00000000008076b3 <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  8076b3:	55                   	push   %rbp
  8076b4:	48 89 e5             	mov    %rsp,%rbp
  8076b7:	48 83 ec 30          	sub    $0x30,%rsp
  8076bb:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8076bf:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  8076c2:	89 d0                	mov    %edx,%eax
  8076c4:	66 89 45 d0          	mov    %ax,-0x30(%rbp)
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  8076c8:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8076cd:	0f 84 b3 02 00 00    	je     807986 <event_callback+0x2d3>
    s = conn->socket;
  8076d3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8076d7:	8b 40 20             	mov    0x20(%rax),%eax
  8076da:	89 45 f4             	mov    %eax,-0xc(%rbp)
    if (s < 0) {
  8076dd:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8076e1:	79 75                	jns    807758 <event_callback+0xa5>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  8076e3:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  8076ea:	00 00 00 
  8076ed:	8b 00                	mov    (%rax),%eax
  8076ef:	89 c7                	mov    %eax,%edi
  8076f1:	48 b8 fc e6 80 00 00 	movabs $0x80e6fc,%rax
  8076f8:	00 00 00 
  8076fb:	ff d0                	callq  *%rax
      if (conn->socket < 0) {
  8076fd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807701:	8b 40 20             	mov    0x20(%rax),%eax
  807704:	85 c0                	test   %eax,%eax
  807706:	79 36                	jns    80773e <event_callback+0x8b>
        if (evt == NETCONN_EVT_RCVPLUS) {
  807708:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  80770c:	75 11                	jne    80771f <event_callback+0x6c>
          conn->socket--;
  80770e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807712:	8b 40 20             	mov    0x20(%rax),%eax
  807715:	8d 50 ff             	lea    -0x1(%rax),%edx
  807718:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80771c:	89 50 20             	mov    %edx,0x20(%rax)
        }
        sys_sem_signal(socksem);
  80771f:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  807726:	00 00 00 
  807729:	8b 00                	mov    (%rax),%eax
  80772b:	89 c7                	mov    %eax,%edi
  80772d:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  807734:	00 00 00 
  807737:	ff d0                	callq  *%rax
        return;
  807739:	e9 4c 02 00 00       	jmpq   80798a <event_callback+0x2d7>
      }
      sys_sem_signal(socksem);
  80773e:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  807745:	00 00 00 
  807748:	8b 00                	mov    (%rax),%eax
  80774a:	89 c7                	mov    %eax,%edi
  80774c:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  807753:	00 00 00 
  807756:	ff d0                	callq  *%rax
    }

    sock = get_socket(s);
  807758:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80775b:	89 c7                	mov    %eax,%edi
  80775d:	48 b8 f6 5c 80 00 00 	movabs $0x805cf6,%rax
  807764:	00 00 00 
  807767:	ff d0                	callq  *%rax
  807769:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (!sock) {
  80776d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  807772:	0f 84 11 02 00 00    	je     807989 <event_callback+0x2d6>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  807778:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  80777f:	00 00 00 
  807782:	8b 00                	mov    (%rax),%eax
  807784:	89 c7                	mov    %eax,%edi
  807786:	48 b8 fc e6 80 00 00 	movabs $0x80e6fc,%rax
  80778d:	00 00 00 
  807790:	ff d0                	callq  *%rax
  /* Set event as required */
  switch (evt) {
  807792:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  807795:	83 f8 01             	cmp    $0x1,%eax
  807798:	74 26                	je     8077c0 <event_callback+0x10d>
  80779a:	83 f8 01             	cmp    $0x1,%eax
  80779d:	72 0c                	jb     8077ab <event_callback+0xf8>
  80779f:	83 f8 02             	cmp    $0x2,%eax
  8077a2:	74 31                	je     8077d5 <event_callback+0x122>
  8077a4:	83 f8 03             	cmp    $0x3,%eax
  8077a7:	74 38                	je     8077e1 <event_callback+0x12e>
  8077a9:	eb 42                	jmp    8077ed <event_callback+0x13a>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  8077ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8077af:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8077b3:	8d 50 01             	lea    0x1(%rax),%edx
  8077b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8077ba:	66 89 50 12          	mov    %dx,0x12(%rax)
      break;
  8077be:	eb 57                	jmp    807817 <event_callback+0x164>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  8077c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8077c4:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8077c8:	8d 50 ff             	lea    -0x1(%rax),%edx
  8077cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8077cf:	66 89 50 12          	mov    %dx,0x12(%rax)
      break;
  8077d3:	eb 42                	jmp    807817 <event_callback+0x164>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  8077d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8077d9:	66 c7 40 14 01 00    	movw   $0x1,0x14(%rax)
      break;
  8077df:	eb 36                	jmp    807817 <event_callback+0x164>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  8077e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8077e5:	66 c7 40 14 00 00    	movw   $0x0,0x14(%rax)
      break;
  8077eb:	eb 2a                	jmp    807817 <event_callback+0x164>
    default:
      LWIP_ASSERT("unknown event", 0);
  8077ed:	48 ba 39 19 82 00 00 	movabs $0x821939,%rdx
  8077f4:	00 00 00 
  8077f7:	be 18 04 00 00       	mov    $0x418,%esi
  8077fc:	48 bf 91 18 82 00 00 	movabs $0x821891,%rdi
  807803:	00 00 00 
  807806:	b8 00 00 00 00       	mov    $0x0,%eax
  80780b:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  807812:	00 00 00 
  807815:	ff d1                	callq  *%rcx
      break;
  }
  sys_sem_signal(selectsem);
  807817:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  80781e:	00 00 00 
  807821:	8b 00                	mov    (%rax),%eax
  807823:	89 c7                	mov    %eax,%edi
  807825:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  80782c:	00 00 00 
  80782f:	ff d0                	callq  *%rax
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  807831:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807838:	00 00 00 
  80783b:	8b 00                	mov    (%rax),%eax
  80783d:	89 c7                	mov    %eax,%edi
  80783f:	48 b8 fc e6 80 00 00 	movabs $0x80e6fc,%rax
  807846:	00 00 00 
  807849:	ff d0                	callq  *%rax
    for (scb = select_cb_list; scb; scb = scb->next) {
  80784b:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  807852:	00 00 00 
  807855:	48 8b 00             	mov    (%rax),%rax
  807858:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80785c:	e9 b2 00 00 00       	jmpq   807913 <event_callback+0x260>
      if (scb->sem_signalled == 0) {
  807861:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807865:	8b 40 20             	mov    0x20(%rax),%eax
  807868:	85 c0                	test   %eax,%eax
  80786a:	0f 85 98 00 00 00    	jne    807908 <event_callback+0x255>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  807870:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807874:	48 8b 40 08          	mov    0x8(%rax),%rax
  807878:	48 85 c0             	test   %rax,%rax
  80787b:	74 3f                	je     8078bc <event_callback+0x209>
  80787d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807881:	48 8b 50 08          	mov    0x8(%rax),%rdx
  807885:	8b 45 f4             	mov    -0xc(%rbp),%eax
  807888:	8d 48 07             	lea    0x7(%rax),%ecx
  80788b:	85 c0                	test   %eax,%eax
  80788d:	0f 48 c1             	cmovs  %ecx,%eax
  807890:	c1 f8 03             	sar    $0x3,%eax
  807893:	48 98                	cltq   
  807895:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  807899:	0f b6 d0             	movzbl %al,%edx
  80789c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80789f:	83 e0 07             	and    $0x7,%eax
  8078a2:	89 c1                	mov    %eax,%ecx
  8078a4:	d3 fa                	sar    %cl,%edx
  8078a6:	89 d0                	mov    %edx,%eax
  8078a8:	83 e0 01             	and    $0x1,%eax
  8078ab:	85 c0                	test   %eax,%eax
  8078ad:	74 0d                	je     8078bc <event_callback+0x209>
          if (sock->rcvevent)
  8078af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8078b3:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8078b7:	66 85 c0             	test   %ax,%ax
  8078ba:	75 64                	jne    807920 <event_callback+0x26d>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  8078bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8078c0:	48 8b 40 10          	mov    0x10(%rax),%rax
  8078c4:	48 85 c0             	test   %rax,%rax
  8078c7:	74 3f                	je     807908 <event_callback+0x255>
  8078c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8078cd:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8078d1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8078d4:	8d 48 07             	lea    0x7(%rax),%ecx
  8078d7:	85 c0                	test   %eax,%eax
  8078d9:	0f 48 c1             	cmovs  %ecx,%eax
  8078dc:	c1 f8 03             	sar    $0x3,%eax
  8078df:	48 98                	cltq   
  8078e1:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8078e5:	0f b6 d0             	movzbl %al,%edx
  8078e8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8078eb:	83 e0 07             	and    $0x7,%eax
  8078ee:	89 c1                	mov    %eax,%ecx
  8078f0:	d3 fa                	sar    %cl,%edx
  8078f2:	89 d0                	mov    %edx,%eax
  8078f4:	83 e0 01             	and    $0x1,%eax
  8078f7:	85 c0                	test   %eax,%eax
  8078f9:	74 0d                	je     807908 <event_callback+0x255>
          if (sock->sendevent)
  8078fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8078ff:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  807903:	66 85 c0             	test   %ax,%ax
  807906:	75 1b                	jne    807923 <event_callback+0x270>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  807908:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80790c:	48 8b 00             	mov    (%rax),%rax
  80790f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  807913:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  807918:	0f 85 43 ff ff ff    	jne    807861 <event_callback+0x1ae>
  80791e:	eb 04                	jmp    807924 <event_callback+0x271>
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
          if (sock->rcvevent)
            break;
  807920:	90                   	nop
  807921:	eb 01                	jmp    807924 <event_callback+0x271>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
          if (sock->sendevent)
            break;
  807923:	90                   	nop
      }
    }
    if (scb) {
  807924:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  807929:	74 3f                	je     80796a <event_callback+0x2b7>
      scb->sem_signalled = 1;
  80792b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80792f:	c7 40 20 01 00 00 00 	movl   $0x1,0x20(%rax)
      sys_sem_signal(selectsem);
  807936:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  80793d:	00 00 00 
  807940:	8b 00                	mov    (%rax),%eax
  807942:	89 c7                	mov    %eax,%edi
  807944:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  80794b:	00 00 00 
  80794e:	ff d0                	callq  *%rax
      sys_sem_signal(scb->sem);
  807950:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807954:	8b 40 24             	mov    0x24(%rax),%eax
  807957:	89 c7                	mov    %eax,%edi
  807959:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  807960:	00 00 00 
  807963:	ff d0                	callq  *%rax
  807965:	e9 c7 fe ff ff       	jmpq   807831 <event_callback+0x17e>
    } else {
      sys_sem_signal(selectsem);
  80796a:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807971:	00 00 00 
  807974:	8b 00                	mov    (%rax),%eax
  807976:	89 c7                	mov    %eax,%edi
  807978:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  80797f:	00 00 00 
  807982:	ff d0                	callq  *%rax
      break;
  807984:	eb 04                	jmp    80798a <event_callback+0x2d7>
    sock = get_socket(s);
    if (!sock) {
      return;
    }
  } else {
    return;
  807986:	90                   	nop
  807987:	eb 01                	jmp    80798a <event_callback+0x2d7>
      sys_sem_signal(socksem);
    }

    sock = get_socket(s);
    if (!sock) {
      return;
  807989:	90                   	nop
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
}
  80798a:	c9                   	leaveq 
  80798b:	c3                   	retq   

000000000080798c <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  80798c:	55                   	push   %rbp
  80798d:	48 89 e5             	mov    %rsp,%rbp
  807990:	48 83 ec 10          	sub    $0x10,%rsp
  807994:	89 7d fc             	mov    %edi,-0x4(%rbp)
  807997:	89 75 f8             	mov    %esi,-0x8(%rbp)
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  80799a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80799d:	89 c7                	mov    %eax,%edi
  80799f:	48 b8 50 63 80 00 00 	movabs $0x806350,%rax
  8079a6:	00 00 00 
  8079a9:	ff d0                	callq  *%rax
}
  8079ab:	c9                   	leaveq 
  8079ac:	c3                   	retq   

00000000008079ad <lwip_getaddrname>:

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  8079ad:	55                   	push   %rbp
  8079ae:	48 89 e5             	mov    %rsp,%rbp
  8079b1:	48 83 ec 50          	sub    $0x50,%rsp
  8079b5:	89 7d cc             	mov    %edi,-0x34(%rbp)
  8079b8:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8079bc:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8079c0:	89 c8                	mov    %ecx,%eax
  8079c2:	88 45 c8             	mov    %al,-0x38(%rbp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  8079c5:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8079c8:	89 c7                	mov    %eax,%edi
  8079ca:	48 b8 f6 5c 80 00 00 	movabs $0x805cf6,%rax
  8079d1:	00 00 00 
  8079d4:	ff d0                	callq  *%rax
  8079d6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  8079da:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8079df:	75 0a                	jne    8079eb <lwip_getaddrname+0x3e>
    return -1;
  8079e1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8079e6:	e9 c9 00 00 00       	jmpq   807ab4 <lwip_getaddrname+0x107>

  memset(&sin, 0, sizeof(sin));
  8079eb:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8079ef:	ba 10 00 00 00       	mov    $0x10,%edx
  8079f4:	be 00 00 00 00       	mov    $0x0,%esi
  8079f9:	48 89 c7             	mov    %rax,%rdi
  8079fc:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  807a03:	00 00 00 
  807a06:	ff d0                	callq  *%rax
  sin.sin_len = sizeof(sin);
  807a08:	c6 45 e0 10          	movb   $0x10,-0x20(%rbp)
  sin.sin_family = AF_INET;
  807a0c:	c6 45 e1 02          	movb   $0x2,-0x1f(%rbp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  807a10:	0f b6 55 c8          	movzbl -0x38(%rbp),%edx
  807a14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807a18:	48 8b 00             	mov    (%rax),%rax
  807a1b:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  807a1f:	48 8d 79 02          	lea    0x2(%rcx),%rdi
  807a23:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  807a27:	89 d1                	mov    %edx,%ecx
  807a29:	48 89 fa             	mov    %rdi,%rdx
  807a2c:	48 89 c7             	mov    %rax,%rdi
  807a2f:	48 b8 da 9d 81 00 00 	movabs $0x819dda,%rax
  807a36:	00 00 00 
  807a39:	ff d0                	callq  *%rax

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  807a3b:	0f b7 45 e2          	movzwl -0x1e(%rbp),%eax
  807a3f:	0f b7 c0             	movzwl %ax,%eax
  807a42:	89 c7                	mov    %eax,%edi
  807a44:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  807a4b:	00 00 00 
  807a4e:	ff d0                	callq  *%rax
  807a50:	66 89 45 e2          	mov    %ax,-0x1e(%rbp)
  sin.sin_addr.s_addr = naddr.addr;
  807a54:	8b 45 d0             	mov    -0x30(%rbp),%eax
  807a57:	89 45 e4             	mov    %eax,-0x1c(%rbp)

  if (*namelen > sizeof(sin))
  807a5a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  807a5e:	8b 00                	mov    (%rax),%eax
  807a60:	83 f8 10             	cmp    $0x10,%eax
  807a63:	76 0a                	jbe    807a6f <lwip_getaddrname+0xc2>
    *namelen = sizeof(sin);
  807a65:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  807a69:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

  SMEMCPY(name, &sin, *namelen);
  807a6f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  807a73:	8b 00                	mov    (%rax),%eax
  807a75:	89 c2                	mov    %eax,%edx
  807a77:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  807a7b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  807a7f:	48 89 ce             	mov    %rcx,%rsi
  807a82:	48 89 c7             	mov    %rax,%rdi
  807a85:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  807a8c:	00 00 00 
  807a8f:	ff d0                	callq  *%rax
  sock_set_errno(sock, 0);
  807a91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807a95:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  807a9c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807aa0:	8b 50 18             	mov    0x18(%rax),%edx
  807aa3:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807aaa:	00 00 00 
  807aad:	89 10                	mov    %edx,(%rax)
  return 0;
  807aaf:	b8 00 00 00 00       	mov    $0x0,%eax
}
  807ab4:	c9                   	leaveq 
  807ab5:	c3                   	retq   

0000000000807ab6 <lwip_getpeername>:

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  807ab6:	55                   	push   %rbp
  807ab7:	48 89 e5             	mov    %rsp,%rbp
  807aba:	48 83 ec 20          	sub    $0x20,%rsp
  807abe:	89 7d fc             	mov    %edi,-0x4(%rbp)
  807ac1:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  807ac5:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  return lwip_getaddrname(s, name, namelen, 0);
  807ac9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  807acd:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  807ad1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807ad4:	b9 00 00 00 00       	mov    $0x0,%ecx
  807ad9:	89 c7                	mov    %eax,%edi
  807adb:	48 b8 ad 79 80 00 00 	movabs $0x8079ad,%rax
  807ae2:	00 00 00 
  807ae5:	ff d0                	callq  *%rax
}
  807ae7:	c9                   	leaveq 
  807ae8:	c3                   	retq   

0000000000807ae9 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  807ae9:	55                   	push   %rbp
  807aea:	48 89 e5             	mov    %rsp,%rbp
  807aed:	48 83 ec 20          	sub    $0x20,%rsp
  807af1:	89 7d fc             	mov    %edi,-0x4(%rbp)
  807af4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  807af8:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  return lwip_getaddrname(s, name, namelen, 1);
  807afc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  807b00:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  807b04:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807b07:	b9 01 00 00 00       	mov    $0x1,%ecx
  807b0c:	89 c7                	mov    %eax,%edi
  807b0e:	48 b8 ad 79 80 00 00 	movabs $0x8079ad,%rax
  807b15:	00 00 00 
  807b18:	ff d0                	callq  *%rax
}
  807b1a:	c9                   	leaveq 
  807b1b:	c3                   	retq   

0000000000807b1c <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  807b1c:	55                   	push   %rbp
  807b1d:	48 89 e5             	mov    %rsp,%rbp
  807b20:	48 83 ec 60          	sub    $0x60,%rsp
  807b24:	89 7d bc             	mov    %edi,-0x44(%rbp)
  807b27:	89 75 b8             	mov    %esi,-0x48(%rbp)
  807b2a:	89 55 b4             	mov    %edx,-0x4c(%rbp)
  807b2d:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  807b31:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  err_t err = ERR_OK;
  807b35:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  struct lwip_socket *sock = get_socket(s);
  807b39:	8b 45 bc             	mov    -0x44(%rbp),%eax
  807b3c:	89 c7                	mov    %eax,%edi
  807b3e:	48 b8 f6 5c 80 00 00 	movabs $0x805cf6,%rax
  807b45:	00 00 00 
  807b48:	ff d0                	callq  *%rax
  807b4a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct lwip_setgetsockopt_data data;

  if (!sock)
  807b4e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  807b53:	75 0a                	jne    807b5f <lwip_getsockopt+0x43>
    return -1;
  807b55:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807b5a:	e9 15 02 00 00       	jmpq   807d74 <lwip_getsockopt+0x258>

  if ((NULL == optval) || (NULL == optlen)) {
  807b5f:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  807b64:	74 07                	je     807b6d <lwip_getsockopt+0x51>
  807b66:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  807b6b:	75 28                	jne    807b95 <lwip_getsockopt+0x79>
    sock_set_errno(sock, EFAULT);
  807b6d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807b71:	c7 40 18 0e 00 00 00 	movl   $0xe,0x18(%rax)
  807b78:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807b7c:	8b 50 18             	mov    0x18(%rax),%edx
  807b7f:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807b86:	00 00 00 
  807b89:	89 10                	mov    %edx,(%rax)
    return -1;
  807b8b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807b90:	e9 df 01 00 00       	jmpq   807d74 <lwip_getsockopt+0x258>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  807b95:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807b98:	83 f8 06             	cmp    $0x6,%eax
  807b9b:	0f 84 c2 00 00 00    	je     807c63 <lwip_getsockopt+0x147>
  807ba1:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807ba6:	74 0d                	je     807bb5 <lwip_getsockopt+0x99>
  807ba8:	85 c0                	test   %eax,%eax
  807baa:	0f 84 8e 00 00 00    	je     807c3e <lwip_getsockopt+0x122>
  807bb0:	e9 eb 00 00 00       	jmpq   807ca0 <lwip_getsockopt+0x184>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807bb5:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807bb8:	83 f8 20             	cmp    $0x20,%eax
  807bbb:	74 28                	je     807be5 <lwip_getsockopt+0xc9>
  807bbd:	83 f8 20             	cmp    $0x20,%eax
  807bc0:	7f 0c                	jg     807bce <lwip_getsockopt+0xb2>
  807bc2:	83 f8 02             	cmp    $0x2,%eax
  807bc5:	74 1e                	je     807be5 <lwip_getsockopt+0xc9>
  807bc7:	83 f8 08             	cmp    $0x8,%eax
  807bca:	74 19                	je     807be5 <lwip_getsockopt+0xc9>
  807bcc:	eb 64                	jmp    807c32 <lwip_getsockopt+0x116>
  807bce:	3d 07 10 00 00       	cmp    $0x1007,%eax
  807bd3:	7c 5d                	jl     807c32 <lwip_getsockopt+0x116>
  807bd5:	3d 08 10 00 00       	cmp    $0x1008,%eax
  807bda:	7e 09                	jle    807be5 <lwip_getsockopt+0xc9>
  807bdc:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  807be1:	74 13                	je     807bf6 <lwip_getsockopt+0xda>
  807be3:	eb 4d                	jmp    807c32 <lwip_getsockopt+0x116>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  807be5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807be9:	8b 00                	mov    (%rax),%eax
  807beb:	83 f8 03             	cmp    $0x3,%eax
  807bee:	77 48                	ja     807c38 <lwip_getsockopt+0x11c>
        err = EINVAL;
  807bf0:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
      break;
  807bf4:	eb 42                	jmp    807c38 <lwip_getsockopt+0x11c>

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
  807bf6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807bfa:	8b 00                	mov    (%rax),%eax
  807bfc:	83 f8 03             	cmp    $0x3,%eax
  807bff:	77 04                	ja     807c05 <lwip_getsockopt+0xe9>
        err = EINVAL;
  807c01:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  807c05:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c09:	48 8b 00             	mov    (%rax),%rax
  807c0c:	8b 00                	mov    (%rax),%eax
  807c0e:	83 f8 20             	cmp    $0x20,%eax
  807c11:	75 19                	jne    807c2c <lwip_getsockopt+0x110>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  807c13:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c17:	48 8b 00             	mov    (%rax),%rax
  807c1a:	48 8b 40 08          	mov    0x8(%rax),%rax
  807c1e:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  807c22:	0f b6 c0             	movzbl %al,%eax
  807c25:	83 e0 02             	and    $0x2,%eax
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  807c28:	85 c0                	test   %eax,%eax
  807c2a:	74 0f                	je     807c3b <lwip_getsockopt+0x11f>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  807c2c:	c6 45 ff 61          	movb   $0x61,-0x1(%rbp)
      }
#endif /* LWIP_UDP */
      break;
  807c30:	eb 09                	jmp    807c3b <lwip_getsockopt+0x11f>

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  807c32:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  807c36:	eb 6c                	jmp    807ca4 <lwip_getsockopt+0x188>
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
  807c38:	90                   	nop
  807c39:	eb 69                	jmp    807ca4 <lwip_getsockopt+0x188>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
      }
#endif /* LWIP_UDP */
      break;
  807c3b:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  807c3c:	eb 66                	jmp    807ca4 <lwip_getsockopt+0x188>
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  807c3e:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807c41:	83 e8 01             	sub    $0x1,%eax
  807c44:	83 f8 01             	cmp    $0x1,%eax
  807c47:	77 11                	ja     807c5a <lwip_getsockopt+0x13e>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  807c49:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807c4d:	8b 00                	mov    (%rax),%eax
  807c4f:	83 f8 03             	cmp    $0x3,%eax
  807c52:	77 0c                	ja     807c60 <lwip_getsockopt+0x144>
        err = EINVAL;
  807c54:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
      break;
  807c58:	eb 06                	jmp    807c60 <lwip_getsockopt+0x144>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  807c5a:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  807c5e:	eb 44                	jmp    807ca4 <lwip_getsockopt+0x188>
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
  807c60:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  807c61:	eb 41                	jmp    807ca4 <lwip_getsockopt+0x188>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  807c63:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807c67:	8b 00                	mov    (%rax),%eax
  807c69:	83 f8 03             	cmp    $0x3,%eax
  807c6c:	77 06                	ja     807c74 <lwip_getsockopt+0x158>
      err = EINVAL;
  807c6e:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      break;
  807c72:	eb 30                	jmp    807ca4 <lwip_getsockopt+0x188>
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  807c74:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c78:	48 8b 00             	mov    (%rax),%rax
  807c7b:	8b 00                	mov    (%rax),%eax
  807c7d:	83 f8 10             	cmp    $0x10,%eax
  807c80:	74 0a                	je     807c8c <lwip_getsockopt+0x170>
      return 0;
  807c82:	b8 00 00 00 00       	mov    $0x0,%eax
  807c87:	e9 e8 00 00 00       	jmpq   807d74 <lwip_getsockopt+0x258>

    switch (optname) {
  807c8c:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807c8f:	83 e8 01             	sub    $0x1,%eax
  807c92:	83 f8 01             	cmp    $0x1,%eax
  807c95:	76 06                	jbe    807c9d <lwip_getsockopt+0x181>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  807c97:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  807c9b:	eb 07                	jmp    807ca4 <lwip_getsockopt+0x188>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
  807c9d:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  807c9e:	eb 04                	jmp    807ca4 <lwip_getsockopt+0x188>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  807ca0:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
  }  /* switch */

   
  if (err != ERR_OK) {
  807ca4:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  807ca8:	74 28                	je     807cd2 <lwip_getsockopt+0x1b6>
    sock_set_errno(sock, err);
  807caa:	0f be 55 ff          	movsbl -0x1(%rbp),%edx
  807cae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807cb2:	89 50 18             	mov    %edx,0x18(%rax)
  807cb5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807cb9:	8b 50 18             	mov    0x18(%rax),%edx
  807cbc:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807cc3:	00 00 00 
  807cc6:	89 10                	mov    %edx,(%rax)
    return -1;
  807cc8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807ccd:	e9 a2 00 00 00       	jmpq   807d74 <lwip_getsockopt+0x258>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  807cd2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807cd6:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  data.level = level;
  807cda:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807cdd:	89 45 cc             	mov    %eax,-0x34(%rbp)
  data.optname = optname;
  807ce0:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807ce3:	89 45 d0             	mov    %eax,-0x30(%rbp)
  data.optval = optval;
  807ce6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  807cea:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  data.optlen = optlen;
  807cee:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807cf2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  data.err = err;
  807cf6:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  807cfa:	88 45 e8             	mov    %al,-0x18(%rbp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  807cfd:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  807d01:	ba 01 00 00 00       	mov    $0x1,%edx
  807d06:	48 89 c6             	mov    %rax,%rsi
  807d09:	48 bf 76 7d 80 00 00 	movabs $0x807d76,%rdi
  807d10:	00 00 00 
  807d13:	48 b8 e6 8a 80 00 00 	movabs $0x808ae6,%rax
  807d1a:	00 00 00 
  807d1d:	ff d0                	callq  *%rax
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  807d1f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807d23:	48 8b 00             	mov    (%rax),%rax
  807d26:	8b 40 14             	mov    0x14(%rax),%eax
  807d29:	be 00 00 00 00       	mov    $0x0,%esi
  807d2e:	89 c7                	mov    %eax,%edi
  807d30:	48 b8 6f 82 81 00 00 	movabs $0x81826f,%rax
  807d37:	00 00 00 
  807d3a:	ff d0                	callq  *%rax
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  807d3c:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  807d40:	88 45 ff             	mov    %al,-0x1(%rbp)

  sock_set_errno(sock, err);
  807d43:	0f be 55 ff          	movsbl -0x1(%rbp),%edx
  807d47:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807d4b:	89 50 18             	mov    %edx,0x18(%rax)
  807d4e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807d52:	8b 50 18             	mov    0x18(%rax),%edx
  807d55:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807d5c:	00 00 00 
  807d5f:	89 10                	mov    %edx,(%rax)
  return err ? -1 : 0;
  807d61:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  807d65:	74 07                	je     807d6e <lwip_getsockopt+0x252>
  807d67:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807d6c:	eb 06                	jmp    807d74 <lwip_getsockopt+0x258>
  807d6e:	b8 00 00 00 00       	mov    $0x0,%eax
  807d73:	90                   	nop
}
  807d74:	c9                   	leaveq 
  807d75:	c3                   	retq   

0000000000807d76 <lwip_getsockopt_internal>:

static void
lwip_getsockopt_internal(void *arg)
{
  807d76:	55                   	push   %rbp
  807d77:	48 89 e5             	mov    %rsp,%rbp
  807d7a:	48 83 ec 40          	sub    $0x40,%rsp
  807d7e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  807d82:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  807d87:	75 2a                	jne    807db3 <lwip_getsockopt_internal+0x3d>
  807d89:	48 ba 47 19 82 00 00 	movabs $0x821947,%rdx
  807d90:	00 00 00 
  807d93:	be 39 05 00 00       	mov    $0x539,%esi
  807d98:	48 bf 91 18 82 00 00 	movabs $0x821891,%rdi
  807d9f:	00 00 00 
  807da2:	b8 00 00 00 00       	mov    $0x0,%eax
  807da7:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  807dae:	00 00 00 
  807db1:	ff d1                	callq  *%rcx

  data = (struct lwip_setgetsockopt_data*)arg;
  807db3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  807db7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sock = data->sock;
  807dbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807dbf:	48 8b 00             	mov    (%rax),%rax
  807dc2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#ifdef LWIP_DEBUG
  s = data->s;
  807dc6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807dca:	8b 40 08             	mov    0x8(%rax),%eax
  807dcd:	89 45 ec             	mov    %eax,-0x14(%rbp)
#endif /* LWIP_DEBUG */
  level = data->level;
  807dd0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807dd4:	8b 40 0c             	mov    0xc(%rax),%eax
  807dd7:	89 45 e8             	mov    %eax,-0x18(%rbp)
  optname = data->optname;
  807dda:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807dde:	8b 40 10             	mov    0x10(%rax),%eax
  807de1:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  optval = data->optval;
  807de4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807de8:	48 8b 40 18          	mov    0x18(%rax),%rax
  807dec:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  switch (level) {
  807df0:	8b 45 e8             	mov    -0x18(%rbp),%eax
  807df3:	83 f8 06             	cmp    $0x6,%eax
  807df6:	0f 84 bc 01 00 00    	je     807fb8 <lwip_getsockopt_internal+0x242>
  807dfc:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807e01:	74 0d                	je     807e10 <lwip_getsockopt_internal+0x9a>
  807e03:	85 c0                	test   %eax,%eax
  807e05:	0f 84 69 01 00 00    	je     807f74 <lwip_getsockopt_internal+0x1fe>
  807e0b:	e9 f1 01 00 00       	jmpq   808001 <lwip_getsockopt_internal+0x28b>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807e10:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807e13:	83 f8 20             	cmp    $0x20,%eax
  807e16:	74 36                	je     807e4e <lwip_getsockopt_internal+0xd8>
  807e18:	83 f8 20             	cmp    $0x20,%eax
  807e1b:	7f 0f                	jg     807e2c <lwip_getsockopt_internal+0xb6>
  807e1d:	83 f8 02             	cmp    $0x2,%eax
  807e20:	74 2c                	je     807e4e <lwip_getsockopt_internal+0xd8>
  807e22:	83 f8 08             	cmp    $0x8,%eax
  807e25:	74 27                	je     807e4e <lwip_getsockopt_internal+0xd8>
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
  807e27:	e9 d5 01 00 00       	jmpq   808001 <lwip_getsockopt_internal+0x28b>

  switch (level) {
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807e2c:	3d 08 10 00 00       	cmp    $0x1008,%eax
  807e31:	74 3d                	je     807e70 <lwip_getsockopt_internal+0xfa>
  807e33:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  807e38:	0f 84 0d 01 00 00    	je     807f4b <lwip_getsockopt_internal+0x1d5>
  807e3e:	3d 07 10 00 00       	cmp    $0x1007,%eax
  807e43:	0f 84 85 00 00 00    	je     807ece <lwip_getsockopt_internal+0x158>
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
  807e49:	e9 b3 01 00 00       	jmpq   808001 <lwip_getsockopt_internal+0x28b>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  807e4e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e52:	48 8b 00             	mov    (%rax),%rax
  807e55:	48 8b 40 08          	mov    0x8(%rax),%rax
  807e59:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  807e5d:	0f b7 c0             	movzwl %ax,%eax
  807e60:	23 45 e4             	and    -0x1c(%rbp),%eax
  807e63:	89 c2                	mov    %eax,%edx
  807e65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807e69:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  807e6b:	e9 ff 00 00 00       	jmpq   807f6f <lwip_getsockopt_internal+0x1f9>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  807e70:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e74:	48 8b 00             	mov    (%rax),%rax
  807e77:	8b 00                	mov    (%rax),%eax
  807e79:	25 f0 00 00 00       	and    $0xf0,%eax
  807e7e:	83 f8 20             	cmp    $0x20,%eax
  807e81:	74 24                	je     807ea7 <lwip_getsockopt_internal+0x131>
  807e83:	83 f8 40             	cmp    $0x40,%eax
  807e86:	74 07                	je     807e8f <lwip_getsockopt_internal+0x119>
  807e88:	83 f8 10             	cmp    $0x10,%eax
  807e8b:	74 0e                	je     807e9b <lwip_getsockopt_internal+0x125>
  807e8d:	eb 24                	jmp    807eb3 <lwip_getsockopt_internal+0x13d>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  807e8f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807e93:	c7 00 03 00 00 00    	movl   $0x3,(%rax)
        break;
  807e99:	eb 2e                	jmp    807ec9 <lwip_getsockopt_internal+0x153>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
  807e9b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807e9f:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
        break;
  807ea5:	eb 22                	jmp    807ec9 <lwip_getsockopt_internal+0x153>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  807ea7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807eab:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
        break;
  807eb1:	eb 16                	jmp    807ec9 <lwip_getsockopt_internal+0x153>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  807eb3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807eb7:	48 8b 00             	mov    (%rax),%rax
  807eba:	8b 00                	mov    (%rax),%eax
  807ebc:	89 c2                	mov    %eax,%edx
  807ebe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807ec2:	89 10                	mov    %edx,(%rax)
                    ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
                    s, *(int *)optval));
      }  /* switch (sock->conn->type) */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;
  807ec4:	e9 a6 00 00 00       	jmpq   807f6f <lwip_getsockopt_internal+0x1f9>
  807ec9:	e9 a1 00 00 00       	jmpq   807f6f <lwip_getsockopt_internal+0x1f9>

    case SO_ERROR:
      if (sock->err == 0) {
  807ece:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807ed2:	8b 40 18             	mov    0x18(%rax),%eax
  807ed5:	85 c0                	test   %eax,%eax
  807ed7:	75 58                	jne    807f31 <lwip_getsockopt_internal+0x1bb>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  807ed9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807edd:	48 8b 00             	mov    (%rax),%rax
  807ee0:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  807ee4:	0f be c0             	movsbl %al,%eax
  807ee7:	f7 d8                	neg    %eax
  807ee9:	83 f8 0e             	cmp    $0xe,%eax
  807eec:	77 24                	ja     807f12 <lwip_getsockopt_internal+0x19c>
  807eee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807ef2:	48 8b 00             	mov    (%rax),%rax
  807ef5:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  807ef9:	0f be c0             	movsbl %al,%eax
  807efc:	f7 d8                	neg    %eax
  807efe:	89 c2                	mov    %eax,%edx
  807f00:	48 b8 40 18 82 00 00 	movabs $0x821840,%rax
  807f07:	00 00 00 
  807f0a:	48 63 d2             	movslq %edx,%rdx
  807f0d:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  807f10:	eb 05                	jmp    807f17 <lwip_getsockopt_internal+0x1a1>
  807f12:	b8 05 00 00 00       	mov    $0x5,%eax
  807f17:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  807f1b:	89 42 18             	mov    %eax,0x18(%rdx)
  807f1e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f22:	8b 50 18             	mov    0x18(%rax),%edx
  807f25:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807f2c:	00 00 00 
  807f2f:	89 10                	mov    %edx,(%rax)
      } 
      *(int *)optval = sock->err;
  807f31:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f35:	8b 50 18             	mov    0x18(%rax),%edx
  807f38:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807f3c:	89 10                	mov    %edx,(%rax)
      sock->err = 0;
  807f3e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f42:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  807f49:	eb 24                	jmp    807f6f <lwip_getsockopt_internal+0x1f9>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  807f4b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f4f:	48 8b 00             	mov    (%rax),%rax
  807f52:	48 8b 40 08          	mov    0x8(%rax),%rax
  807f56:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  807f5a:	0f b6 c0             	movzbl %al,%eax
  807f5d:	83 e0 01             	and    $0x1,%eax
  807f60:	85 c0                	test   %eax,%eax
  807f62:	0f 95 c0             	setne  %al
  807f65:	0f b6 d0             	movzbl %al,%edx
  807f68:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807f6c:	89 10                	mov    %edx,(%rax)
      break;
  807f6e:	90                   	nop
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
  807f6f:	e9 8d 00 00 00       	jmpq   808001 <lwip_getsockopt_internal+0x28b>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  807f74:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807f77:	83 f8 01             	cmp    $0x1,%eax
  807f7a:	74 21                	je     807f9d <lwip_getsockopt_internal+0x227>
  807f7c:	83 f8 02             	cmp    $0x2,%eax
  807f7f:	74 02                	je     807f83 <lwip_getsockopt_internal+0x20d>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  807f81:	eb 7e                	jmp    808001 <lwip_getsockopt_internal+0x28b>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  807f83:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f87:	48 8b 00             	mov    (%rax),%rax
  807f8a:	48 8b 40 08          	mov    0x8(%rax),%rax
  807f8e:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  807f92:	0f b6 d0             	movzbl %al,%edx
  807f95:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807f99:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  807f9b:	eb 19                	jmp    807fb6 <lwip_getsockopt_internal+0x240>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  807f9d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807fa1:	48 8b 00             	mov    (%rax),%rax
  807fa4:	48 8b 40 08          	mov    0x8(%rax),%rax
  807fa8:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  807fac:	0f b6 d0             	movzbl %al,%edx
  807faf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807fb3:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
  807fb5:	90                   	nop
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  807fb6:	eb 49                	jmp    808001 <lwip_getsockopt_internal+0x28b>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  807fb8:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807fbb:	83 f8 01             	cmp    $0x1,%eax
  807fbe:	74 07                	je     807fc7 <lwip_getsockopt_internal+0x251>
  807fc0:	83 f8 02             	cmp    $0x2,%eax
  807fc3:	74 21                	je     807fe6 <lwip_getsockopt_internal+0x270>
                  s, *(int *)optval));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  807fc5:	eb 39                	jmp    808000 <lwip_getsockopt_internal+0x28a>
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  807fc7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807fcb:	48 8b 00             	mov    (%rax),%rax
  807fce:	48 8b 40 08          	mov    0x8(%rax),%rax
  807fd2:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  807fd6:	0f b6 c0             	movzbl %al,%eax
  807fd9:	83 e0 40             	and    $0x40,%eax
  807fdc:	89 c2                	mov    %eax,%edx
  807fde:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807fe2:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  807fe4:	eb 1a                	jmp    808000 <lwip_getsockopt_internal+0x28a>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  807fe6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807fea:	48 8b 00             	mov    (%rax),%rax
  807fed:	48 8b 40 08          	mov    0x8(%rax),%rax
  807ff1:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  807ff7:	89 c2                	mov    %eax,%edx
  807ff9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807ffd:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPALIVE) = %d\n",
                  s, *(int *)optval));
      break;
  807fff:	90                   	nop
                  s, *(int *)optval));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  808000:	90                   	nop
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  808001:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808005:	48 8b 00             	mov    (%rax),%rax
  808008:	8b 40 14             	mov    0x14(%rax),%eax
  80800b:	89 c7                	mov    %eax,%edi
  80800d:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  808014:	00 00 00 
  808017:	ff d0                	callq  *%rax
}
  808019:	90                   	nop
  80801a:	c9                   	leaveq 
  80801b:	c3                   	retq   

000000000080801c <lwip_setsockopt>:

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  80801c:	55                   	push   %rbp
  80801d:	48 89 e5             	mov    %rsp,%rbp
  808020:	48 83 ec 60          	sub    $0x60,%rsp
  808024:	89 7d bc             	mov    %edi,-0x44(%rbp)
  808027:	89 75 b8             	mov    %esi,-0x48(%rbp)
  80802a:	89 55 b4             	mov    %edx,-0x4c(%rbp)
  80802d:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  808031:	44 89 45 b0          	mov    %r8d,-0x50(%rbp)
  struct lwip_socket *sock = get_socket(s);
  808035:	8b 45 bc             	mov    -0x44(%rbp),%eax
  808038:	89 c7                	mov    %eax,%edi
  80803a:	48 b8 f6 5c 80 00 00 	movabs $0x805cf6,%rax
  808041:	00 00 00 
  808044:	ff d0                	callq  *%rax
  808046:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  int err = ERR_OK;
  80804a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  struct lwip_setgetsockopt_data data;

  if (!sock)
  808051:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  808056:	75 0a                	jne    808062 <lwip_setsockopt+0x46>
    return -1;
  808058:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80805d:	e9 fd 01 00 00       	jmpq   80825f <lwip_setsockopt+0x243>

  if (NULL == optval) {
  808062:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  808067:	75 28                	jne    808091 <lwip_setsockopt+0x75>
    sock_set_errno(sock, EFAULT);
  808069:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80806d:	c7 40 18 0e 00 00 00 	movl   $0xe,0x18(%rax)
  808074:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808078:	8b 50 18             	mov    0x18(%rax),%edx
  80807b:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  808082:	00 00 00 
  808085:	89 10                	mov    %edx,(%rax)
    return -1;
  808087:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80808c:	e9 ce 01 00 00       	jmpq   80825f <lwip_setsockopt+0x243>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  808091:	8b 45 b8             	mov    -0x48(%rbp),%eax
  808094:	83 f8 06             	cmp    $0x6,%eax
  808097:	0f 84 ab 00 00 00    	je     808148 <lwip_setsockopt+0x12c>
  80809d:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  8080a2:	74 09                	je     8080ad <lwip_setsockopt+0x91>
  8080a4:	85 c0                	test   %eax,%eax
  8080a6:	74 78                	je     808120 <lwip_setsockopt+0x104>
  8080a8:	e9 db 00 00 00       	jmpq   808188 <lwip_setsockopt+0x16c>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  8080ad:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8080b0:	83 f8 20             	cmp    $0x20,%eax
  8080b3:	74 0c                	je     8080c1 <lwip_setsockopt+0xa5>
  8080b5:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  8080ba:	74 16                	je     8080d2 <lwip_setsockopt+0xb6>
  8080bc:	83 f8 08             	cmp    $0x8,%eax
  8080bf:	75 50                	jne    808111 <lwip_setsockopt+0xf5>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  8080c1:	8b 45 b0             	mov    -0x50(%rbp),%eax
  8080c4:	83 f8 03             	cmp    $0x3,%eax
  8080c7:	77 51                	ja     80811a <lwip_setsockopt+0xfe>
        err = EINVAL;
  8080c9:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
      break;
  8080d0:	eb 48                	jmp    80811a <lwip_setsockopt+0xfe>
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
  8080d2:	8b 45 b0             	mov    -0x50(%rbp),%eax
  8080d5:	83 f8 03             	cmp    $0x3,%eax
  8080d8:	77 07                	ja     8080e1 <lwip_setsockopt+0xc5>
        err = EINVAL;
  8080da:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  8080e1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8080e5:	48 8b 00             	mov    (%rax),%rax
  8080e8:	8b 00                	mov    (%rax),%eax
  8080ea:	83 f8 20             	cmp    $0x20,%eax
  8080ed:	75 19                	jne    808108 <lwip_setsockopt+0xec>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  8080ef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8080f3:	48 8b 00             	mov    (%rax),%rax
  8080f6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8080fa:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8080fe:	0f b6 c0             	movzbl %al,%eax
  808101:	83 e0 02             	and    $0x2,%eax
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  808104:	85 c0                	test   %eax,%eax
  808106:	74 15                	je     80811d <lwip_setsockopt+0x101>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  808108:	c7 45 fc 61 00 00 00 	movl   $0x61,-0x4(%rbp)
      }
#endif /* LWIP_UDP */
      break;
  80810f:	eb 0c                	jmp    80811d <lwip_setsockopt+0x101>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  808111:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  808118:	eb 75                	jmp    80818f <lwip_setsockopt+0x173>
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
  80811a:	90                   	nop
  80811b:	eb 72                	jmp    80818f <lwip_setsockopt+0x173>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
      }
#endif /* LWIP_UDP */
      break;
  80811d:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  80811e:	eb 6f                	jmp    80818f <lwip_setsockopt+0x173>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  808120:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  808123:	83 e8 01             	sub    $0x1,%eax
  808126:	83 f8 01             	cmp    $0x1,%eax
  808129:	77 11                	ja     80813c <lwip_setsockopt+0x120>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  80812b:	8b 45 b0             	mov    -0x50(%rbp),%eax
  80812e:	83 f8 03             	cmp    $0x3,%eax
  808131:	77 12                	ja     808145 <lwip_setsockopt+0x129>
        err = EINVAL;
  808133:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
      break;
  80813a:	eb 09                	jmp    808145 <lwip_setsockopt+0x129>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  80813c:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  808143:	eb 4a                	jmp    80818f <lwip_setsockopt+0x173>
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
  808145:	90                   	nop
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  808146:	eb 47                	jmp    80818f <lwip_setsockopt+0x173>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  808148:	8b 45 b0             	mov    -0x50(%rbp),%eax
  80814b:	83 f8 03             	cmp    $0x3,%eax
  80814e:	77 09                	ja     808159 <lwip_setsockopt+0x13d>
      err = EINVAL;
  808150:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      break;
  808157:	eb 36                	jmp    80818f <lwip_setsockopt+0x173>
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  808159:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80815d:	48 8b 00             	mov    (%rax),%rax
  808160:	8b 00                	mov    (%rax),%eax
  808162:	83 f8 10             	cmp    $0x10,%eax
  808165:	74 0a                	je     808171 <lwip_setsockopt+0x155>
      return 0;
  808167:	b8 00 00 00 00       	mov    $0x0,%eax
  80816c:	e9 ee 00 00 00       	jmpq   80825f <lwip_setsockopt+0x243>

    switch (optname) {
  808171:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  808174:	83 e8 01             	sub    $0x1,%eax
  808177:	83 f8 01             	cmp    $0x1,%eax
  80817a:	76 09                	jbe    808185 <lwip_setsockopt+0x169>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  80817c:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  808183:	eb 0a                	jmp    80818f <lwip_setsockopt+0x173>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
  808185:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  808186:	eb 07                	jmp    80818f <lwip_setsockopt+0x173>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  808188:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
  }  /* switch (level) */


  if (err != ERR_OK) {
  80818f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  808193:	74 27                	je     8081bc <lwip_setsockopt+0x1a0>
    sock_set_errno(sock, err);
  808195:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808199:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80819c:	89 50 18             	mov    %edx,0x18(%rax)
  80819f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8081a3:	8b 50 18             	mov    0x18(%rax),%edx
  8081a6:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8081ad:	00 00 00 
  8081b0:	89 10                	mov    %edx,(%rax)
    return -1;
  8081b2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8081b7:	e9 a3 00 00 00       	jmpq   80825f <lwip_setsockopt+0x243>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  8081bc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8081c0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  data.level = level;
  8081c4:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8081c7:	89 45 cc             	mov    %eax,-0x34(%rbp)
  data.optname = optname;
  8081ca:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8081cd:	89 45 d0             	mov    %eax,-0x30(%rbp)
  data.optval = (void*)optval;
  8081d0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8081d4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  data.optlen = &optlen;
  8081d8:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  8081dc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  data.err = err;
  8081e0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8081e3:	88 45 e8             	mov    %al,-0x18(%rbp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  8081e6:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8081ea:	ba 01 00 00 00       	mov    $0x1,%edx
  8081ef:	48 89 c6             	mov    %rax,%rsi
  8081f2:	48 bf 61 82 80 00 00 	movabs $0x808261,%rdi
  8081f9:	00 00 00 
  8081fc:	48 b8 e6 8a 80 00 00 	movabs $0x808ae6,%rax
  808203:	00 00 00 
  808206:	ff d0                	callq  *%rax
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  808208:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80820c:	48 8b 00             	mov    (%rax),%rax
  80820f:	8b 40 14             	mov    0x14(%rax),%eax
  808212:	be 00 00 00 00       	mov    $0x0,%esi
  808217:	89 c7                	mov    %eax,%edi
  808219:	48 b8 6f 82 81 00 00 	movabs $0x81826f,%rax
  808220:	00 00 00 
  808223:	ff d0                	callq  *%rax
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  808225:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  808229:	0f be c0             	movsbl %al,%eax
  80822c:	89 45 fc             	mov    %eax,-0x4(%rbp)

  sock_set_errno(sock, err);
  80822f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808233:	8b 55 fc             	mov    -0x4(%rbp),%edx
  808236:	89 50 18             	mov    %edx,0x18(%rax)
  808239:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80823d:	8b 50 18             	mov    0x18(%rax),%edx
  808240:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  808247:	00 00 00 
  80824a:	89 10                	mov    %edx,(%rax)
  return err ? -1 : 0;
  80824c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  808250:	74 07                	je     808259 <lwip_setsockopt+0x23d>
  808252:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808257:	eb 06                	jmp    80825f <lwip_setsockopt+0x243>
  808259:	b8 00 00 00 00       	mov    $0x0,%eax
  80825e:	90                   	nop
}
  80825f:	c9                   	leaveq 
  808260:	c3                   	retq   

0000000000808261 <lwip_setsockopt_internal>:

static void
lwip_setsockopt_internal(void *arg)
{
  808261:	55                   	push   %rbp
  808262:	48 89 e5             	mov    %rsp,%rbp
  808265:	48 83 ec 40          	sub    $0x40,%rsp
  808269:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  80826d:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  808272:	75 2a                	jne    80829e <lwip_setsockopt_internal+0x3d>
  808274:	48 ba 47 19 82 00 00 	movabs $0x821947,%rdx
  80827b:	00 00 00 
  80827e:	be af 06 00 00       	mov    $0x6af,%esi
  808283:	48 bf 91 18 82 00 00 	movabs $0x821891,%rdi
  80828a:	00 00 00 
  80828d:	b8 00 00 00 00       	mov    $0x0,%eax
  808292:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  808299:	00 00 00 
  80829c:	ff d1                	callq  *%rcx

  data = (struct lwip_setgetsockopt_data*)arg;
  80829e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8082a2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sock = data->sock;
  8082a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8082aa:	48 8b 00             	mov    (%rax),%rax
  8082ad:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#ifdef LWIP_DEBUG
  s = data->s;
  8082b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8082b5:	8b 40 08             	mov    0x8(%rax),%eax
  8082b8:	89 45 ec             	mov    %eax,-0x14(%rbp)
#endif /* LWIP_DEBUG */
  level = data->level;
  8082bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8082bf:	8b 40 0c             	mov    0xc(%rax),%eax
  8082c2:	89 45 e8             	mov    %eax,-0x18(%rbp)
  optname = data->optname;
  8082c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8082c9:	8b 40 10             	mov    0x10(%rax),%eax
  8082cc:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  optval = data->optval;
  8082cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8082d3:	48 8b 40 18          	mov    0x18(%rax),%rax
  8082d7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  switch (level) {
  8082db:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8082de:	83 f8 06             	cmp    $0x6,%eax
  8082e1:	0f 84 18 01 00 00    	je     8083ff <lwip_setsockopt_internal+0x19e>
  8082e7:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  8082ec:	74 0d                	je     8082fb <lwip_setsockopt_internal+0x9a>
  8082ee:	85 c0                	test   %eax,%eax
  8082f0:	0f 84 ca 00 00 00    	je     8083c0 <lwip_setsockopt_internal+0x15f>
  8082f6:	e9 7a 01 00 00       	jmpq   808475 <lwip_setsockopt_internal+0x214>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  8082fb:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8082fe:	83 f8 20             	cmp    $0x20,%eax
  808301:	74 11                	je     808314 <lwip_setsockopt_internal+0xb3>
  808303:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  808308:	74 64                	je     80836e <lwip_setsockopt_internal+0x10d>
  80830a:	83 f8 08             	cmp    $0x8,%eax
  80830d:	74 05                	je     808314 <lwip_setsockopt_internal+0xb3>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
  80830f:	e9 61 01 00 00       	jmpq   808475 <lwip_setsockopt_internal+0x214>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  808314:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  808318:	8b 00                	mov    (%rax),%eax
  80831a:	85 c0                	test   %eax,%eax
  80831c:	74 27                	je     808345 <lwip_setsockopt_internal+0xe4>
        sock->conn->pcb.ip->so_options |= optname;
  80831e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808322:	48 8b 00             	mov    (%rax),%rax
  808325:	48 8b 40 08          	mov    0x8(%rax),%rax
  808329:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80832d:	48 8b 12             	mov    (%rdx),%rdx
  808330:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  808334:	0f b7 52 08          	movzwl 0x8(%rdx),%edx
  808338:	89 d1                	mov    %edx,%ecx
  80833a:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80833d:	09 ca                	or     %ecx,%edx
  80833f:	66 89 50 08          	mov    %dx,0x8(%rax)
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
  808343:	eb 76                	jmp    8083bb <lwip_setsockopt_internal+0x15a>
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
        sock->conn->pcb.ip->so_options |= optname;
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  808345:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808349:	48 8b 00             	mov    (%rax),%rax
  80834c:	48 8b 40 08          	mov    0x8(%rax),%rax
  808350:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808354:	48 8b 12             	mov    (%rdx),%rdx
  808357:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  80835b:	0f b7 52 08          	movzwl 0x8(%rdx),%edx
  80835f:	89 d1                	mov    %edx,%ecx
  808361:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  808364:	f7 d2                	not    %edx
  808366:	21 ca                	and    %ecx,%edx
  808368:	66 89 50 08          	mov    %dx,0x8(%rax)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
  80836c:	eb 4d                	jmp    8083bb <lwip_setsockopt_internal+0x15a>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  80836e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  808372:	8b 00                	mov    (%rax),%eax
  808374:	85 c0                	test   %eax,%eax
  808376:	74 22                	je     80839a <lwip_setsockopt_internal+0x139>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  808378:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80837c:	48 8b 00             	mov    (%rax),%rax
  80837f:	48 8b 40 08          	mov    0x8(%rax),%rax
  808383:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808387:	48 8b 12             	mov    (%rdx),%rdx
  80838a:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  80838e:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  808392:	83 ca 01             	or     $0x1,%edx
  808395:	88 50 18             	mov    %dl,0x18(%rax)
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
  808398:	eb 20                	jmp    8083ba <lwip_setsockopt_internal+0x159>
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  80839a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80839e:	48 8b 00             	mov    (%rax),%rax
  8083a1:	48 8b 40 08          	mov    0x8(%rax),%rax
  8083a5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8083a9:	48 8b 12             	mov    (%rdx),%rdx
  8083ac:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8083b0:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  8083b4:	83 e2 fe             	and    $0xfffffffe,%edx
  8083b7:	88 50 18             	mov    %dl,0x18(%rax)
      }
      break;
  8083ba:	90                   	nop
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
  8083bb:	e9 b5 00 00 00       	jmpq   808475 <lwip_setsockopt_internal+0x214>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  8083c0:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8083c3:	83 f8 01             	cmp    $0x1,%eax
  8083c6:	74 20                	je     8083e8 <lwip_setsockopt_internal+0x187>
  8083c8:	83 f8 02             	cmp    $0x2,%eax
  8083cb:	74 05                	je     8083d2 <lwip_setsockopt_internal+0x171>
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  8083cd:	e9 a3 00 00 00       	jmpq   808475 <lwip_setsockopt_internal+0x214>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  8083d2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8083d6:	48 8b 00             	mov    (%rax),%rax
  8083d9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8083dd:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8083e1:	8b 12                	mov    (%rdx),%edx
  8083e3:	88 50 0b             	mov    %dl,0xb(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  8083e6:	eb 15                	jmp    8083fd <lwip_setsockopt_internal+0x19c>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  8083e8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8083ec:	48 8b 00             	mov    (%rax),%rax
  8083ef:	48 8b 40 08          	mov    0x8(%rax),%rax
  8083f3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8083f7:	8b 12                	mov    (%rdx),%edx
  8083f9:	88 50 0a             	mov    %dl,0xa(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
                  s, sock->conn->pcb.ip->tos));
      break;
  8083fc:	90                   	nop
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  8083fd:	eb 76                	jmp    808475 <lwip_setsockopt_internal+0x214>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  8083ff:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  808402:	83 f8 01             	cmp    $0x1,%eax
  808405:	74 07                	je     80840e <lwip_setsockopt_internal+0x1ad>
  808407:	83 f8 02             	cmp    $0x2,%eax
  80840a:	74 50                	je     80845c <lwip_setsockopt_internal+0x1fb>
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  80840c:	eb 66                	jmp    808474 <lwip_setsockopt_internal+0x213>
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
  80840e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  808412:	8b 00                	mov    (%rax),%eax
  808414:	85 c0                	test   %eax,%eax
  808416:	74 22                	je     80843a <lwip_setsockopt_internal+0x1d9>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  808418:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80841c:	48 8b 00             	mov    (%rax),%rax
  80841f:	48 8b 40 08          	mov    0x8(%rax),%rax
  808423:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808427:	48 8b 12             	mov    (%rdx),%rdx
  80842a:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  80842e:	0f b6 52 2c          	movzbl 0x2c(%rdx),%edx
  808432:	83 ca 40             	or     $0x40,%edx
  808435:	88 50 2c             	mov    %dl,0x2c(%rax)
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
  808438:	eb 3a                	jmp    808474 <lwip_setsockopt_internal+0x213>
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  80843a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80843e:	48 8b 00             	mov    (%rax),%rax
  808441:	48 8b 40 08          	mov    0x8(%rax),%rax
  808445:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808449:	48 8b 12             	mov    (%rdx),%rdx
  80844c:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  808450:	0f b6 52 2c          	movzbl 0x2c(%rdx),%edx
  808454:	83 e2 bf             	and    $0xffffffbf,%edx
  808457:	88 50 2c             	mov    %dl,0x2c(%rax)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
  80845a:	eb 18                	jmp    808474 <lwip_setsockopt_internal+0x213>
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  80845c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808460:	48 8b 00             	mov    (%rax),%rax
  808463:	48 8b 40 08          	mov    0x8(%rax),%rax
  808467:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80846b:	8b 12                	mov    (%rdx),%edx
  80846d:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %lu\n",
                  s, sock->conn->pcb.tcp->keep_idle));
      break;
  808473:	90                   	nop
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  808474:	90                   	nop
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  808475:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808479:	48 8b 00             	mov    (%rax),%rax
  80847c:	8b 40 14             	mov    0x14(%rax),%eax
  80847f:	89 c7                	mov    %eax,%edi
  808481:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  808488:	00 00 00 
  80848b:	ff d0                	callq  *%rax
}
  80848d:	90                   	nop
  80848e:	c9                   	leaveq 
  80848f:	c3                   	retq   

0000000000808490 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  808490:	55                   	push   %rbp
  808491:	48 89 e5             	mov    %rsp,%rbp
  808494:	48 83 ec 28          	sub    $0x28,%rsp
  808498:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80849b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80849f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  struct lwip_socket *sock = get_socket(s);
  8084a3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8084a6:	89 c7                	mov    %eax,%edi
  8084a8:	48 b8 f6 5c 80 00 00 	movabs $0x805cf6,%rax
  8084af:	00 00 00 
  8084b2:	ff d0                	callq  *%rax
  8084b4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  u16_t buflen = 0;
  8084b8:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)

  if (!sock)
  8084be:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8084c3:	75 0a                	jne    8084cf <lwip_ioctl+0x3f>
    return -1;
  8084c5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8084ca:	e9 4d 01 00 00       	jmpq   80861c <lwip_ioctl+0x18c>

  switch (cmd) {
  8084cf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8084d3:	48 3d 7f 66 08 40    	cmp    $0x4008667f,%rax
  8084d9:	74 13                	je     8084ee <lwip_ioctl+0x5e>
  8084db:	ba 7e 66 08 80       	mov    $0x8008667e,%edx
  8084e0:	48 39 d0             	cmp    %rdx,%rax
  8084e3:	0f 84 ae 00 00 00    	je     808597 <lwip_ioctl+0x107>
  8084e9:	e9 0b 01 00 00       	jmpq   8085f9 <lwip_ioctl+0x169>
  case FIONREAD:
    if (!argp) {
  8084ee:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8084f3:	75 28                	jne    80851d <lwip_ioctl+0x8d>
      sock_set_errno(sock, EINVAL);
  8084f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8084f9:	c7 40 18 16 00 00 00 	movl   $0x16,0x18(%rax)
  808500:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808504:	8b 50 18             	mov    0x18(%rax),%edx
  808507:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80850e:	00 00 00 
  808511:	89 10                	mov    %edx,(%rax)
      return -1;
  808513:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808518:	e9 ff 00 00 00       	jmpq   80861c <lwip_ioctl+0x18c>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  80851d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808521:	48 8b 00             	mov    (%rax),%rax
  808524:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  808528:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80852c:	66 89 10             	mov    %dx,(%rax)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  80852f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808533:	48 8b 40 08          	mov    0x8(%rax),%rax
  808537:	48 85 c0             	test   %rax,%rax
  80853a:	74 33                	je     80856f <lwip_ioctl+0xdf>
      buflen = netbuf_len(sock->lastdata);
  80853c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808540:	48 8b 40 08          	mov    0x8(%rax),%rax
  808544:	48 8b 00             	mov    (%rax),%rax
  808547:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80854b:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
      buflen -= sock->lastoffset;
  80854f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808553:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  808557:	66 29 45 f6          	sub    %ax,-0xa(%rbp)

      *((u16_t*)argp) += buflen;
  80855b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80855f:	0f b7 10             	movzwl (%rax),%edx
  808562:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  808566:	01 c2                	add    %eax,%edx
  808568:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80856c:	66 89 10             	mov    %dx,(%rax)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  80856f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808573:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  80857a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80857e:	8b 50 18             	mov    0x18(%rax),%edx
  808581:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  808588:	00 00 00 
  80858b:	89 10                	mov    %edx,(%rax)
    return 0;
  80858d:	b8 00 00 00 00       	mov    $0x0,%eax
  808592:	e9 85 00 00 00       	jmpq   80861c <lwip_ioctl+0x18c>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  808597:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80859c:	74 21                	je     8085bf <lwip_ioctl+0x12f>
  80859e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8085a2:	8b 00                	mov    (%rax),%eax
  8085a4:	85 c0                	test   %eax,%eax
  8085a6:	74 17                	je     8085bf <lwip_ioctl+0x12f>
      sock->flags |= O_NONBLOCK;
  8085a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085ac:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  8085b0:	80 cc 08             	or     $0x8,%ah
  8085b3:	89 c2                	mov    %eax,%edx
  8085b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085b9:	66 89 50 16          	mov    %dx,0x16(%rax)
  8085bd:	eb 15                	jmp    8085d4 <lwip_ioctl+0x144>
    else
      sock->flags &= ~O_NONBLOCK;
  8085bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085c3:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  8085c7:	80 e4 f7             	and    $0xf7,%ah
  8085ca:	89 c2                	mov    %eax,%edx
  8085cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085d0:	66 89 50 16          	mov    %dx,0x16(%rax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  8085d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085d8:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8085df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085e3:	8b 50 18             	mov    0x18(%rax),%edx
  8085e6:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8085ed:	00 00 00 
  8085f0:	89 10                	mov    %edx,(%rax)
    return 0;
  8085f2:	b8 00 00 00 00       	mov    $0x0,%eax
  8085f7:	eb 23                	jmp    80861c <lwip_ioctl+0x18c>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  8085f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085fd:	c7 40 18 26 00 00 00 	movl   $0x26,0x18(%rax)
  808604:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808608:	8b 50 18             	mov    0x18(%rax),%edx
  80860b:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  808612:	00 00 00 
  808615:	89 10                	mov    %edx,(%rax)
    return -1;
  808617:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  } /* switch (cmd) */
}
  80861c:	c9                   	leaveq 
  80861d:	c3                   	retq   

000000000080861e <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  80861e:	55                   	push   %rbp
  80861f:	48 89 e5             	mov    %rsp,%rbp
  808622:	48 83 ec 10          	sub    $0x10,%rsp
  808626:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  80862a:	48 b8 42 ec 80 00 00 	movabs $0x80ec42,%rax
  808631:	00 00 00 
  808634:	ff d0                	callq  *%rax
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  808636:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80863d:	00 00 00 
  808640:	48 8b 00             	mov    (%rax),%rax
  808643:	48 85 c0             	test   %rax,%rax
  808646:	75 12                	jne    80865a <tcpip_tcp_timer+0x3c>
  808648:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80864f:	00 00 00 
  808652:	48 8b 00             	mov    (%rax),%rax
  808655:	48 85 c0             	test   %rax,%rax
  808658:	74 22                	je     80867c <tcpip_tcp_timer+0x5e>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  80865a:	ba 00 00 00 00       	mov    $0x0,%edx
  80865f:	48 be 1e 86 80 00 00 	movabs $0x80861e,%rsi
  808666:	00 00 00 
  808669:	bf fa 00 00 00       	mov    $0xfa,%edi
  80866e:	48 b8 23 e8 80 00 00 	movabs $0x80e823,%rax
  808675:	00 00 00 
  808678:	ff d0                	callq  *%rax
  80867a:	eb 10                	jmp    80868c <tcpip_tcp_timer+0x6e>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  80867c:	48 b8 c0 94 82 00 00 	movabs $0x8294c0,%rax
  808683:	00 00 00 
  808686:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  }
}
  80868c:	90                   	nop
  80868d:	c9                   	leaveq 
  80868e:	c3                   	retq   

000000000080868f <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  80868f:	55                   	push   %rbp
  808690:	48 89 e5             	mov    %rsp,%rbp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  808693:	48 b8 c0 94 82 00 00 	movabs $0x8294c0,%rax
  80869a:	00 00 00 
  80869d:	8b 00                	mov    (%rax),%eax
  80869f:	85 c0                	test   %eax,%eax
  8086a1:	75 54                	jne    8086f7 <tcp_timer_needed+0x68>
  8086a3:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  8086aa:	00 00 00 
  8086ad:	48 8b 00             	mov    (%rax),%rax
  8086b0:	48 85 c0             	test   %rax,%rax
  8086b3:	75 12                	jne    8086c7 <tcp_timer_needed+0x38>
  8086b5:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  8086bc:	00 00 00 
  8086bf:	48 8b 00             	mov    (%rax),%rax
  8086c2:	48 85 c0             	test   %rax,%rax
  8086c5:	74 30                	je     8086f7 <tcp_timer_needed+0x68>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  8086c7:	48 b8 c0 94 82 00 00 	movabs $0x8294c0,%rax
  8086ce:	00 00 00 
  8086d1:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  8086d7:	ba 00 00 00 00       	mov    $0x0,%edx
  8086dc:	48 be 1e 86 80 00 00 	movabs $0x80861e,%rsi
  8086e3:	00 00 00 
  8086e6:	bf fa 00 00 00       	mov    $0xfa,%edi
  8086eb:	48 b8 23 e8 80 00 00 	movabs $0x80e823,%rax
  8086f2:	00 00 00 
  8086f5:	ff d0                	callq  *%rax
  }
}
  8086f7:	90                   	nop
  8086f8:	5d                   	pop    %rbp
  8086f9:	c3                   	retq   

00000000008086fa <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  8086fa:	55                   	push   %rbp
  8086fb:	48 89 e5             	mov    %rsp,%rbp
  8086fe:	48 83 ec 10          	sub    $0x10,%rsp
  808702:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  808706:	48 b8 8a 16 81 00 00 	movabs $0x81168a,%rax
  80870d:	00 00 00 
  808710:	ff d0                	callq  *%rax
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  808712:	ba 00 00 00 00       	mov    $0x0,%edx
  808717:	48 be fa 86 80 00 00 	movabs $0x8086fa,%rsi
  80871e:	00 00 00 
  808721:	bf e8 03 00 00       	mov    $0x3e8,%edi
  808726:	48 b8 23 e8 80 00 00 	movabs $0x80e823,%rax
  80872d:	00 00 00 
  808730:	ff d0                	callq  *%rax
}
  808732:	90                   	nop
  808733:	c9                   	leaveq 
  808734:	c3                   	retq   

0000000000808735 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  808735:	55                   	push   %rbp
  808736:	48 89 e5             	mov    %rsp,%rbp
  808739:	48 83 ec 10          	sub    $0x10,%rsp
  80873d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  808741:	48 b8 9f 5b 81 00 00 	movabs $0x815b9f,%rax
  808748:	00 00 00 
  80874b:	ff d0                	callq  *%rax
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  80874d:	ba 00 00 00 00       	mov    $0x0,%edx
  808752:	48 be 35 87 80 00 00 	movabs $0x808735,%rsi
  808759:	00 00 00 
  80875c:	bf 88 13 00 00       	mov    $0x1388,%edi
  808761:	48 b8 23 e8 80 00 00 	movabs $0x80e823,%rax
  808768:	00 00 00 
  80876b:	ff d0                	callq  *%rax
}
  80876d:	90                   	nop
  80876e:	c9                   	leaveq 
  80876f:	c3                   	retq   

0000000000808770 <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  808770:	55                   	push   %rbp
  808771:	48 89 e5             	mov    %rsp,%rbp
  808774:	48 83 ec 10          	sub    $0x10,%rsp
  808778:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  80877c:	48 b8 b8 98 80 00 00 	movabs $0x8098b8,%rax
  808783:	00 00 00 
  808786:	ff d0                	callq  *%rax
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  808788:	ba 00 00 00 00       	mov    $0x0,%edx
  80878d:	48 be 70 87 80 00 00 	movabs $0x808770,%rsi
  808794:	00 00 00 
  808797:	bf 60 ea 00 00       	mov    $0xea60,%edi
  80879c:	48 b8 23 e8 80 00 00 	movabs $0x80e823,%rax
  8087a3:	00 00 00 
  8087a6:	ff d0                	callq  *%rax
}
  8087a8:	90                   	nop
  8087a9:	c9                   	leaveq 
  8087aa:	c3                   	retq   

00000000008087ab <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  8087ab:	55                   	push   %rbp
  8087ac:	48 89 e5             	mov    %rsp,%rbp
  8087af:	48 83 ec 10          	sub    $0x10,%rsp
  8087b3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  8087b7:	48 b8 4f 99 80 00 00 	movabs $0x80994f,%rax
  8087be:	00 00 00 
  8087c1:	ff d0                	callq  *%rax
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8087c3:	ba 00 00 00 00       	mov    $0x0,%edx
  8087c8:	48 be ab 87 80 00 00 	movabs $0x8087ab,%rsi
  8087cf:	00 00 00 
  8087d2:	bf f4 01 00 00       	mov    $0x1f4,%edi
  8087d7:	48 b8 23 e8 80 00 00 	movabs $0x80e823,%rax
  8087de:	00 00 00 
  8087e1:	ff d0                	callq  *%rax
}
  8087e3:	90                   	nop
  8087e4:	c9                   	leaveq 
  8087e5:	c3                   	retq   

00000000008087e6 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  8087e6:	55                   	push   %rbp
  8087e7:	48 89 e5             	mov    %rsp,%rbp
  8087ea:	48 83 ec 20          	sub    $0x20,%rsp
  8087ee:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  8087f2:	ba 00 00 00 00       	mov    $0x0,%edx
  8087f7:	48 be fa 86 80 00 00 	movabs $0x8086fa,%rsi
  8087fe:	00 00 00 
  808801:	bf e8 03 00 00       	mov    $0x3e8,%edi
  808806:	48 b8 23 e8 80 00 00 	movabs $0x80e823,%rax
  80880d:	00 00 00 
  808810:	ff d0                	callq  *%rax
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  808812:	ba 00 00 00 00       	mov    $0x0,%edx
  808817:	48 be 35 87 80 00 00 	movabs $0x808735,%rsi
  80881e:	00 00 00 
  808821:	bf 88 13 00 00       	mov    $0x1388,%edi
  808826:	48 b8 23 e8 80 00 00 	movabs $0x80e823,%rax
  80882d:	00 00 00 
  808830:	ff d0                	callq  *%rax
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  808832:	ba 00 00 00 00       	mov    $0x0,%edx
  808837:	48 be 70 87 80 00 00 	movabs $0x808770,%rsi
  80883e:	00 00 00 
  808841:	bf 60 ea 00 00       	mov    $0xea60,%edi
  808846:	48 b8 23 e8 80 00 00 	movabs $0x80e823,%rax
  80884d:	00 00 00 
  808850:	ff d0                	callq  *%rax
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  808852:	ba 00 00 00 00       	mov    $0x0,%edx
  808857:	48 be ab 87 80 00 00 	movabs $0x8087ab,%rsi
  80885e:	00 00 00 
  808861:	bf f4 01 00 00       	mov    $0x1f4,%edi
  808866:	48 b8 23 e8 80 00 00 	movabs $0x80e823,%rax
  80886d:	00 00 00 
  808870:	ff d0                	callq  *%rax
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  808872:	48 b8 b0 94 82 00 00 	movabs $0x8294b0,%rax
  808879:	00 00 00 
  80887c:	48 8b 00             	mov    (%rax),%rax
  80887f:	48 85 c0             	test   %rax,%rax
  808882:	74 1f                	je     8088a3 <tcpip_thread+0xbd>
    tcpip_init_done(tcpip_init_done_arg);
  808884:	48 b8 b0 94 82 00 00 	movabs $0x8294b0,%rax
  80888b:	00 00 00 
  80888e:	48 8b 00             	mov    (%rax),%rax
  808891:	48 ba b8 94 82 00 00 	movabs $0x8294b8,%rdx
  808898:	00 00 00 
  80889b:	48 8b 12             	mov    (%rdx),%rdx
  80889e:	48 89 d7             	mov    %rdx,%rdi
  8088a1:	ff d0                	callq  *%rax
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  8088a3:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8088aa:	00 00 00 
  8088ad:	8b 00                	mov    (%rax),%eax
  8088af:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  8088b3:	48 89 d6             	mov    %rdx,%rsi
  8088b6:	89 c7                	mov    %eax,%edi
  8088b8:	48 b8 c2 e5 80 00 00 	movabs $0x80e5c2,%rax
  8088bf:	00 00 00 
  8088c2:	ff d0                	callq  *%rax
    switch (msg->type) {
  8088c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8088c8:	8b 00                	mov    (%rax),%eax
  8088ca:	83 f8 01             	cmp    $0x1,%eax
  8088cd:	74 3d                	je     80890c <tcpip_thread+0x126>
  8088cf:	83 f8 01             	cmp    $0x1,%eax
  8088d2:	72 17                	jb     8088eb <tcpip_thread+0x105>
  8088d4:	83 f8 02             	cmp    $0x2,%eax
  8088d7:	0f 84 a8 00 00 00    	je     808985 <tcpip_thread+0x19f>
  8088dd:	83 f8 03             	cmp    $0x3,%eax
  8088e0:	0f 84 ce 00 00 00    	je     8089b4 <tcpip_thread+0x1ce>
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
      break;

    default:
      break;
  8088e6:	e9 3a 01 00 00       	jmpq   808a25 <tcpip_thread+0x23f>
    sys_mbox_fetch(mbox, (void *)&msg);
    switch (msg->type) {
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  8088eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8088ef:	48 8b 40 10          	mov    0x10(%rax),%rax
  8088f3:	48 8b 00             	mov    (%rax),%rax
  8088f6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8088fa:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8088fe:	48 83 c2 08          	add    $0x8,%rdx
  808902:	48 89 d7             	mov    %rdx,%rdi
  808905:	ff d0                	callq  *%rax
      break;
  808907:	e9 19 01 00 00       	jmpq   808a25 <tcpip_thread+0x23f>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  80890c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808910:	48 8b 40 18          	mov    0x18(%rax),%rax
  808914:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  808918:	0f b6 c0             	movzbl %al,%eax
  80891b:	83 e0 20             	and    $0x20,%eax
  80891e:	85 c0                	test   %eax,%eax
  808920:	74 24                	je     808946 <tcpip_thread+0x160>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  808922:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808926:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80892a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80892e:	48 8b 40 10          	mov    0x10(%rax),%rax
  808932:	48 89 d6             	mov    %rdx,%rsi
  808935:	48 89 c7             	mov    %rax,%rdi
  808938:	48 b8 45 74 81 00 00 	movabs $0x817445,%rax
  80893f:	00 00 00 
  808942:	ff d0                	callq  *%rax
  808944:	eb 22                	jmp    808968 <tcpip_thread+0x182>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  808946:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80894a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80894e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808952:	48 8b 40 10          	mov    0x10(%rax),%rax
  808956:	48 89 d6             	mov    %rdx,%rsi
  808959:	48 89 c7             	mov    %rax,%rdi
  80895c:	48 b8 bf 0e 81 00 00 	movabs $0x810ebf,%rax
  808963:	00 00 00 
  808966:	ff d0                	callq  *%rax
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  808968:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80896c:	48 89 c6             	mov    %rax,%rsi
  80896f:	bf 09 00 00 00       	mov    $0x9,%edi
  808974:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80897b:	00 00 00 
  80897e:	ff d0                	callq  *%rax
      break;
  808980:	e9 a0 00 00 00       	jmpq   808a25 <tcpip_thread+0x23f>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  808985:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808989:	48 8b 40 10          	mov    0x10(%rax),%rax
  80898d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808991:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  808995:	48 89 d7             	mov    %rdx,%rdi
  808998:	ff d0                	callq  *%rax
      memp_free(MEMP_TCPIP_MSG_API, msg);
  80899a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80899e:	48 89 c6             	mov    %rax,%rsi
  8089a1:	bf 08 00 00 00       	mov    $0x8,%edi
  8089a6:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  8089ad:	00 00 00 
  8089b0:	ff d0                	callq  *%rax
      break;
  8089b2:	eb 71                	jmp    808a25 <tcpip_thread+0x23f>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  8089b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089b8:	8b 40 10             	mov    0x10(%rax),%eax
  8089bb:	83 f8 ff             	cmp    $0xffffffff,%eax
  8089be:	74 2a                	je     8089ea <tcpip_thread+0x204>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  8089c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089c4:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8089c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089cc:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8089d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089d4:	8b 40 10             	mov    0x10(%rax),%eax
  8089d7:	48 89 ce             	mov    %rcx,%rsi
  8089da:	89 c7                	mov    %eax,%edi
  8089dc:	48 b8 23 e8 80 00 00 	movabs $0x80e823,%rax
  8089e3:	00 00 00 
  8089e6:	ff d0                	callq  *%rax
  8089e8:	eb 22                	jmp    808a0c <tcpip_thread+0x226>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  8089ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089ee:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8089f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089f6:	48 8b 40 18          	mov    0x18(%rax),%rax
  8089fa:	48 89 d6             	mov    %rdx,%rsi
  8089fd:	48 89 c7             	mov    %rax,%rdi
  808a00:	48 b8 0c ea 80 00 00 	movabs $0x80ea0c,%rax
  808a07:	00 00 00 
  808a0a:	ff d0                	callq  *%rax
      memp_free(MEMP_TCPIP_MSG_API, msg);
  808a0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a10:	48 89 c6             	mov    %rax,%rsi
  808a13:	bf 08 00 00 00       	mov    $0x8,%edi
  808a18:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  808a1f:	00 00 00 
  808a22:	ff d0                	callq  *%rax
      break;
  808a24:	90                   	nop

    default:
      break;
    }
  }
  808a25:	e9 79 fe ff ff       	jmpq   8088a3 <tcpip_thread+0xbd>

0000000000808a2a <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  808a2a:	55                   	push   %rbp
  808a2b:	48 89 e5             	mov    %rsp,%rbp
  808a2e:	48 83 ec 20          	sub    $0x20,%rsp
  808a32:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  808a36:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  808a3a:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808a41:	00 00 00 
  808a44:	8b 00                	mov    (%rax),%eax
  808a46:	83 f8 ff             	cmp    $0xffffffff,%eax
  808a49:	0f 84 90 00 00 00    	je     808adf <tcpip_input+0xb5>
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  808a4f:	bf 09 00 00 00       	mov    $0x9,%edi
  808a54:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  808a5b:	00 00 00 
  808a5e:	ff d0                	callq  *%rax
  808a60:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  808a64:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808a69:	75 07                	jne    808a72 <tcpip_input+0x48>
      return ERR_MEM;
  808a6b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808a70:	eb 72                	jmp    808ae4 <tcpip_input+0xba>
    }

    msg->type = TCPIP_MSG_INPKT;
  808a72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a76:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    msg->msg.inp.p = p;
  808a7c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a80:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  808a84:	48 89 50 10          	mov    %rdx,0x10(%rax)
    msg->msg.inp.netif = inp;
  808a88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a8c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  808a90:	48 89 50 18          	mov    %rdx,0x18(%rax)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  808a94:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808a9b:	00 00 00 
  808a9e:	8b 00                	mov    (%rax),%eax
  808aa0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808aa4:	48 89 d6             	mov    %rdx,%rsi
  808aa7:	89 c7                	mov    %eax,%edi
  808aa9:	48 b8 6b 7c 81 00 00 	movabs $0x817c6b,%rax
  808ab0:	00 00 00 
  808ab3:	ff d0                	callq  *%rax
  808ab5:	84 c0                	test   %al,%al
  808ab7:	74 1f                	je     808ad8 <tcpip_input+0xae>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  808ab9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808abd:	48 89 c6             	mov    %rax,%rsi
  808ac0:	bf 09 00 00 00       	mov    $0x9,%edi
  808ac5:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  808acc:	00 00 00 
  808acf:	ff d0                	callq  *%rax
      return ERR_MEM;
  808ad1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808ad6:	eb 0c                	jmp    808ae4 <tcpip_input+0xba>
    }
    return ERR_OK;
  808ad8:	b8 00 00 00 00       	mov    $0x0,%eax
  808add:	eb 05                	jmp    808ae4 <tcpip_input+0xba>
  }
  return ERR_VAL;
  808adf:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808ae4:	c9                   	leaveq 
  808ae5:	c3                   	retq   

0000000000808ae6 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  808ae6:	55                   	push   %rbp
  808ae7:	48 89 e5             	mov    %rsp,%rbp
  808aea:	48 83 ec 30          	sub    $0x30,%rsp
  808aee:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  808af2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  808af6:	89 d0                	mov    %edx,%eax
  808af8:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  808afb:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808b02:	00 00 00 
  808b05:	8b 00                	mov    (%rax),%eax
  808b07:	83 f8 ff             	cmp    $0xffffffff,%eax
  808b0a:	0f 84 bc 00 00 00    	je     808bcc <tcpip_callback_with_block+0xe6>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  808b10:	bf 08 00 00 00       	mov    $0x8,%edi
  808b15:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  808b1c:	00 00 00 
  808b1f:	ff d0                	callq  *%rax
  808b21:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  808b25:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808b2a:	75 0a                	jne    808b36 <tcpip_callback_with_block+0x50>
      return ERR_MEM;
  808b2c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808b31:	e9 9b 00 00 00       	jmpq   808bd1 <tcpip_callback_with_block+0xeb>
    }

    msg->type = TCPIP_MSG_CALLBACK;
  808b36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b3a:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
    msg->msg.cb.f = f;
  808b40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b44:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  808b48:	48 89 50 10          	mov    %rdx,0x10(%rax)
    msg->msg.cb.ctx = ctx;
  808b4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b50:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  808b54:	48 89 50 18          	mov    %rdx,0x18(%rax)
    if (block) {
  808b58:	80 7d dc 00          	cmpb   $0x0,-0x24(%rbp)
  808b5c:	74 23                	je     808b81 <tcpip_callback_with_block+0x9b>
      sys_mbox_post(mbox, msg);
  808b5e:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808b65:	00 00 00 
  808b68:	8b 00                	mov    (%rax),%eax
  808b6a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808b6e:	48 89 d6             	mov    %rdx,%rsi
  808b71:	89 c7                	mov    %eax,%edi
  808b73:	48 b8 08 7c 81 00 00 	movabs $0x817c08,%rax
  808b7a:	00 00 00 
  808b7d:	ff d0                	callq  *%rax
  808b7f:	eb 44                	jmp    808bc5 <tcpip_callback_with_block+0xdf>
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  808b81:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808b88:	00 00 00 
  808b8b:	8b 00                	mov    (%rax),%eax
  808b8d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808b91:	48 89 d6             	mov    %rdx,%rsi
  808b94:	89 c7                	mov    %eax,%edi
  808b96:	48 b8 6b 7c 81 00 00 	movabs $0x817c6b,%rax
  808b9d:	00 00 00 
  808ba0:	ff d0                	callq  *%rax
  808ba2:	84 c0                	test   %al,%al
  808ba4:	74 1f                	je     808bc5 <tcpip_callback_with_block+0xdf>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  808ba6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808baa:	48 89 c6             	mov    %rax,%rsi
  808bad:	bf 08 00 00 00       	mov    $0x8,%edi
  808bb2:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  808bb9:	00 00 00 
  808bbc:	ff d0                	callq  *%rax
        return ERR_MEM;
  808bbe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808bc3:	eb 0c                	jmp    808bd1 <tcpip_callback_with_block+0xeb>
      }
    }
    return ERR_OK;
  808bc5:	b8 00 00 00 00       	mov    $0x0,%eax
  808bca:	eb 05                	jmp    808bd1 <tcpip_callback_with_block+0xeb>
  }
  return ERR_VAL;
  808bcc:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808bd1:	c9                   	leaveq 
  808bd2:	c3                   	retq   

0000000000808bd3 <tcpip_timeout>:

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  808bd3:	55                   	push   %rbp
  808bd4:	48 89 e5             	mov    %rsp,%rbp
  808bd7:	48 83 ec 30          	sub    $0x30,%rsp
  808bdb:	89 7d ec             	mov    %edi,-0x14(%rbp)
  808bde:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  808be2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  808be6:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808bed:	00 00 00 
  808bf0:	8b 00                	mov    (%rax),%eax
  808bf2:	83 f8 ff             	cmp    $0xffffffff,%eax
  808bf5:	74 77                	je     808c6e <tcpip_timeout+0x9b>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  808bf7:	bf 08 00 00 00       	mov    $0x8,%edi
  808bfc:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  808c03:	00 00 00 
  808c06:	ff d0                	callq  *%rax
  808c08:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  808c0c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808c11:	75 07                	jne    808c1a <tcpip_timeout+0x47>
      return ERR_MEM;
  808c13:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808c18:	eb 59                	jmp    808c73 <tcpip_timeout+0xa0>
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  808c1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c1e:	c7 00 03 00 00 00    	movl   $0x3,(%rax)
    msg->msg.tmo.msecs = msecs;
  808c24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c28:	8b 55 ec             	mov    -0x14(%rbp),%edx
  808c2b:	89 50 10             	mov    %edx,0x10(%rax)
    msg->msg.tmo.h = h;
  808c2e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c32:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  808c36:	48 89 50 18          	mov    %rdx,0x18(%rax)
    msg->msg.tmo.arg = arg;
  808c3a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c3e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  808c42:	48 89 50 20          	mov    %rdx,0x20(%rax)
    sys_mbox_post(mbox, msg);
  808c46:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808c4d:	00 00 00 
  808c50:	8b 00                	mov    (%rax),%eax
  808c52:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808c56:	48 89 d6             	mov    %rdx,%rsi
  808c59:	89 c7                	mov    %eax,%edi
  808c5b:	48 b8 08 7c 81 00 00 	movabs $0x817c08,%rax
  808c62:	00 00 00 
  808c65:	ff d0                	callq  *%rax
    return ERR_OK;
  808c67:	b8 00 00 00 00       	mov    $0x0,%eax
  808c6c:	eb 05                	jmp    808c73 <tcpip_timeout+0xa0>
  }
  return ERR_VAL;
  808c6e:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808c73:	c9                   	leaveq 
  808c74:	c3                   	retq   

0000000000808c75 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  808c75:	55                   	push   %rbp
  808c76:	48 89 e5             	mov    %rsp,%rbp
  808c79:	48 83 ec 40          	sub    $0x40,%rsp
  808c7d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  808c81:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808c88:	00 00 00 
  808c8b:	8b 00                	mov    (%rax),%eax
  808c8d:	83 f8 ff             	cmp    $0xffffffff,%eax
  808c90:	74 55                	je     808ce7 <tcpip_apimsg+0x72>
    msg.type = TCPIP_MSG_API;
  808c92:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%rbp)
    msg.msg.apimsg = apimsg;
  808c99:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  808c9d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    sys_mbox_post(mbox, &msg);
  808ca1:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808ca8:	00 00 00 
  808cab:	8b 00                	mov    (%rax),%eax
  808cad:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  808cb1:	48 89 d6             	mov    %rdx,%rsi
  808cb4:	89 c7                	mov    %eax,%edi
  808cb6:	48 b8 08 7c 81 00 00 	movabs $0x817c08,%rax
  808cbd:	00 00 00 
  808cc0:	ff d0                	callq  *%rax
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  808cc2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  808cc6:	48 8b 40 08          	mov    0x8(%rax),%rax
  808cca:	8b 40 14             	mov    0x14(%rax),%eax
  808ccd:	be 00 00 00 00       	mov    $0x0,%esi
  808cd2:	89 c7                	mov    %eax,%edi
  808cd4:	48 b8 6f 82 81 00 00 	movabs $0x81826f,%rax
  808cdb:	00 00 00 
  808cde:	ff d0                	callq  *%rax
    return ERR_OK;
  808ce0:	b8 00 00 00 00       	mov    $0x0,%eax
  808ce5:	eb 05                	jmp    808cec <tcpip_apimsg+0x77>
  }
  return ERR_VAL;
  808ce7:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808cec:	c9                   	leaveq 
  808ced:	c3                   	retq   

0000000000808cee <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  808cee:	55                   	push   %rbp
  808cef:	48 89 e5             	mov    %rsp,%rbp
  808cf2:	48 83 ec 10          	sub    $0x10,%rsp
  808cf6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808cfa:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  lwip_init();
  808cfe:	48 b8 a8 93 80 00 00 	movabs $0x8093a8,%rax
  808d05:	00 00 00 
  808d08:	ff d0                	callq  *%rax

  tcpip_init_done = initfunc;
  808d0a:	48 b8 b0 94 82 00 00 	movabs $0x8294b0,%rax
  808d11:	00 00 00 
  808d14:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808d18:	48 89 10             	mov    %rdx,(%rax)
  tcpip_init_done_arg = arg;
  808d1b:	48 b8 b8 94 82 00 00 	movabs $0x8294b8,%rax
  808d22:	00 00 00 
  808d25:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808d29:	48 89 10             	mov    %rdx,(%rax)
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  808d2c:	bf 00 00 00 00       	mov    $0x0,%edi
  808d31:	48 b8 de 77 81 00 00 	movabs $0x8177de,%rax
  808d38:	00 00 00 
  808d3b:	ff d0                	callq  *%rax
  808d3d:	89 c2                	mov    %eax,%edx
  808d3f:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808d46:	00 00 00 
  808d49:	89 10                	mov    %edx,(%rax)
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  808d4b:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  808d51:	b9 00 00 00 00       	mov    $0x0,%ecx
  808d56:	ba 00 00 00 00       	mov    $0x0,%edx
  808d5b:	48 be e6 87 80 00 00 	movabs $0x8087e6,%rsi
  808d62:	00 00 00 
  808d65:	48 bf 53 19 82 00 00 	movabs $0x821953,%rdi
  808d6c:	00 00 00 
  808d6f:	48 b8 b0 87 81 00 00 	movabs $0x8187b0,%rax
  808d76:	00 00 00 
  808d79:	ff d0                	callq  *%rax
}
  808d7b:	90                   	nop
  808d7c:	c9                   	leaveq 
  808d7d:	c3                   	retq   

0000000000808d7e <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  808d7e:	55                   	push   %rbp
  808d7f:	48 89 e5             	mov    %rsp,%rbp
  808d82:	48 83 ec 20          	sub    $0x20,%rsp
  808d86:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct pbuf *q = p;
  808d8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808d8e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  pbuf_free(q);
  808d92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d96:	48 89 c7             	mov    %rax,%rdi
  808d99:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  808da0:	00 00 00 
  808da3:	ff d0                	callq  *%rax
}
  808da5:	90                   	nop
  808da6:	c9                   	leaveq 
  808da7:	c3                   	retq   

0000000000808da8 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  808da8:	55                   	push   %rbp
  808da9:	48 89 e5             	mov    %rsp,%rbp
  808dac:	48 83 ec 10          	sub    $0x10,%rsp
  808db0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  808db4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808db8:	ba 00 00 00 00       	mov    $0x0,%edx
  808dbd:	48 89 c6             	mov    %rax,%rsi
  808dc0:	48 bf 7e 8d 80 00 00 	movabs $0x808d7e,%rdi
  808dc7:	00 00 00 
  808dca:	48 b8 e6 8a 80 00 00 	movabs $0x808ae6,%rax
  808dd1:	00 00 00 
  808dd4:	ff d0                	callq  *%rax
}
  808dd6:	c9                   	leaveq 
  808dd7:	c3                   	retq   

0000000000808dd8 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  808dd8:	55                   	push   %rbp
  808dd9:	48 89 e5             	mov    %rsp,%rbp
  808ddc:	48 83 ec 10          	sub    $0x10,%rsp
  808de0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return tcpip_callback_with_block(mem_free, m, 0);
  808de4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808de8:	ba 00 00 00 00       	mov    $0x0,%edx
  808ded:	48 89 c6             	mov    %rax,%rsi
  808df0:	48 bf f2 c4 80 00 00 	movabs $0x80c4f2,%rdi
  808df7:	00 00 00 
  808dfa:	48 b8 e6 8a 80 00 00 	movabs $0x808ae6,%rax
  808e01:	00 00 00 
  808e04:	ff d0                	callq  *%rax
}
  808e06:	c9                   	leaveq 
  808e07:	c3                   	retq   

0000000000808e08 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  808e08:	55                   	push   %rbp
  808e09:	48 89 e5             	mov    %rsp,%rbp
  808e0c:	48 83 ec 10          	sub    $0x10,%rsp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  808e10:	bf 06 00 00 00       	mov    $0x6,%edi
  808e15:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  808e1c:	00 00 00 
  808e1f:	ff d0                	callq  *%rax
  808e21:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (buf != NULL) {
  808e25:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808e2a:	74 29                	je     808e55 <netbuf_new+0x4d>
    buf->p = NULL;
  808e2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e30:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    buf->ptr = NULL;
  808e37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e3b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808e42:	00 
    buf->addr = NULL;
  808e43:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e47:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  808e4e:	00 
    return buf;
  808e4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e53:	eb 05                	jmp    808e5a <netbuf_new+0x52>
  } else {
    return NULL;
  808e55:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
  808e5a:	c9                   	leaveq 
  808e5b:	c3                   	retq   

0000000000808e5c <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  808e5c:	55                   	push   %rbp
  808e5d:	48 89 e5             	mov    %rsp,%rbp
  808e60:	48 83 ec 10          	sub    $0x10,%rsp
  808e64:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (buf != NULL) {
  808e68:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808e6d:	74 55                	je     808ec4 <netbuf_delete+0x68>
    if (buf->p != NULL) {
  808e6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e73:	48 8b 00             	mov    (%rax),%rax
  808e76:	48 85 c0             	test   %rax,%rax
  808e79:	74 31                	je     808eac <netbuf_delete+0x50>
      pbuf_free(buf->p);
  808e7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e7f:	48 8b 00             	mov    (%rax),%rax
  808e82:	48 89 c7             	mov    %rax,%rdi
  808e85:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  808e8c:	00 00 00 
  808e8f:	ff d0                	callq  *%rax
      buf->p = buf->ptr = NULL;
  808e91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e95:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808e9c:	00 
  808e9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ea1:	48 8b 50 08          	mov    0x8(%rax),%rdx
  808ea5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ea9:	48 89 10             	mov    %rdx,(%rax)
    }
    memp_free(MEMP_NETBUF, buf);
  808eac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808eb0:	48 89 c6             	mov    %rax,%rsi
  808eb3:	bf 06 00 00 00       	mov    $0x6,%edi
  808eb8:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  808ebf:	00 00 00 
  808ec2:	ff d0                	callq  *%rax
  }
}
  808ec4:	90                   	nop
  808ec5:	c9                   	leaveq 
  808ec6:	c3                   	retq   

0000000000808ec7 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  808ec7:	55                   	push   %rbp
  808ec8:	48 89 e5             	mov    %rsp,%rbp
  808ecb:	48 83 ec 10          	sub    $0x10,%rsp
  808ecf:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808ed3:	89 f0                	mov    %esi,%eax
  808ed5:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  808ed9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808ede:	75 2a                	jne    808f0a <netbuf_alloc+0x43>
  808ee0:	48 ba 60 19 82 00 00 	movabs $0x821960,%rdx
  808ee7:	00 00 00 
  808eea:	be 64 00 00 00       	mov    $0x64,%esi
  808eef:	48 bf 7a 19 82 00 00 	movabs $0x82197a,%rdi
  808ef6:	00 00 00 
  808ef9:	b8 00 00 00 00       	mov    $0x0,%eax
  808efe:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  808f05:	00 00 00 
  808f08:	ff d1                	callq  *%rcx

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  808f0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f0e:	48 8b 00             	mov    (%rax),%rax
  808f11:	48 85 c0             	test   %rax,%rax
  808f14:	74 16                	je     808f2c <netbuf_alloc+0x65>
    pbuf_free(buf->p);
  808f16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f1a:	48 8b 00             	mov    (%rax),%rax
  808f1d:	48 89 c7             	mov    %rax,%rdi
  808f20:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  808f27:	00 00 00 
  808f2a:	ff d0                	callq  *%rax
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  808f2c:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  808f30:	ba 00 00 00 00       	mov    $0x0,%edx
  808f35:	89 c6                	mov    %eax,%esi
  808f37:	bf 00 00 00 00       	mov    $0x0,%edi
  808f3c:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  808f43:	00 00 00 
  808f46:	ff d0                	callq  *%rax
  808f48:	48 89 c2             	mov    %rax,%rdx
  808f4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f4f:	48 89 10             	mov    %rdx,(%rax)
  if (buf->p == NULL) {
  808f52:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f56:	48 8b 00             	mov    (%rax),%rax
  808f59:	48 85 c0             	test   %rax,%rax
  808f5c:	75 07                	jne    808f65 <netbuf_alloc+0x9e>
     return NULL;
  808f5e:	b8 00 00 00 00       	mov    $0x0,%eax
  808f63:	eb 55                	jmp    808fba <netbuf_alloc+0xf3>
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  808f65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f69:	48 8b 00             	mov    (%rax),%rax
  808f6c:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  808f70:	66 3b 45 f4          	cmp    -0xc(%rbp),%ax
  808f74:	73 2a                	jae    808fa0 <netbuf_alloc+0xd9>
  808f76:	48 ba 90 19 82 00 00 	movabs $0x821990,%rdx
  808f7d:	00 00 00 
  808f80:	be 6f 00 00 00       	mov    $0x6f,%esi
  808f85:	48 bf 7a 19 82 00 00 	movabs $0x82197a,%rdi
  808f8c:	00 00 00 
  808f8f:	b8 00 00 00 00       	mov    $0x0,%eax
  808f94:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  808f9b:	00 00 00 
  808f9e:	ff d1                	callq  *%rcx
             (buf->p->len >= size));
  buf->ptr = buf->p;
  808fa0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808fa4:	48 8b 10             	mov    (%rax),%rdx
  808fa7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808fab:	48 89 50 08          	mov    %rdx,0x8(%rax)
  return buf->p->payload;
  808faf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808fb3:	48 8b 00             	mov    (%rax),%rax
  808fb6:	48 8b 40 08          	mov    0x8(%rax),%rax
}
  808fba:	c9                   	leaveq 
  808fbb:	c3                   	retq   

0000000000808fbc <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  808fbc:	55                   	push   %rbp
  808fbd:	48 89 e5             	mov    %rsp,%rbp
  808fc0:	48 83 ec 10          	sub    $0x10,%rsp
  808fc4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  808fc8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808fcd:	75 2a                	jne    808ff9 <netbuf_free+0x3d>
  808fcf:	48 ba b4 19 82 00 00 	movabs $0x8219b4,%rdx
  808fd6:	00 00 00 
  808fd9:	be 7c 00 00 00       	mov    $0x7c,%esi
  808fde:	48 bf 7a 19 82 00 00 	movabs $0x82197a,%rdi
  808fe5:	00 00 00 
  808fe8:	b8 00 00 00 00       	mov    $0x0,%eax
  808fed:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  808ff4:	00 00 00 
  808ff7:	ff d1                	callq  *%rcx
  if (buf->p != NULL) {
  808ff9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ffd:	48 8b 00             	mov    (%rax),%rax
  809000:	48 85 c0             	test   %rax,%rax
  809003:	74 16                	je     80901b <netbuf_free+0x5f>
    pbuf_free(buf->p);
  809005:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809009:	48 8b 00             	mov    (%rax),%rax
  80900c:	48 89 c7             	mov    %rax,%rdi
  80900f:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  809016:	00 00 00 
  809019:	ff d0                	callq  *%rax
  }
  buf->p = buf->ptr = NULL;
  80901b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80901f:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  809026:	00 
  809027:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80902b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80902f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809033:	48 89 10             	mov    %rdx,(%rax)
}
  809036:	90                   	nop
  809037:	c9                   	leaveq 
  809038:	c3                   	retq   

0000000000809039 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  809039:	55                   	push   %rbp
  80903a:	48 89 e5             	mov    %rsp,%rbp
  80903d:	48 83 ec 20          	sub    $0x20,%rsp
  809041:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  809045:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  809049:	89 d0                	mov    %edx,%eax
  80904b:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  80904f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809054:	75 2a                	jne    809080 <netbuf_ref+0x47>
  809056:	48 ba cd 19 82 00 00 	movabs $0x8219cd,%rdx
  80905d:	00 00 00 
  809060:	be 8f 00 00 00       	mov    $0x8f,%esi
  809065:	48 bf 7a 19 82 00 00 	movabs $0x82197a,%rdi
  80906c:	00 00 00 
  80906f:	b8 00 00 00 00       	mov    $0x0,%eax
  809074:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80907b:	00 00 00 
  80907e:	ff d1                	callq  *%rcx
  if (buf->p != NULL) {
  809080:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809084:	48 8b 00             	mov    (%rax),%rax
  809087:	48 85 c0             	test   %rax,%rax
  80908a:	74 16                	je     8090a2 <netbuf_ref+0x69>
    pbuf_free(buf->p);
  80908c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809090:	48 8b 00             	mov    (%rax),%rax
  809093:	48 89 c7             	mov    %rax,%rdi
  809096:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  80909d:	00 00 00 
  8090a0:	ff d0                	callq  *%rax
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  8090a2:	ba 02 00 00 00       	mov    $0x2,%edx
  8090a7:	be 00 00 00 00       	mov    $0x0,%esi
  8090ac:	bf 00 00 00 00       	mov    $0x0,%edi
  8090b1:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  8090b8:	00 00 00 
  8090bb:	ff d0                	callq  *%rax
  8090bd:	48 89 c2             	mov    %rax,%rdx
  8090c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090c4:	48 89 10             	mov    %rdx,(%rax)
  if (buf->p == NULL) {
  8090c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090cb:	48 8b 00             	mov    (%rax),%rax
  8090ce:	48 85 c0             	test   %rax,%rax
  8090d1:	75 13                	jne    8090e6 <netbuf_ref+0xad>
    buf->ptr = NULL;
  8090d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090d7:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8090de:	00 
    return ERR_MEM;
  8090df:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8090e4:	eb 41                	jmp    809127 <netbuf_ref+0xee>
  }
  buf->p->payload = (void*)dataptr;
  8090e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090ea:	48 8b 00             	mov    (%rax),%rax
  8090ed:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8090f1:	48 89 50 08          	mov    %rdx,0x8(%rax)
  buf->p->len = buf->p->tot_len = size;
  8090f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090f9:	48 8b 10             	mov    (%rax),%rdx
  8090fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809100:	48 8b 00             	mov    (%rax),%rax
  809103:	0f b7 4d ec          	movzwl -0x14(%rbp),%ecx
  809107:	66 89 48 10          	mov    %cx,0x10(%rax)
  80910b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80910f:	66 89 42 12          	mov    %ax,0x12(%rdx)
  buf->ptr = buf->p;
  809113:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809117:	48 8b 10             	mov    (%rax),%rdx
  80911a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80911e:	48 89 50 08          	mov    %rdx,0x8(%rax)
  return ERR_OK;
  809122:	b8 00 00 00 00       	mov    $0x0,%eax
}
  809127:	c9                   	leaveq 
  809128:	c3                   	retq   

0000000000809129 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  809129:	55                   	push   %rbp
  80912a:	48 89 e5             	mov    %rsp,%rbp
  80912d:	48 83 ec 10          	sub    $0x10,%rsp
  809131:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  809135:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  809139:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80913e:	75 2a                	jne    80916a <netbuf_chain+0x41>
  809140:	48 ba e5 19 82 00 00 	movabs $0x8219e5,%rdx
  809147:	00 00 00 
  80914a:	be a7 00 00 00       	mov    $0xa7,%esi
  80914f:	48 bf 7a 19 82 00 00 	movabs $0x82197a,%rdi
  809156:	00 00 00 
  809159:	b8 00 00 00 00       	mov    $0x0,%eax
  80915e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  809165:	00 00 00 
  809168:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  80916a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80916f:	75 2a                	jne    80919b <netbuf_chain+0x72>
  809171:	48 ba fe 19 82 00 00 	movabs $0x8219fe,%rdx
  809178:	00 00 00 
  80917b:	be a8 00 00 00       	mov    $0xa8,%esi
  809180:	48 bf 7a 19 82 00 00 	movabs $0x82197a,%rdi
  809187:	00 00 00 
  80918a:	b8 00 00 00 00       	mov    $0x0,%eax
  80918f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  809196:	00 00 00 
  809199:	ff d1                	callq  *%rcx
  pbuf_chain(head->p, tail->p);
  80919b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80919f:	48 8b 10             	mov    (%rax),%rdx
  8091a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8091a6:	48 8b 00             	mov    (%rax),%rax
  8091a9:	48 89 d6             	mov    %rdx,%rsi
  8091ac:	48 89 c7             	mov    %rax,%rdi
  8091af:	48 b8 79 e0 80 00 00 	movabs $0x80e079,%rax
  8091b6:	00 00 00 
  8091b9:	ff d0                	callq  *%rax
  head->ptr = head->p;
  8091bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8091bf:	48 8b 10             	mov    (%rax),%rdx
  8091c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8091c6:	48 89 50 08          	mov    %rdx,0x8(%rax)
  memp_free(MEMP_NETBUF, tail);
  8091ca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8091ce:	48 89 c6             	mov    %rax,%rsi
  8091d1:	bf 06 00 00 00       	mov    $0x6,%edi
  8091d6:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  8091dd:	00 00 00 
  8091e0:	ff d0                	callq  *%rax
}
  8091e2:	90                   	nop
  8091e3:	c9                   	leaveq 
  8091e4:	c3                   	retq   

00000000008091e5 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  8091e5:	55                   	push   %rbp
  8091e6:	48 89 e5             	mov    %rsp,%rbp
  8091e9:	48 83 ec 20          	sub    $0x20,%rsp
  8091ed:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8091f1:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8091f5:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  8091f9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8091fe:	75 2a                	jne    80922a <netbuf_data+0x45>
  809200:	48 ba 19 1a 82 00 00 	movabs $0x821a19,%rdx
  809207:	00 00 00 
  80920a:	be ba 00 00 00       	mov    $0xba,%esi
  80920f:	48 bf 7a 19 82 00 00 	movabs $0x82197a,%rdi
  809216:	00 00 00 
  809219:	b8 00 00 00 00       	mov    $0x0,%eax
  80921e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  809225:	00 00 00 
  809228:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  80922a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80922f:	75 2a                	jne    80925b <netbuf_data+0x76>
  809231:	48 ba 32 1a 82 00 00 	movabs $0x821a32,%rdx
  809238:	00 00 00 
  80923b:	be bb 00 00 00       	mov    $0xbb,%esi
  809240:	48 bf 7a 19 82 00 00 	movabs $0x82197a,%rdi
  809247:	00 00 00 
  80924a:	b8 00 00 00 00       	mov    $0x0,%eax
  80924f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  809256:	00 00 00 
  809259:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  80925b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  809260:	75 2a                	jne    80928c <netbuf_data+0xa7>
  809262:	48 ba 4f 1a 82 00 00 	movabs $0x821a4f,%rdx
  809269:	00 00 00 
  80926c:	be bc 00 00 00       	mov    $0xbc,%esi
  809271:	48 bf 7a 19 82 00 00 	movabs $0x82197a,%rdi
  809278:	00 00 00 
  80927b:	b8 00 00 00 00       	mov    $0x0,%eax
  809280:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  809287:	00 00 00 
  80928a:	ff d1                	callq  *%rcx

  if (buf->ptr == NULL) {
  80928c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809290:	48 8b 40 08          	mov    0x8(%rax),%rax
  809294:	48 85 c0             	test   %rax,%rax
  809297:	75 07                	jne    8092a0 <netbuf_data+0xbb>
    return ERR_BUF;
  809299:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80929e:	eb 2b                	jmp    8092cb <netbuf_data+0xe6>
  }
  *dataptr = buf->ptr->payload;
  8092a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8092a4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8092a8:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8092ac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8092b0:	48 89 10             	mov    %rdx,(%rax)
  *len = buf->ptr->len;
  8092b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8092b7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8092bb:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  8092bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8092c3:	66 89 10             	mov    %dx,(%rax)
  return ERR_OK;
  8092c6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8092cb:	c9                   	leaveq 
  8092cc:	c3                   	retq   

00000000008092cd <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  8092cd:	55                   	push   %rbp
  8092ce:	48 89 e5             	mov    %rsp,%rbp
  8092d1:	48 83 ec 10          	sub    $0x10,%rsp
  8092d5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  8092d9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8092de:	75 2a                	jne    80930a <netbuf_next+0x3d>
  8092e0:	48 ba b4 19 82 00 00 	movabs $0x8219b4,%rdx
  8092e7:	00 00 00 
  8092ea:	be d3 00 00 00       	mov    $0xd3,%esi
  8092ef:	48 bf 7a 19 82 00 00 	movabs $0x82197a,%rdi
  8092f6:	00 00 00 
  8092f9:	b8 00 00 00 00       	mov    $0x0,%eax
  8092fe:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  809305:	00 00 00 
  809308:	ff d1                	callq  *%rcx
  if (buf->ptr->next == NULL) {
  80930a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80930e:	48 8b 40 08          	mov    0x8(%rax),%rax
  809312:	48 8b 00             	mov    (%rax),%rax
  809315:	48 85 c0             	test   %rax,%rax
  809318:	75 07                	jne    809321 <netbuf_next+0x54>
    return -1;
  80931a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80931f:	eb 2f                	jmp    809350 <netbuf_next+0x83>
  }
  buf->ptr = buf->ptr->next;
  809321:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809325:	48 8b 40 08          	mov    0x8(%rax),%rax
  809329:	48 8b 10             	mov    (%rax),%rdx
  80932c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809330:	48 89 50 08          	mov    %rdx,0x8(%rax)
  if (buf->ptr->next == NULL) {
  809334:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809338:	48 8b 40 08          	mov    0x8(%rax),%rax
  80933c:	48 8b 00             	mov    (%rax),%rax
  80933f:	48 85 c0             	test   %rax,%rax
  809342:	75 07                	jne    80934b <netbuf_next+0x7e>
    return 1;
  809344:	b8 01 00 00 00       	mov    $0x1,%eax
  809349:	eb 05                	jmp    809350 <netbuf_next+0x83>
  }
  return 0;
  80934b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  809350:	c9                   	leaveq 
  809351:	c3                   	retq   

0000000000809352 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  809352:	55                   	push   %rbp
  809353:	48 89 e5             	mov    %rsp,%rbp
  809356:	48 83 ec 10          	sub    $0x10,%rsp
  80935a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  80935e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809363:	75 2a                	jne    80938f <netbuf_first+0x3d>
  809365:	48 ba b4 19 82 00 00 	movabs $0x8219b4,%rdx
  80936c:	00 00 00 
  80936f:	be e8 00 00 00       	mov    $0xe8,%esi
  809374:	48 bf 7a 19 82 00 00 	movabs $0x82197a,%rdi
  80937b:	00 00 00 
  80937e:	b8 00 00 00 00       	mov    $0x0,%eax
  809383:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80938a:	00 00 00 
  80938d:	ff d1                	callq  *%rcx
  buf->ptr = buf->p;
  80938f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809393:	48 8b 10             	mov    (%rax),%rdx
  809396:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80939a:	48 89 50 08          	mov    %rdx,0x8(%rax)
}
  80939e:	90                   	nop
  80939f:	c9                   	leaveq 
  8093a0:	c3                   	retq   

00000000008093a1 <lwip_sanity_check>:
#endif

#ifdef LWIP_DEBUG
static void
lwip_sanity_check(void)
{
  8093a1:	55                   	push   %rbp
  8093a2:	48 89 e5             	mov    %rsp,%rbp
  if (TCP_WND > (PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE))
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is larger than space provided by PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE\n"));
  if (TCP_WND < TCP_MSS)
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is smaller than MSS\n"));
#endif /* LWIP_TCP */
}
  8093a5:	90                   	nop
  8093a6:	5d                   	pop    %rbp
  8093a7:	c3                   	retq   

00000000008093a8 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  8093a8:	55                   	push   %rbp
  8093a9:	48 89 e5             	mov    %rsp,%rbp
  /* Sanity check user-configurable values */
  lwip_sanity_check();
  8093ac:	48 b8 a1 93 80 00 00 	movabs $0x8093a1,%rax
  8093b3:	00 00 00 
  8093b6:	ff d0                	callq  *%rax

  /* Modules initialization */
  stats_init();
  sys_init();
  8093b8:	48 b8 57 75 81 00 00 	movabs $0x817557,%rax
  8093bf:	00 00 00 
  8093c2:	ff d0                	callq  *%rax
  mem_init();
  8093c4:	48 b8 05 c4 80 00 00 	movabs $0x80c405,%rax
  8093cb:	00 00 00 
  8093ce:	ff d0                	callq  *%rax
  memp_init();
  8093d0:	48 b8 72 cd 80 00 00 	movabs $0x80cd72,%rax
  8093d7:	00 00 00 
  8093da:	ff d0                	callq  *%rax
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  8093dc:	48 b8 b1 5c 80 00 00 	movabs $0x805cb1,%rax
  8093e3:	00 00 00 
  8093e6:	ff d0                	callq  *%rax
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  8093e8:	90                   	nop
  8093e9:	5d                   	pop    %rbp
  8093ea:	c3                   	retq   

00000000008093eb <dhcp_handle_nak>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  8093eb:	55                   	push   %rbp
  8093ec:	48 89 e5             	mov    %rsp,%rbp
  8093ef:	48 83 ec 20          	sub    $0x20,%rsp
  8093f3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  8093f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8093fb:	48 8b 40 38          	mov    0x38(%rax),%rax
  8093ff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  809403:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809407:	48 89 c7             	mov    %rax,%rdi
  80940a:	48 b8 16 d4 80 00 00 	movabs $0x80d416,%rax
  809411:	00 00 00 
  809414:	ff d0                	callq  *%rax
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  809416:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80941a:	48 be 68 28 82 00 00 	movabs $0x822868,%rsi
  809421:	00 00 00 
  809424:	48 89 c7             	mov    %rax,%rdi
  809427:	48 b8 29 d2 80 00 00 	movabs $0x80d229,%rax
  80942e:	00 00 00 
  809431:	ff d0                	callq  *%rax
  netif_set_gw(netif, IP_ADDR_ANY);
  809433:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809437:	48 be 68 28 82 00 00 	movabs $0x822868,%rsi
  80943e:	00 00 00 
  809441:	48 89 c7             	mov    %rax,%rdi
  809444:	48 b8 30 d3 80 00 00 	movabs $0x80d330,%rax
  80944b:	00 00 00 
  80944e:	ff d0                	callq  *%rax
  netif_set_netmask(netif, IP_ADDR_ANY); 
  809450:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809454:	48 be 68 28 82 00 00 	movabs $0x822868,%rsi
  80945b:	00 00 00 
  80945e:	48 89 c7             	mov    %rax,%rdi
  809461:	48 b8 5e d3 80 00 00 	movabs $0x80d35e,%rax
  809468:	00 00 00 
  80946b:	ff d0                	callq  *%rax
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  80946d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809471:	be 0c 00 00 00       	mov    $0xc,%esi
  809476:	48 89 c7             	mov    %rax,%rdi
  809479:	48 b8 a2 b1 80 00 00 	movabs $0x80b1a2,%rax
  809480:	00 00 00 
  809483:	ff d0                	callq  *%rax
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  809485:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809489:	48 89 c7             	mov    %rax,%rdi
  80948c:	48 b8 bb a5 80 00 00 	movabs $0x80a5bb,%rax
  809493:	00 00 00 
  809496:	ff d0                	callq  *%rax
}
  809498:	90                   	nop
  809499:	c9                   	leaveq 
  80949a:	c3                   	retq   

000000000080949b <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  80949b:	55                   	push   %rbp
  80949c:	48 89 e5             	mov    %rsp,%rbp
  80949f:	48 83 ec 20          	sub    $0x20,%rsp
  8094a3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  8094a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8094ab:	48 8b 40 38          	mov    0x38(%rax),%rax
  8094af:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  8094b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8094b7:	48 8d 48 4c          	lea    0x4c(%rax),%rcx
  8094bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8094bf:	ba 00 00 00 00       	mov    $0x0,%edx
  8094c4:	48 89 ce             	mov    %rcx,%rsi
  8094c7:	48 89 c7             	mov    %rax,%rdi
  8094ca:	48 b8 fa 6c 81 00 00 	movabs $0x816cfa,%rax
  8094d1:	00 00 00 
  8094d4:	ff d0                	callq  *%rax
  8094d6:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  8094d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8094dd:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8094e1:	8d 50 01             	lea    0x1(%rax),%edx
  8094e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8094e8:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = 500;
  8094eb:	66 c7 45 f4 f4 01    	movw   $0x1f4,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8094f1:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  8094f5:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  8094fb:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  809500:	89 c8                	mov    %ecx,%eax
  809502:	f7 ea                	imul   %edx
  809504:	c1 fa 05             	sar    $0x5,%edx
  809507:	89 c8                	mov    %ecx,%eax
  809509:	c1 f8 1f             	sar    $0x1f,%eax
  80950c:	29 c2                	sub    %eax,%edx
  80950e:	89 d0                	mov    %edx,%eax
  809510:	89 c2                	mov    %eax,%edx
  809512:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809516:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  80951a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80951e:	be 08 00 00 00       	mov    $0x8,%esi
  809523:	48 89 c7             	mov    %rax,%rdi
  809526:	48 b8 a2 b1 80 00 00 	movabs $0x80b1a2,%rax
  80952d:	00 00 00 
  809530:	ff d0                	callq  *%rax
}
  809532:	90                   	nop
  809533:	c9                   	leaveq 
  809534:	c3                   	retq   

0000000000809535 <dhcp_handle_offer>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  809535:	55                   	push   %rbp
  809536:	48 89 e5             	mov    %rsp,%rbp
  809539:	48 83 ec 20          	sub    $0x20,%rsp
  80953d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809541:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809545:	48 8b 40 38          	mov    0x38(%rax),%rax
  809549:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  80954d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809551:	be 36 00 00 00       	mov    $0x36,%esi
  809556:	48 89 c7             	mov    %rax,%rdi
  809559:	48 b8 8a bf 80 00 00 	movabs $0x80bf8a,%rax
  809560:	00 00 00 
  809563:	ff d0                	callq  *%rax
  809565:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  809569:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80956e:	74 6b                	je     8095db <dhcp_handle_offer+0xa6>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  809570:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809574:	48 83 c0 02          	add    $0x2,%rax
  809578:	48 89 c7             	mov    %rax,%rdi
  80957b:	48 b8 61 c1 80 00 00 	movabs $0x80c161,%rax
  809582:	00 00 00 
  809585:	ff d0                	callq  *%rax
  809587:	89 c7                	mov    %eax,%edi
  809589:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  809590:	00 00 00 
  809593:	ff d0                	callq  *%rax
  809595:	89 c2                	mov    %eax,%edx
  809597:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80959b:	89 50 48             	mov    %edx,0x48(%rax)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  80959e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095a2:	48 8b 40 18          	mov    0x18(%rax),%rax
  8095a6:	48 83 c0 10          	add    $0x10,%rax
  8095aa:	48 85 c0             	test   %rax,%rax
  8095ad:	74 0d                	je     8095bc <dhcp_handle_offer+0x87>
  8095af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095b3:	48 8b 40 18          	mov    0x18(%rax),%rax
  8095b7:	8b 40 10             	mov    0x10(%rax),%eax
  8095ba:	eb 05                	jmp    8095c1 <dhcp_handle_offer+0x8c>
  8095bc:	b8 00 00 00 00       	mov    $0x0,%eax
  8095c1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8095c5:	89 42 4c             	mov    %eax,0x4c(%rdx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  8095c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8095cc:	48 89 c7             	mov    %rax,%rdi
  8095cf:	48 b8 de 95 80 00 00 	movabs $0x8095de,%rax
  8095d6:	00 00 00 
  8095d9:	ff d0                	callq  *%rax
  }
}
  8095db:	90                   	nop
  8095dc:	c9                   	leaveq 
  8095dd:	c3                   	retq   

00000000008095de <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  8095de:	55                   	push   %rbp
  8095df:	48 89 e5             	mov    %rsp,%rbp
  8095e2:	48 83 ec 20          	sub    $0x20,%rsp
  8095e6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  8095ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8095ee:	48 8b 40 38          	mov    0x38(%rax),%rax
  8095f2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8095f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8095fa:	48 89 c7             	mov    %rax,%rdi
  8095fd:	48 b8 b2 b9 80 00 00 	movabs $0x80b9b2,%rax
  809604:	00 00 00 
  809607:	ff d0                	callq  *%rax
  809609:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80960c:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  809610:	0f 85 3a 02 00 00    	jne    809850 <dhcp_select+0x272>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  809616:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80961a:	ba 01 00 00 00       	mov    $0x1,%edx
  80961f:	be 35 00 00 00       	mov    $0x35,%esi
  809624:	48 89 c7             	mov    %rax,%rdi
  809627:	48 b8 d4 b1 80 00 00 	movabs $0x80b1d4,%rax
  80962e:	00 00 00 
  809631:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  809633:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809637:	be 03 00 00 00       	mov    $0x3,%esi
  80963c:	48 89 c7             	mov    %rax,%rdi
  80963f:	48 b8 86 b2 80 00 00 	movabs $0x80b286,%rax
  809646:	00 00 00 
  809649:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80964b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80964f:	ba 02 00 00 00       	mov    $0x2,%edx
  809654:	be 39 00 00 00       	mov    $0x39,%esi
  809659:	48 89 c7             	mov    %rax,%rdi
  80965c:	48 b8 d4 b1 80 00 00 	movabs $0x80b1d4,%rax
  809663:	00 00 00 
  809666:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  809668:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80966c:	be 40 02 00 00       	mov    $0x240,%esi
  809671:	48 89 c7             	mov    %rax,%rdi
  809674:	48 b8 fd b2 80 00 00 	movabs $0x80b2fd,%rax
  80967b:	00 00 00 
  80967e:	ff d0                	callq  *%rax

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  809680:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809684:	ba 04 00 00 00       	mov    $0x4,%edx
  809689:	be 32 00 00 00       	mov    $0x32,%esi
  80968e:	48 89 c7             	mov    %rax,%rdi
  809691:	48 b8 d4 b1 80 00 00 	movabs $0x80b1d4,%rax
  809698:	00 00 00 
  80969b:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  80969d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096a1:	8b 40 4c             	mov    0x4c(%rax),%eax
  8096a4:	89 c7                	mov    %eax,%edi
  8096a6:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  8096ad:	00 00 00 
  8096b0:	ff d0                	callq  *%rax
  8096b2:	89 c2                	mov    %eax,%edx
  8096b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096b8:	89 d6                	mov    %edx,%esi
  8096ba:	48 89 c7             	mov    %rax,%rdi
  8096bd:	48 b8 a9 b3 80 00 00 	movabs $0x80b3a9,%rax
  8096c4:	00 00 00 
  8096c7:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  8096c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096cd:	ba 04 00 00 00       	mov    $0x4,%edx
  8096d2:	be 36 00 00 00       	mov    $0x36,%esi
  8096d7:	48 89 c7             	mov    %rax,%rdi
  8096da:	48 b8 d4 b1 80 00 00 	movabs $0x80b1d4,%rax
  8096e1:	00 00 00 
  8096e4:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  8096e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096ea:	8b 40 48             	mov    0x48(%rax),%eax
  8096ed:	89 c7                	mov    %eax,%edi
  8096ef:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  8096f6:	00 00 00 
  8096f9:	ff d0                	callq  *%rax
  8096fb:	89 c2                	mov    %eax,%edx
  8096fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809701:	89 d6                	mov    %edx,%esi
  809703:	48 89 c7             	mov    %rax,%rdi
  809706:	48 b8 a9 b3 80 00 00 	movabs $0x80b3a9,%rax
  80970d:	00 00 00 
  809710:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  809712:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809716:	ba 04 00 00 00       	mov    $0x4,%edx
  80971b:	be 37 00 00 00       	mov    $0x37,%esi
  809720:	48 89 c7             	mov    %rax,%rdi
  809723:	48 b8 d4 b1 80 00 00 	movabs $0x80b1d4,%rax
  80972a:	00 00 00 
  80972d:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  80972f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809733:	be 01 00 00 00       	mov    $0x1,%esi
  809738:	48 89 c7             	mov    %rax,%rdi
  80973b:	48 b8 86 b2 80 00 00 	movabs $0x80b286,%rax
  809742:	00 00 00 
  809745:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  809747:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80974b:	be 03 00 00 00       	mov    $0x3,%esi
  809750:	48 89 c7             	mov    %rax,%rdi
  809753:	48 b8 86 b2 80 00 00 	movabs $0x80b286,%rax
  80975a:	00 00 00 
  80975d:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  80975f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809763:	be 1c 00 00 00       	mov    $0x1c,%esi
  809768:	48 89 c7             	mov    %rax,%rdi
  80976b:	48 b8 86 b2 80 00 00 	movabs $0x80b286,%rax
  809772:	00 00 00 
  809775:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  809777:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80977b:	be 06 00 00 00       	mov    $0x6,%esi
  809780:	48 89 c7             	mov    %rax,%rdi
  809783:	48 b8 86 b2 80 00 00 	movabs $0x80b286,%rax
  80978a:	00 00 00 
  80978d:	ff d0                	callq  *%rax
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  80978f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809793:	48 89 c7             	mov    %rax,%rdi
  809796:	48 b8 31 be 80 00 00 	movabs $0x80be31,%rax
  80979d:	00 00 00 
  8097a0:	ff d0                	callq  *%rax
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8097a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097a6:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  8097aa:	66 05 f0 00          	add    $0xf0,%ax
  8097ae:	0f b7 d0             	movzwl %ax,%edx
  8097b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097b5:	48 8b 40 30          	mov    0x30(%rax),%rax
  8097b9:	89 d6                	mov    %edx,%esi
  8097bb:	48 89 c7             	mov    %rax,%rdi
  8097be:	48 b8 3f d9 80 00 00 	movabs $0x80d93f,%rax
  8097c5:	00 00 00 
  8097c8:	ff d0                	callq  *%rax

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8097ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097ce:	48 8b 70 30          	mov    0x30(%rax),%rsi
  8097d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097d6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8097da:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8097de:	49 89 d0             	mov    %rdx,%r8
  8097e1:	b9 43 00 00 00       	mov    $0x43,%ecx
  8097e6:	48 ba 6c 28 82 00 00 	movabs $0x82286c,%rdx
  8097ed:	00 00 00 
  8097f0:	48 89 c7             	mov    %rax,%rdi
  8097f3:	48 b8 38 54 81 00 00 	movabs $0x815438,%rax
  8097fa:	00 00 00 
  8097fd:	ff d0                	callq  *%rax
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8097ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809803:	48 8b 40 08          	mov    0x8(%rax),%rax
  809807:	ba 43 00 00 00       	mov    $0x43,%edx
  80980c:	48 be 68 28 82 00 00 	movabs $0x822868,%rsi
  809813:	00 00 00 
  809816:	48 89 c7             	mov    %rax,%rdi
  809819:	48 b8 42 58 81 00 00 	movabs $0x815842,%rax
  809820:	00 00 00 
  809823:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  809825:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809829:	48 89 c7             	mov    %rax,%rdi
  80982c:	48 b8 0a bd 80 00 00 	movabs $0x80bd0a,%rax
  809833:	00 00 00 
  809836:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  809838:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80983c:	be 01 00 00 00       	mov    $0x1,%esi
  809841:	48 89 c7             	mov    %rax,%rdi
  809844:	48 b8 a2 b1 80 00 00 	movabs $0x80b1a2,%rax
  80984b:	00 00 00 
  80984e:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  809850:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809854:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809858:	8d 50 01             	lea    0x1(%rax),%edx
  80985b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80985f:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  809862:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809866:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80986a:	3c 03                	cmp    $0x3,%al
  80986c:	77 12                	ja     809880 <dhcp_select+0x2a2>
  80986e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809872:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809876:	0f b6 c0             	movzbl %al,%eax
  809879:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80987e:	eb 05                	jmp    809885 <dhcp_select+0x2a7>
  809880:	b8 a0 0f 00 00       	mov    $0xfa0,%eax
  809885:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  809889:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80988d:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  809893:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  809898:	89 c8                	mov    %ecx,%eax
  80989a:	f7 ea                	imul   %edx
  80989c:	c1 fa 05             	sar    $0x5,%edx
  80989f:	89 c8                	mov    %ecx,%eax
  8098a1:	c1 f8 1f             	sar    $0x1f,%eax
  8098a4:	29 c2                	sub    %eax,%edx
  8098a6:	89 d0                	mov    %edx,%eax
  8098a8:	89 c2                	mov    %eax,%edx
  8098aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098ae:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  8098b2:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  8098b6:	c9                   	leaveq 
  8098b7:	c3                   	retq   

00000000008098b8 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  8098b8:	55                   	push   %rbp
  8098b9:	48 89 e5             	mov    %rsp,%rbp
  8098bc:	48 83 ec 10          	sub    $0x10,%rsp
  struct netif *netif = netif_list;
  8098c0:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  8098c7:	00 00 00 
  8098ca:	48 8b 00             	mov    (%rax),%rax
  8098cd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  8098d1:	eb 72                	jmp    809945 <dhcp_coarse_tmr+0x8d>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  8098d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098d7:	48 8b 40 38          	mov    0x38(%rax),%rax
  8098db:	48 85 c0             	test   %rax,%rax
  8098de:	74 5a                	je     80993a <dhcp_coarse_tmr+0x82>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  8098e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098e4:	48 8b 40 38          	mov    0x38(%rax),%rax
  8098e8:	0f b7 50 46          	movzwl 0x46(%rax),%edx
  8098ec:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  8098ef:	66 89 48 46          	mov    %cx,0x46(%rax)
  8098f3:	66 83 fa 01          	cmp    $0x1,%dx
  8098f7:	75 15                	jne    80990e <dhcp_coarse_tmr+0x56>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
  8098f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098fd:	48 89 c7             	mov    %rax,%rdi
  809900:	48 b8 93 9b 80 00 00 	movabs $0x809b93,%rax
  809907:	00 00 00 
  80990a:	ff d0                	callq  *%rax
  80990c:	eb 2c                	jmp    80993a <dhcp_coarse_tmr+0x82>
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  80990e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809912:	48 8b 40 38          	mov    0x38(%rax),%rax
  809916:	0f b7 50 44          	movzwl 0x44(%rax),%edx
  80991a:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  80991d:	66 89 48 44          	mov    %cx,0x44(%rax)
  809921:	66 83 fa 01          	cmp    $0x1,%dx
  809925:	75 13                	jne    80993a <dhcp_coarse_tmr+0x82>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
  809927:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80992b:	48 89 c7             	mov    %rax,%rdi
  80992e:	48 b8 44 9b 80 00 00 	movabs $0x809b44,%rax
  809935:	00 00 00 
  809938:	ff d0                	callq  *%rax
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  80993a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80993e:	48 8b 00             	mov    (%rax),%rax
  809941:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  809945:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80994a:	75 87                	jne    8098d3 <dhcp_coarse_tmr+0x1b>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  80994c:	90                   	nop
  80994d:	c9                   	leaveq 
  80994e:	c3                   	retq   

000000000080994f <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  80994f:	55                   	push   %rbp
  809950:	48 89 e5             	mov    %rsp,%rbp
  809953:	48 83 ec 10          	sub    $0x10,%rsp
  struct netif *netif = netif_list;
  809957:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80995e:	00 00 00 
  809961:	48 8b 00             	mov    (%rax),%rax
  809964:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* loop through netif's */
  while (netif != NULL) {
  809968:	eb 77                	jmp    8099e1 <dhcp_fine_tmr+0x92>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  80996a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80996e:	48 8b 40 38          	mov    0x38(%rax),%rax
  809972:	48 85 c0             	test   %rax,%rax
  809975:	74 5f                	je     8099d6 <dhcp_fine_tmr+0x87>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  809977:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80997b:	48 8b 40 38          	mov    0x38(%rax),%rax
  80997f:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  809983:	66 83 f8 01          	cmp    $0x1,%ax
  809987:	76 15                	jbe    80999e <dhcp_fine_tmr+0x4f>
        netif->dhcp->request_timeout--;
  809989:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80998d:	48 8b 40 38          	mov    0x38(%rax),%rax
  809991:	0f b7 50 42          	movzwl 0x42(%rax),%edx
  809995:	83 ea 01             	sub    $0x1,%edx
  809998:	66 89 50 42          	mov    %dx,0x42(%rax)
  80999c:	eb 38                	jmp    8099d6 <dhcp_fine_tmr+0x87>
      }
      else if (netif->dhcp->request_timeout == 1) {
  80999e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099a2:	48 8b 40 38          	mov    0x38(%rax),%rax
  8099a6:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  8099aa:	66 83 f8 01          	cmp    $0x1,%ax
  8099ae:	75 26                	jne    8099d6 <dhcp_fine_tmr+0x87>
        netif->dhcp->request_timeout--;
  8099b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099b4:	48 8b 40 38          	mov    0x38(%rax),%rax
  8099b8:	0f b7 50 42          	movzwl 0x42(%rax),%edx
  8099bc:	83 ea 01             	sub    $0x1,%edx
  8099bf:	66 89 50 42          	mov    %dx,0x42(%rax)
        /* { netif->dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
  8099c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099c7:	48 89 c7             	mov    %rax,%rdi
  8099ca:	48 b8 eb 99 80 00 00 	movabs $0x8099eb,%rax
  8099d1:	00 00 00 
  8099d4:	ff d0                	callq  *%rax
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  8099d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099da:	48 8b 00             	mov    (%rax),%rax
  8099dd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  8099e1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8099e6:	75 82                	jne    80996a <dhcp_fine_tmr+0x1b>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  8099e8:	90                   	nop
  8099e9:	c9                   	leaveq 
  8099ea:	c3                   	retq   

00000000008099eb <dhcp_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  8099eb:	55                   	push   %rbp
  8099ec:	48 89 e5             	mov    %rsp,%rbp
  8099ef:	48 83 ec 20          	sub    $0x20,%rsp
  8099f3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  8099f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8099fb:	48 8b 40 38          	mov    0x38(%rax),%rax
  8099ff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  809a03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a07:	0f b6 00             	movzbl (%rax),%eax
  809a0a:	3c 0c                	cmp    $0xc,%al
  809a0c:	74 0b                	je     809a19 <dhcp_timeout+0x2e>
  809a0e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a12:	0f b6 00             	movzbl (%rax),%eax
  809a15:	3c 06                	cmp    $0x6,%al
  809a17:	75 18                	jne    809a31 <dhcp_timeout+0x46>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  809a19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809a1d:	48 89 c7             	mov    %rax,%rdi
  809a20:	48 b8 bb a5 80 00 00 	movabs $0x80a5bb,%rax
  809a27:	00 00 00 
  809a2a:	ff d0                	callq  *%rax
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  }
}
  809a2c:	e9 10 01 00 00       	jmpq   809b41 <dhcp_timeout+0x156>
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  809a31:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a35:	0f b6 00             	movzbl (%rax),%eax
  809a38:	3c 01                	cmp    $0x1,%al
  809a3a:	75 4f                	jne    809a8b <dhcp_timeout+0xa0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  809a3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a40:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809a44:	3c 05                	cmp    $0x5,%al
  809a46:	77 18                	ja     809a60 <dhcp_timeout+0x75>
      dhcp_select(netif);
  809a48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809a4c:	48 89 c7             	mov    %rax,%rdi
  809a4f:	48 b8 de 95 80 00 00 	movabs $0x8095de,%rax
  809a56:	00 00 00 
  809a59:	ff d0                	callq  *%rax
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  }
}
  809a5b:	e9 e1 00 00 00       	jmpq   809b41 <dhcp_timeout+0x156>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
      dhcp_select(netif);
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  809a60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809a64:	48 89 c7             	mov    %rax,%rdi
  809a67:	48 b8 37 ae 80 00 00 	movabs $0x80ae37,%rax
  809a6e:	00 00 00 
  809a71:	ff d0                	callq  *%rax
      dhcp_discover(netif);
  809a73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809a77:	48 89 c7             	mov    %rax,%rdi
  809a7a:	48 b8 bb a5 80 00 00 	movabs $0x80a5bb,%rax
  809a81:	00 00 00 
  809a84:	ff d0                	callq  *%rax
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  }
}
  809a86:	e9 b6 00 00 00       	jmpq   809b41 <dhcp_timeout+0x156>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  809a8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a8f:	0f b6 00             	movzbl (%rax),%eax
  809a92:	3c 08                	cmp    $0x8,%al
  809a94:	75 39                	jne    809acf <dhcp_timeout+0xe4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  809a96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a9a:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809a9e:	3c 01                	cmp    $0x1,%al
  809aa0:	77 18                	ja     809aba <dhcp_timeout+0xcf>
      dhcp_check(netif);
  809aa2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809aa6:	48 89 c7             	mov    %rax,%rdi
  809aa9:	48 b8 9b 94 80 00 00 	movabs $0x80949b,%rax
  809ab0:	00 00 00 
  809ab3:	ff d0                	callq  *%rax
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  }
}
  809ab5:	e9 87 00 00 00       	jmpq   809b41 <dhcp_timeout+0x156>
      dhcp_check(netif);
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  809aba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809abe:	48 89 c7             	mov    %rax,%rdi
  809ac1:	48 b8 1d a8 80 00 00 	movabs $0x80a81d,%rax
  809ac8:	00 00 00 
  809acb:	ff d0                	callq  *%rax
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  }
}
  809acd:	eb 72                	jmp    809b41 <dhcp_timeout+0x156>
      /* bind the interface to the offered address */
      dhcp_bind(netif);
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  809acf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809ad3:	0f b6 00             	movzbl (%rax),%eax
  809ad6:	3c 05                	cmp    $0x5,%al
  809ad8:	75 15                	jne    809aef <dhcp_timeout+0x104>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  809ada:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809ade:	48 89 c7             	mov    %rax,%rdi
  809ae1:	48 b8 a2 aa 80 00 00 	movabs $0x80aaa2,%rax
  809ae8:	00 00 00 
  809aeb:	ff d0                	callq  *%rax
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  }
}
  809aed:	eb 52                	jmp    809b41 <dhcp_timeout+0x156>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  809aef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809af3:	0f b6 00             	movzbl (%rax),%eax
  809af6:	3c 04                	cmp    $0x4,%al
  809af8:	75 47                	jne    809b41 <dhcp_timeout+0x156>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  809afa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809afe:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809b02:	3c 08                	cmp    $0x8,%al
  809b04:	77 15                	ja     809b1b <dhcp_timeout+0x130>
      dhcp_rebind(netif);
  809b06:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b0a:	48 89 c7             	mov    %rax,%rdi
  809b0d:	48 b8 6c ac 80 00 00 	movabs $0x80ac6c,%rax
  809b14:	00 00 00 
  809b17:	ff d0                	callq  *%rax
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  }
}
  809b19:	eb 26                	jmp    809b41 <dhcp_timeout+0x156>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
      dhcp_rebind(netif);
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  809b1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b1f:	48 89 c7             	mov    %rax,%rdi
  809b22:	48 b8 37 ae 80 00 00 	movabs $0x80ae37,%rax
  809b29:	00 00 00 
  809b2c:	ff d0                	callq  *%rax
      dhcp_discover(netif);
  809b2e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b32:	48 89 c7             	mov    %rax,%rdi
  809b35:	48 b8 bb a5 80 00 00 	movabs $0x80a5bb,%rax
  809b3c:	00 00 00 
  809b3f:	ff d0                	callq  *%rax
    }
  }
}
  809b41:	90                   	nop
  809b42:	c9                   	leaveq 
  809b43:	c3                   	retq   

0000000000809b44 <dhcp_t1_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
  809b44:	55                   	push   %rbp
  809b45:	48 89 e5             	mov    %rsp,%rbp
  809b48:	48 83 ec 20          	sub    $0x20,%rsp
  809b4c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809b50:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b54:	48 8b 40 38          	mov    0x38(%rax),%rax
  809b58:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  809b5c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809b60:	0f b6 00             	movzbl (%rax),%eax
  809b63:	3c 01                	cmp    $0x1,%al
  809b65:	74 16                	je     809b7d <dhcp_t1_timeout+0x39>
  809b67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809b6b:	0f b6 00             	movzbl (%rax),%eax
  809b6e:	3c 0a                	cmp    $0xa,%al
  809b70:	74 0b                	je     809b7d <dhcp_t1_timeout+0x39>
  809b72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809b76:	0f b6 00             	movzbl (%rax),%eax
  809b79:	3c 05                	cmp    $0x5,%al
  809b7b:	75 13                	jne    809b90 <dhcp_t1_timeout+0x4c>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  809b7d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b81:	48 89 c7             	mov    %rax,%rdi
  809b84:	48 b8 a2 aa 80 00 00 	movabs $0x80aaa2,%rax
  809b8b:	00 00 00 
  809b8e:	ff d0                	callq  *%rax
  }
}
  809b90:	90                   	nop
  809b91:	c9                   	leaveq 
  809b92:	c3                   	retq   

0000000000809b93 <dhcp_t2_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
  809b93:	55                   	push   %rbp
  809b94:	48 89 e5             	mov    %rsp,%rbp
  809b97:	48 83 ec 20          	sub    $0x20,%rsp
  809b9b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809b9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809ba3:	48 8b 40 38          	mov    0x38(%rax),%rax
  809ba7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  809bab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809baf:	0f b6 00             	movzbl (%rax),%eax
  809bb2:	3c 01                	cmp    $0x1,%al
  809bb4:	74 16                	je     809bcc <dhcp_t2_timeout+0x39>
  809bb6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809bba:	0f b6 00             	movzbl (%rax),%eax
  809bbd:	3c 0a                	cmp    $0xa,%al
  809bbf:	74 0b                	je     809bcc <dhcp_t2_timeout+0x39>
  809bc1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809bc5:	0f b6 00             	movzbl (%rax),%eax
  809bc8:	3c 05                	cmp    $0x5,%al
  809bca:	75 13                	jne    809bdf <dhcp_t2_timeout+0x4c>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  809bcc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809bd0:	48 89 c7             	mov    %rax,%rdi
  809bd3:	48 b8 6c ac 80 00 00 	movabs $0x80ac6c,%rax
  809bda:	00 00 00 
  809bdd:	ff d0                	callq  *%rax
  }
}
  809bdf:	90                   	nop
  809be0:	c9                   	leaveq 
  809be1:	c3                   	retq   

0000000000809be2 <dhcp_handle_ack>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  809be2:	55                   	push   %rbp
  809be3:	48 89 e5             	mov    %rsp,%rbp
  809be6:	53                   	push   %rbx
  809be7:	48 83 ec 38          	sub    $0x38,%rsp
  809beb:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809bef:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  809bf3:	48 8b 40 38          	mov    0x38(%rax),%rax
  809bf7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  809bfb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809bff:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%rax)
  dhcp->offered_gw_addr.addr = 0;
  809c06:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809c0a:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%rax)
  dhcp->offered_bc_addr.addr = 0;
  809c11:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809c15:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%rax)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  809c1c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809c20:	be 33 00 00 00       	mov    $0x33,%esi
  809c25:	48 89 c7             	mov    %rax,%rdi
  809c28:	48 b8 8a bf 80 00 00 	movabs $0x80bf8a,%rax
  809c2f:	00 00 00 
  809c32:	ff d0                	callq  *%rax
  809c34:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809c38:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809c3d:	74 20                	je     809c5f <dhcp_handle_ack+0x7d>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  809c3f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809c43:	48 83 c0 02          	add    $0x2,%rax
  809c47:	48 89 c7             	mov    %rax,%rdi
  809c4a:	48 b8 61 c1 80 00 00 	movabs $0x80c161,%rax
  809c51:	00 00 00 
  809c54:	ff d0                	callq  *%rax
  809c56:	89 c2                	mov    %eax,%edx
  809c58:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809c5c:	89 50 68             	mov    %edx,0x68(%rax)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  809c5f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809c63:	be 3a 00 00 00       	mov    $0x3a,%esi
  809c68:	48 89 c7             	mov    %rax,%rdi
  809c6b:	48 b8 8a bf 80 00 00 	movabs $0x80bf8a,%rax
  809c72:	00 00 00 
  809c75:	ff d0                	callq  *%rax
  809c77:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809c7b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809c80:	74 22                	je     809ca4 <dhcp_handle_ack+0xc2>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  809c82:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809c86:	48 83 c0 02          	add    $0x2,%rax
  809c8a:	48 89 c7             	mov    %rax,%rdi
  809c8d:	48 b8 61 c1 80 00 00 	movabs $0x80c161,%rax
  809c94:	00 00 00 
  809c97:	ff d0                	callq  *%rax
  809c99:	89 c2                	mov    %eax,%edx
  809c9b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809c9f:	89 50 6c             	mov    %edx,0x6c(%rax)
  809ca2:	eb 12                	jmp    809cb6 <dhcp_handle_ack+0xd4>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  809ca4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809ca8:	8b 40 68             	mov    0x68(%rax),%eax
  809cab:	d1 e8                	shr    %eax
  809cad:	89 c2                	mov    %eax,%edx
  809caf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809cb3:	89 50 6c             	mov    %edx,0x6c(%rax)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  809cb6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809cba:	be 3b 00 00 00       	mov    $0x3b,%esi
  809cbf:	48 89 c7             	mov    %rax,%rdi
  809cc2:	48 b8 8a bf 80 00 00 	movabs $0x80bf8a,%rax
  809cc9:	00 00 00 
  809ccc:	ff d0                	callq  *%rax
  809cce:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809cd2:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809cd7:	74 22                	je     809cfb <dhcp_handle_ack+0x119>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  809cd9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809cdd:	48 83 c0 02          	add    $0x2,%rax
  809ce1:	48 89 c7             	mov    %rax,%rdi
  809ce4:	48 b8 61 c1 80 00 00 	movabs $0x80c161,%rax
  809ceb:	00 00 00 
  809cee:	ff d0                	callq  *%rax
  809cf0:	89 c2                	mov    %eax,%edx
  809cf2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809cf6:	89 50 70             	mov    %edx,0x70(%rax)
  809cf9:	eb 0e                	jmp    809d09 <dhcp_handle_ack+0x127>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  809cfb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809cff:	8b 50 68             	mov    0x68(%rax),%edx
  809d02:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d06:	89 50 70             	mov    %edx,0x70(%rax)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  809d09:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d0d:	48 8b 40 18          	mov    0x18(%rax),%rax
  809d11:	48 83 c0 10          	add    $0x10,%rax
  809d15:	48 85 c0             	test   %rax,%rax
  809d18:	74 0d                	je     809d27 <dhcp_handle_ack+0x145>
  809d1a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d1e:	48 8b 40 18          	mov    0x18(%rax),%rax
  809d22:	8b 40 10             	mov    0x10(%rax),%eax
  809d25:	eb 05                	jmp    809d2c <dhcp_handle_ack+0x14a>
  809d27:	b8 00 00 00 00       	mov    $0x0,%eax
  809d2c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809d30:	89 42 4c             	mov    %eax,0x4c(%rdx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  809d33:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d37:	be 01 00 00 00       	mov    $0x1,%esi
  809d3c:	48 89 c7             	mov    %rax,%rdi
  809d3f:	48 b8 8a bf 80 00 00 	movabs $0x80bf8a,%rax
  809d46:	00 00 00 
  809d49:	ff d0                	callq  *%rax
  809d4b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  /* subnet mask given? */
  if (option_ptr != NULL) {
  809d4f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809d54:	74 2e                	je     809d84 <dhcp_handle_ack+0x1a2>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  809d56:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809d5a:	48 83 c0 02          	add    $0x2,%rax
  809d5e:	48 89 c7             	mov    %rax,%rdi
  809d61:	48 b8 61 c1 80 00 00 	movabs $0x80c161,%rax
  809d68:	00 00 00 
  809d6b:	ff d0                	callq  *%rax
  809d6d:	89 c7                	mov    %eax,%edi
  809d6f:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  809d76:	00 00 00 
  809d79:	ff d0                	callq  *%rax
  809d7b:	89 c2                	mov    %eax,%edx
  809d7d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d81:	89 50 50             	mov    %edx,0x50(%rax)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  809d84:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d88:	be 03 00 00 00       	mov    $0x3,%esi
  809d8d:	48 89 c7             	mov    %rax,%rdi
  809d90:	48 b8 8a bf 80 00 00 	movabs $0x80bf8a,%rax
  809d97:	00 00 00 
  809d9a:	ff d0                	callq  *%rax
  809d9c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809da0:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809da5:	74 2e                	je     809dd5 <dhcp_handle_ack+0x1f3>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  809da7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809dab:	48 83 c0 02          	add    $0x2,%rax
  809daf:	48 89 c7             	mov    %rax,%rdi
  809db2:	48 b8 61 c1 80 00 00 	movabs $0x80c161,%rax
  809db9:	00 00 00 
  809dbc:	ff d0                	callq  *%rax
  809dbe:	89 c7                	mov    %eax,%edi
  809dc0:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  809dc7:	00 00 00 
  809dca:	ff d0                	callq  *%rax
  809dcc:	89 c2                	mov    %eax,%edx
  809dce:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809dd2:	89 50 54             	mov    %edx,0x54(%rax)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  809dd5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809dd9:	be 1c 00 00 00       	mov    $0x1c,%esi
  809dde:	48 89 c7             	mov    %rax,%rdi
  809de1:	48 b8 8a bf 80 00 00 	movabs $0x80bf8a,%rax
  809de8:	00 00 00 
  809deb:	ff d0                	callq  *%rax
  809ded:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809df1:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809df6:	74 2e                	je     809e26 <dhcp_handle_ack+0x244>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  809df8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809dfc:	48 83 c0 02          	add    $0x2,%rax
  809e00:	48 89 c7             	mov    %rax,%rdi
  809e03:	48 b8 61 c1 80 00 00 	movabs $0x80c161,%rax
  809e0a:	00 00 00 
  809e0d:	ff d0                	callq  *%rax
  809e0f:	89 c7                	mov    %eax,%edi
  809e11:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  809e18:	00 00 00 
  809e1b:	ff d0                	callq  *%rax
  809e1d:	89 c2                	mov    %eax,%edx
  809e1f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809e23:	89 50 58             	mov    %edx,0x58(%rax)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  809e26:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809e2a:	be 06 00 00 00       	mov    $0x6,%esi
  809e2f:	48 89 c7             	mov    %rax,%rdi
  809e32:	48 b8 8a bf 80 00 00 	movabs $0x80bf8a,%rax
  809e39:	00 00 00 
  809e3c:	ff d0                	callq  *%rax
  809e3e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809e42:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809e47:	0f 84 9f 00 00 00    	je     809eec <dhcp_handle_ack+0x30a>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  809e4d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809e51:	48 83 c0 01          	add    $0x1,%rax
  809e55:	48 89 c7             	mov    %rax,%rdi
  809e58:	48 b8 4c c1 80 00 00 	movabs $0x80c14c,%rax
  809e5f:	00 00 00 
  809e62:	ff d0                	callq  *%rax
  809e64:	c0 e8 02             	shr    $0x2,%al
  809e67:	0f b6 d0             	movzbl %al,%edx
  809e6a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809e6e:	89 50 5c             	mov    %edx,0x5c(%rax)
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
  809e71:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809e75:	8b 40 5c             	mov    0x5c(%rax),%eax
  809e78:	83 f8 02             	cmp    $0x2,%eax
  809e7b:	76 0b                	jbe    809e88 <dhcp_handle_ack+0x2a6>
      dhcp->dns_count = DHCP_MAX_DNS;
  809e7d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809e81:	c7 40 5c 02 00 00 00 	movl   $0x2,0x5c(%rax)
    for (n = 0; n < dhcp->dns_count; n++) {
  809e88:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  809e8c:	eb 4f                	jmp    809edd <dhcp_handle_ack+0x2fb>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  809e8e:	0f b6 5d ef          	movzbl -0x11(%rbp),%ebx
  809e92:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  809e96:	c1 e0 02             	shl    $0x2,%eax
  809e99:	83 c0 02             	add    $0x2,%eax
  809e9c:	48 63 d0             	movslq %eax,%rdx
  809e9f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809ea3:	48 01 d0             	add    %rdx,%rax
  809ea6:	48 89 c7             	mov    %rax,%rdi
  809ea9:	48 b8 61 c1 80 00 00 	movabs $0x80c161,%rax
  809eb0:	00 00 00 
  809eb3:	ff d0                	callq  *%rax
  809eb5:	89 c7                	mov    %eax,%edi
  809eb7:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  809ebe:	00 00 00 
  809ec1:	ff d0                	callq  *%rax
  809ec3:	89 c1                	mov    %eax,%ecx
  809ec5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809ec9:	48 63 d3             	movslq %ebx,%rdx
  809ecc:	48 83 c2 18          	add    $0x18,%rdx
  809ed0:	89 0c 90             	mov    %ecx,(%rax,%rdx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  809ed3:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  809ed7:	83 c0 01             	add    $0x1,%eax
  809eda:	88 45 ef             	mov    %al,-0x11(%rbp)
  809edd:	0f b6 55 ef          	movzbl -0x11(%rbp),%edx
  809ee1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809ee5:	8b 40 5c             	mov    0x5c(%rax),%eax
  809ee8:	39 c2                	cmp    %eax,%edx
  809eea:	72 a2                	jb     809e8e <dhcp_handle_ack+0x2ac>
    }
#if LWIP_DNS
    dns_setserver( n, (struct ip_addr *)(&ip_addr_any));
#endif /* LWIP_DNS */
  }
}
  809eec:	90                   	nop
  809eed:	48 83 c4 38          	add    $0x38,%rsp
  809ef1:	5b                   	pop    %rbx
  809ef2:	5d                   	pop    %rbp
  809ef3:	c3                   	retq   

0000000000809ef4 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  809ef4:	55                   	push   %rbp
  809ef5:	48 89 e5             	mov    %rsp,%rbp
  809ef8:	48 83 ec 20          	sub    $0x20,%rsp
  809efc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp;
  err_t result = ERR_OK;
  809f00:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  809f04:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  809f09:	75 2a                	jne    809f35 <dhcp_start+0x41>
  809f0b:	48 ba 68 1a 82 00 00 	movabs $0x821a68,%rdx
  809f12:	00 00 00 
  809f15:	be 39 02 00 00       	mov    $0x239,%esi
  809f1a:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  809f21:	00 00 00 
  809f24:	b8 00 00 00 00       	mov    $0x0,%eax
  809f29:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  809f30:	00 00 00 
  809f33:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  809f35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809f39:	48 8b 40 38          	mov    0x38(%rax),%rax
  809f3d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  809f41:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809f45:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  809f49:	83 e0 f7             	and    $0xfffffff7,%eax
  809f4c:	89 c2                	mov    %eax,%edx
  809f4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809f52:	88 50 4a             	mov    %dl,0x4a(%rax)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  809f55:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809f5a:	75 32                	jne    809f8e <dhcp_start+0x9a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  809f5c:	bf 78 00 00 00       	mov    $0x78,%edi
  809f61:	48 b8 95 c9 80 00 00 	movabs $0x80c995,%rax
  809f68:	00 00 00 
  809f6b:	ff d0                	callq  *%rax
  809f6d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (dhcp == NULL) {
  809f71:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809f76:	75 0a                	jne    809f82 <dhcp_start+0x8e>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  809f78:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809f7d:	e9 3d 01 00 00       	jmpq   80a0bf <dhcp_start+0x1cb>
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  809f82:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809f86:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  809f8a:	48 89 50 38          	mov    %rdx,0x38(%rax)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  809f8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809f92:	ba 78 00 00 00       	mov    $0x78,%edx
  809f97:	be 00 00 00 00       	mov    $0x0,%esi
  809f9c:	48 89 c7             	mov    %rax,%rdi
  809f9f:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  809fa6:	00 00 00 
  809fa9:	ff d0                	callq  *%rax
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  809fab:	48 b8 55 5a 81 00 00 	movabs $0x815a55,%rax
  809fb2:	00 00 00 
  809fb5:	ff d0                	callq  *%rax
  809fb7:	48 89 c2             	mov    %rax,%rdx
  809fba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809fbe:	48 89 50 08          	mov    %rdx,0x8(%rax)
  if (dhcp->pcb == NULL) {
  809fc2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809fc6:	48 8b 40 08          	mov    0x8(%rax),%rax
  809fca:	48 85 c0             	test   %rax,%rax
  809fcd:	75 31                	jne    80a000 <dhcp_start+0x10c>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  809fcf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809fd3:	48 89 c7             	mov    %rax,%rdi
  809fd6:	48 b8 f2 c4 80 00 00 	movabs $0x80c4f2,%rax
  809fdd:	00 00 00 
  809fe0:	ff d0                	callq  *%rax
    netif->dhcp = dhcp = NULL;
  809fe2:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  809fe9:	00 
  809fea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809fee:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  809ff2:	48 89 50 38          	mov    %rdx,0x38(%rax)
    return ERR_MEM;
  809ff6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809ffb:	e9 bf 00 00 00       	jmpq   80a0bf <dhcp_start+0x1cb>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80a000:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a004:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a008:	ba 44 00 00 00       	mov    $0x44,%edx
  80a00d:	48 be 68 28 82 00 00 	movabs $0x822868,%rsi
  80a014:	00 00 00 
  80a017:	48 89 c7             	mov    %rax,%rdi
  80a01a:	48 b8 f6 56 81 00 00 	movabs $0x8156f6,%rax
  80a021:	00 00 00 
  80a024:	ff d0                	callq  *%rax
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a026:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a02a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a02e:	ba 43 00 00 00       	mov    $0x43,%edx
  80a033:	48 be 68 28 82 00 00 	movabs $0x822868,%rsi
  80a03a:	00 00 00 
  80a03d:	48 89 c7             	mov    %rax,%rdi
  80a040:	48 b8 42 58 81 00 00 	movabs $0x815842,%rax
  80a047:	00 00 00 
  80a04a:	ff d0                	callq  *%rax
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  80a04c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a050:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a054:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a058:	48 be 52 b7 80 00 00 	movabs $0x80b752,%rsi
  80a05f:	00 00 00 
  80a062:	48 89 c7             	mov    %rax,%rdi
  80a065:	48 b8 7b 59 81 00 00 	movabs $0x81597b,%rax
  80a06c:	00 00 00 
  80a06f:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  80a071:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a075:	48 89 c7             	mov    %rax,%rdi
  80a078:	48 b8 bb a5 80 00 00 	movabs $0x80a5bb,%rax
  80a07f:	00 00 00 
  80a082:	ff d0                	callq  *%rax
  80a084:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result != ERR_OK) {
  80a087:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a08b:	74 1a                	je     80a0a7 <dhcp_start+0x1b3>
    /* free resources allocated above */
    dhcp_stop(netif);
  80a08d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a091:	48 89 c7             	mov    %rax,%rdi
  80a094:	48 b8 a5 b0 80 00 00 	movabs $0x80b0a5,%rax
  80a09b:	00 00 00 
  80a09e:	ff d0                	callq  *%rax
    return ERR_MEM;
  80a0a0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a0a5:	eb 18                	jmp    80a0bf <dhcp_start+0x1cb>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  80a0a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a0ab:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80a0af:	83 c8 08             	or     $0x8,%eax
  80a0b2:	89 c2                	mov    %eax,%edx
  80a0b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a0b8:	88 50 4a             	mov    %dl,0x4a(%rax)
  return result;
  80a0bb:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a0bf:	c9                   	leaveq 
  80a0c0:	c3                   	retq   

000000000080a0c1 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  80a0c1:	55                   	push   %rbp
  80a0c2:	48 89 e5             	mov    %rsp,%rbp
  80a0c5:	48 83 ec 30          	sub    $0x30,%rsp
  80a0c9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  80a0cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a0d1:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a0d5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  80a0d9:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  dhcp = mem_malloc(sizeof(struct dhcp));
  80a0dd:	bf 78 00 00 00       	mov    $0x78,%edi
  80a0e2:	48 b8 95 c9 80 00 00 	movabs $0x80c995,%rax
  80a0e9:	00 00 00 
  80a0ec:	ff d0                	callq  *%rax
  80a0ee:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (dhcp == NULL) {
  80a0f2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80a0f7:	0f 84 3c 02 00 00    	je     80a339 <dhcp_inform+0x278>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  80a0fd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a101:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a105:	48 89 50 38          	mov    %rdx,0x38(%rax)
  memset(dhcp, 0, sizeof(struct dhcp));
  80a109:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a10d:	ba 78 00 00 00       	mov    $0x78,%edx
  80a112:	be 00 00 00 00       	mov    $0x0,%esi
  80a117:	48 89 c7             	mov    %rax,%rdi
  80a11a:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  80a121:	00 00 00 
  80a124:	ff d0                	callq  *%rax

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  80a126:	48 b8 55 5a 81 00 00 	movabs $0x815a55,%rax
  80a12d:	00 00 00 
  80a130:	ff d0                	callq  *%rax
  80a132:	48 89 c2             	mov    %rax,%rdx
  80a135:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a139:	48 89 50 08          	mov    %rdx,0x8(%rax)
  if (dhcp->pcb == NULL) {
  80a13d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a141:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a145:	48 85 c0             	test   %rax,%rax
  80a148:	75 18                	jne    80a162 <dhcp_inform+0xa1>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  80a14a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a14e:	48 89 c7             	mov    %rax,%rdi
  80a151:	48 b8 f2 c4 80 00 00 	movabs $0x80c4f2,%rax
  80a158:	00 00 00 
  80a15b:	ff d0                	callq  *%rax
    return;
  80a15d:	e9 d8 01 00 00       	jmpq   80a33a <dhcp_inform+0x279>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a162:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a166:	48 89 c7             	mov    %rax,%rdi
  80a169:	48 b8 b2 b9 80 00 00 	movabs $0x80b9b2,%rax
  80a170:	00 00 00 
  80a173:	ff d0                	callq  *%rax
  80a175:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a178:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a17c:	0f 85 5f 01 00 00    	jne    80a2e1 <dhcp_inform+0x220>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a182:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a186:	ba 01 00 00 00       	mov    $0x1,%edx
  80a18b:	be 35 00 00 00       	mov    $0x35,%esi
  80a190:	48 89 c7             	mov    %rax,%rdi
  80a193:	48 b8 d4 b1 80 00 00 	movabs $0x80b1d4,%rax
  80a19a:	00 00 00 
  80a19d:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_INFORM);
  80a19f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a1a3:	be 08 00 00 00       	mov    $0x8,%esi
  80a1a8:	48 89 c7             	mov    %rax,%rdi
  80a1ab:	48 b8 86 b2 80 00 00 	movabs $0x80b286,%rax
  80a1b2:	00 00 00 
  80a1b5:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a1b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a1bb:	ba 02 00 00 00       	mov    $0x2,%edx
  80a1c0:	be 39 00 00 00       	mov    $0x39,%esi
  80a1c5:	48 89 c7             	mov    %rax,%rdi
  80a1c8:	48 b8 d4 b1 80 00 00 	movabs $0x80b1d4,%rax
  80a1cf:	00 00 00 
  80a1d2:	ff d0                	callq  *%rax
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  80a1d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a1d8:	be 40 02 00 00       	mov    $0x240,%esi
  80a1dd:	48 89 c7             	mov    %rax,%rdi
  80a1e0:	48 b8 fd b2 80 00 00 	movabs $0x80b2fd,%rax
  80a1e7:	00 00 00 
  80a1ea:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80a1ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a1f0:	48 89 c7             	mov    %rax,%rdi
  80a1f3:	48 b8 31 be 80 00 00 	movabs $0x80be31,%rax
  80a1fa:	00 00 00 
  80a1fd:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a1ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a203:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a207:	66 05 f0 00          	add    $0xf0,%ax
  80a20b:	0f b7 d0             	movzwl %ax,%edx
  80a20e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a212:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a216:	89 d6                	mov    %edx,%esi
  80a218:	48 89 c7             	mov    %rax,%rdi
  80a21b:	48 b8 3f d9 80 00 00 	movabs $0x80d93f,%rax
  80a222:	00 00 00 
  80a225:	ff d0                	callq  *%rax

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80a227:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a22b:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a22f:	ba 44 00 00 00       	mov    $0x44,%edx
  80a234:	48 be 68 28 82 00 00 	movabs $0x822868,%rsi
  80a23b:	00 00 00 
  80a23e:	48 89 c7             	mov    %rax,%rdi
  80a241:	48 b8 f6 56 81 00 00 	movabs $0x8156f6,%rax
  80a248:	00 00 00 
  80a24b:	ff d0                	callq  *%rax
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  80a24d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a251:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a255:	ba 43 00 00 00       	mov    $0x43,%edx
  80a25a:	48 be 6c 28 82 00 00 	movabs $0x82286c,%rsi
  80a261:	00 00 00 
  80a264:	48 89 c7             	mov    %rax,%rdi
  80a267:	48 b8 42 58 81 00 00 	movabs $0x815842,%rax
  80a26e:	00 00 00 
  80a271:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a273:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a277:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a27b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a27f:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a283:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80a287:	49 89 d0             	mov    %rdx,%r8
  80a28a:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a28f:	48 ba 6c 28 82 00 00 	movabs $0x82286c,%rdx
  80a296:	00 00 00 
  80a299:	48 89 c7             	mov    %rax,%rdi
  80a29c:	48 b8 38 54 81 00 00 	movabs $0x815438,%rax
  80a2a3:	00 00 00 
  80a2a6:	ff d0                	callq  *%rax
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a2a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a2ac:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a2b0:	ba 43 00 00 00       	mov    $0x43,%edx
  80a2b5:	48 be 68 28 82 00 00 	movabs $0x822868,%rsi
  80a2bc:	00 00 00 
  80a2bf:	48 89 c7             	mov    %rax,%rdi
  80a2c2:	48 b8 42 58 81 00 00 	movabs $0x815842,%rax
  80a2c9:	00 00 00 
  80a2cc:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80a2ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a2d2:	48 89 c7             	mov    %rax,%rdi
  80a2d5:	48 b8 0a bd 80 00 00 	movabs $0x80bd0a,%rax
  80a2dc:	00 00 00 
  80a2df:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
  80a2e1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80a2e6:	74 52                	je     80a33a <dhcp_inform+0x279>
    if (dhcp->pcb != NULL) {
  80a2e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a2ec:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a2f0:	48 85 c0             	test   %rax,%rax
  80a2f3:	74 17                	je     80a30c <dhcp_inform+0x24b>
      udp_remove(dhcp->pcb);
  80a2f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a2f9:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a2fd:	48 89 c7             	mov    %rax,%rdi
  80a300:	48 b8 aa 59 81 00 00 	movabs $0x8159aa,%rax
  80a307:	00 00 00 
  80a30a:	ff d0                	callq  *%rax
    }
    dhcp->pcb = NULL;
  80a30c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a310:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80a317:	00 
    mem_free((void *)dhcp);
  80a318:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a31c:	48 89 c7             	mov    %rax,%rdi
  80a31f:	48 b8 f2 c4 80 00 00 	movabs $0x80c4f2,%rax
  80a326:	00 00 00 
  80a329:	ff d0                	callq  *%rax
    netif->dhcp = old_dhcp;
  80a32b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a32f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80a333:	48 89 50 38          	mov    %rdx,0x38(%rax)
  80a337:	eb 01                	jmp    80a33a <dhcp_inform+0x279>
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  80a339:	90                   	nop
    }
    dhcp->pcb = NULL;
    mem_free((void *)dhcp);
    netif->dhcp = old_dhcp;
  }
}
  80a33a:	c9                   	leaveq 
  80a33b:	c3                   	retq   

000000000080a33c <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  80a33c:	55                   	push   %rbp
  80a33d:	48 89 e5             	mov    %rsp,%rbp
  80a340:	48 83 ec 10          	sub    $0x10,%rsp
  80a344:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80a348:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80a34c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80a351:	75 2a                	jne    80a37d <dhcp_arp_reply+0x41>
  80a353:	48 ba 68 1a 82 00 00 	movabs $0x821a68,%rdx
  80a35a:	00 00 00 
  80a35d:	be b6 02 00 00       	mov    $0x2b6,%esi
  80a362:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80a369:	00 00 00 
  80a36c:	b8 00 00 00 00       	mov    $0x0,%eax
  80a371:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80a378:	00 00 00 
  80a37b:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  80a37d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a381:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a385:	48 85 c0             	test   %rax,%rax
  80a388:	74 37                	je     80a3c1 <dhcp_arp_reply+0x85>
  80a38a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a38e:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a392:	0f b6 00             	movzbl (%rax),%eax
  80a395:	3c 08                	cmp    $0x8,%al
  80a397:	75 28                	jne    80a3c1 <dhcp_arp_reply+0x85>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  80a399:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a39d:	8b 10                	mov    (%rax),%edx
  80a39f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3a3:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a3a7:	8b 40 4c             	mov    0x4c(%rax),%eax
  80a3aa:	39 c2                	cmp    %eax,%edx
  80a3ac:	75 13                	jne    80a3c1 <dhcp_arp_reply+0x85>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
  80a3ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3b2:	48 89 c7             	mov    %rax,%rdi
  80a3b5:	48 b8 c4 a3 80 00 00 	movabs $0x80a3c4,%rax
  80a3bc:	00 00 00 
  80a3bf:	ff d0                	callq  *%rax
    }
  }
}
  80a3c1:	90                   	nop
  80a3c2:	c9                   	leaveq 
  80a3c3:	c3                   	retq   

000000000080a3c4 <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
  80a3c4:	55                   	push   %rbp
  80a3c5:	48 89 e5             	mov    %rsp,%rbp
  80a3c8:	48 83 ec 20          	sub    $0x20,%rsp
  80a3cc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a3d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a3d4:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a3d8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  80a3dc:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  80a3e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3e4:	be 0c 00 00 00       	mov    $0xc,%esi
  80a3e9:	48 89 c7             	mov    %rax,%rdi
  80a3ec:	48 b8 a2 b1 80 00 00 	movabs $0x80b1a2,%rax
  80a3f3:	00 00 00 
  80a3f6:	ff d0                	callq  *%rax
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a3f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a3fc:	48 89 c7             	mov    %rax,%rdi
  80a3ff:	48 b8 b2 b9 80 00 00 	movabs $0x80b9b2,%rax
  80a406:	00 00 00 
  80a409:	ff d0                	callq  *%rax
  80a40b:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a40e:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a412:	0f 85 5c 01 00 00    	jne    80a574 <dhcp_decline+0x1b0>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a418:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a41c:	ba 01 00 00 00       	mov    $0x1,%edx
  80a421:	be 35 00 00 00       	mov    $0x35,%esi
  80a426:	48 89 c7             	mov    %rax,%rdi
  80a429:	48 b8 d4 b1 80 00 00 	movabs $0x80b1d4,%rax
  80a430:	00 00 00 
  80a433:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  80a435:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a439:	be 04 00 00 00       	mov    $0x4,%esi
  80a43e:	48 89 c7             	mov    %rax,%rdi
  80a441:	48 b8 86 b2 80 00 00 	movabs $0x80b286,%rax
  80a448:	00 00 00 
  80a44b:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a44d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a451:	ba 02 00 00 00       	mov    $0x2,%edx
  80a456:	be 39 00 00 00       	mov    $0x39,%esi
  80a45b:	48 89 c7             	mov    %rax,%rdi
  80a45e:	48 b8 d4 b1 80 00 00 	movabs $0x80b1d4,%rax
  80a465:	00 00 00 
  80a468:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80a46a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a46e:	be 40 02 00 00       	mov    $0x240,%esi
  80a473:	48 89 c7             	mov    %rax,%rdi
  80a476:	48 b8 fd b2 80 00 00 	movabs $0x80b2fd,%rax
  80a47d:	00 00 00 
  80a480:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  80a482:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a486:	ba 04 00 00 00       	mov    $0x4,%edx
  80a48b:	be 32 00 00 00       	mov    $0x32,%esi
  80a490:	48 89 c7             	mov    %rax,%rdi
  80a493:	48 b8 d4 b1 80 00 00 	movabs $0x80b1d4,%rax
  80a49a:	00 00 00 
  80a49d:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  80a49f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a4a3:	8b 40 4c             	mov    0x4c(%rax),%eax
  80a4a6:	89 c7                	mov    %eax,%edi
  80a4a8:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  80a4af:	00 00 00 
  80a4b2:	ff d0                	callq  *%rax
  80a4b4:	89 c2                	mov    %eax,%edx
  80a4b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a4ba:	89 d6                	mov    %edx,%esi
  80a4bc:	48 89 c7             	mov    %rax,%rdi
  80a4bf:	48 b8 a9 b3 80 00 00 	movabs $0x80b3a9,%rax
  80a4c6:	00 00 00 
  80a4c9:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80a4cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a4cf:	48 89 c7             	mov    %rax,%rdi
  80a4d2:	48 b8 31 be 80 00 00 	movabs $0x80be31,%rax
  80a4d9:	00 00 00 
  80a4dc:	ff d0                	callq  *%rax
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a4de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a4e2:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a4e6:	66 05 f0 00          	add    $0xf0,%ax
  80a4ea:	0f b7 d0             	movzwl %ax,%edx
  80a4ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a4f1:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a4f5:	89 d6                	mov    %edx,%esi
  80a4f7:	48 89 c7             	mov    %rax,%rdi
  80a4fa:	48 b8 3f d9 80 00 00 	movabs $0x80d93f,%rax
  80a501:	00 00 00 
  80a504:	ff d0                	callq  *%rax

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a506:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a50a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a50e:	ba 43 00 00 00       	mov    $0x43,%edx
  80a513:	48 be 68 28 82 00 00 	movabs $0x822868,%rsi
  80a51a:	00 00 00 
  80a51d:	48 89 c7             	mov    %rax,%rdi
  80a520:	48 b8 42 58 81 00 00 	movabs $0x815842,%rax
  80a527:	00 00 00 
  80a52a:	ff d0                	callq  *%rax
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a52c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a530:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a534:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a538:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a53c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a540:	49 89 d0             	mov    %rdx,%r8
  80a543:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a548:	48 ba 6c 28 82 00 00 	movabs $0x82286c,%rdx
  80a54f:	00 00 00 
  80a552:	48 89 c7             	mov    %rax,%rdi
  80a555:	48 b8 38 54 81 00 00 	movabs $0x815438,%rax
  80a55c:	00 00 00 
  80a55f:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80a561:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a565:	48 89 c7             	mov    %rax,%rdi
  80a568:	48 b8 0a bd 80 00 00 	movabs $0x80bd0a,%rax
  80a56f:	00 00 00 
  80a572:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a574:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a578:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a57c:	8d 50 01             	lea    0x1(%rax),%edx
  80a57f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a583:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = 10*1000;
  80a586:	66 c7 45 f4 10 27    	movw   $0x2710,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a58c:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a590:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a596:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a59b:	89 c8                	mov    %ecx,%eax
  80a59d:	f7 ea                	imul   %edx
  80a59f:	c1 fa 05             	sar    $0x5,%edx
  80a5a2:	89 c8                	mov    %ecx,%eax
  80a5a4:	c1 f8 1f             	sar    $0x1f,%eax
  80a5a7:	29 c2                	sub    %eax,%edx
  80a5a9:	89 d0                	mov    %edx,%eax
  80a5ab:	89 c2                	mov    %eax,%edx
  80a5ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5b1:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80a5b5:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a5b9:	c9                   	leaveq 
  80a5ba:	c3                   	retq   

000000000080a5bb <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  80a5bb:	55                   	push   %rbp
  80a5bc:	48 89 e5             	mov    %rsp,%rbp
  80a5bf:	48 83 ec 20          	sub    $0x20,%rsp
  80a5c3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a5c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a5cb:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a5cf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  80a5d3:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  80a5d7:	48 b8 68 28 82 00 00 	movabs $0x822868,%rax
  80a5de:	00 00 00 
  80a5e1:	8b 10                	mov    (%rax),%edx
  80a5e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5e7:	89 50 4c             	mov    %edx,0x4c(%rax)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a5ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a5ee:	48 89 c7             	mov    %rax,%rdi
  80a5f1:	48 b8 b2 b9 80 00 00 	movabs $0x80b9b2,%rax
  80a5f8:	00 00 00 
  80a5fb:	ff d0                	callq  *%rax
  80a5fd:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a600:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a604:	0f 85 a8 01 00 00    	jne    80a7b2 <dhcp_discover+0x1f7>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a60a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a60e:	ba 01 00 00 00       	mov    $0x1,%edx
  80a613:	be 35 00 00 00       	mov    $0x35,%esi
  80a618:	48 89 c7             	mov    %rax,%rdi
  80a61b:	48 b8 d4 b1 80 00 00 	movabs $0x80b1d4,%rax
  80a622:	00 00 00 
  80a625:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  80a627:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a62b:	be 01 00 00 00       	mov    $0x1,%esi
  80a630:	48 89 c7             	mov    %rax,%rdi
  80a633:	48 b8 86 b2 80 00 00 	movabs $0x80b286,%rax
  80a63a:	00 00 00 
  80a63d:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a63f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a643:	ba 02 00 00 00       	mov    $0x2,%edx
  80a648:	be 39 00 00 00       	mov    $0x39,%esi
  80a64d:	48 89 c7             	mov    %rax,%rdi
  80a650:	48 b8 d4 b1 80 00 00 	movabs $0x80b1d4,%rax
  80a657:	00 00 00 
  80a65a:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80a65c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a660:	be 40 02 00 00       	mov    $0x240,%esi
  80a665:	48 89 c7             	mov    %rax,%rdi
  80a668:	48 b8 fd b2 80 00 00 	movabs $0x80b2fd,%rax
  80a66f:	00 00 00 
  80a672:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  80a674:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a678:	ba 04 00 00 00       	mov    $0x4,%edx
  80a67d:	be 37 00 00 00       	mov    $0x37,%esi
  80a682:	48 89 c7             	mov    %rax,%rdi
  80a685:	48 b8 d4 b1 80 00 00 	movabs $0x80b1d4,%rax
  80a68c:	00 00 00 
  80a68f:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  80a691:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a695:	be 01 00 00 00       	mov    $0x1,%esi
  80a69a:	48 89 c7             	mov    %rax,%rdi
  80a69d:	48 b8 86 b2 80 00 00 	movabs $0x80b286,%rax
  80a6a4:	00 00 00 
  80a6a7:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80a6a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6ad:	be 03 00 00 00       	mov    $0x3,%esi
  80a6b2:	48 89 c7             	mov    %rax,%rdi
  80a6b5:	48 b8 86 b2 80 00 00 	movabs $0x80b286,%rax
  80a6bc:	00 00 00 
  80a6bf:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  80a6c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6c5:	be 1c 00 00 00       	mov    $0x1c,%esi
  80a6ca:	48 89 c7             	mov    %rax,%rdi
  80a6cd:	48 b8 86 b2 80 00 00 	movabs $0x80b286,%rax
  80a6d4:	00 00 00 
  80a6d7:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  80a6d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6dd:	be 06 00 00 00       	mov    $0x6,%esi
  80a6e2:	48 89 c7             	mov    %rax,%rdi
  80a6e5:	48 b8 86 b2 80 00 00 	movabs $0x80b286,%rax
  80a6ec:	00 00 00 
  80a6ef:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80a6f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6f5:	48 89 c7             	mov    %rax,%rdi
  80a6f8:	48 b8 31 be 80 00 00 	movabs $0x80be31,%rax
  80a6ff:	00 00 00 
  80a702:	ff d0                	callq  *%rax

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a704:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a708:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a70c:	66 05 f0 00          	add    $0xf0,%ax
  80a710:	0f b7 d0             	movzwl %ax,%edx
  80a713:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a717:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a71b:	89 d6                	mov    %edx,%esi
  80a71d:	48 89 c7             	mov    %rax,%rdi
  80a720:	48 b8 3f d9 80 00 00 	movabs $0x80d93f,%rax
  80a727:	00 00 00 
  80a72a:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a72c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a730:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a734:	ba 43 00 00 00       	mov    $0x43,%edx
  80a739:	48 be 68 28 82 00 00 	movabs $0x822868,%rsi
  80a740:	00 00 00 
  80a743:	48 89 c7             	mov    %rax,%rdi
  80a746:	48 b8 42 58 81 00 00 	movabs $0x815842,%rax
  80a74d:	00 00 00 
  80a750:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a752:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a756:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a75a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a75e:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a762:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a766:	49 89 d0             	mov    %rdx,%r8
  80a769:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a76e:	48 ba 6c 28 82 00 00 	movabs $0x82286c,%rdx
  80a775:	00 00 00 
  80a778:	48 89 c7             	mov    %rax,%rdi
  80a77b:	48 b8 38 54 81 00 00 	movabs $0x815438,%rax
  80a782:	00 00 00 
  80a785:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  80a787:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a78b:	48 89 c7             	mov    %rax,%rdi
  80a78e:	48 b8 0a bd 80 00 00 	movabs $0x80bd0a,%rax
  80a795:	00 00 00 
  80a798:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  80a79a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a79e:	be 06 00 00 00       	mov    $0x6,%esi
  80a7a3:	48 89 c7             	mov    %rax,%rdi
  80a7a6:	48 b8 a2 b1 80 00 00 	movabs $0x80b1a2,%rax
  80a7ad:	00 00 00 
  80a7b0:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a7b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7b6:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a7ba:	8d 50 01             	lea    0x1(%rax),%edx
  80a7bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7c1:	88 50 01             	mov    %dl,0x1(%rax)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  80a7c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7c8:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a7cc:	3c 03                	cmp    $0x3,%al
  80a7ce:	77 15                	ja     80a7e5 <dhcp_discover+0x22a>
  80a7d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7d4:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a7d8:	0f b6 c0             	movzbl %al,%eax
  80a7db:	83 c0 01             	add    $0x1,%eax
  80a7de:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80a7e3:	eb 05                	jmp    80a7ea <dhcp_discover+0x22f>
  80a7e5:	b8 10 27 00 00       	mov    $0x2710,%eax
  80a7ea:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a7ee:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a7f2:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a7f8:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a7fd:	89 c8                	mov    %ecx,%eax
  80a7ff:	f7 ea                	imul   %edx
  80a801:	c1 fa 05             	sar    $0x5,%edx
  80a804:	89 c8                	mov    %ecx,%eax
  80a806:	c1 f8 1f             	sar    $0x1f,%eax
  80a809:	29 c2                	sub    %eax,%edx
  80a80b:	89 d0                	mov    %edx,%eax
  80a80d:	89 c2                	mov    %eax,%edx
  80a80f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a813:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80a817:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a81b:	c9                   	leaveq 
  80a81c:	c3                   	retq   

000000000080a81d <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  80a81d:	55                   	push   %rbp
  80a81e:	48 89 e5             	mov    %rsp,%rbp
  80a821:	48 83 ec 40          	sub    $0x40,%rsp
  80a825:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  80a829:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80a82e:	75 2a                	jne    80a85a <dhcp_bind+0x3d>
  80a830:	48 ba 8b 1a 82 00 00 	movabs $0x821a8b,%rdx
  80a837:	00 00 00 
  80a83a:	be 3e 03 00 00       	mov    $0x33e,%esi
  80a83f:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80a846:	00 00 00 
  80a849:	b8 00 00 00 00       	mov    $0x0,%eax
  80a84e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80a855:	00 00 00 
  80a858:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80a85a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80a85e:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a862:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80a866:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80a86b:	75 2a                	jne    80a897 <dhcp_bind+0x7a>
  80a86d:	48 ba a4 1a 82 00 00 	movabs $0x821aa4,%rdx
  80a874:	00 00 00 
  80a877:	be 40 03 00 00       	mov    $0x340,%esi
  80a87c:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80a883:	00 00 00 
  80a886:	b8 00 00 00 00       	mov    $0x0,%eax
  80a88b:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80a892:	00 00 00 
  80a895:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  80a897:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a89b:	8b 40 6c             	mov    0x6c(%rax),%eax
  80a89e:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a8a1:	74 4d                	je     80a8f0 <dhcp_bind+0xd3>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80a8a3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a8a7:	8b 40 6c             	mov    0x6c(%rax),%eax
  80a8aa:	83 c0 1e             	add    $0x1e,%eax
  80a8ad:	ba 89 88 88 88       	mov    $0x88888889,%edx
  80a8b2:	f7 e2                	mul    %edx
  80a8b4:	89 d0                	mov    %edx,%eax
  80a8b6:	c1 e8 05             	shr    $0x5,%eax
  80a8b9:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if(timeout > 0xffff) {
  80a8bc:	81 7d fc ff ff 00 00 	cmpl   $0xffff,-0x4(%rbp)
  80a8c3:	76 07                	jbe    80a8cc <dhcp_bind+0xaf>
      timeout = 0xffff;
  80a8c5:	c7 45 fc ff ff 00 00 	movl   $0xffff,-0x4(%rbp)
    }
    dhcp->t1_timeout = (u16_t)timeout;
  80a8cc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80a8cf:	89 c2                	mov    %eax,%edx
  80a8d1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a8d5:	66 89 50 44          	mov    %dx,0x44(%rax)
    if (dhcp->t1_timeout == 0) {
  80a8d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a8dd:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  80a8e1:	66 85 c0             	test   %ax,%ax
  80a8e4:	75 0a                	jne    80a8f0 <dhcp_bind+0xd3>
      dhcp->t1_timeout = 1;
  80a8e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a8ea:	66 c7 40 44 01 00    	movw   $0x1,0x44(%rax)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  80a8f0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a8f4:	8b 40 70             	mov    0x70(%rax),%eax
  80a8f7:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a8fa:	74 4d                	je     80a949 <dhcp_bind+0x12c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80a8fc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a900:	8b 40 70             	mov    0x70(%rax),%eax
  80a903:	83 c0 1e             	add    $0x1e,%eax
  80a906:	ba 89 88 88 88       	mov    $0x88888889,%edx
  80a90b:	f7 e2                	mul    %edx
  80a90d:	89 d0                	mov    %edx,%eax
  80a90f:	c1 e8 05             	shr    $0x5,%eax
  80a912:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if(timeout > 0xffff) {
  80a915:	81 7d fc ff ff 00 00 	cmpl   $0xffff,-0x4(%rbp)
  80a91c:	76 07                	jbe    80a925 <dhcp_bind+0x108>
      timeout = 0xffff;
  80a91e:	c7 45 fc ff ff 00 00 	movl   $0xffff,-0x4(%rbp)
    }
    dhcp->t2_timeout = (u16_t)timeout;
  80a925:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80a928:	89 c2                	mov    %eax,%edx
  80a92a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a92e:	66 89 50 46          	mov    %dx,0x46(%rax)
    if (dhcp->t2_timeout == 0) {
  80a932:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a936:	0f b7 40 46          	movzwl 0x46(%rax),%eax
  80a93a:	66 85 c0             	test   %ax,%ax
  80a93d:	75 0a                	jne    80a949 <dhcp_bind+0x12c>
      dhcp->t2_timeout = 1;
  80a93f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a943:	66 c7 40 46 01 00    	movw   $0x1,0x46(%rax)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80a949:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a94d:	48 83 c0 50          	add    $0x50,%rax
  80a951:	48 85 c0             	test   %rax,%rax
  80a954:	74 09                	je     80a95f <dhcp_bind+0x142>
  80a956:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a95a:	8b 40 50             	mov    0x50(%rax),%eax
  80a95d:	eb 05                	jmp    80a964 <dhcp_bind+0x147>
  80a95f:	b8 00 00 00 00       	mov    $0x0,%eax
  80a964:	89 45 e0             	mov    %eax,-0x20(%rbp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  80a967:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80a96a:	85 c0                	test   %eax,%eax
  80a96c:	75 65                	jne    80a9d3 <dhcp_bind+0x1b6>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  80a96e:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80a971:	89 c7                	mov    %eax,%edi
  80a973:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  80a97a:	00 00 00 
  80a97d:	ff d0                	callq  *%rax
  80a97f:	c1 e8 18             	shr    $0x18,%eax
  80a982:	88 45 ef             	mov    %al,-0x11(%rbp)
    if (first_octet <= 127) {
  80a985:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80a989:	84 c0                	test   %al,%al
  80a98b:	78 16                	js     80a9a3 <dhcp_bind+0x186>
      sn_mask.addr = htonl(0xff000000);
  80a98d:	bf 00 00 00 ff       	mov    $0xff000000,%edi
  80a992:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  80a999:	00 00 00 
  80a99c:	ff d0                	callq  *%rax
  80a99e:	89 45 e0             	mov    %eax,-0x20(%rbp)
  80a9a1:	eb 30                	jmp    80a9d3 <dhcp_bind+0x1b6>
    } else if (first_octet >= 192) {
  80a9a3:	80 7d ef bf          	cmpb   $0xbf,-0x11(%rbp)
  80a9a7:	76 16                	jbe    80a9bf <dhcp_bind+0x1a2>
      sn_mask.addr = htonl(0xffffff00);
  80a9a9:	bf 00 ff ff ff       	mov    $0xffffff00,%edi
  80a9ae:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  80a9b5:	00 00 00 
  80a9b8:	ff d0                	callq  *%rax
  80a9ba:	89 45 e0             	mov    %eax,-0x20(%rbp)
  80a9bd:	eb 14                	jmp    80a9d3 <dhcp_bind+0x1b6>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  80a9bf:	bf 00 00 ff ff       	mov    $0xffff0000,%edi
  80a9c4:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  80a9cb:	00 00 00 
  80a9ce:	ff d0                	callq  *%rax
  80a9d0:	89 45 e0             	mov    %eax,-0x20(%rbp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  80a9d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a9d7:	48 83 c0 54          	add    $0x54,%rax
  80a9db:	48 85 c0             	test   %rax,%rax
  80a9de:	74 09                	je     80a9e9 <dhcp_bind+0x1cc>
  80a9e0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a9e4:	8b 40 54             	mov    0x54(%rax),%eax
  80a9e7:	eb 05                	jmp    80a9ee <dhcp_bind+0x1d1>
  80a9e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80a9ee:	89 45 d0             	mov    %eax,-0x30(%rbp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  80a9f1:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80a9f4:	85 c0                	test   %eax,%eax
  80a9f6:	75 2a                	jne    80aa22 <dhcp_bind+0x205>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  80a9f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a9fc:	8b 50 4c             	mov    0x4c(%rax),%edx
  80a9ff:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80aa02:	21 d0                	and    %edx,%eax
  80aa04:	89 45 d0             	mov    %eax,-0x30(%rbp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  80aa07:	bf 01 00 00 00       	mov    $0x1,%edi
  80aa0c:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  80aa13:	00 00 00 
  80aa16:	ff d0                	callq  *%rax
  80aa18:	89 c2                	mov    %eax,%edx
  80aa1a:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80aa1d:	09 d0                	or     %edx,%eax
  80aa1f:	89 45 d0             	mov    %eax,-0x30(%rbp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  80aa22:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80aa26:	48 8d 50 4c          	lea    0x4c(%rax),%rdx
  80aa2a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80aa2e:	48 89 d6             	mov    %rdx,%rsi
  80aa31:	48 89 c7             	mov    %rax,%rdi
  80aa34:	48 b8 29 d2 80 00 00 	movabs $0x80d229,%rax
  80aa3b:	00 00 00 
  80aa3e:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  80aa40:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  80aa44:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80aa48:	48 89 d6             	mov    %rdx,%rsi
  80aa4b:	48 89 c7             	mov    %rax,%rdi
  80aa4e:	48 b8 5e d3 80 00 00 	movabs $0x80d35e,%rax
  80aa55:	00 00 00 
  80aa58:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  80aa5a:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80aa5e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80aa62:	48 89 d6             	mov    %rdx,%rsi
  80aa65:	48 89 c7             	mov    %rax,%rdi
  80aa68:	48 b8 30 d3 80 00 00 	movabs $0x80d330,%rax
  80aa6f:	00 00 00 
  80aa72:	ff d0                	callq  *%rax
  /* bring the interface up */
  netif_set_up(netif);
  80aa74:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80aa78:	48 89 c7             	mov    %rax,%rdi
  80aa7b:	48 b8 ac d3 80 00 00 	movabs $0x80d3ac,%rax
  80aa82:	00 00 00 
  80aa85:	ff d0                	callq  *%rax
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  80aa87:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80aa8b:	be 0a 00 00 00       	mov    $0xa,%esi
  80aa90:	48 89 c7             	mov    %rax,%rdi
  80aa93:	48 b8 a2 b1 80 00 00 	movabs $0x80b1a2,%rax
  80aa9a:	00 00 00 
  80aa9d:	ff d0                	callq  *%rax
}
  80aa9f:	90                   	nop
  80aaa0:	c9                   	leaveq 
  80aaa1:	c3                   	retq   

000000000080aaa2 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  80aaa2:	55                   	push   %rbp
  80aaa3:	48 89 e5             	mov    %rsp,%rbp
  80aaa6:	48 83 ec 20          	sub    $0x20,%rsp
  80aaaa:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80aaae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aab2:	48 8b 40 38          	mov    0x38(%rax),%rax
  80aab6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  80aaba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aabe:	be 05 00 00 00       	mov    $0x5,%esi
  80aac3:	48 89 c7             	mov    %rax,%rdi
  80aac6:	48 b8 a2 b1 80 00 00 	movabs $0x80b1a2,%rax
  80aacd:	00 00 00 
  80aad0:	ff d0                	callq  *%rax

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80aad2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aad6:	48 89 c7             	mov    %rax,%rdi
  80aad9:	48 b8 b2 b9 80 00 00 	movabs $0x80b9b2,%rax
  80aae0:	00 00 00 
  80aae3:	ff d0                	callq  *%rax
  80aae5:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80aae8:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80aaec:	0f 85 12 01 00 00    	jne    80ac04 <dhcp_renew+0x162>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80aaf2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aaf6:	ba 01 00 00 00       	mov    $0x1,%edx
  80aafb:	be 35 00 00 00       	mov    $0x35,%esi
  80ab00:	48 89 c7             	mov    %rax,%rdi
  80ab03:	48 b8 d4 b1 80 00 00 	movabs $0x80b1d4,%rax
  80ab0a:	00 00 00 
  80ab0d:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80ab0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab13:	be 03 00 00 00       	mov    $0x3,%esi
  80ab18:	48 89 c7             	mov    %rax,%rdi
  80ab1b:	48 b8 86 b2 80 00 00 	movabs $0x80b286,%rax
  80ab22:	00 00 00 
  80ab25:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80ab27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab2b:	ba 02 00 00 00       	mov    $0x2,%edx
  80ab30:	be 39 00 00 00       	mov    $0x39,%esi
  80ab35:	48 89 c7             	mov    %rax,%rdi
  80ab38:	48 b8 d4 b1 80 00 00 	movabs $0x80b1d4,%rax
  80ab3f:	00 00 00 
  80ab42:	ff d0                	callq  *%rax
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  80ab44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab48:	be 40 02 00 00       	mov    $0x240,%esi
  80ab4d:	48 89 c7             	mov    %rax,%rdi
  80ab50:	48 b8 fd b2 80 00 00 	movabs $0x80b2fd,%rax
  80ab57:	00 00 00 
  80ab5a:	ff d0                	callq  *%rax
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  80ab5c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab60:	48 89 c7             	mov    %rax,%rdi
  80ab63:	48 b8 31 be 80 00 00 	movabs $0x80be31,%rax
  80ab6a:	00 00 00 
  80ab6d:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80ab6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab73:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ab77:	66 05 f0 00          	add    $0xf0,%ax
  80ab7b:	0f b7 d0             	movzwl %ax,%edx
  80ab7e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab82:	48 8b 40 30          	mov    0x30(%rax),%rax
  80ab86:	89 d6                	mov    %edx,%esi
  80ab88:	48 89 c7             	mov    %rax,%rdi
  80ab8b:	48 b8 3f d9 80 00 00 	movabs $0x80d93f,%rax
  80ab92:	00 00 00 
  80ab95:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  80ab97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab9b:	48 8d 48 48          	lea    0x48(%rax),%rcx
  80ab9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aba3:	48 8b 40 08          	mov    0x8(%rax),%rax
  80aba7:	ba 43 00 00 00       	mov    $0x43,%edx
  80abac:	48 89 ce             	mov    %rcx,%rsi
  80abaf:	48 89 c7             	mov    %rax,%rdi
  80abb2:	48 b8 42 58 81 00 00 	movabs $0x815842,%rax
  80abb9:	00 00 00 
  80abbc:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  80abbe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abc2:	48 8d 50 48          	lea    0x48(%rax),%rdx
  80abc6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abca:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80abce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abd2:	48 8b 40 08          	mov    0x8(%rax),%rax
  80abd6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80abda:	49 89 c8             	mov    %rcx,%r8
  80abdd:	b9 43 00 00 00       	mov    $0x43,%ecx
  80abe2:	48 89 c7             	mov    %rax,%rdi
  80abe5:	48 b8 38 54 81 00 00 	movabs $0x815438,%rax
  80abec:	00 00 00 
  80abef:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80abf1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80abf5:	48 89 c7             	mov    %rax,%rdi
  80abf8:	48 b8 0a bd 80 00 00 	movabs $0x80bd0a,%rax
  80abff:	00 00 00 
  80ac02:	ff d0                	callq  *%rax

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80ac04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac08:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ac0c:	8d 50 01             	lea    0x1(%rax),%edx
  80ac0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac13:	88 50 01             	mov    %dl,0x1(%rax)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  80ac16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac1a:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ac1e:	3c 09                	cmp    $0x9,%al
  80ac20:	77 12                	ja     80ac34 <dhcp_renew+0x192>
  80ac22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac26:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ac2a:	0f b6 c0             	movzbl %al,%eax
  80ac2d:	66 69 c0 d0 07       	imul   $0x7d0,%ax,%ax
  80ac32:	eb 05                	jmp    80ac39 <dhcp_renew+0x197>
  80ac34:	b8 20 4e 00 00       	mov    $0x4e20,%eax
  80ac39:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80ac3d:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80ac41:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80ac47:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80ac4c:	89 c8                	mov    %ecx,%eax
  80ac4e:	f7 ea                	imul   %edx
  80ac50:	c1 fa 05             	sar    $0x5,%edx
  80ac53:	89 c8                	mov    %ecx,%eax
  80ac55:	c1 f8 1f             	sar    $0x1f,%eax
  80ac58:	29 c2                	sub    %eax,%edx
  80ac5a:	89 d0                	mov    %edx,%eax
  80ac5c:	89 c2                	mov    %eax,%edx
  80ac5e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac62:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80ac66:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80ac6a:	c9                   	leaveq 
  80ac6b:	c3                   	retq   

000000000080ac6c <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  80ac6c:	55                   	push   %rbp
  80ac6d:	48 89 e5             	mov    %rsp,%rbp
  80ac70:	48 83 ec 20          	sub    $0x20,%rsp
  80ac74:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80ac78:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ac7c:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ac80:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  80ac84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac88:	be 04 00 00 00       	mov    $0x4,%esi
  80ac8d:	48 89 c7             	mov    %rax,%rdi
  80ac90:	48 b8 a2 b1 80 00 00 	movabs $0x80b1a2,%rax
  80ac97:	00 00 00 
  80ac9a:	ff d0                	callq  *%rax

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80ac9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aca0:	48 89 c7             	mov    %rax,%rdi
  80aca3:	48 b8 b2 b9 80 00 00 	movabs $0x80b9b2,%rax
  80acaa:	00 00 00 
  80acad:	ff d0                	callq  *%rax
  80acaf:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80acb2:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80acb6:	0f 85 13 01 00 00    	jne    80adcf <dhcp_rebind+0x163>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80acbc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80acc0:	ba 01 00 00 00       	mov    $0x1,%edx
  80acc5:	be 35 00 00 00       	mov    $0x35,%esi
  80acca:	48 89 c7             	mov    %rax,%rdi
  80accd:	48 b8 d4 b1 80 00 00 	movabs $0x80b1d4,%rax
  80acd4:	00 00 00 
  80acd7:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80acd9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80acdd:	be 03 00 00 00       	mov    $0x3,%esi
  80ace2:	48 89 c7             	mov    %rax,%rdi
  80ace5:	48 b8 86 b2 80 00 00 	movabs $0x80b286,%rax
  80acec:	00 00 00 
  80acef:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80acf1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80acf5:	ba 02 00 00 00       	mov    $0x2,%edx
  80acfa:	be 39 00 00 00       	mov    $0x39,%esi
  80acff:	48 89 c7             	mov    %rax,%rdi
  80ad02:	48 b8 d4 b1 80 00 00 	movabs $0x80b1d4,%rax
  80ad09:	00 00 00 
  80ad0c:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80ad0e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad12:	be 40 02 00 00       	mov    $0x240,%esi
  80ad17:	48 89 c7             	mov    %rax,%rdi
  80ad1a:	48 b8 fd b2 80 00 00 	movabs $0x80b2fd,%rax
  80ad21:	00 00 00 
  80ad24:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  80ad26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad2a:	48 89 c7             	mov    %rax,%rdi
  80ad2d:	48 b8 31 be 80 00 00 	movabs $0x80be31,%rax
  80ad34:	00 00 00 
  80ad37:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80ad39:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad3d:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ad41:	66 05 f0 00          	add    $0xf0,%ax
  80ad45:	0f b7 d0             	movzwl %ax,%edx
  80ad48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad4c:	48 8b 40 30          	mov    0x30(%rax),%rax
  80ad50:	89 d6                	mov    %edx,%esi
  80ad52:	48 89 c7             	mov    %rax,%rdi
  80ad55:	48 b8 3f d9 80 00 00 	movabs $0x80d93f,%rax
  80ad5c:	00 00 00 
  80ad5f:	ff d0                	callq  *%rax

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80ad61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad65:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ad69:	ba 43 00 00 00       	mov    $0x43,%edx
  80ad6e:	48 be 68 28 82 00 00 	movabs $0x822868,%rsi
  80ad75:	00 00 00 
  80ad78:	48 89 c7             	mov    %rax,%rdi
  80ad7b:	48 b8 42 58 81 00 00 	movabs $0x815842,%rax
  80ad82:	00 00 00 
  80ad85:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80ad87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad8b:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80ad8f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad93:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ad97:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80ad9b:	49 89 d0             	mov    %rdx,%r8
  80ad9e:	b9 43 00 00 00       	mov    $0x43,%ecx
  80ada3:	48 ba 6c 28 82 00 00 	movabs $0x82286c,%rdx
  80adaa:	00 00 00 
  80adad:	48 89 c7             	mov    %rax,%rdi
  80adb0:	48 b8 38 54 81 00 00 	movabs $0x815438,%rax
  80adb7:	00 00 00 
  80adba:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80adbc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80adc0:	48 89 c7             	mov    %rax,%rdi
  80adc3:	48 b8 0a bd 80 00 00 	movabs $0x80bd0a,%rax
  80adca:	00 00 00 
  80adcd:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80adcf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80add3:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80add7:	8d 50 01             	lea    0x1(%rax),%edx
  80adda:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80adde:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80ade1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ade5:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ade9:	3c 09                	cmp    $0x9,%al
  80adeb:	77 12                	ja     80adff <dhcp_rebind+0x193>
  80aded:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80adf1:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80adf5:	0f b6 c0             	movzbl %al,%eax
  80adf8:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80adfd:	eb 05                	jmp    80ae04 <dhcp_rebind+0x198>
  80adff:	b8 10 27 00 00       	mov    $0x2710,%eax
  80ae04:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80ae08:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80ae0c:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80ae12:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80ae17:	89 c8                	mov    %ecx,%eax
  80ae19:	f7 ea                	imul   %edx
  80ae1b:	c1 fa 05             	sar    $0x5,%edx
  80ae1e:	89 c8                	mov    %ecx,%eax
  80ae20:	c1 f8 1f             	sar    $0x1f,%eax
  80ae23:	29 c2                	sub    %eax,%edx
  80ae25:	89 d0                	mov    %edx,%eax
  80ae27:	89 c2                	mov    %eax,%edx
  80ae29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae2d:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80ae31:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80ae35:	c9                   	leaveq 
  80ae36:	c3                   	retq   

000000000080ae37 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  80ae37:	55                   	push   %rbp
  80ae38:	48 89 e5             	mov    %rsp,%rbp
  80ae3b:	48 83 ec 20          	sub    $0x20,%rsp
  80ae3f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80ae43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ae47:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ae4b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  80ae4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae53:	be 0d 00 00 00       	mov    $0xd,%esi
  80ae58:	48 89 c7             	mov    %rax,%rdi
  80ae5b:	48 b8 a2 b1 80 00 00 	movabs $0x80b1a2,%rax
  80ae62:	00 00 00 
  80ae65:	ff d0                	callq  *%rax
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  80ae67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae6b:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%rax)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  80ae72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae76:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%rax)
  80ae7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae81:	8b 50 50             	mov    0x50(%rax),%edx
  80ae84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae88:	89 50 4c             	mov    %edx,0x4c(%rax)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  80ae8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae8f:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%rax)
  80ae96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae9a:	8b 50 58             	mov    0x58(%rax),%edx
  80ae9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aea1:	89 50 54             	mov    %edx,0x54(%rax)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  80aea4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aea8:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%rax)
  80aeaf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aeb3:	8b 50 70             	mov    0x70(%rax),%edx
  80aeb6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aeba:	89 50 6c             	mov    %edx,0x6c(%rax)
  80aebd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aec1:	8b 50 6c             	mov    0x6c(%rax),%edx
  80aec4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aec8:	89 50 68             	mov    %edx,0x68(%rax)
  dhcp->dns_count = 0;
  80aecb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aecf:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80aed6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aeda:	48 89 c7             	mov    %rax,%rdi
  80aedd:	48 b8 b2 b9 80 00 00 	movabs $0x80b9b2,%rax
  80aee4:	00 00 00 
  80aee7:	ff d0                	callq  *%rax
  80aee9:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80aeec:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80aef0:	0f 85 dd 00 00 00    	jne    80afd3 <dhcp_release+0x19c>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80aef6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aefa:	ba 01 00 00 00       	mov    $0x1,%edx
  80aeff:	be 35 00 00 00       	mov    $0x35,%esi
  80af04:	48 89 c7             	mov    %rax,%rdi
  80af07:	48 b8 d4 b1 80 00 00 	movabs $0x80b1d4,%rax
  80af0e:	00 00 00 
  80af11:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  80af13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af17:	be 07 00 00 00       	mov    $0x7,%esi
  80af1c:	48 89 c7             	mov    %rax,%rdi
  80af1f:	48 b8 86 b2 80 00 00 	movabs $0x80b286,%rax
  80af26:	00 00 00 
  80af29:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80af2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af2f:	48 89 c7             	mov    %rax,%rdi
  80af32:	48 b8 31 be 80 00 00 	movabs $0x80be31,%rax
  80af39:	00 00 00 
  80af3c:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80af3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af42:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80af46:	66 05 f0 00          	add    $0xf0,%ax
  80af4a:	0f b7 d0             	movzwl %ax,%edx
  80af4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af51:	48 8b 40 30          	mov    0x30(%rax),%rax
  80af55:	89 d6                	mov    %edx,%esi
  80af57:	48 89 c7             	mov    %rax,%rdi
  80af5a:	48 b8 3f d9 80 00 00 	movabs $0x80d93f,%rax
  80af61:	00 00 00 
  80af64:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  80af66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af6a:	48 8d 48 48          	lea    0x48(%rax),%rcx
  80af6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af72:	48 8b 40 08          	mov    0x8(%rax),%rax
  80af76:	ba 43 00 00 00       	mov    $0x43,%edx
  80af7b:	48 89 ce             	mov    %rcx,%rsi
  80af7e:	48 89 c7             	mov    %rax,%rdi
  80af81:	48 b8 42 58 81 00 00 	movabs $0x815842,%rax
  80af88:	00 00 00 
  80af8b:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  80af8d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af91:	48 8d 50 48          	lea    0x48(%rax),%rdx
  80af95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af99:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80af9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80afa1:	48 8b 40 08          	mov    0x8(%rax),%rax
  80afa5:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80afa9:	49 89 c8             	mov    %rcx,%r8
  80afac:	b9 43 00 00 00       	mov    $0x43,%ecx
  80afb1:	48 89 c7             	mov    %rax,%rdi
  80afb4:	48 b8 38 54 81 00 00 	movabs $0x815438,%rax
  80afbb:	00 00 00 
  80afbe:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80afc0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80afc4:	48 89 c7             	mov    %rax,%rdi
  80afc7:	48 b8 0a bd 80 00 00 	movabs $0x80bd0a,%rax
  80afce:	00 00 00 
  80afd1:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80afd3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80afd7:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80afdb:	8d 50 01             	lea    0x1(%rax),%edx
  80afde:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80afe2:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80afe5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80afe9:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80afed:	3c 09                	cmp    $0x9,%al
  80afef:	77 12                	ja     80b003 <dhcp_release+0x1cc>
  80aff1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aff5:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80aff9:	0f b6 c0             	movzbl %al,%eax
  80affc:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80b001:	eb 05                	jmp    80b008 <dhcp_release+0x1d1>
  80b003:	b8 10 27 00 00       	mov    $0x2710,%eax
  80b008:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80b00c:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80b010:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80b016:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80b01b:	89 c8                	mov    %ecx,%eax
  80b01d:	f7 ea                	imul   %edx
  80b01f:	c1 fa 05             	sar    $0x5,%edx
  80b022:	89 c8                	mov    %ecx,%eax
  80b024:	c1 f8 1f             	sar    $0x1f,%eax
  80b027:	29 c2                	sub    %eax,%edx
  80b029:	89 d0                	mov    %edx,%eax
  80b02b:	89 c2                	mov    %eax,%edx
  80b02d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b031:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  80b035:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b039:	48 89 c7             	mov    %rax,%rdi
  80b03c:	48 b8 16 d4 80 00 00 	movabs $0x80d416,%rax
  80b043:	00 00 00 
  80b046:	ff d0                	callq  *%rax
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  80b048:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b04c:	48 be 68 28 82 00 00 	movabs $0x822868,%rsi
  80b053:	00 00 00 
  80b056:	48 89 c7             	mov    %rax,%rdi
  80b059:	48 b8 29 d2 80 00 00 	movabs $0x80d229,%rax
  80b060:	00 00 00 
  80b063:	ff d0                	callq  *%rax
  netif_set_gw(netif, IP_ADDR_ANY);
  80b065:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b069:	48 be 68 28 82 00 00 	movabs $0x822868,%rsi
  80b070:	00 00 00 
  80b073:	48 89 c7             	mov    %rax,%rdi
  80b076:	48 b8 30 d3 80 00 00 	movabs $0x80d330,%rax
  80b07d:	00 00 00 
  80b080:	ff d0                	callq  *%rax
  netif_set_netmask(netif, IP_ADDR_ANY);
  80b082:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b086:	48 be 68 28 82 00 00 	movabs $0x822868,%rsi
  80b08d:	00 00 00 
  80b090:	48 89 c7             	mov    %rax,%rdi
  80b093:	48 b8 5e d3 80 00 00 	movabs $0x80d35e,%rax
  80b09a:	00 00 00 
  80b09d:	ff d0                	callq  *%rax
  
  /* TODO: netif_down(netif); */
  return result;
  80b09f:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80b0a3:	c9                   	leaveq 
  80b0a4:	c3                   	retq   

000000000080b0a5 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  80b0a5:	55                   	push   %rbp
  80b0a6:	48 89 e5             	mov    %rsp,%rbp
  80b0a9:	48 83 ec 20          	sub    $0x20,%rsp
  80b0ad:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80b0b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b0b5:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b0b9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  80b0bd:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80b0c2:	75 2a                	jne    80b0ee <dhcp_stop+0x49>
  80b0c4:	48 ba bc 1a 82 00 00 	movabs $0x821abc,%rdx
  80b0cb:	00 00 00 
  80b0ce:	be 2d 04 00 00       	mov    $0x42d,%esi
  80b0d3:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80b0da:	00 00 00 
  80b0dd:	b8 00 00 00 00       	mov    $0x0,%eax
  80b0e2:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80b0e9:	00 00 00 
  80b0ec:	ff d1                	callq  *%rcx
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  80b0ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b0f2:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80b0f6:	83 e0 f7             	and    $0xfffffff7,%eax
  80b0f9:	89 c2                	mov    %eax,%edx
  80b0fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b0ff:	88 50 4a             	mov    %dl,0x4a(%rax)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  80b102:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80b107:	0f 84 92 00 00 00    	je     80b19f <dhcp_stop+0xfa>
    if (dhcp->pcb != NULL) {
  80b10d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b111:	48 8b 40 08          	mov    0x8(%rax),%rax
  80b115:	48 85 c0             	test   %rax,%rax
  80b118:	74 23                	je     80b13d <dhcp_stop+0x98>
      udp_remove(dhcp->pcb);
  80b11a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b11e:	48 8b 40 08          	mov    0x8(%rax),%rax
  80b122:	48 89 c7             	mov    %rax,%rdi
  80b125:	48 b8 aa 59 81 00 00 	movabs $0x8159aa,%rax
  80b12c:	00 00 00 
  80b12f:	ff d0                	callq  *%rax
      dhcp->pcb = NULL;
  80b131:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b135:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80b13c:	00 
    }
    if (dhcp->p != NULL) {
  80b13d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b141:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b145:	48 85 c0             	test   %rax,%rax
  80b148:	74 23                	je     80b16d <dhcp_stop+0xc8>
      pbuf_free(dhcp->p);
  80b14a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b14e:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b152:	48 89 c7             	mov    %rax,%rdi
  80b155:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  80b15c:	00 00 00 
  80b15f:	ff d0                	callq  *%rax
      dhcp->p = NULL;
  80b161:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b165:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80b16c:	00 
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  80b16d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b171:	48 89 c7             	mov    %rax,%rdi
  80b174:	48 b8 d9 b6 80 00 00 	movabs $0x80b6d9,%rax
  80b17b:	00 00 00 
  80b17e:	ff d0                	callq  *%rax
    mem_free((void *)dhcp);
  80b180:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b184:	48 89 c7             	mov    %rax,%rdi
  80b187:	48 b8 f2 c4 80 00 00 	movabs $0x80c4f2,%rax
  80b18e:	00 00 00 
  80b191:	ff d0                	callq  *%rax
    netif->dhcp = NULL;
  80b193:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b197:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80b19e:	00 
  }
}
  80b19f:	90                   	nop
  80b1a0:	c9                   	leaveq 
  80b1a1:	c3                   	retq   

000000000080b1a2 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  80b1a2:	55                   	push   %rbp
  80b1a3:	48 89 e5             	mov    %rsp,%rbp
  80b1a6:	48 83 ec 10          	sub    $0x10,%rsp
  80b1aa:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b1ae:	89 f0                	mov    %esi,%eax
  80b1b0:	88 45 f4             	mov    %al,-0xc(%rbp)
  if (new_state != dhcp->state) {
  80b1b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1b7:	0f b6 00             	movzbl (%rax),%eax
  80b1ba:	3a 45 f4             	cmp    -0xc(%rbp),%al
  80b1bd:	74 12                	je     80b1d1 <dhcp_set_state+0x2f>
    dhcp->state = new_state;
  80b1bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1c3:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  80b1c7:	88 10                	mov    %dl,(%rax)
    dhcp->tries = 0;
  80b1c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1cd:	c6 40 01 00          	movb   $0x0,0x1(%rax)
  }
}
  80b1d1:	90                   	nop
  80b1d2:	c9                   	leaveq 
  80b1d3:	c3                   	retq   

000000000080b1d4 <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  80b1d4:	55                   	push   %rbp
  80b1d5:	48 89 e5             	mov    %rsp,%rbp
  80b1d8:	48 83 ec 10          	sub    $0x10,%rsp
  80b1dc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b1e0:	89 f1                	mov    %esi,%ecx
  80b1e2:	89 d0                	mov    %edx,%eax
  80b1e4:	88 4d f4             	mov    %cl,-0xc(%rbp)
  80b1e7:	88 45 f0             	mov    %al,-0x10(%rbp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  80b1ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1ee:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b1f2:	0f b7 d0             	movzwl %ax,%edx
  80b1f5:	0f b6 45 f0          	movzbl -0x10(%rbp),%eax
  80b1f9:	01 d0                	add    %edx,%eax
  80b1fb:	83 c0 02             	add    $0x2,%eax
  80b1fe:	83 f8 44             	cmp    $0x44,%eax
  80b201:	76 2a                	jbe    80b22d <dhcp_option+0x59>
  80b203:	48 ba d8 1a 82 00 00 	movabs $0x821ad8,%rdx
  80b20a:	00 00 00 
  80b20d:	be 5b 04 00 00       	mov    $0x45b,%esi
  80b212:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80b219:	00 00 00 
  80b21c:	b8 00 00 00 00       	mov    $0x0,%eax
  80b221:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80b228:	00 00 00 
  80b22b:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  80b22d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b231:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b235:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b239:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b23d:	8d 70 01             	lea    0x1(%rax),%esi
  80b240:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b244:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b248:	0f b7 c0             	movzwl %ax,%eax
  80b24b:	48 98                	cltq   
  80b24d:	0f b6 4d f4          	movzbl -0xc(%rbp),%ecx
  80b251:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  80b258:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b25c:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b260:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b264:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b268:	8d 70 01             	lea    0x1(%rax),%esi
  80b26b:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b26f:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b273:	0f b7 c0             	movzwl %ax,%eax
  80b276:	48 98                	cltq   
  80b278:	0f b6 4d f0          	movzbl -0x10(%rbp),%ecx
  80b27c:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80b283:	90                   	nop
  80b284:	c9                   	leaveq 
  80b285:	c3                   	retq   

000000000080b286 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  80b286:	55                   	push   %rbp
  80b287:	48 89 e5             	mov    %rsp,%rbp
  80b28a:	48 83 ec 10          	sub    $0x10,%rsp
  80b28e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b292:	89 f0                	mov    %esi,%eax
  80b294:	88 45 f4             	mov    %al,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80b297:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b29b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b29f:	66 83 f8 43          	cmp    $0x43,%ax
  80b2a3:	76 2a                	jbe    80b2cf <dhcp_option_byte+0x49>
  80b2a5:	48 ba 20 1b 82 00 00 	movabs $0x821b20,%rdx
  80b2ac:	00 00 00 
  80b2af:	be 66 04 00 00       	mov    $0x466,%esi
  80b2b4:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80b2bb:	00 00 00 
  80b2be:	b8 00 00 00 00       	mov    $0x0,%eax
  80b2c3:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80b2ca:	00 00 00 
  80b2cd:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  80b2cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b2d3:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b2d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b2db:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b2df:	8d 70 01             	lea    0x1(%rax),%esi
  80b2e2:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b2e6:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b2ea:	0f b7 c0             	movzwl %ax,%eax
  80b2ed:	48 98                	cltq   
  80b2ef:	0f b6 4d f4          	movzbl -0xc(%rbp),%ecx
  80b2f3:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80b2fa:	90                   	nop
  80b2fb:	c9                   	leaveq 
  80b2fc:	c3                   	retq   

000000000080b2fd <dhcp_option_short>:

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  80b2fd:	55                   	push   %rbp
  80b2fe:	48 89 e5             	mov    %rsp,%rbp
  80b301:	48 83 ec 10          	sub    $0x10,%rsp
  80b305:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b309:	89 f0                	mov    %esi,%eax
  80b30b:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  80b30f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b313:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b317:	0f b7 c0             	movzwl %ax,%eax
  80b31a:	83 c0 02             	add    $0x2,%eax
  80b31d:	83 f8 44             	cmp    $0x44,%eax
  80b320:	76 2a                	jbe    80b34c <dhcp_option_short+0x4f>
  80b322:	48 ba 60 1b 82 00 00 	movabs $0x821b60,%rdx
  80b329:	00 00 00 
  80b32c:	be 6d 04 00 00       	mov    $0x46d,%esi
  80b331:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80b338:	00 00 00 
  80b33b:	b8 00 00 00 00       	mov    $0x0,%eax
  80b340:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80b347:	00 00 00 
  80b34a:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  80b34c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b350:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b354:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b358:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b35c:	8d 70 01             	lea    0x1(%rax),%esi
  80b35f:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b363:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b367:	0f b7 c0             	movzwl %ax,%eax
  80b36a:	0f b7 4d f4          	movzwl -0xc(%rbp),%ecx
  80b36e:	66 c1 e9 08          	shr    $0x8,%cx
  80b372:	48 98                	cltq   
  80b374:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  80b37b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b37f:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b383:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b387:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b38b:	8d 70 01             	lea    0x1(%rax),%esi
  80b38e:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b392:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b396:	0f b7 c0             	movzwl %ax,%eax
  80b399:	0f b7 4d f4          	movzwl -0xc(%rbp),%ecx
  80b39d:	48 98                	cltq   
  80b39f:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80b3a6:	90                   	nop
  80b3a7:	c9                   	leaveq 
  80b3a8:	c3                   	retq   

000000000080b3a9 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  80b3a9:	55                   	push   %rbp
  80b3aa:	48 89 e5             	mov    %rsp,%rbp
  80b3ad:	48 83 ec 10          	sub    $0x10,%rsp
  80b3b1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b3b5:	89 75 f4             	mov    %esi,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  80b3b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b3bc:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b3c0:	0f b7 c0             	movzwl %ax,%eax
  80b3c3:	83 c0 04             	add    $0x4,%eax
  80b3c6:	83 f8 44             	cmp    $0x44,%eax
  80b3c9:	76 2a                	jbe    80b3f5 <dhcp_option_long+0x4c>
  80b3cb:	48 ba a8 1b 82 00 00 	movabs $0x821ba8,%rdx
  80b3d2:	00 00 00 
  80b3d5:	be 75 04 00 00       	mov    $0x475,%esi
  80b3da:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80b3e1:	00 00 00 
  80b3e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80b3e9:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80b3f0:	00 00 00 
  80b3f3:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  80b3f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b3f9:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b3fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b401:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b405:	8d 70 01             	lea    0x1(%rax),%esi
  80b408:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b40c:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b410:	0f b7 c0             	movzwl %ax,%eax
  80b413:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b416:	c1 e9 18             	shr    $0x18,%ecx
  80b419:	48 98                	cltq   
  80b41b:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  80b422:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b426:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b42a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b42e:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b432:	8d 70 01             	lea    0x1(%rax),%esi
  80b435:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b439:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b43d:	0f b7 c0             	movzwl %ax,%eax
  80b440:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b443:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
  80b449:	48 c1 e9 10          	shr    $0x10,%rcx
  80b44d:	48 98                	cltq   
  80b44f:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  80b456:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b45a:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b45e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b462:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b466:	8d 70 01             	lea    0x1(%rax),%esi
  80b469:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b46d:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b471:	0f b7 c0             	movzwl %ax,%eax
  80b474:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b477:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  80b47d:	48 c1 e9 08          	shr    $0x8,%rcx
  80b481:	48 98                	cltq   
  80b483:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  80b48a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b48e:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b492:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b496:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b49a:	8d 70 01             	lea    0x1(%rax),%esi
  80b49d:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b4a1:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b4a5:	0f b7 c0             	movzwl %ax,%eax
  80b4a8:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b4ab:	48 98                	cltq   
  80b4ad:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80b4b4:	90                   	nop
  80b4b5:	c9                   	leaveq 
  80b4b6:	c3                   	retq   

000000000080b4b7 <dhcp_unfold_reply>:
 * use that further on.
 *
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  80b4b7:	55                   	push   %rbp
  80b4b8:	48 89 e5             	mov    %rsp,%rbp
  80b4bb:	48 83 ec 20          	sub    $0x20,%rsp
  80b4bf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  80b4c3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80b4c8:	75 2a                	jne    80b4f4 <dhcp_unfold_reply+0x3d>
  80b4ca:	48 ba e8 1b 82 00 00 	movabs $0x821be8,%rdx
  80b4d1:	00 00 00 
  80b4d4:	be 8a 04 00 00       	mov    $0x48a,%esi
  80b4d9:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80b4e0:	00 00 00 
  80b4e3:	b8 00 00 00 00       	mov    $0x0,%eax
  80b4e8:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80b4ef:	00 00 00 
  80b4f2:	ff d1                	callq  *%rcx
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  80b4f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b4f8:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b4fc:	48 85 c0             	test   %rax,%rax
  80b4ff:	75 2a                	jne    80b52b <dhcp_unfold_reply+0x74>
  80b501:	48 ba f5 1b 82 00 00 	movabs $0x821bf5,%rdx
  80b508:	00 00 00 
  80b50b:	be 8b 04 00 00       	mov    $0x48b,%esi
  80b510:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80b517:	00 00 00 
  80b51a:	b8 00 00 00 00       	mov    $0x0,%eax
  80b51f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80b526:	00 00 00 
  80b529:	ff d1                	callq  *%rcx
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  80b52b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b52f:	48 89 c7             	mov    %rax,%rdi
  80b532:	48 b8 d9 b6 80 00 00 	movabs $0x80b6d9,%rax
  80b539:	00 00 00 
  80b53c:	ff d0                	callq  *%rax
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  80b53e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b542:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b546:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80b54a:	66 3d f0 00          	cmp    $0xf0,%ax
  80b54e:	76 55                	jbe    80b5a5 <dhcp_unfold_reply+0xee>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b550:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b554:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b558:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80b55c:	8d 90 10 ff ff ff    	lea    -0xf0(%rax),%edx
  80b562:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b566:	66 89 50 28          	mov    %dx,0x28(%rax)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  80b56a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b56e:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b572:	0f b7 c0             	movzwl %ax,%eax
  80b575:	89 c7                	mov    %eax,%edi
  80b577:	48 b8 95 c9 80 00 00 	movabs $0x80c995,%rax
  80b57e:	00 00 00 
  80b581:	ff d0                	callq  *%rax
  80b583:	48 89 c2             	mov    %rax,%rdx
  80b586:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b58a:	48 89 50 20          	mov    %rdx,0x20(%rax)
    if (dhcp->options_in == NULL) {
  80b58e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b592:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b596:	48 85 c0             	test   %rax,%rax
  80b599:	75 0a                	jne    80b5a5 <dhcp_unfold_reply+0xee>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
  80b59b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b5a0:	e9 32 01 00 00       	jmpq   80b6d7 <dhcp_unfold_reply+0x220>
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b5a5:	bf f0 00 00 00       	mov    $0xf0,%edi
  80b5aa:	48 b8 95 c9 80 00 00 	movabs $0x80c995,%rax
  80b5b1:	00 00 00 
  80b5b4:	ff d0                	callq  *%rax
  80b5b6:	48 89 c2             	mov    %rax,%rdx
  80b5b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5bd:	48 89 50 18          	mov    %rdx,0x18(%rax)
  if (dhcp->msg_in == NULL) {
  80b5c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5c5:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b5c9:	48 85 c0             	test   %rax,%rax
  80b5cc:	75 2d                	jne    80b5fb <dhcp_unfold_reply+0x144>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  80b5ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5d2:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b5d6:	48 89 c7             	mov    %rax,%rdi
  80b5d9:	48 b8 f2 c4 80 00 00 	movabs $0x80c4f2,%rax
  80b5e0:	00 00 00 
  80b5e3:	ff d0                	callq  *%rax
    dhcp->options_in = NULL;
  80b5e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5e9:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  80b5f0:	00 
    return ERR_MEM;
  80b5f1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b5f6:	e9 dc 00 00 00       	jmpq   80b6d7 <dhcp_unfold_reply+0x220>
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  80b5fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5ff:	48 8b 70 18          	mov    0x18(%rax),%rsi
  80b603:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b607:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b60b:	b9 00 00 00 00       	mov    $0x0,%ecx
  80b610:	ba f0 00 00 00       	mov    $0xf0,%edx
  80b615:	48 89 c7             	mov    %rax,%rdi
  80b618:	48 b8 5e e4 80 00 00 	movabs $0x80e45e,%rax
  80b61f:	00 00 00 
  80b622:	ff d0                	callq  *%rax
  80b624:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b628:	66 81 7d fe f0 00    	cmpw   $0xf0,-0x2(%rbp)
  80b62e:	74 2a                	je     80b65a <dhcp_unfold_reply+0x1a3>
  80b630:	48 ba 08 1c 82 00 00 	movabs $0x821c08,%rdx
  80b637:	00 00 00 
  80b63a:	be a1 04 00 00       	mov    $0x4a1,%esi
  80b63f:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80b646:	00 00 00 
  80b649:	b8 00 00 00 00       	mov    $0x0,%eax
  80b64e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80b655:	00 00 00 
  80b658:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  80b65a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b65e:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b662:	48 85 c0             	test   %rax,%rax
  80b665:	74 6b                	je     80b6d2 <dhcp_unfold_reply+0x21b>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b667:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b66b:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b66f:	0f b7 d0             	movzwl %ax,%edx
  80b672:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b676:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80b67a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b67e:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b682:	b9 f0 00 00 00       	mov    $0xf0,%ecx
  80b687:	48 89 c7             	mov    %rax,%rdi
  80b68a:	48 b8 5e e4 80 00 00 	movabs $0x80e45e,%rax
  80b691:	00 00 00 
  80b694:	ff d0                	callq  *%rax
  80b696:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  80b69a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b69e:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b6a2:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80b6a6:	74 2a                	je     80b6d2 <dhcp_unfold_reply+0x21b>
  80b6a8:	48 ba 3a 1c 82 00 00 	movabs $0x821c3a,%rdx
  80b6af:	00 00 00 
  80b6b2:	be a8 04 00 00       	mov    $0x4a8,%esi
  80b6b7:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80b6be:	00 00 00 
  80b6c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80b6c6:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80b6cd:	00 00 00 
  80b6d0:	ff d1                	callq  *%rcx
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes to dhcp->options_in[]\n",
      dhcp->options_in_len));
  }
  LWIP_UNUSED_ARG(ret);
  return ERR_OK;
  80b6d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b6d7:	c9                   	leaveq 
  80b6d8:	c3                   	retq   

000000000080b6d9 <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  80b6d9:	55                   	push   %rbp
  80b6da:	48 89 e5             	mov    %rsp,%rbp
  80b6dd:	48 83 ec 10          	sub    $0x10,%rsp
  80b6e1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (dhcp->msg_in != NULL) {
  80b6e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b6e9:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b6ed:	48 85 c0             	test   %rax,%rax
  80b6f0:	74 23                	je     80b715 <dhcp_free_reply+0x3c>
    mem_free((void *)dhcp->msg_in);
  80b6f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b6f6:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b6fa:	48 89 c7             	mov    %rax,%rdi
  80b6fd:	48 b8 f2 c4 80 00 00 	movabs $0x80c4f2,%rax
  80b704:	00 00 00 
  80b707:	ff d0                	callq  *%rax
    dhcp->msg_in = NULL;
  80b709:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b70d:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  80b714:	00 
  }
  if (dhcp->options_in) {
  80b715:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b719:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b71d:	48 85 c0             	test   %rax,%rax
  80b720:	74 2d                	je     80b74f <dhcp_free_reply+0x76>
    mem_free((void *)dhcp->options_in);
  80b722:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b726:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b72a:	48 89 c7             	mov    %rax,%rdi
  80b72d:	48 b8 f2 c4 80 00 00 	movabs $0x80c4f2,%rax
  80b734:	00 00 00 
  80b737:	ff d0                	callq  *%rax
    dhcp->options_in = NULL;
  80b739:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b73d:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  80b744:	00 
    dhcp->options_in_len = 0;
  80b745:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b749:	66 c7 40 28 00 00    	movw   $0x0,0x28(%rax)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  80b74f:	90                   	nop
  80b750:	c9                   	leaveq 
  80b751:	c3                   	retq   

000000000080b752 <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  80b752:	55                   	push   %rbp
  80b753:	48 89 e5             	mov    %rsp,%rbp
  80b756:	48 83 ec 60          	sub    $0x60,%rsp
  80b75a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80b75e:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80b762:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80b766:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80b76a:	44 89 c0             	mov    %r8d,%eax
  80b76d:	66 89 45 ac          	mov    %ax,-0x54(%rbp)
  struct netif *netif = (struct netif *)arg;
  80b771:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80b775:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80b779:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b77d:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b781:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  80b785:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80b789:	48 8b 40 08          	mov    0x8(%rax),%rax
  80b78d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  80b791:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b795:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80b799:	48 89 50 10          	mov    %rdx,0x10(%rax)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  80b79d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b7a1:	0f b6 00             	movzbl (%rax),%eax
  80b7a4:	3c 02                	cmp    $0x2,%al
  80b7a6:	0f 85 d7 01 00 00    	jne    80b983 <dhcp_recv+0x231>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80b7ac:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  80b7b0:	eb 30                	jmp    80b7e2 <dhcp_recv+0x90>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  80b7b2:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80b7b6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80b7ba:	48 98                	cltq   
  80b7bc:	0f b6 4c 02 41       	movzbl 0x41(%rdx,%rax,1),%ecx
  80b7c1:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80b7c5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80b7c9:	48 98                	cltq   
  80b7cb:	0f b6 44 02 1c       	movzbl 0x1c(%rdx,%rax,1),%eax
  80b7d0:	38 c1                	cmp    %al,%cl
  80b7d2:	0f 85 ae 01 00 00    	jne    80b986 <dhcp_recv+0x234>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80b7d8:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80b7dc:	83 c0 01             	add    $0x1,%eax
  80b7df:	88 45 ff             	mov    %al,-0x1(%rbp)
  80b7e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b7e6:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  80b7ea:	3a 45 ff             	cmp    -0x1(%rbp),%al
  80b7ed:	77 c3                	ja     80b7b2 <dhcp_recv+0x60>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  80b7ef:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b7f3:	8b 40 04             	mov    0x4(%rax),%eax
  80b7f6:	89 c7                	mov    %eax,%edi
  80b7f8:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  80b7ff:	00 00 00 
  80b802:	ff d0                	callq  *%rax
  80b804:	89 c2                	mov    %eax,%edx
  80b806:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b80a:	8b 40 04             	mov    0x4(%rax),%eax
  80b80d:	39 c2                	cmp    %eax,%edx
  80b80f:	0f 85 74 01 00 00    	jne    80b989 <dhcp_recv+0x237>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  }
  /* option fields could be unfold? */
  if (dhcp_unfold_reply(dhcp) != ERR_OK) {
  80b815:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b819:	48 89 c7             	mov    %rax,%rdi
  80b81c:	48 b8 b7 b4 80 00 00 	movabs $0x80b4b7,%rax
  80b823:	00 00 00 
  80b826:	ff d0                	callq  *%rax
  80b828:	84 c0                	test   %al,%al
  80b82a:	0f 85 5c 01 00 00    	jne    80b98c <dhcp_recv+0x23a>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  80b830:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b834:	be 35 00 00 00       	mov    $0x35,%esi
  80b839:	48 89 c7             	mov    %rax,%rdi
  80b83c:	48 b8 8a bf 80 00 00 	movabs $0x80bf8a,%rax
  80b843:	00 00 00 
  80b846:	ff d0                	callq  *%rax
  80b848:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (options_ptr == NULL) {
  80b84c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80b851:	0f 84 38 01 00 00    	je     80b98f <dhcp_recv+0x23d>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  80b857:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b85b:	48 83 c0 02          	add    $0x2,%rax
  80b85f:	48 89 c7             	mov    %rax,%rdi
  80b862:	48 b8 4c c1 80 00 00 	movabs $0x80c14c,%rax
  80b869:	00 00 00 
  80b86c:	ff d0                	callq  *%rax
  80b86e:	88 45 d7             	mov    %al,-0x29(%rbp)
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  80b871:	80 7d d7 05          	cmpb   $0x5,-0x29(%rbp)
  80b875:	0f 85 87 00 00 00    	jne    80b902 <dhcp_recv+0x1b0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  80b87b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b87f:	0f b6 00             	movzbl (%rax),%eax
  80b882:	3c 01                	cmp    $0x1,%al
  80b884:	75 35                	jne    80b8bb <dhcp_recv+0x169>
      dhcp_handle_ack(netif);
  80b886:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b88a:	48 89 c7             	mov    %rax,%rdi
  80b88d:	48 b8 e2 9b 80 00 00 	movabs $0x809be2,%rax
  80b894:	00 00 00 
  80b897:	ff d0                	callq  *%rax
      dhcp->request_timeout = 0;
  80b899:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b89d:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  80b8a3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b8a7:	48 89 c7             	mov    %rax,%rdi
  80b8aa:	48 b8 9b 94 80 00 00 	movabs $0x80949b,%rax
  80b8b1:	00 00 00 
  80b8b4:	ff d0                	callq  *%rax
  80b8b6:	e9 d5 00 00 00       	jmpq   80b990 <dhcp_recv+0x23e>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  80b8bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b8bf:	0f b6 00             	movzbl (%rax),%eax
  80b8c2:	3c 03                	cmp    $0x3,%al
  80b8c4:	74 1a                	je     80b8e0 <dhcp_recv+0x18e>
  80b8c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b8ca:	0f b6 00             	movzbl (%rax),%eax
  80b8cd:	3c 04                	cmp    $0x4,%al
  80b8cf:	74 0f                	je     80b8e0 <dhcp_recv+0x18e>
  80b8d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b8d5:	0f b6 00             	movzbl (%rax),%eax
  80b8d8:	3c 05                	cmp    $0x5,%al
  80b8da:	0f 85 b0 00 00 00    	jne    80b990 <dhcp_recv+0x23e>
      dhcp->request_timeout = 0;
  80b8e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b8e4:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
      dhcp_bind(netif);
  80b8ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b8ee:	48 89 c7             	mov    %rax,%rdi
  80b8f1:	48 b8 1d a8 80 00 00 	movabs $0x80a81d,%rax
  80b8f8:	00 00 00 
  80b8fb:	ff d0                	callq  *%rax
  80b8fd:	e9 8e 00 00 00       	jmpq   80b990 <dhcp_recv+0x23e>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  80b902:	80 7d d7 06          	cmpb   $0x6,-0x29(%rbp)
  80b906:	75 4b                	jne    80b953 <dhcp_recv+0x201>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b908:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b90c:	0f b6 00             	movzbl (%rax),%eax
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  80b90f:	3c 03                	cmp    $0x3,%al
  80b911:	74 21                	je     80b934 <dhcp_recv+0x1e2>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b913:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b917:	0f b6 00             	movzbl (%rax),%eax
  80b91a:	3c 01                	cmp    $0x1,%al
  80b91c:	74 16                	je     80b934 <dhcp_recv+0x1e2>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  80b91e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b922:	0f b6 00             	movzbl (%rax),%eax
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b925:	3c 04                	cmp    $0x4,%al
  80b927:	74 0b                	je     80b934 <dhcp_recv+0x1e2>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  80b929:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b92d:	0f b6 00             	movzbl (%rax),%eax
  80b930:	3c 05                	cmp    $0x5,%al
  80b932:	75 1f                	jne    80b953 <dhcp_recv+0x201>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  80b934:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b938:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
    dhcp_handle_nak(netif);
  80b93e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b942:	48 89 c7             	mov    %rax,%rdi
  80b945:	48 b8 eb 93 80 00 00 	movabs $0x8093eb,%rax
  80b94c:	00 00 00 
  80b94f:	ff d0                	callq  *%rax
  80b951:	eb 3d                	jmp    80b990 <dhcp_recv+0x23e>
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  80b953:	80 7d d7 02          	cmpb   $0x2,-0x29(%rbp)
  80b957:	75 37                	jne    80b990 <dhcp_recv+0x23e>
  80b959:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b95d:	0f b6 00             	movzbl (%rax),%eax
  80b960:	3c 06                	cmp    $0x6,%al
  80b962:	75 2c                	jne    80b990 <dhcp_recv+0x23e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  80b964:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b968:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
    /* remember offered lease */
    dhcp_handle_offer(netif);
  80b96e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b972:	48 89 c7             	mov    %rax,%rdi
  80b975:	48 b8 35 95 80 00 00 	movabs $0x809535,%rax
  80b97c:	00 00 00 
  80b97f:	ff d0                	callq  *%rax
  80b981:	eb 0d                	jmp    80b990 <dhcp_recv+0x23e>
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  80b983:	90                   	nop
  80b984:	eb 0a                	jmp    80b990 <dhcp_recv+0x23e>
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("netif->hwaddr[%"U16_F"]==%02"X16_F" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
  80b986:	90                   	nop
  80b987:	eb 07                	jmp    80b990 <dhcp_recv+0x23e>
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  80b989:	90                   	nop
  80b98a:	eb 04                	jmp    80b990 <dhcp_recv+0x23e>
  }
  /* option fields could be unfold? */
  if (dhcp_unfold_reply(dhcp) != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("problem unfolding DHCP message - too short on memory?\n"));
    goto free_pbuf_and_return;
  80b98c:	90                   	nop
  80b98d:	eb 01                	jmp    80b990 <dhcp_recv+0x23e>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  if (options_ptr == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  80b98f:	90                   	nop
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  80b990:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80b994:	48 89 c7             	mov    %rax,%rdi
  80b997:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  80b99e:	00 00 00 
  80b9a1:	ff d0                	callq  *%rax
  dhcp->p = NULL;
  80b9a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b9a7:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80b9ae:	00 
}
  80b9af:	90                   	nop
  80b9b0:	c9                   	leaveq 
  80b9b1:	c3                   	retq   

000000000080b9b2 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  80b9b2:	55                   	push   %rbp
  80b9b3:	48 89 e5             	mov    %rsp,%rbp
  80b9b6:	53                   	push   %rbx
  80b9b7:	48 83 ec 28          	sub    $0x28,%rsp
  80b9bb:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  80b9bf:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80b9c4:	75 2a                	jne    80b9f0 <dhcp_create_request+0x3e>
  80b9c6:	48 ba 58 1c 82 00 00 	movabs $0x821c58,%rdx
  80b9cd:	00 00 00 
  80b9d0:	be 2e 05 00 00       	mov    $0x52e,%esi
  80b9d5:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80b9dc:	00 00 00 
  80b9df:	b8 00 00 00 00       	mov    $0x0,%eax
  80b9e4:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80b9eb:	00 00 00 
  80b9ee:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80b9f0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b9f4:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b9f8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  80b9fc:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80ba01:	75 2a                	jne    80ba2d <dhcp_create_request+0x7b>
  80ba03:	48 ba 80 1c 82 00 00 	movabs $0x821c80,%rdx
  80ba0a:	00 00 00 
  80ba0d:	be 30 05 00 00       	mov    $0x530,%esi
  80ba12:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80ba19:	00 00 00 
  80ba1c:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba21:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80ba28:	00 00 00 
  80ba2b:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  80ba2d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ba31:	48 8b 40 30          	mov    0x30(%rax),%rax
  80ba35:	48 85 c0             	test   %rax,%rax
  80ba38:	74 2a                	je     80ba64 <dhcp_create_request+0xb2>
  80ba3a:	48 ba a8 1c 82 00 00 	movabs $0x821ca8,%rdx
  80ba41:	00 00 00 
  80ba44:	be 31 05 00 00       	mov    $0x531,%esi
  80ba49:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80ba50:	00 00 00 
  80ba53:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba58:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80ba5f:	00 00 00 
  80ba62:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  80ba64:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ba68:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ba6c:	48 85 c0             	test   %rax,%rax
  80ba6f:	74 2a                	je     80ba9b <dhcp_create_request+0xe9>
  80ba71:	48 ba d8 1c 82 00 00 	movabs $0x821cd8,%rdx
  80ba78:	00 00 00 
  80ba7b:	be 32 05 00 00       	mov    $0x532,%esi
  80ba80:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80ba87:	00 00 00 
  80ba8a:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba8f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80ba96:	00 00 00 
  80ba99:	ff d1                	callq  *%rcx
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  80ba9b:	ba 00 00 00 00       	mov    $0x0,%edx
  80baa0:	be 34 01 00 00       	mov    $0x134,%esi
  80baa5:	bf 00 00 00 00       	mov    $0x0,%edi
  80baaa:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  80bab1:	00 00 00 
  80bab4:	ff d0                	callq  *%rax
  80bab6:	48 89 c2             	mov    %rax,%rdx
  80bab9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80babd:	48 89 50 30          	mov    %rdx,0x30(%rax)
  if (dhcp->p_out == NULL) {
  80bac1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bac5:	48 8b 40 30          	mov    0x30(%rax),%rax
  80bac9:	48 85 c0             	test   %rax,%rax
  80bacc:	75 0a                	jne    80bad8 <dhcp_create_request+0x126>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  80bace:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bad3:	e9 2b 02 00 00       	jmpq   80bd03 <dhcp_create_request+0x351>
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  80bad8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80badc:	48 8b 40 30          	mov    0x30(%rax),%rax
  80bae0:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80bae4:	66 3d 33 01          	cmp    $0x133,%ax
  80bae8:	77 2a                	ja     80bb14 <dhcp_create_request+0x162>
  80baea:	48 ba 08 1d 82 00 00 	movabs $0x821d08,%rdx
  80baf1:	00 00 00 
  80baf4:	be 39 05 00 00       	mov    $0x539,%esi
  80baf9:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80bb00:	00 00 00 
  80bb03:	b8 00 00 00 00       	mov    $0x0,%eax
  80bb08:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80bb0f:	00 00 00 
  80bb12:	ff d1                	callq  *%rcx
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  80bb14:	48 b8 7c 81 82 00 00 	movabs $0x82817c,%rax
  80bb1b:	00 00 00 
  80bb1e:	8b 00                	mov    (%rax),%eax
  80bb20:	8d 48 01             	lea    0x1(%rax),%ecx
  80bb23:	48 ba 7c 81 82 00 00 	movabs $0x82817c,%rdx
  80bb2a:	00 00 00 
  80bb2d:	89 0a                	mov    %ecx,(%rdx)
  80bb2f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80bb33:	89 42 04             	mov    %eax,0x4(%rdx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  80bb36:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb3a:	48 8b 40 30          	mov    0x30(%rax),%rax
  80bb3e:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80bb42:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb46:	48 89 50 38          	mov    %rdx,0x38(%rax)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  80bb4a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb4e:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bb52:	c6 00 01             	movb   $0x1,(%rax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  80bb55:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb59:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bb5d:	c6 40 01 01          	movb   $0x1,0x1(%rax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  80bb61:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb65:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bb69:	c6 40 02 06          	movb   $0x6,0x2(%rax)
  dhcp->msg_out->hops = 0;
  80bb6d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb71:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bb75:	c6 40 03 00          	movb   $0x0,0x3(%rax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  80bb79:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb7d:	48 8b 58 38          	mov    0x38(%rax),%rbx
  80bb81:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb85:	8b 40 04             	mov    0x4(%rax),%eax
  80bb88:	89 c7                	mov    %eax,%edi
  80bb8a:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  80bb91:	00 00 00 
  80bb94:	ff d0                	callq  *%rax
  80bb96:	89 43 04             	mov    %eax,0x4(%rbx)
  dhcp->msg_out->secs = 0;
  80bb99:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb9d:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bba1:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
  dhcp->msg_out->flags = 0;
  80bba7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbab:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bbaf:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  80bbb5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbb9:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bbbd:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80bbc1:	8b 52 08             	mov    0x8(%rdx),%edx
  80bbc4:	89 50 0c             	mov    %edx,0xc(%rax)
  dhcp->msg_out->yiaddr.addr = 0;
  80bbc7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbcb:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bbcf:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
  dhcp->msg_out->siaddr.addr = 0;
  80bbd6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbda:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bbde:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%rax)
  dhcp->msg_out->giaddr.addr = 0;
  80bbe5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbe9:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bbed:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  80bbf4:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80bbfa:	eb 45                	jmp    80bc41 <dhcp_create_request+0x28f>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  80bbfc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bc00:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80bc04:	0f b7 75 ee          	movzwl -0x12(%rbp),%esi
  80bc08:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bc0c:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  80bc10:	0f b6 c0             	movzbl %al,%eax
  80bc13:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80bc17:	76 11                	jbe    80bc2a <dhcp_create_request+0x278>
  80bc19:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bc1d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80bc21:	48 98                	cltq   
  80bc23:	0f b6 44 02 41       	movzbl 0x41(%rdx,%rax,1),%eax
  80bc28:	eb 05                	jmp    80bc2f <dhcp_create_request+0x27d>
  80bc2a:	b8 00 00 00 00       	mov    $0x0,%eax
  80bc2f:	48 63 d6             	movslq %esi,%rdx
  80bc32:	88 44 11 1c          	mov    %al,0x1c(%rcx,%rdx,1)
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  80bc36:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bc3a:	83 c0 01             	add    $0x1,%eax
  80bc3d:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80bc41:	66 83 7d ee 0f       	cmpw   $0xf,-0x12(%rbp)
  80bc46:	76 b4                	jbe    80bbfc <dhcp_create_request+0x24a>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80bc48:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80bc4e:	eb 1e                	jmp    80bc6e <dhcp_create_request+0x2bc>
    dhcp->msg_out->sname[i] = 0;
  80bc50:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bc54:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bc58:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bc5c:	48 98                	cltq   
  80bc5e:	c6 44 02 2c 00       	movb   $0x0,0x2c(%rdx,%rax,1)
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80bc63:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bc67:	83 c0 01             	add    $0x1,%eax
  80bc6a:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80bc6e:	66 83 7d ee 3f       	cmpw   $0x3f,-0x12(%rbp)
  80bc73:	76 db                	jbe    80bc50 <dhcp_create_request+0x29e>
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80bc75:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80bc7b:	eb 1e                	jmp    80bc9b <dhcp_create_request+0x2e9>
    dhcp->msg_out->file[i] = 0;
  80bc7d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bc81:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bc85:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bc89:	48 98                	cltq   
  80bc8b:	c6 44 02 6c 00       	movb   $0x0,0x6c(%rdx,%rax,1)
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80bc90:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bc94:	83 c0 01             	add    $0x1,%eax
  80bc97:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80bc9b:	66 83 7d ee 7f       	cmpw   $0x7f,-0x12(%rbp)
  80bca0:	76 db                	jbe    80bc7d <dhcp_create_request+0x2cb>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  80bca2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bca6:	48 8b 58 38          	mov    0x38(%rax),%rbx
  80bcaa:	bf 63 53 82 63       	mov    $0x63825363,%edi
  80bcaf:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  80bcb6:	00 00 00 
  80bcb9:	ff d0                	callq  *%rax
  80bcbb:	89 83 ec 00 00 00    	mov    %eax,0xec(%rbx)
  dhcp->options_out_len = 0;
  80bcc1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bcc5:	66 c7 40 40 00 00    	movw   $0x0,0x40(%rax)
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  80bccb:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80bcd1:	eb 24                	jmp    80bcf7 <dhcp_create_request+0x345>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  80bcd3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bcd7:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bcdb:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bcdf:	0f b7 4d ee          	movzwl -0x12(%rbp),%ecx
  80bce3:	48 98                	cltq   
  80bce5:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  80bcec:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bcf0:	83 c0 01             	add    $0x1,%eax
  80bcf3:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80bcf7:	66 83 7d ee 43       	cmpw   $0x43,-0x12(%rbp)
  80bcfc:	76 d5                	jbe    80bcd3 <dhcp_create_request+0x321>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
  80bcfe:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80bd03:	48 83 c4 28          	add    $0x28,%rsp
  80bd07:	5b                   	pop    %rbx
  80bd08:	5d                   	pop    %rbp
  80bd09:	c3                   	retq   

000000000080bd0a <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  80bd0a:	55                   	push   %rbp
  80bd0b:	48 89 e5             	mov    %rsp,%rbp
  80bd0e:	48 83 ec 20          	sub    $0x20,%rsp
  80bd12:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  80bd16:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80bd1b:	75 2a                	jne    80bd47 <dhcp_delete_request+0x3d>
  80bd1d:	48 ba 50 1d 82 00 00 	movabs $0x821d50,%rdx
  80bd24:	00 00 00 
  80bd27:	be 6a 05 00 00       	mov    $0x56a,%esi
  80bd2c:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80bd33:	00 00 00 
  80bd36:	b8 00 00 00 00       	mov    $0x0,%eax
  80bd3b:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80bd42:	00 00 00 
  80bd45:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80bd47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bd4b:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bd4f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  80bd53:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80bd58:	75 2a                	jne    80bd84 <dhcp_delete_request+0x7a>
  80bd5a:	48 ba 78 1d 82 00 00 	movabs $0x821d78,%rdx
  80bd61:	00 00 00 
  80bd64:	be 6c 05 00 00       	mov    $0x56c,%esi
  80bd69:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80bd70:	00 00 00 
  80bd73:	b8 00 00 00 00       	mov    $0x0,%eax
  80bd78:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80bd7f:	00 00 00 
  80bd82:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  80bd84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bd88:	48 8b 40 30          	mov    0x30(%rax),%rax
  80bd8c:	48 85 c0             	test   %rax,%rax
  80bd8f:	75 2a                	jne    80bdbb <dhcp_delete_request+0xb1>
  80bd91:	48 ba a0 1d 82 00 00 	movabs $0x821da0,%rdx
  80bd98:	00 00 00 
  80bd9b:	be 6d 05 00 00       	mov    $0x56d,%esi
  80bda0:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80bda7:	00 00 00 
  80bdaa:	b8 00 00 00 00       	mov    $0x0,%eax
  80bdaf:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80bdb6:	00 00 00 
  80bdb9:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  80bdbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bdbf:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bdc3:	48 85 c0             	test   %rax,%rax
  80bdc6:	75 2a                	jne    80bdf2 <dhcp_delete_request+0xe8>
  80bdc8:	48 ba d0 1d 82 00 00 	movabs $0x821dd0,%rdx
  80bdcf:	00 00 00 
  80bdd2:	be 6e 05 00 00       	mov    $0x56e,%esi
  80bdd7:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80bdde:	00 00 00 
  80bde1:	b8 00 00 00 00       	mov    $0x0,%eax
  80bde6:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80bded:	00 00 00 
  80bdf0:	ff d1                	callq  *%rcx
  if (dhcp->p_out != NULL) {
  80bdf2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bdf6:	48 8b 40 30          	mov    0x30(%rax),%rax
  80bdfa:	48 85 c0             	test   %rax,%rax
  80bdfd:	74 17                	je     80be16 <dhcp_delete_request+0x10c>
    pbuf_free(dhcp->p_out);
  80bdff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be03:	48 8b 40 30          	mov    0x30(%rax),%rax
  80be07:	48 89 c7             	mov    %rax,%rdi
  80be0a:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  80be11:	00 00 00 
  80be14:	ff d0                	callq  *%rax
  }
  dhcp->p_out = NULL;
  80be16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be1a:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  80be21:	00 
  dhcp->msg_out = NULL;
  80be22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be26:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80be2d:	00 
}
  80be2e:	90                   	nop
  80be2f:	c9                   	leaveq 
  80be30:	c3                   	retq   

000000000080be31 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  80be31:	55                   	push   %rbp
  80be32:	48 89 e5             	mov    %rsp,%rbp
  80be35:	48 83 ec 10          	sub    $0x10,%rsp
  80be39:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  80be3d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80be42:	75 2a                	jne    80be6e <dhcp_option_trailer+0x3d>
  80be44:	48 ba 00 1e 82 00 00 	movabs $0x821e00,%rdx
  80be4b:	00 00 00 
  80be4e:	be 81 05 00 00       	mov    $0x581,%esi
  80be53:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80be5a:	00 00 00 
  80be5d:	b8 00 00 00 00       	mov    $0x0,%eax
  80be62:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80be69:	00 00 00 
  80be6c:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  80be6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be72:	48 8b 40 38          	mov    0x38(%rax),%rax
  80be76:	48 85 c0             	test   %rax,%rax
  80be79:	75 2a                	jne    80bea5 <dhcp_option_trailer+0x74>
  80be7b:	48 ba 28 1e 82 00 00 	movabs $0x821e28,%rdx
  80be82:	00 00 00 
  80be85:	be 82 05 00 00       	mov    $0x582,%esi
  80be8a:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80be91:	00 00 00 
  80be94:	b8 00 00 00 00       	mov    $0x0,%eax
  80be99:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80bea0:	00 00 00 
  80bea3:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80bea5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bea9:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bead:	66 83 f8 43          	cmp    $0x43,%ax
  80beb1:	76 2a                	jbe    80bedd <dhcp_option_trailer+0xac>
  80beb3:	48 ba 58 1e 82 00 00 	movabs $0x821e58,%rdx
  80beba:	00 00 00 
  80bebd:	be 83 05 00 00       	mov    $0x583,%esi
  80bec2:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80bec9:	00 00 00 
  80becc:	b8 00 00 00 00       	mov    $0x0,%eax
  80bed1:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80bed8:	00 00 00 
  80bedb:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  80bedd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bee1:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bee5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bee9:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80beed:	8d 70 01             	lea    0x1(%rax),%esi
  80bef0:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80bef4:	66 89 71 40          	mov    %si,0x40(%rcx)
  80bef8:	0f b7 c0             	movzwl %ax,%eax
  80befb:	48 98                	cltq   
  80befd:	c6 84 02 f0 00 00 00 	movb   $0xff,0xf0(%rdx,%rax,1)
  80bf04:	ff 
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  80bf05:	eb 60                	jmp    80bf67 <dhcp_option_trailer+0x136>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80bf07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bf0b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bf0f:	66 83 f8 43          	cmp    $0x43,%ax
  80bf13:	76 2a                	jbe    80bf3f <dhcp_option_trailer+0x10e>
  80bf15:	48 ba 58 1e 82 00 00 	movabs $0x821e58,%rdx
  80bf1c:	00 00 00 
  80bf1f:	be 88 05 00 00       	mov    $0x588,%esi
  80bf24:	48 bf 76 1a 82 00 00 	movabs $0x821a76,%rdi
  80bf2b:	00 00 00 
  80bf2e:	b8 00 00 00 00       	mov    $0x0,%eax
  80bf33:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80bf3a:	00 00 00 
  80bf3d:	ff d1                	callq  *%rcx
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  80bf3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bf43:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bf47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bf4b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bf4f:	8d 70 01             	lea    0x1(%rax),%esi
  80bf52:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80bf56:	66 89 71 40          	mov    %si,0x40(%rcx)
  80bf5a:	0f b7 c0             	movzwl %ax,%eax
  80bf5d:	48 98                	cltq   
  80bf5f:	c6 84 02 f0 00 00 00 	movb   $0x0,0xf0(%rdx,%rax,1)
  80bf66:	00 
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  80bf67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bf6b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bf6f:	66 83 f8 43          	cmp    $0x43,%ax
  80bf73:	76 92                	jbe    80bf07 <dhcp_option_trailer+0xd6>
  80bf75:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bf79:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bf7d:	0f b7 c0             	movzwl %ax,%eax
  80bf80:	83 e0 03             	and    $0x3,%eax
  80bf83:	85 c0                	test   %eax,%eax
  80bf85:	75 80                	jne    80bf07 <dhcp_option_trailer+0xd6>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  80bf87:	90                   	nop
  80bf88:	c9                   	leaveq 
  80bf89:	c3                   	retq   

000000000080bf8a <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  80bf8a:	55                   	push   %rbp
  80bf8b:	48 89 e5             	mov    %rsp,%rbp
  80bf8e:	48 83 ec 30          	sub    $0x30,%rsp
  80bf92:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80bf96:	89 f0                	mov    %esi,%eax
  80bf98:	88 45 d4             	mov    %al,-0x2c(%rbp)
  u8_t overload = DHCP_OVERLOAD_NONE;
  80bf9b:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80bf9f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bfa3:	48 8b 40 20          	mov    0x20(%rax),%rax
  80bfa7:	48 85 c0             	test   %rax,%rax
  80bfaa:	0f 84 95 01 00 00    	je     80c145 <dhcp_get_option_ptr+0x1bb>
  80bfb0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bfb4:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80bfb8:	66 85 c0             	test   %ax,%ax
  80bfbb:	0f 84 84 01 00 00    	je     80c145 <dhcp_get_option_ptr+0x1bb>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
  80bfc1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bfc5:	48 8b 40 20          	mov    0x20(%rax),%rax
  80bfc9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    u16_t offset = 0;
  80bfcd:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80bfd3:	e9 80 00 00 00       	jmpq   80c058 <dhcp_get_option_ptr+0xce>
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  80bfd8:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80bfdc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80bfe0:	48 01 d0             	add    %rdx,%rax
  80bfe3:	0f b6 00             	movzbl (%rax),%eax
  80bfe6:	3c 34                	cmp    $0x34,%al
  80bfe8:	75 22                	jne    80c00c <dhcp_get_option_ptr+0x82>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  80bfea:	66 83 45 ee 02       	addw   $0x2,-0x12(%rbp)
        overload = options[offset++];
  80bfef:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bff3:	8d 50 01             	lea    0x1(%rax),%edx
  80bff6:	66 89 55 ee          	mov    %dx,-0x12(%rbp)
  80bffa:	0f b7 d0             	movzwl %ax,%edx
  80bffd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c001:	48 01 d0             	add    %rdx,%rax
  80c004:	0f b6 00             	movzbl (%rax),%eax
  80c007:	88 45 ff             	mov    %al,-0x1(%rbp)
  80c00a:	eb 4c                	jmp    80c058 <dhcp_get_option_ptr+0xce>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  80c00c:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c010:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c014:	48 01 d0             	add    %rdx,%rax
  80c017:	0f b6 00             	movzbl (%rax),%eax
  80c01a:	3a 45 d4             	cmp    -0x2c(%rbp),%al
  80c01d:	75 10                	jne    80c02f <dhcp_get_option_ptr+0xa5>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset %"U16_F" in options\n", offset));
        return &options[offset];
  80c01f:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c023:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c027:	48 01 d0             	add    %rdx,%rax
  80c02a:	e9 1b 01 00 00       	jmpq   80c14a <dhcp_get_option_ptr+0x1c0>
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  80c02f:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c033:	83 c0 01             	add    $0x1,%eax
  80c036:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  80c03a:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c03e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c042:	48 01 d0             	add    %rdx,%rax
  80c045:	0f b6 00             	movzbl (%rax),%eax
  80c048:	0f b6 d0             	movzbl %al,%edx
  80c04b:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c04f:	01 d0                	add    %edx,%eax
  80c051:	83 c0 01             	add    $0x1,%eax
  80c054:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80c058:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c05c:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80c060:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80c064:	76 16                	jbe    80c07c <dhcp_get_option_ptr+0xf2>
  80c066:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c06a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c06e:	48 01 d0             	add    %rdx,%rax
  80c071:	0f b6 00             	movzbl (%rax),%eax
  80c074:	3c ff                	cmp    $0xff,%al
  80c076:	0f 85 5c ff ff ff    	jne    80bfd8 <dhcp_get_option_ptr+0x4e>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  80c07c:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80c080:	0f 84 bf 00 00 00    	je     80c145 <dhcp_get_option_ptr+0x1bb>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  80c086:	80 7d ff 01          	cmpb   $0x1,-0x1(%rbp)
  80c08a:	75 18                	jne    80c0a4 <dhcp_get_option_ptr+0x11a>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  80c08c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c090:	48 8b 40 18          	mov    0x18(%rax),%rax
  80c094:	48 83 c0 6c          	add    $0x6c,%rax
  80c098:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_FILE_LEN;
  80c09c:	66 c7 45 ec 80 00    	movw   $0x80,-0x14(%rbp)
  80c0a2:	eb 34                	jmp    80c0d8 <dhcp_get_option_ptr+0x14e>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  80c0a4:	80 7d ff 02          	cmpb   $0x2,-0x1(%rbp)
  80c0a8:	75 18                	jne    80c0c2 <dhcp_get_option_ptr+0x138>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80c0aa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c0ae:	48 8b 40 18          	mov    0x18(%rax),%rax
  80c0b2:	48 83 c0 2c          	add    $0x2c,%rax
  80c0b6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_SNAME_LEN;
  80c0ba:	66 c7 45 ec 40 00    	movw   $0x40,-0x14(%rbp)
  80c0c0:	eb 16                	jmp    80c0d8 <dhcp_get_option_ptr+0x14e>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80c0c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c0c6:	48 8b 40 18          	mov    0x18(%rax),%rax
  80c0ca:	48 83 c0 2c          	add    $0x2c,%rax
  80c0ce:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  80c0d2:	66 c7 45 ec c0 00    	movw   $0xc0,-0x14(%rbp)
      }
      offset = 0;
  80c0d8:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80c0de:	eb 49                	jmp    80c129 <dhcp_get_option_ptr+0x19f>
        if (options[offset] == option_type) {
  80c0e0:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c0e4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c0e8:	48 01 d0             	add    %rdx,%rax
  80c0eb:	0f b6 00             	movzbl (%rax),%eax
  80c0ee:	3a 45 d4             	cmp    -0x2c(%rbp),%al
  80c0f1:	75 0d                	jne    80c100 <dhcp_get_option_ptr+0x176>
           LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset=%"U16_F"\n", offset));
          return &options[offset];
  80c0f3:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c0f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c0fb:	48 01 d0             	add    %rdx,%rax
  80c0fe:	eb 4a                	jmp    80c14a <dhcp_get_option_ptr+0x1c0>
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  80c100:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c104:	83 c0 01             	add    $0x1,%eax
  80c107:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
          offset += 1 + options[offset];
  80c10b:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c10f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c113:	48 01 d0             	add    %rdx,%rax
  80c116:	0f b6 00             	movzbl (%rax),%eax
  80c119:	0f b6 d0             	movzbl %al,%edx
  80c11c:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c120:	01 d0                	add    %edx,%eax
  80c122:	83 c0 01             	add    $0x1,%eax
  80c125:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80c129:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c12d:	66 3b 45 ec          	cmp    -0x14(%rbp),%ax
  80c131:	73 12                	jae    80c145 <dhcp_get_option_ptr+0x1bb>
  80c133:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c137:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c13b:	48 01 d0             	add    %rdx,%rax
  80c13e:	0f b6 00             	movzbl (%rax),%eax
  80c141:	3c ff                	cmp    $0xff,%al
  80c143:	75 9b                	jne    80c0e0 <dhcp_get_option_ptr+0x156>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  80c145:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80c14a:	c9                   	leaveq 
  80c14b:	c3                   	retq   

000000000080c14c <dhcp_get_option_byte>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  80c14c:	55                   	push   %rbp
  80c14d:	48 89 e5             	mov    %rsp,%rbp
  80c150:	48 83 ec 08          	sub    $0x8,%rsp
  80c154:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  80c158:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c15c:	0f b6 00             	movzbl (%rax),%eax
}
  80c15f:	c9                   	leaveq 
  80c160:	c3                   	retq   

000000000080c161 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  80c161:	55                   	push   %rbp
  80c162:	48 89 e5             	mov    %rsp,%rbp
  80c165:	48 83 ec 18          	sub    $0x18,%rsp
  80c169:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  80c16d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c171:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80c175:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80c179:	0f b6 00             	movzbl (%rax),%eax
  80c17c:	0f b6 c0             	movzbl %al,%eax
  80c17f:	c1 e0 18             	shl    $0x18,%eax
  80c182:	89 45 fc             	mov    %eax,-0x4(%rbp)
  value |= (u32_t)(*ptr++) << 16;
  80c185:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c189:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80c18d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80c191:	0f b6 00             	movzbl (%rax),%eax
  80c194:	0f b6 c0             	movzbl %al,%eax
  80c197:	c1 e0 10             	shl    $0x10,%eax
  80c19a:	09 45 fc             	or     %eax,-0x4(%rbp)
  value |= (u32_t)(*ptr++) << 8;
  80c19d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c1a1:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80c1a5:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80c1a9:	0f b6 00             	movzbl (%rax),%eax
  80c1ac:	0f b6 c0             	movzbl %al,%eax
  80c1af:	c1 e0 08             	shl    $0x8,%eax
  80c1b2:	09 45 fc             	or     %eax,-0x4(%rbp)
  value |= (u32_t)(*ptr++);
  80c1b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c1b9:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80c1bd:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80c1c1:	0f b6 00             	movzbl (%rax),%eax
  80c1c4:	0f b6 c0             	movzbl %al,%eax
  80c1c7:	09 45 fc             	or     %eax,-0x4(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
  80c1ca:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80c1cd:	c9                   	leaveq 
  80c1ce:	c3                   	retq   

000000000080c1cf <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
  80c1cf:	55                   	push   %rbp
  80c1d0:	48 89 e5             	mov    %rsp,%rbp
  80c1d3:	48 83 ec 20          	sub    $0x20,%rsp
  80c1d7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  80c1db:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c1e2:	00 00 00 
  80c1e5:	48 8b 00             	mov    (%rax),%rax
  80c1e8:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c1ec:	73 2a                	jae    80c218 <plug_holes+0x49>
  80c1ee:	48 ba 98 1e 82 00 00 	movabs $0x821e98,%rdx
  80c1f5:	00 00 00 
  80c1f8:	be e4 00 00 00       	mov    $0xe4,%esi
  80c1fd:	48 bf af 1e 82 00 00 	movabs $0x821eaf,%rdi
  80c204:	00 00 00 
  80c207:	b8 00 00 00 00       	mov    $0x0,%eax
  80c20c:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80c213:	00 00 00 
  80c216:	ff d1                	callq  *%rcx
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80c218:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c21f:	00 00 00 
  80c222:	48 8b 00             	mov    (%rax),%rax
  80c225:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c229:	72 2a                	jb     80c255 <plug_holes+0x86>
  80c22b:	48 ba c3 1e 82 00 00 	movabs $0x821ec3,%rdx
  80c232:	00 00 00 
  80c235:	be e5 00 00 00       	mov    $0xe5,%esi
  80c23a:	48 bf af 1e 82 00 00 	movabs $0x821eaf,%rdi
  80c241:	00 00 00 
  80c244:	b8 00 00 00 00       	mov    $0x0,%eax
  80c249:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80c250:	00 00 00 
  80c253:	ff d1                	callq  *%rcx
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
  80c255:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c259:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c25d:	84 c0                	test   %al,%al
  80c25f:	74 2a                	je     80c28b <plug_holes+0xbc>
  80c261:	48 ba dd 1e 82 00 00 	movabs $0x821edd,%rdx
  80c268:	00 00 00 
  80c26b:	be e6 00 00 00       	mov    $0xe6,%esi
  80c270:	48 bf af 1e 82 00 00 	movabs $0x821eaf,%rdi
  80c277:	00 00 00 
  80c27a:	b8 00 00 00 00       	mov    $0x0,%eax
  80c27f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80c286:	00 00 00 
  80c289:	ff d1                	callq  *%rcx

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  80c28b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c28f:	8b 00                	mov    (%rax),%eax
  80c291:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c296:	76 2a                	jbe    80c2c2 <plug_holes+0xf3>
  80c298:	48 ba f8 1e 82 00 00 	movabs $0x821ef8,%rdx
  80c29f:	00 00 00 
  80c2a2:	be e9 00 00 00       	mov    $0xe9,%esi
  80c2a7:	48 bf af 1e 82 00 00 	movabs $0x821eaf,%rdi
  80c2ae:	00 00 00 
  80c2b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80c2b6:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80c2bd:	00 00 00 
  80c2c0:	ff d1                	callq  *%rcx

  nmem = (struct mem *)&ram[mem->next];
  80c2c2:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c2c9:	00 00 00 
  80c2cc:	48 8b 10             	mov    (%rax),%rdx
  80c2cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c2d3:	8b 00                	mov    (%rax),%eax
  80c2d5:	89 c0                	mov    %eax,%eax
  80c2d7:	48 01 d0             	add    %rdx,%rax
  80c2da:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  80c2de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c2e2:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80c2e6:	0f 84 81 00 00 00    	je     80c36d <plug_holes+0x19e>
  80c2ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c2f0:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c2f4:	84 c0                	test   %al,%al
  80c2f6:	75 75                	jne    80c36d <plug_holes+0x19e>
  80c2f8:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c2ff:	00 00 00 
  80c302:	48 8b 00             	mov    (%rax),%rax
  80c305:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80c309:	74 62                	je     80c36d <plug_holes+0x19e>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  80c30b:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c312:	00 00 00 
  80c315:	48 8b 00             	mov    (%rax),%rax
  80c318:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80c31c:	75 11                	jne    80c32f <plug_holes+0x160>
      lfree = mem;
  80c31e:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c325:	00 00 00 
  80c328:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80c32c:	48 89 10             	mov    %rdx,(%rax)
    }
    mem->next = nmem->next;
  80c32f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c333:	8b 10                	mov    (%rax),%edx
  80c335:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c339:	89 10                	mov    %edx,(%rax)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  80c33b:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c342:	00 00 00 
  80c345:	48 8b 10             	mov    (%rax),%rdx
  80c348:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c34c:	8b 00                	mov    (%rax),%eax
  80c34e:	89 c0                	mov    %eax,%eax
  80c350:	48 01 c2             	add    %rax,%rdx
  80c353:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80c357:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c35e:	00 00 00 
  80c361:	48 8b 00             	mov    (%rax),%rax
  80c364:	48 29 c1             	sub    %rax,%rcx
  80c367:	48 89 c8             	mov    %rcx,%rax
  80c36a:	89 42 04             	mov    %eax,0x4(%rdx)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  80c36d:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c374:	00 00 00 
  80c377:	48 8b 10             	mov    (%rax),%rdx
  80c37a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c37e:	8b 40 04             	mov    0x4(%rax),%eax
  80c381:	89 c0                	mov    %eax,%eax
  80c383:	48 01 d0             	add    %rdx,%rax
  80c386:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (pmem != mem && pmem->used == 0) {
  80c38a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c38e:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c392:	74 6e                	je     80c402 <plug_holes+0x233>
  80c394:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c398:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c39c:	84 c0                	test   %al,%al
  80c39e:	75 62                	jne    80c402 <plug_holes+0x233>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  80c3a0:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c3a7:	00 00 00 
  80c3aa:	48 8b 00             	mov    (%rax),%rax
  80c3ad:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c3b1:	75 11                	jne    80c3c4 <plug_holes+0x1f5>
      lfree = pmem;
  80c3b3:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c3ba:	00 00 00 
  80c3bd:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80c3c1:	48 89 10             	mov    %rdx,(%rax)
    }
    pmem->next = mem->next;
  80c3c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c3c8:	8b 10                	mov    (%rax),%edx
  80c3ca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c3ce:	89 10                	mov    %edx,(%rax)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  80c3d0:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c3d7:	00 00 00 
  80c3da:	48 8b 10             	mov    (%rax),%rdx
  80c3dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c3e1:	8b 00                	mov    (%rax),%eax
  80c3e3:	89 c0                	mov    %eax,%eax
  80c3e5:	48 01 c2             	add    %rax,%rdx
  80c3e8:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80c3ec:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c3f3:	00 00 00 
  80c3f6:	48 8b 00             	mov    (%rax),%rax
  80c3f9:	48 29 c1             	sub    %rax,%rcx
  80c3fc:	48 89 c8             	mov    %rcx,%rax
  80c3ff:	89 42 04             	mov    %eax,0x4(%rdx)
  }
}
  80c402:	90                   	nop
  80c403:	c9                   	leaveq 
  80c404:	c3                   	retq   

000000000080c405 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  80c405:	55                   	push   %rbp
  80c406:	48 89 e5             	mov    %rsp,%rbp
  80c409:	48 83 ec 10          	sub    $0x10,%rsp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  80c40d:	48 b8 e0 94 82 00 00 	movabs $0x8294e0,%rax
  80c414:	00 00 00 
  80c417:	48 83 c0 03          	add    $0x3,%rax
  80c41b:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80c41f:	48 89 c2             	mov    %rax,%rdx
  80c422:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c429:	00 00 00 
  80c42c:	48 89 10             	mov    %rdx,(%rax)
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  80c42f:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c436:	00 00 00 
  80c439:	48 8b 00             	mov    (%rax),%rax
  80c43c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  mem->next = MEM_SIZE_ALIGNED;
  80c440:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c444:	c7 00 00 00 22 00    	movl   $0x220000,(%rax)
  mem->prev = 0;
  80c44a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c44e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  mem->used = 0;
  80c455:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c459:	c6 40 08 00          	movb   $0x0,0x8(%rax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  80c45d:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c464:	00 00 00 
  80c467:	48 8b 00             	mov    (%rax),%rax
  80c46a:	48 8d 90 00 00 22 00 	lea    0x220000(%rax),%rdx
  80c471:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c478:	00 00 00 
  80c47b:	48 89 10             	mov    %rdx,(%rax)
  ram_end->used = 1;
  80c47e:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c485:	00 00 00 
  80c488:	48 8b 00             	mov    (%rax),%rax
  80c48b:	c6 40 08 01          	movb   $0x1,0x8(%rax)
  ram_end->next = MEM_SIZE_ALIGNED;
  80c48f:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c496:	00 00 00 
  80c499:	48 8b 00             	mov    (%rax),%rax
  80c49c:	c7 00 00 00 22 00    	movl   $0x220000,(%rax)
  ram_end->prev = MEM_SIZE_ALIGNED;
  80c4a2:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c4a9:	00 00 00 
  80c4ac:	48 8b 00             	mov    (%rax),%rax
  80c4af:	c7 40 04 00 00 22 00 	movl   $0x220000,0x4(%rax)

  mem_sem = sys_sem_new(1);
  80c4b6:	bf 01 00 00 00       	mov    $0x1,%edi
  80c4bb:	48 b8 e1 7e 81 00 00 	movabs $0x817ee1,%rax
  80c4c2:	00 00 00 
  80c4c5:	ff d0                	callq  *%rax
  80c4c7:	89 c2                	mov    %eax,%edx
  80c4c9:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c4d0:	00 00 00 
  80c4d3:	89 10                	mov    %edx,(%rax)

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  80c4d5:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c4dc:	00 00 00 
  80c4df:	48 8b 10             	mov    (%rax),%rdx
  80c4e2:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c4e9:	00 00 00 
  80c4ec:	48 89 10             	mov    %rdx,(%rax)

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  80c4ef:	90                   	nop
  80c4f0:	c9                   	leaveq 
  80c4f1:	c3                   	retq   

000000000080c4f2 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  80c4f2:	55                   	push   %rbp
  80c4f3:	48 89 e5             	mov    %rsp,%rbp
  80c4f6:	48 83 ec 20          	sub    $0x20,%rsp
  80c4fa:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  80c4fe:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80c503:	0f 84 70 01 00 00    	je     80c679 <mem_free+0x187>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  80c509:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c50d:	83 e0 03             	and    $0x3,%eax
  80c510:	48 85 c0             	test   %rax,%rax
  80c513:	74 2a                	je     80c53f <mem_free+0x4d>
  80c515:	48 ba 28 1f 82 00 00 	movabs $0x821f28,%rdx
  80c51c:	00 00 00 
  80c51f:	be 31 01 00 00       	mov    $0x131,%esi
  80c524:	48 bf af 1e 82 00 00 	movabs $0x821eaf,%rdi
  80c52b:	00 00 00 
  80c52e:	b8 00 00 00 00       	mov    $0x0,%eax
  80c533:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80c53a:	00 00 00 
  80c53d:	ff d1                	callq  *%rcx

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80c53f:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c546:	00 00 00 
  80c549:	48 8b 00             	mov    (%rax),%rax
  80c54c:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c550:	72 13                	jb     80c565 <mem_free+0x73>
  80c552:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c559:	00 00 00 
  80c55c:	48 8b 00             	mov    (%rax),%rax
  80c55f:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c563:	72 2a                	jb     80c58f <mem_free+0x9d>
  80c565:	48 ba 49 1f 82 00 00 	movabs $0x821f49,%rdx
  80c56c:	00 00 00 
  80c56f:	be 34 01 00 00       	mov    $0x134,%esi
  80c574:	48 bf af 1e 82 00 00 	movabs $0x821eaf,%rdi
  80c57b:	00 00 00 
  80c57e:	b8 00 00 00 00       	mov    $0x0,%eax
  80c583:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80c58a:	00 00 00 
  80c58d:	ff d1                	callq  *%rcx
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  80c58f:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c596:	00 00 00 
  80c599:	48 8b 00             	mov    (%rax),%rax
  80c59c:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c5a0:	0f 82 d6 00 00 00    	jb     80c67c <mem_free+0x18a>
  80c5a6:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c5ad:	00 00 00 
  80c5b0:	48 8b 00             	mov    (%rax),%rax
  80c5b3:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c5b7:	0f 83 bf 00 00 00    	jae    80c67c <mem_free+0x18a>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80c5bd:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c5c4:	00 00 00 
  80c5c7:	8b 00                	mov    (%rax),%eax
  80c5c9:	be 00 00 00 00       	mov    $0x0,%esi
  80c5ce:	89 c7                	mov    %eax,%edi
  80c5d0:	48 b8 6f 82 81 00 00 	movabs $0x81826f,%rax
  80c5d7:	00 00 00 
  80c5da:	ff d0                	callq  *%rax
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80c5dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c5e0:	48 83 e8 0c          	sub    $0xc,%rax
  80c5e4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  80c5e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c5ec:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c5f0:	84 c0                	test   %al,%al
  80c5f2:	75 2a                	jne    80c61e <mem_free+0x12c>
  80c5f4:	48 ba 60 1f 82 00 00 	movabs $0x821f60,%rdx
  80c5fb:	00 00 00 
  80c5fe:	be 44 01 00 00       	mov    $0x144,%esi
  80c603:	48 bf af 1e 82 00 00 	movabs $0x821eaf,%rdi
  80c60a:	00 00 00 
  80c60d:	b8 00 00 00 00       	mov    $0x0,%eax
  80c612:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80c619:	00 00 00 
  80c61c:	ff d1                	callq  *%rcx
  /* ... and is now unused. */
  mem->used = 0;
  80c61e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c622:	c6 40 08 00          	movb   $0x0,0x8(%rax)

  if (mem < lfree) {
  80c626:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c62d:	00 00 00 
  80c630:	48 8b 00             	mov    (%rax),%rax
  80c633:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80c637:	73 11                	jae    80c64a <mem_free+0x158>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  80c639:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c640:	00 00 00 
  80c643:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c647:	48 89 10             	mov    %rdx,(%rax)
  }

  MEM_STATS_DEC_USED(used, mem->next - ((u8_t *)mem - ram));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
  80c64a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c64e:	48 89 c7             	mov    %rax,%rdi
  80c651:	48 b8 cf c1 80 00 00 	movabs $0x80c1cf,%rax
  80c658:	00 00 00 
  80c65b:	ff d0                	callq  *%rax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80c65d:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c664:	00 00 00 
  80c667:	8b 00                	mov    (%rax),%eax
  80c669:	89 c7                	mov    %eax,%edi
  80c66b:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  80c672:	00 00 00 
  80c675:	ff d0                	callq  *%rax
  80c677:	eb 04                	jmp    80c67d <mem_free+0x18b>
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  80c679:	90                   	nop
  80c67a:	eb 01                	jmp    80c67d <mem_free+0x18b>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  80c67c:	90                   	nop
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
  80c67d:	c9                   	leaveq 
  80c67e:	c3                   	retq   

000000000080c67f <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  80c67f:	55                   	push   %rbp
  80c680:	48 89 e5             	mov    %rsp,%rbp
  80c683:	48 83 ec 30          	sub    $0x30,%rsp
  80c687:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80c68b:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  80c68e:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c691:	83 c0 03             	add    $0x3,%eax
  80c694:	83 e0 fc             	and    $0xfffffffc,%eax
  80c697:	89 45 d4             	mov    %eax,-0x2c(%rbp)

  if(newsize < MIN_SIZE_ALIGNED) {
  80c69a:	83 7d d4 0b          	cmpl   $0xb,-0x2c(%rbp)
  80c69e:	77 07                	ja     80c6a7 <mem_realloc+0x28>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  80c6a0:	c7 45 d4 0c 00 00 00 	movl   $0xc,-0x2c(%rbp)
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  80c6a7:	81 7d d4 00 00 22 00 	cmpl   $0x220000,-0x2c(%rbp)
  80c6ae:	76 0a                	jbe    80c6ba <mem_realloc+0x3b>
    return NULL;
  80c6b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80c6b5:	e9 d9 02 00 00       	jmpq   80c993 <mem_realloc+0x314>
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80c6ba:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c6c1:	00 00 00 
  80c6c4:	48 8b 00             	mov    (%rax),%rax
  80c6c7:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c6cb:	72 13                	jb     80c6e0 <mem_realloc+0x61>
  80c6cd:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c6d4:	00 00 00 
  80c6d7:	48 8b 00             	mov    (%rax),%rax
  80c6da:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c6de:	72 2a                	jb     80c70a <mem_realloc+0x8b>
  80c6e0:	48 ba 74 1f 82 00 00 	movabs $0x821f74,%rdx
  80c6e7:	00 00 00 
  80c6ea:	be 7a 01 00 00       	mov    $0x17a,%esi
  80c6ef:	48 bf af 1e 82 00 00 	movabs $0x821eaf,%rdi
  80c6f6:	00 00 00 
  80c6f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80c6fe:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80c705:	00 00 00 
  80c708:	ff d1                	callq  *%rcx
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  80c70a:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c711:	00 00 00 
  80c714:	48 8b 00             	mov    (%rax),%rax
  80c717:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c71b:	72 13                	jb     80c730 <mem_realloc+0xb1>
  80c71d:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c724:	00 00 00 
  80c727:	48 8b 00             	mov    (%rax),%rax
  80c72a:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c72e:	72 09                	jb     80c739 <mem_realloc+0xba>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_realloc: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  80c730:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c734:	e9 5a 02 00 00       	jmpq   80c993 <mem_realloc+0x314>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80c739:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c73d:	48 83 e8 0c          	sub    $0xc,%rax
  80c741:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  80c745:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c749:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c750:	00 00 00 
  80c753:	48 8b 00             	mov    (%rax),%rax
  80c756:	48 29 c2             	sub    %rax,%rdx
  80c759:	48 89 d0             	mov    %rdx,%rax
  80c75c:	89 45 f4             	mov    %eax,-0xc(%rbp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  80c75f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c763:	8b 00                	mov    (%rax),%eax
  80c765:	2b 45 f4             	sub    -0xc(%rbp),%eax
  80c768:	83 e8 0c             	sub    $0xc,%eax
  80c76b:	89 45 f0             	mov    %eax,-0x10(%rbp)
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  80c76e:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c771:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c774:	76 2a                	jbe    80c7a0 <mem_realloc+0x121>
  80c776:	48 ba 90 1f 82 00 00 	movabs $0x821f90,%rdx
  80c77d:	00 00 00 
  80c780:	be 8b 01 00 00       	mov    $0x18b,%esi
  80c785:	48 bf af 1e 82 00 00 	movabs $0x821eaf,%rdi
  80c78c:	00 00 00 
  80c78f:	b8 00 00 00 00       	mov    $0x0,%eax
  80c794:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80c79b:	00 00 00 
  80c79e:	ff d1                	callq  *%rcx
  if (newsize > size) {
  80c7a0:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c7a3:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c7a6:	76 0a                	jbe    80c7b2 <mem_realloc+0x133>
    /* not supported */
    return NULL;
  80c7a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80c7ad:	e9 e1 01 00 00       	jmpq   80c993 <mem_realloc+0x314>
  }
  if (newsize == size) {
  80c7b2:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c7b5:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c7b8:	75 09                	jne    80c7c3 <mem_realloc+0x144>
    /* No change in size, simply return */
    return rmem;
  80c7ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c7be:	e9 d0 01 00 00       	jmpq   80c993 <mem_realloc+0x314>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80c7c3:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c7ca:	00 00 00 
  80c7cd:	8b 00                	mov    (%rax),%eax
  80c7cf:	be 00 00 00 00       	mov    $0x0,%esi
  80c7d4:	89 c7                	mov    %eax,%edi
  80c7d6:	48 b8 6f 82 81 00 00 	movabs $0x81826f,%rax
  80c7dd:	00 00 00 
  80c7e0:	ff d0                	callq  *%rax

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  80c7e2:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c7e9:	00 00 00 
  80c7ec:	48 8b 10             	mov    (%rax),%rdx
  80c7ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c7f3:	8b 00                	mov    (%rax),%eax
  80c7f5:	89 c0                	mov    %eax,%eax
  80c7f7:	48 01 d0             	add    %rdx,%rax
  80c7fa:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if(mem2->used == 0) {
  80c7fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c802:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c806:	84 c0                	test   %al,%al
  80c808:	0f 85 b9 00 00 00    	jne    80c8c7 <mem_realloc+0x248>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  80c80e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c812:	8b 00                	mov    (%rax),%eax
  80c814:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80c817:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c81a:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c81d:	01 d0                	add    %edx,%eax
  80c81f:	83 c0 0c             	add    $0xc,%eax
  80c822:	89 45 e0             	mov    %eax,-0x20(%rbp)
    if (lfree == mem2) {
  80c825:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c82c:	00 00 00 
  80c82f:	48 8b 00             	mov    (%rax),%rax
  80c832:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c836:	75 20                	jne    80c858 <mem_realloc+0x1d9>
      lfree = (struct mem *)&ram[ptr2];
  80c838:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c83f:	00 00 00 
  80c842:	48 8b 10             	mov    (%rax),%rdx
  80c845:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c848:	48 01 c2             	add    %rax,%rdx
  80c84b:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c852:	00 00 00 
  80c855:	48 89 10             	mov    %rdx,(%rax)
    }
    mem2 = (struct mem *)&ram[ptr2];
  80c858:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c85f:	00 00 00 
  80c862:	48 8b 10             	mov    (%rax),%rdx
  80c865:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c868:	48 01 d0             	add    %rdx,%rax
  80c86b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    mem2->used = 0;
  80c86f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c873:	c6 40 08 00          	movb   $0x0,0x8(%rax)
    /* restore the next pointer */
    mem2->next = next;
  80c877:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c87b:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80c87e:	89 10                	mov    %edx,(%rax)
    /* link it back to mem */
    mem2->prev = ptr;
  80c880:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c884:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c887:	89 50 04             	mov    %edx,0x4(%rax)
    /* link mem to it */
    mem->next = ptr2;
  80c88a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c88e:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80c891:	89 10                	mov    %edx,(%rax)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80c893:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c897:	8b 00                	mov    (%rax),%eax
  80c899:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c89e:	0f 84 d1 00 00 00    	je     80c975 <mem_realloc+0x2f6>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80c8a4:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c8ab:	00 00 00 
  80c8ae:	48 8b 10             	mov    (%rax),%rdx
  80c8b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c8b5:	8b 00                	mov    (%rax),%eax
  80c8b7:	89 c0                	mov    %eax,%eax
  80c8b9:	48 01 c2             	add    %rax,%rdx
  80c8bc:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c8bf:	89 42 04             	mov    %eax,0x4(%rdx)
  80c8c2:	e9 ae 00 00 00       	jmpq   80c975 <mem_realloc+0x2f6>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  80c8c7:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c8ca:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80c8ce:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80c8d1:	48 39 c2             	cmp    %rax,%rdx
  80c8d4:	0f 87 9b 00 00 00    	ja     80c975 <mem_realloc+0x2f6>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80c8da:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c8dd:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c8e0:	01 d0                	add    %edx,%eax
  80c8e2:	83 c0 0c             	add    $0xc,%eax
  80c8e5:	89 45 e0             	mov    %eax,-0x20(%rbp)
    mem2 = (struct mem *)&ram[ptr2];
  80c8e8:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c8ef:	00 00 00 
  80c8f2:	48 8b 10             	mov    (%rax),%rdx
  80c8f5:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c8f8:	48 01 d0             	add    %rdx,%rax
  80c8fb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (mem2 < lfree) {
  80c8ff:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c906:	00 00 00 
  80c909:	48 8b 00             	mov    (%rax),%rax
  80c90c:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c910:	73 11                	jae    80c923 <mem_realloc+0x2a4>
      lfree = mem2;
  80c912:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c919:	00 00 00 
  80c91c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80c920:	48 89 10             	mov    %rdx,(%rax)
    }
    mem2->used = 0;
  80c923:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c927:	c6 40 08 00          	movb   $0x0,0x8(%rax)
    mem2->next = mem->next;
  80c92b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c92f:	8b 10                	mov    (%rax),%edx
  80c931:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c935:	89 10                	mov    %edx,(%rax)
    mem2->prev = ptr;
  80c937:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c93b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c93e:	89 50 04             	mov    %edx,0x4(%rax)
    mem->next = ptr2;
  80c941:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c945:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80c948:	89 10                	mov    %edx,(%rax)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80c94a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c94e:	8b 00                	mov    (%rax),%eax
  80c950:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c955:	74 1e                	je     80c975 <mem_realloc+0x2f6>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80c957:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c95e:	00 00 00 
  80c961:	48 8b 10             	mov    (%rax),%rdx
  80c964:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c968:	8b 00                	mov    (%rax),%eax
  80c96a:	89 c0                	mov    %eax,%eax
  80c96c:	48 01 c2             	add    %rax,%rdx
  80c96f:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c972:	89 42 04             	mov    %eax,0x4(%rdx)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80c975:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c97c:	00 00 00 
  80c97f:	8b 00                	mov    (%rax),%eax
  80c981:	89 c7                	mov    %eax,%edi
  80c983:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  80c98a:	00 00 00 
  80c98d:	ff d0                	callq  *%rax
  return rmem;
  80c98f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
}
  80c993:	c9                   	leaveq 
  80c994:	c3                   	retq   

000000000080c995 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  80c995:	55                   	push   %rbp
  80c996:	48 89 e5             	mov    %rsp,%rbp
  80c999:	48 83 ec 30          	sub    $0x30,%rsp
  80c99d:	89 7d dc             	mov    %edi,-0x24(%rbp)
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  80c9a0:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80c9a4:	75 0a                	jne    80c9b0 <mem_malloc+0x1b>
    return NULL;
  80c9a6:	b8 00 00 00 00       	mov    $0x0,%eax
  80c9ab:	e9 6b 03 00 00       	jmpq   80cd1b <mem_malloc+0x386>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  80c9b0:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80c9b3:	83 c0 03             	add    $0x3,%eax
  80c9b6:	83 e0 fc             	and    $0xfffffffc,%eax
  80c9b9:	89 45 dc             	mov    %eax,-0x24(%rbp)

  if(size < MIN_SIZE_ALIGNED) {
  80c9bc:	83 7d dc 0b          	cmpl   $0xb,-0x24(%rbp)
  80c9c0:	77 07                	ja     80c9c9 <mem_malloc+0x34>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  80c9c2:	c7 45 dc 0c 00 00 00 	movl   $0xc,-0x24(%rbp)
  }

  if (size > MEM_SIZE_ALIGNED) {
  80c9c9:	81 7d dc 00 00 22 00 	cmpl   $0x220000,-0x24(%rbp)
  80c9d0:	76 0a                	jbe    80c9dc <mem_malloc+0x47>
    return NULL;
  80c9d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80c9d7:	e9 3f 03 00 00       	jmpq   80cd1b <mem_malloc+0x386>
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  80c9dc:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c9e3:	00 00 00 
  80c9e6:	8b 00                	mov    (%rax),%eax
  80c9e8:	be 00 00 00 00       	mov    $0x0,%esi
  80c9ed:	89 c7                	mov    %eax,%edi
  80c9ef:	48 b8 6f 82 81 00 00 	movabs $0x81826f,%rax
  80c9f6:	00 00 00 
  80c9f9:	ff d0                	callq  *%rax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80c9fb:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80ca02:	00 00 00 
  80ca05:	48 8b 00             	mov    (%rax),%rax
  80ca08:	48 89 c2             	mov    %rax,%rdx
  80ca0b:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80ca12:	00 00 00 
  80ca15:	48 8b 00             	mov    (%rax),%rax
  80ca18:	48 29 c2             	sub    %rax,%rdx
  80ca1b:	48 89 d0             	mov    %rdx,%rax
  80ca1e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80ca21:	e9 c5 02 00 00       	jmpq   80cceb <mem_malloc+0x356>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  80ca26:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80ca2d:	00 00 00 
  80ca30:	48 8b 10             	mov    (%rax),%rdx
  80ca33:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80ca36:	48 01 d0             	add    %rdx,%rax
  80ca39:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80ca3d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ca41:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80ca45:	84 c0                	test   %al,%al
  80ca47:	0f 85 86 02 00 00    	jne    80ccd3 <mem_malloc+0x33e>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  80ca4d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ca51:	8b 00                	mov    (%rax),%eax
  80ca53:	89 c2                	mov    %eax,%edx
  80ca55:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80ca58:	48 29 c2             	sub    %rax,%rdx
  80ca5b:	48 89 d0             	mov    %rdx,%rax
  80ca5e:	48 8d 50 f4          	lea    -0xc(%rax),%rdx
  80ca62:	8b 45 dc             	mov    -0x24(%rbp),%eax
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80ca65:	48 39 c2             	cmp    %rax,%rdx
  80ca68:	0f 82 65 02 00 00    	jb     80ccd3 <mem_malloc+0x33e>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  80ca6e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ca72:	8b 00                	mov    (%rax),%eax
  80ca74:	89 c2                	mov    %eax,%edx
  80ca76:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80ca79:	48 29 c2             	sub    %rax,%rdx
  80ca7c:	48 89 d0             	mov    %rdx,%rax
  80ca7f:	48 8d 50 f4          	lea    -0xc(%rax),%rdx
  80ca83:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80ca86:	48 83 c0 18          	add    $0x18,%rax
  80ca8a:	48 39 c2             	cmp    %rax,%rdx
  80ca8d:	0f 82 81 00 00 00    	jb     80cb14 <mem_malloc+0x17f>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  80ca93:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80ca96:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80ca99:	01 d0                	add    %edx,%eax
  80ca9b:	83 c0 0c             	add    $0xc,%eax
  80ca9e:	89 45 ec             	mov    %eax,-0x14(%rbp)
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  80caa1:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80caa8:	00 00 00 
  80caab:	48 8b 10             	mov    (%rax),%rdx
  80caae:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80cab1:	48 01 d0             	add    %rdx,%rax
  80cab4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          mem2->used = 0;
  80cab8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cabc:	c6 40 08 00          	movb   $0x0,0x8(%rax)
          mem2->next = mem->next;
  80cac0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cac4:	8b 10                	mov    (%rax),%edx
  80cac6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80caca:	89 10                	mov    %edx,(%rax)
          mem2->prev = ptr;
  80cacc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cad0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80cad3:	89 50 04             	mov    %edx,0x4(%rax)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  80cad6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cada:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cadd:	89 10                	mov    %edx,(%rax)
          mem->used = 1;
  80cadf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cae3:	c6 40 08 01          	movb   $0x1,0x8(%rax)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  80cae7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80caeb:	8b 00                	mov    (%rax),%eax
  80caed:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80caf2:	74 28                	je     80cb1c <mem_malloc+0x187>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80caf4:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80cafb:	00 00 00 
  80cafe:	48 8b 10             	mov    (%rax),%rdx
  80cb01:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cb05:	8b 00                	mov    (%rax),%eax
  80cb07:	89 c0                	mov    %eax,%eax
  80cb09:	48 01 c2             	add    %rax,%rdx
  80cb0c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80cb0f:	89 42 04             	mov    %eax,0x4(%rdx)
  80cb12:	eb 08                	jmp    80cb1c <mem_malloc+0x187>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  80cb14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cb18:	c6 40 08 01          	movb   $0x1,0x8(%rax)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  80cb1c:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cb23:	00 00 00 
  80cb26:	48 8b 00             	mov    (%rax),%rax
  80cb29:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  80cb2d:	0f 85 c2 00 00 00    	jne    80cbf5 <mem_malloc+0x260>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80cb33:	eb 2e                	jmp    80cb63 <mem_malloc+0x1ce>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  80cb35:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80cb3c:	00 00 00 
  80cb3f:	48 8b 10             	mov    (%rax),%rdx
  80cb42:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cb49:	00 00 00 
  80cb4c:	48 8b 00             	mov    (%rax),%rax
  80cb4f:	8b 00                	mov    (%rax),%eax
  80cb51:	89 c0                	mov    %eax,%eax
  80cb53:	48 01 c2             	add    %rax,%rdx
  80cb56:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cb5d:	00 00 00 
  80cb60:	48 89 10             	mov    %rdx,(%rax)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80cb63:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cb6a:	00 00 00 
  80cb6d:	48 8b 00             	mov    (%rax),%rax
  80cb70:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80cb74:	84 c0                	test   %al,%al
  80cb76:	74 1f                	je     80cb97 <mem_malloc+0x202>
  80cb78:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cb7f:	00 00 00 
  80cb82:	48 8b 10             	mov    (%rax),%rdx
  80cb85:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80cb8c:	00 00 00 
  80cb8f:	48 8b 00             	mov    (%rax),%rax
  80cb92:	48 39 c2             	cmp    %rax,%rdx
  80cb95:	75 9e                	jne    80cb35 <mem_malloc+0x1a0>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  80cb97:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cb9e:	00 00 00 
  80cba1:	48 8b 10             	mov    (%rax),%rdx
  80cba4:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80cbab:	00 00 00 
  80cbae:	48 8b 00             	mov    (%rax),%rax
  80cbb1:	48 39 c2             	cmp    %rax,%rdx
  80cbb4:	74 3f                	je     80cbf5 <mem_malloc+0x260>
  80cbb6:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cbbd:	00 00 00 
  80cbc0:	48 8b 00             	mov    (%rax),%rax
  80cbc3:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80cbc7:	84 c0                	test   %al,%al
  80cbc9:	74 2a                	je     80cbf5 <mem_malloc+0x260>
  80cbcb:	48 ba b3 1f 82 00 00 	movabs $0x821fb3,%rdx
  80cbd2:	00 00 00 
  80cbd5:	be 47 02 00 00       	mov    $0x247,%esi
  80cbda:	48 bf af 1e 82 00 00 	movabs $0x821eaf,%rdi
  80cbe1:	00 00 00 
  80cbe4:	b8 00 00 00 00       	mov    $0x0,%eax
  80cbe9:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80cbf0:	00 00 00 
  80cbf3:	ff d1                	callq  *%rcx
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  80cbf5:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80cbfc:	00 00 00 
  80cbff:	8b 00                	mov    (%rax),%eax
  80cc01:	89 c7                	mov    %eax,%edi
  80cc03:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  80cc0a:	00 00 00 
  80cc0d:	ff d0                	callq  *%rax
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  80cc0f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80cc12:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cc16:	48 01 d0             	add    %rdx,%rax
  80cc19:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  80cc1d:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80cc24:	00 00 00 
  80cc27:	48 8b 00             	mov    (%rax),%rax
  80cc2a:	48 39 c2             	cmp    %rax,%rdx
  80cc2d:	76 2a                	jbe    80cc59 <mem_malloc+0x2c4>
  80cc2f:	48 ba d0 1f 82 00 00 	movabs $0x821fd0,%rdx
  80cc36:	00 00 00 
  80cc39:	be 4c 02 00 00       	mov    $0x24c,%esi
  80cc3e:	48 bf af 1e 82 00 00 	movabs $0x821eaf,%rdi
  80cc45:	00 00 00 
  80cc48:	b8 00 00 00 00       	mov    $0x0,%eax
  80cc4d:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80cc54:	00 00 00 
  80cc57:	ff d1                	callq  *%rcx
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  80cc59:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cc5d:	48 83 c0 0c          	add    $0xc,%rax
  80cc61:	83 e0 03             	and    $0x3,%eax
  80cc64:	48 85 c0             	test   %rax,%rax
  80cc67:	74 2a                	je     80cc93 <mem_malloc+0x2fe>
  80cc69:	48 ba 00 20 82 00 00 	movabs $0x822000,%rdx
  80cc70:	00 00 00 
  80cc73:	be 4e 02 00 00       	mov    $0x24e,%esi
  80cc78:	48 bf af 1e 82 00 00 	movabs $0x821eaf,%rdi
  80cc7f:	00 00 00 
  80cc82:	b8 00 00 00 00       	mov    $0x0,%eax
  80cc87:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80cc8e:	00 00 00 
  80cc91:	ff d1                	callq  *%rcx
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  80cc93:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cc97:	83 e0 03             	and    $0x3,%eax
  80cc9a:	48 85 c0             	test   %rax,%rax
  80cc9d:	74 2a                	je     80ccc9 <mem_malloc+0x334>
  80cc9f:	48 ba 30 20 82 00 00 	movabs $0x822030,%rdx
  80cca6:	00 00 00 
  80cca9:	be 50 02 00 00       	mov    $0x250,%esi
  80ccae:	48 bf af 1e 82 00 00 	movabs $0x821eaf,%rdi
  80ccb5:	00 00 00 
  80ccb8:	b8 00 00 00 00       	mov    $0x0,%eax
  80ccbd:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80ccc4:	00 00 00 
  80ccc7:	ff d1                	callq  *%rcx
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
  80ccc9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cccd:	48 83 c0 0c          	add    $0xc,%rax
  80ccd1:	eb 48                	jmp    80cd1b <mem_malloc+0x386>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  80ccd3:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80ccda:	00 00 00 
  80ccdd:	48 8b 10             	mov    (%rax),%rdx
  80cce0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80cce3:	48 01 d0             	add    %rdx,%rax
  80cce6:	8b 00                	mov    (%rax),%eax
  80cce8:	89 45 fc             	mov    %eax,-0x4(%rbp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80cceb:	b8 00 00 22 00       	mov    $0x220000,%eax
  80ccf0:	2b 45 dc             	sub    -0x24(%rbp),%eax
  80ccf3:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80ccf6:	0f 87 2a fd ff ff    	ja     80ca26 <mem_malloc+0x91>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  80ccfc:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80cd03:	00 00 00 
  80cd06:	8b 00                	mov    (%rax),%eax
  80cd08:	89 c7                	mov    %eax,%edi
  80cd0a:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  80cd11:	00 00 00 
  80cd14:	ff d0                	callq  *%rax
  return NULL;
  80cd16:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80cd1b:	c9                   	leaveq 
  80cd1c:	c3                   	retq   

000000000080cd1d <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  80cd1d:	55                   	push   %rbp
  80cd1e:	48 89 e5             	mov    %rsp,%rbp
  80cd21:	48 83 ec 20          	sub    $0x20,%rsp
  80cd25:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80cd28:	89 75 e8             	mov    %esi,-0x18(%rbp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  80cd2b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80cd2e:	0f af 45 e8          	imul   -0x18(%rbp),%eax
  80cd32:	89 c7                	mov    %eax,%edi
  80cd34:	48 b8 95 c9 80 00 00 	movabs $0x80c995,%rax
  80cd3b:	00 00 00 
  80cd3e:	ff d0                	callq  *%rax
  80cd40:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (p) {
  80cd44:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80cd49:	74 21                	je     80cd6c <mem_calloc+0x4f>
    /* zero the memory */
    memset(p, 0, count * size);
  80cd4b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80cd4e:	0f af 45 e8          	imul   -0x18(%rbp),%eax
  80cd52:	89 c2                	mov    %eax,%edx
  80cd54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cd58:	be 00 00 00 00       	mov    $0x0,%esi
  80cd5d:	48 89 c7             	mov    %rax,%rdi
  80cd60:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  80cd67:	00 00 00 
  80cd6a:	ff d0                	callq  *%rax
  }
  return p;
  80cd6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80cd70:	c9                   	leaveq 
  80cd71:	c3                   	retq   

000000000080cd72 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  80cd72:	55                   	push   %rbp
  80cd73:	48 89 e5             	mov    %rsp,%rbp
  80cd76:	48 83 ec 10          	sub    $0x10,%rsp
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
  80cd7a:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)
  80cd80:	eb 05                	jmp    80cd87 <memp_init+0x15>
  80cd82:	66 83 45 f6 01       	addw   $0x1,-0xa(%rbp)
  80cd87:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%rbp)
  80cd8c:	76 f4                	jbe    80cd82 <memp_init+0x10>
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  80cd8e:	48 b8 a0 95 a4 00 00 	movabs $0xa495a0,%rax
  80cd95:	00 00 00 
  80cd98:	48 83 c0 03          	add    $0x3,%rax
  80cd9c:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80cda0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80cda4:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)
  80cdaa:	e9 97 00 00 00       	jmpq   80ce46 <memp_init+0xd4>
    memp_tab[i] = NULL;
  80cdaf:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80cdb3:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cdba:	00 00 00 
  80cdbd:	48 63 d2             	movslq %edx,%rdx
  80cdc0:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  80cdc7:	00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80cdc8:	66 c7 45 f4 00 00    	movw   $0x0,-0xc(%rbp)
  80cdce:	eb 56                	jmp    80ce26 <memp_init+0xb4>
      memp->next = memp_tab[i];
  80cdd0:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80cdd4:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cddb:	00 00 00 
  80cdde:	48 63 d2             	movslq %edx,%rdx
  80cde1:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  80cde5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cde9:	48 89 10             	mov    %rdx,(%rax)
      memp_tab[i] = memp;
  80cdec:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80cdf0:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cdf7:	00 00 00 
  80cdfa:	48 63 d2             	movslq %edx,%rdx
  80cdfd:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80ce01:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80ce05:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80ce09:	48 b8 60 20 82 00 00 	movabs $0x822060,%rax
  80ce10:	00 00 00 
  80ce13:	48 63 d2             	movslq %edx,%rdx
  80ce16:	0f b7 04 50          	movzwl (%rax,%rdx,2),%eax
  80ce1a:	0f b7 c0             	movzwl %ax,%eax
  80ce1d:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80ce21:	66 83 45 f4 01       	addw   $0x1,-0xc(%rbp)
  80ce26:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80ce2a:	48 b8 80 20 82 00 00 	movabs $0x822080,%rax
  80ce31:	00 00 00 
  80ce34:	48 63 d2             	movslq %edx,%rdx
  80ce37:	0f b7 04 50          	movzwl (%rax,%rdx,2),%eax
  80ce3b:	66 3b 45 f4          	cmp    -0xc(%rbp),%ax
  80ce3f:	77 8f                	ja     80cdd0 <memp_init+0x5e>
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80ce41:	66 83 45 f6 01       	addw   $0x1,-0xa(%rbp)
  80ce46:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%rbp)
  80ce4b:	0f 86 5e ff ff ff    	jbe    80cdaf <memp_init+0x3d>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  80ce51:	90                   	nop
  80ce52:	c9                   	leaveq 
  80ce53:	c3                   	retq   

000000000080ce54 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  80ce54:	55                   	push   %rbp
  80ce55:	48 89 e5             	mov    %rsp,%rbp
  80ce58:	48 83 ec 20          	sub    $0x20,%rsp
  80ce5c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  80ce5f:	83 7d ec 0d          	cmpl   $0xd,-0x14(%rbp)
  80ce63:	76 2a                	jbe    80ce8f <memp_malloc+0x3b>
  80ce65:	48 ba 2f 21 82 00 00 	movabs $0x82212f,%rdx
  80ce6c:	00 00 00 
  80ce6f:	be 2e 01 00 00       	mov    $0x12e,%esi
  80ce74:	48 bf 4c 21 82 00 00 	movabs $0x82214c,%rdi
  80ce7b:	00 00 00 
  80ce7e:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce83:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80ce8a:	00 00 00 
  80ce8d:	ff d1                	callq  *%rcx
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  80ce8f:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80ce96:	00 00 00 
  80ce99:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80ce9c:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80cea0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
  if (memp != NULL) {    
  80cea4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80cea9:	74 4e                	je     80cef9 <memp_malloc+0xa5>
    memp_tab[type] = memp->next;    
  80ceab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ceaf:	48 8b 08             	mov    (%rax),%rcx
  80ceb2:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80ceb9:	00 00 00 
  80cebc:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cebf:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  80cec3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cec7:	83 e0 03             	and    $0x3,%eax
  80ceca:	48 85 c0             	test   %rax,%rax
  80cecd:	74 2a                	je     80cef9 <memp_malloc+0xa5>
  80cecf:	48 ba 68 21 82 00 00 	movabs $0x822168,%rdx
  80ced6:	00 00 00 
  80ced9:	be 40 01 00 00       	mov    $0x140,%esi
  80cede:	48 bf 4c 21 82 00 00 	movabs $0x82214c,%rdi
  80cee5:	00 00 00 
  80cee8:	b8 00 00 00 00       	mov    $0x0,%eax
  80ceed:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80cef4:	00 00 00 
  80cef7:	ff d1                	callq  *%rcx
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
  80cef9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80cefd:	c9                   	leaveq 
  80cefe:	c3                   	retq   

000000000080ceff <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  80ceff:	55                   	push   %rbp
  80cf00:	48 89 e5             	mov    %rsp,%rbp
  80cf03:	48 83 ec 20          	sub    $0x20,%rsp
  80cf07:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80cf0a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  80cf0e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80cf13:	74 6d                	je     80cf82 <memp_free+0x83>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  80cf15:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cf19:	83 e0 03             	and    $0x3,%eax
  80cf1c:	48 85 c0             	test   %rax,%rax
  80cf1f:	74 2a                	je     80cf4b <memp_free+0x4c>
  80cf21:	48 ba 90 21 82 00 00 	movabs $0x822190,%rdx
  80cf28:	00 00 00 
  80cf2b:	be 5c 01 00 00       	mov    $0x15c,%esi
  80cf30:	48 bf 4c 21 82 00 00 	movabs $0x82214c,%rdi
  80cf37:	00 00 00 
  80cf3a:	b8 00 00 00 00       	mov    $0x0,%eax
  80cf3f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80cf46:	00 00 00 
  80cf49:	ff d1                	callq  *%rcx
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)((u8_t*)mem - MEMP_SIZE);
  80cf4b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cf4f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  80cf53:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cf5a:	00 00 00 
  80cf5d:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cf60:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  80cf64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf68:	48 89 10             	mov    %rdx,(%rax)
  memp_tab[type] = memp;
  80cf6b:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cf72:	00 00 00 
  80cf75:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cf78:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80cf7c:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
  80cf80:	eb 01                	jmp    80cf83 <memp_free+0x84>
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
  80cf82:	90                   	nop
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  80cf83:	c9                   	leaveq 
  80cf84:	c3                   	retq   

000000000080cf85 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  80cf85:	55                   	push   %rbp
  80cf86:	48 89 e5             	mov    %rsp,%rbp
  80cf89:	48 83 ec 30          	sub    $0x30,%rsp
  80cf8d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80cf91:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80cf95:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80cf99:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  80cf9d:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  80cfa1:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  80cfa5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfa9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
  netif->netmask.addr = 0;
  80cfb0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfb4:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
  netif->gw.addr = 0;
  80cfbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfbf:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
  netif->flags = 0;
  80cfc6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfca:	c6 40 4a 00          	movb   $0x0,0x4a(%rax)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  80cfce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfd2:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80cfd9:	00 
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  80cfda:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfde:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80cfe2:	48 89 50 30          	mov    %rdx,0x30(%rax)
  netif->num = netifnum++;
  80cfe6:	48 b8 4b b0 b4 00 00 	movabs $0xb4b04b,%rax
  80cfed:	00 00 00 
  80cff0:	0f b6 00             	movzbl (%rax),%eax
  80cff3:	8d 48 01             	lea    0x1(%rax),%ecx
  80cff6:	48 ba 4b b0 b4 00 00 	movabs $0xb4b04b,%rdx
  80cffd:	00 00 00 
  80d000:	88 0a                	mov    %cl,(%rdx)
  80d002:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d006:	88 42 4d             	mov    %al,0x4d(%rdx)
  netif->input = input;
  80d009:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d00d:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80d011:	48 89 50 18          	mov    %rdx,0x18(%rax)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  80d015:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80d019:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80d01d:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80d021:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d025:	48 89 c7             	mov    %rax,%rdi
  80d028:	48 b8 77 d0 80 00 00 	movabs $0x80d077,%rax
  80d02f:	00 00 00 
  80d032:	ff d0                	callq  *%rax

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  80d034:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d038:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80d03c:	48 89 d7             	mov    %rdx,%rdi
  80d03f:	ff d0                	callq  *%rax
  80d041:	84 c0                	test   %al,%al
  80d043:	74 07                	je     80d04c <netif_add+0xc7>
    return NULL;
  80d045:	b8 00 00 00 00       	mov    $0x0,%eax
  80d04a:	eb 29                	jmp    80d075 <netif_add+0xf0>
  }

  /* add this netif to the list */
  netif->next = netif_list;
  80d04c:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d053:	00 00 00 
  80d056:	48 8b 10             	mov    (%rax),%rdx
  80d059:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d05d:	48 89 10             	mov    %rdx,(%rax)
  netif_list = netif;
  80d060:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d067:	00 00 00 
  80d06a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d06e:	48 89 10             	mov    %rdx,(%rax)
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  80d071:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80d075:	c9                   	leaveq 
  80d076:	c3                   	retq   

000000000080d077 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  80d077:	55                   	push   %rbp
  80d078:	48 89 e5             	mov    %rsp,%rbp
  80d07b:	48 83 ec 20          	sub    $0x20,%rsp
  80d07f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80d083:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80d087:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80d08b:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  netif_set_ipaddr(netif, ipaddr);
  80d08f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80d093:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d097:	48 89 d6             	mov    %rdx,%rsi
  80d09a:	48 89 c7             	mov    %rax,%rdi
  80d09d:	48 b8 29 d2 80 00 00 	movabs $0x80d229,%rax
  80d0a4:	00 00 00 
  80d0a7:	ff d0                	callq  *%rax
  netif_set_netmask(netif, netmask);
  80d0a9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80d0ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d0b1:	48 89 d6             	mov    %rdx,%rsi
  80d0b4:	48 89 c7             	mov    %rax,%rdi
  80d0b7:	48 b8 5e d3 80 00 00 	movabs $0x80d35e,%rax
  80d0be:	00 00 00 
  80d0c1:	ff d0                	callq  *%rax
  netif_set_gw(netif, gw);
  80d0c3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80d0c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d0cb:	48 89 d6             	mov    %rdx,%rsi
  80d0ce:	48 89 c7             	mov    %rax,%rdi
  80d0d1:	48 b8 30 d3 80 00 00 	movabs $0x80d330,%rax
  80d0d8:	00 00 00 
  80d0db:	ff d0                	callq  *%rax
}
  80d0dd:	90                   	nop
  80d0de:	c9                   	leaveq 
  80d0df:	c3                   	retq   

000000000080d0e0 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  80d0e0:	55                   	push   %rbp
  80d0e1:	48 89 e5             	mov    %rsp,%rbp
  80d0e4:	48 83 ec 20          	sub    $0x20,%rsp
  80d0e8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if ( netif == NULL ) return;
  80d0ec:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d0f1:	0f 84 98 00 00 00    	je     80d18f <netif_remove+0xaf>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  80d0f7:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d0fe:	00 00 00 
  80d101:	48 8b 00             	mov    (%rax),%rax
  80d104:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80d108:	75 16                	jne    80d120 <netif_remove+0x40>
    netif_list = netif->next;
  80d10a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d10e:	48 8b 10             	mov    (%rax),%rdx
  80d111:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d118:	00 00 00 
  80d11b:	48 89 10             	mov    %rdx,(%rax)
  80d11e:	eb 49                	jmp    80d169 <netif_remove+0x89>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80d120:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d127:	00 00 00 
  80d12a:	48 8b 00             	mov    (%rax),%rax
  80d12d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d131:	eb 28                	jmp    80d15b <netif_remove+0x7b>
      if (tmpNetif->next == netif) {
  80d133:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d137:	48 8b 00             	mov    (%rax),%rax
  80d13a:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80d13e:	75 10                	jne    80d150 <netif_remove+0x70>
        tmpNetif->next = netif->next;
  80d140:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d144:	48 8b 10             	mov    (%rax),%rdx
  80d147:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d14b:	48 89 10             	mov    %rdx,(%rax)
        snmp_dec_iflist();
        break;
  80d14e:	eb 12                	jmp    80d162 <netif_remove+0x82>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80d150:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d154:	48 8b 00             	mov    (%rax),%rax
  80d157:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d15b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d160:	75 d1                	jne    80d133 <netif_remove+0x53>
        tmpNetif->next = netif->next;
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
  80d162:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d167:	74 29                	je     80d192 <netif_remove+0xb2>
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  80d169:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  80d170:	00 00 00 
  80d173:	48 8b 00             	mov    (%rax),%rax
  80d176:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80d17a:	75 17                	jne    80d193 <netif_remove+0xb3>
    /* reset default netif */
    netif_set_default(NULL);
  80d17c:	bf 00 00 00 00       	mov    $0x0,%edi
  80d181:	48 b8 8c d3 80 00 00 	movabs $0x80d38c,%rax
  80d188:	00 00 00 
  80d18b:	ff d0                	callq  *%rax
  80d18d:	eb 04                	jmp    80d193 <netif_remove+0xb3>
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  if ( netif == NULL ) return;
  80d18f:	90                   	nop
  80d190:	eb 01                	jmp    80d193 <netif_remove+0xb3>
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  80d192:	90                   	nop
  /* this netif is default? */
  if (netif_default == netif)
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  80d193:	c9                   	leaveq 
  80d194:	c3                   	retq   

000000000080d195 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  80d195:	55                   	push   %rbp
  80d196:	48 89 e5             	mov    %rsp,%rbp
  80d199:	48 83 ec 18          	sub    $0x18,%rsp
  80d19d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  80d1a1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d1a6:	75 07                	jne    80d1af <netif_find+0x1a>
    return NULL;
  80d1a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80d1ad:	eb 78                	jmp    80d227 <netif_find+0x92>
  }

  num = name[2] - '0';
  80d1af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d1b3:	48 83 c0 02          	add    $0x2,%rax
  80d1b7:	0f b6 00             	movzbl (%rax),%eax
  80d1ba:	83 e8 30             	sub    $0x30,%eax
  80d1bd:	88 45 f7             	mov    %al,-0x9(%rbp)

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80d1c0:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d1c7:	00 00 00 
  80d1ca:	48 8b 00             	mov    (%rax),%rax
  80d1cd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d1d1:	eb 48                	jmp    80d21b <netif_find+0x86>
    if (num == netif->num &&
  80d1d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d1d7:	0f b6 40 4d          	movzbl 0x4d(%rax),%eax
  80d1db:	3a 45 f7             	cmp    -0x9(%rbp),%al
  80d1de:	75 30                	jne    80d210 <netif_find+0x7b>
       name[0] == netif->name[0] &&
  80d1e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d1e4:	0f b6 10             	movzbl (%rax),%edx
  80d1e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d1eb:	0f b6 40 4b          	movzbl 0x4b(%rax),%eax
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
  80d1ef:	38 c2                	cmp    %al,%dl
  80d1f1:	75 1d                	jne    80d210 <netif_find+0x7b>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
  80d1f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d1f7:	48 83 c0 01          	add    $0x1,%rax
  80d1fb:	0f b6 10             	movzbl (%rax),%edx
  80d1fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d202:	0f b6 40 4c          	movzbl 0x4c(%rax),%eax

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
       name[0] == netif->name[0] &&
  80d206:	38 c2                	cmp    %al,%dl
  80d208:	75 06                	jne    80d210 <netif_find+0x7b>
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
  80d20a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d20e:	eb 17                	jmp    80d227 <netif_find+0x92>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80d210:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d214:	48 8b 00             	mov    (%rax),%rax
  80d217:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d21b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d220:	75 b1                	jne    80d1d3 <netif_find+0x3e>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
  80d222:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80d227:	c9                   	leaveq 
  80d228:	c3                   	retq   

000000000080d229 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  80d229:	55                   	push   %rbp
  80d22a:	48 89 e5             	mov    %rsp,%rbp
  80d22d:	48 83 ec 30          	sub    $0x30,%rsp
  80d231:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80d235:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  80d239:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80d23d:	8b 10                	mov    (%rax),%edx
  80d23f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d243:	8b 40 08             	mov    0x8(%rax),%eax
  80d246:	39 c2                	cmp    %eax,%edx
  80d248:	0f 84 c4 00 00 00    	je     80d312 <netif_set_ipaddr+0xe9>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  80d24e:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80d255:	00 00 00 
  80d258:	48 8b 00             	mov    (%rax),%rax
  80d25b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (pcb != NULL) {
  80d25f:	eb 46                	jmp    80d2a7 <netif_set_ipaddr+0x7e>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80d261:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d265:	8b 10                	mov    (%rax),%edx
  80d267:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d26b:	8b 40 08             	mov    0x8(%rax),%eax
  80d26e:	39 c2                	cmp    %eax,%edx
  80d270:	75 29                	jne    80d29b <netif_set_ipaddr+0x72>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  80d272:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d276:	48 8b 40 10          	mov    0x10(%rax),%rax
  80d27a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  80d27e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d282:	48 89 c7             	mov    %rax,%rdi
  80d285:	48 b8 1c ef 80 00 00 	movabs $0x80ef1c,%rax
  80d28c:	00 00 00 
  80d28f:	ff d0                	callq  *%rax
        pcb = next;
  80d291:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d295:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d299:	eb 0c                	jmp    80d2a7 <netif_set_ipaddr+0x7e>
      } else {
        pcb = pcb->next;
  80d29b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d29f:	48 8b 40 10          	mov    0x10(%rax),%rax
  80d2a3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  80d2a7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d2ac:	75 b3                	jne    80d261 <netif_set_ipaddr+0x38>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d2ae:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80d2b5:	00 00 00 
  80d2b8:	48 8b 00             	mov    (%rax),%rax
  80d2bb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80d2bf:	eb 4a                	jmp    80d30b <netif_set_ipaddr+0xe2>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80d2c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d2c5:	48 85 c0             	test   %rax,%rax
  80d2c8:	74 35                	je     80d2ff <netif_set_ipaddr+0xd6>
  80d2ca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d2ce:	8b 00                	mov    (%rax),%eax
  80d2d0:	85 c0                	test   %eax,%eax
  80d2d2:	74 2b                	je     80d2ff <netif_set_ipaddr+0xd6>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
  80d2d4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d2d8:	8b 10                	mov    (%rax),%edx
  80d2da:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d2de:	8b 40 08             	mov    0x8(%rax),%eax
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80d2e1:	39 c2                	cmp    %eax,%edx
  80d2e3:	75 1a                	jne    80d2ff <netif_set_ipaddr+0xd6>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  80d2e5:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80d2ea:	74 08                	je     80d2f4 <netif_set_ipaddr+0xcb>
  80d2ec:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80d2f0:	8b 00                	mov    (%rax),%eax
  80d2f2:	eb 05                	jmp    80d2f9 <netif_set_ipaddr+0xd0>
  80d2f4:	b8 00 00 00 00       	mov    $0x0,%eax
  80d2f9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80d2fd:	89 02                	mov    %eax,(%rdx)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d2ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d303:	48 8b 40 10          	mov    0x10(%rax),%rax
  80d307:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80d30b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80d310:	75 af                	jne    80d2c1 <netif_set_ipaddr+0x98>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  80d312:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80d317:	74 08                	je     80d321 <netif_set_ipaddr+0xf8>
  80d319:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80d31d:	8b 00                	mov    (%rax),%eax
  80d31f:	eb 05                	jmp    80d326 <netif_set_ipaddr+0xfd>
  80d321:	b8 00 00 00 00       	mov    $0x0,%eax
  80d326:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80d32a:	89 42 08             	mov    %eax,0x8(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  80d32d:	90                   	nop
  80d32e:	c9                   	leaveq 
  80d32f:	c3                   	retq   

000000000080d330 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  80d330:	55                   	push   %rbp
  80d331:	48 89 e5             	mov    %rsp,%rbp
  80d334:	48 83 ec 10          	sub    $0x10,%rsp
  80d338:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80d33c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&(netif->gw), gw);
  80d340:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80d345:	74 08                	je     80d34f <netif_set_gw+0x1f>
  80d347:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d34b:	8b 00                	mov    (%rax),%eax
  80d34d:	eb 05                	jmp    80d354 <netif_set_gw+0x24>
  80d34f:	b8 00 00 00 00       	mov    $0x0,%eax
  80d354:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d358:	89 42 10             	mov    %eax,0x10(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  80d35b:	90                   	nop
  80d35c:	c9                   	leaveq 
  80d35d:	c3                   	retq   

000000000080d35e <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  80d35e:	55                   	push   %rbp
  80d35f:	48 89 e5             	mov    %rsp,%rbp
  80d362:	48 83 ec 10          	sub    $0x10,%rsp
  80d366:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80d36a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  80d36e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80d373:	74 08                	je     80d37d <netif_set_netmask+0x1f>
  80d375:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d379:	8b 00                	mov    (%rax),%eax
  80d37b:	eb 05                	jmp    80d382 <netif_set_netmask+0x24>
  80d37d:	b8 00 00 00 00       	mov    $0x0,%eax
  80d382:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d386:	89 42 0c             	mov    %eax,0xc(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  80d389:	90                   	nop
  80d38a:	c9                   	leaveq 
  80d38b:	c3                   	retq   

000000000080d38c <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  80d38c:	55                   	push   %rbp
  80d38d:	48 89 e5             	mov    %rsp,%rbp
  80d390:	48 83 ec 08          	sub    $0x8,%rsp
  80d394:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  80d398:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  80d39f:	00 00 00 
  80d3a2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d3a6:	48 89 10             	mov    %rdx,(%rax)
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  80d3a9:	90                   	nop
  80d3aa:	c9                   	leaveq 
  80d3ab:	c3                   	retq   

000000000080d3ac <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  80d3ac:	55                   	push   %rbp
  80d3ad:	48 89 e5             	mov    %rsp,%rbp
  80d3b0:	48 83 ec 10          	sub    $0x10,%rsp
  80d3b4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  80d3b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d3bc:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d3c0:	0f b6 c0             	movzbl %al,%eax
  80d3c3:	83 e0 01             	and    $0x1,%eax
  80d3c6:	85 c0                	test   %eax,%eax
  80d3c8:	75 49                	jne    80d413 <netif_set_up+0x67>
    netif->flags |= NETIF_FLAG_UP;
  80d3ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d3ce:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d3d2:	83 c8 01             	or     $0x1,%eax
  80d3d5:	89 c2                	mov    %eax,%edx
  80d3d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d3db:	88 50 4a             	mov    %dl,0x4a(%rax)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  80d3de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d3e2:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d3e6:	0f b6 c0             	movzbl %al,%eax
  80d3e9:	83 e0 20             	and    $0x20,%eax
  80d3ec:	85 c0                	test   %eax,%eax
  80d3ee:	74 23                	je     80d413 <netif_set_up+0x67>
      etharp_query(netif, &(netif->ip_addr), NULL);
  80d3f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d3f4:	48 8d 48 08          	lea    0x8(%rax),%rcx
  80d3f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d3fc:	ba 00 00 00 00       	mov    $0x0,%edx
  80d401:	48 89 ce             	mov    %rcx,%rsi
  80d404:	48 89 c7             	mov    %rax,%rdi
  80d407:	48 b8 fa 6c 81 00 00 	movabs $0x816cfa,%rax
  80d40e:	00 00 00 
  80d411:	ff d0                	callq  *%rax
    }
#endif /* LWIP_ARP */
    
  }
}
  80d413:	90                   	nop
  80d414:	c9                   	leaveq 
  80d415:	c3                   	retq   

000000000080d416 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  80d416:	55                   	push   %rbp
  80d417:	48 89 e5             	mov    %rsp,%rbp
  80d41a:	48 83 ec 08          	sub    $0x8,%rsp
  80d41e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if ( netif->flags & NETIF_FLAG_UP )
  80d422:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d426:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d42a:	0f b6 c0             	movzbl %al,%eax
  80d42d:	83 e0 01             	and    $0x1,%eax
  80d430:	85 c0                	test   %eax,%eax
  80d432:	74 14                	je     80d448 <netif_set_down+0x32>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  80d434:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d438:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d43c:	83 e0 fe             	and    $0xfffffffe,%eax
  80d43f:	89 c2                	mov    %eax,%edx
  80d441:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d445:	88 50 4a             	mov    %dl,0x4a(%rax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  80d448:	90                   	nop
  80d449:	c9                   	leaveq 
  80d44a:	c3                   	retq   

000000000080d44b <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  80d44b:	55                   	push   %rbp
  80d44c:	48 89 e5             	mov    %rsp,%rbp
  80d44f:	48 83 ec 08          	sub    $0x8,%rsp
  80d453:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  80d457:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d45b:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d45f:	0f b6 c0             	movzbl %al,%eax
  80d462:	83 e0 01             	and    $0x1,%eax
  80d465:	85 c0                	test   %eax,%eax
  80d467:	0f 95 c0             	setne  %al
}
  80d46a:	c9                   	leaveq 
  80d46b:	c3                   	retq   

000000000080d46c <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  80d46c:	55                   	push   %rbp
  80d46d:	48 89 e5             	mov    %rsp,%rbp
  80d470:	48 83 ec 30          	sub    $0x30,%rsp
  80d474:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80d477:	89 f0                	mov    %esi,%eax
  80d479:	89 55 d4             	mov    %edx,-0x2c(%rbp)
  80d47c:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  80d480:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  switch (layer) {
  80d486:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80d489:	83 f8 01             	cmp    $0x1,%eax
  80d48c:	74 16                	je     80d4a4 <pbuf_alloc+0x38>
  80d48e:	83 f8 01             	cmp    $0x1,%eax
  80d491:	72 0c                	jb     80d49f <pbuf_alloc+0x33>
  80d493:	83 f8 02             	cmp    $0x2,%eax
  80d496:	74 11                	je     80d4a9 <pbuf_alloc+0x3d>
  80d498:	83 f8 03             	cmp    $0x3,%eax
  80d49b:	74 3d                	je     80d4da <pbuf_alloc+0x6e>
  80d49d:	eb 11                	jmp    80d4b0 <pbuf_alloc+0x44>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  80d49f:	66 83 45 ee 14       	addw   $0x14,-0x12(%rbp)
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  80d4a4:	66 83 45 ee 14       	addw   $0x14,-0x12(%rbp)
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  80d4a9:	66 83 45 ee 0e       	addw   $0xe,-0x12(%rbp)
    break;
  80d4ae:	eb 2b                	jmp    80d4db <pbuf_alloc+0x6f>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  80d4b0:	48 ba b0 21 82 00 00 	movabs $0x8221b0,%rdx
  80d4b7:	00 00 00 
  80d4ba:	be 8b 00 00 00       	mov    $0x8b,%esi
  80d4bf:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80d4c6:	00 00 00 
  80d4c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80d4ce:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80d4d5:	00 00 00 
  80d4d8:	ff d1                	callq  *%rcx
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    break;
  80d4da:	90                   	nop
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
  80d4db:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d4de:	83 f8 02             	cmp    $0x2,%eax
  80d4e1:	77 0e                	ja     80d4f1 <pbuf_alloc+0x85>
  80d4e3:	83 f8 01             	cmp    $0x1,%eax
  80d4e6:	0f 83 a9 03 00 00    	jae    80d895 <pbuf_alloc+0x429>
  80d4ec:	e9 d6 02 00 00       	jmpq   80d7c7 <pbuf_alloc+0x35b>
  80d4f1:	83 f8 03             	cmp    $0x3,%eax
  80d4f4:	0f 85 02 04 00 00    	jne    80d8fc <pbuf_alloc+0x490>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  80d4fa:	bf 0d 00 00 00       	mov    $0xd,%edi
  80d4ff:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  80d506:	00 00 00 
  80d509:	ff d0                	callq  *%rax
  80d50b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  80d50f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d514:	75 0a                	jne    80d520 <pbuf_alloc+0xb4>
      return NULL;
  80d516:	b8 00 00 00 00       	mov    $0x0,%eax
  80d51b:	e9 1d 04 00 00       	jmpq   80d93d <pbuf_alloc+0x4d1>
    }
    p->type = type;
  80d520:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d523:	89 c2                	mov    %eax,%edx
  80d525:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d529:	88 50 14             	mov    %dl,0x14(%rax)
    p->next = NULL;
  80d52c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d530:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  80d537:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d53b:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80d53f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d543:	48 01 d0             	add    %rdx,%rax
  80d546:	48 83 c0 03          	add    $0x3,%rax
  80d54a:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80d54e:	48 89 c2             	mov    %rax,%rdx
  80d551:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d555:	48 89 50 08          	mov    %rdx,0x8(%rax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
  80d559:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d55d:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d561:	83 e0 03             	and    $0x3,%eax
  80d564:	48 85 c0             	test   %rax,%rax
  80d567:	74 2a                	je     80d593 <pbuf_alloc+0x127>
  80d569:	48 ba e0 21 82 00 00 	movabs $0x8221e0,%rdx
  80d570:	00 00 00 
  80d573:	be 9d 00 00 00       	mov    $0x9d,%esi
  80d578:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80d57f:	00 00 00 
  80d582:	b8 00 00 00 00       	mov    $0x0,%eax
  80d587:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80d58e:	00 00 00 
  80d591:	ff d1                	callq  *%rcx
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  80d593:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d597:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d59b:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  80d59f:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d5a3:	83 c0 03             	add    $0x3,%eax
  80d5a6:	83 e0 fc             	and    $0xfffffffc,%eax
  80d5a9:	ba d0 07 00 00       	mov    $0x7d0,%edx
  80d5ae:	29 c2                	sub    %eax,%edx
  80d5b0:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  80d5b4:	39 c2                	cmp    %eax,%edx
  80d5b6:	0f 4e c2             	cmovle %edx,%eax
  80d5b9:	89 c2                	mov    %eax,%edx
  80d5bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d5bf:	66 89 50 12          	mov    %dx,0x12(%rax)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80d5c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d5c7:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80d5cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d5cf:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d5d3:	0f b7 c0             	movzwl %ax,%eax
  80d5d6:	48 01 c2             	add    %rax,%rdx
  80d5d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d5dd:	48 05 e8 07 00 00    	add    $0x7e8,%rax
  80d5e3:	48 39 c2             	cmp    %rax,%rdx
  80d5e6:	76 2a                	jbe    80d612 <pbuf_alloc+0x1a6>
  80d5e8:	48 ba 10 22 82 00 00 	movabs $0x822210,%rdx
  80d5ef:	00 00 00 
  80d5f2:	be a4 00 00 00       	mov    $0xa4,%esi
  80d5f7:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80d5fe:	00 00 00 
  80d601:	b8 00 00 00 00       	mov    $0x0,%eax
  80d606:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80d60d:	00 00 00 
  80d610:	ff d1                	callq  *%rcx
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  80d612:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d616:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  80d61c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d620:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* remaining length to be allocated */
    rem_len = length - p->len;
  80d624:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d628:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d62c:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d630:	0f b7 c0             	movzwl %ax,%eax
  80d633:	29 c2                	sub    %eax,%edx
  80d635:	89 d0                	mov    %edx,%eax
  80d637:	89 45 e8             	mov    %eax,-0x18(%rbp)
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  80d63a:	e9 79 01 00 00       	jmpq   80d7b8 <pbuf_alloc+0x34c>
      q = memp_malloc(MEMP_PBUF_POOL);
  80d63f:	bf 0d 00 00 00       	mov    $0xd,%edi
  80d644:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  80d64b:	00 00 00 
  80d64e:	ff d0                	callq  *%rax
  80d650:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      if (q == NULL) {
  80d654:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80d659:	75 1d                	jne    80d678 <pbuf_alloc+0x20c>
        /* free chain so far allocated */
        pbuf_free(p);
  80d65b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d65f:	48 89 c7             	mov    %rax,%rdi
  80d662:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  80d669:	00 00 00 
  80d66c:	ff d0                	callq  *%rax
        /* bail out unsuccesfully */
        return NULL;
  80d66e:	b8 00 00 00 00       	mov    $0x0,%eax
  80d673:	e9 c5 02 00 00       	jmpq   80d93d <pbuf_alloc+0x4d1>
      }
      q->type = type;
  80d678:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d67b:	89 c2                	mov    %eax,%edx
  80d67d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d681:	88 50 14             	mov    %dl,0x14(%rax)
      q->flags = 0;
  80d684:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d688:	c6 40 15 00          	movb   $0x0,0x15(%rax)
      q->next = NULL;
  80d68c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d690:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  80d697:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d69b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80d69f:	48 89 10             	mov    %rdx,(%rax)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  80d6a2:	81 7d e8 fe ff 00 00 	cmpl   $0xfffe,-0x18(%rbp)
  80d6a9:	7e 2a                	jle    80d6d5 <pbuf_alloc+0x269>
  80d6ab:	48 ba 41 22 82 00 00 	movabs $0x822241,%rdx
  80d6b2:	00 00 00 
  80d6b5:	be bd 00 00 00       	mov    $0xbd,%esi
  80d6ba:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80d6c1:	00 00 00 
  80d6c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80d6c9:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80d6d0:	00 00 00 
  80d6d3:	ff d1                	callq  *%rcx
      q->tot_len = (u16_t)rem_len;
  80d6d5:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80d6d8:	89 c2                	mov    %eax,%edx
  80d6da:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d6de:	66 89 50 10          	mov    %dx,0x10(%rax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  80d6e2:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80d6e5:	0f b7 c0             	movzwl %ax,%eax
  80d6e8:	ba d0 07 00 00       	mov    $0x7d0,%edx
  80d6ed:	3d d0 07 00 00       	cmp    $0x7d0,%eax
  80d6f2:	0f 4f c2             	cmovg  %edx,%eax
  80d6f5:	89 c2                	mov    %eax,%edx
  80d6f7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d6fb:	66 89 50 12          	mov    %dx,0x12(%rax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  80d6ff:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d703:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80d707:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d70b:	48 89 50 08          	mov    %rdx,0x8(%rax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  80d70f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d713:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d717:	83 e0 03             	and    $0x3,%eax
  80d71a:	48 85 c0             	test   %rax,%rax
  80d71d:	74 2a                	je     80d749 <pbuf_alloc+0x2dd>
  80d71f:	48 ba 58 22 82 00 00 	movabs $0x822258,%rdx
  80d726:	00 00 00 
  80d729:	be c3 00 00 00       	mov    $0xc3,%esi
  80d72e:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80d735:	00 00 00 
  80d738:	b8 00 00 00 00       	mov    $0x0,%eax
  80d73d:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80d744:	00 00 00 
  80d747:	ff d1                	callq  *%rcx
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80d749:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d74d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80d751:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d755:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d759:	0f b7 c0             	movzwl %ax,%eax
  80d75c:	48 01 c2             	add    %rax,%rdx
  80d75f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d763:	48 05 e8 07 00 00    	add    $0x7e8,%rax
  80d769:	48 39 c2             	cmp    %rax,%rdx
  80d76c:	76 2a                	jbe    80d798 <pbuf_alloc+0x32c>
  80d76e:	48 ba 10 22 82 00 00 	movabs $0x822210,%rdx
  80d775:	00 00 00 
  80d778:	be c6 00 00 00       	mov    $0xc6,%esi
  80d77d:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80d784:	00 00 00 
  80d787:	b8 00 00 00 00       	mov    $0x0,%eax
  80d78c:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80d793:	00 00 00 
  80d796:	ff d1                	callq  *%rcx
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  80d798:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d79c:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  80d7a2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d7a6:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d7aa:	0f b7 c0             	movzwl %ax,%eax
  80d7ad:	29 45 e8             	sub    %eax,-0x18(%rbp)
      /* remember this pbuf for linkage in next iteration */
      r = q;
  80d7b0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d7b4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  80d7b8:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80d7bc:	0f 8f 7d fe ff ff    	jg     80d63f <pbuf_alloc+0x1d3>
      r = q;
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
  80d7c2:	e9 60 01 00 00       	jmpq   80d927 <pbuf_alloc+0x4bb>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  80d7c7:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d7cb:	83 c0 1b             	add    $0x1b,%eax
  80d7ce:	83 e0 fc             	and    $0xfffffffc,%eax
  80d7d1:	89 c2                	mov    %eax,%edx
  80d7d3:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  80d7d7:	83 c0 03             	add    $0x3,%eax
  80d7da:	83 e0 fc             	and    $0xfffffffc,%eax
  80d7dd:	01 d0                	add    %edx,%eax
  80d7df:	89 c7                	mov    %eax,%edi
  80d7e1:	48 b8 95 c9 80 00 00 	movabs $0x80c995,%rax
  80d7e8:	00 00 00 
  80d7eb:	ff d0                	callq  *%rax
  80d7ed:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (p == NULL) {
  80d7f1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d7f6:	75 0a                	jne    80d802 <pbuf_alloc+0x396>
      return NULL;
  80d7f8:	b8 00 00 00 00       	mov    $0x0,%eax
  80d7fd:	e9 3b 01 00 00       	jmpq   80d93d <pbuf_alloc+0x4d1>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  80d802:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d806:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80d80a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d80e:	48 01 d0             	add    %rdx,%rax
  80d811:	48 83 c0 03          	add    $0x3,%rax
  80d815:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80d819:	48 89 c2             	mov    %rax,%rdx
  80d81c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d820:	48 89 50 08          	mov    %rdx,0x8(%rax)
    p->len = p->tot_len = length;
  80d824:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d828:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d82c:	66 89 50 10          	mov    %dx,0x10(%rax)
  80d830:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d834:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d838:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d83c:	66 89 50 12          	mov    %dx,0x12(%rax)
    p->next = NULL;
  80d840:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d844:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    p->type = type;
  80d84b:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d84e:	89 c2                	mov    %eax,%edx
  80d850:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d854:	88 50 14             	mov    %dl,0x14(%rax)

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
  80d857:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d85b:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d85f:	83 e0 03             	and    $0x3,%eax
  80d862:	48 85 c0             	test   %rax,%rax
  80d865:	0f 84 bb 00 00 00    	je     80d926 <pbuf_alloc+0x4ba>
  80d86b:	48 ba 88 22 82 00 00 	movabs $0x822288,%rdx
  80d872:	00 00 00 
  80d875:	be de 00 00 00       	mov    $0xde,%esi
  80d87a:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80d881:	00 00 00 
  80d884:	b8 00 00 00 00       	mov    $0x0,%eax
  80d889:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80d890:	00 00 00 
  80d893:	ff d1                	callq  *%rcx
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  80d895:	bf 0c 00 00 00       	mov    $0xc,%edi
  80d89a:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  80d8a1:	00 00 00 
  80d8a4:	ff d0                	callq  *%rax
  80d8a6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (p == NULL) {
  80d8aa:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d8af:	75 0a                	jne    80d8bb <pbuf_alloc+0x44f>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
  80d8b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80d8b6:	e9 82 00 00 00       	jmpq   80d93d <pbuf_alloc+0x4d1>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  80d8bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d8bf:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80d8c6:	00 
    p->len = p->tot_len = length;
  80d8c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d8cb:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d8cf:	66 89 50 10          	mov    %dx,0x10(%rax)
  80d8d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d8d7:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d8db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d8df:	66 89 50 12          	mov    %dx,0x12(%rax)
    p->next = NULL;
  80d8e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d8e7:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    p->type = type;
  80d8ee:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d8f1:	89 c2                	mov    %eax,%edx
  80d8f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d8f7:	88 50 14             	mov    %dl,0x14(%rax)
    break;
  80d8fa:	eb 2b                	jmp    80d927 <pbuf_alloc+0x4bb>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  80d8fc:	48 ba b3 22 82 00 00 	movabs $0x8222b3,%rdx
  80d903:	00 00 00 
  80d906:	be f2 00 00 00       	mov    $0xf2,%esi
  80d90b:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80d912:	00 00 00 
  80d915:	b8 00 00 00 00       	mov    $0x0,%eax
  80d91a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80d921:	00 00 00 
  80d924:	ff d1                	callq  *%rcx
    p->next = NULL;
    p->type = type;

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
  80d926:	90                   	nop
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  80d927:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d92b:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)
  /* set flags */
  p->flags = 0;
  80d931:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d935:	c6 40 15 00          	movb   $0x0,0x15(%rax)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
  80d939:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80d93d:	c9                   	leaveq 
  80d93e:	c3                   	retq   

000000000080d93f <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  80d93f:	55                   	push   %rbp
  80d940:	48 89 e5             	mov    %rsp,%rbp
  80d943:	48 83 ec 20          	sub    $0x20,%rsp
  80d947:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80d94b:	89 f0                	mov    %esi,%eax
  80d94d:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  80d951:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d956:	75 2a                	jne    80d982 <pbuf_realloc+0x43>
  80d958:	48 ba ce 22 82 00 00 	movabs $0x8222ce,%rdx
  80d95f:	00 00 00 
  80d962:	be 14 01 00 00       	mov    $0x114,%esi
  80d967:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80d96e:	00 00 00 
  80d971:	b8 00 00 00 00       	mov    $0x0,%eax
  80d976:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80d97d:	00 00 00 
  80d980:	ff d1                	callq  *%rcx
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  80d982:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d986:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d98a:	3c 03                	cmp    $0x3,%al
  80d98c:	74 4e                	je     80d9dc <pbuf_realloc+0x9d>
  80d98e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d992:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d996:	3c 01                	cmp    $0x1,%al
  80d998:	74 42                	je     80d9dc <pbuf_realloc+0x9d>
  80d99a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d99e:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d9a2:	84 c0                	test   %al,%al
  80d9a4:	74 36                	je     80d9dc <pbuf_realloc+0x9d>
  80d9a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d9aa:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d9ae:	3c 02                	cmp    $0x2,%al
  80d9b0:	74 2a                	je     80d9dc <pbuf_realloc+0x9d>
  80d9b2:	48 ba e6 22 82 00 00 	movabs $0x8222e6,%rdx
  80d9b9:	00 00 00 
  80d9bc:	be 18 01 00 00       	mov    $0x118,%esi
  80d9c1:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80d9c8:	00 00 00 
  80d9cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80d9d0:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80d9d7:	00 00 00 
  80d9da:	ff d1                	callq  *%rcx
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  80d9dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d9e0:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d9e4:	66 3b 45 e4          	cmp    -0x1c(%rbp),%ax
  80d9e8:	0f 86 99 01 00 00    	jbe    80db87 <pbuf_realloc+0x248>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  80d9ee:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  80d9f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d9f6:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d9fa:	0f b7 c0             	movzwl %ax,%eax
  80d9fd:	29 c2                	sub    %eax,%edx
  80d9ff:	89 d0                	mov    %edx,%eax
  80da01:	89 45 f0             	mov    %eax,-0x10(%rbp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  80da04:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80da08:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  q = p;
  80da0c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80da10:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  80da14:	e9 90 00 00 00       	jmpq   80daa9 <pbuf_realloc+0x16a>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  80da19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da1d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80da21:	66 29 45 f6          	sub    %ax,-0xa(%rbp)
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  80da25:	81 7d f0 fe ff 00 00 	cmpl   $0xfffe,-0x10(%rbp)
  80da2c:	7e 2a                	jle    80da58 <pbuf_realloc+0x119>
  80da2e:	48 ba 01 23 82 00 00 	movabs $0x822301,%rdx
  80da35:	00 00 00 
  80da38:	be 2c 01 00 00       	mov    $0x12c,%esi
  80da3d:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80da44:	00 00 00 
  80da47:	b8 00 00 00 00       	mov    $0x0,%eax
  80da4c:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80da53:	00 00 00 
  80da56:	ff d1                	callq  *%rcx
    q->tot_len += (u16_t)grow;
  80da58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da5c:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80da60:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80da63:	01 c2                	add    %eax,%edx
  80da65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da69:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* proceed to next pbuf in chain */
    q = q->next;
  80da6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da71:	48 8b 00             	mov    (%rax),%rax
  80da74:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  80da78:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80da7d:	75 2a                	jne    80daa9 <pbuf_realloc+0x16a>
  80da7f:	48 ba 12 23 82 00 00 	movabs $0x822312,%rdx
  80da86:	00 00 00 
  80da89:	be 30 01 00 00       	mov    $0x130,%esi
  80da8e:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80da95:	00 00 00 
  80da98:	b8 00 00 00 00       	mov    $0x0,%eax
  80da9d:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80daa4:	00 00 00 
  80daa7:	ff d1                	callq  *%rcx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  80daa9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80daad:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dab1:	66 3b 45 f6          	cmp    -0xa(%rbp),%ax
  80dab5:	0f 82 5e ff ff ff    	jb     80da19 <pbuf_realloc+0xda>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  80dabb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dabf:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80dac3:	84 c0                	test   %al,%al
  80dac5:	75 75                	jne    80db3c <pbuf_realloc+0x1fd>
  80dac7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dacb:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dacf:	66 3b 45 f6          	cmp    -0xa(%rbp),%ax
  80dad3:	74 67                	je     80db3c <pbuf_realloc+0x1fd>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  80dad5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dad9:	48 8b 40 08          	mov    0x8(%rax),%rax
  80dadd:	48 89 c2             	mov    %rax,%rdx
  80dae0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dae4:	48 29 c2             	sub    %rax,%rdx
  80dae7:	48 89 d0             	mov    %rdx,%rax
  80daea:	89 c2                	mov    %eax,%edx
  80daec:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80daf0:	01 c2                	add    %eax,%edx
  80daf2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80daf6:	89 d6                	mov    %edx,%esi
  80daf8:	48 89 c7             	mov    %rax,%rdi
  80dafb:	48 b8 7f c6 80 00 00 	movabs $0x80c67f,%rax
  80db02:	00 00 00 
  80db05:	ff d0                	callq  *%rax
  80db07:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  80db0b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80db10:	75 2a                	jne    80db3c <pbuf_realloc+0x1fd>
  80db12:	48 ba 2a 23 82 00 00 	movabs $0x82232a,%rdx
  80db19:	00 00 00 
  80db1c:	be 3a 01 00 00       	mov    $0x13a,%esi
  80db21:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80db28:	00 00 00 
  80db2b:	b8 00 00 00 00       	mov    $0x0,%eax
  80db30:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80db37:	00 00 00 
  80db3a:	ff d1                	callq  *%rcx
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  80db3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db40:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80db44:	66 89 50 12          	mov    %dx,0x12(%rax)
  q->tot_len = q->len;
  80db48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db4c:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80db50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db54:	66 89 50 10          	mov    %dx,0x10(%rax)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  80db58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db5c:	48 8b 00             	mov    (%rax),%rax
  80db5f:	48 85 c0             	test   %rax,%rax
  80db62:	74 16                	je     80db7a <pbuf_realloc+0x23b>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  80db64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db68:	48 8b 00             	mov    (%rax),%rax
  80db6b:	48 89 c7             	mov    %rax,%rdi
  80db6e:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  80db75:	00 00 00 
  80db78:	ff d0                	callq  *%rax
  }
  /* q is last packet in chain */
  q->next = NULL;
  80db7a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db7e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  80db85:	eb 01                	jmp    80db88 <pbuf_realloc+0x249>
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    /* enlarging not yet supported */
    return;
  80db87:	90                   	nop
    pbuf_free(q->next);
  }
  /* q is last packet in chain */
  q->next = NULL;

}
  80db88:	c9                   	leaveq 
  80db89:	c3                   	retq   

000000000080db8a <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  80db8a:	55                   	push   %rbp
  80db8b:	48 89 e5             	mov    %rsp,%rbp
  80db8e:	48 83 ec 20          	sub    $0x20,%rsp
  80db92:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80db96:	89 f0                	mov    %esi,%eax
  80db98:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  80db9c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80dba1:	75 2a                	jne    80dbcd <pbuf_header+0x43>
  80dba3:	48 ba 45 23 82 00 00 	movabs $0x822345,%rdx
  80dbaa:	00 00 00 
  80dbad:	be 65 01 00 00       	mov    $0x165,%esi
  80dbb2:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80dbb9:	00 00 00 
  80dbbc:	b8 00 00 00 00       	mov    $0x0,%eax
  80dbc1:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80dbc8:	00 00 00 
  80dbcb:	ff d1                	callq  *%rcx
  if ((header_size_increment == 0) || (p == NULL))
  80dbcd:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80dbd2:	74 07                	je     80dbdb <pbuf_header+0x51>
  80dbd4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80dbd9:	75 0a                	jne    80dbe5 <pbuf_header+0x5b>
    return 0;
  80dbdb:	b8 00 00 00 00       	mov    $0x0,%eax
  80dbe0:	e9 66 01 00 00       	jmpq   80dd4b <pbuf_header+0x1c1>
 
  if (header_size_increment < 0){
  80dbe5:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80dbea:	79 42                	jns    80dc2e <pbuf_header+0xa4>
    increment_magnitude = -header_size_increment;
  80dbec:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80dbf0:	f7 d8                	neg    %eax
  80dbf2:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  80dbf6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dbfa:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dbfe:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80dc02:	73 32                	jae    80dc36 <pbuf_header+0xac>
  80dc04:	48 ba 4f 23 82 00 00 	movabs $0x82234f,%rdx
  80dc0b:	00 00 00 
  80dc0e:	be 6c 01 00 00       	mov    $0x16c,%esi
  80dc13:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80dc1a:	00 00 00 
  80dc1d:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc22:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80dc29:	00 00 00 
  80dc2c:	ff d1                	callq  *%rcx
  } else {
    increment_magnitude = header_size_increment;
  80dc2e:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80dc32:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  80dc36:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dc3a:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80dc3e:	0f b6 c0             	movzbl %al,%eax
  80dc41:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  /* remember current payload pointer */
  payload = p->payload;
  80dc45:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dc49:	48 8b 40 08          	mov    0x8(%rax),%rax
  80dc4d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  80dc51:	66 83 7d fc 00       	cmpw   $0x0,-0x4(%rbp)
  80dc56:	74 07                	je     80dc5f <pbuf_header+0xd5>
  80dc58:	66 83 7d fc 03       	cmpw   $0x3,-0x4(%rbp)
  80dc5d:	75 4a                	jne    80dca9 <pbuf_header+0x11f>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  80dc5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dc63:	48 8b 40 08          	mov    0x8(%rax),%rax
  80dc67:	48 0f bf 55 e4       	movswq -0x1c(%rbp),%rdx
  80dc6c:	48 f7 da             	neg    %rdx
  80dc6f:	48 01 c2             	add    %rax,%rdx
  80dc72:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dc76:	48 89 50 08          	mov    %rdx,0x8(%rax)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  80dc7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dc7e:	48 8b 40 08          	mov    0x8(%rax),%rax
  80dc82:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80dc86:	48 83 c2 18          	add    $0x18,%rdx
  80dc8a:	48 39 d0             	cmp    %rdx,%rax
  80dc8d:	0f 83 87 00 00 00    	jae    80dd1a <pbuf_header+0x190>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  80dc93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dc97:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80dc9b:	48 89 50 08          	mov    %rdx,0x8(%rax)
      /* bail out unsuccesfully */
      return 1;
  80dc9f:	b8 01 00 00 00       	mov    $0x1,%eax
  80dca4:	e9 a2 00 00 00       	jmpq   80dd4b <pbuf_header+0x1c1>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  80dca9:	66 83 7d fc 02       	cmpw   $0x2,-0x4(%rbp)
  80dcae:	74 07                	je     80dcb7 <pbuf_header+0x12d>
  80dcb0:	66 83 7d fc 01       	cmpw   $0x1,-0x4(%rbp)
  80dcb5:	75 39                	jne    80dcf0 <pbuf_header+0x166>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  80dcb7:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80dcbc:	79 2b                	jns    80dce9 <pbuf_header+0x15f>
  80dcbe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dcc2:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dcc6:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80dcca:	72 1d                	jb     80dce9 <pbuf_header+0x15f>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  80dccc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dcd0:	48 8b 40 08          	mov    0x8(%rax),%rax
  80dcd4:	48 0f bf 55 e4       	movswq -0x1c(%rbp),%rdx
  80dcd9:	48 f7 da             	neg    %rdx
  80dcdc:	48 01 c2             	add    %rax,%rdx
  80dcdf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dce3:	48 89 50 08          	mov    %rdx,0x8(%rax)
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  80dce7:	eb 31                	jmp    80dd1a <pbuf_header+0x190>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  80dce9:	b8 01 00 00 00       	mov    $0x1,%eax
  80dcee:	eb 5b                	jmp    80dd4b <pbuf_header+0x1c1>
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  80dcf0:	48 ba 6d 23 82 00 00 	movabs $0x82236d,%rdx
  80dcf7:	00 00 00 
  80dcfa:	be 9b 01 00 00       	mov    $0x19b,%esi
  80dcff:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80dd06:	00 00 00 
  80dd09:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd0e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80dd15:	00 00 00 
  80dd18:	ff d1                	callq  *%rcx
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  80dd1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd1e:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80dd22:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80dd26:	01 c2                	add    %eax,%edx
  80dd28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd2c:	66 89 50 12          	mov    %dx,0x12(%rax)
  p->tot_len += header_size_increment;
  80dd30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd34:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80dd38:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80dd3c:	01 c2                	add    %eax,%edx
  80dd3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd42:	66 89 50 10          	mov    %dx,0x10(%rax)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  80dd46:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80dd4b:	c9                   	leaveq 
  80dd4c:	c3                   	retq   

000000000080dd4d <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  80dd4d:	55                   	push   %rbp
  80dd4e:	48 89 e5             	mov    %rsp,%rbp
  80dd51:	48 83 ec 30          	sub    $0x30,%rsp
  80dd55:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  80dd59:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80dd5e:	75 3b                	jne    80dd9b <pbuf_free+0x4e>
    LWIP_ASSERT("p != NULL", p != NULL);
  80dd60:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80dd65:	75 2a                	jne    80dd91 <pbuf_free+0x44>
  80dd67:	48 ba 45 23 82 00 00 	movabs $0x822345,%rdx
  80dd6e:	00 00 00 
  80dd71:	be d1 01 00 00       	mov    $0x1d1,%esi
  80dd76:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80dd7d:	00 00 00 
  80dd80:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd85:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80dd8c:	00 00 00 
  80dd8f:	ff d1                	callq  *%rcx
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_free(p == NULL) was called.\n"));
    return 0;
  80dd91:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd96:	e9 65 01 00 00       	jmpq   80df00 <pbuf_free+0x1b3>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  80dd9b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd9f:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80dda3:	84 c0                	test   %al,%al
  80dda5:	74 4e                	je     80ddf5 <pbuf_free+0xa8>
  80dda7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80ddab:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80ddaf:	3c 01                	cmp    $0x1,%al
  80ddb1:	74 42                	je     80ddf5 <pbuf_free+0xa8>
  80ddb3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80ddb7:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80ddbb:	3c 02                	cmp    $0x2,%al
  80ddbd:	74 36                	je     80ddf5 <pbuf_free+0xa8>
  80ddbf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80ddc3:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80ddc7:	3c 03                	cmp    $0x3,%al
  80ddc9:	74 2a                	je     80ddf5 <pbuf_free+0xa8>
  80ddcb:	48 ba 7b 23 82 00 00 	movabs $0x82237b,%rdx
  80ddd2:	00 00 00 
  80ddd5:	be dc 01 00 00       	mov    $0x1dc,%esi
  80ddda:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80dde1:	00 00 00 
  80dde4:	b8 00 00 00 00       	mov    $0x0,%eax
  80dde9:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80ddf0:	00 00 00 
  80ddf3:	ff d1                	callq  *%rcx
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  80ddf5:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  80ddf9:	e9 f3 00 00 00       	jmpq   80def1 <pbuf_free+0x1a4>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  80ddfe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de02:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80de06:	66 85 c0             	test   %ax,%ax
  80de09:	75 2a                	jne    80de35 <pbuf_free+0xe8>
  80de0b:	48 ba 90 23 82 00 00 	movabs $0x822390,%rdx
  80de12:	00 00 00 
  80de15:	be e9 01 00 00       	mov    $0x1e9,%esi
  80de1a:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80de21:	00 00 00 
  80de24:	b8 00 00 00 00       	mov    $0x0,%eax
  80de29:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80de30:	00 00 00 
  80de33:	ff d1                	callq  *%rcx
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  80de35:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de39:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80de3d:	8d 50 ff             	lea    -0x1(%rax),%edx
  80de40:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de44:	66 89 50 16          	mov    %dx,0x16(%rax)
  80de48:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de4c:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80de50:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  80de54:	66 83 7d fc 00       	cmpw   $0x0,-0x4(%rbp)
  80de59:	0f 85 8a 00 00 00    	jne    80dee9 <pbuf_free+0x19c>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  80de5f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de63:	48 8b 00             	mov    (%rax),%rax
  80de66:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  80de6a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de6e:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80de72:	0f b6 c0             	movzbl %al,%eax
  80de75:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  80de79:	66 83 7d ee 03       	cmpw   $0x3,-0x12(%rbp)
  80de7e:	75 1a                	jne    80de9a <pbuf_free+0x14d>
        memp_free(MEMP_PBUF_POOL, p);
  80de80:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de84:	48 89 c6             	mov    %rax,%rsi
  80de87:	bf 0d 00 00 00       	mov    $0xd,%edi
  80de8c:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80de93:	00 00 00 
  80de96:	ff d0                	callq  *%rax
  80de98:	eb 3b                	jmp    80ded5 <pbuf_free+0x188>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  80de9a:	66 83 7d ee 01       	cmpw   $0x1,-0x12(%rbp)
  80de9f:	74 07                	je     80dea8 <pbuf_free+0x15b>
  80dea1:	66 83 7d ee 02       	cmpw   $0x2,-0x12(%rbp)
  80dea6:	75 1a                	jne    80dec2 <pbuf_free+0x175>
        memp_free(MEMP_PBUF, p);
  80dea8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80deac:	48 89 c6             	mov    %rax,%rsi
  80deaf:	bf 0c 00 00 00       	mov    $0xc,%edi
  80deb4:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80debb:	00 00 00 
  80debe:	ff d0                	callq  *%rax
  80dec0:	eb 13                	jmp    80ded5 <pbuf_free+0x188>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  80dec2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dec6:	48 89 c7             	mov    %rax,%rdi
  80dec9:	48 b8 f2 c4 80 00 00 	movabs $0x80c4f2,%rax
  80ded0:	00 00 00 
  80ded3:	ff d0                	callq  *%rax
      }
      count++;
  80ded5:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80ded9:	83 c0 01             	add    $0x1,%eax
  80dedc:	88 45 ff             	mov    %al,-0x1(%rbp)
      /* proceed to next pbuf */
      p = q;
  80dedf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dee3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80dee7:	eb 08                	jmp    80def1 <pbuf_free+0x1a4>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
  80dee9:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  80def0:	00 
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  80def1:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80def6:	0f 85 02 ff ff ff    	jne    80ddfe <pbuf_free+0xb1>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
  80defc:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80df00:	c9                   	leaveq 
  80df01:	c3                   	retq   

000000000080df02 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  80df02:	55                   	push   %rbp
  80df03:	48 89 e5             	mov    %rsp,%rbp
  80df06:	48 83 ec 18          	sub    $0x18,%rsp
  80df0a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t len;

  len = 0;
  80df0e:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  while (p != NULL) {
  80df12:	eb 0f                	jmp    80df23 <pbuf_clen+0x21>
    ++len;
  80df14:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
    p = p->next;
  80df18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80df1c:	48 8b 00             	mov    (%rax),%rax
  80df1f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  80df23:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80df28:	75 ea                	jne    80df14 <pbuf_clen+0x12>
    ++len;
    p = p->next;
  }
  return len;
  80df2a:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80df2e:	c9                   	leaveq 
  80df2f:	c3                   	retq   

000000000080df30 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  80df30:	55                   	push   %rbp
  80df31:	48 89 e5             	mov    %rsp,%rbp
  80df34:	48 83 ec 08          	sub    $0x8,%rsp
  80df38:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  80df3c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80df41:	74 13                	je     80df56 <pbuf_ref+0x26>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  80df43:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80df47:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80df4b:	8d 50 01             	lea    0x1(%rax),%edx
  80df4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80df52:	66 89 50 16          	mov    %dx,0x16(%rax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  80df56:	90                   	nop
  80df57:	c9                   	leaveq 
  80df58:	c3                   	retq   

000000000080df59 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  80df59:	55                   	push   %rbp
  80df5a:	48 89 e5             	mov    %rsp,%rbp
  80df5d:	48 83 ec 20          	sub    $0x20,%rsp
  80df61:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80df65:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  80df69:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80df6e:	74 07                	je     80df77 <pbuf_cat+0x1e>
  80df70:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80df75:	75 2a                	jne    80dfa1 <pbuf_cat+0x48>
  80df77:	48 ba a8 23 82 00 00 	movabs $0x8223a8,%rdx
  80df7e:	00 00 00 
  80df81:	be 43 02 00 00       	mov    $0x243,%esi
  80df86:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80df8d:	00 00 00 
  80df90:	b8 00 00 00 00       	mov    $0x0,%eax
  80df95:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80df9c:	00 00 00 
  80df9f:	ff d1                	callq  *%rcx
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  80dfa1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dfa5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80dfa9:	eb 25                	jmp    80dfd0 <pbuf_cat+0x77>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  80dfab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dfaf:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80dfb3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80dfb7:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80dfbb:	01 c2                	add    %eax,%edx
  80dfbd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dfc1:	66 89 50 10          	mov    %dx,0x10(%rax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  80dfc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dfc9:	48 8b 00             	mov    (%rax),%rax
  80dfcc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80dfd0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dfd4:	48 8b 00             	mov    (%rax),%rax
  80dfd7:	48 85 c0             	test   %rax,%rax
  80dfda:	75 cf                	jne    80dfab <pbuf_cat+0x52>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  80dfdc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dfe0:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80dfe4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dfe8:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dfec:	66 39 c2             	cmp    %ax,%dx
  80dfef:	74 2a                	je     80e01b <pbuf_cat+0xc2>
  80dff1:	48 ba e0 23 82 00 00 	movabs $0x8223e0,%rdx
  80dff8:	00 00 00 
  80dffb:	be 4b 02 00 00       	mov    $0x24b,%esi
  80e000:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80e007:	00 00 00 
  80e00a:	b8 00 00 00 00       	mov    $0x0,%eax
  80e00f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e016:	00 00 00 
  80e019:	ff d1                	callq  *%rcx
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  80e01b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e01f:	48 8b 00             	mov    (%rax),%rax
  80e022:	48 85 c0             	test   %rax,%rax
  80e025:	74 2a                	je     80e051 <pbuf_cat+0xf8>
  80e027:	48 ba 0d 24 82 00 00 	movabs $0x82240d,%rdx
  80e02e:	00 00 00 
  80e031:	be 4c 02 00 00       	mov    $0x24c,%esi
  80e036:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80e03d:	00 00 00 
  80e040:	b8 00 00 00 00       	mov    $0x0,%eax
  80e045:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e04c:	00 00 00 
  80e04f:	ff d1                	callq  *%rcx
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  80e051:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e055:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80e059:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e05d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e061:	01 c2                	add    %eax,%edx
  80e063:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e067:	66 89 50 10          	mov    %dx,0x10(%rax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  80e06b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e06f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e073:	48 89 10             	mov    %rdx,(%rax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  80e076:	90                   	nop
  80e077:	c9                   	leaveq 
  80e078:	c3                   	retq   

000000000080e079 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  80e079:	55                   	push   %rbp
  80e07a:	48 89 e5             	mov    %rsp,%rbp
  80e07d:	48 83 ec 10          	sub    $0x10,%rsp
  80e081:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80e085:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pbuf_cat(h, t);
  80e089:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e08d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e091:	48 89 d6             	mov    %rdx,%rsi
  80e094:	48 89 c7             	mov    %rax,%rdi
  80e097:	48 b8 59 df 80 00 00 	movabs $0x80df59,%rax
  80e09e:	00 00 00 
  80e0a1:	ff d0                	callq  *%rax
  /* t is now referenced by h */
  pbuf_ref(t);
  80e0a3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e0a7:	48 89 c7             	mov    %rax,%rdi
  80e0aa:	48 b8 30 df 80 00 00 	movabs $0x80df30,%rax
  80e0b1:	00 00 00 
  80e0b4:	ff d0                	callq  *%rax
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  80e0b6:	90                   	nop
  80e0b7:	c9                   	leaveq 
  80e0b8:	c3                   	retq   

000000000080e0b9 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  80e0b9:	55                   	push   %rbp
  80e0ba:	48 89 e5             	mov    %rsp,%rbp
  80e0bd:	48 83 ec 20          	sub    $0x20,%rsp
  80e0c1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct pbuf *q;
  u8_t tail_gone = 1;
  80e0c5:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  /* tail */
  q = p->next;
  80e0c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e0cd:	48 8b 00             	mov    (%rax),%rax
  80e0d0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  /* pbuf has successor in chain? */
  if (q != NULL) {
  80e0d4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e0d9:	0f 84 9e 00 00 00    	je     80e17d <pbuf_dechain+0xc4>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  80e0df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e0e3:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e0e7:	0f b7 d0             	movzwl %ax,%edx
  80e0ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e0ee:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e0f2:	0f b7 c8             	movzwl %ax,%ecx
  80e0f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e0f9:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e0fd:	0f b7 c0             	movzwl %ax,%eax
  80e100:	29 c1                	sub    %eax,%ecx
  80e102:	89 c8                	mov    %ecx,%eax
  80e104:	39 c2                	cmp    %eax,%edx
  80e106:	74 2a                	je     80e132 <pbuf_dechain+0x79>
  80e108:	48 ba 20 24 82 00 00 	movabs $0x822420,%rdx
  80e10f:	00 00 00 
  80e112:	be 81 02 00 00       	mov    $0x281,%esi
  80e117:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80e11e:	00 00 00 
  80e121:	b8 00 00 00 00       	mov    $0x0,%eax
  80e126:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e12d:	00 00 00 
  80e130:	ff d1                	callq  *%rcx
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  80e132:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e136:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80e13a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e13e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e142:	29 c2                	sub    %eax,%edx
  80e144:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e148:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* decouple pbuf from remainder */
    p->next = NULL;
  80e14c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e150:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  80e157:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e15b:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80e15f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e163:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  80e167:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e16b:	48 89 c7             	mov    %rax,%rdi
  80e16e:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  80e175:	00 00 00 
  80e178:	ff d0                	callq  *%rax
  80e17a:	88 45 ff             	mov    %al,-0x1(%rbp)
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  80e17d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e181:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80e185:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e189:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e18d:	66 39 c2             	cmp    %ax,%dx
  80e190:	74 2a                	je     80e1bc <pbuf_dechain+0x103>
  80e192:	48 ba 42 24 82 00 00 	movabs $0x822442,%rdx
  80e199:	00 00 00 
  80e19c:	be 92 02 00 00       	mov    $0x292,%esi
  80e1a1:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80e1a8:	00 00 00 
  80e1ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80e1b0:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e1b7:	00 00 00 
  80e1ba:	ff d1                	callq  *%rcx
  return ((tail_gone > 0) ? NULL : q);
  80e1bc:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80e1c0:	75 06                	jne    80e1c8 <pbuf_dechain+0x10f>
  80e1c2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e1c6:	eb 05                	jmp    80e1cd <pbuf_dechain+0x114>
  80e1c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80e1cd:	c9                   	leaveq 
  80e1ce:	c3                   	retq   

000000000080e1cf <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  80e1cf:	55                   	push   %rbp
  80e1d0:	48 89 e5             	mov    %rsp,%rbp
  80e1d3:	48 83 ec 20          	sub    $0x20,%rsp
  80e1d7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80e1db:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  u16_t offset_to=0, offset_from=0, len;
  80e1df:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
  80e1e5:	66 c7 45 fc 00 00    	movw   $0x0,-0x4(%rbp)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  80e1eb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e1f0:	74 1c                	je     80e20e <pbuf_copy+0x3f>
  80e1f2:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e1f7:	74 15                	je     80e20e <pbuf_copy+0x3f>
  80e1f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e1fd:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80e201:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e205:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e209:	66 39 c2             	cmp    %ax,%dx
  80e20c:	73 2a                	jae    80e238 <pbuf_copy+0x69>
  80e20e:	48 ba 58 24 82 00 00 	movabs $0x822458,%rdx
  80e215:	00 00 00 
  80e218:	be b2 02 00 00       	mov    $0x2b2,%esi
  80e21d:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80e224:	00 00 00 
  80e227:	b8 00 00 00 00       	mov    $0x0,%eax
  80e22c:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e233:	00 00 00 
  80e236:	ff d1                	callq  *%rcx
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  80e238:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e23d:	75 2a                	jne    80e269 <pbuf_copy+0x9a>
  80e23f:	48 ba 88 24 82 00 00 	movabs $0x822488,%rdx
  80e246:	00 00 00 
  80e249:	be b7 02 00 00       	mov    $0x2b7,%esi
  80e24e:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80e255:	00 00 00 
  80e258:	b8 00 00 00 00       	mov    $0x0,%eax
  80e25d:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e264:	00 00 00 
  80e267:	ff d1                	callq  *%rcx
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  80e269:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e26d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e271:	0f b7 d0             	movzwl %ax,%edx
  80e274:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  80e278:	89 d1                	mov    %edx,%ecx
  80e27a:	29 c1                	sub    %eax,%ecx
  80e27c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e280:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e284:	0f b7 d0             	movzwl %ax,%edx
  80e287:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  80e28b:	29 c2                	sub    %eax,%edx
  80e28d:	89 d0                	mov    %edx,%eax
  80e28f:	39 c1                	cmp    %eax,%ecx
  80e291:	7c 12                	jl     80e2a5 <pbuf_copy+0xd6>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  80e293:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e297:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e29b:	66 2b 45 fc          	sub    -0x4(%rbp),%ax
  80e29f:	66 89 45 fa          	mov    %ax,-0x6(%rbp)
  80e2a3:	eb 10                	jmp    80e2b5 <pbuf_copy+0xe6>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
  80e2a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e2a9:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e2ad:	66 2b 45 fe          	sub    -0x2(%rbp),%ax
  80e2b1:	66 89 45 fa          	mov    %ax,-0x6(%rbp)
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  80e2b5:	0f b7 45 fa          	movzwl -0x6(%rbp),%eax
  80e2b9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e2bd:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80e2c1:	0f b7 55 fc          	movzwl -0x4(%rbp),%edx
  80e2c5:	48 8d 34 11          	lea    (%rcx,%rdx,1),%rsi
  80e2c9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80e2cd:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80e2d1:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  80e2d5:	48 01 d1             	add    %rdx,%rcx
  80e2d8:	48 89 c2             	mov    %rax,%rdx
  80e2db:	48 89 cf             	mov    %rcx,%rdi
  80e2de:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  80e2e5:	00 00 00 
  80e2e8:	ff d0                	callq  *%rax
    offset_to += len;
  80e2ea:	0f b7 45 fa          	movzwl -0x6(%rbp),%eax
  80e2ee:	66 01 45 fe          	add    %ax,-0x2(%rbp)
    offset_from += len;
  80e2f2:	0f b7 45 fa          	movzwl -0x6(%rbp),%eax
  80e2f6:	66 01 45 fc          	add    %ax,-0x4(%rbp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  80e2fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e2fe:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e302:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80e306:	73 2a                	jae    80e332 <pbuf_copy+0x163>
  80e308:	48 ba 95 24 82 00 00 	movabs $0x822495,%rdx
  80e30f:	00 00 00 
  80e312:	be c3 02 00 00       	mov    $0x2c3,%esi
  80e317:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80e31e:	00 00 00 
  80e321:	b8 00 00 00 00       	mov    $0x0,%eax
  80e326:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e32d:	00 00 00 
  80e330:	ff d1                	callq  *%rcx
    if (offset_to == p_to->len) {
  80e332:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e336:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e33a:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80e33e:	75 11                	jne    80e351 <pbuf_copy+0x182>
      /* on to next p_to (if any) */
      offset_to = 0;
  80e340:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
      p_to = p_to->next;
  80e346:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e34a:	48 8b 00             	mov    (%rax),%rax
  80e34d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  80e351:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e355:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e359:	66 3b 45 fc          	cmp    -0x4(%rbp),%ax
  80e35d:	73 2a                	jae    80e389 <pbuf_copy+0x1ba>
  80e35f:	48 ba ac 24 82 00 00 	movabs $0x8224ac,%rdx
  80e366:	00 00 00 
  80e369:	be c9 02 00 00       	mov    $0x2c9,%esi
  80e36e:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80e375:	00 00 00 
  80e378:	b8 00 00 00 00       	mov    $0x0,%eax
  80e37d:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e384:	00 00 00 
  80e387:	ff d1                	callq  *%rcx
    if (offset_from >= p_from->len) {
  80e389:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e38d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e391:	66 3b 45 fc          	cmp    -0x4(%rbp),%ax
  80e395:	77 11                	ja     80e3a8 <pbuf_copy+0x1d9>
      /* on to next p_from (if any) */
      offset_from = 0;
  80e397:	66 c7 45 fc 00 00    	movw   $0x0,-0x4(%rbp)
      p_from = p_from->next;
  80e39d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e3a1:	48 8b 00             	mov    (%rax),%rax
  80e3a4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  80e3a8:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e3ad:	74 4b                	je     80e3fa <pbuf_copy+0x22b>
  80e3af:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e3b3:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80e3b7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e3bb:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e3bf:	66 39 c2             	cmp    %ax,%dx
  80e3c2:	75 36                	jne    80e3fa <pbuf_copy+0x22b>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80e3c4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e3c8:	48 8b 00             	mov    (%rax),%rax
  80e3cb:	48 85 c0             	test   %rax,%rax
  80e3ce:	74 2a                	je     80e3fa <pbuf_copy+0x22b>
  80e3d0:	48 ba c8 24 82 00 00 	movabs $0x8224c8,%rdx
  80e3d7:	00 00 00 
  80e3da:	be d3 02 00 00       	mov    $0x2d3,%esi
  80e3df:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80e3e6:	00 00 00 
  80e3e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80e3ee:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e3f5:	00 00 00 
  80e3f8:	ff d1                	callq  *%rcx
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  80e3fa:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e3ff:	74 4b                	je     80e44c <pbuf_copy+0x27d>
  80e401:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e405:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80e409:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e40d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e411:	66 39 c2             	cmp    %ax,%dx
  80e414:	75 36                	jne    80e44c <pbuf_copy+0x27d>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80e416:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e41a:	48 8b 00             	mov    (%rax),%rax
  80e41d:	48 85 c0             	test   %rax,%rax
  80e420:	74 2a                	je     80e44c <pbuf_copy+0x27d>
  80e422:	48 ba c8 24 82 00 00 	movabs $0x8224c8,%rdx
  80e429:	00 00 00 
  80e42c:	be d8 02 00 00       	mov    $0x2d8,%esi
  80e431:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80e438:	00 00 00 
  80e43b:	b8 00 00 00 00       	mov    $0x0,%eax
  80e440:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e447:	00 00 00 
  80e44a:	ff d1                	callq  *%rcx
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  80e44c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e451:	0f 85 e1 fd ff ff    	jne    80e238 <pbuf_copy+0x69>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
  80e457:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80e45c:	c9                   	leaveq 
  80e45d:	c3                   	retq   

000000000080e45e <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  80e45e:	55                   	push   %rbp
  80e45f:	48 89 e5             	mov    %rsp,%rbp
  80e462:	48 83 ec 30          	sub    $0x30,%rsp
  80e466:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80e46a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80e46e:	89 c8                	mov    %ecx,%eax
  80e470:	66 89 55 dc          	mov    %dx,-0x24(%rbp)
  80e474:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
  80e478:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%rbp)

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  80e47e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e483:	75 2a                	jne    80e4af <pbuf_copy_partial+0x51>
  80e485:	48 ba f8 24 82 00 00 	movabs $0x8224f8,%rdx
  80e48c:	00 00 00 
  80e48f:	be f0 02 00 00       	mov    $0x2f0,%esi
  80e494:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80e49b:	00 00 00 
  80e49e:	b8 00 00 00 00       	mov    $0x0,%eax
  80e4a3:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e4aa:	00 00 00 
  80e4ad:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  80e4af:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e4b4:	75 2a                	jne    80e4e0 <pbuf_copy_partial+0x82>
  80e4b6:	48 ba 20 25 82 00 00 	movabs $0x822520,%rdx
  80e4bd:	00 00 00 
  80e4c0:	be f1 02 00 00       	mov    $0x2f1,%esi
  80e4c5:	48 bf cb 21 82 00 00 	movabs $0x8221cb,%rdi
  80e4cc:	00 00 00 
  80e4cf:	b8 00 00 00 00       	mov    $0x0,%eax
  80e4d4:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e4db:	00 00 00 
  80e4de:	ff d1                	callq  *%rcx

  left = 0;
  80e4e0:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)

  if((buf == NULL) || (dataptr == NULL)) {
  80e4e6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e4eb:	74 07                	je     80e4f4 <pbuf_copy_partial+0x96>
  80e4ed:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e4f2:	75 0a                	jne    80e4fe <pbuf_copy_partial+0xa0>
    return 0;
  80e4f4:	b8 00 00 00 00       	mov    $0x0,%eax
  80e4f9:	e9 c2 00 00 00       	jmpq   80e5c0 <pbuf_copy_partial+0x162>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80e4fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e502:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e506:	e9 9f 00 00 00       	jmpq   80e5aa <pbuf_copy_partial+0x14c>
    if ((offset != 0) && (offset >= p->len)) {
  80e50b:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%rbp)
  80e510:	74 1c                	je     80e52e <pbuf_copy_partial+0xd0>
  80e512:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e516:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e51a:	66 3b 45 d8          	cmp    -0x28(%rbp),%ax
  80e51e:	77 0e                	ja     80e52e <pbuf_copy_partial+0xd0>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  80e520:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e524:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e528:	66 29 45 d8          	sub    %ax,-0x28(%rbp)
  80e52c:	eb 71                	jmp    80e59f <pbuf_copy_partial+0x141>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  80e52e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e532:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e536:	66 2b 45 d8          	sub    -0x28(%rbp),%ax
  80e53a:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
      if (buf_copy_len > len)
  80e53e:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e542:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80e546:	76 08                	jbe    80e550 <pbuf_copy_partial+0xf2>
          buf_copy_len = len;
  80e548:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  80e54c:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  80e550:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e554:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80e558:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80e55c:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80e560:	48 8d 34 11          	lea    (%rcx,%rdx,1),%rsi
  80e564:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  80e568:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e56c:	48 01 d1             	add    %rdx,%rcx
  80e56f:	48 89 c2             	mov    %rax,%rdx
  80e572:	48 89 cf             	mov    %rcx,%rdi
  80e575:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  80e57c:	00 00 00 
  80e57f:	ff d0                	callq  *%rax
      copied_total += buf_copy_len;
  80e581:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e585:	66 01 45 f2          	add    %ax,-0xe(%rbp)
      left += buf_copy_len;
  80e589:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e58d:	66 01 45 f6          	add    %ax,-0xa(%rbp)
      len -= buf_copy_len;
  80e591:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e595:	66 29 45 dc          	sub    %ax,-0x24(%rbp)
      offset = 0;
  80e599:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%rbp)
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80e59f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e5a3:	48 8b 00             	mov    (%rax),%rax
  80e5a6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e5aa:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  80e5af:	74 0b                	je     80e5bc <pbuf_copy_partial+0x15e>
  80e5b1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80e5b6:	0f 85 4f ff ff ff    	jne    80e50b <pbuf_copy_partial+0xad>
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
  80e5bc:	0f b7 45 f2          	movzwl -0xe(%rbp),%eax
}
  80e5c0:	c9                   	leaveq 
  80e5c1:	c3                   	retq   

000000000080e5c2 <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  80e5c2:	55                   	push   %rbp
  80e5c3:	48 89 e5             	mov    %rsp,%rbp
  80e5c6:	48 83 ec 40          	sub    $0x40,%rsp
  80e5ca:	89 7d cc             	mov    %edi,-0x34(%rbp)
  80e5cd:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  80e5d1:	48 b8 9b 89 81 00 00 	movabs $0x81899b,%rax
  80e5d8:	00 00 00 
  80e5db:	ff d0                	callq  *%rax
  80e5dd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if (!timeouts || !timeouts->next) {
  80e5e1:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e5e6:	74 0c                	je     80e5f4 <sys_mbox_fetch+0x32>
  80e5e8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e5ec:	48 8b 00             	mov    (%rax),%rax
  80e5ef:	48 85 c0             	test   %rax,%rax
  80e5f2:	75 25                	jne    80e619 <sys_mbox_fetch+0x57>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  80e5f4:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80e5f8:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e5fb:	ba 00 00 00 00       	mov    $0x0,%edx
  80e600:	48 89 ce             	mov    %rcx,%rsi
  80e603:	89 c7                	mov    %eax,%edi
  80e605:	48 b8 a6 84 81 00 00 	movabs $0x8184a6,%rax
  80e60c:	00 00 00 
  80e60f:	ff d0                	callq  *%rax
  80e611:	89 45 fc             	mov    %eax,-0x4(%rbp)
      } else {
        timeouts->next->time = 0;
      }
    }
  }
}
  80e614:	e9 e0 00 00 00       	jmpq   80e6f9 <sys_mbox_fetch+0x137>
  if (!timeouts || !timeouts->next) {
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  80e619:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e61d:	48 8b 00             	mov    (%rax),%rax
  80e620:	8b 40 08             	mov    0x8(%rax),%eax
  80e623:	85 c0                	test   %eax,%eax
  80e625:	74 27                	je     80e64e <sys_mbox_fetch+0x8c>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  80e627:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e62b:	48 8b 00             	mov    (%rax),%rax
  80e62e:	8b 50 08             	mov    0x8(%rax),%edx
  80e631:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80e635:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e638:	48 89 ce             	mov    %rcx,%rsi
  80e63b:	89 c7                	mov    %eax,%edi
  80e63d:	48 b8 a6 84 81 00 00 	movabs $0x8184a6,%rax
  80e644:	00 00 00 
  80e647:	ff d0                	callq  *%rax
  80e649:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80e64c:	eb 07                	jmp    80e655 <sys_mbox_fetch+0x93>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
  80e64e:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80e655:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80e659:	75 68                	jne    80e6c3 <sys_mbox_fetch+0x101>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80e65b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e65f:	48 8b 00             	mov    (%rax),%rax
  80e662:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      timeouts->next = tmptimeout->next;
  80e666:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e66a:	48 8b 10             	mov    (%rax),%rdx
  80e66d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e671:	48 89 10             	mov    %rdx,(%rax)
      h   = tmptimeout->h;
  80e674:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e678:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e67c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      arg = tmptimeout->arg;
  80e680:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e684:	48 8b 40 18          	mov    0x18(%rax),%rax
  80e688:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80e68c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e690:	48 89 c6             	mov    %rax,%rsi
  80e693:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e698:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80e69f:	00 00 00 
  80e6a2:	ff d0                	callq  *%rax
      if (h != NULL) {
  80e6a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e6a8:	48 85 c0             	test   %rax,%rax
  80e6ab:	0f 84 20 ff ff ff    	je     80e5d1 <sys_mbox_fetch+0xf>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  80e6b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e6b5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e6b9:	48 89 d7             	mov    %rdx,%rdi
  80e6bc:	ff d0                	callq  *%rax
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80e6be:	e9 0e ff ff ff       	jmpq   80e5d1 <sys_mbox_fetch+0xf>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  80e6c3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e6c7:	48 8b 00             	mov    (%rax),%rax
  80e6ca:	8b 40 08             	mov    0x8(%rax),%eax
  80e6cd:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80e6d0:	76 19                	jbe    80e6eb <sys_mbox_fetch+0x129>
        timeouts->next->time -= time_needed;
  80e6d2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e6d6:	48 8b 00             	mov    (%rax),%rax
  80e6d9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e6dd:	48 8b 12             	mov    (%rdx),%rdx
  80e6e0:	8b 52 08             	mov    0x8(%rdx),%edx
  80e6e3:	2b 55 fc             	sub    -0x4(%rbp),%edx
  80e6e6:	89 50 08             	mov    %edx,0x8(%rax)
      } else {
        timeouts->next->time = 0;
      }
    }
  }
}
  80e6e9:	eb 0e                	jmp    80e6f9 <sys_mbox_fetch+0x137>
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
        timeouts->next->time -= time_needed;
      } else {
        timeouts->next->time = 0;
  80e6eb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e6ef:	48 8b 00             	mov    (%rax),%rax
  80e6f2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      }
    }
  }
}
  80e6f9:	90                   	nop
  80e6fa:	c9                   	leaveq 
  80e6fb:	c3                   	retq   

000000000080e6fc <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  80e6fc:	55                   	push   %rbp
  80e6fd:	48 89 e5             	mov    %rsp,%rbp
  80e700:	48 83 ec 40          	sub    $0x40,%rsp
  80e704:	89 7d cc             	mov    %edi,-0x34(%rbp)
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  80e707:	48 b8 9b 89 81 00 00 	movabs $0x81899b,%rax
  80e70e:	00 00 00 
  80e711:	ff d0                	callq  *%rax
  80e713:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if (!timeouts || !timeouts->next) {
  80e717:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e71c:	74 0c                	je     80e72a <sys_sem_wait+0x2e>
  80e71e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e722:	48 8b 00             	mov    (%rax),%rax
  80e725:	48 85 c0             	test   %rax,%rax
  80e728:	75 1b                	jne    80e745 <sys_sem_wait+0x49>
    sys_arch_sem_wait(sem, 0);
  80e72a:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e72d:	be 00 00 00 00       	mov    $0x0,%esi
  80e732:	89 c7                	mov    %eax,%edi
  80e734:	48 b8 6f 82 81 00 00 	movabs $0x81826f,%rax
  80e73b:	00 00 00 
  80e73e:	ff d0                	callq  *%rax
      } else {
        timeouts->next->time = 0;
      }
    }
  }
}
  80e740:	e9 db 00 00 00       	jmpq   80e820 <sys_sem_wait+0x124>
  timeouts = sys_arch_timeouts();

  if (!timeouts || !timeouts->next) {
    sys_arch_sem_wait(sem, 0);
  } else {
    if (timeouts->next->time > 0) {
  80e745:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e749:	48 8b 00             	mov    (%rax),%rax
  80e74c:	8b 40 08             	mov    0x8(%rax),%eax
  80e74f:	85 c0                	test   %eax,%eax
  80e751:	74 22                	je     80e775 <sys_sem_wait+0x79>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  80e753:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e757:	48 8b 00             	mov    (%rax),%rax
  80e75a:	8b 50 08             	mov    0x8(%rax),%edx
  80e75d:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e760:	89 d6                	mov    %edx,%esi
  80e762:	89 c7                	mov    %eax,%edi
  80e764:	48 b8 6f 82 81 00 00 	movabs $0x81826f,%rax
  80e76b:	00 00 00 
  80e76e:	ff d0                	callq  *%rax
  80e770:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80e773:	eb 07                	jmp    80e77c <sys_sem_wait+0x80>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
  80e775:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80e77c:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80e780:	75 68                	jne    80e7ea <sys_sem_wait+0xee>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80e782:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e786:	48 8b 00             	mov    (%rax),%rax
  80e789:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      timeouts->next = tmptimeout->next;
  80e78d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e791:	48 8b 10             	mov    (%rax),%rdx
  80e794:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e798:	48 89 10             	mov    %rdx,(%rax)
      h = tmptimeout->h;
  80e79b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e79f:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e7a3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      arg = tmptimeout->arg;
  80e7a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e7ab:	48 8b 40 18          	mov    0x18(%rax),%rax
  80e7af:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80e7b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e7b7:	48 89 c6             	mov    %rax,%rsi
  80e7ba:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e7bf:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80e7c6:	00 00 00 
  80e7c9:	ff d0                	callq  *%rax
      if (h != NULL) {
  80e7cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e7cf:	48 85 c0             	test   %rax,%rax
  80e7d2:	0f 84 2f ff ff ff    	je     80e707 <sys_sem_wait+0xb>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  80e7d8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e7dc:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e7e0:	48 89 d7             	mov    %rdx,%rdi
  80e7e3:	ff d0                	callq  *%rax
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80e7e5:	e9 1d ff ff ff       	jmpq   80e707 <sys_sem_wait+0xb>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  80e7ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e7ee:	48 8b 00             	mov    (%rax),%rax
  80e7f1:	8b 40 08             	mov    0x8(%rax),%eax
  80e7f4:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80e7f7:	76 19                	jbe    80e812 <sys_sem_wait+0x116>
        timeouts->next->time -= time_needed;
  80e7f9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e7fd:	48 8b 00             	mov    (%rax),%rax
  80e800:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e804:	48 8b 12             	mov    (%rdx),%rdx
  80e807:	8b 52 08             	mov    0x8(%rdx),%edx
  80e80a:	2b 55 fc             	sub    -0x4(%rbp),%edx
  80e80d:	89 50 08             	mov    %edx,0x8(%rax)
      } else {
        timeouts->next->time = 0;
      }
    }
  }
}
  80e810:	eb 0e                	jmp    80e820 <sys_sem_wait+0x124>
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
        timeouts->next->time -= time_needed;
      } else {
        timeouts->next->time = 0;
  80e812:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e816:	48 8b 00             	mov    (%rax),%rax
  80e819:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      }
    }
  }
}
  80e820:	90                   	nop
  80e821:	c9                   	leaveq 
  80e822:	c3                   	retq   

000000000080e823 <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  80e823:	55                   	push   %rbp
  80e824:	48 89 e5             	mov    %rsp,%rbp
  80e827:	48 83 ec 40          	sub    $0x40,%rsp
  80e82b:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80e82e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80e832:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  80e836:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e83b:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  80e842:	00 00 00 
  80e845:	ff d0                	callq  *%rax
  80e847:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (timeout == NULL) {
  80e84b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e850:	75 35                	jne    80e887 <sys_timeout+0x64>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  80e852:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e857:	0f 85 a9 01 00 00    	jne    80ea06 <sys_timeout+0x1e3>
  80e85d:	48 ba 48 25 82 00 00 	movabs $0x822548,%rdx
  80e864:	00 00 00 
  80e867:	be c4 00 00 00       	mov    $0xc4,%esi
  80e86c:	48 bf 65 25 82 00 00 	movabs $0x822565,%rdi
  80e873:	00 00 00 
  80e876:	b8 00 00 00 00       	mov    $0x0,%eax
  80e87b:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e882:	00 00 00 
  80e885:	ff d1                	callq  *%rcx
    return;
  }
  timeout->next = NULL;
  80e887:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e88b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  timeout->h = h;
  80e892:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80e896:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e89a:	48 89 50 10          	mov    %rdx,0x10(%rax)
  timeout->arg = arg;
  80e89e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e8a2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80e8a6:	48 89 50 18          	mov    %rdx,0x18(%rax)
  timeout->time = msecs;
  80e8aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e8ae:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80e8b1:	89 50 08             	mov    %edx,0x8(%rax)

  timeouts = sys_arch_timeouts();
  80e8b4:	48 b8 9b 89 81 00 00 	movabs $0x81899b,%rax
  80e8bb:	00 00 00 
  80e8be:	ff d0                	callq  *%rax
  80e8c0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  80e8c4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e8c9:	75 35                	jne    80e900 <sys_timeout+0xdd>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  80e8cb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e8d0:	0f 85 33 01 00 00    	jne    80ea09 <sys_timeout+0x1e6>
  80e8d6:	48 ba 79 25 82 00 00 	movabs $0x822579,%rdx
  80e8dd:	00 00 00 
  80e8e0:	be d2 00 00 00       	mov    $0xd2,%esi
  80e8e5:	48 bf 65 25 82 00 00 	movabs $0x822565,%rdi
  80e8ec:	00 00 00 
  80e8ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80e8f4:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e8fb:	00 00 00 
  80e8fe:	ff d1                	callq  *%rcx
    return;
  }

  if (timeouts->next == NULL) {
  80e900:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e904:	48 8b 00             	mov    (%rax),%rax
  80e907:	48 85 c0             	test   %rax,%rax
  80e90a:	75 10                	jne    80e91c <sys_timeout+0xf9>
    timeouts->next = timeout;
  80e90c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e910:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e914:	48 89 10             	mov    %rdx,(%rax)
    return;
  80e917:	e9 ee 00 00 00       	jmpq   80ea0a <sys_timeout+0x1e7>
  }

  if (timeouts->next->time > msecs) {
  80e91c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e920:	48 8b 00             	mov    (%rax),%rax
  80e923:	8b 40 08             	mov    0x8(%rax),%eax
  80e926:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  80e929:	76 35                	jbe    80e960 <sys_timeout+0x13d>
    timeouts->next->time -= msecs;
  80e92b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e92f:	48 8b 00             	mov    (%rax),%rax
  80e932:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80e936:	48 8b 12             	mov    (%rdx),%rdx
  80e939:	8b 52 08             	mov    0x8(%rdx),%edx
  80e93c:	2b 55 dc             	sub    -0x24(%rbp),%edx
  80e93f:	89 50 08             	mov    %edx,0x8(%rax)
    timeout->next = timeouts->next;
  80e942:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e946:	48 8b 10             	mov    (%rax),%rdx
  80e949:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e94d:	48 89 10             	mov    %rdx,(%rax)
    timeouts->next = timeout;
  80e950:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e954:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e958:	48 89 10             	mov    %rdx,(%rax)
  80e95b:	e9 aa 00 00 00       	jmpq   80ea0a <sys_timeout+0x1e7>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
  80e960:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e964:	48 8b 00             	mov    (%rax),%rax
  80e967:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e96b:	e9 89 00 00 00       	jmpq   80e9f9 <sys_timeout+0x1d6>
      timeout->time -= t->time;
  80e970:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e974:	8b 50 08             	mov    0x8(%rax),%edx
  80e977:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e97b:	8b 40 08             	mov    0x8(%rax),%eax
  80e97e:	29 c2                	sub    %eax,%edx
  80e980:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e984:	89 50 08             	mov    %edx,0x8(%rax)
      if (t->next == NULL || t->next->time > timeout->time) {
  80e987:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e98b:	48 8b 00             	mov    (%rax),%rax
  80e98e:	48 85 c0             	test   %rax,%rax
  80e991:	74 15                	je     80e9a8 <sys_timeout+0x185>
  80e993:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e997:	48 8b 00             	mov    (%rax),%rax
  80e99a:	8b 50 08             	mov    0x8(%rax),%edx
  80e99d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e9a1:	8b 40 08             	mov    0x8(%rax),%eax
  80e9a4:	39 c2                	cmp    %eax,%edx
  80e9a6:	76 46                	jbe    80e9ee <sys_timeout+0x1cb>
        if (t->next != NULL) {
  80e9a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e9ac:	48 8b 00             	mov    (%rax),%rax
  80e9af:	48 85 c0             	test   %rax,%rax
  80e9b2:	74 1f                	je     80e9d3 <sys_timeout+0x1b0>
          t->next->time -= timeout->time;
  80e9b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e9b8:	48 8b 00             	mov    (%rax),%rax
  80e9bb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80e9bf:	48 8b 12             	mov    (%rdx),%rdx
  80e9c2:	8b 4a 08             	mov    0x8(%rdx),%ecx
  80e9c5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e9c9:	8b 52 08             	mov    0x8(%rdx),%edx
  80e9cc:	29 d1                	sub    %edx,%ecx
  80e9ce:	89 ca                	mov    %ecx,%edx
  80e9d0:	89 50 08             	mov    %edx,0x8(%rax)
        }
        timeout->next = t->next;
  80e9d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e9d7:	48 8b 10             	mov    (%rax),%rdx
  80e9da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e9de:	48 89 10             	mov    %rdx,(%rax)
        t->next = timeout;
  80e9e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e9e5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e9e9:	48 89 10             	mov    %rdx,(%rax)
        break;
  80e9ec:	eb 1c                	jmp    80ea0a <sys_timeout+0x1e7>
  if (timeouts->next->time > msecs) {
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
  80e9ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e9f2:	48 8b 00             	mov    (%rax),%rax
  80e9f5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e9f9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80e9fe:	0f 85 6c ff ff ff    	jne    80e970 <sys_timeout+0x14d>
  80ea04:	eb 04                	jmp    80ea0a <sys_timeout+0x1e7>
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
    return;
  80ea06:	90                   	nop
  80ea07:	eb 01                	jmp    80ea0a <sys_timeout+0x1e7>
  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
    return;
  80ea09:	90                   	nop
        t->next = timeout;
        break;
      }
    }
  }
}
  80ea0a:	c9                   	leaveq 
  80ea0b:	c3                   	retq   

000000000080ea0c <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  80ea0c:	55                   	push   %rbp
  80ea0d:	48 89 e5             	mov    %rsp,%rbp
  80ea10:	48 83 ec 30          	sub    $0x30,%rsp
  80ea14:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80ea18:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  80ea1c:	48 b8 9b 89 81 00 00 	movabs $0x81899b,%rax
  80ea23:	00 00 00 
  80ea26:	ff d0                	callq  *%rax
  80ea28:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  if (timeouts == NULL) {
  80ea2c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80ea31:	75 35                	jne    80ea68 <sys_untimeout+0x5c>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  80ea33:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80ea38:	0f 85 f7 00 00 00    	jne    80eb35 <sys_untimeout+0x129>
  80ea3e:	48 ba 98 25 82 00 00 	movabs $0x822598,%rdx
  80ea45:	00 00 00 
  80ea48:	be 01 01 00 00       	mov    $0x101,%esi
  80ea4d:	48 bf 65 25 82 00 00 	movabs $0x822565,%rdi
  80ea54:	00 00 00 
  80ea57:	b8 00 00 00 00       	mov    $0x0,%eax
  80ea5c:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80ea63:	00 00 00 
  80ea66:	ff d1                	callq  *%rcx
    return;
  }
  if (timeouts->next == NULL) {
  80ea68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ea6c:	48 8b 00             	mov    (%rax),%rax
  80ea6f:	48 85 c0             	test   %rax,%rax
  80ea72:	0f 84 c0 00 00 00    	je     80eb38 <sys_untimeout+0x12c>
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80ea78:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ea7c:	48 8b 00             	mov    (%rax),%rax
  80ea7f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80ea83:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80ea8a:	00 
  80ea8b:	e9 97 00 00 00       	jmpq   80eb27 <sys_untimeout+0x11b>
    if ((t->h == h) && (t->arg == arg)) {
  80ea90:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ea94:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ea98:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80ea9c:	75 76                	jne    80eb14 <sys_untimeout+0x108>
  80ea9e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eaa2:	48 8b 40 18          	mov    0x18(%rax),%rax
  80eaa6:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80eaaa:	75 68                	jne    80eb14 <sys_untimeout+0x108>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  80eaac:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80eab1:	75 10                	jne    80eac3 <sys_untimeout+0xb7>
        timeouts->next = t->next;
  80eab3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eab7:	48 8b 10             	mov    (%rax),%rdx
  80eaba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eabe:	48 89 10             	mov    %rdx,(%rax)
  80eac1:	eb 0e                	jmp    80ead1 <sys_untimeout+0xc5>
      else
        prev_t->next = t->next;
  80eac3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eac7:	48 8b 10             	mov    (%rax),%rdx
  80eaca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eace:	48 89 10             	mov    %rdx,(%rax)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  80ead1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ead5:	48 8b 00             	mov    (%rax),%rax
  80ead8:	48 85 c0             	test   %rax,%rax
  80eadb:	74 1d                	je     80eafa <sys_untimeout+0xee>
        t->next->time += t->time;
  80eadd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eae1:	48 8b 00             	mov    (%rax),%rax
  80eae4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80eae8:	48 8b 12             	mov    (%rdx),%rdx
  80eaeb:	8b 4a 08             	mov    0x8(%rdx),%ecx
  80eaee:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80eaf2:	8b 52 08             	mov    0x8(%rdx),%edx
  80eaf5:	01 ca                	add    %ecx,%edx
  80eaf7:	89 50 08             	mov    %edx,0x8(%rax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  80eafa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eafe:	48 89 c6             	mov    %rax,%rsi
  80eb01:	bf 0b 00 00 00       	mov    $0xb,%edi
  80eb06:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80eb0d:	00 00 00 
  80eb10:	ff d0                	callq  *%rax
      return;
  80eb12:	eb 25                	jmp    80eb39 <sys_untimeout+0x12d>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80eb14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eb18:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80eb1c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eb20:	48 8b 00             	mov    (%rax),%rax
  80eb23:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80eb27:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80eb2c:	0f 85 5e ff ff ff    	jne    80ea90 <sys_untimeout+0x84>
        t->next->time += t->time;
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
  80eb32:	90                   	nop
  80eb33:	eb 04                	jmp    80eb39 <sys_untimeout+0x12d>

  timeouts = sys_arch_timeouts();

  if (timeouts == NULL) {
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
    return;
  80eb35:	90                   	nop
  80eb36:	eb 01                	jmp    80eb39 <sys_untimeout+0x12d>
  }
  if (timeouts->next == NULL) {
    return;
  80eb38:	90                   	nop
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  80eb39:	c9                   	leaveq 
  80eb3a:	c3                   	retq   

000000000080eb3b <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  80eb3b:	55                   	push   %rbp
  80eb3c:	48 89 e5             	mov    %rsp,%rbp
  80eb3f:	48 83 ec 20          	sub    $0x20,%rsp
  80eb43:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;
  80eb47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eb4b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  80eb4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eb53:	66 c7 00 01 00       	movw   $0x1,(%rax)
  sys_sem_signal(*(sswt_cb->psem));
  80eb58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eb5c:	48 8b 40 08          	mov    0x8(%rax),%rax
  80eb60:	8b 00                	mov    (%rax),%eax
  80eb62:	89 c7                	mov    %eax,%edi
  80eb64:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  80eb6b:	00 00 00 
  80eb6e:	ff d0                	callq  *%rax
}
  80eb70:	90                   	nop
  80eb71:	c9                   	leaveq 
  80eb72:	c3                   	retq   

000000000080eb73 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  80eb73:	55                   	push   %rbp
  80eb74:	48 89 e5             	mov    %rsp,%rbp
  80eb77:	48 83 ec 20          	sub    $0x20,%rsp
  80eb7b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80eb7e:	89 75 e8             	mov    %esi,-0x18(%rbp)
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  80eb81:	48 8d 45 ec          	lea    -0x14(%rbp),%rax
  80eb85:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sswt_cb.timeflag = 0;
  80eb89:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%rbp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  80eb8f:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80eb93:	74 1f                	je     80ebb4 <sys_sem_wait_timeout+0x41>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  80eb95:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80eb99:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80eb9c:	48 be 3b eb 80 00 00 	movabs $0x80eb3b,%rsi
  80eba3:	00 00 00 
  80eba6:	89 c7                	mov    %eax,%edi
  80eba8:	48 b8 23 e8 80 00 00 	movabs $0x80e823,%rax
  80ebaf:	00 00 00 
  80ebb2:	ff d0                	callq  *%rax
  }
  sys_sem_wait(sem);
  80ebb4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80ebb7:	89 c7                	mov    %eax,%edi
  80ebb9:	48 b8 fc e6 80 00 00 	movabs $0x80e6fc,%rax
  80ebc0:	00 00 00 
  80ebc3:	ff d0                	callq  *%rax
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  80ebc5:	0f b7 45 f0          	movzwl -0x10(%rbp),%eax
  80ebc9:	66 85 c0             	test   %ax,%ax
  80ebcc:	74 07                	je     80ebd5 <sys_sem_wait_timeout+0x62>
    /* timeout */
    return 0;
  80ebce:	b8 00 00 00 00       	mov    $0x0,%eax
  80ebd3:	eb 22                	jmp    80ebf7 <sys_sem_wait_timeout+0x84>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  80ebd5:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  80ebd9:	48 89 c6             	mov    %rax,%rsi
  80ebdc:	48 bf 3b eb 80 00 00 	movabs $0x80eb3b,%rdi
  80ebe3:	00 00 00 
  80ebe6:	48 b8 0c ea 80 00 00 	movabs $0x80ea0c,%rax
  80ebed:	00 00 00 
  80ebf0:	ff d0                	callq  *%rax
    return 1;
  80ebf2:	b8 01 00 00 00       	mov    $0x1,%eax
  }
}
  80ebf7:	c9                   	leaveq 
  80ebf8:	c3                   	retq   

000000000080ebf9 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  80ebf9:	55                   	push   %rbp
  80ebfa:	48 89 e5             	mov    %rsp,%rbp
  80ebfd:	48 83 ec 20          	sub    $0x20,%rsp
  80ec01:	89 7d ec             	mov    %edi,-0x14(%rbp)
  sys_sem_t delaysem = sys_sem_new(0);
  80ec04:	bf 00 00 00 00       	mov    $0x0,%edi
  80ec09:	48 b8 e1 7e 81 00 00 	movabs $0x817ee1,%rax
  80ec10:	00 00 00 
  80ec13:	ff d0                	callq  *%rax
  80ec15:	89 45 fc             	mov    %eax,-0x4(%rbp)

  sys_sem_wait_timeout(delaysem, ms);
  80ec18:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80ec1b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80ec1e:	89 d6                	mov    %edx,%esi
  80ec20:	89 c7                	mov    %eax,%edi
  80ec22:	48 b8 73 eb 80 00 00 	movabs $0x80eb73,%rax
  80ec29:	00 00 00 
  80ec2c:	ff d0                	callq  *%rax

  sys_sem_free(delaysem);
  80ec2e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80ec31:	89 c7                	mov    %eax,%edi
  80ec33:	48 b8 df 7f 81 00 00 	movabs $0x817fdf,%rax
  80ec3a:	00 00 00 
  80ec3d:	ff d0                	callq  *%rax
}
  80ec3f:	90                   	nop
  80ec40:	c9                   	leaveq 
  80ec41:	c3                   	retq   

000000000080ec42 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  80ec42:	55                   	push   %rbp
  80ec43:	48 89 e5             	mov    %rsp,%rbp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  80ec46:	48 b8 3e 03 81 00 00 	movabs $0x81033e,%rax
  80ec4d:	00 00 00 
  80ec50:	ff d0                	callq  *%rax

  if (++tcp_timer & 1) {
  80ec52:	48 b8 4c b0 b4 00 00 	movabs $0xb4b04c,%rax
  80ec59:	00 00 00 
  80ec5c:	0f b6 00             	movzbl (%rax),%eax
  80ec5f:	8d 50 01             	lea    0x1(%rax),%edx
  80ec62:	48 b8 4c b0 b4 00 00 	movabs $0xb4b04c,%rax
  80ec69:	00 00 00 
  80ec6c:	88 10                	mov    %dl,(%rax)
  80ec6e:	48 b8 4c b0 b4 00 00 	movabs $0xb4b04c,%rax
  80ec75:	00 00 00 
  80ec78:	0f b6 00             	movzbl (%rax),%eax
  80ec7b:	0f b6 c0             	movzbl %al,%eax
  80ec7e:	83 e0 01             	and    $0x1,%eax
  80ec81:	85 c0                	test   %eax,%eax
  80ec83:	74 0c                	je     80ec91 <tcp_tmr+0x4f>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  80ec85:	48 b8 ff fa 80 00 00 	movabs $0x80faff,%rax
  80ec8c:	00 00 00 
  80ec8f:	ff d0                	callq  *%rax
  }
}
  80ec91:	90                   	nop
  80ec92:	5d                   	pop    %rbp
  80ec93:	c3                   	retq   

000000000080ec94 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  80ec94:	55                   	push   %rbp
  80ec95:	48 89 e5             	mov    %rsp,%rbp
  80ec98:	48 83 ec 20          	sub    $0x20,%rsp
  80ec9c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  80eca0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eca4:	8b 40 18             	mov    0x18(%rax),%eax
  80eca7:	83 f8 07             	cmp    $0x7,%eax
  80ecaa:	0f 87 31 02 00 00    	ja     80eee1 <tcp_close+0x24d>
  80ecb0:	89 c0                	mov    %eax,%eax
  80ecb2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80ecb9:	00 
  80ecba:	48 b8 d0 25 82 00 00 	movabs $0x8225d0,%rax
  80ecc1:	00 00 00 
  80ecc4:	48 01 d0             	add    %rdx,%rax
  80ecc7:	48 8b 00             	mov    (%rax),%rax
  80ecca:	ff e0                	jmpq   *%rax
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
  80eccc:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    TCP_RMV(&tcp_bound_pcbs, pcb);
  80ecd0:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ecd7:	00 00 00 
  80ecda:	48 8b 00             	mov    (%rax),%rax
  80ecdd:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80ece1:	75 23                	jne    80ed06 <tcp_close+0x72>
  80ece3:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ecea:	00 00 00 
  80eced:	48 8b 00             	mov    (%rax),%rax
  80ecf0:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80ecf4:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ecfb:	00 00 00 
  80ecfe:	48 89 10             	mov    %rdx,(%rax)
  80ed01:	e9 94 00 00 00       	jmpq   80ed9a <tcp_close+0x106>
  80ed06:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ed0d:	00 00 00 
  80ed10:	48 8b 10             	mov    (%rax),%rdx
  80ed13:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ed1a:	00 00 00 
  80ed1d:	48 89 10             	mov    %rdx,(%rax)
  80ed20:	eb 66                	jmp    80ed88 <tcp_close+0xf4>
  80ed22:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ed29:	00 00 00 
  80ed2c:	48 8b 00             	mov    (%rax),%rax
  80ed2f:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ed33:	48 85 c0             	test   %rax,%rax
  80ed36:	74 32                	je     80ed6a <tcp_close+0xd6>
  80ed38:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ed3f:	00 00 00 
  80ed42:	48 8b 00             	mov    (%rax),%rax
  80ed45:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ed49:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80ed4d:	75 1b                	jne    80ed6a <tcp_close+0xd6>
  80ed4f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ed56:	00 00 00 
  80ed59:	48 8b 00             	mov    (%rax),%rax
  80ed5c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80ed60:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80ed64:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80ed68:	eb 30                	jmp    80ed9a <tcp_close+0x106>
  80ed6a:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ed71:	00 00 00 
  80ed74:	48 8b 00             	mov    (%rax),%rax
  80ed77:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80ed7b:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ed82:	00 00 00 
  80ed85:	48 89 10             	mov    %rdx,(%rax)
  80ed88:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ed8f:	00 00 00 
  80ed92:	48 8b 00             	mov    (%rax),%rax
  80ed95:	48 85 c0             	test   %rax,%rax
  80ed98:	75 88                	jne    80ed22 <tcp_close+0x8e>
  80ed9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed9e:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80eda5:	00 
    memp_free(MEMP_TCP_PCB, pcb);
  80eda6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80edaa:	48 89 c6             	mov    %rax,%rsi
  80edad:	bf 02 00 00 00       	mov    $0x2,%edi
  80edb2:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80edb9:	00 00 00 
  80edbc:	ff d0                	callq  *%rax
    pcb = NULL;
  80edbe:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80edc5:	00 
    break;
  80edc6:	e9 2b 01 00 00       	jmpq   80eef6 <tcp_close+0x262>
  case LISTEN:
    err = ERR_OK;
  80edcb:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  80edcf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80edd3:	48 89 c6             	mov    %rax,%rsi
  80edd6:	48 bf 28 b0 b5 00 00 	movabs $0xb5b028,%rdi
  80eddd:	00 00 00 
  80ede0:	48 b8 d7 0a 81 00 00 	movabs $0x810ad7,%rax
  80ede7:	00 00 00 
  80edea:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  80edec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80edf0:	48 89 c6             	mov    %rax,%rsi
  80edf3:	bf 03 00 00 00       	mov    $0x3,%edi
  80edf8:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80edff:	00 00 00 
  80ee02:	ff d0                	callq  *%rax
    pcb = NULL;
  80ee04:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80ee0b:	00 
    break;
  80ee0c:	e9 e5 00 00 00       	jmpq   80eef6 <tcp_close+0x262>
  case SYN_SENT:
    err = ERR_OK;
  80ee11:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80ee15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee19:	48 89 c6             	mov    %rax,%rsi
  80ee1c:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  80ee23:	00 00 00 
  80ee26:	48 b8 d7 0a 81 00 00 	movabs $0x810ad7,%rax
  80ee2d:	00 00 00 
  80ee30:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB, pcb);
  80ee32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee36:	48 89 c6             	mov    %rax,%rsi
  80ee39:	bf 02 00 00 00       	mov    $0x2,%edi
  80ee3e:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80ee45:	00 00 00 
  80ee48:	ff d0                	callq  *%rax
    pcb = NULL;
  80ee4a:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80ee51:	00 
    snmp_inc_tcpattemptfails();
    break;
  80ee52:	e9 9f 00 00 00       	jmpq   80eef6 <tcp_close+0x262>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80ee57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee5b:	be 01 00 00 00       	mov    $0x1,%esi
  80ee60:	48 89 c7             	mov    %rax,%rdi
  80ee63:	48 b8 38 31 81 00 00 	movabs $0x813138,%rax
  80ee6a:	00 00 00 
  80ee6d:	ff d0                	callq  *%rax
  80ee6f:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80ee72:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80ee76:	75 77                	jne    80eeef <tcp_close+0x25b>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  80ee78:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee7c:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%rax)
    }
    break;
  80ee83:	eb 6a                	jmp    80eeef <tcp_close+0x25b>
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80ee85:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee89:	be 01 00 00 00       	mov    $0x1,%esi
  80ee8e:	48 89 c7             	mov    %rax,%rdi
  80ee91:	48 b8 38 31 81 00 00 	movabs $0x813138,%rax
  80ee98:	00 00 00 
  80ee9b:	ff d0                	callq  *%rax
  80ee9d:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80eea0:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80eea4:	75 4c                	jne    80eef2 <tcp_close+0x25e>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  80eea6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eeaa:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%rax)
    }
    break;
  80eeb1:	eb 3f                	jmp    80eef2 <tcp_close+0x25e>
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80eeb3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eeb7:	be 01 00 00 00       	mov    $0x1,%esi
  80eebc:	48 89 c7             	mov    %rax,%rdi
  80eebf:	48 b8 38 31 81 00 00 	movabs $0x813138,%rax
  80eec6:	00 00 00 
  80eec9:	ff d0                	callq  *%rax
  80eecb:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80eece:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80eed2:	75 21                	jne    80eef5 <tcp_close+0x261>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  80eed4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eed8:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
    }
    break;
  80eedf:	eb 14                	jmp    80eef5 <tcp_close+0x261>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
  80eee1:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    pcb = NULL;
  80eee5:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80eeec:	00 
    break;
  80eeed:	eb 07                	jmp    80eef6 <tcp_close+0x262>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    }
    break;
  80eeef:	90                   	nop
  80eef0:	eb 04                	jmp    80eef6 <tcp_close+0x262>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
  80eef2:	90                   	nop
  80eef3:	eb 01                	jmp    80eef6 <tcp_close+0x262>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    }
    break;
  80eef5:	90                   	nop
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  80eef6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80eefb:	74 19                	je     80ef16 <tcp_close+0x282>
  80eefd:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80ef01:	75 13                	jne    80ef16 <tcp_close+0x282>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  80ef03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ef07:	48 89 c7             	mov    %rax,%rdi
  80ef0a:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  80ef11:	00 00 00 
  80ef14:	ff d0                	callq  *%rax
  }
  return err;
  80ef16:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80ef1a:	c9                   	leaveq 
  80ef1b:	c3                   	retq   

000000000080ef1c <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  80ef1c:	55                   	push   %rbp
  80ef1d:	48 89 e5             	mov    %rsp,%rbp
  80ef20:	48 83 ec 50          	sub    $0x50,%rsp
  80ef24:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  80ef28:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef2c:	8b 40 18             	mov    0x18(%rax),%eax
  80ef2f:	83 f8 0a             	cmp    $0xa,%eax
  80ef32:	75 3a                	jne    80ef6e <tcp_abort+0x52>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  80ef34:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef38:	48 89 c6             	mov    %rax,%rsi
  80ef3b:	48 bf 40 b0 b5 00 00 	movabs $0xb5b040,%rdi
  80ef42:	00 00 00 
  80ef45:	48 b8 d7 0a 81 00 00 	movabs $0x810ad7,%rax
  80ef4c:	00 00 00 
  80ef4f:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB, pcb);
  80ef51:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef55:	48 89 c6             	mov    %rax,%rsi
  80ef58:	bf 02 00 00 00       	mov    $0x2,%edi
  80ef5d:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80ef64:	00 00 00 
  80ef67:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB, pcb);
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  }
}
  80ef69:	e9 75 01 00 00       	jmpq   80f0e3 <tcp_abort+0x1c7>
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
  } else {
    seqno = pcb->snd_nxt;
  80ef6e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef72:	8b 40 60             	mov    0x60(%rax),%eax
  80ef75:	89 45 fc             	mov    %eax,-0x4(%rbp)
    ackno = pcb->rcv_nxt;
  80ef78:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef7c:	8b 40 30             	mov    0x30(%rax),%eax
  80ef7f:	89 45 f8             	mov    %eax,-0x8(%rbp)
    ip_addr_set(&local_ip, &(pcb->local_ip));
  80ef82:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef86:	48 85 c0             	test   %rax,%rax
  80ef89:	74 08                	je     80ef93 <tcp_abort+0x77>
  80ef8b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef8f:	8b 00                	mov    (%rax),%eax
  80ef91:	eb 05                	jmp    80ef98 <tcp_abort+0x7c>
  80ef93:	b8 00 00 00 00       	mov    $0x0,%eax
  80ef98:	89 45 c0             	mov    %eax,-0x40(%rbp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  80ef9b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ef9f:	48 83 c0 04          	add    $0x4,%rax
  80efa3:	48 85 c0             	test   %rax,%rax
  80efa6:	74 09                	je     80efb1 <tcp_abort+0x95>
  80efa8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80efac:	8b 40 04             	mov    0x4(%rax),%eax
  80efaf:	eb 05                	jmp    80efb6 <tcp_abort+0x9a>
  80efb1:	b8 00 00 00 00       	mov    $0x0,%eax
  80efb6:	89 45 d0             	mov    %eax,-0x30(%rbp)
    local_port = pcb->local_port;
  80efb9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80efbd:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80efc1:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    remote_port = pcb->remote_port;
  80efc5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80efc9:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  80efcd:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  80efd1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80efd5:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  80efdc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  80efe0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80efe4:	48 8b 40 20          	mov    0x20(%rax),%rax
  80efe8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80efec:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eff0:	48 89 c6             	mov    %rax,%rsi
  80eff3:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  80effa:	00 00 00 
  80effd:	48 b8 d7 0a 81 00 00 	movabs $0x810ad7,%rax
  80f004:	00 00 00 
  80f007:	ff d0                	callq  *%rax
    if (pcb->unacked != NULL) {
  80f009:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f00d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80f014:	48 85 c0             	test   %rax,%rax
  80f017:	74 1a                	je     80f033 <tcp_abort+0x117>
      tcp_segs_free(pcb->unacked);
  80f019:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f01d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80f024:	48 89 c7             	mov    %rax,%rdi
  80f027:	48 b8 58 04 81 00 00 	movabs $0x810458,%rax
  80f02e:	00 00 00 
  80f031:	ff d0                	callq  *%rax
    }
    if (pcb->unsent != NULL) {
  80f033:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f037:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80f03e:	48 85 c0             	test   %rax,%rax
  80f041:	74 1a                	je     80f05d <tcp_abort+0x141>
      tcp_segs_free(pcb->unsent);
  80f043:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f047:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80f04e:	48 89 c7             	mov    %rax,%rdi
  80f051:	48 b8 58 04 81 00 00 	movabs $0x810458,%rax
  80f058:	00 00 00 
  80f05b:	ff d0                	callq  *%rax
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  80f05d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f061:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80f068:	48 85 c0             	test   %rax,%rax
  80f06b:	74 1a                	je     80f087 <tcp_abort+0x16b>
      tcp_segs_free(pcb->ooseq);
  80f06d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f071:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80f078:	48 89 c7             	mov    %rax,%rdi
  80f07b:	48 b8 58 04 81 00 00 	movabs $0x810458,%rax
  80f082:	00 00 00 
  80f085:	ff d0                	callq  *%rax
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  80f087:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f08b:	48 89 c6             	mov    %rax,%rsi
  80f08e:	bf 02 00 00 00       	mov    $0x2,%edi
  80f093:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80f09a:	00 00 00 
  80f09d:	ff d0                	callq  *%rax
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  80f09f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80f0a4:	74 12                	je     80f0b8 <tcp_abort+0x19c>
  80f0a6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f0aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f0ae:	be fb ff ff ff       	mov    $0xfffffffb,%esi
  80f0b3:	48 89 d7             	mov    %rdx,%rdi
  80f0b6:	ff d0                	callq  *%rax
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  80f0b8:	44 0f b7 45 f4       	movzwl -0xc(%rbp),%r8d
  80f0bd:	0f b7 7d f6          	movzwl -0xa(%rbp),%edi
  80f0c1:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80f0c5:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  80f0c9:	8b 75 f8             	mov    -0x8(%rbp),%esi
  80f0cc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80f0cf:	45 89 c1             	mov    %r8d,%r9d
  80f0d2:	41 89 f8             	mov    %edi,%r8d
  80f0d5:	89 c7                	mov    %eax,%edi
  80f0d7:	48 b8 05 46 81 00 00 	movabs $0x814605,%rax
  80f0de:	00 00 00 
  80f0e1:	ff d0                	callq  *%rax
  }
}
  80f0e3:	90                   	nop
  80f0e4:	c9                   	leaveq 
  80f0e5:	c3                   	retq   

000000000080f0e6 <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80f0e6:	55                   	push   %rbp
  80f0e7:	48 89 e5             	mov    %rsp,%rbp
  80f0ea:	48 83 ec 30          	sub    $0x30,%rsp
  80f0ee:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80f0f2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80f0f6:	89 d0                	mov    %edx,%eax
  80f0f8:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80f0fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f100:	8b 40 18             	mov    0x18(%rax),%eax
  80f103:	85 c0                	test   %eax,%eax
  80f105:	74 2a                	je     80f131 <tcp_bind+0x4b>
  80f107:	48 ba 10 26 82 00 00 	movabs $0x822610,%rdx
  80f10e:	00 00 00 
  80f111:	be 06 01 00 00       	mov    $0x106,%esi
  80f116:	48 bf 3b 26 82 00 00 	movabs $0x82263b,%rdi
  80f11d:	00 00 00 
  80f120:	b8 00 00 00 00       	mov    $0x0,%eax
  80f125:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80f12c:	00 00 00 
  80f12f:	ff d1                	callq  *%rcx

  if (port == 0) {
  80f131:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  80f136:	75 10                	jne    80f148 <tcp_bind+0x62>
    port = tcp_new_port();
  80f138:	48 b8 fa f6 80 00 00 	movabs $0x80f6fa,%rax
  80f13f:	00 00 00 
  80f142:	ff d0                	callq  *%rax
  80f144:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80f148:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f14f:	00 00 00 
  80f152:	48 8b 00             	mov    (%rax),%rax
  80f155:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f159:	eb 58                	jmp    80f1b3 <tcp_bind+0xcd>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80f15b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f15f:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f163:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80f167:	75 3e                	jne    80f1a7 <tcp_bind+0xc1>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80f169:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f16d:	48 85 c0             	test   %rax,%rax
  80f170:	74 2b                	je     80f19d <tcp_bind+0xb7>
  80f172:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f176:	8b 00                	mov    (%rax),%eax
  80f178:	85 c0                	test   %eax,%eax
  80f17a:	74 21                	je     80f19d <tcp_bind+0xb7>
  80f17c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f181:	74 1a                	je     80f19d <tcp_bind+0xb7>
          ip_addr_isany(ipaddr) ||
  80f183:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f187:	8b 00                	mov    (%rax),%eax
  80f189:	85 c0                	test   %eax,%eax
  80f18b:	74 10                	je     80f19d <tcp_bind+0xb7>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80f18d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f191:	8b 10                	mov    (%rax),%edx
  80f193:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f197:	8b 00                	mov    (%rax),%eax
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80f199:	39 c2                	cmp    %eax,%edx
  80f19b:	75 0a                	jne    80f1a7 <tcp_bind+0xc1>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80f19d:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80f1a2:	e9 a2 01 00 00       	jmpq   80f349 <tcp_bind+0x263>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80f1a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1ab:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f1af:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80f1b3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f1b8:	75 a1                	jne    80f15b <tcp_bind+0x75>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  80f1ba:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f1c1:	00 00 00 
  80f1c4:	48 8b 00             	mov    (%rax),%rax
  80f1c7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f1cb:	eb 58                	jmp    80f225 <tcp_bind+0x13f>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80f1cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1d1:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f1d5:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80f1d9:	75 3e                	jne    80f219 <tcp_bind+0x133>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80f1db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1df:	48 85 c0             	test   %rax,%rax
  80f1e2:	74 2b                	je     80f20f <tcp_bind+0x129>
  80f1e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1e8:	8b 00                	mov    (%rax),%eax
  80f1ea:	85 c0                	test   %eax,%eax
  80f1ec:	74 21                	je     80f20f <tcp_bind+0x129>
  80f1ee:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f1f3:	74 1a                	je     80f20f <tcp_bind+0x129>
          ip_addr_isany(ipaddr) ||
  80f1f5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f1f9:	8b 00                	mov    (%rax),%eax
  80f1fb:	85 c0                	test   %eax,%eax
  80f1fd:	74 10                	je     80f20f <tcp_bind+0x129>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80f1ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f203:	8b 10                	mov    (%rax),%edx
  80f205:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f209:	8b 00                	mov    (%rax),%eax
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80f20b:	39 c2                	cmp    %eax,%edx
  80f20d:	75 0a                	jne    80f219 <tcp_bind+0x133>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80f20f:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80f214:	e9 30 01 00 00       	jmpq   80f349 <tcp_bind+0x263>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80f219:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f21d:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f221:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  80f225:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f22a:	75 a1                	jne    80f1cd <tcp_bind+0xe7>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80f22c:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f233:	00 00 00 
  80f236:	48 8b 00             	mov    (%rax),%rax
  80f239:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f23d:	eb 58                	jmp    80f297 <tcp_bind+0x1b1>
    if (cpcb->local_port == port) {
  80f23f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f243:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f247:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80f24b:	75 3e                	jne    80f28b <tcp_bind+0x1a5>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80f24d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f251:	48 85 c0             	test   %rax,%rax
  80f254:	74 2b                	je     80f281 <tcp_bind+0x19b>
  80f256:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f25a:	8b 00                	mov    (%rax),%eax
  80f25c:	85 c0                	test   %eax,%eax
  80f25e:	74 21                	je     80f281 <tcp_bind+0x19b>
  80f260:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f265:	74 1a                	je     80f281 <tcp_bind+0x19b>
          ip_addr_isany(ipaddr) ||
  80f267:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f26b:	8b 00                	mov    (%rax),%eax
  80f26d:	85 c0                	test   %eax,%eax
  80f26f:	74 10                	je     80f281 <tcp_bind+0x19b>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80f271:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f275:	8b 10                	mov    (%rax),%edx
  80f277:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f27b:	8b 00                	mov    (%rax),%eax
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80f27d:	39 c2                	cmp    %eax,%edx
  80f27f:	75 0a                	jne    80f28b <tcp_bind+0x1a5>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80f281:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80f286:	e9 be 00 00 00       	jmpq   80f349 <tcp_bind+0x263>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80f28b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f28f:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f293:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f297:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f29c:	75 a1                	jne    80f23f <tcp_bind+0x159>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80f29e:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80f2a5:	00 00 00 
  80f2a8:	48 8b 00             	mov    (%rax),%rax
  80f2ab:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f2af:	eb 31                	jmp    80f2e2 <tcp_bind+0x1fc>
    if (cpcb->local_port == port) {
  80f2b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2b5:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f2b9:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80f2bd:	75 17                	jne    80f2d6 <tcp_bind+0x1f0>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80f2bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2c3:	8b 10                	mov    (%rax),%edx
  80f2c5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f2c9:	8b 00                	mov    (%rax),%eax
  80f2cb:	39 c2                	cmp    %eax,%edx
  80f2cd:	75 07                	jne    80f2d6 <tcp_bind+0x1f0>
        return ERR_USE;
  80f2cf:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80f2d4:	eb 73                	jmp    80f349 <tcp_bind+0x263>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80f2d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2da:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f2de:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f2e2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f2e7:	75 c8                	jne    80f2b1 <tcp_bind+0x1cb>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  80f2e9:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f2ee:	74 16                	je     80f306 <tcp_bind+0x220>
  80f2f0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f2f4:	8b 00                	mov    (%rax),%eax
  80f2f6:	85 c0                	test   %eax,%eax
  80f2f8:	74 0c                	je     80f306 <tcp_bind+0x220>
    pcb->local_ip = *ipaddr;
  80f2fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f2fe:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f302:	8b 12                	mov    (%rdx),%edx
  80f304:	89 10                	mov    %edx,(%rax)
  }
  pcb->local_port = port;
  80f306:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f30a:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80f30e:	66 89 50 28          	mov    %dx,0x28(%rax)
  TCP_REG(&tcp_bound_pcbs, pcb);
  80f312:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f319:	00 00 00 
  80f31c:	48 8b 10             	mov    (%rax),%rdx
  80f31f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f323:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f327:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f32e:	00 00 00 
  80f331:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f335:	48 89 10             	mov    %rdx,(%rax)
  80f338:	48 b8 8f 86 80 00 00 	movabs $0x80868f,%rax
  80f33f:	00 00 00 
  80f342:	ff d0                	callq  *%rax
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  80f344:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f349:	c9                   	leaveq 
  80f34a:	c3                   	retq   

000000000080f34b <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80f34b:	55                   	push   %rbp
  80f34c:	48 89 e5             	mov    %rsp,%rbp
  80f34f:	48 83 ec 18          	sub    $0x18,%rsp
  80f353:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80f357:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80f35b:	89 d0                	mov    %edx,%eax
  80f35d:	88 45 ec             	mov    %al,-0x14(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
  80f360:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  80f365:	c9                   	leaveq 
  80f366:	c3                   	retq   

000000000080f367 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  80f367:	55                   	push   %rbp
  80f368:	48 89 e5             	mov    %rsp,%rbp
  80f36b:	48 83 ec 20          	sub    $0x20,%rsp
  80f36f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80f373:	89 f0                	mov    %esi,%eax
  80f375:	88 45 e4             	mov    %al,-0x1c(%rbp)
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  80f378:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f37c:	8b 40 18             	mov    0x18(%rax),%eax
  80f37f:	85 c0                	test   %eax,%eax
  80f381:	74 2a                	je     80f3ad <tcp_listen_with_backlog+0x46>
  80f383:	48 ba 50 26 82 00 00 	movabs $0x822650,%rdx
  80f38a:	00 00 00 
  80f38d:	be 61 01 00 00       	mov    $0x161,%esi
  80f392:	48 bf 3b 26 82 00 00 	movabs $0x82263b,%rdi
  80f399:	00 00 00 
  80f39c:	b8 00 00 00 00       	mov    $0x0,%eax
  80f3a1:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80f3a8:	00 00 00 
  80f3ab:	ff d1                	callq  *%rcx

  /* already listening? */
  if (pcb->state == LISTEN) {
  80f3ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f3b1:	8b 40 18             	mov    0x18(%rax),%eax
  80f3b4:	83 f8 01             	cmp    $0x1,%eax
  80f3b7:	75 09                	jne    80f3c2 <tcp_listen_with_backlog+0x5b>
    return pcb;
  80f3b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f3bd:	e9 e6 01 00 00       	jmpq   80f5a8 <tcp_listen_with_backlog+0x241>
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  80f3c2:	bf 03 00 00 00       	mov    $0x3,%edi
  80f3c7:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  80f3ce:	00 00 00 
  80f3d1:	ff d0                	callq  *%rax
  80f3d3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (lpcb == NULL) {
  80f3d7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f3dc:	75 0a                	jne    80f3e8 <tcp_listen_with_backlog+0x81>
    return NULL;
  80f3de:	b8 00 00 00 00       	mov    $0x0,%eax
  80f3e3:	e9 c0 01 00 00       	jmpq   80f5a8 <tcp_listen_with_backlog+0x241>
  }
  lpcb->callback_arg = pcb->callback_arg;
  80f3e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f3ec:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80f3f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f3f4:	48 89 50 20          	mov    %rdx,0x20(%rax)
  lpcb->local_port = pcb->local_port;
  80f3f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f3fc:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f400:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f404:	66 89 50 28          	mov    %dx,0x28(%rax)
  lpcb->state = LISTEN;
  80f408:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f40c:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%rax)
  lpcb->so_options = pcb->so_options;
  80f413:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f417:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  80f41b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f41f:	66 89 50 08          	mov    %dx,0x8(%rax)
  lpcb->so_options |= SOF_ACCEPTCONN;
  80f423:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f427:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80f42b:	83 c8 02             	or     $0x2,%eax
  80f42e:	89 c2                	mov    %eax,%edx
  80f430:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f434:	66 89 50 08          	mov    %dx,0x8(%rax)
  lpcb->ttl = pcb->ttl;
  80f438:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f43c:	0f b6 50 0b          	movzbl 0xb(%rax),%edx
  80f440:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f444:	88 50 0b             	mov    %dl,0xb(%rax)
  lpcb->tos = pcb->tos;
  80f447:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f44b:	0f b6 50 0a          	movzbl 0xa(%rax),%edx
  80f44f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f453:	88 50 0a             	mov    %dl,0xa(%rax)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  80f456:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f45a:	48 85 c0             	test   %rax,%rax
  80f45d:	74 08                	je     80f467 <tcp_listen_with_backlog+0x100>
  80f45f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f463:	8b 00                	mov    (%rax),%eax
  80f465:	eb 05                	jmp    80f46c <tcp_listen_with_backlog+0x105>
  80f467:	b8 00 00 00 00       	mov    $0x0,%eax
  80f46c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80f470:	89 02                	mov    %eax,(%rdx)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80f472:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f479:	00 00 00 
  80f47c:	48 8b 00             	mov    (%rax),%rax
  80f47f:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80f483:	75 23                	jne    80f4a8 <tcp_listen_with_backlog+0x141>
  80f485:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f48c:	00 00 00 
  80f48f:	48 8b 00             	mov    (%rax),%rax
  80f492:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f496:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f49d:	00 00 00 
  80f4a0:	48 89 10             	mov    %rdx,(%rax)
  80f4a3:	e9 94 00 00 00       	jmpq   80f53c <tcp_listen_with_backlog+0x1d5>
  80f4a8:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f4af:	00 00 00 
  80f4b2:	48 8b 10             	mov    (%rax),%rdx
  80f4b5:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f4bc:	00 00 00 
  80f4bf:	48 89 10             	mov    %rdx,(%rax)
  80f4c2:	eb 66                	jmp    80f52a <tcp_listen_with_backlog+0x1c3>
  80f4c4:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f4cb:	00 00 00 
  80f4ce:	48 8b 00             	mov    (%rax),%rax
  80f4d1:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f4d5:	48 85 c0             	test   %rax,%rax
  80f4d8:	74 32                	je     80f50c <tcp_listen_with_backlog+0x1a5>
  80f4da:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f4e1:	00 00 00 
  80f4e4:	48 8b 00             	mov    (%rax),%rax
  80f4e7:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f4eb:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80f4ef:	75 1b                	jne    80f50c <tcp_listen_with_backlog+0x1a5>
  80f4f1:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f4f8:	00 00 00 
  80f4fb:	48 8b 00             	mov    (%rax),%rax
  80f4fe:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f502:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80f506:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f50a:	eb 30                	jmp    80f53c <tcp_listen_with_backlog+0x1d5>
  80f50c:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f513:	00 00 00 
  80f516:	48 8b 00             	mov    (%rax),%rax
  80f519:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f51d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f524:	00 00 00 
  80f527:	48 89 10             	mov    %rdx,(%rax)
  80f52a:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f531:	00 00 00 
  80f534:	48 8b 00             	mov    (%rax),%rax
  80f537:	48 85 c0             	test   %rax,%rax
  80f53a:	75 88                	jne    80f4c4 <tcp_listen_with_backlog+0x15d>
  80f53c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f540:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80f547:	00 
  memp_free(MEMP_TCP_PCB, pcb);
  80f548:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f54c:	48 89 c6             	mov    %rax,%rsi
  80f54f:	bf 02 00 00 00       	mov    $0x2,%edi
  80f554:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  80f55b:	00 00 00 
  80f55e:	ff d0                	callq  *%rax
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  80f560:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f564:	48 b9 4b f3 80 00 00 	movabs $0x80f34b,%rcx
  80f56b:	00 00 00 
  80f56e:	48 89 48 30          	mov    %rcx,0x30(%rax)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  80f572:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f579:	00 00 00 
  80f57c:	48 8b 10             	mov    (%rax),%rdx
  80f57f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f583:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f587:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f58e:	00 00 00 
  80f591:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80f595:	48 89 10             	mov    %rdx,(%rax)
  80f598:	48 b8 8f 86 80 00 00 	movabs $0x80868f,%rax
  80f59f:	00 00 00 
  80f5a2:	ff d0                	callq  *%rax
  return (struct tcp_pcb *)lpcb;
  80f5a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80f5a8:	c9                   	leaveq 
  80f5a9:	c3                   	retq   

000000000080f5aa <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  80f5aa:	55                   	push   %rbp
  80f5ab:	48 89 e5             	mov    %rsp,%rbp
  80f5ae:	48 83 ec 10          	sub    $0x10,%rsp
  80f5b2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80f5b6:	89 f0                	mov    %esi,%eax
  80f5b8:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  80f5bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f5c0:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  80f5c4:	0f b7 d0             	movzwl %ax,%edx
  80f5c7:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80f5cb:	01 d0                	add    %edx,%eax
  80f5cd:	3d c0 5d 00 00       	cmp    $0x5dc0,%eax
  80f5d2:	76 16                	jbe    80f5ea <tcp_recved+0x40>
    pcb->rcv_wnd = TCP_WND;
  80f5d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f5d8:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
    pcb->rcv_ann_wnd = TCP_WND;
  80f5de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f5e2:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
  80f5e8:	eb 3b                	jmp    80f625 <tcp_recved+0x7b>
  } else {
    pcb->rcv_wnd += len;
  80f5ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f5ee:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80f5f2:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80f5f6:	01 c2                	add    %eax,%edx
  80f5f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f5fc:	66 89 50 34          	mov    %dx,0x34(%rax)
    if (pcb->rcv_wnd >= pcb->mss) {
  80f600:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f604:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80f608:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f60c:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f610:	66 39 c2             	cmp    %ax,%dx
  80f613:	72 10                	jb     80f625 <tcp_recved+0x7b>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  80f615:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f619:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80f61d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f621:	66 89 50 36          	mov    %dx,0x36(%rax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  80f625:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f629:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f62d:	0f b6 c0             	movzbl %al,%eax
  80f630:	83 e0 01             	and    $0x1,%eax
  80f633:	85 c0                	test   %eax,%eax
  80f635:	75 77                	jne    80f6ae <tcp_recved+0x104>
     !(pcb->flags & TF_ACK_NOW)) {
  80f637:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f63b:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f63f:	0f b6 c0             	movzbl %al,%eax
  80f642:	83 e0 02             	and    $0x2,%eax
    if (pcb->rcv_wnd >= pcb->mss) {
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  80f645:	85 c0                	test   %eax,%eax
  80f647:	75 65                	jne    80f6ae <tcp_recved+0x104>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  80f649:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f64d:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f651:	0f b6 c0             	movzbl %al,%eax
  80f654:	83 e0 01             	and    $0x1,%eax
  80f657:	85 c0                	test   %eax,%eax
  80f659:	74 3d                	je     80f698 <tcp_recved+0xee>
  80f65b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f65f:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f663:	83 e0 fe             	and    $0xfffffffe,%eax
  80f666:	89 c2                	mov    %eax,%edx
  80f668:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f66c:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f66f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f673:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f677:	83 c8 02             	or     $0x2,%eax
  80f67a:	89 c2                	mov    %eax,%edx
  80f67c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f680:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f683:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f687:	48 89 c7             	mov    %rax,%rdi
  80f68a:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  80f691:	00 00 00 
  80f694:	ff d0                	callq  *%rax
  80f696:	eb 5f                	jmp    80f6f7 <tcp_recved+0x14d>
  80f698:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f69c:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f6a0:	83 c8 01             	or     $0x1,%eax
  80f6a3:	89 c2                	mov    %eax,%edx
  80f6a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6a9:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f6ac:	eb 49                	jmp    80f6f7 <tcp_recved+0x14d>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  80f6ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6b2:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f6b6:	0f b6 c0             	movzbl %al,%eax
  80f6b9:	83 e0 01             	and    $0x1,%eax
  80f6bc:	85 c0                	test   %eax,%eax
  80f6be:	74 37                	je     80f6f7 <tcp_recved+0x14d>
  80f6c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6c4:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  80f6c8:	66 3d df 2e          	cmp    $0x2edf,%ax
  80f6cc:	76 29                	jbe    80f6f7 <tcp_recved+0x14d>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  80f6ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6d2:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f6d6:	83 c8 02             	or     $0x2,%eax
  80f6d9:	89 c2                	mov    %eax,%edx
  80f6db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6df:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f6e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6e6:	48 89 c7             	mov    %rax,%rdi
  80f6e9:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  80f6f0:	00 00 00 
  80f6f3:	ff d0                	callq  *%rax
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  80f6f5:	eb 00                	jmp    80f6f7 <tcp_recved+0x14d>
  80f6f7:	90                   	nop
  80f6f8:	c9                   	leaveq 
  80f6f9:	c3                   	retq   

000000000080f6fa <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80f6fa:	55                   	push   %rbp
  80f6fb:	48 89 e5             	mov    %rsp,%rbp
  80f6fe:	48 83 ec 10          	sub    $0x10,%rsp
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  80f702:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f709:	00 00 00 
  80f70c:	0f b7 00             	movzwl (%rax),%eax
  80f70f:	8d 50 01             	lea    0x1(%rax),%edx
  80f712:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f719:	00 00 00 
  80f71c:	66 89 10             	mov    %dx,(%rax)
  80f71f:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f726:	00 00 00 
  80f729:	0f b7 00             	movzwl (%rax),%eax
  80f72c:	66 85 c0             	test   %ax,%ax
  80f72f:	79 0f                	jns    80f740 <tcp_new_port+0x46>
    port = TCP_LOCAL_PORT_RANGE_START;
  80f731:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f738:	00 00 00 
  80f73b:	66 c7 00 00 10       	movw   $0x1000,(%rax)
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80f740:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f747:	00 00 00 
  80f74a:	48 8b 00             	mov    (%rax),%rax
  80f74d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f751:	eb 28                	jmp    80f77b <tcp_new_port+0x81>
    if (pcb->local_port == port) {
  80f753:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f757:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f75b:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f762:	00 00 00 
  80f765:	0f b7 00             	movzwl (%rax),%eax
  80f768:	66 39 c2             	cmp    %ax,%dx
  80f76b:	75 02                	jne    80f76f <tcp_new_port+0x75>
      goto again;
  80f76d:	eb 93                	jmp    80f702 <tcp_new_port+0x8>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80f76f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f773:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f777:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f77b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f780:	75 d1                	jne    80f753 <tcp_new_port+0x59>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80f782:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80f789:	00 00 00 
  80f78c:	48 8b 00             	mov    (%rax),%rax
  80f78f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f793:	eb 2b                	jmp    80f7c0 <tcp_new_port+0xc6>
    if (pcb->local_port == port) {
  80f795:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f799:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f79d:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f7a4:	00 00 00 
  80f7a7:	0f b7 00             	movzwl (%rax),%eax
  80f7aa:	66 39 c2             	cmp    %ax,%dx
  80f7ad:	75 05                	jne    80f7b4 <tcp_new_port+0xba>
      goto again;
  80f7af:	e9 4e ff ff ff       	jmpq   80f702 <tcp_new_port+0x8>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80f7b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7b8:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f7bc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f7c0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f7c5:	75 ce                	jne    80f795 <tcp_new_port+0x9b>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80f7c7:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f7ce:	00 00 00 
  80f7d1:	48 8b 00             	mov    (%rax),%rax
  80f7d4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f7d8:	eb 2b                	jmp    80f805 <tcp_new_port+0x10b>
    if (pcb->local_port == port) {
  80f7da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7de:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f7e2:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f7e9:	00 00 00 
  80f7ec:	0f b7 00             	movzwl (%rax),%eax
  80f7ef:	66 39 c2             	cmp    %ax,%dx
  80f7f2:	75 05                	jne    80f7f9 <tcp_new_port+0xff>
      goto again;
  80f7f4:	e9 09 ff ff ff       	jmpq   80f702 <tcp_new_port+0x8>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80f7f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7fd:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f801:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f805:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f80a:	75 ce                	jne    80f7da <tcp_new_port+0xe0>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
  80f80c:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f813:	00 00 00 
  80f816:	0f b7 00             	movzwl (%rax),%eax
}
  80f819:	c9                   	leaveq 
  80f81a:	c3                   	retq   

000000000080f81b <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  80f81b:	55                   	push   %rbp
  80f81c:	48 89 e5             	mov    %rsp,%rbp
  80f81f:	48 83 ec 30          	sub    $0x30,%rsp
  80f823:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80f827:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80f82b:	89 d0                	mov    %edx,%eax
  80f82d:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  80f831:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80f835:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f839:	8b 40 18             	mov    0x18(%rax),%eax
  80f83c:	85 c0                	test   %eax,%eax
  80f83e:	74 2a                	je     80f86a <tcp_connect+0x4f>
  80f840:	48 ba 78 26 82 00 00 	movabs $0x822678,%rdx
  80f847:	00 00 00 
  80f84a:	be ed 01 00 00       	mov    $0x1ed,%esi
  80f84f:	48 bf 3b 26 82 00 00 	movabs $0x82263b,%rdi
  80f856:	00 00 00 
  80f859:	b8 00 00 00 00       	mov    $0x0,%eax
  80f85e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80f865:	00 00 00 
  80f868:	ff d1                	callq  *%rcx

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  80f86a:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f86f:	74 28                	je     80f899 <tcp_connect+0x7e>
    pcb->remote_ip = *ipaddr;
  80f871:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f875:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f879:	8b 12                	mov    (%rdx),%edx
  80f87b:	89 50 04             	mov    %edx,0x4(%rax)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  80f87e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f882:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80f886:	66 89 50 2a          	mov    %dx,0x2a(%rax)
  if (pcb->local_port == 0) {
  80f88a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f88e:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f892:	66 85 c0             	test   %ax,%ax
  80f895:	75 22                	jne    80f8b9 <tcp_connect+0x9e>
  80f897:	eb 0a                	jmp    80f8a3 <tcp_connect+0x88>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  80f899:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80f89e:	e9 5a 02 00 00       	jmpq   80fafd <tcp_connect+0x2e2>
  }
  pcb->remote_port = port;
  if (pcb->local_port == 0) {
    pcb->local_port = tcp_new_port();
  80f8a3:	48 b8 fa f6 80 00 00 	movabs $0x80f6fa,%rax
  80f8aa:	00 00 00 
  80f8ad:	ff d0                	callq  *%rax
  80f8af:	89 c2                	mov    %eax,%edx
  80f8b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8b5:	66 89 50 28          	mov    %dx,0x28(%rax)
  }
  iss = tcp_next_iss();
  80f8b9:	48 b8 d5 0c 81 00 00 	movabs $0x810cd5,%rax
  80f8c0:	00 00 00 
  80f8c3:	ff d0                	callq  *%rax
  80f8c5:	89 45 fc             	mov    %eax,-0x4(%rbp)
  pcb->rcv_nxt = 0;
  80f8c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8cc:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
  pcb->snd_nxt = iss;
  80f8d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8d7:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80f8da:	89 50 60             	mov    %edx,0x60(%rax)
  pcb->lastack = iss - 1;
  80f8dd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80f8e0:	8d 50 ff             	lea    -0x1(%rax),%edx
  80f8e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8e7:	89 50 54             	mov    %edx,0x54(%rax)
  pcb->snd_lbb = iss - 1;
  80f8ea:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80f8ed:	8d 50 ff             	lea    -0x1(%rax),%edx
  80f8f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8f4:	89 50 74             	mov    %edx,0x74(%rax)
  pcb->rcv_wnd = TCP_WND;
  80f8f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8fb:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
  pcb->rcv_ann_wnd = TCP_WND;
  80f901:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f905:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
  pcb->snd_wnd = TCP_WND;
  80f90b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f90f:	66 c7 40 68 c0 5d    	movw   $0x5dc0,0x68(%rax)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80f915:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f919:	66 c7 40 40 18 02    	movw   $0x218,0x40(%rax)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  80f91f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f923:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f927:	0f b7 c0             	movzwl %ax,%eax
  80f92a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f92e:	48 89 d6             	mov    %rdx,%rsi
  80f931:	89 c7                	mov    %eax,%edi
  80f933:	48 b8 0d 0d 81 00 00 	movabs $0x810d0d,%rax
  80f93a:	00 00 00 
  80f93d:	ff d0                	callq  *%rax
  80f93f:	89 c2                	mov    %eax,%edx
  80f941:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f945:	66 89 50 40          	mov    %dx,0x40(%rax)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  80f949:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f94d:	66 c7 40 5a 01 00    	movw   $0x1,0x5a(%rax)
  pcb->ssthresh = pcb->mss * 10;
  80f953:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f957:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  80f95b:	89 d0                	mov    %edx,%eax
  80f95d:	c1 e0 02             	shl    $0x2,%eax
  80f960:	01 d0                	add    %edx,%eax
  80f962:	01 c0                	add    %eax,%eax
  80f964:	89 c2                	mov    %eax,%edx
  80f966:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f96a:	66 89 50 5c          	mov    %dx,0x5c(%rax)
  pcb->state = SYN_SENT;
  80f96e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f972:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%rax)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  80f979:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f97d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80f981:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80f988:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f98f:	00 00 00 
  80f992:	48 8b 00             	mov    (%rax),%rax
  80f995:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80f999:	75 23                	jne    80f9be <tcp_connect+0x1a3>
  80f99b:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f9a2:	00 00 00 
  80f9a5:	48 8b 00             	mov    (%rax),%rax
  80f9a8:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f9ac:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f9b3:	00 00 00 
  80f9b6:	48 89 10             	mov    %rdx,(%rax)
  80f9b9:	e9 94 00 00 00       	jmpq   80fa52 <tcp_connect+0x237>
  80f9be:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f9c5:	00 00 00 
  80f9c8:	48 8b 10             	mov    (%rax),%rdx
  80f9cb:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f9d2:	00 00 00 
  80f9d5:	48 89 10             	mov    %rdx,(%rax)
  80f9d8:	eb 66                	jmp    80fa40 <tcp_connect+0x225>
  80f9da:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f9e1:	00 00 00 
  80f9e4:	48 8b 00             	mov    (%rax),%rax
  80f9e7:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f9eb:	48 85 c0             	test   %rax,%rax
  80f9ee:	74 32                	je     80fa22 <tcp_connect+0x207>
  80f9f0:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f9f7:	00 00 00 
  80f9fa:	48 8b 00             	mov    (%rax),%rax
  80f9fd:	48 8b 40 10          	mov    0x10(%rax),%rax
  80fa01:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80fa05:	75 1b                	jne    80fa22 <tcp_connect+0x207>
  80fa07:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80fa0e:	00 00 00 
  80fa11:	48 8b 00             	mov    (%rax),%rax
  80fa14:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80fa18:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80fa1c:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80fa20:	eb 30                	jmp    80fa52 <tcp_connect+0x237>
  80fa22:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80fa29:	00 00 00 
  80fa2c:	48 8b 00             	mov    (%rax),%rax
  80fa2f:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80fa33:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80fa3a:	00 00 00 
  80fa3d:	48 89 10             	mov    %rdx,(%rax)
  80fa40:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80fa47:	00 00 00 
  80fa4a:	48 8b 00             	mov    (%rax),%rax
  80fa4d:	48 85 c0             	test   %rax,%rax
  80fa50:	75 88                	jne    80f9da <tcp_connect+0x1bf>
  80fa52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80fa56:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80fa5d:	00 
  TCP_REG(&tcp_active_pcbs, pcb);
  80fa5e:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fa65:	00 00 00 
  80fa68:	48 8b 10             	mov    (%rax),%rdx
  80fa6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80fa6f:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80fa73:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fa7a:	00 00 00 
  80fa7d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80fa81:	48 89 10             	mov    %rdx,(%rax)
  80fa84:	48 b8 8f 86 80 00 00 	movabs $0x80868f,%rax
  80fa8b:	00 00 00 
  80fa8e:	ff d0                	callq  *%rax

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  80fa90:	bf b4 05 04 02       	mov    $0x20405b4,%edi
  80fa95:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  80fa9c:	00 00 00 
  80fa9f:	ff d0                	callq  *%rax
  80faa1:	89 45 f4             	mov    %eax,-0xc(%rbp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  80faa4:	48 8d 55 f4          	lea    -0xc(%rbp),%rdx
  80faa8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80faac:	48 83 ec 08          	sub    $0x8,%rsp
  80fab0:	6a 04                	pushq  $0x4
  80fab2:	49 89 d1             	mov    %rdx,%r9
  80fab5:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80fabb:	b9 02 00 00 00       	mov    $0x2,%ecx
  80fac0:	ba 00 00 00 00       	mov    $0x0,%edx
  80fac5:	be 00 00 00 00       	mov    $0x0,%esi
  80faca:	48 89 c7             	mov    %rax,%rdi
  80facd:	48 b8 1b 32 81 00 00 	movabs $0x81321b,%rax
  80fad4:	00 00 00 
  80fad7:	ff d0                	callq  *%rax
  80fad9:	48 83 c4 10          	add    $0x10,%rsp
  80fadd:	88 45 fb             	mov    %al,-0x5(%rbp)
  if (ret == ERR_OK) { 
  80fae0:	80 7d fb 00          	cmpb   $0x0,-0x5(%rbp)
  80fae4:	75 13                	jne    80faf9 <tcp_connect+0x2de>
    tcp_output(pcb);
  80fae6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80faea:	48 89 c7             	mov    %rax,%rdi
  80faed:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  80faf4:	00 00 00 
  80faf7:	ff d0                	callq  *%rax
  }
  return ret;
  80faf9:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
} 
  80fafd:	c9                   	leaveq 
  80fafe:	c3                   	retq   

000000000080faff <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  80faff:	55                   	push   %rbp
  80fb00:	48 89 e5             	mov    %rsp,%rbp
  80fb03:	48 83 ec 20          	sub    $0x20,%rsp
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  80fb07:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)

  ++tcp_ticks;
  80fb0b:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fb12:	00 00 00 
  80fb15:	8b 00                	mov    (%rax),%eax
  80fb17:	8d 50 01             	lea    0x1(%rax),%edx
  80fb1a:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fb21:	00 00 00 
  80fb24:	89 10                	mov    %edx,(%rax)

  /* Steps through all of the active PCBs. */
  prev = NULL;
  80fb26:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80fb2d:	00 
  pcb = tcp_active_pcbs;
  80fb2e:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fb35:	00 00 00 
  80fb38:	48 8b 00             	mov    (%rax),%rax
  80fb3b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  80fb3f:	e9 60 06 00 00       	jmpq   8101a4 <tcp_slowtmr+0x6a5>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  80fb44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb48:	8b 40 18             	mov    0x18(%rax),%eax
  80fb4b:	85 c0                	test   %eax,%eax
  80fb4d:	75 2a                	jne    80fb79 <tcp_slowtmr+0x7a>
  80fb4f:	48 ba b0 26 82 00 00 	movabs $0x8226b0,%rdx
  80fb56:	00 00 00 
  80fb59:	be 37 02 00 00       	mov    $0x237,%esi
  80fb5e:	48 bf 3b 26 82 00 00 	movabs $0x82263b,%rdi
  80fb65:	00 00 00 
  80fb68:	b8 00 00 00 00       	mov    $0x0,%eax
  80fb6d:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80fb74:	00 00 00 
  80fb77:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  80fb79:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb7d:	8b 40 18             	mov    0x18(%rax),%eax
  80fb80:	83 f8 01             	cmp    $0x1,%eax
  80fb83:	75 2a                	jne    80fbaf <tcp_slowtmr+0xb0>
  80fb85:	48 ba e0 26 82 00 00 	movabs $0x8226e0,%rdx
  80fb8c:	00 00 00 
  80fb8f:	be 38 02 00 00       	mov    $0x238,%esi
  80fb94:	48 bf 3b 26 82 00 00 	movabs $0x82263b,%rdi
  80fb9b:	00 00 00 
  80fb9e:	b8 00 00 00 00       	mov    $0x0,%eax
  80fba3:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80fbaa:	00 00 00 
  80fbad:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  80fbaf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbb3:	8b 40 18             	mov    0x18(%rax),%eax
  80fbb6:	83 f8 0a             	cmp    $0xa,%eax
  80fbb9:	75 2a                	jne    80fbe5 <tcp_slowtmr+0xe6>
  80fbbb:	48 ba 10 27 82 00 00 	movabs $0x822710,%rdx
  80fbc2:	00 00 00 
  80fbc5:	be 39 02 00 00       	mov    $0x239,%esi
  80fbca:	48 bf 3b 26 82 00 00 	movabs $0x82263b,%rdi
  80fbd1:	00 00 00 
  80fbd4:	b8 00 00 00 00       	mov    $0x0,%eax
  80fbd9:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80fbe0:	00 00 00 
  80fbe3:	ff d1                	callq  *%rcx

    pcb_remove = 0;
  80fbe5:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  80fbe9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbed:	8b 40 18             	mov    0x18(%rax),%eax
  80fbf0:	83 f8 02             	cmp    $0x2,%eax
  80fbf3:	75 15                	jne    80fc0a <tcp_slowtmr+0x10b>
  80fbf5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbf9:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80fbfd:	3c 06                	cmp    $0x6,%al
  80fbff:	75 09                	jne    80fc0a <tcp_slowtmr+0x10b>
      ++pcb_remove;
  80fc01:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
  80fc05:	e9 e6 01 00 00       	jmpq   80fdf0 <tcp_slowtmr+0x2f1>
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  80fc0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc0e:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80fc12:	3c 0c                	cmp    $0xc,%al
  80fc14:	75 09                	jne    80fc1f <tcp_slowtmr+0x120>
      ++pcb_remove;
  80fc16:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  80fc1a:	e9 d1 01 00 00       	jmpq   80fdf0 <tcp_slowtmr+0x2f1>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  80fc1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc23:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80fc2a:	84 c0                	test   %al,%al
  80fc2c:	0f 84 9a 00 00 00    	je     80fccc <tcp_slowtmr+0x1cd>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  80fc32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc36:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80fc3c:	8d 50 01             	lea    0x1(%rax),%edx
  80fc3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc43:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  80fc49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc4d:	8b 88 d4 00 00 00    	mov    0xd4(%rax),%ecx
  80fc53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc57:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80fc5e:	0f b6 c0             	movzbl %al,%eax
  80fc61:	83 e8 01             	sub    $0x1,%eax
  80fc64:	48 ba c5 25 82 00 00 	movabs $0x8225c5,%rdx
  80fc6b:	00 00 00 
  80fc6e:	48 98                	cltq   
  80fc70:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80fc74:	0f b6 c0             	movzbl %al,%eax
  80fc77:	39 c1                	cmp    %eax,%ecx
  80fc79:	0f 82 71 01 00 00    	jb     80fdf0 <tcp_slowtmr+0x2f1>
          pcb->persist_cnt = 0;
  80fc7f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc83:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  80fc8a:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  80fc8d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc91:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80fc98:	3c 06                	cmp    $0x6,%al
  80fc9a:	77 18                	ja     80fcb4 <tcp_slowtmr+0x1b5>
            pcb->persist_backoff++;
  80fc9c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fca0:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80fca7:	8d 50 01             	lea    0x1(%rax),%edx
  80fcaa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcae:	88 90 d8 00 00 00    	mov    %dl,0xd8(%rax)
          }
          tcp_zero_window_probe(pcb);
  80fcb4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcb8:	48 89 c7             	mov    %rax,%rdi
  80fcbb:	48 b8 03 4c 81 00 00 	movabs $0x814c03,%rax
  80fcc2:	00 00 00 
  80fcc5:	ff d0                	callq  *%rax
  80fcc7:	e9 24 01 00 00       	jmpq   80fdf0 <tcp_slowtmr+0x2f1>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  80fccc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcd0:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80fcd4:	66 85 c0             	test   %ax,%ax
  80fcd7:	78 15                	js     80fcee <tcp_slowtmr+0x1ef>
          ++pcb->rtime;
  80fcd9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcdd:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80fce1:	83 c0 01             	add    $0x1,%eax
  80fce4:	89 c2                	mov    %eax,%edx
  80fce6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcea:	66 89 50 3e          	mov    %dx,0x3e(%rax)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  80fcee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcf2:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80fcf9:	48 85 c0             	test   %rax,%rax
  80fcfc:	0f 84 ee 00 00 00    	je     80fdf0 <tcp_slowtmr+0x2f1>
  80fd02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd06:	0f b7 50 3e          	movzwl 0x3e(%rax),%edx
  80fd0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd0e:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80fd12:	66 39 c2             	cmp    %ax,%dx
  80fd15:	0f 8c d5 00 00 00    	jl     80fdf0 <tcp_slowtmr+0x2f1>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  80fd1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd1f:	8b 40 18             	mov    0x18(%rax),%eax
  80fd22:	83 f8 02             	cmp    $0x2,%eax
  80fd25:	74 49                	je     80fd70 <tcp_slowtmr+0x271>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  80fd27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd2b:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80fd2f:	66 c1 f8 03          	sar    $0x3,%ax
  80fd33:	0f bf d0             	movswl %ax,%edx
  80fd36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd3a:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  80fd3e:	98                   	cwtl   
  80fd3f:	8d 34 02             	lea    (%rdx,%rax,1),%esi
  80fd42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd46:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80fd4a:	0f b6 c0             	movzbl %al,%eax
  80fd4d:	48 ba b8 25 82 00 00 	movabs $0x8225b8,%rdx
  80fd54:	00 00 00 
  80fd57:	48 98                	cltq   
  80fd59:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80fd5d:	0f b6 c0             	movzbl %al,%eax
  80fd60:	89 c1                	mov    %eax,%ecx
  80fd62:	d3 e6                	shl    %cl,%esi
  80fd64:	89 f0                	mov    %esi,%eax
  80fd66:	89 c2                	mov    %eax,%edx
  80fd68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd6c:	66 89 50 50          	mov    %dx,0x50(%rax)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  80fd70:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd74:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  80fd7a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd7e:	0f b7 50 68          	movzwl 0x68(%rax),%edx
  80fd82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd86:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  80fd8a:	66 39 c2             	cmp    %ax,%dx
  80fd8d:	0f 46 c2             	cmovbe %edx,%eax
  80fd90:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
          pcb->ssthresh = eff_wnd >> 1;
  80fd94:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  80fd98:	66 d1 e8             	shr    %ax
  80fd9b:	89 c2                	mov    %eax,%edx
  80fd9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fda1:	66 89 50 5c          	mov    %dx,0x5c(%rax)
          if (pcb->ssthresh < pcb->mss) {
  80fda5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fda9:	0f b7 50 5c          	movzwl 0x5c(%rax),%edx
  80fdad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdb1:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80fdb5:	66 39 c2             	cmp    %ax,%dx
  80fdb8:	73 13                	jae    80fdcd <tcp_slowtmr+0x2ce>
            pcb->ssthresh = pcb->mss * 2;
  80fdba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdbe:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80fdc2:	8d 14 00             	lea    (%rax,%rax,1),%edx
  80fdc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdc9:	66 89 50 5c          	mov    %dx,0x5c(%rax)
          }
          pcb->cwnd = pcb->mss;
  80fdcd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdd1:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  80fdd5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdd9:	66 89 50 5a          	mov    %dx,0x5a(%rax)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  80fddd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fde1:	48 89 c7             	mov    %rax,%rdi
  80fde4:	48 b8 21 48 81 00 00 	movabs $0x814821,%rax
  80fdeb:	00 00 00 
  80fdee:	ff d0                	callq  *%rax
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  80fdf0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdf4:	8b 40 18             	mov    0x18(%rax),%eax
  80fdf7:	83 f8 06             	cmp    $0x6,%eax
  80fdfa:	75 20                	jne    80fe1c <tcp_slowtmr+0x31d>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80fdfc:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fe03:	00 00 00 
  80fe06:	8b 10                	mov    (%rax),%edx
  80fe08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe0c:	8b 40 38             	mov    0x38(%rax),%eax
  80fe0f:	29 c2                	sub    %eax,%edx
  80fe11:	89 d0                	mov    %edx,%eax
  80fe13:	83 f8 28             	cmp    $0x28,%eax
  80fe16:	76 04                	jbe    80fe1c <tcp_slowtmr+0x31d>
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80fe18:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  80fe1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe20:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80fe24:	0f b7 c0             	movzwl %ax,%eax
  80fe27:	83 e0 08             	and    $0x8,%eax
  80fe2a:	85 c0                	test   %eax,%eax
  80fe2c:	0f 84 01 01 00 00    	je     80ff33 <tcp_slowtmr+0x434>
       ((pcb->state == ESTABLISHED) || 
  80fe32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe36:	8b 40 18             	mov    0x18(%rax),%eax
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  80fe39:	83 f8 04             	cmp    $0x4,%eax
  80fe3c:	74 10                	je     80fe4e <tcp_slowtmr+0x34f>
       ((pcb->state == ESTABLISHED) || 
        (pcb->state == CLOSE_WAIT))) {
  80fe3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe42:	8b 40 18             	mov    0x18(%rax),%eax
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
       ((pcb->state == ESTABLISHED) || 
  80fe45:	83 f8 07             	cmp    $0x7,%eax
  80fe48:	0f 85 e5 00 00 00    	jne    80ff33 <tcp_slowtmr+0x434>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80fe4e:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fe55:	00 00 00 
  80fe58:	8b 10                	mov    (%rax),%edx
  80fe5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe5e:	8b 40 38             	mov    0x38(%rax),%eax
  80fe61:	29 c2                	sub    %eax,%edx
  80fe63:	89 d0                	mov    %edx,%eax
  80fe65:	89 c1                	mov    %eax,%ecx
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  80fe67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe6b:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80fe71:	89 c0                	mov    %eax,%eax
  80fe73:	48 05 b8 4c 0a 00    	add    $0xa4cb8,%rax
  80fe79:	48 c1 e8 02          	shr    $0x2,%rax
  80fe7d:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  80fe84:	9b c4 20 
  80fe87:	48 f7 e2             	mul    %rdx
  80fe8a:	48 89 d0             	mov    %rdx,%rax
  80fe8d:	48 c1 e8 04          	shr    $0x4,%rax
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80fe91:	48 39 c1             	cmp    %rax,%rcx
  80fe94:	76 18                	jbe    80feae <tcp_slowtmr+0x3af>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  80fe96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe9a:	48 89 c7             	mov    %rax,%rdi
  80fe9d:	48 b8 1c ef 80 00 00 	movabs $0x80ef1c,%rax
  80fea4:	00 00 00 
  80fea7:	ff d0                	callq  *%rax
  80fea9:	e9 85 00 00 00       	jmpq   80ff33 <tcp_slowtmr+0x434>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80feae:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80feb5:	00 00 00 
  80feb8:	8b 10                	mov    (%rax),%edx
  80feba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80febe:	8b 40 38             	mov    0x38(%rax),%eax
  80fec1:	29 c2                	sub    %eax,%edx
  80fec3:	89 d0                	mov    %edx,%eax
  80fec5:	89 c1                	mov    %eax,%ecx
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  80fec7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fecb:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80fed1:	89 c2                	mov    %eax,%edx
  80fed3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fed7:	0f b6 80 d9 00 00 00 	movzbl 0xd9(%rax),%eax
  80fede:	0f b6 c0             	movzbl %al,%eax
  80fee1:	48 69 c0 f8 24 01 00 	imul   $0x124f8,%rax,%rax
  80fee8:	48 01 d0             	add    %rdx,%rax
              / TCP_SLOW_INTERVAL)
  80feeb:	48 c1 e8 02          	shr    $0x2,%rax
  80feef:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  80fef6:	9b c4 20 
  80fef9:	48 f7 e2             	mul    %rdx
  80fefc:	48 89 d0             	mov    %rdx,%rax
  80feff:	48 c1 e8 04          	shr    $0x4,%rax
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80ff03:	48 39 c1             	cmp    %rax,%rcx
  80ff06:	76 2b                	jbe    80ff33 <tcp_slowtmr+0x434>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  80ff08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff0c:	48 89 c7             	mov    %rax,%rdi
  80ff0f:	48 b8 cc 49 81 00 00 	movabs $0x8149cc,%rax
  80ff16:	00 00 00 
  80ff19:	ff d0                	callq  *%rax
        pcb->keep_cnt_sent++;
  80ff1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff1f:	0f b6 80 d9 00 00 00 	movzbl 0xd9(%rax),%eax
  80ff26:	8d 50 01             	lea    0x1(%rax),%edx
  80ff29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff2d:	88 90 d9 00 00 00    	mov    %dl,0xd9(%rax)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80ff33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff37:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80ff3e:	48 85 c0             	test   %rax,%rax
  80ff41:	74 57                	je     80ff9a <tcp_slowtmr+0x49b>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  80ff43:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80ff4a:	00 00 00 
  80ff4d:	8b 10                	mov    (%rax),%edx
  80ff4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff53:	8b 40 38             	mov    0x38(%rax),%eax
  80ff56:	89 d1                	mov    %edx,%ecx
  80ff58:	29 c1                	sub    %eax,%ecx
  80ff5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff5e:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80ff62:	0f bf d0             	movswl %ax,%edx
  80ff65:	89 d0                	mov    %edx,%eax
  80ff67:	01 c0                	add    %eax,%eax
  80ff69:	01 d0                	add    %edx,%eax
  80ff6b:	01 c0                	add    %eax,%eax

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80ff6d:	39 c1                	cmp    %eax,%ecx
  80ff6f:	72 29                	jb     80ff9a <tcp_slowtmr+0x49b>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  80ff71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff75:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80ff7c:	48 89 c7             	mov    %rax,%rdi
  80ff7f:	48 b8 58 04 81 00 00 	movabs $0x810458,%rax
  80ff86:	00 00 00 
  80ff89:	ff d0                	callq  *%rax
      pcb->ooseq = NULL;
  80ff8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff8f:	48 c7 80 90 00 00 00 	movq   $0x0,0x90(%rax)
  80ff96:	00 00 00 00 
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  80ff9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff9e:	8b 40 18             	mov    0x18(%rax),%eax
  80ffa1:	83 f8 03             	cmp    $0x3,%eax
  80ffa4:	75 20                	jne    80ffc6 <tcp_slowtmr+0x4c7>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80ffa6:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80ffad:	00 00 00 
  80ffb0:	8b 10                	mov    (%rax),%edx
  80ffb2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffb6:	8b 40 38             	mov    0x38(%rax),%eax
  80ffb9:	29 c2                	sub    %eax,%edx
  80ffbb:	89 d0                	mov    %edx,%eax
  80ffbd:	83 f8 28             	cmp    $0x28,%eax
  80ffc0:	76 04                	jbe    80ffc6 <tcp_slowtmr+0x4c7>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80ffc2:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  80ffc6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffca:	8b 40 18             	mov    0x18(%rax),%eax
  80ffcd:	83 f8 09             	cmp    $0x9,%eax
  80ffd0:	75 22                	jne    80fff4 <tcp_slowtmr+0x4f5>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80ffd2:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80ffd9:	00 00 00 
  80ffdc:	8b 10                	mov    (%rax),%edx
  80ffde:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffe2:	8b 40 38             	mov    0x38(%rax),%eax
  80ffe5:	29 c2                	sub    %eax,%edx
  80ffe7:	89 d0                	mov    %edx,%eax
  80ffe9:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80ffee:	76 04                	jbe    80fff4 <tcp_slowtmr+0x4f5>
        ++pcb_remove;
  80fff0:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  80fff4:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  80fff8:	0f 84 19 01 00 00    	je     810117 <tcp_slowtmr+0x618>
      tcp_pcb_purge(pcb);      
  80fffe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810002:	48 89 c7             	mov    %rax,%rdi
  810005:	48 b8 d4 09 81 00 00 	movabs $0x8109d4,%rax
  81000c:	00 00 00 
  81000f:	ff d0                	callq  *%rax
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  810011:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  810016:	74 4f                	je     810067 <tcp_slowtmr+0x568>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  810018:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81001f:	00 00 00 
  810022:	48 8b 00             	mov    (%rax),%rax
  810025:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  810029:	75 2a                	jne    810055 <tcp_slowtmr+0x556>
  81002b:	48 ba 40 27 82 00 00 	movabs $0x822740,%rdx
  810032:	00 00 00 
  810035:	be c2 02 00 00       	mov    $0x2c2,%esi
  81003a:	48 bf 3b 26 82 00 00 	movabs $0x82263b,%rdi
  810041:	00 00 00 
  810044:	b8 00 00 00 00       	mov    $0x0,%eax
  810049:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  810050:	00 00 00 
  810053:	ff d1                	callq  *%rcx
        prev->next = pcb->next;
  810055:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810059:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81005d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810061:	48 89 50 10          	mov    %rdx,0x10(%rax)
  810065:	eb 52                	jmp    8100b9 <tcp_slowtmr+0x5ba>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  810067:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81006e:	00 00 00 
  810071:	48 8b 00             	mov    (%rax),%rax
  810074:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  810078:	74 2a                	je     8100a4 <tcp_slowtmr+0x5a5>
  81007a:	48 ba 70 27 82 00 00 	movabs $0x822770,%rdx
  810081:	00 00 00 
  810084:	be c6 02 00 00       	mov    $0x2c6,%esi
  810089:	48 bf 3b 26 82 00 00 	movabs $0x82263b,%rdi
  810090:	00 00 00 
  810093:	b8 00 00 00 00       	mov    $0x0,%eax
  810098:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81009f:	00 00 00 
  8100a2:	ff d1                	callq  *%rcx
        tcp_active_pcbs = pcb->next;
  8100a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100a8:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8100ac:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  8100b3:	00 00 00 
  8100b6:	48 89 10             	mov    %rdx,(%rax)
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  8100b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100bd:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  8100c4:	48 85 c0             	test   %rax,%rax
  8100c7:	74 1d                	je     8100e6 <tcp_slowtmr+0x5e7>
  8100c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100cd:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  8100d4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8100d8:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  8100dc:	be fb ff ff ff       	mov    $0xfffffffb,%esi
  8100e1:	48 89 d7             	mov    %rdx,%rdi
  8100e4:	ff d0                	callq  *%rax

      pcb2 = pcb->next;
  8100e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100ea:	48 8b 40 10          	mov    0x10(%rax),%rax
  8100ee:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_TCP_PCB, pcb);
  8100f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100f6:	48 89 c6             	mov    %rax,%rsi
  8100f9:	bf 02 00 00 00       	mov    $0x2,%edi
  8100fe:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  810105:	00 00 00 
  810108:	ff d0                	callq  *%rax
      pcb = pcb2;
  81010a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81010e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810112:	e9 8d 00 00 00       	jmpq   8101a4 <tcp_slowtmr+0x6a5>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  810117:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81011b:	0f b6 40 3c          	movzbl 0x3c(%rax),%eax
  81011f:	8d 50 01             	lea    0x1(%rax),%edx
  810122:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810126:	88 50 3c             	mov    %dl,0x3c(%rax)
      if (pcb->polltmr >= pcb->pollinterval) {
  810129:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81012d:	0f b6 50 3c          	movzbl 0x3c(%rax),%edx
  810131:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810135:	0f b6 40 3d          	movzbl 0x3d(%rax),%eax
  810139:	38 c2                	cmp    %al,%dl
  81013b:	72 53                	jb     810190 <tcp_slowtmr+0x691>
        pcb->polltmr = 0;
  81013d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810141:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  810145:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810149:	48 8b 80 c0 00 00 00 	mov    0xc0(%rax),%rax
  810150:	48 85 c0             	test   %rax,%rax
  810153:	74 22                	je     810177 <tcp_slowtmr+0x678>
  810155:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810159:	48 8b 80 c0 00 00 00 	mov    0xc0(%rax),%rax
  810160:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  810164:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  810168:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81016c:	48 89 ce             	mov    %rcx,%rsi
  81016f:	48 89 d7             	mov    %rdx,%rdi
  810172:	ff d0                	callq  *%rax
  810174:	88 45 ee             	mov    %al,-0x12(%rbp)
        if (err == ERR_OK) {
  810177:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  81017b:	75 13                	jne    810190 <tcp_slowtmr+0x691>
          tcp_output(pcb);
  81017d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810181:	48 89 c7             	mov    %rax,%rdi
  810184:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  81018b:	00 00 00 
  81018e:	ff d0                	callq  *%rax
        }
      }
      
      prev = pcb;
  810190:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810194:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb = pcb->next;
  810198:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81019c:	48 8b 40 10          	mov    0x10(%rax),%rax
  8101a0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  8101a4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8101a9:	0f 85 95 f9 ff ff    	jne    80fb44 <tcp_slowtmr+0x45>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  8101af:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8101b6:	00 
  pcb = tcp_tw_pcbs;
  8101b7:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  8101be:	00 00 00 
  8101c1:	48 8b 00             	mov    (%rax),%rax
  8101c4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (pcb != NULL) {
  8101c8:	e9 63 01 00 00       	jmpq   810330 <tcp_slowtmr+0x831>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  8101cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8101d1:	8b 40 18             	mov    0x18(%rax),%eax
  8101d4:	83 f8 0a             	cmp    $0xa,%eax
  8101d7:	74 2a                	je     810203 <tcp_slowtmr+0x704>
  8101d9:	48 ba a0 27 82 00 00 	movabs $0x8227a0,%rdx
  8101e0:	00 00 00 
  8101e3:	be e6 02 00 00       	mov    $0x2e6,%esi
  8101e8:	48 bf 3b 26 82 00 00 	movabs $0x82263b,%rdi
  8101ef:	00 00 00 
  8101f2:	b8 00 00 00 00       	mov    $0x0,%eax
  8101f7:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8101fe:	00 00 00 
  810201:	ff d1                	callq  *%rcx
    pcb_remove = 0;
  810203:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  810207:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81020e:	00 00 00 
  810211:	8b 10                	mov    (%rax),%edx
  810213:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810217:	8b 40 38             	mov    0x38(%rax),%eax
  81021a:	29 c2                	sub    %eax,%edx
  81021c:	89 d0                	mov    %edx,%eax
  81021e:	3d f0 00 00 00       	cmp    $0xf0,%eax
  810223:	76 04                	jbe    810229 <tcp_slowtmr+0x72a>
      ++pcb_remove;
  810225:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  810229:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  81022d:	0f 84 e9 00 00 00    	je     81031c <tcp_slowtmr+0x81d>
      tcp_pcb_purge(pcb);      
  810233:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810237:	48 89 c7             	mov    %rax,%rdi
  81023a:	48 b8 d4 09 81 00 00 	movabs $0x8109d4,%rax
  810241:	00 00 00 
  810244:	ff d0                	callq  *%rax
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  810246:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81024b:	74 4f                	je     81029c <tcp_slowtmr+0x79d>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  81024d:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  810254:	00 00 00 
  810257:	48 8b 00             	mov    (%rax),%rax
  81025a:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  81025e:	75 2a                	jne    81028a <tcp_slowtmr+0x78b>
  810260:	48 ba d0 27 82 00 00 	movabs $0x8227d0,%rdx
  810267:	00 00 00 
  81026a:	be f5 02 00 00       	mov    $0x2f5,%esi
  81026f:	48 bf 3b 26 82 00 00 	movabs $0x82263b,%rdi
  810276:	00 00 00 
  810279:	b8 00 00 00 00       	mov    $0x0,%eax
  81027e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  810285:	00 00 00 
  810288:	ff d1                	callq  *%rcx
        prev->next = pcb->next;
  81028a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81028e:	48 8b 50 10          	mov    0x10(%rax),%rdx
  810292:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810296:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81029a:	eb 52                	jmp    8102ee <tcp_slowtmr+0x7ef>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  81029c:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  8102a3:	00 00 00 
  8102a6:	48 8b 00             	mov    (%rax),%rax
  8102a9:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8102ad:	74 2a                	je     8102d9 <tcp_slowtmr+0x7da>
  8102af:	48 ba f8 27 82 00 00 	movabs $0x8227f8,%rdx
  8102b6:	00 00 00 
  8102b9:	be f9 02 00 00       	mov    $0x2f9,%esi
  8102be:	48 bf 3b 26 82 00 00 	movabs $0x82263b,%rdi
  8102c5:	00 00 00 
  8102c8:	b8 00 00 00 00       	mov    $0x0,%eax
  8102cd:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8102d4:	00 00 00 
  8102d7:	ff d1                	callq  *%rcx
        tcp_tw_pcbs = pcb->next;
  8102d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102dd:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8102e1:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  8102e8:	00 00 00 
  8102eb:	48 89 10             	mov    %rdx,(%rax)
      }
      pcb2 = pcb->next;
  8102ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102f2:	48 8b 40 10          	mov    0x10(%rax),%rax
  8102f6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_TCP_PCB, pcb);
  8102fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102fe:	48 89 c6             	mov    %rax,%rsi
  810301:	bf 02 00 00 00       	mov    $0x2,%edi
  810306:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  81030d:	00 00 00 
  810310:	ff d0                	callq  *%rax
      pcb = pcb2;
  810312:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810316:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81031a:	eb 14                	jmp    810330 <tcp_slowtmr+0x831>
    } else {
      prev = pcb;
  81031c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810320:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb = pcb->next;
  810324:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810328:	48 8b 40 10          	mov    0x10(%rax),%rax
  81032c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  810330:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810335:	0f 85 92 fe ff ff    	jne    8101cd <tcp_slowtmr+0x6ce>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  81033b:	90                   	nop
  81033c:	c9                   	leaveq 
  81033d:	c3                   	retq   

000000000081033e <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  81033e:	55                   	push   %rbp
  81033f:	48 89 e5             	mov    %rsp,%rbp
  810342:	48 83 ec 10          	sub    $0x10,%rsp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  810346:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81034d:	00 00 00 
  810350:	48 8b 00             	mov    (%rax),%rax
  810353:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810357:	e9 ee 00 00 00       	jmpq   81044a <tcp_fasttmr+0x10c>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  81035c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810360:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  810367:	48 85 c0             	test   %rax,%rax
  81036a:	0f 84 81 00 00 00    	je     8103f1 <tcp_fasttmr+0xb3>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  810370:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810374:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81037b:	48 85 c0             	test   %rax,%rax
  81037e:	74 2e                	je     8103ae <tcp_fasttmr+0x70>
  810380:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810384:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81038b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81038f:	48 8b 92 98 00 00 00 	mov    0x98(%rdx),%rdx
  810396:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81039a:	48 8b 79 20          	mov    0x20(%rcx),%rdi
  81039e:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8103a2:	b9 00 00 00 00       	mov    $0x0,%ecx
  8103a7:	ff d0                	callq  *%rax
  8103a9:	88 45 f7             	mov    %al,-0x9(%rbp)
  8103ac:	eb 2e                	jmp    8103dc <tcp_fasttmr+0x9e>
  8103ae:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  8103b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103b6:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  8103bd:	48 85 c0             	test   %rax,%rax
  8103c0:	74 1a                	je     8103dc <tcp_fasttmr+0x9e>
  8103c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103c6:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  8103cd:	48 89 c7             	mov    %rax,%rdi
  8103d0:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  8103d7:	00 00 00 
  8103da:	ff d0                	callq  *%rax
      if (err == ERR_OK) {
  8103dc:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  8103e0:	75 0f                	jne    8103f1 <tcp_fasttmr+0xb3>
        pcb->refused_data = NULL;
  8103e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103e6:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  8103ed:	00 00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  8103f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103f5:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8103f9:	0f b6 c0             	movzbl %al,%eax
  8103fc:	83 e0 01             	and    $0x1,%eax
  8103ff:	85 c0                	test   %eax,%eax
  810401:	74 3b                	je     81043e <tcp_fasttmr+0x100>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  810403:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810407:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81040b:	83 c8 02             	or     $0x2,%eax
  81040e:	89 c2                	mov    %eax,%edx
  810410:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810414:	88 50 2c             	mov    %dl,0x2c(%rax)
  810417:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81041b:	48 89 c7             	mov    %rax,%rdi
  81041e:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  810425:	00 00 00 
  810428:	ff d0                	callq  *%rax
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  81042a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81042e:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  810432:	83 e0 fc             	and    $0xfffffffc,%eax
  810435:	89 c2                	mov    %eax,%edx
  810437:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81043b:	88 50 2c             	mov    %dl,0x2c(%rax)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81043e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810442:	48 8b 40 10          	mov    0x10(%rax),%rax
  810446:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81044a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81044f:	0f 85 07 ff ff ff    	jne    81035c <tcp_fasttmr+0x1e>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  810455:	90                   	nop
  810456:	c9                   	leaveq 
  810457:	c3                   	retq   

0000000000810458 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  810458:	55                   	push   %rbp
  810459:	48 89 e5             	mov    %rsp,%rbp
  81045c:	48 83 ec 20          	sub    $0x20,%rsp
  810460:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t count = 0;
  810464:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  struct tcp_seg *next;
  while (seg != NULL) {
  810468:	eb 29                	jmp    810493 <tcp_segs_free+0x3b>
    next = seg->next;
  81046a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81046e:	48 8b 00             	mov    (%rax),%rax
  810471:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    count += tcp_seg_free(seg);
  810475:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810479:	48 89 c7             	mov    %rax,%rdi
  81047c:	48 b8 a0 04 81 00 00 	movabs $0x8104a0,%rax
  810483:	00 00 00 
  810486:	ff d0                	callq  *%rax
  810488:	00 45 ff             	add    %al,-0x1(%rbp)
    seg = next;
  81048b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81048f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  810493:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  810498:	75 d0                	jne    81046a <tcp_segs_free+0x12>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
  81049a:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  81049e:	c9                   	leaveq 
  81049f:	c3                   	retq   

00000000008104a0 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  8104a0:	55                   	push   %rbp
  8104a1:	48 89 e5             	mov    %rsp,%rbp
  8104a4:	48 83 ec 20          	sub    $0x20,%rsp
  8104a8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t count = 0;
  8104ac:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  
  if (seg != NULL) {
  8104b0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8104b5:	74 3f                	je     8104f6 <tcp_seg_free+0x56>
    if (seg->p != NULL) {
  8104b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8104bb:	48 8b 40 08          	mov    0x8(%rax),%rax
  8104bf:	48 85 c0             	test   %rax,%rax
  8104c2:	74 1a                	je     8104de <tcp_seg_free+0x3e>
      count = pbuf_free(seg->p);
  8104c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8104c8:	48 8b 40 08          	mov    0x8(%rax),%rax
  8104cc:	48 89 c7             	mov    %rax,%rdi
  8104cf:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  8104d6:	00 00 00 
  8104d9:	ff d0                	callq  *%rax
  8104db:	88 45 ff             	mov    %al,-0x1(%rbp)
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  8104de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8104e2:	48 89 c6             	mov    %rax,%rsi
  8104e5:	bf 04 00 00 00       	mov    $0x4,%edi
  8104ea:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  8104f1:	00 00 00 
  8104f4:	ff d0                	callq  *%rax
  }
  return count;
  8104f6:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  8104fa:	c9                   	leaveq 
  8104fb:	c3                   	retq   

00000000008104fc <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  8104fc:	55                   	push   %rbp
  8104fd:	48 89 e5             	mov    %rsp,%rbp
  810500:	48 83 ec 10          	sub    $0x10,%rsp
  810504:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810508:	89 f0                	mov    %esi,%eax
  81050a:	88 45 f4             	mov    %al,-0xc(%rbp)
  pcb->prio = prio;
  81050d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810511:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  810515:	88 50 1c             	mov    %dl,0x1c(%rax)
}
  810518:	90                   	nop
  810519:	c9                   	leaveq 
  81051a:	c3                   	retq   

000000000081051b <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  81051b:	55                   	push   %rbp
  81051c:	48 89 e5             	mov    %rsp,%rbp
  81051f:	48 83 ec 20          	sub    $0x20,%rsp
  810523:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  810527:	bf 04 00 00 00       	mov    $0x4,%edi
  81052c:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  810533:	00 00 00 
  810536:	ff d0                	callq  *%rax
  810538:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (cseg == NULL) {
  81053c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810541:	75 07                	jne    81054a <tcp_seg_copy+0x2f>
    return NULL;
  810543:	b8 00 00 00 00       	mov    $0x0,%eax
  810548:	eb 3a                	jmp    810584 <tcp_seg_copy+0x69>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  81054a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81054e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810552:	ba 28 00 00 00       	mov    $0x28,%edx
  810557:	48 89 ce             	mov    %rcx,%rsi
  81055a:	48 89 c7             	mov    %rax,%rdi
  81055d:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  810564:	00 00 00 
  810567:	ff d0                	callq  *%rax
  pbuf_ref(cseg->p);
  810569:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81056d:	48 8b 40 08          	mov    0x8(%rax),%rax
  810571:	48 89 c7             	mov    %rax,%rdi
  810574:	48 b8 30 df 80 00 00 	movabs $0x80df30,%rax
  81057b:	00 00 00 
  81057e:	ff d0                	callq  *%rax
  return cseg;
  810580:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  810584:	c9                   	leaveq 
  810585:	c3                   	retq   

0000000000810586 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  810586:	55                   	push   %rbp
  810587:	48 89 e5             	mov    %rsp,%rbp
  81058a:	48 83 ec 20          	sub    $0x20,%rsp
  81058e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810592:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  810596:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  81059a:	89 c8                	mov    %ecx,%eax
  81059c:	88 45 e4             	mov    %al,-0x1c(%rbp)
  arg = arg;
  if (p != NULL) {
  81059f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8105a4:	74 15                	je     8105bb <tcp_recv_null+0x35>
    pbuf_free(p);
  8105a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8105aa:	48 89 c7             	mov    %rax,%rdi
  8105ad:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  8105b4:	00 00 00 
  8105b7:	ff d0                	callq  *%rax
  8105b9:	eb 1b                	jmp    8105d6 <tcp_recv_null+0x50>
  } else if (err == ERR_OK) {
  8105bb:	80 7d e4 00          	cmpb   $0x0,-0x1c(%rbp)
  8105bf:	75 15                	jne    8105d6 <tcp_recv_null+0x50>
    return tcp_close(pcb);
  8105c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8105c5:	48 89 c7             	mov    %rax,%rdi
  8105c8:	48 b8 94 ec 80 00 00 	movabs $0x80ec94,%rax
  8105cf:	00 00 00 
  8105d2:	ff d0                	callq  *%rax
  8105d4:	eb 05                	jmp    8105db <tcp_recv_null+0x55>
  }
  return ERR_OK;
  8105d6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8105db:	c9                   	leaveq 
  8105dc:	c3                   	retq   

00000000008105dd <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
  8105dd:	55                   	push   %rbp
  8105de:	48 89 e5             	mov    %rsp,%rbp
  8105e1:	48 83 ec 30          	sub    $0x30,%rsp
  8105e5:	89 f8                	mov    %edi,%eax
  8105e7:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  8105ea:	c6 45 eb 7f          	movb   $0x7f,-0x15(%rbp)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  8105ee:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  inactive = NULL;
  8105f5:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8105fc:	00 
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8105fd:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  810604:	00 00 00 
  810607:	48 8b 00             	mov    (%rax),%rax
  81060a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81060e:	eb 6f                	jmp    81067f <tcp_kill_prio+0xa2>
    if (pcb->prio <= prio &&
  810610:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810614:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  810618:	3a 45 dc             	cmp    -0x24(%rbp),%al
  81061b:	77 56                	ja     810673 <tcp_kill_prio+0x96>
       pcb->prio <= mprio &&
  81061d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810621:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  810625:	3a 45 eb             	cmp    -0x15(%rbp),%al
  810628:	77 49                	ja     810673 <tcp_kill_prio+0x96>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  81062a:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810631:	00 00 00 
  810634:	8b 10                	mov    (%rax),%edx
  810636:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81063a:	8b 40 38             	mov    0x38(%rax),%eax
  81063d:	29 c2                	sub    %eax,%edx
  81063f:	89 d0                	mov    %edx,%eax
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
  810641:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  810644:	72 2d                	jb     810673 <tcp_kill_prio+0x96>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  810646:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81064d:	00 00 00 
  810650:	8b 10                	mov    (%rax),%edx
  810652:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810656:	8b 40 38             	mov    0x38(%rax),%eax
  810659:	29 c2                	sub    %eax,%edx
  81065b:	89 d0                	mov    %edx,%eax
  81065d:	89 45 ec             	mov    %eax,-0x14(%rbp)
      inactive = pcb;
  810660:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810664:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      mprio = pcb->prio;
  810668:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81066c:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  810670:	88 45 eb             	mov    %al,-0x15(%rbp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  810673:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810677:	48 8b 40 10          	mov    0x10(%rax),%rax
  81067b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81067f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810684:	75 8a                	jne    810610 <tcp_kill_prio+0x33>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  810686:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81068b:	74 13                	je     8106a0 <tcp_kill_prio+0xc3>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  81068d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810691:	48 89 c7             	mov    %rax,%rdi
  810694:	48 b8 1c ef 80 00 00 	movabs $0x80ef1c,%rax
  81069b:	00 00 00 
  81069e:	ff d0                	callq  *%rax
  }      
}
  8106a0:	90                   	nop
  8106a1:	c9                   	leaveq 
  8106a2:	c3                   	retq   

00000000008106a3 <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
  8106a3:	55                   	push   %rbp
  8106a4:	48 89 e5             	mov    %rsp,%rbp
  8106a7:	48 83 ec 20          	sub    $0x20,%rsp
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  8106ab:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  inactive = NULL;
  8106b2:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8106b9:	00 
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8106ba:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  8106c1:	00 00 00 
  8106c4:	48 8b 00             	mov    (%rax),%rax
  8106c7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8106cb:	eb 4a                	jmp    810717 <tcp_kill_timewait+0x74>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8106cd:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  8106d4:	00 00 00 
  8106d7:	8b 10                	mov    (%rax),%edx
  8106d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106dd:	8b 40 38             	mov    0x38(%rax),%eax
  8106e0:	29 c2                	sub    %eax,%edx
  8106e2:	89 d0                	mov    %edx,%eax
  8106e4:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8106e7:	72 22                	jb     81070b <tcp_kill_timewait+0x68>
      inactivity = tcp_ticks - pcb->tmr;
  8106e9:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  8106f0:	00 00 00 
  8106f3:	8b 10                	mov    (%rax),%edx
  8106f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106f9:	8b 40 38             	mov    0x38(%rax),%eax
  8106fc:	29 c2                	sub    %eax,%edx
  8106fe:	89 d0                	mov    %edx,%eax
  810700:	89 45 ec             	mov    %eax,-0x14(%rbp)
      inactive = pcb;
  810703:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810707:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  81070b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81070f:	48 8b 40 10          	mov    0x10(%rax),%rax
  810713:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810717:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81071c:	75 af                	jne    8106cd <tcp_kill_timewait+0x2a>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  81071e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  810723:	74 13                	je     810738 <tcp_kill_timewait+0x95>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  810725:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810729:	48 89 c7             	mov    %rax,%rdi
  81072c:	48 b8 1c ef 80 00 00 	movabs $0x80ef1c,%rax
  810733:	00 00 00 
  810736:	ff d0                	callq  *%rax
  }      
}
  810738:	90                   	nop
  810739:	c9                   	leaveq 
  81073a:	c3                   	retq   

000000000081073b <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  81073b:	55                   	push   %rbp
  81073c:	48 89 e5             	mov    %rsp,%rbp
  81073f:	48 83 ec 20          	sub    $0x20,%rsp
  810743:	89 f8                	mov    %edi,%eax
  810745:	88 45 ec             	mov    %al,-0x14(%rbp)
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  810748:	bf 02 00 00 00       	mov    $0x2,%edi
  81074d:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  810754:	00 00 00 
  810757:	ff d0                	callq  *%rax
  810759:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (pcb == NULL) {
  81075d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810762:	75 4f                	jne    8107b3 <tcp_alloc+0x78>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
  810764:	48 b8 a3 06 81 00 00 	movabs $0x8106a3,%rax
  81076b:	00 00 00 
  81076e:	ff d0                	callq  *%rax
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  810770:	bf 02 00 00 00       	mov    $0x2,%edi
  810775:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  81077c:	00 00 00 
  81077f:	ff d0                	callq  *%rax
  810781:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (pcb == NULL) {
  810785:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81078a:	75 27                	jne    8107b3 <tcp_alloc+0x78>
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
  81078c:	0f b6 45 ec          	movzbl -0x14(%rbp),%eax
  810790:	89 c7                	mov    %eax,%edi
  810792:	48 b8 dd 05 81 00 00 	movabs $0x8105dd,%rax
  810799:	00 00 00 
  81079c:	ff d0                	callq  *%rax
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  81079e:	bf 02 00 00 00       	mov    $0x2,%edi
  8107a3:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  8107aa:	00 00 00 
  8107ad:	ff d0                	callq  *%rax
  8107af:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    }
  }
  if (pcb != NULL) {
  8107b3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8107b8:	0f 84 23 01 00 00    	je     8108e1 <tcp_alloc+0x1a6>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  8107be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8107c2:	ba e0 00 00 00       	mov    $0xe0,%edx
  8107c7:	be 00 00 00 00       	mov    $0x0,%esi
  8107cc:	48 89 c7             	mov    %rax,%rdi
  8107cf:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  8107d6:	00 00 00 
  8107d9:	ff d0                	callq  *%rax
    pcb->prio = TCP_PRIO_NORMAL;
  8107db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8107df:	c6 40 1c 40          	movb   $0x40,0x1c(%rax)
    pcb->snd_buf = TCP_SND_BUF;
  8107e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8107e7:	66 c7 40 7a 40 5b    	movw   $0x5b40,0x7a(%rax)
    pcb->snd_queuelen = 0;
  8107ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8107f1:	66 c7 40 7c 00 00    	movw   $0x0,0x7c(%rax)
    pcb->rcv_wnd = TCP_WND;
  8107f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8107fb:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
    pcb->rcv_ann_wnd = TCP_WND;
  810801:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810805:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
    pcb->tos = 0;
  81080b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81080f:	c6 40 0a 00          	movb   $0x0,0xa(%rax)
    pcb->ttl = TCP_TTL;
  810813:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810817:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  81081b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81081f:	66 c7 40 40 18 02    	movw   $0x218,0x40(%rax)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  810825:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810829:	66 c7 40 50 06 00    	movw   $0x6,0x50(%rax)
    pcb->sa = 0;
  81082f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810833:	66 c7 40 4c 00 00    	movw   $0x0,0x4c(%rax)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  810839:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81083d:	66 c7 40 4e 06 00    	movw   $0x6,0x4e(%rax)
    pcb->rtime = -1;
  810843:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810847:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
    pcb->cwnd = 1;
  81084d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810851:	66 c7 40 5a 01 00    	movw   $0x1,0x5a(%rax)
    iss = tcp_next_iss();
  810857:	48 b8 d5 0c 81 00 00 	movabs $0x810cd5,%rax
  81085e:	00 00 00 
  810861:	ff d0                	callq  *%rax
  810863:	89 45 f4             	mov    %eax,-0xc(%rbp)
    pcb->snd_wl2 = iss;
  810866:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81086a:	8b 55 f4             	mov    -0xc(%rbp),%edx
  81086d:	89 50 70             	mov    %edx,0x70(%rax)
    pcb->snd_nxt = iss;
  810870:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810874:	8b 55 f4             	mov    -0xc(%rbp),%edx
  810877:	89 50 60             	mov    %edx,0x60(%rax)
    pcb->snd_max = iss;
  81087a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81087e:	8b 55 f4             	mov    -0xc(%rbp),%edx
  810881:	89 50 64             	mov    %edx,0x64(%rax)
    pcb->lastack = iss;
  810884:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810888:	8b 55 f4             	mov    -0xc(%rbp),%edx
  81088b:	89 50 54             	mov    %edx,0x54(%rax)
    pcb->snd_lbb = iss;   
  81088e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810892:	8b 55 f4             	mov    -0xc(%rbp),%edx
  810895:	89 50 74             	mov    %edx,0x74(%rax)
    pcb->tmr = tcp_ticks;
  810898:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81089f:	00 00 00 
  8108a2:	8b 10                	mov    (%rax),%edx
  8108a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108a8:	89 50 38             	mov    %edx,0x38(%rax)

    pcb->polltmr = 0;
  8108ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108af:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  8108b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108b7:	48 b9 86 05 81 00 00 	movabs $0x810586,%rcx
  8108be:	00 00 00 
  8108c1:	48 89 88 a8 00 00 00 	mov    %rcx,0xa8(%rax)
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  8108c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108cc:	c7 80 d0 00 00 00 00 	movl   $0x6ddd00,0xd0(%rax)
  8108d3:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  8108d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108da:	c6 80 d9 00 00 00 00 	movb   $0x0,0xd9(%rax)
  }
  return pcb;
  8108e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8108e5:	c9                   	leaveq 
  8108e6:	c3                   	retq   

00000000008108e7 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  8108e7:	55                   	push   %rbp
  8108e8:	48 89 e5             	mov    %rsp,%rbp
  return tcp_alloc(TCP_PRIO_NORMAL);
  8108eb:	bf 40 00 00 00       	mov    $0x40,%edi
  8108f0:	48 b8 3b 07 81 00 00 	movabs $0x81073b,%rax
  8108f7:	00 00 00 
  8108fa:	ff d0                	callq  *%rax
}
  8108fc:	5d                   	pop    %rbp
  8108fd:	c3                   	retq   

00000000008108fe <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  8108fe:	55                   	push   %rbp
  8108ff:	48 89 e5             	mov    %rsp,%rbp
  810902:	48 83 ec 10          	sub    $0x10,%rsp
  810906:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81090a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->callback_arg = arg;
  81090e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810912:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  810916:	48 89 50 20          	mov    %rdx,0x20(%rax)
}
  81091a:	90                   	nop
  81091b:	c9                   	leaveq 
  81091c:	c3                   	retq   

000000000081091d <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  81091d:	55                   	push   %rbp
  81091e:	48 89 e5             	mov    %rsp,%rbp
  810921:	48 83 ec 10          	sub    $0x10,%rsp
  810925:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810929:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->recv = recv;
  81092d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810931:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  810935:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
}
  81093c:	90                   	nop
  81093d:	c9                   	leaveq 
  81093e:	c3                   	retq   

000000000081093f <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  81093f:	55                   	push   %rbp
  810940:	48 89 e5             	mov    %rsp,%rbp
  810943:	48 83 ec 10          	sub    $0x10,%rsp
  810947:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81094b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->sent = sent;
  81094f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810953:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  810957:	48 89 90 a0 00 00 00 	mov    %rdx,0xa0(%rax)
}
  81095e:	90                   	nop
  81095f:	c9                   	leaveq 
  810960:	c3                   	retq   

0000000000810961 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  810961:	55                   	push   %rbp
  810962:	48 89 e5             	mov    %rsp,%rbp
  810965:	48 83 ec 10          	sub    $0x10,%rsp
  810969:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81096d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->errf = errf;
  810971:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810975:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  810979:	48 89 90 c8 00 00 00 	mov    %rdx,0xc8(%rax)
}
  810980:	90                   	nop
  810981:	c9                   	leaveq 
  810982:	c3                   	retq   

0000000000810983 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  810983:	55                   	push   %rbp
  810984:	48 89 e5             	mov    %rsp,%rbp
  810987:	48 83 ec 10          	sub    $0x10,%rsp
  81098b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81098f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  810993:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810997:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81099b:	48 89 50 30          	mov    %rdx,0x30(%rax)
}
  81099f:	90                   	nop
  8109a0:	c9                   	leaveq 
  8109a1:	c3                   	retq   

00000000008109a2 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  8109a2:	55                   	push   %rbp
  8109a3:	48 89 e5             	mov    %rsp,%rbp
  8109a6:	48 83 ec 18          	sub    $0x18,%rsp
  8109aa:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8109ae:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8109b2:	89 d0                	mov    %edx,%eax
  8109b4:	88 45 ec             	mov    %al,-0x14(%rbp)
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  8109b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8109bb:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8109bf:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  8109c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8109ca:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  8109ce:	88 50 3d             	mov    %dl,0x3d(%rax)
}
  8109d1:	90                   	nop
  8109d2:	c9                   	leaveq 
  8109d3:	c3                   	retq   

00000000008109d4 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  8109d4:	55                   	push   %rbp
  8109d5:	48 89 e5             	mov    %rsp,%rbp
  8109d8:	48 83 ec 10          	sub    $0x10,%rsp
  8109dc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (pcb->state != CLOSED &&
  8109e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8109e4:	8b 40 18             	mov    0x18(%rax),%eax
  8109e7:	85 c0                	test   %eax,%eax
  8109e9:	0f 84 e5 00 00 00    	je     810ad4 <tcp_pcb_purge+0x100>
     pcb->state != TIME_WAIT &&
  8109ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8109f3:	8b 40 18             	mov    0x18(%rax),%eax
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
  8109f6:	83 f8 0a             	cmp    $0xa,%eax
  8109f9:	0f 84 d5 00 00 00    	je     810ad4 <tcp_pcb_purge+0x100>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {
  8109ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a03:	8b 40 18             	mov    0x18(%rax),%eax
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
  810a06:	83 f8 01             	cmp    $0x1,%eax
  810a09:	0f 84 c5 00 00 00    	je     810ad4 <tcp_pcb_purge+0x100>
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  810a0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a13:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  810a1a:	48 85 c0             	test   %rax,%rax
  810a1d:	74 29                	je     810a48 <tcp_pcb_purge+0x74>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  810a1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a23:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  810a2a:	48 89 c7             	mov    %rax,%rdi
  810a2d:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  810a34:	00 00 00 
  810a37:	ff d0                	callq  *%rax
      pcb->refused_data = NULL;
  810a39:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a3d:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  810a44:	00 00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  810a48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a4c:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)

    tcp_segs_free(pcb->ooseq);
  810a52:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a56:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  810a5d:	48 89 c7             	mov    %rax,%rdi
  810a60:	48 b8 58 04 81 00 00 	movabs $0x810458,%rax
  810a67:	00 00 00 
  810a6a:	ff d0                	callq  *%rax
    pcb->ooseq = NULL;
  810a6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a70:	48 c7 80 90 00 00 00 	movq   $0x0,0x90(%rax)
  810a77:	00 00 00 00 
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  810a7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a7f:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  810a86:	48 89 c7             	mov    %rax,%rdi
  810a89:	48 b8 58 04 81 00 00 	movabs $0x810458,%rax
  810a90:	00 00 00 
  810a93:	ff d0                	callq  *%rax
    tcp_segs_free(pcb->unacked);
  810a95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a99:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  810aa0:	48 89 c7             	mov    %rax,%rdi
  810aa3:	48 b8 58 04 81 00 00 	movabs $0x810458,%rax
  810aaa:	00 00 00 
  810aad:	ff d0                	callq  *%rax
    pcb->unacked = pcb->unsent = NULL;
  810aaf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810ab3:	48 c7 80 80 00 00 00 	movq   $0x0,0x80(%rax)
  810aba:	00 00 00 00 
  810abe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810ac2:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
  810ac9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810acd:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
  }
}
  810ad4:	90                   	nop
  810ad5:	c9                   	leaveq 
  810ad6:	c3                   	retq   

0000000000810ad7 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  810ad7:	55                   	push   %rbp
  810ad8:	48 89 e5             	mov    %rsp,%rbp
  810adb:	48 83 ec 10          	sub    $0x10,%rsp
  810adf:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810ae3:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  TCP_RMV(pcblist, pcb);
  810ae7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810aeb:	48 8b 00             	mov    (%rax),%rax
  810aee:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  810af2:	75 17                	jne    810b0b <tcp_pcb_remove+0x34>
  810af4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810af8:	48 8b 00             	mov    (%rax),%rax
  810afb:	48 8b 50 10          	mov    0x10(%rax),%rdx
  810aff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810b03:	48 89 10             	mov    %rdx,(%rax)
  810b06:	e9 8e 00 00 00       	jmpq   810b99 <tcp_pcb_remove+0xc2>
  810b0b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810b0f:	48 8b 10             	mov    (%rax),%rdx
  810b12:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810b19:	00 00 00 
  810b1c:	48 89 10             	mov    %rdx,(%rax)
  810b1f:	eb 66                	jmp    810b87 <tcp_pcb_remove+0xb0>
  810b21:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810b28:	00 00 00 
  810b2b:	48 8b 00             	mov    (%rax),%rax
  810b2e:	48 8b 40 10          	mov    0x10(%rax),%rax
  810b32:	48 85 c0             	test   %rax,%rax
  810b35:	74 32                	je     810b69 <tcp_pcb_remove+0x92>
  810b37:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810b3e:	00 00 00 
  810b41:	48 8b 00             	mov    (%rax),%rax
  810b44:	48 8b 40 10          	mov    0x10(%rax),%rax
  810b48:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  810b4c:	75 1b                	jne    810b69 <tcp_pcb_remove+0x92>
  810b4e:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810b55:	00 00 00 
  810b58:	48 8b 00             	mov    (%rax),%rax
  810b5b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  810b5f:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  810b63:	48 89 50 10          	mov    %rdx,0x10(%rax)
  810b67:	eb 30                	jmp    810b99 <tcp_pcb_remove+0xc2>
  810b69:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810b70:	00 00 00 
  810b73:	48 8b 00             	mov    (%rax),%rax
  810b76:	48 8b 50 10          	mov    0x10(%rax),%rdx
  810b7a:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810b81:	00 00 00 
  810b84:	48 89 10             	mov    %rdx,(%rax)
  810b87:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810b8e:	00 00 00 
  810b91:	48 8b 00             	mov    (%rax),%rax
  810b94:	48 85 c0             	test   %rax,%rax
  810b97:	75 88                	jne    810b21 <tcp_pcb_remove+0x4a>
  810b99:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810b9d:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  810ba4:	00 

  tcp_pcb_purge(pcb);
  810ba5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810ba9:	48 89 c7             	mov    %rax,%rdi
  810bac:	48 b8 d4 09 81 00 00 	movabs $0x8109d4,%rax
  810bb3:	00 00 00 
  810bb6:	ff d0                	callq  *%rax
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  810bb8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810bbc:	8b 40 18             	mov    0x18(%rax),%eax
  810bbf:	83 f8 0a             	cmp    $0xa,%eax
  810bc2:	74 45                	je     810c09 <tcp_pcb_remove+0x132>
     pcb->state != LISTEN &&
  810bc4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810bc8:	8b 40 18             	mov    0x18(%rax),%eax
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  810bcb:	83 f8 01             	cmp    $0x1,%eax
  810bce:	74 39                	je     810c09 <tcp_pcb_remove+0x132>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  810bd0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810bd4:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  810bd8:	0f b6 c0             	movzbl %al,%eax
  810bdb:	83 e0 01             	and    $0x1,%eax

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  810bde:	85 c0                	test   %eax,%eax
  810be0:	74 27                	je     810c09 <tcp_pcb_remove+0x132>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  810be2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810be6:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  810bea:	83 c8 02             	or     $0x2,%eax
  810bed:	89 c2                	mov    %eax,%edx
  810bef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810bf3:	88 50 2c             	mov    %dl,0x2c(%rax)
    tcp_output(pcb);
  810bf6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810bfa:	48 89 c7             	mov    %rax,%rdi
  810bfd:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  810c04:	00 00 00 
  810c07:	ff d0                	callq  *%rax
  }

  if (pcb->state != LISTEN) {
  810c09:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c0d:	8b 40 18             	mov    0x18(%rax),%eax
  810c10:	83 f8 01             	cmp    $0x1,%eax
  810c13:	0f 84 ae 00 00 00    	je     810cc7 <tcp_pcb_remove+0x1f0>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  810c19:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c1d:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  810c24:	48 85 c0             	test   %rax,%rax
  810c27:	74 2a                	je     810c53 <tcp_pcb_remove+0x17c>
  810c29:	48 ba 1e 28 82 00 00 	movabs $0x82281e,%rdx
  810c30:	00 00 00 
  810c33:	be b5 04 00 00       	mov    $0x4b5,%esi
  810c38:	48 bf 3b 26 82 00 00 	movabs $0x82263b,%rdi
  810c3f:	00 00 00 
  810c42:	b8 00 00 00 00       	mov    $0x0,%eax
  810c47:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  810c4e:	00 00 00 
  810c51:	ff d1                	callq  *%rcx
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  810c53:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c57:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  810c5e:	48 85 c0             	test   %rax,%rax
  810c61:	74 2a                	je     810c8d <tcp_pcb_remove+0x1b6>
  810c63:	48 ba 36 28 82 00 00 	movabs $0x822836,%rdx
  810c6a:	00 00 00 
  810c6d:	be b6 04 00 00       	mov    $0x4b6,%esi
  810c72:	48 bf 3b 26 82 00 00 	movabs $0x82263b,%rdi
  810c79:	00 00 00 
  810c7c:	b8 00 00 00 00       	mov    $0x0,%eax
  810c81:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  810c88:	00 00 00 
  810c8b:	ff d1                	callq  *%rcx
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  810c8d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c91:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  810c98:	48 85 c0             	test   %rax,%rax
  810c9b:	74 2a                	je     810cc7 <tcp_pcb_remove+0x1f0>
  810c9d:	48 ba 4f 28 82 00 00 	movabs $0x82284f,%rdx
  810ca4:	00 00 00 
  810ca7:	be b8 04 00 00       	mov    $0x4b8,%esi
  810cac:	48 bf 3b 26 82 00 00 	movabs $0x82263b,%rdi
  810cb3:	00 00 00 
  810cb6:	b8 00 00 00 00       	mov    $0x0,%eax
  810cbb:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  810cc2:	00 00 00 
  810cc5:	ff d1                	callq  *%rcx
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  810cc7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810ccb:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  810cd2:	90                   	nop
  810cd3:	c9                   	leaveq 
  810cd4:	c3                   	retq   

0000000000810cd5 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  810cd5:	55                   	push   %rbp
  810cd6:	48 89 e5             	mov    %rsp,%rbp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  810cd9:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  810ce0:	00 00 00 
  810ce3:	8b 10                	mov    (%rax),%edx
  810ce5:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810cec:	00 00 00 
  810cef:	8b 00                	mov    (%rax),%eax
  810cf1:	01 c2                	add    %eax,%edx
  810cf3:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  810cfa:	00 00 00 
  810cfd:	89 10                	mov    %edx,(%rax)
  return iss;
  810cff:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  810d06:	00 00 00 
  810d09:	8b 00                	mov    (%rax),%eax
}
  810d0b:	5d                   	pop    %rbp
  810d0c:	c3                   	retq   

0000000000810d0d <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  810d0d:	55                   	push   %rbp
  810d0e:	48 89 e5             	mov    %rsp,%rbp
  810d11:	48 83 ec 20          	sub    $0x20,%rsp
  810d15:	89 f8                	mov    %edi,%eax
  810d17:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  810d1b:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  810d1f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810d23:	48 89 c7             	mov    %rax,%rdi
  810d26:	48 b8 0d 0e 81 00 00 	movabs $0x810e0d,%rax
  810d2d:	00 00 00 
  810d30:	ff d0                	callq  *%rax
  810d32:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if ((outif != NULL) && (outif->mtu != 0)) {
  810d36:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810d3b:	74 2d                	je     810d6a <tcp_eff_send_mss+0x5d>
  810d3d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810d41:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  810d45:	66 85 c0             	test   %ax,%ax
  810d48:	74 20                	je     810d6a <tcp_eff_send_mss+0x5d>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  810d4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810d4e:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  810d52:	83 e8 28             	sub    $0x28,%eax
  810d55:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  810d59:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  810d5d:	66 39 45 f6          	cmp    %ax,-0xa(%rbp)
  810d61:	66 0f 46 45 f6       	cmovbe -0xa(%rbp),%ax
  810d66:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  }
  return sendmss;
  810d6a:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
}
  810d6e:	c9                   	leaveq 
  810d6f:	c3                   	retq   

0000000000810d70 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  810d70:	55                   	push   %rbp
  810d71:	48 89 e5             	mov    %rsp,%rbp
  810d74:	48 83 ec 20          	sub    $0x20,%rsp
  810d78:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  810d7c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  u32_t addr2test;

  addr2test = addr->addr;
  810d80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810d84:	8b 00                	mov    (%rax),%eax
  810d86:	89 45 fc             	mov    %eax,-0x4(%rbp)
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  810d89:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  810d8d:	74 06                	je     810d95 <ip_addr_isbroadcast+0x25>
  810d8f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  810d93:	75 07                	jne    810d9c <ip_addr_isbroadcast+0x2c>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  810d95:	b8 01 00 00 00       	mov    $0x1,%eax
  810d9a:	eb 6f                	jmp    810e0b <ip_addr_isbroadcast+0x9b>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  810d9c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810da0:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  810da4:	0f b6 c0             	movzbl %al,%eax
  810da7:	83 e0 02             	and    $0x2,%eax
  810daa:	85 c0                	test   %eax,%eax
  810dac:	75 07                	jne    810db5 <ip_addr_isbroadcast+0x45>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  810dae:	b8 00 00 00 00       	mov    $0x0,%eax
  810db3:	eb 56                	jmp    810e0b <ip_addr_isbroadcast+0x9b>
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  810db5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810db9:	8b 40 08             	mov    0x8(%rax),%eax
  810dbc:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  810dbf:	75 07                	jne    810dc8 <ip_addr_isbroadcast+0x58>
    return 0;
  810dc1:	b8 00 00 00 00       	mov    $0x0,%eax
  810dc6:	eb 43                	jmp    810e0b <ip_addr_isbroadcast+0x9b>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  810dc8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810dcc:	8b 10                	mov    (%rax),%edx
  810dce:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810dd2:	8b 40 08             	mov    0x8(%rax),%eax
  810dd5:	31 c2                	xor    %eax,%edx
  810dd7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810ddb:	8b 40 0c             	mov    0xc(%rax),%eax
  810dde:	21 d0                	and    %edx,%eax
  810de0:	85 c0                	test   %eax,%eax
  810de2:	75 22                	jne    810e06 <ip_addr_isbroadcast+0x96>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  810de4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810de8:	8b 40 0c             	mov    0xc(%rax),%eax
  810deb:	f7 d0                	not    %eax
  810ded:	23 45 fc             	and    -0x4(%rbp),%eax
  810df0:	89 c2                	mov    %eax,%edx
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
  810df2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810df6:	8b 40 0c             	mov    0xc(%rax),%eax
  810df9:	f7 d0                	not    %eax
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  810dfb:	39 c2                	cmp    %eax,%edx
  810dfd:	75 07                	jne    810e06 <ip_addr_isbroadcast+0x96>
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  810dff:	b8 01 00 00 00       	mov    $0x1,%eax
  810e04:	eb 05                	jmp    810e0b <ip_addr_isbroadcast+0x9b>
  else
    return 0;
  810e06:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810e0b:	c9                   	leaveq 
  810e0c:	c3                   	retq   

0000000000810e0d <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  810e0d:	55                   	push   %rbp
  810e0e:	48 89 e5             	mov    %rsp,%rbp
  810e11:	48 83 ec 20          	sub    $0x20,%rsp
  810e15:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  810e19:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  810e20:	00 00 00 
  810e23:	48 8b 00             	mov    (%rax),%rax
  810e26:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810e2a:	eb 44                	jmp    810e70 <ip_route+0x63>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  810e2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810e30:	48 89 c7             	mov    %rax,%rdi
  810e33:	48 b8 4b d4 80 00 00 	movabs $0x80d44b,%rax
  810e3a:	00 00 00 
  810e3d:	ff d0                	callq  *%rax
  810e3f:	84 c0                	test   %al,%al
  810e41:	74 22                	je     810e65 <ip_route+0x58>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  810e43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810e47:	8b 10                	mov    (%rax),%edx
  810e49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810e4d:	8b 40 08             	mov    0x8(%rax),%eax
  810e50:	31 c2                	xor    %eax,%edx
  810e52:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810e56:	8b 40 0c             	mov    0xc(%rax),%eax
  810e59:	21 d0                	and    %edx,%eax
  810e5b:	85 c0                	test   %eax,%eax
  810e5d:	75 06                	jne    810e65 <ip_route+0x58>
        /* return netif on which to forward IP packet */
        return netif;
  810e5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810e63:	eb 58                	jmp    810ebd <ip_route+0xb0>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  810e65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810e69:	48 8b 00             	mov    (%rax),%rax
  810e6c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810e70:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810e75:	75 b5                	jne    810e2c <ip_route+0x1f>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  810e77:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  810e7e:	00 00 00 
  810e81:	48 8b 00             	mov    (%rax),%rax
  810e84:	48 85 c0             	test   %rax,%rax
  810e87:	74 20                	je     810ea9 <ip_route+0x9c>
  810e89:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  810e90:	00 00 00 
  810e93:	48 8b 00             	mov    (%rax),%rax
  810e96:	48 89 c7             	mov    %rax,%rdi
  810e99:	48 b8 4b d4 80 00 00 	movabs $0x80d44b,%rax
  810ea0:	00 00 00 
  810ea3:	ff d0                	callq  *%rax
  810ea5:	84 c0                	test   %al,%al
  810ea7:	75 07                	jne    810eb0 <ip_route+0xa3>
    LWIP_DEBUGF(IP_DEBUG | 2, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  810ea9:	b8 00 00 00 00       	mov    $0x0,%eax
  810eae:	eb 0d                	jmp    810ebd <ip_route+0xb0>
  }
  /* no matching netif found, use default netif */
  return netif_default;
  810eb0:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  810eb7:	00 00 00 
  810eba:	48 8b 00             	mov    (%rax),%rax
}
  810ebd:	c9                   	leaveq 
  810ebe:	c3                   	retq   

0000000000810ebf <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  810ebf:	55                   	push   %rbp
  810ec0:	48 89 e5             	mov    %rsp,%rbp
  810ec3:	53                   	push   %rbx
  810ec4:	48 83 ec 38          	sub    $0x38,%rsp
  810ec8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  810ecc:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if LWIP_DHCP
  int check_ip_src=1;
  810ed0:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  810ed7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810edb:	48 8b 40 08          	mov    0x8(%rax),%rax
  810edf:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (IPH_V(iphdr) != 4) {
  810ee3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810ee7:	0f b7 00             	movzwl (%rax),%eax
  810eea:	0f b7 c0             	movzwl %ax,%eax
  810eed:	89 c7                	mov    %eax,%edi
  810eef:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  810ef6:	00 00 00 
  810ef9:	ff d0                	callq  *%rax
  810efb:	66 c1 e8 0c          	shr    $0xc,%ax
  810eff:	66 83 f8 04          	cmp    $0x4,%ax
  810f03:	74 1d                	je     810f22 <ip_input+0x63>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  810f05:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810f09:	48 89 c7             	mov    %rax,%rdi
  810f0c:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  810f13:	00 00 00 
  810f16:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  810f18:	b8 00 00 00 00       	mov    $0x0,%eax
  810f1d:	e9 1a 04 00 00       	jmpq   81133c <ip_input+0x47d>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  810f22:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810f26:	0f b7 00             	movzwl (%rax),%eax
  810f29:	0f b7 c0             	movzwl %ax,%eax
  810f2c:	89 c7                	mov    %eax,%edi
  810f2e:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  810f35:	00 00 00 
  810f38:	ff d0                	callq  *%rax
  810f3a:	66 c1 e8 08          	shr    $0x8,%ax
  810f3e:	83 e0 0f             	and    $0xf,%eax
  810f41:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  810f45:	66 c1 65 d6 02       	shlw   $0x2,-0x2a(%rbp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  810f4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810f4e:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  810f52:	0f b7 c0             	movzwl %ax,%eax
  810f55:	89 c7                	mov    %eax,%edi
  810f57:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  810f5e:	00 00 00 
  810f61:	ff d0                	callq  *%rax
  810f63:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  810f67:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810f6b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  810f6f:	66 3b 45 d6          	cmp    -0x2a(%rbp),%ax
  810f73:	72 0e                	jb     810f83 <ip_input+0xc4>
  810f75:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810f79:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  810f7d:	66 3b 45 d4          	cmp    -0x2c(%rbp),%ax
  810f81:	73 1d                	jae    810fa0 <ip_input+0xe1>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  810f83:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810f87:	48 89 c7             	mov    %rax,%rdi
  810f8a:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  810f91:	00 00 00 
  810f94:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  810f96:	b8 00 00 00 00       	mov    $0x0,%eax
  810f9b:	e9 9c 03 00 00       	jmpq   81133c <ip_input+0x47d>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  810fa0:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  810fa4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810fa8:	89 d6                	mov    %edx,%esi
  810faa:	48 89 c7             	mov    %rax,%rdi
  810fad:	48 b8 4e 2b 81 00 00 	movabs $0x812b4e,%rax
  810fb4:	00 00 00 
  810fb7:	ff d0                	callq  *%rax
  810fb9:	66 85 c0             	test   %ax,%ax
  810fbc:	74 1d                	je     810fdb <ip_input+0x11c>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  810fbe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810fc2:	48 89 c7             	mov    %rax,%rdi
  810fc5:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  810fcc:	00 00 00 
  810fcf:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  810fd1:	b8 00 00 00 00       	mov    $0x0,%eax
  810fd6:	e9 61 03 00 00       	jmpq   81133c <ip_input+0x47d>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  810fdb:	0f b7 55 d4          	movzwl -0x2c(%rbp),%edx
  810fdf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810fe3:	89 d6                	mov    %edx,%esi
  810fe5:	48 89 c7             	mov    %rax,%rdi
  810fe8:	48 b8 3f d9 80 00 00 	movabs $0x80d93f,%rax
  810fef:	00 00 00 
  810ff2:	ff d0                	callq  *%rax
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  810ff4:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
    netif = inp;
  810ffb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  810fff:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  811003:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811007:	48 89 c7             	mov    %rax,%rdi
  81100a:	48 b8 4b d4 80 00 00 	movabs $0x80d44b,%rax
  811011:	00 00 00 
  811014:	ff d0                	callq  *%rax
  811016:	84 c0                	test   %al,%al
  811018:	74 4c                	je     811066 <ip_input+0x1a7>
  81101a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81101e:	48 83 c0 08          	add    $0x8,%rax
  811022:	48 85 c0             	test   %rax,%rax
  811025:	74 3f                	je     811066 <ip_input+0x1a7>
  811027:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81102b:	8b 40 08             	mov    0x8(%rax),%eax
  81102e:	85 c0                	test   %eax,%eax
  811030:	74 34                	je     811066 <ip_input+0x1a7>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  811032:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811036:	8b 50 10             	mov    0x10(%rax),%edx
  811039:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81103d:	8b 40 08             	mov    0x8(%rax),%eax
  811040:	39 c2                	cmp    %eax,%edx
  811042:	74 6f                	je     8110b3 <ip_input+0x1f4>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  811044:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811048:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81104c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811050:	48 89 c6             	mov    %rax,%rsi
  811053:	48 89 d7             	mov    %rdx,%rdi
  811056:	48 b8 70 0d 81 00 00 	movabs $0x810d70,%rax
  81105d:	00 00 00 
  811060:	ff d0                	callq  *%rax
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  811062:	84 c0                	test   %al,%al
  811064:	75 4d                	jne    8110b3 <ip_input+0x1f4>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  811066:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  81106a:	74 1a                	je     811086 <ip_input+0x1c7>
        first = 0;
  81106c:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
        netif = netif_list;
  811073:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  81107a:	00 00 00 
  81107d:	48 8b 00             	mov    (%rax),%rax
  811080:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  811084:	eb 0b                	jmp    811091 <ip_input+0x1d2>
      } else {
        netif = netif->next;
  811086:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81108a:	48 8b 00             	mov    (%rax),%rax
  81108d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      }
      if (netif == inp) {
  811091:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811095:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  811099:	75 0b                	jne    8110a6 <ip_input+0x1e7>
        netif = netif->next;
  81109b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81109f:	48 8b 00             	mov    (%rax),%rax
  8110a2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      }
    } while(netif != NULL);
  8110a6:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8110ab:	0f 85 52 ff ff ff    	jne    811003 <ip_input+0x144>
  8110b1:	eb 01                	jmp    8110b4 <ip_input+0x1f5>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
          LWIP_DEBUGF(IP_DEBUG, ("ip_input: packet accepted on interface %c%c\n",
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
  8110b3:	90                   	nop
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  8110b4:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8110b9:	75 59                	jne    811114 <ip_input+0x255>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  8110bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8110bf:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8110c3:	0f b7 c0             	movzwl %ax,%eax
  8110c6:	89 c7                	mov    %eax,%edi
  8110c8:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  8110cf:	00 00 00 
  8110d2:	ff d0                	callq  *%rax
  8110d4:	0f b7 c0             	movzwl %ax,%eax
  8110d7:	0f b6 c0             	movzbl %al,%eax
  8110da:	83 f8 11             	cmp    $0x11,%eax
  8110dd:	75 35                	jne    811114 <ip_input+0x255>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  8110df:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  8110e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8110e7:	48 01 d0             	add    %rdx,%rax
  8110ea:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8110ee:	0f b7 c0             	movzwl %ax,%eax
  8110f1:	89 c7                	mov    %eax,%edi
  8110f3:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  8110fa:	00 00 00 
  8110fd:	ff d0                	callq  *%rax
  8110ff:	66 83 f8 44          	cmp    $0x44,%ax
  811103:	75 0f                	jne    811114 <ip_input+0x255>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  811105:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  811109:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        check_ip_src = 0;
  81110d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
  }
#endif /* LWIP_DHCP */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
  811114:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  811118:	74 6e                	je     811188 <ip_input+0x2c9>
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  81111a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81111e:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  811122:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  811126:	48 89 c6             	mov    %rax,%rsi
  811129:	48 89 d7             	mov    %rdx,%rdi
  81112c:	48 b8 70 0d 81 00 00 	movabs $0x810d70,%rax
  811133:	00 00 00 
  811136:	ff d0                	callq  *%rax
  811138:	84 c0                	test   %al,%al
  81113a:	75 2f                	jne    81116b <ip_input+0x2ac>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  81113c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811140:	8b 58 0c             	mov    0xc(%rax),%ebx
  811143:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  811148:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  81114f:	00 00 00 
  811152:	ff d0                	callq  *%rax
  811154:	21 c3                	and    %eax,%ebx
  811156:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81115b:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  811162:	00 00 00 
  811165:	ff d0                	callq  *%rax

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  811167:	39 c3                	cmp    %eax,%ebx
  811169:	75 1d                	jne    811188 <ip_input+0x2c9>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  81116b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81116f:	48 89 c7             	mov    %rax,%rdi
  811172:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  811179:	00 00 00 
  81117c:	ff d0                	callq  *%rax
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  81117e:	b8 00 00 00 00       	mov    $0x0,%eax
  811183:	e9 b4 01 00 00       	jmpq   81133c <ip_input+0x47d>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  811188:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81118d:	75 1d                	jne    8111ac <ip_input+0x2ed>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  81118f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811193:	48 89 c7             	mov    %rax,%rdi
  811196:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81119d:	00 00 00 
  8111a0:	ff d0                	callq  *%rax
    return ERR_OK;
  8111a2:	b8 00 00 00 00       	mov    $0x0,%eax
  8111a7:	e9 90 01 00 00       	jmpq   81133c <ip_input+0x47d>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  8111ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8111b0:	0f b7 58 06          	movzwl 0x6(%rax),%ebx
  8111b4:	bf ff 3f 00 00       	mov    $0x3fff,%edi
  8111b9:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  8111c0:	00 00 00 
  8111c3:	ff d0                	callq  *%rax
  8111c5:	21 d8                	and    %ebx,%eax
  8111c7:	66 85 c0             	test   %ax,%ax
  8111ca:	74 34                	je     811200 <ip_input+0x341>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  8111cc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8111d0:	48 89 c7             	mov    %rax,%rdi
  8111d3:	48 b8 2c 20 81 00 00 	movabs $0x81202c,%rax
  8111da:	00 00 00 
  8111dd:	ff d0                	callq  *%rax
  8111df:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  8111e3:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8111e8:	75 0a                	jne    8111f4 <ip_input+0x335>
      return ERR_OK;
  8111ea:	b8 00 00 00 00       	mov    $0x0,%eax
  8111ef:	e9 48 01 00 00       	jmpq   81133c <ip_input+0x47d>
    }
    iphdr = p->payload;
  8111f4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8111f8:	48 8b 40 08          	mov    0x8(%rax),%rax
  8111fc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  811200:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  811204:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811208:	48 89 d6             	mov    %rdx,%rsi
  81120b:	48 89 c7             	mov    %rax,%rdi
  81120e:	48 b8 eb fe 81 00 00 	movabs $0x81feeb,%rax
  811215:	00 00 00 
  811218:	ff d0                	callq  *%rax
  81121a:	84 c0                	test   %al,%al
  81121c:	0f 85 15 01 00 00    	jne    811337 <ip_input+0x478>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  811222:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811226:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81122a:	0f b7 c0             	movzwl %ax,%eax
  81122d:	89 c7                	mov    %eax,%edi
  81122f:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  811236:	00 00 00 
  811239:	ff d0                	callq  *%rax
  81123b:	0f b7 c0             	movzwl %ax,%eax
  81123e:	0f b6 c0             	movzbl %al,%eax
  811241:	83 f8 06             	cmp    $0x6,%eax
  811244:	74 2b                	je     811271 <ip_input+0x3b2>
  811246:	83 f8 11             	cmp    $0x11,%eax
  811249:	74 07                	je     811252 <ip_input+0x393>
  81124b:	83 f8 01             	cmp    $0x1,%eax
  81124e:	74 40                	je     811290 <ip_input+0x3d1>
  811250:	eb 5d                	jmp    8112af <ip_input+0x3f0>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  811252:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  811256:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81125a:	48 89 d6             	mov    %rdx,%rsi
  81125d:	48 89 c7             	mov    %rax,%rdi
  811260:	48 b8 77 4e 81 00 00 	movabs $0x814e77,%rax
  811267:	00 00 00 
  81126a:	ff d0                	callq  *%rax
      break;
  81126c:	e9 c6 00 00 00       	jmpq   811337 <ip_input+0x478>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  811271:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  811275:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811279:	48 89 d6             	mov    %rdx,%rsi
  81127c:	48 89 c7             	mov    %rax,%rdi
  81127f:	48 b8 87 c5 81 00 00 	movabs $0x81c587,%rax
  811286:	00 00 00 
  811289:	ff d0                	callq  *%rax
      break;
  81128b:	e9 a7 00 00 00       	jmpq   811337 <ip_input+0x478>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  811290:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  811294:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811298:	48 89 d6             	mov    %rdx,%rsi
  81129b:	48 89 c7             	mov    %rax,%rdi
  81129e:	48 b8 a6 03 82 00 00 	movabs $0x8203a6,%rax
  8112a5:	00 00 00 
  8112a8:	ff d0                	callq  *%rax
      break;
  8112aa:	e9 88 00 00 00       	jmpq   811337 <ip_input+0x478>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8112af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8112b3:	48 8d 50 10          	lea    0x10(%rax),%rdx
  8112b7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8112bb:	48 89 c6             	mov    %rax,%rsi
  8112be:	48 89 d7             	mov    %rdx,%rdi
  8112c1:	48 b8 70 0d 81 00 00 	movabs $0x810d70,%rax
  8112c8:	00 00 00 
  8112cb:	ff d0                	callq  *%rax
  8112cd:	84 c0                	test   %al,%al
  8112cf:	75 53                	jne    811324 <ip_input+0x465>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  8112d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8112d5:	8b 58 10             	mov    0x10(%rax),%ebx
  8112d8:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  8112dd:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  8112e4:	00 00 00 
  8112e7:	ff d0                	callq  *%rax
  8112e9:	21 c3                	and    %eax,%ebx
  8112eb:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  8112f0:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  8112f7:	00 00 00 
  8112fa:	ff d0                	callq  *%rax
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8112fc:	39 c3                	cmp    %eax,%ebx
  8112fe:	74 24                	je     811324 <ip_input+0x465>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  811300:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811304:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811308:	48 89 50 08          	mov    %rdx,0x8(%rax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  81130c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811310:	be 02 00 00 00       	mov    $0x2,%esi
  811315:	48 89 c7             	mov    %rax,%rdi
  811318:	48 b8 da 08 82 00 00 	movabs $0x8208da,%rax
  81131f:	00 00 00 
  811322:	ff d0                	callq  *%rax
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  811324:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811328:	48 89 c7             	mov    %rax,%rdi
  81132b:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  811332:	00 00 00 
  811335:	ff d0                	callq  *%rax
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
  811337:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81133c:	48 83 c4 38          	add    $0x38,%rsp
  811340:	5b                   	pop    %rbx
  811341:	5d                   	pop    %rbp
  811342:	c3                   	retq   

0000000000811343 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  811343:	55                   	push   %rbp
  811344:	48 89 e5             	mov    %rsp,%rbp
  811347:	53                   	push   %rbx
  811348:	48 83 ec 48          	sub    $0x48,%rsp
  81134c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  811350:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  811354:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  811358:	89 c8                	mov    %ecx,%eax
  81135a:	44 89 c1             	mov    %r8d,%ecx
  81135d:	44 89 ca             	mov    %r9d,%edx
  811360:	88 45 c4             	mov    %al,-0x3c(%rbp)
  811363:	88 4d c0             	mov    %cl,-0x40(%rbp)
  811366:	88 55 bc             	mov    %dl,-0x44(%rbp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  811369:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81136e:	0f 84 1a 02 00 00    	je     81158e <ip_output_if+0x24b>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  811374:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811378:	be 14 00 00 00       	mov    $0x14,%esi
  81137d:	48 89 c7             	mov    %rax,%rdi
  811380:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  811387:	00 00 00 
  81138a:	ff d0                	callq  *%rax
  81138c:	84 c0                	test   %al,%al
  81138e:	74 0a                	je     81139a <ip_output_if+0x57>
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  811390:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  811395:	e9 64 02 00 00       	jmpq   8115fe <ip_output_if+0x2bb>
    }

    iphdr = p->payload;
  81139a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81139e:	48 8b 40 08          	mov    0x8(%rax),%rax
  8113a2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  8113a6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8113aa:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8113ae:	66 83 f8 13          	cmp    $0x13,%ax
  8113b2:	77 2a                	ja     8113de <ip_output_if+0x9b>
  8113b4:	48 ba 70 28 82 00 00 	movabs $0x822870,%rdx
  8113bb:	00 00 00 
  8113be:	be ef 01 00 00       	mov    $0x1ef,%esi
  8113c3:	48 bf 9d 28 82 00 00 	movabs $0x82289d,%rdi
  8113ca:	00 00 00 
  8113cd:	b8 00 00 00 00       	mov    $0x0,%eax
  8113d2:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8113d9:	00 00 00 
  8113dc:	ff d1                	callq  *%rcx
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  8113de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8113e2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8113e6:	0f b7 c0             	movzwl %ax,%eax
  8113e9:	89 c7                	mov    %eax,%edi
  8113eb:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  8113f2:	00 00 00 
  8113f5:	ff d0                	callq  *%rax
  8113f7:	0f b6 c0             	movzbl %al,%eax
  8113fa:	0f b6 55 c4          	movzbl -0x3c(%rbp),%edx
  8113fe:	c1 e2 08             	shl    $0x8,%edx
  811401:	09 d0                	or     %edx,%eax
  811403:	0f b7 c0             	movzwl %ax,%eax
  811406:	89 c7                	mov    %eax,%edi
  811408:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  81140f:	00 00 00 
  811412:	ff d0                	callq  *%rax
  811414:	89 c2                	mov    %eax,%edx
  811416:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81141a:	66 89 50 08          	mov    %dx,0x8(%rax)
    IPH_PROTO_SET(iphdr, proto);
  81141e:	0f b6 5d bc          	movzbl -0x44(%rbp),%ebx
  811422:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811426:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81142a:	0f b7 c0             	movzwl %ax,%eax
  81142d:	89 c7                	mov    %eax,%edi
  81142f:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  811436:	00 00 00 
  811439:	ff d0                	callq  *%rax
  81143b:	66 c1 e8 08          	shr    $0x8,%ax
  81143f:	0f b7 c0             	movzwl %ax,%eax
  811442:	c1 e0 08             	shl    $0x8,%eax
  811445:	09 d8                	or     %ebx,%eax
  811447:	0f b7 c0             	movzwl %ax,%eax
  81144a:	89 c7                	mov    %eax,%edi
  81144c:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  811453:	00 00 00 
  811456:	ff d0                	callq  *%rax
  811458:	89 c2                	mov    %eax,%edx
  81145a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81145e:	66 89 50 08          	mov    %dx,0x8(%rax)

    ip_addr_set(&(iphdr->dest), dest);
  811462:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  811467:	74 08                	je     811471 <ip_output_if+0x12e>
  811469:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81146d:	8b 00                	mov    (%rax),%eax
  81146f:	eb 05                	jmp    811476 <ip_output_if+0x133>
  811471:	b8 00 00 00 00       	mov    $0x0,%eax
  811476:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81147a:	89 42 10             	mov    %eax,0x10(%rdx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  81147d:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
  811481:	80 cc 45             	or     $0x45,%ah
  811484:	0f b7 c0             	movzwl %ax,%eax
  811487:	89 c7                	mov    %eax,%edi
  811489:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  811490:	00 00 00 
  811493:	ff d0                	callq  *%rax
  811495:	89 c2                	mov    %eax,%edx
  811497:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81149b:	66 89 10             	mov    %dx,(%rax)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  81149e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8114a2:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8114a6:	0f b7 c0             	movzwl %ax,%eax
  8114a9:	89 c7                	mov    %eax,%edi
  8114ab:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  8114b2:	00 00 00 
  8114b5:	ff d0                	callq  *%rax
  8114b7:	89 c2                	mov    %eax,%edx
  8114b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8114bd:	66 89 50 02          	mov    %dx,0x2(%rax)
    IPH_OFFSET_SET(iphdr, 0);
  8114c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8114c5:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
    IPH_ID_SET(iphdr, htons(ip_id));
  8114cb:	48 b8 4e b0 b4 00 00 	movabs $0xb4b04e,%rax
  8114d2:	00 00 00 
  8114d5:	0f b7 00             	movzwl (%rax),%eax
  8114d8:	0f b7 c0             	movzwl %ax,%eax
  8114db:	89 c7                	mov    %eax,%edi
  8114dd:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  8114e4:	00 00 00 
  8114e7:	ff d0                	callq  *%rax
  8114e9:	89 c2                	mov    %eax,%edx
  8114eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8114ef:	66 89 50 04          	mov    %dx,0x4(%rax)
    ++ip_id;
  8114f3:	48 b8 4e b0 b4 00 00 	movabs $0xb4b04e,%rax
  8114fa:	00 00 00 
  8114fd:	0f b7 00             	movzwl (%rax),%eax
  811500:	8d 50 01             	lea    0x1(%rax),%edx
  811503:	48 b8 4e b0 b4 00 00 	movabs $0xb4b04e,%rax
  81150a:	00 00 00 
  81150d:	66 89 10             	mov    %dx,(%rax)

    if (ip_addr_isany(src)) {
  811510:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  811515:	74 0a                	je     811521 <ip_output_if+0x1de>
  811517:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81151b:	8b 00                	mov    (%rax),%eax
  81151d:	85 c0                	test   %eax,%eax
  81151f:	75 24                	jne    811545 <ip_output_if+0x202>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  811521:	48 8b 45 10          	mov    0x10(%rbp),%rax
  811525:	48 83 c0 08          	add    $0x8,%rax
  811529:	48 85 c0             	test   %rax,%rax
  81152c:	74 09                	je     811537 <ip_output_if+0x1f4>
  81152e:	48 8b 45 10          	mov    0x10(%rbp),%rax
  811532:	8b 40 08             	mov    0x8(%rax),%eax
  811535:	eb 05                	jmp    81153c <ip_output_if+0x1f9>
  811537:	b8 00 00 00 00       	mov    $0x0,%eax
  81153c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811540:	89 42 0c             	mov    %eax,0xc(%rdx)
  811543:	eb 1b                	jmp    811560 <ip_output_if+0x21d>
    } else {
      ip_addr_set(&(iphdr->src), src);
  811545:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81154a:	74 08                	je     811554 <ip_output_if+0x211>
  81154c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811550:	8b 00                	mov    (%rax),%eax
  811552:	eb 05                	jmp    811559 <ip_output_if+0x216>
  811554:	b8 00 00 00 00       	mov    $0x0,%eax
  811559:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81155d:	89 42 0c             	mov    %eax,0xc(%rdx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  811560:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811564:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  81156a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81156e:	be 14 00 00 00       	mov    $0x14,%esi
  811573:	48 89 c7             	mov    %rax,%rdi
  811576:	48 b8 4e 2b 81 00 00 	movabs $0x812b4e,%rax
  81157d:	00 00 00 
  811580:	ff d0                	callq  *%rax
  811582:	89 c2                	mov    %eax,%edx
  811584:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811588:	66 89 50 0a          	mov    %dx,0xa(%rax)
  81158c:	eb 18                	jmp    8115a6 <ip_output_if+0x263>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
  81158e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811592:	48 8b 40 08          	mov    0x8(%rax),%rax
  811596:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    dest = &(iphdr->dest);
  81159a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81159e:	48 83 c0 10          	add    $0x10,%rax
  8115a2:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  8115a6:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8115aa:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  8115ae:	66 85 c0             	test   %ax,%ax
  8115b1:	74 32                	je     8115e5 <ip_output_if+0x2a2>
  8115b3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8115b7:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  8115bb:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8115bf:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  8115c3:	66 39 c2             	cmp    %ax,%dx
  8115c6:	76 1d                	jbe    8115e5 <ip_output_if+0x2a2>
    return ip_frag(p,netif,dest);
  8115c8:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8115cc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8115d0:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  8115d4:	48 89 c7             	mov    %rax,%rdi
  8115d7:	48 b8 76 24 81 00 00 	movabs $0x812476,%rax
  8115de:	00 00 00 
  8115e1:	ff d0                	callq  *%rax
  8115e3:	eb 19                	jmp    8115fe <ip_output_if+0x2bb>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  8115e5:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8115e9:	48 8b 40 20          	mov    0x20(%rax),%rax
  8115ed:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8115f1:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8115f5:	48 89 ce             	mov    %rcx,%rsi
  8115f8:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8115fc:	ff d0                	callq  *%rax
  }
}
  8115fe:	48 83 c4 48          	add    $0x48,%rsp
  811602:	5b                   	pop    %rbx
  811603:	5d                   	pop    %rbp
  811604:	c3                   	retq   

0000000000811605 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  811605:	55                   	push   %rbp
  811606:	48 89 e5             	mov    %rsp,%rbp
  811609:	48 83 ec 40          	sub    $0x40,%rsp
  81160d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  811611:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  811615:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  811619:	89 c8                	mov    %ecx,%eax
  81161b:	44 89 c1             	mov    %r8d,%ecx
  81161e:	44 89 ca             	mov    %r9d,%edx
  811621:	88 45 d4             	mov    %al,-0x2c(%rbp)
  811624:	88 4d d0             	mov    %cl,-0x30(%rbp)
  811627:	88 55 cc             	mov    %dl,-0x34(%rbp)
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  81162a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81162e:	48 89 c7             	mov    %rax,%rdi
  811631:	48 b8 0d 0e 81 00 00 	movabs $0x810e0d,%rax
  811638:	00 00 00 
  81163b:	ff d0                	callq  *%rax
  81163d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  811641:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  811646:	75 07                	jne    81164f <ip_output+0x4a>
    return ERR_RTE;
  811648:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  81164d:	eb 39                	jmp    811688 <ip_output+0x83>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  81164f:	44 0f b6 45 cc       	movzbl -0x34(%rbp),%r8d
  811654:	0f b6 7d d0          	movzbl -0x30(%rbp),%edi
  811658:	0f b6 4d d4          	movzbl -0x2c(%rbp),%ecx
  81165c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  811660:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  811664:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811668:	48 83 ec 08          	sub    $0x8,%rsp
  81166c:	ff 75 f8             	pushq  -0x8(%rbp)
  81166f:	45 89 c1             	mov    %r8d,%r9d
  811672:	41 89 f8             	mov    %edi,%r8d
  811675:	48 89 c7             	mov    %rax,%rdi
  811678:	48 b8 43 13 81 00 00 	movabs $0x811343,%rax
  81167f:	00 00 00 
  811682:	ff d0                	callq  *%rax
  811684:	48 83 c4 10          	add    $0x10,%rsp
}
  811688:	c9                   	leaveq 
  811689:	c3                   	retq   

000000000081168a <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  81168a:	55                   	push   %rbp
  81168b:	48 89 e5             	mov    %rsp,%rbp
  81168e:	48 83 ec 20          	sub    $0x20,%rsp
  struct ip_reassdata *r, *prev = NULL;
  811692:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  811699:	00 

  r = reassdatagrams;
  81169a:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  8116a1:	00 00 00 
  8116a4:	48 8b 00             	mov    (%rax),%rax
  8116a7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (r != NULL) {
  8116ab:	eb 60                	jmp    81170d <ip_reass_tmr+0x83>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  8116ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8116b1:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  8116b5:	84 c0                	test   %al,%al
  8116b7:	74 27                	je     8116e0 <ip_reass_tmr+0x56>
      r->timer--;
  8116b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8116bd:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  8116c1:	8d 50 ff             	lea    -0x1(%rax),%edx
  8116c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8116c8:	88 50 27             	mov    %dl,0x27(%rax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  8116cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8116cf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      r = r->next;
  8116d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8116d7:	48 8b 00             	mov    (%rax),%rax
  8116da:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8116de:	eb 2d                	jmp    81170d <ip_reass_tmr+0x83>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
  8116e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8116e4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      /* get the next pointer before freeing */
      r = r->next;
  8116e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8116ec:	48 8b 00             	mov    (%rax),%rax
  8116ef:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  8116f3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8116f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8116fb:	48 89 d6             	mov    %rdx,%rsi
  8116fe:	48 89 c7             	mov    %rax,%rdi
  811701:	48 b8 17 17 81 00 00 	movabs $0x811717,%rax
  811708:	00 00 00 
  81170b:	ff d0                	callq  *%rax
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  81170d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  811712:	75 99                	jne    8116ad <ip_reass_tmr+0x23>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  811714:	90                   	nop
  811715:	c9                   	leaveq 
  811716:	c3                   	retq   

0000000000811717 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  811717:	55                   	push   %rbp
  811718:	48 89 e5             	mov    %rsp,%rbp
  81171b:	48 83 ec 30          	sub    $0x30,%rsp
  81171f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  811723:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  int pbufs_freed = 0;
  811727:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  81172e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811732:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  811736:	75 2a                	jne    811762 <ip_reass_free_complete_datagram+0x4b>
  811738:	48 ba b8 28 82 00 00 	movabs $0x8228b8,%rdx
  81173f:	00 00 00 
  811742:	be 9a 00 00 00       	mov    $0x9a,%esi
  811747:	48 bf c4 28 82 00 00 	movabs $0x8228c4,%rdi
  81174e:	00 00 00 
  811751:	b8 00 00 00 00       	mov    $0x0,%eax
  811756:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81175d:	00 00 00 
  811760:	ff d1                	callq  *%rcx
  if (prev != NULL) {
  811762:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  811767:	74 37                	je     8117a0 <ip_reass_free_complete_datagram+0x89>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  811769:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81176d:	48 8b 00             	mov    (%rax),%rax
  811770:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  811774:	74 2a                	je     8117a0 <ip_reass_free_complete_datagram+0x89>
  811776:	48 ba e1 28 82 00 00 	movabs $0x8228e1,%rdx
  81177d:	00 00 00 
  811780:	be 9c 00 00 00       	mov    $0x9c,%esi
  811785:	48 bf c4 28 82 00 00 	movabs $0x8228c4,%rdi
  81178c:	00 00 00 
  81178f:	b8 00 00 00 00       	mov    $0x0,%eax
  811794:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81179b:	00 00 00 
  81179e:	ff d1                	callq  *%rcx
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  8117a0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8117a4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8117a8:	48 8b 40 08          	mov    0x8(%rax),%rax
  8117ac:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (iprh->start == 0) {
  8117b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8117b4:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8117b8:	66 85 c0             	test   %ax,%ax
  8117bb:	0f 85 86 00 00 00    	jne    811847 <ip_reass_free_complete_datagram+0x130>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
  8117c1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8117c5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8117c9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    ipr->p = iprh->next_pbuf;
  8117cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8117d1:	48 8b 10             	mov    (%rax),%rdx
  8117d4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8117d8:	48 89 50 08          	mov    %rdx,0x8(%rax)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  8117dc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8117e0:	48 8d 48 10          	lea    0x10(%rax),%rcx
  8117e4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8117e8:	48 8b 40 08          	mov    0x8(%rax),%rax
  8117ec:	ba 14 00 00 00       	mov    $0x14,%edx
  8117f1:	48 89 ce             	mov    %rcx,%rsi
  8117f4:	48 89 c7             	mov    %rax,%rdi
  8117f7:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  8117fe:	00 00 00 
  811801:	ff d0                	callq  *%rax
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  811803:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811807:	be 01 00 00 00       	mov    $0x1,%esi
  81180c:	48 89 c7             	mov    %rax,%rdi
  81180f:	48 b8 7e 0a 82 00 00 	movabs $0x820a7e,%rax
  811816:	00 00 00 
  811819:	ff d0                	callq  *%rax
    pbufs_freed += pbuf_clen(p);
  81181b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81181f:	48 89 c7             	mov    %rax,%rdi
  811822:	48 b8 02 df 80 00 00 	movabs $0x80df02,%rax
  811829:	00 00 00 
  81182c:	ff d0                	callq  *%rax
  81182e:	0f b6 c0             	movzbl %al,%eax
  811831:	01 45 fc             	add    %eax,-0x4(%rbp)
    pbuf_free(p);
  811834:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811838:	48 89 c7             	mov    %rax,%rdi
  81183b:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  811842:	00 00 00 
  811845:	ff d0                	callq  *%rax
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  811847:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81184b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81184f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  while (p != NULL) {
  811853:	eb 4b                	jmp    8118a0 <ip_reass_free_complete_datagram+0x189>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  811855:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811859:	48 8b 40 08          	mov    0x8(%rax),%rax
  81185d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    pcur = p;
  811861:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811865:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  811869:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81186d:	48 8b 00             	mov    (%rax),%rax
  811870:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    pbufs_freed += pbuf_clen(pcur);
  811874:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811878:	48 89 c7             	mov    %rax,%rdi
  81187b:	48 b8 02 df 80 00 00 	movabs $0x80df02,%rax
  811882:	00 00 00 
  811885:	ff d0                	callq  *%rax
  811887:	0f b6 c0             	movzbl %al,%eax
  81188a:	01 45 fc             	add    %eax,-0x4(%rbp)
    pbuf_free(pcur);    
  81188d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811891:	48 89 c7             	mov    %rax,%rdi
  811894:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81189b:	00 00 00 
  81189e:	ff d0                	callq  *%rax
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  8118a0:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8118a5:	75 ae                	jne    811855 <ip_reass_free_complete_datagram+0x13e>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  8118a7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8118ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8118af:	48 89 d6             	mov    %rdx,%rsi
  8118b2:	48 89 c7             	mov    %rax,%rdi
  8118b5:	48 b8 1c 1b 81 00 00 	movabs $0x811b1c,%rax
  8118bc:	00 00 00 
  8118bf:	ff d0                	callq  *%rax
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  8118c1:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8118c8:	00 00 00 
  8118cb:	0f b7 00             	movzwl (%rax),%eax
  8118ce:	0f b7 c0             	movzwl %ax,%eax
  8118d1:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8118d4:	7d 2a                	jge    811900 <ip_reass_free_complete_datagram+0x1e9>
  8118d6:	48 ba f3 28 82 00 00 	movabs $0x8228f3,%rdx
  8118dd:	00 00 00 
  8118e0:	be bd 00 00 00       	mov    $0xbd,%esi
  8118e5:	48 bf c4 28 82 00 00 	movabs $0x8228c4,%rdi
  8118ec:	00 00 00 
  8118ef:	b8 00 00 00 00       	mov    $0x0,%eax
  8118f4:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8118fb:	00 00 00 
  8118fe:	ff d1                	callq  *%rcx
  ip_reass_pbufcount -= pbufs_freed;
  811900:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811907:	00 00 00 
  81190a:	0f b7 00             	movzwl (%rax),%eax
  81190d:	8b 55 fc             	mov    -0x4(%rbp),%edx
  811910:	29 d0                	sub    %edx,%eax
  811912:	89 c2                	mov    %eax,%edx
  811914:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  81191b:	00 00 00 
  81191e:	66 89 10             	mov    %dx,(%rax)

  return pbufs_freed;
  811921:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  811924:	c9                   	leaveq 
  811925:	c3                   	retq   

0000000000811926 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  811926:	55                   	push   %rbp
  811927:	48 89 e5             	mov    %rsp,%rbp
  81192a:	48 83 ec 40          	sub    $0x40,%rsp
  81192e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  811932:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  811935:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  81193c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  811943:	00 
    prev = NULL;
  811944:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  81194b:	00 
    other_datagrams = 0;
  81194c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    r = reassdatagrams;
  811953:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  81195a:	00 00 00 
  81195d:	48 8b 00             	mov    (%rax),%rax
  811960:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (r != NULL) {
  811964:	e9 89 00 00 00       	jmpq   8119f2 <ip_reass_remove_oldest_datagram+0xcc>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  811969:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81196d:	8b 50 1c             	mov    0x1c(%rax),%edx
  811970:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811974:	8b 40 0c             	mov    0xc(%rax),%eax
  811977:	39 c2                	cmp    %eax,%edx
  811979:	75 27                	jne    8119a2 <ip_reass_remove_oldest_datagram+0x7c>
  81197b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81197f:	8b 50 20             	mov    0x20(%rax),%edx
  811982:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811986:	8b 40 10             	mov    0x10(%rax),%eax
  811989:	39 c2                	cmp    %eax,%edx
  81198b:	75 15                	jne    8119a2 <ip_reass_remove_oldest_datagram+0x7c>
  81198d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811991:	0f b7 50 14          	movzwl 0x14(%rax),%edx
  811995:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811999:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  81199d:	66 39 c2             	cmp    %ax,%dx
  8119a0:	74 31                	je     8119d3 <ip_reass_remove_oldest_datagram+0xad>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  8119a2:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
        if (oldest == NULL) {
  8119a6:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8119ab:	75 0a                	jne    8119b7 <ip_reass_remove_oldest_datagram+0x91>
          oldest = r;
  8119ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8119b1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8119b5:	eb 1c                	jmp    8119d3 <ip_reass_remove_oldest_datagram+0xad>
        } else if (r->timer <= oldest->timer) {
  8119b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8119bb:	0f b6 50 27          	movzbl 0x27(%rax),%edx
  8119bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8119c3:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  8119c7:	38 c2                	cmp    %al,%dl
  8119c9:	77 08                	ja     8119d3 <ip_reass_remove_oldest_datagram+0xad>
          /* older than the previous oldest */
          oldest = r;
  8119cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8119cf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        }
      }
      if (r->next != NULL) {
  8119d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8119d7:	48 8b 00             	mov    (%rax),%rax
  8119da:	48 85 c0             	test   %rax,%rax
  8119dd:	74 08                	je     8119e7 <ip_reass_remove_oldest_datagram+0xc1>
        prev = r;
  8119df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8119e3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      }
      r = r->next;
  8119e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8119eb:	48 8b 00             	mov    (%rax),%rax
  8119ee:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  8119f2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8119f7:	0f 85 6c ff ff ff    	jne    811969 <ip_reass_remove_oldest_datagram+0x43>
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  8119fd:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  811a02:	74 23                	je     811a27 <ip_reass_remove_oldest_datagram+0x101>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  811a04:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811a08:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811a0c:	48 89 d6             	mov    %rdx,%rsi
  811a0f:	48 89 c7             	mov    %rax,%rdi
  811a12:	48 b8 17 17 81 00 00 	movabs $0x811717,%rax
  811a19:	00 00 00 
  811a1c:	ff d0                	callq  *%rax
  811a1e:	89 45 dc             	mov    %eax,-0x24(%rbp)
      pbufs_freed += pbufs_freed_current;
  811a21:	8b 45 dc             	mov    -0x24(%rbp),%eax
  811a24:	01 45 e4             	add    %eax,-0x1c(%rbp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  811a27:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  811a2a:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  811a2d:	7d 0a                	jge    811a39 <ip_reass_remove_oldest_datagram+0x113>
  811a2f:	83 7d e0 01          	cmpl   $0x1,-0x20(%rbp)
  811a33:	0f 8f 03 ff ff ff    	jg     81193c <ip_reass_remove_oldest_datagram+0x16>
  return pbufs_freed;
  811a39:	8b 45 e4             	mov    -0x1c(%rbp),%eax
}
  811a3c:	c9                   	leaveq 
  811a3d:	c3                   	retq   

0000000000811a3e <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  811a3e:	55                   	push   %rbp
  811a3f:	48 89 e5             	mov    %rsp,%rbp
  811a42:	48 83 ec 20          	sub    $0x20,%rsp
  811a46:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  811a4a:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  811a4d:	bf 05 00 00 00       	mov    $0x5,%edi
  811a52:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  811a59:	00 00 00 
  811a5c:	ff d0                	callq  *%rax
  811a5e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (ipr == NULL) {
  811a62:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  811a67:	75 40                	jne    811aa9 <ip_reass_enqueue_new_datagram+0x6b>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  811a69:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  811a6c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811a70:	89 d6                	mov    %edx,%esi
  811a72:	48 89 c7             	mov    %rax,%rdi
  811a75:	48 b8 26 19 81 00 00 	movabs $0x811926,%rax
  811a7c:	00 00 00 
  811a7f:	ff d0                	callq  *%rax
  811a81:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  811a84:	7c 15                	jl     811a9b <ip_reass_enqueue_new_datagram+0x5d>
      ipr = memp_malloc(MEMP_REASSDATA);
  811a86:	bf 05 00 00 00       	mov    $0x5,%edi
  811a8b:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  811a92:	00 00 00 
  811a95:	ff d0                	callq  *%rax
  811a97:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    }
    if (ipr == NULL)
  811a9b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  811aa0:	75 07                	jne    811aa9 <ip_reass_enqueue_new_datagram+0x6b>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
  811aa2:	b8 00 00 00 00       	mov    $0x0,%eax
  811aa7:	eb 71                	jmp    811b1a <ip_reass_enqueue_new_datagram+0xdc>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  811aa9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811aad:	ba 28 00 00 00       	mov    $0x28,%edx
  811ab2:	be 00 00 00 00       	mov    $0x0,%esi
  811ab7:	48 89 c7             	mov    %rax,%rdi
  811aba:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  811ac1:	00 00 00 
  811ac4:	ff d0                	callq  *%rax
  ipr->timer = IP_REASS_MAXAGE;
  811ac6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811aca:	c6 40 27 03          	movb   $0x3,0x27(%rax)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  811ace:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811ad5:	00 00 00 
  811ad8:	48 8b 10             	mov    (%rax),%rdx
  811adb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811adf:	48 89 10             	mov    %rdx,(%rax)
  reassdatagrams = ipr;
  811ae2:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811ae9:	00 00 00 
  811aec:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  811af0:	48 89 10             	mov    %rdx,(%rax)
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  811af3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811af7:	48 8d 48 10          	lea    0x10(%rax),%rcx
  811afb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811aff:	ba 14 00 00 00       	mov    $0x14,%edx
  811b04:	48 89 c6             	mov    %rax,%rsi
  811b07:	48 89 cf             	mov    %rcx,%rdi
  811b0a:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  811b11:	00 00 00 
  811b14:	ff d0                	callq  *%rax
  return ipr;
  811b16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  811b1a:	c9                   	leaveq 
  811b1b:	c3                   	retq   

0000000000811b1c <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  811b1c:	55                   	push   %rbp
  811b1d:	48 89 e5             	mov    %rsp,%rbp
  811b20:	48 83 ec 10          	sub    $0x10,%rsp
  811b24:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  811b28:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  811b2c:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811b33:	00 00 00 
  811b36:	48 8b 00             	mov    (%rax),%rax
  811b39:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  811b3d:	75 16                	jne    811b55 <ip_reass_dequeue_datagram+0x39>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  811b3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811b43:	48 8b 10             	mov    (%rax),%rdx
  811b46:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811b4d:	00 00 00 
  811b50:	48 89 10             	mov    %rdx,(%rax)
  811b53:	eb 3f                	jmp    811b94 <ip_reass_dequeue_datagram+0x78>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  811b55:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  811b5a:	75 2a                	jne    811b86 <ip_reass_dequeue_datagram+0x6a>
  811b5c:	48 ba 0e 29 82 00 00 	movabs $0x82290e,%rdx
  811b63:	00 00 00 
  811b66:	be 2a 01 00 00       	mov    $0x12a,%esi
  811b6b:	48 bf c4 28 82 00 00 	movabs $0x8228c4,%rdi
  811b72:	00 00 00 
  811b75:	b8 00 00 00 00       	mov    $0x0,%eax
  811b7a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  811b81:	00 00 00 
  811b84:	ff d1                	callq  *%rcx
    prev->next = ipr->next;
  811b86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811b8a:	48 8b 10             	mov    (%rax),%rdx
  811b8d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811b91:	48 89 10             	mov    %rdx,(%rax)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  811b94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811b98:	48 89 c6             	mov    %rax,%rsi
  811b9b:	bf 05 00 00 00       	mov    $0x5,%edi
  811ba0:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  811ba7:	00 00 00 
  811baa:	ff d0                	callq  *%rax
}
  811bac:	90                   	nop
  811bad:	c9                   	leaveq 
  811bae:	c3                   	retq   

0000000000811baf <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  811baf:	55                   	push   %rbp
  811bb0:	48 89 e5             	mov    %rsp,%rbp
  811bb3:	53                   	push   %rbx
  811bb4:	48 83 ec 58          	sub    $0x58,%rsp
  811bb8:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  811bbc:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  811bc0:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  811bc7:	00 
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  811bc8:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  811bcf:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811bd3:	48 8b 40 08          	mov    0x8(%rax),%rax
  811bd7:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  811bdb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811bdf:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  811be3:	0f b7 c0             	movzwl %ax,%eax
  811be6:	89 c7                	mov    %eax,%edi
  811be8:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  811bef:	00 00 00 
  811bf2:	ff d0                	callq  *%rax
  811bf4:	89 c3                	mov    %eax,%ebx
  811bf6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811bfa:	0f b7 00             	movzwl (%rax),%eax
  811bfd:	0f b7 c0             	movzwl %ax,%eax
  811c00:	89 c7                	mov    %eax,%edi
  811c02:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  811c09:	00 00 00 
  811c0c:	ff d0                	callq  *%rax
  811c0e:	66 c1 e8 08          	shr    $0x8,%ax
  811c12:	83 e0 0f             	and    $0xf,%eax
  811c15:	c1 e0 02             	shl    $0x2,%eax
  811c18:	29 c3                	sub    %eax,%ebx
  811c1a:	89 d8                	mov    %ebx,%eax
  811c1c:	66 89 45 c6          	mov    %ax,-0x3a(%rbp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  811c20:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811c24:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  811c28:	0f b7 c0             	movzwl %ax,%eax
  811c2b:	89 c7                	mov    %eax,%edi
  811c2d:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  811c34:	00 00 00 
  811c37:	ff d0                	callq  *%rax
  811c39:	66 25 ff 1f          	and    $0x1fff,%ax
  811c3d:	c1 e0 03             	shl    $0x3,%eax
  811c40:	66 89 45 c4          	mov    %ax,-0x3c(%rbp)
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  811c44:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811c48:	48 8b 40 08          	mov    0x8(%rax),%rax
  811c4c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  iprh->next_pbuf = NULL;
  811c50:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811c54:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  iprh->start = offset;
  811c5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811c5f:	0f b7 55 c4          	movzwl -0x3c(%rbp),%edx
  811c63:	66 89 50 08          	mov    %dx,0x8(%rax)
  iprh->end = offset + len;
  811c67:	0f b7 55 c4          	movzwl -0x3c(%rbp),%edx
  811c6b:	0f b7 45 c6          	movzwl -0x3a(%rbp),%eax
  811c6f:	01 c2                	add    %eax,%edx
  811c71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811c75:	66 89 50 0a          	mov    %dx,0xa(%rax)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  811c79:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811c7d:	48 8b 40 08          	mov    0x8(%rax),%rax
  811c81:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  811c85:	e9 eb 00 00 00       	jmpq   811d75 <ip_reass_chain_frag_into_datagram_and_validate+0x1c6>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  811c8a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811c8e:	48 8b 40 08          	mov    0x8(%rax),%rax
  811c92:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    if (iprh->start < iprh_tmp->start) {
  811c96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811c9a:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811c9e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811ca2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811ca6:	66 39 c2             	cmp    %ax,%dx
  811ca9:	73 62                	jae    811d0d <ip_reass_chain_frag_into_datagram_and_validate+0x15e>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  811cab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811caf:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  811cb3:	48 89 10             	mov    %rdx,(%rax)
      if (iprh_prev != NULL) {
  811cb6:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811cbb:	74 42                	je     811cff <ip_reass_chain_frag_into_datagram_and_validate+0x150>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  811cbd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811cc1:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811cc5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811cc9:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  811ccd:	66 39 c2             	cmp    %ax,%dx
  811cd0:	0f 82 03 03 00 00    	jb     811fd9 <ip_reass_chain_frag_into_datagram_and_validate+0x42a>
  811cd6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811cda:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811cde:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811ce2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811ce6:	66 39 c2             	cmp    %ax,%dx
  811ce9:	0f 87 ea 02 00 00    	ja     811fd9 <ip_reass_chain_frag_into_datagram_and_validate+0x42a>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  811cef:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811cf3:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811cf7:	48 89 10             	mov    %rdx,(%rax)
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
  811cfa:	e9 81 00 00 00       	jmpq   811d80 <ip_reass_chain_frag_into_datagram_and_validate+0x1d1>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  811cff:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811d03:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811d07:	48 89 50 08          	mov    %rdx,0x8(%rax)
      }
      break;
  811d0b:	eb 73                	jmp    811d80 <ip_reass_chain_frag_into_datagram_and_validate+0x1d1>
    } else if(iprh->start == iprh_tmp->start) {
  811d0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811d11:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811d15:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811d19:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811d1d:	66 39 c2             	cmp    %ax,%dx
  811d20:	0f 84 af 02 00 00    	je     811fd5 <ip_reass_chain_frag_into_datagram_and_validate+0x426>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  811d26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811d2a:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811d2e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811d32:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  811d36:	66 39 c2             	cmp    %ax,%dx
  811d39:	0f 82 99 02 00 00    	jb     811fd8 <ip_reass_chain_frag_into_datagram_and_validate+0x429>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  811d3f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811d44:	74 1c                	je     811d62 <ip_reass_chain_frag_into_datagram_and_validate+0x1b3>
        if (iprh_prev->end != iprh_tmp->start) {
  811d46:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811d4a:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811d4e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811d52:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811d56:	66 39 c2             	cmp    %ax,%dx
  811d59:	74 07                	je     811d62 <ip_reass_chain_frag_into_datagram_and_validate+0x1b3>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  811d5b:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  811d62:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811d66:	48 8b 00             	mov    (%rax),%rax
  811d69:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    iprh_prev = iprh_tmp;
  811d6d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811d71:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  811d75:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  811d7a:	0f 85 0a ff ff ff    	jne    811c8a <ip_reass_chain_frag_into_datagram_and_validate+0xdb>
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
  811d80:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  811d85:	0f 85 b2 00 00 00    	jne    811e3d <ip_reass_chain_frag_into_datagram_and_validate+0x28e>
    if (iprh_prev != NULL) {
  811d8b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811d90:	74 68                	je     811dfa <ip_reass_chain_frag_into_datagram_and_validate+0x24b>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  811d92:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811d96:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811d9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811d9e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811da2:	66 39 c2             	cmp    %ax,%dx
  811da5:	76 2a                	jbe    811dd1 <ip_reass_chain_frag_into_datagram_and_validate+0x222>
  811da7:	48 ba 27 29 82 00 00 	movabs $0x822927,%rdx
  811dae:	00 00 00 
  811db1:	be 84 01 00 00       	mov    $0x184,%esi
  811db6:	48 bf c4 28 82 00 00 	movabs $0x8228c4,%rdi
  811dbd:	00 00 00 
  811dc0:	b8 00 00 00 00       	mov    $0x0,%eax
  811dc5:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  811dcc:	00 00 00 
  811dcf:	ff d1                	callq  *%rcx
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  811dd1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811dd5:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811dd9:	48 89 10             	mov    %rdx,(%rax)
      if (iprh_prev->end != iprh->start) {
  811ddc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811de0:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811de4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811de8:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811dec:	66 39 c2             	cmp    %ax,%dx
  811def:	74 4c                	je     811e3d <ip_reass_chain_frag_into_datagram_and_validate+0x28e>
        valid = 0;
  811df1:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  811df8:	eb 43                	jmp    811e3d <ip_reass_chain_frag_into_datagram_and_validate+0x28e>
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  811dfa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811dfe:	48 8b 40 08          	mov    0x8(%rax),%rax
  811e02:	48 85 c0             	test   %rax,%rax
  811e05:	74 2a                	je     811e31 <ip_reass_chain_frag_into_datagram_and_validate+0x282>
  811e07:	48 ba 48 29 82 00 00 	movabs $0x822948,%rdx
  811e0e:	00 00 00 
  811e11:	be 8d 01 00 00       	mov    $0x18d,%esi
  811e16:	48 bf c4 28 82 00 00 	movabs $0x8228c4,%rdi
  811e1d:	00 00 00 
  811e20:	b8 00 00 00 00       	mov    $0x0,%eax
  811e25:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  811e2c:	00 00 00 
  811e2f:	ff d1                	callq  *%rcx
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  811e31:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811e35:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811e39:	48 89 50 08          	mov    %rdx,0x8(%rax)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  811e3d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811e41:	0f b6 40 26          	movzbl 0x26(%rax),%eax
  811e45:	0f b6 c0             	movzbl %al,%eax
  811e48:	83 e0 01             	and    $0x1,%eax
  811e4b:	85 c0                	test   %eax,%eax
  811e4d:	0f 84 7b 01 00 00    	je     811fce <ip_reass_chain_frag_into_datagram_and_validate+0x41f>
    /* and had no wholes so far */
    if (valid) {
  811e53:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  811e57:	0f 84 6c 01 00 00    	je     811fc9 <ip_reass_chain_frag_into_datagram_and_validate+0x41a>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  811e5d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811e61:	48 8b 40 08          	mov    0x8(%rax),%rax
  811e65:	48 8b 40 08          	mov    0x8(%rax),%rax
  811e69:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811e6d:	66 85 c0             	test   %ax,%ax
  811e70:	74 0c                	je     811e7e <ip_reass_chain_frag_into_datagram_and_validate+0x2cf>
        valid = 0;
  811e72:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  811e79:	e9 4b 01 00 00       	jmpq   811fc9 <ip_reass_chain_frag_into_datagram_and_validate+0x41a>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
  811e7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811e82:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        q = iprh->next_pbuf;
  811e86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811e8a:	48 8b 00             	mov    (%rax),%rax
  811e8d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        while (q != NULL) {
  811e91:	eb 3d                	jmp    811ed0 <ip_reass_chain_frag_into_datagram_and_validate+0x321>
          iprh = (struct ip_reass_helper*)q->payload;
  811e93:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811e97:	48 8b 40 08          	mov    0x8(%rax),%rax
  811e9b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
          if (iprh_prev->end != iprh->start) {
  811e9f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811ea3:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811ea7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811eab:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811eaf:	66 39 c2             	cmp    %ax,%dx
  811eb2:	74 09                	je     811ebd <ip_reass_chain_frag_into_datagram_and_validate+0x30e>
            valid = 0;
  811eb4:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
            break;
  811ebb:	eb 1a                	jmp    811ed7 <ip_reass_chain_frag_into_datagram_and_validate+0x328>
          }
          iprh_prev = iprh;
  811ebd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811ec1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          q = iprh->next_pbuf;
  811ec5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811ec9:	48 8b 00             	mov    (%rax),%rax
  811ecc:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  811ed0:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  811ed5:	75 bc                	jne    811e93 <ip_reass_chain_frag_into_datagram_and_validate+0x2e4>
          iprh_prev = iprh;
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
  811ed7:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  811edb:	0f 84 e8 00 00 00    	je     811fc9 <ip_reass_chain_frag_into_datagram_and_validate+0x41a>
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  811ee1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811ee5:	48 8b 40 08          	mov    0x8(%rax),%rax
  811ee9:	48 85 c0             	test   %rax,%rax
  811eec:	75 2a                	jne    811f18 <ip_reass_chain_frag_into_datagram_and_validate+0x369>
  811eee:	48 ba 7f 29 82 00 00 	movabs $0x82297f,%rdx
  811ef5:	00 00 00 
  811ef8:	be ad 01 00 00       	mov    $0x1ad,%esi
  811efd:	48 bf c4 28 82 00 00 	movabs $0x8228c4,%rdi
  811f04:	00 00 00 
  811f07:	b8 00 00 00 00       	mov    $0x0,%eax
  811f0c:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  811f13:	00 00 00 
  811f16:	ff d1                	callq  *%rcx
          LWIP_ASSERT("sanity check",
  811f18:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811f1c:	48 8b 40 08          	mov    0x8(%rax),%rax
  811f20:	48 8b 40 08          	mov    0x8(%rax),%rax
  811f24:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  811f28:	75 2a                	jne    811f54 <ip_reass_chain_frag_into_datagram_and_validate+0x3a5>
  811f2a:	48 ba 7f 29 82 00 00 	movabs $0x82297f,%rdx
  811f31:	00 00 00 
  811f34:	be af 01 00 00       	mov    $0x1af,%esi
  811f39:	48 bf c4 28 82 00 00 	movabs $0x8228c4,%rdi
  811f40:	00 00 00 
  811f43:	b8 00 00 00 00       	mov    $0x0,%eax
  811f48:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  811f4f:	00 00 00 
  811f52:	ff d1                	callq  *%rcx
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  811f54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811f58:	48 8b 00             	mov    (%rax),%rax
  811f5b:	48 85 c0             	test   %rax,%rax
  811f5e:	74 2a                	je     811f8a <ip_reass_chain_frag_into_datagram_and_validate+0x3db>
  811f60:	48 ba 90 29 82 00 00 	movabs $0x822990,%rdx
  811f67:	00 00 00 
  811f6a:	be b1 01 00 00       	mov    $0x1b1,%esi
  811f6f:	48 bf c4 28 82 00 00 	movabs $0x8228c4,%rdi
  811f76:	00 00 00 
  811f79:	b8 00 00 00 00       	mov    $0x0,%eax
  811f7e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  811f85:	00 00 00 
  811f88:	ff d1                	callq  *%rcx
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  811f8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811f8e:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811f92:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811f96:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  811f9a:	66 39 c2             	cmp    %ax,%dx
  811f9d:	74 2a                	je     811fc9 <ip_reass_chain_frag_into_datagram_and_validate+0x41a>
  811f9f:	48 ba b8 29 82 00 00 	movabs $0x8229b8,%rdx
  811fa6:	00 00 00 
  811fa9:	be b3 01 00 00       	mov    $0x1b3,%esi
  811fae:	48 bf c4 28 82 00 00 	movabs $0x8228c4,%rdi
  811fb5:	00 00 00 
  811fb8:	b8 00 00 00 00       	mov    $0x0,%eax
  811fbd:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  811fc4:	00 00 00 
  811fc7:	ff d1                	callq  *%rcx
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
  811fc9:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  811fcc:	eb 57                	jmp    812025 <ip_reass_chain_frag_into_datagram_and_validate+0x476>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
  811fce:	b8 00 00 00 00       	mov    $0x0,%eax
  811fd3:	eb 50                	jmp    812025 <ip_reass_chain_frag_into_datagram_and_validate+0x476>
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
  811fd5:	90                   	nop
  811fd6:	eb 01                	jmp    811fd9 <ip_reass_chain_frag_into_datagram_and_validate+0x42a>
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
  811fd8:	90                   	nop
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  811fd9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811fdd:	48 89 c7             	mov    %rax,%rdi
  811fe0:	48 b8 02 df 80 00 00 	movabs $0x80df02,%rax
  811fe7:	00 00 00 
  811fea:	ff d0                	callq  *%rax
  811fec:	89 c1                	mov    %eax,%ecx
  811fee:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811ff5:	00 00 00 
  811ff8:	0f b7 10             	movzwl (%rax),%edx
  811ffb:	0f b6 c1             	movzbl %cl,%eax
  811ffe:	29 c2                	sub    %eax,%edx
  812000:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  812007:	00 00 00 
  81200a:	66 89 10             	mov    %dx,(%rax)
  pbuf_free(new_p);
  81200d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  812011:	48 89 c7             	mov    %rax,%rdi
  812014:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81201b:	00 00 00 
  81201e:	ff d0                	callq  *%rax
  return 0;
  812020:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* IP_REASS_CHECK_OVERLAP */
}
  812025:	48 83 c4 58          	add    $0x58,%rsp
  812029:	5b                   	pop    %rbx
  81202a:	5d                   	pop    %rbp
  81202b:	c3                   	retq   

000000000081202c <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  81202c:	55                   	push   %rbp
  81202d:	48 89 e5             	mov    %rsp,%rbp
  812030:	53                   	push   %rbx
  812031:	48 83 ec 48          	sub    $0x48,%rsp
  812035:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  812039:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  812040:	00 

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  812041:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  812045:	48 8b 40 08          	mov    0x8(%rax),%rax
  812049:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  81204d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812051:	0f b7 00             	movzwl (%rax),%eax
  812054:	0f b7 c0             	movzwl %ax,%eax
  812057:	89 c7                	mov    %eax,%edi
  812059:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  812060:	00 00 00 
  812063:	ff d0                	callq  *%rax
  812065:	66 c1 e8 08          	shr    $0x8,%ax
  812069:	0f b7 c0             	movzwl %ax,%eax
  81206c:	83 e0 0f             	and    $0xf,%eax
  81206f:	c1 e0 02             	shl    $0x2,%eax
  812072:	83 f8 14             	cmp    $0x14,%eax
  812075:	0f 85 d8 03 00 00    	jne    812453 <ip_reass+0x427>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  81207b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81207f:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  812083:	0f b7 c0             	movzwl %ax,%eax
  812086:	89 c7                	mov    %eax,%edi
  812088:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81208f:	00 00 00 
  812092:	ff d0                	callq  *%rax
  812094:	66 25 ff 1f          	and    $0x1fff,%ax
  812098:	c1 e0 03             	shl    $0x3,%eax
  81209b:	66 89 45 ce          	mov    %ax,-0x32(%rbp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  81209f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8120a3:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8120a7:	0f b7 c0             	movzwl %ax,%eax
  8120aa:	89 c7                	mov    %eax,%edi
  8120ac:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  8120b3:	00 00 00 
  8120b6:	ff d0                	callq  *%rax
  8120b8:	89 c3                	mov    %eax,%ebx
  8120ba:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8120be:	0f b7 00             	movzwl (%rax),%eax
  8120c1:	0f b7 c0             	movzwl %ax,%eax
  8120c4:	89 c7                	mov    %eax,%edi
  8120c6:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  8120cd:	00 00 00 
  8120d0:	ff d0                	callq  *%rax
  8120d2:	66 c1 e8 08          	shr    $0x8,%ax
  8120d6:	83 e0 0f             	and    $0xf,%eax
  8120d9:	c1 e0 02             	shl    $0x2,%eax
  8120dc:	29 c3                	sub    %eax,%ebx
  8120de:	89 d8                	mov    %ebx,%eax
  8120e0:	66 89 45 cc          	mov    %ax,-0x34(%rbp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  8120e4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8120e8:	48 89 c7             	mov    %rax,%rdi
  8120eb:	48 b8 02 df 80 00 00 	movabs $0x80df02,%rax
  8120f2:	00 00 00 
  8120f5:	ff d0                	callq  *%rax
  8120f7:	88 45 cb             	mov    %al,-0x35(%rbp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  8120fa:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  812101:	00 00 00 
  812104:	0f b7 00             	movzwl (%rax),%eax
  812107:	0f b7 d0             	movzwl %ax,%edx
  81210a:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  81210e:	01 d0                	add    %edx,%eax
  812110:	83 f8 0a             	cmp    $0xa,%eax
  812113:	7e 40                	jle    812155 <ip_reass+0x129>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  812115:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  812119:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81211d:	89 d6                	mov    %edx,%esi
  81211f:	48 89 c7             	mov    %rax,%rdi
  812122:	48 b8 26 19 81 00 00 	movabs $0x811926,%rax
  812129:	00 00 00 
  81212c:	ff d0                	callq  *%rax
  81212e:	85 c0                	test   %eax,%eax
  812130:	0f 84 20 03 00 00    	je     812456 <ip_reass+0x42a>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  812136:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  81213d:	00 00 00 
  812140:	0f b7 00             	movzwl (%rax),%eax
  812143:	0f b7 d0             	movzwl %ax,%edx
  812146:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  81214a:	01 d0                	add    %edx,%eax

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  81214c:	83 f8 0a             	cmp    $0xa,%eax
  81214f:	0f 8f 01 03 00 00    	jg     812456 <ip_reass+0x42a>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  812155:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  81215c:	00 00 00 
  81215f:	48 8b 00             	mov    (%rax),%rax
  812162:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  812166:	eb 4c                	jmp    8121b4 <ip_reass+0x188>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  812168:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81216c:	8b 50 1c             	mov    0x1c(%rax),%edx
  81216f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812173:	8b 40 0c             	mov    0xc(%rax),%eax
  812176:	39 c2                	cmp    %eax,%edx
  812178:	75 27                	jne    8121a1 <ip_reass+0x175>
  81217a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81217e:	8b 50 20             	mov    0x20(%rax),%edx
  812181:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812185:	8b 40 10             	mov    0x10(%rax),%eax
  812188:	39 c2                	cmp    %eax,%edx
  81218a:	75 15                	jne    8121a1 <ip_reass+0x175>
  81218c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812190:	0f b7 50 14          	movzwl 0x14(%rax),%edx
  812194:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812198:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  81219c:	66 39 c2             	cmp    %ax,%dx
  81219f:	74 1c                	je     8121bd <ip_reass+0x191>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
    }
    ipr_prev = ipr;
  8121a1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8121a5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  8121a9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8121ad:	48 8b 00             	mov    (%rax),%rax
  8121b0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8121b4:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8121b9:	75 ad                	jne    812168 <ip_reass+0x13c>
  8121bb:	eb 01                	jmp    8121be <ip_reass+0x192>
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
  8121bd:	90                   	nop
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
  8121be:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8121c3:	75 29                	jne    8121ee <ip_reass+0x1c2>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
  8121c5:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  8121c9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8121cd:	89 d6                	mov    %edx,%esi
  8121cf:	48 89 c7             	mov    %rax,%rdi
  8121d2:	48 b8 3e 1a 81 00 00 	movabs $0x811a3e,%rax
  8121d9:	00 00 00 
  8121dc:	ff d0                	callq  *%rax
  8121de:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
  8121e2:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8121e7:	75 72                	jne    81225b <ip_reass+0x22f>
      goto nullreturn;
  8121e9:	e9 69 02 00 00       	jmpq   812457 <ip_reass+0x42b>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  8121ee:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8121f2:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  8121f6:	0f b7 c0             	movzwl %ax,%eax
  8121f9:	89 c7                	mov    %eax,%edi
  8121fb:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  812202:	00 00 00 
  812205:	ff d0                	callq  *%rax
  812207:	0f b7 c0             	movzwl %ax,%eax
  81220a:	25 ff 1f 00 00       	and    $0x1fff,%eax
  81220f:	85 c0                	test   %eax,%eax
  812211:	75 48                	jne    81225b <ip_reass+0x22f>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  812213:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812217:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  81221b:	0f b7 c0             	movzwl %ax,%eax
  81221e:	89 c7                	mov    %eax,%edi
  812220:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  812227:	00 00 00 
  81222a:	ff d0                	callq  *%rax
  81222c:	0f b7 c0             	movzwl %ax,%eax
  81222f:	25 ff 1f 00 00       	and    $0x1fff,%eax
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  812234:	85 c0                	test   %eax,%eax
  812236:	74 23                	je     81225b <ip_reass+0x22f>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  812238:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81223c:	48 8d 48 10          	lea    0x10(%rax),%rcx
  812240:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812244:	ba 14 00 00 00       	mov    $0x14,%edx
  812249:	48 89 c6             	mov    %rax,%rsi
  81224c:	48 89 cf             	mov    %rcx,%rdi
  81224f:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  812256:	00 00 00 
  812259:	ff d0                	callq  *%rax
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  81225b:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  81225f:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  812266:	00 00 00 
  812269:	0f b7 00             	movzwl (%rax),%eax
  81226c:	01 c2                	add    %eax,%edx
  81226e:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  812275:	00 00 00 
  812278:	66 89 10             	mov    %dx,(%rax)

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  81227b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81227f:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  812283:	0f b7 c0             	movzwl %ax,%eax
  812286:	89 c7                	mov    %eax,%edi
  812288:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81228f:	00 00 00 
  812292:	ff d0                	callq  *%rax
  812294:	0f b7 c0             	movzwl %ax,%eax
  812297:	25 00 20 00 00       	and    $0x2000,%eax
  81229c:	85 c0                	test   %eax,%eax
  81229e:	75 26                	jne    8122c6 <ip_reass+0x29a>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  8122a0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8122a4:	0f b6 40 26          	movzbl 0x26(%rax),%eax
  8122a8:	83 c8 01             	or     $0x1,%eax
  8122ab:	89 c2                	mov    %eax,%edx
  8122ad:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8122b1:	88 50 26             	mov    %dl,0x26(%rax)
    ipr->datagram_len = offset + len;
  8122b4:	0f b7 55 ce          	movzwl -0x32(%rbp),%edx
  8122b8:	0f b7 45 cc          	movzwl -0x34(%rbp),%eax
  8122bc:	01 c2                	add    %eax,%edx
  8122be:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8122c2:	66 89 50 24          	mov    %dx,0x24(%rax)
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
  8122c6:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8122ca:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8122ce:	48 89 d6             	mov    %rdx,%rsi
  8122d1:	48 89 c7             	mov    %rax,%rdi
  8122d4:	48 b8 af 1b 81 00 00 	movabs $0x811baf,%rax
  8122db:	00 00 00 
  8122de:	ff d0                	callq  *%rax
  8122e0:	85 c0                	test   %eax,%eax
  8122e2:	0f 84 64 01 00 00    	je     81244c <ip_reass+0x420>
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  8122e8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8122ec:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  8122f0:	8d 50 14             	lea    0x14(%rax),%edx
  8122f3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8122f7:	66 89 50 24          	mov    %dx,0x24(%rax)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  8122fb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8122ff:	48 8b 40 08          	mov    0x8(%rax),%rax
  812303:	48 8b 40 08          	mov    0x8(%rax),%rax
  812307:	48 8b 00             	mov    (%rax),%rax
  81230a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
  81230e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812312:	48 8b 40 08          	mov    0x8(%rax),%rax
  812316:	48 8b 40 08          	mov    0x8(%rax),%rax
  81231a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  81231e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812322:	48 8d 48 10          	lea    0x10(%rax),%rcx
  812326:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81232a:	ba 14 00 00 00       	mov    $0x14,%edx
  81232f:	48 89 ce             	mov    %rcx,%rsi
  812332:	48 89 c7             	mov    %rax,%rdi
  812335:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  81233c:	00 00 00 
  81233f:	ff d0                	callq  *%rax
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  812341:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812345:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  812349:	0f b7 c0             	movzwl %ax,%eax
  81234c:	89 c7                	mov    %eax,%edi
  81234e:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  812355:	00 00 00 
  812358:	ff d0                	callq  *%rax
  81235a:	89 c2                	mov    %eax,%edx
  81235c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812360:	66 89 50 02          	mov    %dx,0x2(%rax)
    IPH_OFFSET_SET(fraghdr, 0);
  812364:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812368:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
    IPH_CHKSUM_SET(fraghdr, 0);
  81236e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812372:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  812378:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81237c:	be 14 00 00 00       	mov    $0x14,%esi
  812381:	48 89 c7             	mov    %rax,%rdi
  812384:	48 b8 4e 2b 81 00 00 	movabs $0x812b4e,%rax
  81238b:	00 00 00 
  81238e:	ff d0                	callq  *%rax
  812390:	89 c2                	mov    %eax,%edx
  812392:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812396:	66 89 50 0a          	mov    %dx,0xa(%rax)

    p = ipr->p;
  81239a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81239e:	48 8b 40 08          	mov    0x8(%rax),%rax
  8123a2:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  8123a6:	eb 49                	jmp    8123f1 <ip_reass+0x3c5>
      iprh = (struct ip_reass_helper*)r->payload;
  8123a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8123ac:	48 8b 40 08          	mov    0x8(%rax),%rax
  8123b0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  8123b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8123b8:	be ec ff ff ff       	mov    $0xffffffec,%esi
  8123bd:	48 89 c7             	mov    %rax,%rdi
  8123c0:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  8123c7:	00 00 00 
  8123ca:	ff d0                	callq  *%rax
      pbuf_cat(p, r);
  8123cc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8123d0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8123d4:	48 89 d6             	mov    %rdx,%rsi
  8123d7:	48 89 c7             	mov    %rax,%rdi
  8123da:	48 b8 59 df 80 00 00 	movabs $0x80df59,%rax
  8123e1:	00 00 00 
  8123e4:	ff d0                	callq  *%rax
      r = iprh->next_pbuf;
  8123e6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8123ea:	48 8b 00             	mov    (%rax),%rax
  8123ed:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  8123f1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8123f6:	75 b0                	jne    8123a8 <ip_reass+0x37c>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  8123f8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8123fc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812400:	48 89 d6             	mov    %rdx,%rsi
  812403:	48 89 c7             	mov    %rax,%rdi
  812406:	48 b8 1c 1b 81 00 00 	movabs $0x811b1c,%rax
  81240d:	00 00 00 
  812410:	ff d0                	callq  *%rax

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  812412:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  812416:	48 89 c7             	mov    %rax,%rdi
  812419:	48 b8 02 df 80 00 00 	movabs $0x80df02,%rax
  812420:	00 00 00 
  812423:	ff d0                	callq  *%rax
  812425:	89 c1                	mov    %eax,%ecx
  812427:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  81242e:	00 00 00 
  812431:	0f b7 10             	movzwl (%rax),%edx
  812434:	0f b6 c1             	movzbl %cl,%eax
  812437:	29 c2                	sub    %eax,%edx
  812439:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  812440:	00 00 00 
  812443:	66 89 10             	mov    %dx,(%rax)

    /* Return the pbuf chain */
    return p;
  812446:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81244a:	eb 23                	jmp    81246f <ip_reass+0x443>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  81244c:	b8 00 00 00 00       	mov    $0x0,%eax
  812451:	eb 1c                	jmp    81246f <ip_reass+0x443>
  fraghdr = (struct ip_hdr*)p->payload;

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  812453:	90                   	nop
  812454:	eb 01                	jmp    812457 <ip_reass+0x42b>
      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
        ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
      IPFRAG_STATS_INC(ip_frag.memerr);
      /* @todo: send ICMP time exceeded here? */
      /* drop this pbuf */
      goto nullreturn;
  812456:	90                   	nop
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  812457:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81245b:	48 89 c7             	mov    %rax,%rdi
  81245e:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  812465:	00 00 00 
  812468:	ff d0                	callq  *%rax
  return NULL;
  81246a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81246f:	48 83 c4 48          	add    $0x48,%rsp
  812473:	5b                   	pop    %rbx
  812474:	5d                   	pop    %rbp
  812475:	c3                   	retq   

0000000000812476 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  812476:	55                   	push   %rbp
  812477:	48 89 e5             	mov    %rsp,%rbp
  81247a:	48 83 ec 50          	sub    $0x50,%rsp
  81247e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  812482:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  812486:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  81248a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81248e:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  812492:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  812496:	66 c7 45 fa 14 00    	movw   $0x14,-0x6(%rbp)
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  81249c:	ba 02 00 00 00       	mov    $0x2,%edx
  8124a1:	be 00 00 00 00       	mov    $0x0,%esi
  8124a6:	bf 02 00 00 00       	mov    $0x2,%edi
  8124ab:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  8124b2:	00 00 00 
  8124b5:	ff d0                	callq  *%rax
  8124b7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (rambuf == NULL) {
  8124bb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8124c0:	75 0a                	jne    8124cc <ip_frag+0x56>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  8124c2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8124c7:	e9 85 02 00 00       	jmpq   812751 <ip_frag+0x2db>
  }
  rambuf->tot_len = rambuf->len = mtu;
  8124cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8124d0:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8124d4:	66 89 50 12          	mov    %dx,0x12(%rax)
  8124d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8124dc:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  8124e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8124e4:	66 89 50 10          	mov    %dx,0x10(%rax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  8124e8:	48 b8 80 b0 b4 00 00 	movabs $0xb4b080,%rax
  8124ef:	00 00 00 
  8124f2:	48 83 c0 03          	add    $0x3,%rax
  8124f6:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  8124fa:	48 89 c2             	mov    %rax,%rdx
  8124fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812501:	48 89 50 08          	mov    %rdx,0x8(%rax)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  812505:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812509:	48 8b 40 08          	mov    0x8(%rax),%rax
  81250d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  812511:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812515:	48 8b 48 08          	mov    0x8(%rax),%rcx
  812519:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81251d:	ba 14 00 00 00       	mov    $0x14,%edx
  812522:	48 89 ce             	mov    %rcx,%rsi
  812525:	48 89 c7             	mov    %rax,%rdi
  812528:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  81252f:	00 00 00 
  812532:	ff d0                	callq  *%rax
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  812534:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812538:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  81253c:	0f b7 c0             	movzwl %ax,%eax
  81253f:	89 c7                	mov    %eax,%edi
  812541:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  812548:	00 00 00 
  81254b:	ff d0                	callq  *%rax
  81254d:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
  ofo = tmp & IP_OFFMASK;
  812551:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  812555:	66 25 ff 1f          	and    $0x1fff,%ax
  812559:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  omf = tmp & IP_MF;
  81255d:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  812561:	66 25 00 20          	and    $0x2000,%ax
  812565:	66 89 45 de          	mov    %ax,-0x22(%rbp)

  left = p->tot_len - IP_HLEN;
  812569:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81256d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  812571:	83 e8 14             	sub    $0x14,%eax
  812574:	66 89 45 fe          	mov    %ax,-0x2(%rbp)

  nfb = (mtu - IP_HLEN) / 8;
  812578:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  81257c:	83 e8 14             	sub    $0x14,%eax
  81257f:	8d 50 07             	lea    0x7(%rax),%edx
  812582:	85 c0                	test   %eax,%eax
  812584:	0f 48 c2             	cmovs  %edx,%eax
  812587:	c1 f8 03             	sar    $0x3,%eax
  81258a:	66 89 45 dc          	mov    %ax,-0x24(%rbp)

  while (left) {
  81258e:	e9 9b 01 00 00       	jmpq   81272e <ip_frag+0x2b8>
    last = (left <= mtu - IP_HLEN);
  812593:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  812597:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  81259b:	83 ea 14             	sub    $0x14,%edx
  81259e:	39 d0                	cmp    %edx,%eax
  8125a0:	0f 9e c0             	setle  %al
  8125a3:	0f b6 c0             	movzbl %al,%eax
  8125a6:	66 89 45 da          	mov    %ax,-0x26(%rbp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  8125aa:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  8125ae:	66 25 ff 1f          	and    $0x1fff,%ax
  8125b2:	66 0b 45 de          	or     -0x22(%rbp),%ax
  8125b6:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
    if (!last)
  8125ba:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  8125bf:	75 06                	jne    8125c7 <ip_frag+0x151>
      tmp = tmp | IP_MF;
  8125c1:	66 81 4d f8 00 20    	orw    $0x2000,-0x8(%rbp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  8125c7:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  8125cc:	75 09                	jne    8125d7 <ip_frag+0x161>
  8125ce:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8125d2:	c1 e0 03             	shl    $0x3,%eax
  8125d5:	eb 04                	jmp    8125db <ip_frag+0x165>
  8125d7:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  8125db:	66 89 45 d8          	mov    %ax,-0x28(%rbp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8125df:	0f b7 4d fa          	movzwl -0x6(%rbp),%ecx
  8125e3:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  8125e7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8125eb:	48 8d 70 14          	lea    0x14(%rax),%rsi
  8125ef:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8125f3:	48 89 c7             	mov    %rax,%rdi
  8125f6:	48 b8 5e e4 80 00 00 	movabs $0x80e45e,%rax
  8125fd:	00 00 00 
  812600:	ff d0                	callq  *%rax
  812602:	66 01 45 fa          	add    %ax,-0x6(%rbp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  812606:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  81260a:	89 c7                	mov    %eax,%edi
  81260c:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  812613:	00 00 00 
  812616:	ff d0                	callq  *%rax
  812618:	89 c2                	mov    %eax,%edx
  81261a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81261e:	66 89 50 06          	mov    %dx,0x6(%rax)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  812622:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  812626:	83 c0 14             	add    $0x14,%eax
  812629:	0f b7 c0             	movzwl %ax,%eax
  81262c:	89 c7                	mov    %eax,%edi
  81262e:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  812635:	00 00 00 
  812638:	ff d0                	callq  *%rax
  81263a:	89 c2                	mov    %eax,%edx
  81263c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812640:	66 89 50 02          	mov    %dx,0x2(%rax)
    IPH_CHKSUM_SET(iphdr, 0);
  812644:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812648:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  81264e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812652:	be 14 00 00 00       	mov    $0x14,%esi
  812657:	48 89 c7             	mov    %rax,%rdi
  81265a:	48 b8 4e 2b 81 00 00 	movabs $0x812b4e,%rax
  812661:	00 00 00 
  812664:	ff d0                	callq  *%rax
  812666:	89 c2                	mov    %eax,%edx
  812668:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81266c:	66 89 50 0a          	mov    %dx,0xa(%rax)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  812670:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  812675:	74 1f                	je     812696 <ip_frag+0x220>
      pbuf_realloc(rambuf, left + IP_HLEN);
  812677:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81267b:	83 c0 14             	add    $0x14,%eax
  81267e:	0f b7 d0             	movzwl %ax,%edx
  812681:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812685:	89 d6                	mov    %edx,%esi
  812687:	48 89 c7             	mov    %rax,%rdi
  81268a:	48 b8 3f d9 80 00 00 	movabs $0x80d93f,%rax
  812691:	00 00 00 
  812694:	ff d0                	callq  *%rax
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  812696:	ba 00 00 00 00       	mov    $0x0,%edx
  81269b:	be 00 00 00 00       	mov    $0x0,%esi
  8126a0:	bf 02 00 00 00       	mov    $0x2,%edi
  8126a5:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  8126ac:	00 00 00 
  8126af:	ff d0                	callq  *%rax
  8126b1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (header != NULL) {
  8126b5:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8126ba:	74 48                	je     812704 <ip_frag+0x28e>
      pbuf_chain(header, rambuf);
  8126bc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8126c0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8126c4:	48 89 d6             	mov    %rdx,%rsi
  8126c7:	48 89 c7             	mov    %rax,%rdi
  8126ca:	48 b8 79 e0 80 00 00 	movabs $0x80e079,%rax
  8126d1:	00 00 00 
  8126d4:	ff d0                	callq  *%rax
      netif->output(netif, header, dest);
  8126d6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8126da:	48 8b 40 20          	mov    0x20(%rax),%rax
  8126de:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8126e2:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8126e6:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8126ea:	48 89 cf             	mov    %rcx,%rdi
  8126ed:	ff d0                	callq  *%rax
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  8126ef:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8126f3:	48 89 c7             	mov    %rax,%rdi
  8126f6:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  8126fd:	00 00 00 
  812700:	ff d0                	callq  *%rax
  812702:	eb 1a                	jmp    81271e <ip_frag+0x2a8>
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  812704:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812708:	48 89 c7             	mov    %rax,%rdi
  81270b:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  812712:	00 00 00 
  812715:	ff d0                	callq  *%rax
      return ERR_MEM;
  812717:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81271c:	eb 33                	jmp    812751 <ip_frag+0x2db>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  81271e:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  812722:	66 29 45 fe          	sub    %ax,-0x2(%rbp)
    ofo += nfb;
  812726:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  81272a:	66 01 45 fc          	add    %ax,-0x4(%rbp)

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  81272e:	66 83 7d fe 00       	cmpw   $0x0,-0x2(%rbp)
  812733:	0f 85 5a fe ff ff    	jne    812593 <ip_frag+0x11d>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  812739:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81273d:	48 89 c7             	mov    %rax,%rdi
  812740:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  812747:	00 00 00 
  81274a:	ff d0                	callq  *%rax
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  81274c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  812751:	c9                   	leaveq 
  812752:	c3                   	retq   

0000000000812753 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  812753:	55                   	push   %rbp
  812754:	48 89 e5             	mov    %rsp,%rbp
  812757:	48 83 ec 30          	sub    $0x30,%rsp
  81275b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81275f:	89 f0                	mov    %esi,%eax
  812761:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  812765:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  81276c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812770:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  while (len > 1) {
  812774:	eb 35                	jmp    8127ab <lwip_standard_chksum+0x58>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  812776:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81277a:	0f b6 00             	movzbl (%rax),%eax
  81277d:	0f b6 c0             	movzbl %al,%eax
  812780:	c1 e0 08             	shl    $0x8,%eax
  812783:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    octetptr++;
  812787:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
    /* declare second octet as least significant */
    src |= (*octetptr);
  81278c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812790:	0f b6 00             	movzbl (%rax),%eax
  812793:	0f b6 c0             	movzbl %al,%eax
  812796:	66 09 45 ee          	or     %ax,-0x12(%rbp)
    octetptr++;
  81279a:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
    acc += src;
  81279f:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  8127a3:	01 45 fc             	add    %eax,-0x4(%rbp)
    len -= 2;
  8127a6:	66 83 6d d4 02       	subw   $0x2,-0x2c(%rbp)
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8127ab:	66 83 7d d4 01       	cmpw   $0x1,-0x2c(%rbp)
  8127b0:	77 c4                	ja     812776 <lwip_standard_chksum+0x23>
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  8127b2:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%rbp)
  8127b7:	74 18                	je     8127d1 <lwip_standard_chksum+0x7e>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  8127b9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8127bd:	0f b6 00             	movzbl (%rax),%eax
  8127c0:	0f b6 c0             	movzbl %al,%eax
  8127c3:	c1 e0 08             	shl    $0x8,%eax
  8127c6:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    acc += src;
  8127ca:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  8127ce:	01 45 fc             	add    %eax,-0x4(%rbp)
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8127d1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8127d4:	c1 e8 10             	shr    $0x10,%eax
  8127d7:	89 c2                	mov    %eax,%edx
  8127d9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8127dc:	0f b7 c0             	movzwl %ax,%eax
  8127df:	01 d0                	add    %edx,%eax
  8127e1:	89 45 fc             	mov    %eax,-0x4(%rbp)
  if ((acc & 0xffff0000) != 0) {
  8127e4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8127e7:	66 b8 00 00          	mov    $0x0,%ax
  8127eb:	85 c0                	test   %eax,%eax
  8127ed:	74 13                	je     812802 <lwip_standard_chksum+0xaf>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8127ef:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8127f2:	c1 e8 10             	shr    $0x10,%eax
  8127f5:	89 c2                	mov    %eax,%edx
  8127f7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8127fa:	0f b7 c0             	movzwl %ax,%eax
  8127fd:	01 d0                	add    %edx,%eax
  8127ff:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  812802:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812805:	0f b7 c0             	movzwl %ax,%eax
  812808:	89 c7                	mov    %eax,%edi
  81280a:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  812811:	00 00 00 
  812814:	ff d0                	callq  *%rax
}
  812816:	c9                   	leaveq 
  812817:	c3                   	retq   

0000000000812818 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  812818:	55                   	push   %rbp
  812819:	48 89 e5             	mov    %rsp,%rbp
  81281c:	48 83 ec 40          	sub    $0x40,%rsp
  812820:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  812824:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  812828:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  81282c:	89 c8                	mov    %ecx,%eax
  81282e:	44 89 c2             	mov    %r8d,%edx
  812831:	88 45 c4             	mov    %al,-0x3c(%rbp)
  812834:	66 89 55 c0          	mov    %dx,-0x40(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  812838:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  81283f:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  812843:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812847:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  81284b:	eb 7d                	jmp    8128ca <inet_chksum_pseudo+0xb2>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  81284d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812851:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812855:	0f b7 d0             	movzwl %ax,%edx
  812858:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81285c:	48 8b 40 08          	mov    0x8(%rax),%rax
  812860:	89 d6                	mov    %edx,%esi
  812862:	48 89 c7             	mov    %rax,%rdi
  812865:	48 b8 53 27 81 00 00 	movabs $0x812753,%rax
  81286c:	00 00 00 
  81286f:	ff d0                	callq  *%rax
  812871:	0f b7 c0             	movzwl %ax,%eax
  812874:	01 45 fc             	add    %eax,-0x4(%rbp)
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  812877:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81287a:	c1 e8 10             	shr    $0x10,%eax
  81287d:	89 c2                	mov    %eax,%edx
  81287f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812882:	0f b7 c0             	movzwl %ax,%eax
  812885:	01 d0                	add    %edx,%eax
  812887:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  81288a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81288e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812892:	83 e0 01             	and    $0x1,%eax
  812895:	66 85 c0             	test   %ax,%ax
  812898:	74 25                	je     8128bf <inet_chksum_pseudo+0xa7>
      swapped = 1 - swapped;
  81289a:	b8 01 00 00 00       	mov    $0x1,%eax
  81289f:	2a 45 ef             	sub    -0x11(%rbp),%al
  8128a2:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  8128a5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8128a8:	c1 e0 08             	shl    $0x8,%eax
  8128ab:	0f b7 c0             	movzwl %ax,%eax
  8128ae:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8128b1:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  8128b7:	c1 ea 08             	shr    $0x8,%edx
  8128ba:	09 d0                	or     %edx,%eax
  8128bc:	89 45 fc             	mov    %eax,-0x4(%rbp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  8128bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8128c3:	48 8b 00             	mov    (%rax),%rax
  8128c6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8128ca:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8128cf:	0f 85 78 ff ff ff    	jne    81284d <inet_chksum_pseudo+0x35>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  8128d5:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  8128d9:	74 1a                	je     8128f5 <inet_chksum_pseudo+0xdd>
    acc = SWAP_BYTES_IN_WORD(acc);
  8128db:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8128de:	c1 e0 08             	shl    $0x8,%eax
  8128e1:	0f b7 c0             	movzwl %ax,%eax
  8128e4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8128e7:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  8128ed:	c1 ea 08             	shr    $0x8,%edx
  8128f0:	09 d0                	or     %edx,%eax
  8128f2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  acc += (src->addr & 0xffffUL);
  8128f5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8128f9:	8b 00                	mov    (%rax),%eax
  8128fb:	0f b7 c0             	movzwl %ax,%eax
  8128fe:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((src->addr >> 16) & 0xffffUL);
  812901:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812905:	8b 00                	mov    (%rax),%eax
  812907:	c1 e8 10             	shr    $0x10,%eax
  81290a:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (dest->addr & 0xffffUL);
  81290d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812911:	8b 00                	mov    (%rax),%eax
  812913:	0f b7 c0             	movzwl %ax,%eax
  812916:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((dest->addr >> 16) & 0xffffUL);
  812919:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81291d:	8b 00                	mov    (%rax),%eax
  81291f:	c1 e8 10             	shr    $0x10,%eax
  812922:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons((u16_t)proto);
  812925:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  812929:	89 c7                	mov    %eax,%edi
  81292b:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  812932:	00 00 00 
  812935:	ff d0                	callq  *%rax
  812937:	0f b7 c0             	movzwl %ax,%eax
  81293a:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons(proto_len);
  81293d:	0f b7 45 c0          	movzwl -0x40(%rbp),%eax
  812941:	89 c7                	mov    %eax,%edi
  812943:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  81294a:	00 00 00 
  81294d:	ff d0                	callq  *%rax
  81294f:	0f b7 c0             	movzwl %ax,%eax
  812952:	01 45 fc             	add    %eax,-0x4(%rbp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  812955:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812958:	c1 e8 10             	shr    $0x10,%eax
  81295b:	89 c2                	mov    %eax,%edx
  81295d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812960:	0f b7 c0             	movzwl %ax,%eax
  812963:	01 d0                	add    %edx,%eax
  812965:	89 45 fc             	mov    %eax,-0x4(%rbp)
  acc = FOLD_U32T(acc);
  812968:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81296b:	c1 e8 10             	shr    $0x10,%eax
  81296e:	89 c2                	mov    %eax,%edx
  812970:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812973:	0f b7 c0             	movzwl %ax,%eax
  812976:	01 d0                	add    %edx,%eax
  812978:	89 45 fc             	mov    %eax,-0x4(%rbp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  81297b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81297e:	f7 d0                	not    %eax
}
  812980:	c9                   	leaveq 
  812981:	c3                   	retq   

0000000000812982 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  812982:	55                   	push   %rbp
  812983:	48 89 e5             	mov    %rsp,%rbp
  812986:	48 83 ec 50          	sub    $0x50,%rsp
  81298a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81298e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  812992:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  812996:	89 c8                	mov    %ecx,%eax
  812998:	44 89 c1             	mov    %r8d,%ecx
  81299b:	44 89 ca             	mov    %r9d,%edx
  81299e:	88 45 c4             	mov    %al,-0x3c(%rbp)
  8129a1:	66 89 4d c0          	mov    %cx,-0x40(%rbp)
  8129a5:	66 89 55 bc          	mov    %dx,-0x44(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  8129a9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  8129b0:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  8129b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8129b8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8129bc:	e9 ce 00 00 00       	jmpq   812a8f <inet_chksum_pseudo_partial+0x10d>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  8129c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8129c5:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8129c9:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    if (chklen > chksum_len) {
  8129cd:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  8129d1:	66 3b 45 bc          	cmp    -0x44(%rbp),%ax
  8129d5:	76 08                	jbe    8129df <inet_chksum_pseudo_partial+0x5d>
      chklen = chksum_len;
  8129d7:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  8129db:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  8129df:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  8129e3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8129e7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8129eb:	89 d6                	mov    %edx,%esi
  8129ed:	48 89 c7             	mov    %rax,%rdi
  8129f0:	48 b8 53 27 81 00 00 	movabs $0x812753,%rax
  8129f7:	00 00 00 
  8129fa:	ff d0                	callq  *%rax
  8129fc:	0f b7 c0             	movzwl %ax,%eax
  8129ff:	01 45 fc             	add    %eax,-0x4(%rbp)
    chksum_len -= chklen;
  812a02:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  812a06:	66 29 45 bc          	sub    %ax,-0x44(%rbp)
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  812a0a:	66 81 7d bc fe 7f    	cmpw   $0x7ffe,-0x44(%rbp)
  812a10:	76 2a                	jbe    812a3c <inet_chksum_pseudo_partial+0xba>
  812a12:	48 ba e8 29 82 00 00 	movabs $0x8229e8,%rdx
  812a19:	00 00 00 
  812a1c:	be 61 01 00 00       	mov    $0x161,%esi
  812a21:	48 bf f8 29 82 00 00 	movabs $0x8229f8,%rdi
  812a28:	00 00 00 
  812a2b:	b8 00 00 00 00       	mov    $0x0,%eax
  812a30:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  812a37:	00 00 00 
  812a3a:	ff d1                	callq  *%rcx
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  812a3c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812a3f:	c1 e8 10             	shr    $0x10,%eax
  812a42:	89 c2                	mov    %eax,%edx
  812a44:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812a47:	0f b7 c0             	movzwl %ax,%eax
  812a4a:	01 d0                	add    %edx,%eax
  812a4c:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  812a4f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812a53:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812a57:	83 e0 01             	and    $0x1,%eax
  812a5a:	66 85 c0             	test   %ax,%ax
  812a5d:	74 25                	je     812a84 <inet_chksum_pseudo_partial+0x102>
      swapped = 1 - swapped;
  812a5f:	b8 01 00 00 00       	mov    $0x1,%eax
  812a64:	2a 45 ef             	sub    -0x11(%rbp),%al
  812a67:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  812a6a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812a6d:	c1 e0 08             	shl    $0x8,%eax
  812a70:	0f b7 c0             	movzwl %ax,%eax
  812a73:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812a76:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  812a7c:	c1 ea 08             	shr    $0x8,%edx
  812a7f:	09 d0                	or     %edx,%eax
  812a81:	89 45 fc             	mov    %eax,-0x4(%rbp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  812a84:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812a88:	48 8b 00             	mov    (%rax),%rax
  812a8b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  812a8f:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  812a94:	74 0b                	je     812aa1 <inet_chksum_pseudo_partial+0x11f>
  812a96:	66 83 7d bc 00       	cmpw   $0x0,-0x44(%rbp)
  812a9b:	0f 85 20 ff ff ff    	jne    8129c1 <inet_chksum_pseudo_partial+0x3f>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  812aa1:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  812aa5:	74 1a                	je     812ac1 <inet_chksum_pseudo_partial+0x13f>
    acc = SWAP_BYTES_IN_WORD(acc);
  812aa7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812aaa:	c1 e0 08             	shl    $0x8,%eax
  812aad:	0f b7 c0             	movzwl %ax,%eax
  812ab0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812ab3:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  812ab9:	c1 ea 08             	shr    $0x8,%edx
  812abc:	09 d0                	or     %edx,%eax
  812abe:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  acc += (src->addr & 0xffffUL);
  812ac1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812ac5:	8b 00                	mov    (%rax),%eax
  812ac7:	0f b7 c0             	movzwl %ax,%eax
  812aca:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((src->addr >> 16) & 0xffffUL);
  812acd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812ad1:	8b 00                	mov    (%rax),%eax
  812ad3:	c1 e8 10             	shr    $0x10,%eax
  812ad6:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (dest->addr & 0xffffUL);
  812ad9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812add:	8b 00                	mov    (%rax),%eax
  812adf:	0f b7 c0             	movzwl %ax,%eax
  812ae2:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((dest->addr >> 16) & 0xffffUL);
  812ae5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812ae9:	8b 00                	mov    (%rax),%eax
  812aeb:	c1 e8 10             	shr    $0x10,%eax
  812aee:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons((u16_t)proto);
  812af1:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  812af5:	89 c7                	mov    %eax,%edi
  812af7:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  812afe:	00 00 00 
  812b01:	ff d0                	callq  *%rax
  812b03:	0f b7 c0             	movzwl %ax,%eax
  812b06:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons(proto_len);
  812b09:	0f b7 45 c0          	movzwl -0x40(%rbp),%eax
  812b0d:	89 c7                	mov    %eax,%edi
  812b0f:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  812b16:	00 00 00 
  812b19:	ff d0                	callq  *%rax
  812b1b:	0f b7 c0             	movzwl %ax,%eax
  812b1e:	01 45 fc             	add    %eax,-0x4(%rbp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  812b21:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812b24:	c1 e8 10             	shr    $0x10,%eax
  812b27:	89 c2                	mov    %eax,%edx
  812b29:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812b2c:	0f b7 c0             	movzwl %ax,%eax
  812b2f:	01 d0                	add    %edx,%eax
  812b31:	89 45 fc             	mov    %eax,-0x4(%rbp)
  acc = FOLD_U32T(acc);
  812b34:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812b37:	c1 e8 10             	shr    $0x10,%eax
  812b3a:	89 c2                	mov    %eax,%edx
  812b3c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812b3f:	0f b7 c0             	movzwl %ax,%eax
  812b42:	01 d0                	add    %edx,%eax
  812b44:	89 45 fc             	mov    %eax,-0x4(%rbp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  812b47:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812b4a:	f7 d0                	not    %eax
}
  812b4c:	c9                   	leaveq 
  812b4d:	c3                   	retq   

0000000000812b4e <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  812b4e:	55                   	push   %rbp
  812b4f:	48 89 e5             	mov    %rsp,%rbp
  812b52:	48 83 ec 10          	sub    $0x10,%rsp
  812b56:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  812b5a:	89 f0                	mov    %esi,%eax
  812b5c:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  return ~LWIP_CHKSUM(dataptr, len);
  812b60:	0f b7 55 f4          	movzwl -0xc(%rbp),%edx
  812b64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812b68:	89 d6                	mov    %edx,%esi
  812b6a:	48 89 c7             	mov    %rax,%rdi
  812b6d:	48 b8 53 27 81 00 00 	movabs $0x812753,%rax
  812b74:	00 00 00 
  812b77:	ff d0                	callq  *%rax
  812b79:	f7 d0                	not    %eax
}
  812b7b:	c9                   	leaveq 
  812b7c:	c3                   	retq   

0000000000812b7d <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  812b7d:	55                   	push   %rbp
  812b7e:	48 89 e5             	mov    %rsp,%rbp
  812b81:	48 83 ec 30          	sub    $0x30,%rsp
  812b85:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  812b89:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  812b90:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  for(q = p; q != NULL; q = q->next) {
  812b94:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812b98:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  812b9c:	eb 7d                	jmp    812c1b <inet_chksum_pbuf+0x9e>
    acc += LWIP_CHKSUM(q->payload, q->len);
  812b9e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812ba2:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812ba6:	0f b7 d0             	movzwl %ax,%edx
  812ba9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812bad:	48 8b 40 08          	mov    0x8(%rax),%rax
  812bb1:	89 d6                	mov    %edx,%esi
  812bb3:	48 89 c7             	mov    %rax,%rdi
  812bb6:	48 b8 53 27 81 00 00 	movabs $0x812753,%rax
  812bbd:	00 00 00 
  812bc0:	ff d0                	callq  *%rax
  812bc2:	0f b7 c0             	movzwl %ax,%eax
  812bc5:	01 45 fc             	add    %eax,-0x4(%rbp)
    acc = FOLD_U32T(acc);
  812bc8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812bcb:	c1 e8 10             	shr    $0x10,%eax
  812bce:	89 c2                	mov    %eax,%edx
  812bd0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812bd3:	0f b7 c0             	movzwl %ax,%eax
  812bd6:	01 d0                	add    %edx,%eax
  812bd8:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  812bdb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812bdf:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812be3:	83 e0 01             	and    $0x1,%eax
  812be6:	66 85 c0             	test   %ax,%ax
  812be9:	74 25                	je     812c10 <inet_chksum_pbuf+0x93>
      swapped = 1 - swapped;
  812beb:	b8 01 00 00 00       	mov    $0x1,%eax
  812bf0:	2a 45 ef             	sub    -0x11(%rbp),%al
  812bf3:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  812bf6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812bf9:	c1 e0 08             	shl    $0x8,%eax
  812bfc:	0f b7 c0             	movzwl %ax,%eax
  812bff:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812c02:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  812c08:	c1 ea 08             	shr    $0x8,%edx
  812c0b:	09 d0                	or     %edx,%eax
  812c0d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  812c10:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812c14:	48 8b 00             	mov    (%rax),%rax
  812c17:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  812c1b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  812c20:	0f 85 78 ff ff ff    	jne    812b9e <inet_chksum_pbuf+0x21>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  812c26:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  812c2a:	74 1a                	je     812c46 <inet_chksum_pbuf+0xc9>
    acc = SWAP_BYTES_IN_WORD(acc);
  812c2c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812c2f:	c1 e0 08             	shl    $0x8,%eax
  812c32:	0f b7 c0             	movzwl %ax,%eax
  812c35:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812c38:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  812c3e:	c1 ea 08             	shr    $0x8,%edx
  812c41:	09 d0                	or     %edx,%eax
  812c43:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  return (u16_t)~(acc & 0xffffUL);
  812c46:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812c49:	f7 d0                	not    %eax
}
  812c4b:	c9                   	leaveq 
  812c4c:	c3                   	retq   

0000000000812c4d <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  812c4d:	55                   	push   %rbp
  812c4e:	48 89 e5             	mov    %rsp,%rbp
  812c51:	48 83 ec 20          	sub    $0x20,%rsp
  812c55:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  812c59:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  812c5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812c61:	48 89 d6             	mov    %rdx,%rsi
  812c64:	48 89 c7             	mov    %rax,%rdi
  812c67:	48 b8 83 2c 81 00 00 	movabs $0x812c83,%rax
  812c6e:	00 00 00 
  812c71:	ff d0                	callq  *%rax
  812c73:	85 c0                	test   %eax,%eax
  812c75:	74 05                	je     812c7c <inet_addr+0x2f>
    return (val.s_addr);
  812c77:	8b 45 f0             	mov    -0x10(%rbp),%eax
  812c7a:	eb 05                	jmp    812c81 <inet_addr+0x34>
  }
  return (INADDR_NONE);
  812c7c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  812c81:	c9                   	leaveq 
  812c82:	c3                   	retq   

0000000000812c83 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  812c83:	55                   	push   %rbp
  812c84:	48 89 e5             	mov    %rsp,%rbp
  812c87:	48 83 ec 40          	sub    $0x40,%rsp
  812c8b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  812c8f:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  812c93:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  812c97:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  c = *cp;
  812c9b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812c9f:	0f b6 00             	movzbl (%rax),%eax
  812ca2:	0f be c0             	movsbl %al,%eax
  812ca5:	89 45 f4             	mov    %eax,-0xc(%rbp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  812ca8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812cab:	0f b6 c0             	movzbl %al,%eax
  812cae:	83 f8 2f             	cmp    $0x2f,%eax
  812cb1:	7e 0b                	jle    812cbe <inet_aton+0x3b>
  812cb3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812cb6:	0f b6 c0             	movzbl %al,%eax
  812cb9:	83 f8 39             	cmp    $0x39,%eax
  812cbc:	7e 0a                	jle    812cc8 <inet_aton+0x45>
      return (0);
  812cbe:	b8 00 00 00 00       	mov    $0x0,%eax
  812cc3:	e9 a1 02 00 00       	jmpq   812f69 <inet_aton+0x2e6>
    val = 0;
  812cc8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    base = 10;
  812ccf:	c7 45 f8 0a 00 00 00 	movl   $0xa,-0x8(%rbp)
    if (c == '0') {
  812cd6:	83 7d f4 30          	cmpl   $0x30,-0xc(%rbp)
  812cda:	75 40                	jne    812d1c <inet_aton+0x99>
      c = *++cp;
  812cdc:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812ce1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812ce5:	0f b6 00             	movzbl (%rax),%eax
  812ce8:	0f be c0             	movsbl %al,%eax
  812ceb:	89 45 f4             	mov    %eax,-0xc(%rbp)
      if (c == 'x' || c == 'X') {
  812cee:	83 7d f4 78          	cmpl   $0x78,-0xc(%rbp)
  812cf2:	74 06                	je     812cfa <inet_aton+0x77>
  812cf4:	83 7d f4 58          	cmpl   $0x58,-0xc(%rbp)
  812cf8:	75 1b                	jne    812d15 <inet_aton+0x92>
        base = 16;
  812cfa:	c7 45 f8 10 00 00 00 	movl   $0x10,-0x8(%rbp)
        c = *++cp;
  812d01:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812d06:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812d0a:	0f b6 00             	movzbl (%rax),%eax
  812d0d:	0f be c0             	movsbl %al,%eax
  812d10:	89 45 f4             	mov    %eax,-0xc(%rbp)
  812d13:	eb 07                	jmp    812d1c <inet_aton+0x99>
      } else
        base = 8;
  812d15:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%rbp)
    }
    for (;;) {
      if (isdigit(c)) {
  812d1c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d1f:	0f b6 c0             	movzbl %al,%eax
  812d22:	83 f8 2f             	cmp    $0x2f,%eax
  812d25:	7e 36                	jle    812d5d <inet_aton+0xda>
  812d27:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d2a:	0f b6 c0             	movzbl %al,%eax
  812d2d:	83 f8 39             	cmp    $0x39,%eax
  812d30:	7f 2b                	jg     812d5d <inet_aton+0xda>
        val = (val * base) + (int)(c - '0');
  812d32:	8b 45 f8             	mov    -0x8(%rbp),%eax
  812d35:	0f af 45 fc          	imul   -0x4(%rbp),%eax
  812d39:	89 c2                	mov    %eax,%edx
  812d3b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d3e:	01 d0                	add    %edx,%eax
  812d40:	83 e8 30             	sub    $0x30,%eax
  812d43:	89 45 fc             	mov    %eax,-0x4(%rbp)
        c = *++cp;
  812d46:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812d4b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812d4f:	0f b6 00             	movzbl (%rax),%eax
  812d52:	0f be c0             	movsbl %al,%eax
  812d55:	89 45 f4             	mov    %eax,-0xc(%rbp)
  812d58:	e9 97 00 00 00       	jmpq   812df4 <inet_aton+0x171>
      } else if (base == 16 && isxdigit(c)) {
  812d5d:	83 7d f8 10          	cmpl   $0x10,-0x8(%rbp)
  812d61:	0f 85 92 00 00 00    	jne    812df9 <inet_aton+0x176>
  812d67:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d6a:	0f b6 c0             	movzbl %al,%eax
  812d6d:	83 f8 2f             	cmp    $0x2f,%eax
  812d70:	7e 0b                	jle    812d7d <inet_aton+0xfa>
  812d72:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d75:	0f b6 c0             	movzbl %al,%eax
  812d78:	83 f8 39             	cmp    $0x39,%eax
  812d7b:	7e 2c                	jle    812da9 <inet_aton+0x126>
  812d7d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d80:	0f b6 c0             	movzbl %al,%eax
  812d83:	83 f8 60             	cmp    $0x60,%eax
  812d86:	7e 0b                	jle    812d93 <inet_aton+0x110>
  812d88:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d8b:	0f b6 c0             	movzbl %al,%eax
  812d8e:	83 f8 66             	cmp    $0x66,%eax
  812d91:	7e 16                	jle    812da9 <inet_aton+0x126>
  812d93:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d96:	0f b6 c0             	movzbl %al,%eax
  812d99:	83 f8 40             	cmp    $0x40,%eax
  812d9c:	7e 5b                	jle    812df9 <inet_aton+0x176>
  812d9e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812da1:	0f b6 c0             	movzbl %al,%eax
  812da4:	83 f8 46             	cmp    $0x46,%eax
  812da7:	7f 50                	jg     812df9 <inet_aton+0x176>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  812da9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812dac:	c1 e0 04             	shl    $0x4,%eax
  812daf:	89 c2                	mov    %eax,%edx
  812db1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812db4:	8d 48 0a             	lea    0xa(%rax),%ecx
  812db7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812dba:	0f b6 c0             	movzbl %al,%eax
  812dbd:	83 f8 60             	cmp    $0x60,%eax
  812dc0:	7e 12                	jle    812dd4 <inet_aton+0x151>
  812dc2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812dc5:	0f b6 c0             	movzbl %al,%eax
  812dc8:	83 f8 7a             	cmp    $0x7a,%eax
  812dcb:	7f 07                	jg     812dd4 <inet_aton+0x151>
  812dcd:	b8 61 00 00 00       	mov    $0x61,%eax
  812dd2:	eb 05                	jmp    812dd9 <inet_aton+0x156>
  812dd4:	b8 41 00 00 00       	mov    $0x41,%eax
  812dd9:	29 c1                	sub    %eax,%ecx
  812ddb:	89 c8                	mov    %ecx,%eax
  812ddd:	09 d0                	or     %edx,%eax
  812ddf:	89 45 fc             	mov    %eax,-0x4(%rbp)
        c = *++cp;
  812de2:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812de7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812deb:	0f b6 00             	movzbl (%rax),%eax
  812dee:	0f be c0             	movsbl %al,%eax
  812df1:	89 45 f4             	mov    %eax,-0xc(%rbp)
      } else
        break;
    }
  812df4:	e9 23 ff ff ff       	jmpq   812d1c <inet_aton+0x99>
    if (c == '.') {
  812df9:	83 7d f4 2e          	cmpl   $0x2e,-0xc(%rbp)
  812dfd:	75 40                	jne    812e3f <inet_aton+0x1bc>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  812dff:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  812e03:	48 83 c0 0c          	add    $0xc,%rax
  812e07:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  812e0b:	77 0a                	ja     812e17 <inet_aton+0x194>
        return (0);
  812e0d:	b8 00 00 00 00       	mov    $0x0,%eax
  812e12:	e9 52 01 00 00       	jmpq   812f69 <inet_aton+0x2e6>
      *pp++ = val;
  812e17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812e1b:	48 8d 50 04          	lea    0x4(%rax),%rdx
  812e1f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  812e23:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812e26:	89 10                	mov    %edx,(%rax)
      c = *++cp;
  812e28:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812e2d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812e31:	0f b6 00             	movzbl (%rax),%eax
  812e34:	0f be c0             	movsbl %al,%eax
  812e37:	89 45 f4             	mov    %eax,-0xc(%rbp)
    } else
      break;
  }
  812e3a:	e9 69 fe ff ff       	jmpq   812ca8 <inet_aton+0x25>
      if (pp >= parts + 3)
        return (0);
      *pp++ = val;
      c = *++cp;
    } else
      break;
  812e3f:	90                   	nop
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  812e40:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  812e44:	74 44                	je     812e8a <inet_aton+0x207>
  812e46:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812e49:	0f b6 c0             	movzbl %al,%eax
  812e4c:	83 f8 1f             	cmp    $0x1f,%eax
  812e4f:	7e 2f                	jle    812e80 <inet_aton+0x1fd>
  812e51:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812e54:	0f b6 c0             	movzbl %al,%eax
  812e57:	83 f8 7f             	cmp    $0x7f,%eax
  812e5a:	7f 24                	jg     812e80 <inet_aton+0x1fd>
  812e5c:	83 7d f4 20          	cmpl   $0x20,-0xc(%rbp)
  812e60:	74 28                	je     812e8a <inet_aton+0x207>
  812e62:	83 7d f4 0c          	cmpl   $0xc,-0xc(%rbp)
  812e66:	74 22                	je     812e8a <inet_aton+0x207>
  812e68:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  812e6c:	74 1c                	je     812e8a <inet_aton+0x207>
  812e6e:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  812e72:	74 16                	je     812e8a <inet_aton+0x207>
  812e74:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  812e78:	74 10                	je     812e8a <inet_aton+0x207>
  812e7a:	83 7d f4 0b          	cmpl   $0xb,-0xc(%rbp)
  812e7e:	74 0a                	je     812e8a <inet_aton+0x207>
    return (0);
  812e80:	b8 00 00 00 00       	mov    $0x0,%eax
  812e85:	e9 df 00 00 00       	jmpq   812f69 <inet_aton+0x2e6>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  812e8a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  812e8e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  812e92:	48 29 c2             	sub    %rax,%rdx
  812e95:	48 89 d0             	mov    %rdx,%rax
  812e98:	48 c1 f8 02          	sar    $0x2,%rax
  812e9c:	83 c0 01             	add    $0x1,%eax
  812e9f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  switch (n) {
  812ea2:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  812ea6:	0f 87 98 00 00 00    	ja     812f44 <inet_aton+0x2c1>
  812eac:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  812eaf:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  812eb6:	00 
  812eb7:	48 b8 20 2a 82 00 00 	movabs $0x822a20,%rax
  812ebe:	00 00 00 
  812ec1:	48 01 d0             	add    %rdx,%rax
  812ec4:	48 8b 00             	mov    (%rax),%rax
  812ec7:	ff e0                	jmpq   *%rax

  case 0:
    return (0);       /* initial nondigit */
  812ec9:	b8 00 00 00 00       	mov    $0x0,%eax
  812ece:	e9 96 00 00 00       	jmpq   812f69 <inet_aton+0x2e6>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  812ed3:	81 7d fc ff ff ff 00 	cmpl   $0xffffff,-0x4(%rbp)
  812eda:	76 0a                	jbe    812ee6 <inet_aton+0x263>
      return (0);
  812edc:	b8 00 00 00 00       	mov    $0x0,%eax
  812ee1:	e9 83 00 00 00       	jmpq   812f69 <inet_aton+0x2e6>
    val |= parts[0] << 24;
  812ee6:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812ee9:	c1 e0 18             	shl    $0x18,%eax
  812eec:	09 45 fc             	or     %eax,-0x4(%rbp)
    break;
  812eef:	eb 53                	jmp    812f44 <inet_aton+0x2c1>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  812ef1:	81 7d fc ff ff 00 00 	cmpl   $0xffff,-0x4(%rbp)
  812ef8:	76 07                	jbe    812f01 <inet_aton+0x27e>
      return (0);
  812efa:	b8 00 00 00 00       	mov    $0x0,%eax
  812eff:	eb 68                	jmp    812f69 <inet_aton+0x2e6>
    val |= (parts[0] << 24) | (parts[1] << 16);
  812f01:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812f04:	c1 e0 18             	shl    $0x18,%eax
  812f07:	89 c2                	mov    %eax,%edx
  812f09:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  812f0c:	c1 e0 10             	shl    $0x10,%eax
  812f0f:	09 d0                	or     %edx,%eax
  812f11:	09 45 fc             	or     %eax,-0x4(%rbp)
    break;
  812f14:	eb 2e                	jmp    812f44 <inet_aton+0x2c1>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  812f16:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%rbp)
  812f1d:	76 07                	jbe    812f26 <inet_aton+0x2a3>
      return (0);
  812f1f:	b8 00 00 00 00       	mov    $0x0,%eax
  812f24:	eb 43                	jmp    812f69 <inet_aton+0x2e6>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  812f26:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812f29:	c1 e0 18             	shl    $0x18,%eax
  812f2c:	89 c2                	mov    %eax,%edx
  812f2e:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  812f31:	c1 e0 10             	shl    $0x10,%eax
  812f34:	09 c2                	or     %eax,%edx
  812f36:	8b 45 d8             	mov    -0x28(%rbp),%eax
  812f39:	c1 e0 08             	shl    $0x8,%eax
  812f3c:	09 d0                	or     %edx,%eax
  812f3e:	09 45 fc             	or     %eax,-0x4(%rbp)
    break;
  812f41:	eb 01                	jmp    812f44 <inet_aton+0x2c1>

  case 0:
    return (0);       /* initial nondigit */

  case 1:             /* a -- 32 bits */
    break;
  812f43:	90                   	nop
    if (val > 0xff)
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
  812f44:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  812f49:	74 19                	je     812f64 <inet_aton+0x2e1>
    addr->s_addr = htonl(val);
  812f4b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812f4e:	89 c7                	mov    %eax,%edi
  812f50:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  812f57:	00 00 00 
  812f5a:	ff d0                	callq  *%rax
  812f5c:	89 c2                	mov    %eax,%edx
  812f5e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  812f62:	89 10                	mov    %edx,(%rax)
  return (1);
  812f64:	b8 01 00 00 00       	mov    $0x1,%eax
}
  812f69:	c9                   	leaveq 
  812f6a:	c3                   	retq   

0000000000812f6b <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  812f6b:	55                   	push   %rbp
  812f6c:	48 89 e5             	mov    %rsp,%rbp
  812f6f:	48 83 ec 30          	sub    $0x30,%rsp
  812f73:	89 7d d0             	mov    %edi,-0x30(%rbp)
  static char str[16];
  u32_t s_addr = addr.s_addr;
  812f76:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812f79:	89 45 e8             	mov    %eax,-0x18(%rbp)
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  812f7c:	48 b8 60 b6 b4 00 00 	movabs $0xb4b660,%rax
  812f83:	00 00 00 
  812f86:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  ap = (u8_t *)&s_addr;
  812f8a:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  812f8e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  for(n = 0; n < 4; n++) {
  812f92:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  812f96:	e9 e0 00 00 00       	jmpq   81307b <inet_ntoa+0x110>
    i = 0;
  812f9b:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)
    do {
      rem = *ap % (u8_t)10;
  812f9f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812fa3:	0f b6 08             	movzbl (%rax),%ecx
  812fa6:	0f b6 d1             	movzbl %cl,%edx
  812fa9:	89 d0                	mov    %edx,%eax
  812fab:	c1 e0 02             	shl    $0x2,%eax
  812fae:	01 d0                	add    %edx,%eax
  812fb0:	c1 e0 03             	shl    $0x3,%eax
  812fb3:	01 d0                	add    %edx,%eax
  812fb5:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
  812fbc:	01 d0                	add    %edx,%eax
  812fbe:	66 c1 e8 08          	shr    $0x8,%ax
  812fc2:	c0 e8 03             	shr    $0x3,%al
  812fc5:	88 45 ed             	mov    %al,-0x13(%rbp)
  812fc8:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  812fcc:	89 d0                	mov    %edx,%eax
  812fce:	c1 e0 02             	shl    $0x2,%eax
  812fd1:	01 d0                	add    %edx,%eax
  812fd3:	01 c0                	add    %eax,%eax
  812fd5:	29 c1                	sub    %eax,%ecx
  812fd7:	89 c8                	mov    %ecx,%eax
  812fd9:	88 45 ed             	mov    %al,-0x13(%rbp)
      *ap /= (u8_t)10;
  812fdc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812fe0:	0f b6 00             	movzbl (%rax),%eax
  812fe3:	0f b6 d0             	movzbl %al,%edx
  812fe6:	89 d0                	mov    %edx,%eax
  812fe8:	c1 e0 02             	shl    $0x2,%eax
  812feb:	01 d0                	add    %edx,%eax
  812fed:	c1 e0 03             	shl    $0x3,%eax
  812ff0:	01 d0                	add    %edx,%eax
  812ff2:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
  812ff9:	01 d0                	add    %edx,%eax
  812ffb:	66 c1 e8 08          	shr    $0x8,%ax
  812fff:	89 c2                	mov    %eax,%edx
  813001:	c0 ea 03             	shr    $0x3,%dl
  813004:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813008:	88 10                	mov    %dl,(%rax)
      inv[i++] = '0' + rem;
  81300a:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  81300e:	8d 50 01             	lea    0x1(%rax),%edx
  813011:	88 55 ee             	mov    %dl,-0x12(%rbp)
  813014:	0f b6 c0             	movzbl %al,%eax
  813017:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  81301b:	83 c2 30             	add    $0x30,%edx
  81301e:	48 98                	cltq   
  813020:	88 54 05 e0          	mov    %dl,-0x20(%rbp,%rax,1)
    } while(*ap);
  813024:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813028:	0f b6 00             	movzbl (%rax),%eax
  81302b:	84 c0                	test   %al,%al
  81302d:	0f 85 6c ff ff ff    	jne    812f9f <inet_ntoa+0x34>
    while(i--)
  813033:	eb 1a                	jmp    81304f <inet_ntoa+0xe4>
      *rp++ = inv[i];
  813035:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813039:	48 8d 50 01          	lea    0x1(%rax),%rdx
  81303d:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
  813041:	0f b6 55 ee          	movzbl -0x12(%rbp),%edx
  813045:	48 63 d2             	movslq %edx,%rdx
  813048:	0f b6 54 15 e0       	movzbl -0x20(%rbp,%rdx,1),%edx
  81304d:	88 10                	mov    %dl,(%rax)
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  81304f:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  813053:	8d 50 ff             	lea    -0x1(%rax),%edx
  813056:	88 55 ee             	mov    %dl,-0x12(%rbp)
  813059:	84 c0                	test   %al,%al
  81305b:	75 d8                	jne    813035 <inet_ntoa+0xca>
      *rp++ = inv[i];
    *rp++ = '.';
  81305d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813061:	48 8d 50 01          	lea    0x1(%rax),%rdx
  813065:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
  813069:	c6 00 2e             	movb   $0x2e,(%rax)
    ap++;
  81306c:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  813071:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  813075:	83 c0 01             	add    $0x1,%eax
  813078:	88 45 ef             	mov    %al,-0x11(%rbp)
  81307b:	80 7d ef 03          	cmpb   $0x3,-0x11(%rbp)
  81307f:	0f 86 16 ff ff ff    	jbe    812f9b <inet_ntoa+0x30>
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
  813085:	48 83 6d f8 01       	subq   $0x1,-0x8(%rbp)
  81308a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81308e:	c6 00 00             	movb   $0x0,(%rax)
  return str;
  813091:	48 b8 60 b6 b4 00 00 	movabs $0xb4b660,%rax
  813098:	00 00 00 
}
  81309b:	c9                   	leaveq 
  81309c:	c3                   	retq   

000000000081309d <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  81309d:	55                   	push   %rbp
  81309e:	48 89 e5             	mov    %rsp,%rbp
  8130a1:	48 83 ec 08          	sub    $0x8,%rsp
  8130a5:	89 f8                	mov    %edi,%eax
  8130a7:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  8130ab:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  8130af:	c1 e0 08             	shl    $0x8,%eax
  8130b2:	89 c2                	mov    %eax,%edx
  8130b4:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  8130b8:	66 c1 e8 08          	shr    $0x8,%ax
  8130bc:	09 d0                	or     %edx,%eax
}
  8130be:	c9                   	leaveq 
  8130bf:	c3                   	retq   

00000000008130c0 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  8130c0:	55                   	push   %rbp
  8130c1:	48 89 e5             	mov    %rsp,%rbp
  8130c4:	48 83 ec 08          	sub    $0x8,%rsp
  8130c8:	89 f8                	mov    %edi,%eax
  8130ca:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  return htons(n);
  8130ce:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  8130d2:	89 c7                	mov    %eax,%edi
  8130d4:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  8130db:	00 00 00 
  8130de:	ff d0                	callq  *%rax
}
  8130e0:	c9                   	leaveq 
  8130e1:	c3                   	retq   

00000000008130e2 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  8130e2:	55                   	push   %rbp
  8130e3:	48 89 e5             	mov    %rsp,%rbp
  8130e6:	48 83 ec 08          	sub    $0x8,%rsp
  8130ea:	89 7d fc             	mov    %edi,-0x4(%rbp)
  return ((n & 0xff) << 24) |
  8130ed:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8130f0:	c1 e0 18             	shl    $0x18,%eax
  8130f3:	89 c2                	mov    %eax,%edx
    ((n & 0xff00) << 8) |
  8130f5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8130f8:	25 00 ff 00 00       	and    $0xff00,%eax
  8130fd:	c1 e0 08             	shl    $0x8,%eax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  813100:	09 c2                	or     %eax,%edx
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
  813102:	8b 45 fc             	mov    -0x4(%rbp),%eax
  813105:	25 00 00 ff 00       	and    $0xff0000,%eax
  81310a:	48 c1 e8 08          	shr    $0x8,%rax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  81310e:	09 c2                	or     %eax,%edx
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  813110:	8b 45 fc             	mov    -0x4(%rbp),%eax
  813113:	c1 e8 18             	shr    $0x18,%eax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  813116:	09 d0                	or     %edx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  813118:	c9                   	leaveq 
  813119:	c3                   	retq   

000000000081311a <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  81311a:	55                   	push   %rbp
  81311b:	48 89 e5             	mov    %rsp,%rbp
  81311e:	48 83 ec 08          	sub    $0x8,%rsp
  813122:	89 7d fc             	mov    %edi,-0x4(%rbp)
  return htonl(n);
  813125:	8b 45 fc             	mov    -0x4(%rbp),%eax
  813128:	89 c7                	mov    %eax,%edi
  81312a:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  813131:	00 00 00 
  813134:	ff d0                	callq  *%rax
}
  813136:	c9                   	leaveq 
  813137:	c3                   	retq   

0000000000813138 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  813138:	55                   	push   %rbp
  813139:	48 89 e5             	mov    %rsp,%rbp
  81313c:	48 83 ec 10          	sub    $0x10,%rsp
  813140:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  813144:	89 f0                	mov    %esi,%eax
  813146:	88 45 f4             	mov    %al,-0xc(%rbp)
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  813149:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  81314d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813151:	48 83 ec 08          	sub    $0x8,%rsp
  813155:	6a 00                	pushq  $0x0
  813157:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  81315d:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  813163:	89 d1                	mov    %edx,%ecx
  813165:	ba 00 00 00 00       	mov    $0x0,%edx
  81316a:	be 00 00 00 00       	mov    $0x0,%esi
  81316f:	48 89 c7             	mov    %rax,%rdi
  813172:	48 b8 1b 32 81 00 00 	movabs $0x81321b,%rax
  813179:	00 00 00 
  81317c:	ff d0                	callq  *%rax
  81317e:	48 83 c4 10          	add    $0x10,%rsp
}
  813182:	c9                   	leaveq 
  813183:	c3                   	retq   

0000000000813184 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  813184:	55                   	push   %rbp
  813185:	48 89 e5             	mov    %rsp,%rbp
  813188:	48 83 ec 20          	sub    $0x20,%rsp
  81318c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  813190:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  813194:	89 c8                	mov    %ecx,%eax
  813196:	66 89 55 ec          	mov    %dx,-0x14(%rbp)
  81319a:	88 45 e8             	mov    %al,-0x18(%rbp)
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  81319d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8131a1:	8b 40 18             	mov    0x18(%rax),%eax
  8131a4:	83 f8 04             	cmp    $0x4,%eax
  8131a7:	74 24                	je     8131cd <tcp_write+0x49>
     pcb->state == CLOSE_WAIT ||
  8131a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8131ad:	8b 40 18             	mov    0x18(%rax),%eax
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  8131b0:	83 f8 07             	cmp    $0x7,%eax
  8131b3:	74 18                	je     8131cd <tcp_write+0x49>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
  8131b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8131b9:	8b 40 18             	mov    0x18(%rax),%eax
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
  8131bc:	83 f8 02             	cmp    $0x2,%eax
  8131bf:	74 0c                	je     8131cd <tcp_write+0x49>
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
  8131c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8131c5:	8b 40 18             	mov    0x18(%rax),%eax
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
  8131c8:	83 f8 03             	cmp    $0x3,%eax
  8131cb:	75 47                	jne    813214 <tcp_write+0x90>
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  8131cd:	66 83 7d ec 00       	cmpw   $0x0,-0x14(%rbp)
  8131d2:	74 39                	je     81320d <tcp_write+0x89>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  8131d4:	0f b6 4d e8          	movzbl -0x18(%rbp),%ecx
  8131d8:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  8131dc:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8131e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8131e4:	48 83 ec 08          	sub    $0x8,%rsp
  8131e8:	6a 00                	pushq  $0x0
  8131ea:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8131f0:	41 89 c8             	mov    %ecx,%r8d
  8131f3:	b9 00 00 00 00       	mov    $0x0,%ecx
  8131f8:	48 89 c7             	mov    %rax,%rdi
  8131fb:	48 b8 1b 32 81 00 00 	movabs $0x81321b,%rax
  813202:	00 00 00 
  813205:	ff d0                	callq  *%rax
  813207:	48 83 c4 10          	add    $0x10,%rsp
  81320b:	eb 0c                	jmp    813219 <tcp_write+0x95>
    }
    return ERR_OK;
  81320d:	b8 00 00 00 00       	mov    $0x0,%eax
  813212:	eb 05                	jmp    813219 <tcp_write+0x95>
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  813214:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  }
}
  813219:	c9                   	leaveq 
  81321a:	c3                   	retq   

000000000081321b <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  81321b:	55                   	push   %rbp
  81321c:	48 89 e5             	mov    %rsp,%rbp
  81321f:	41 54                	push   %r12
  813221:	53                   	push   %rbx
  813222:	48 83 ec 70          	sub    $0x70,%rsp
  813226:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  81322a:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  81322e:	89 d6                	mov    %edx,%esi
  813230:	89 ca                	mov    %ecx,%edx
  813232:	44 89 c1             	mov    %r8d,%ecx
  813235:	4c 89 4d 88          	mov    %r9,-0x78(%rbp)
  813239:	8b 45 10             	mov    0x10(%rbp),%eax
  81323c:	66 89 75 9c          	mov    %si,-0x64(%rbp)
  813240:	88 55 98             	mov    %dl,-0x68(%rbp)
  813243:	88 4d 94             	mov    %cl,-0x6c(%rbp)
  813246:	88 45 90             	mov    %al,-0x70(%rbp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  813249:	66 83 7d 9c 00       	cmpw   $0x0,-0x64(%rbp)
  81324e:	74 30                	je     813280 <tcp_enqueue+0x65>
  813250:	80 7d 90 00          	cmpb   $0x0,-0x70(%rbp)
  813254:	74 2a                	je     813280 <tcp_enqueue+0x65>
  813256:	48 ba 48 2a 82 00 00 	movabs $0x822a48,%rdx
  81325d:	00 00 00 
  813260:	be 91 00 00 00       	mov    $0x91,%esi
  813265:	48 bf 87 2a 82 00 00 	movabs $0x822a87,%rdi
  81326c:	00 00 00 
  81326f:	b8 00 00 00 00       	mov    $0x0,%eax
  813274:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81327b:	00 00 00 
  81327e:	ff d1                	callq  *%rcx
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  813280:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  813285:	74 31                	je     8132b8 <tcp_enqueue+0x9d>
  813287:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  81328c:	74 2a                	je     8132b8 <tcp_enqueue+0x9d>
  81328e:	48 ba a0 2a 82 00 00 	movabs $0x822aa0,%rdx
  813295:	00 00 00 
  813298:	be 93 00 00 00       	mov    $0x93,%esi
  81329d:	48 bf 87 2a 82 00 00 	movabs $0x822a87,%rdi
  8132a4:	00 00 00 
  8132a7:	b8 00 00 00 00       	mov    $0x0,%eax
  8132ac:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8132b3:	00 00 00 
  8132b6:	ff d1                	callq  *%rcx
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  8132b8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8132bc:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  8132c0:	66 3b 45 9c          	cmp    -0x64(%rbp),%ax
  8132c4:	73 1e                	jae    8132e4 <tcp_enqueue+0xc9>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  8132c6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8132ca:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8132ce:	83 c8 80             	or     $0xffffff80,%eax
  8132d1:	89 c2                	mov    %eax,%edx
  8132d3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8132d7:	88 50 2c             	mov    %dl,0x2c(%rax)
    return ERR_MEM;
  8132da:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8132df:	e9 fc 09 00 00       	jmpq   813ce0 <tcp_enqueue+0xac5>
  }
  left = len;
  8132e4:	0f b7 45 9c          	movzwl -0x64(%rbp),%eax
  8132e8:	66 89 45 d2          	mov    %ax,-0x2e(%rbp)
  ptr = arg;
  8132ec:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8132f0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  8132f4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8132f8:	8b 40 74             	mov    0x74(%rax),%eax
  8132fb:	89 45 d4             	mov    %eax,-0x2c(%rbp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  8132fe:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813302:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  813306:	66 89 45 c6          	mov    %ax,-0x3a(%rbp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  81330a:	66 83 7d c6 1f       	cmpw   $0x1f,-0x3a(%rbp)
  81330f:	77 07                	ja     813318 <tcp_enqueue+0xfd>
  813311:	66 83 7d c6 fc       	cmpw   $0xfffc,-0x3a(%rbp)
  813316:	76 1e                	jbe    813336 <tcp_enqueue+0x11b>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  813318:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81331c:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813320:	83 c8 80             	or     $0xffffff80,%eax
  813323:	89 c2                	mov    %eax,%edx
  813325:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813329:	88 50 2c             	mov    %dl,0x2c(%rax)
    return ERR_MEM;
  81332c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  813331:	e9 aa 09 00 00       	jmpq   813ce0 <tcp_enqueue+0xac5>
  }
  if (queuelen != 0) {
  813336:	66 83 7d c6 00       	cmpw   $0x0,-0x3a(%rbp)
  81333b:	74 4e                	je     81338b <tcp_enqueue+0x170>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  81333d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813341:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813348:	48 85 c0             	test   %rax,%rax
  81334b:	0f 85 84 00 00 00    	jne    8133d5 <tcp_enqueue+0x1ba>
  813351:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813355:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81335c:	48 85 c0             	test   %rax,%rax
  81335f:	75 74                	jne    8133d5 <tcp_enqueue+0x1ba>
  813361:	48 ba e8 2a 82 00 00 	movabs $0x822ae8,%rdx
  813368:	00 00 00 
  81336b:	be af 00 00 00       	mov    $0xaf,%esi
  813370:	48 bf 87 2a 82 00 00 	movabs $0x822a87,%rdi
  813377:	00 00 00 
  81337a:	b8 00 00 00 00       	mov    $0x0,%eax
  81337f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  813386:	00 00 00 
  813389:	ff d1                	callq  *%rcx
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  81338b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81338f:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813396:	48 85 c0             	test   %rax,%rax
  813399:	75 10                	jne    8133ab <tcp_enqueue+0x190>
  81339b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81339f:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8133a6:	48 85 c0             	test   %rax,%rax
  8133a9:	74 2a                	je     8133d5 <tcp_enqueue+0x1ba>
  8133ab:	48 ba 28 2b 82 00 00 	movabs $0x822b28,%rdx
  8133b2:	00 00 00 
  8133b5:	be b2 00 00 00       	mov    $0xb2,%esi
  8133ba:	48 bf 87 2a 82 00 00 	movabs $0x822a87,%rdi
  8133c1:	00 00 00 
  8133c4:	b8 00 00 00 00       	mov    $0x0,%eax
  8133c9:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8133d0:	00 00 00 
  8133d3:	ff d1                	callq  *%rcx
      pcb->unacked == NULL && pcb->unsent == NULL);
  }

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  8133d5:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8133dc:	00 
  8133dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8133e1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8133e5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8133e9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  seglen = 0;
  8133ed:	66 c7 45 d0 00 00    	movw   $0x0,-0x30(%rbp)
  while (queue == NULL || left > 0) {
  8133f3:	e9 00 05 00 00       	jmpq   8138f8 <tcp_enqueue+0x6dd>

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  8133f8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8133fc:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  813400:	0f b7 45 d2          	movzwl -0x2e(%rbp),%eax
  813404:	66 39 c2             	cmp    %ax,%dx
  813407:	0f 46 c2             	cmovbe %edx,%eax
  81340a:	66 89 45 d0          	mov    %ax,-0x30(%rbp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  81340e:	bf 04 00 00 00       	mov    $0x4,%edi
  813413:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  81341a:	00 00 00 
  81341d:	ff d0                	callq  *%rax
  81341f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (seg == NULL) {
  813423:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813428:	0f 84 18 08 00 00    	je     813c46 <tcp_enqueue+0xa2b>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  81342e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813432:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    seg->p = NULL;
  813439:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81343d:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  813444:	00 

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  813445:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81344a:	75 0a                	jne    813456 <tcp_enqueue+0x23b>
      queue = seg;
  81344c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813450:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  813454:	eb 3c                	jmp    813492 <tcp_enqueue+0x277>
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  813456:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81345b:	75 2a                	jne    813487 <tcp_enqueue+0x26c>
  81345d:	48 ba 5c 2b 82 00 00 	movabs $0x822b5c,%rdx
  813464:	00 00 00 
  813467:	be cf 00 00 00       	mov    $0xcf,%esi
  81346c:	48 bf 87 2a 82 00 00 	movabs $0x822a87,%rdi
  813473:	00 00 00 
  813476:	b8 00 00 00 00       	mov    $0x0,%eax
  81347b:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  813482:	00 00 00 
  813485:	ff d1                	callq  *%rcx
      useg->next = seg;
  813487:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81348b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81348f:	48 89 10             	mov    %rdx,(%rax)
    }
    /* remember last segment of to-be-queued data for next iteration */
    useg = seg;
  813492:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813496:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  81349a:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  81349f:	0f 84 ae 00 00 00    	je     813553 <tcp_enqueue+0x338>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  8134a5:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  8134a9:	ba 00 00 00 00       	mov    $0x0,%edx
  8134ae:	89 c6                	mov    %eax,%esi
  8134b0:	bf 00 00 00 00       	mov    $0x0,%edi
  8134b5:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  8134bc:	00 00 00 
  8134bf:	ff d0                	callq  *%rax
  8134c1:	48 89 c2             	mov    %rax,%rdx
  8134c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134c8:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8134cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134d0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8134d4:	48 85 c0             	test   %rax,%rax
  8134d7:	0f 84 6c 07 00 00    	je     813c49 <tcp_enqueue+0xa2e>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  8134dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134e1:	48 8b 40 08          	mov    0x8(%rax),%rax
  8134e5:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  8134e9:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  8134ed:	66 39 c2             	cmp    %ax,%dx
  8134f0:	73 2a                	jae    81351c <tcp_enqueue+0x301>
  8134f2:	48 ba 70 2b 82 00 00 	movabs $0x822b70,%rdx
  8134f9:	00 00 00 
  8134fc:	be e0 00 00 00       	mov    $0xe0,%esi
  813501:	48 bf 87 2a 82 00 00 	movabs $0x822a87,%rdi
  813508:	00 00 00 
  81350b:	b8 00 00 00 00       	mov    $0x0,%eax
  813510:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  813517:	00 00 00 
  81351a:	ff d1                	callq  *%rcx
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  81351c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813520:	48 8b 40 08          	mov    0x8(%rax),%rax
  813524:	48 89 c7             	mov    %rax,%rdi
  813527:	48 b8 02 df 80 00 00 	movabs $0x80df02,%rax
  81352e:	00 00 00 
  813531:	ff d0                	callq  *%rax
  813533:	0f b6 c0             	movzbl %al,%eax
  813536:	66 01 45 c6          	add    %ax,-0x3a(%rbp)
      seg->dataptr = seg->p->payload;
  81353a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81353e:	48 8b 40 08          	mov    0x8(%rax),%rax
  813542:	48 8b 50 08          	mov    0x8(%rax),%rdx
  813546:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81354a:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81354e:	e9 be 01 00 00       	jmpq   813711 <tcp_enqueue+0x4f6>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  813553:	0f b6 45 94          	movzbl -0x6c(%rbp),%eax
  813557:	83 e0 01             	and    $0x1,%eax
  81355a:	85 c0                	test   %eax,%eax
  81355c:	0f 84 d8 00 00 00    	je     81363a <tcp_enqueue+0x41f>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  813562:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  813566:	ba 00 00 00 00       	mov    $0x0,%edx
  81356b:	89 c6                	mov    %eax,%esi
  81356d:	bf 00 00 00 00       	mov    $0x0,%edi
  813572:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  813579:	00 00 00 
  81357c:	ff d0                	callq  *%rax
  81357e:	48 89 c2             	mov    %rax,%rdx
  813581:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813585:	48 89 50 08          	mov    %rdx,0x8(%rax)
  813589:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81358d:	48 8b 40 08          	mov    0x8(%rax),%rax
  813591:	48 85 c0             	test   %rax,%rax
  813594:	0f 84 b2 06 00 00    	je     813c4c <tcp_enqueue+0xa31>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  81359a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81359e:	48 8b 40 08          	mov    0x8(%rax),%rax
  8135a2:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8135a6:	66 3b 45 d0          	cmp    -0x30(%rbp),%ax
  8135aa:	73 2a                	jae    8135d6 <tcp_enqueue+0x3bb>
  8135ac:	48 ba 98 2b 82 00 00 	movabs $0x822b98,%rdx
  8135b3:	00 00 00 
  8135b6:	be eb 00 00 00       	mov    $0xeb,%esi
  8135bb:	48 bf 87 2a 82 00 00 	movabs $0x822a87,%rdi
  8135c2:	00 00 00 
  8135c5:	b8 00 00 00 00       	mov    $0x0,%eax
  8135ca:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8135d1:	00 00 00 
  8135d4:	ff d1                	callq  *%rcx
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  8135d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8135da:	48 8b 40 08          	mov    0x8(%rax),%rax
  8135de:	48 89 c7             	mov    %rax,%rdi
  8135e1:	48 b8 02 df 80 00 00 	movabs $0x80df02,%rax
  8135e8:	00 00 00 
  8135eb:	ff d0                	callq  *%rax
  8135ed:	0f b6 c0             	movzbl %al,%eax
  8135f0:	66 01 45 c6          	add    %ax,-0x3a(%rbp)
      if (arg != NULL) {
  8135f4:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8135f9:	74 26                	je     813621 <tcp_enqueue+0x406>
        MEMCPY(seg->p->payload, ptr, seglen);
  8135fb:	0f b7 55 d0          	movzwl -0x30(%rbp),%edx
  8135ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813603:	48 8b 40 08          	mov    0x8(%rax),%rax
  813607:	48 8b 40 08          	mov    0x8(%rax),%rax
  81360b:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  81360f:	48 89 ce             	mov    %rcx,%rsi
  813612:	48 89 c7             	mov    %rax,%rdi
  813615:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  81361c:	00 00 00 
  81361f:	ff d0                	callq  *%rax
      }
      seg->dataptr = seg->p->payload;
  813621:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813625:	48 8b 40 08          	mov    0x8(%rax),%rax
  813629:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81362d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813631:	48 89 50 10          	mov    %rdx,0x10(%rax)
  813635:	e9 d7 00 00 00       	jmpq   813711 <tcp_enqueue+0x4f6>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  81363a:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  81363e:	ba 01 00 00 00       	mov    $0x1,%edx
  813643:	89 c6                	mov    %eax,%esi
  813645:	bf 00 00 00 00       	mov    $0x0,%edi
  81364a:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  813651:	00 00 00 
  813654:	ff d0                	callq  *%rax
  813656:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  81365a:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  81365f:	0f 84 ea 05 00 00    	je     813c4f <tcp_enqueue+0xa34>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
  813665:	66 83 45 c6 01       	addw   $0x1,-0x3a(%rbp)
      /* reference the non-volatile payload data */
      p->payload = ptr;
  81366a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81366e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813672:	48 89 50 08          	mov    %rdx,0x8(%rax)
      seg->dataptr = ptr;
  813676:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81367a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81367e:	48 89 50 10          	mov    %rdx,0x10(%rax)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  813682:	ba 00 00 00 00       	mov    $0x0,%edx
  813687:	be 00 00 00 00       	mov    $0x0,%esi
  81368c:	bf 00 00 00 00       	mov    $0x0,%edi
  813691:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  813698:	00 00 00 
  81369b:	ff d0                	callq  *%rax
  81369d:	48 89 c2             	mov    %rax,%rdx
  8136a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8136a4:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8136a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8136ac:	48 8b 40 08          	mov    0x8(%rax),%rax
  8136b0:	48 85 c0             	test   %rax,%rax
  8136b3:	75 18                	jne    8136cd <tcp_enqueue+0x4b2>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  8136b5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8136b9:	48 89 c7             	mov    %rax,%rdi
  8136bc:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  8136c3:	00 00 00 
  8136c6:	ff d0                	callq  *%rax
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  8136c8:	e9 89 05 00 00       	jmpq   813c56 <tcp_enqueue+0xa3b>
      }
      queuelen += pbuf_clen(seg->p);
  8136cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8136d1:	48 8b 40 08          	mov    0x8(%rax),%rax
  8136d5:	48 89 c7             	mov    %rax,%rdi
  8136d8:	48 b8 02 df 80 00 00 	movabs $0x80df02,%rax
  8136df:	00 00 00 
  8136e2:	ff d0                	callq  *%rax
  8136e4:	0f b6 c0             	movzbl %al,%eax
  8136e7:	66 01 45 c6          	add    %ax,-0x3a(%rbp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  8136eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8136ef:	48 8b 40 08          	mov    0x8(%rax),%rax
  8136f3:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8136f7:	48 89 d6             	mov    %rdx,%rsi
  8136fa:	48 89 c7             	mov    %rax,%rdi
  8136fd:	48 b8 59 df 80 00 00 	movabs $0x80df59,%rax
  813704:	00 00 00 
  813707:	ff d0                	callq  *%rax
      p = NULL;
  813709:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  813710:	00 
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  813711:	66 83 7d c6 20       	cmpw   $0x20,-0x3a(%rbp)
  813716:	0f 87 36 05 00 00    	ja     813c52 <tcp_enqueue+0xa37>
  81371c:	66 83 7d c6 fc       	cmpw   $0xfffc,-0x3a(%rbp)
  813721:	0f 87 2b 05 00 00    	ja     813c52 <tcp_enqueue+0xa37>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  813727:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81372b:	0f b7 55 d0          	movzwl -0x30(%rbp),%edx
  81372f:	66 89 50 18          	mov    %dx,0x18(%rax)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  813733:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813737:	48 8b 40 08          	mov    0x8(%rax),%rax
  81373b:	be 14 00 00 00       	mov    $0x14,%esi
  813740:	48 89 c7             	mov    %rax,%rdi
  813743:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  81374a:	00 00 00 
  81374d:	ff d0                	callq  *%rax
  81374f:	84 c0                	test   %al,%al
  813751:	0f 85 fe 04 00 00    	jne    813c55 <tcp_enqueue+0xa3a>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  813757:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81375b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81375f:	48 8b 50 08          	mov    0x8(%rax),%rdx
  813763:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813767:	48 89 50 20          	mov    %rdx,0x20(%rax)
    seg->tcphdr->src = htons(pcb->local_port);
  81376b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81376f:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813773:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813777:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  81377b:	0f b7 c0             	movzwl %ax,%eax
  81377e:	89 c7                	mov    %eax,%edi
  813780:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  813787:	00 00 00 
  81378a:	ff d0                	callq  *%rax
  81378c:	66 89 03             	mov    %ax,(%rbx)
    seg->tcphdr->dest = htons(pcb->remote_port);
  81378f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813793:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813797:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81379b:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  81379f:	0f b7 c0             	movzwl %ax,%eax
  8137a2:	89 c7                	mov    %eax,%edi
  8137a4:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  8137ab:	00 00 00 
  8137ae:	ff d0                	callq  *%rax
  8137b0:	66 89 43 02          	mov    %ax,0x2(%rbx)
    seg->tcphdr->seqno = htonl(seqno);
  8137b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8137b8:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8137bc:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8137bf:	89 c7                	mov    %eax,%edi
  8137c1:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  8137c8:	00 00 00 
  8137cb:	ff d0                	callq  *%rax
  8137cd:	89 43 04             	mov    %eax,0x4(%rbx)
    seg->tcphdr->urgp = 0;
  8137d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8137d4:	48 8b 40 20          	mov    0x20(%rax),%rax
  8137d8:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  8137de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8137e2:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8137e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8137ea:	48 8b 40 20          	mov    0x20(%rax),%rax
  8137ee:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8137f2:	0f b7 c0             	movzwl %ax,%eax
  8137f5:	89 c7                	mov    %eax,%edi
  8137f7:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  8137fe:	00 00 00 
  813801:	ff d0                	callq  *%rax
  813803:	83 e0 c0             	and    $0xffffffc0,%eax
  813806:	89 c2                	mov    %eax,%edx
  813808:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  81380c:	09 d0                	or     %edx,%eax
  81380e:	0f b7 c0             	movzwl %ax,%eax
  813811:	89 c7                	mov    %eax,%edi
  813813:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  81381a:	00 00 00 
  81381d:	ff d0                	callq  *%rax
  81381f:	66 89 43 0c          	mov    %ax,0xc(%rbx)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  813823:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  813828:	75 42                	jne    81386c <tcp_enqueue+0x651>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  81382a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81382e:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813832:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813836:	48 8b 40 20          	mov    0x20(%rax),%rax
  81383a:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81383e:	0f b7 c0             	movzwl %ax,%eax
  813841:	89 c7                	mov    %eax,%edi
  813843:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81384a:	00 00 00 
  81384d:	ff d0                	callq  *%rax
  81384f:	83 e0 3f             	and    $0x3f,%eax
  813852:	80 cc 50             	or     $0x50,%ah
  813855:	0f b7 c0             	movzwl %ax,%eax
  813858:	89 c7                	mov    %eax,%edi
  81385a:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  813861:	00 00 00 
  813864:	ff d0                	callq  *%rax
  813866:	66 89 43 0c          	mov    %ax,0xc(%rbx)
  81386a:	eb 75                	jmp    8138e1 <tcp_enqueue+0x6c6>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  81386c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813870:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813874:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  813878:	c0 e8 02             	shr    $0x2,%al
  81387b:	0f b6 c0             	movzbl %al,%eax
  81387e:	83 c0 05             	add    $0x5,%eax
  813881:	c1 e0 0c             	shl    $0xc,%eax
  813884:	41 89 c4             	mov    %eax,%r12d
  813887:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81388b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81388f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813893:	0f b7 c0             	movzwl %ax,%eax
  813896:	89 c7                	mov    %eax,%edi
  813898:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81389f:	00 00 00 
  8138a2:	ff d0                	callq  *%rax
  8138a4:	83 e0 3f             	and    $0x3f,%eax
  8138a7:	44 09 e0             	or     %r12d,%eax
  8138aa:	0f b7 c0             	movzwl %ax,%eax
  8138ad:	89 c7                	mov    %eax,%edi
  8138af:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  8138b6:	00 00 00 
  8138b9:	ff d0                	callq  *%rax
  8138bb:	66 89 43 0c          	mov    %ax,0xc(%rbx)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  8138bf:	0f b6 55 90          	movzbl -0x70(%rbp),%edx
  8138c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8138c7:	48 8b 40 10          	mov    0x10(%rax),%rax
  8138cb:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
  8138cf:	48 89 ce             	mov    %rcx,%rsi
  8138d2:	48 89 c7             	mov    %rax,%rdi
  8138d5:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  8138dc:	00 00 00 
  8138df:	ff d0                	callq  *%rax
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  8138e1:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8138e5:	66 29 45 d2          	sub    %ax,-0x2e(%rbp)
    seqno += seglen;
  8138e9:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8138ed:	01 45 d4             	add    %eax,-0x2c(%rbp)
    ptr = (void *)((u8_t *)ptr + seglen);
  8138f0:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8138f4:	48 01 45 c8          	add    %rax,-0x38(%rbp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  8138f8:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8138fd:	0f 84 f5 fa ff ff    	je     8133f8 <tcp_enqueue+0x1dd>
  813903:	66 83 7d d2 00       	cmpw   $0x0,-0x2e(%rbp)
  813908:	0f 85 ea fa ff ff    	jne    8133f8 <tcp_enqueue+0x1dd>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  81390e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813912:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813919:	48 85 c0             	test   %rax,%rax
  81391c:	75 0a                	jne    813928 <tcp_enqueue+0x70d>
    useg = NULL;
  81391e:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  813925:	00 
  813926:	eb 28                	jmp    813950 <tcp_enqueue+0x735>
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  813928:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81392c:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813933:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  813937:	eb 0b                	jmp    813944 <tcp_enqueue+0x729>
  813939:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81393d:	48 8b 00             	mov    (%rax),%rax
  813940:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  813944:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813948:	48 8b 00             	mov    (%rax),%rax
  81394b:	48 85 c0             	test   %rax,%rax
  81394e:	75 e9                	jne    813939 <tcp_enqueue+0x71e>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  813950:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  813955:	0f 84 94 01 00 00    	je     813aef <tcp_enqueue+0x8d4>
    TCP_TCPLEN(useg) != 0 &&
  81395b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81395f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813963:	0f b7 d8             	movzwl %ax,%ebx
  813966:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81396a:	48 8b 40 20          	mov    0x20(%rax),%rax
  81396e:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813972:	0f b7 c0             	movzwl %ax,%eax
  813975:	89 c7                	mov    %eax,%edi
  813977:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81397e:	00 00 00 
  813981:	ff d0                	callq  *%rax
  813983:	0f b7 c0             	movzwl %ax,%eax
  813986:	83 e0 01             	and    $0x1,%eax
  813989:	85 c0                	test   %eax,%eax
  81398b:	75 27                	jne    8139b4 <tcp_enqueue+0x799>
  81398d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813991:	48 8b 40 20          	mov    0x20(%rax),%rax
  813995:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813999:	0f b7 c0             	movzwl %ax,%eax
  81399c:	89 c7                	mov    %eax,%edi
  81399e:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  8139a5:	00 00 00 
  8139a8:	ff d0                	callq  *%rax
  8139aa:	0f b7 c0             	movzwl %ax,%eax
  8139ad:	83 e0 02             	and    $0x2,%eax
  8139b0:	85 c0                	test   %eax,%eax
  8139b2:	74 07                	je     8139bb <tcp_enqueue+0x7a0>
  8139b4:	b8 01 00 00 00       	mov    $0x1,%eax
  8139b9:	eb 05                	jmp    8139c0 <tcp_enqueue+0x7a5>
  8139bb:	b8 00 00 00 00       	mov    $0x0,%eax
  8139c0:	01 d8                	add    %ebx,%eax
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  8139c2:	85 c0                	test   %eax,%eax
  8139c4:	0f 84 25 01 00 00    	je     813aef <tcp_enqueue+0x8d4>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  8139ca:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8139ce:	48 8b 40 20          	mov    0x20(%rax),%rax
  8139d2:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8139d6:	0f b7 c0             	movzwl %ax,%eax
  8139d9:	89 c7                	mov    %eax,%edi
  8139db:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  8139e2:	00 00 00 
  8139e5:	ff d0                	callq  *%rax
  8139e7:	0f b7 c0             	movzwl %ax,%eax
  8139ea:	83 e0 03             	and    $0x3,%eax
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  8139ed:	85 c0                	test   %eax,%eax
  8139ef:	0f 85 fa 00 00 00    	jne    813aef <tcp_enqueue+0x8d4>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  8139f5:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  8139f9:	83 e0 03             	and    $0x3,%eax

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  8139fc:	85 c0                	test   %eax,%eax
  8139fe:	0f 85 eb 00 00 00    	jne    813aef <tcp_enqueue+0x8d4>
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  813a04:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813a08:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813a0c:	0f b7 d0             	movzwl %ax,%edx
  813a0f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813a13:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813a17:	0f b7 c0             	movzwl %ax,%eax
  813a1a:	01 c2                	add    %eax,%edx
  813a1c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813a20:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  813a24:	0f b7 c0             	movzwl %ax,%eax
  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  813a27:	39 c2                	cmp    %eax,%edx
  813a29:	0f 8f c0 00 00 00    	jg     813aef <tcp_enqueue+0x8d4>
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  813a2f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813a33:	48 8b 40 08          	mov    0x8(%rax),%rax
  813a37:	be ec ff ff ff       	mov    $0xffffffec,%esi
  813a3c:	48 89 c7             	mov    %rax,%rdi
  813a3f:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  813a46:	00 00 00 
  813a49:	ff d0                	callq  *%rax
  813a4b:	84 c0                	test   %al,%al
  813a4d:	74 2a                	je     813a79 <tcp_enqueue+0x85e>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  813a4f:	48 ba cb 2b 82 00 00 	movabs $0x822bcb,%rdx
  813a56:	00 00 00 
  813a59:	be 53 01 00 00       	mov    $0x153,%esi
  813a5e:	48 bf 87 2a 82 00 00 	movabs $0x822a87,%rdi
  813a65:	00 00 00 
  813a68:	b8 00 00 00 00       	mov    $0x0,%eax
  813a6d:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  813a74:	00 00 00 
  813a77:	ff d1                	callq  *%rcx
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  813a79:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813a7d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  813a81:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813a85:	48 8b 40 08          	mov    0x8(%rax),%rax
  813a89:	48 89 d6             	mov    %rdx,%rsi
  813a8c:	48 89 c7             	mov    %rax,%rdi
  813a8f:	48 b8 59 df 80 00 00 	movabs $0x80df59,%rax
  813a96:	00 00 00 
  813a99:	ff d0                	callq  *%rax
    useg->len += queue->len;
  813a9b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813a9f:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  813aa3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813aa7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813aab:	01 c2                	add    %eax,%edx
  813aad:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813ab1:	66 89 50 18          	mov    %dx,0x18(%rax)
    useg->next = queue->next;
  813ab5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813ab9:	48 8b 10             	mov    (%rax),%rdx
  813abc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813ac0:	48 89 10             	mov    %rdx,(%rax)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  813ac3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813ac7:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  813acb:	75 08                	jne    813ad5 <tcp_enqueue+0x8ba>
      seg = NULL;
  813acd:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  813ad4:	00 
    }
    memp_free(MEMP_TCP_SEG, queue);
  813ad5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813ad9:	48 89 c6             	mov    %rax,%rsi
  813adc:	bf 04 00 00 00       	mov    $0x4,%edi
  813ae1:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  813ae8:	00 00 00 
  813aeb:	ff d0                	callq  *%rax
  813aed:	eb 23                	jmp    813b12 <tcp_enqueue+0x8f7>
  }
  else {
    /* empty list */
    if (useg == NULL) {
  813aef:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  813af4:	75 11                	jne    813b07 <tcp_enqueue+0x8ec>
      /* initialize list with this segment */
      pcb->unsent = queue;
  813af6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813afa:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  813afe:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  813b05:	eb 0b                	jmp    813b12 <tcp_enqueue+0x8f7>
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  813b07:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813b0b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  813b0f:	48 89 10             	mov    %rdx,(%rax)
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  813b12:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  813b16:	83 e0 02             	and    $0x2,%eax
  813b19:	85 c0                	test   %eax,%eax
  813b1b:	75 0b                	jne    813b28 <tcp_enqueue+0x90d>
  813b1d:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  813b21:	83 e0 01             	and    $0x1,%eax
  813b24:	85 c0                	test   %eax,%eax
  813b26:	74 05                	je     813b2d <tcp_enqueue+0x912>
    ++len;
  813b28:	66 83 45 9c 01       	addw   $0x1,-0x64(%rbp)
  }
  if (flags & TCP_FIN) {
  813b2d:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  813b31:	83 e0 01             	and    $0x1,%eax
  813b34:	85 c0                	test   %eax,%eax
  813b36:	74 14                	je     813b4c <tcp_enqueue+0x931>
    pcb->flags |= TF_FIN;
  813b38:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813b3c:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813b40:	83 c8 20             	or     $0x20,%eax
  813b43:	89 c2                	mov    %eax,%edx
  813b45:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813b49:	88 50 2c             	mov    %dl,0x2c(%rax)
  }
  pcb->snd_lbb += len;
  813b4c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813b50:	8b 50 74             	mov    0x74(%rax),%edx
  813b53:	0f b7 45 9c          	movzwl -0x64(%rbp),%eax
  813b57:	01 c2                	add    %eax,%edx
  813b59:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813b5d:	89 50 74             	mov    %edx,0x74(%rax)

  pcb->snd_buf -= len;
  813b60:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813b64:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  813b68:	66 2b 45 9c          	sub    -0x64(%rbp),%ax
  813b6c:	89 c2                	mov    %eax,%edx
  813b6e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813b72:	66 89 50 7a          	mov    %dx,0x7a(%rax)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  813b76:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813b7a:	0f b7 55 c6          	movzwl -0x3a(%rbp),%edx
  813b7e:	66 89 50 7c          	mov    %dx,0x7c(%rax)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  813b82:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813b86:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  813b8a:	66 85 c0             	test   %ax,%ax
  813b8d:	74 4a                	je     813bd9 <tcp_enqueue+0x9be>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  813b8f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813b93:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813b9a:	48 85 c0             	test   %rax,%rax
  813b9d:	75 3a                	jne    813bd9 <tcp_enqueue+0x9be>
  813b9f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813ba3:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813baa:	48 85 c0             	test   %rax,%rax
  813bad:	75 2a                	jne    813bd9 <tcp_enqueue+0x9be>
  813baf:	48 ba e0 2b 82 00 00 	movabs $0x822be0,%rdx
  813bb6:	00 00 00 
  813bb9:	be 7b 01 00 00       	mov    $0x17b,%esi
  813bbe:	48 bf 87 2a 82 00 00 	movabs $0x822a87,%rdi
  813bc5:	00 00 00 
  813bc8:	b8 00 00 00 00       	mov    $0x0,%eax
  813bcd:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  813bd4:	00 00 00 
  813bd7:	ff d1                	callq  *%rcx
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  813bd9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813bde:	74 5c                	je     813c3c <tcp_enqueue+0xa21>
  813be0:	66 83 7d d0 00       	cmpw   $0x0,-0x30(%rbp)
  813be5:	74 55                	je     813c3c <tcp_enqueue+0xa21>
  813be7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813beb:	48 8b 40 20          	mov    0x20(%rax),%rax
  813bef:	48 85 c0             	test   %rax,%rax
  813bf2:	74 48                	je     813c3c <tcp_enqueue+0xa21>
  813bf4:	0f b6 45 94          	movzbl -0x6c(%rbp),%eax
  813bf8:	83 e0 02             	and    $0x2,%eax
  813bfb:	85 c0                	test   %eax,%eax
  813bfd:	75 3d                	jne    813c3c <tcp_enqueue+0xa21>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  813bff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c03:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813c07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c0b:	48 8b 40 20          	mov    0x20(%rax),%rax
  813c0f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813c13:	0f b7 c0             	movzwl %ax,%eax
  813c16:	89 c7                	mov    %eax,%edi
  813c18:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  813c1f:	00 00 00 
  813c22:	ff d0                	callq  *%rax
  813c24:	83 c8 08             	or     $0x8,%eax
  813c27:	0f b7 c0             	movzwl %ax,%eax
  813c2a:	89 c7                	mov    %eax,%edi
  813c2c:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  813c33:	00 00 00 
  813c36:	ff d0                	callq  *%rax
  813c38:	66 89 43 0c          	mov    %ax,0xc(%rbx)
  }

  return ERR_OK;
  813c3c:	b8 00 00 00 00       	mov    $0x0,%eax
  813c41:	e9 9a 00 00 00       	jmpq   813ce0 <tcp_enqueue+0xac5>

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
    if (seg == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
  813c46:	90                   	nop
  813c47:	eb 0d                	jmp    813c56 <tcp_enqueue+0xa3b>
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
        goto memerr;
  813c49:	90                   	nop
  813c4a:	eb 0a                	jmp    813c56 <tcp_enqueue+0xa3b>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
  813c4c:	90                   	nop
  813c4d:	eb 07                	jmp    813c56 <tcp_enqueue+0xa3b>
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
  813c4f:	90                   	nop
  813c50:	eb 04                	jmp    813c56 <tcp_enqueue+0xa3b>

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
  813c52:	90                   	nop
  813c53:	eb 01                	jmp    813c56 <tcp_enqueue+0xa3b>

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
  813c55:	90                   	nop
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  813c56:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813c5a:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813c5e:	83 c8 80             	or     $0xffffff80,%eax
  813c61:	89 c2                	mov    %eax,%edx
  813c63:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813c67:	88 50 2c             	mov    %dl,0x2c(%rax)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  813c6a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  813c6f:	74 13                	je     813c84 <tcp_enqueue+0xa69>
    tcp_segs_free(queue);
  813c71:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813c75:	48 89 c7             	mov    %rax,%rdi
  813c78:	48 b8 58 04 81 00 00 	movabs $0x810458,%rax
  813c7f:	00 00 00 
  813c82:	ff d0                	callq  *%rax
  }
  if (pcb->snd_queuelen != 0) {
  813c84:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813c88:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  813c8c:	66 85 c0             	test   %ax,%ax
  813c8f:	74 4a                	je     813cdb <tcp_enqueue+0xac0>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  813c91:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813c95:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813c9c:	48 85 c0             	test   %rax,%rax
  813c9f:	75 3a                	jne    813cdb <tcp_enqueue+0xac0>
  813ca1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813ca5:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813cac:	48 85 c0             	test   %rax,%rax
  813caf:	75 2a                	jne    813cdb <tcp_enqueue+0xac0>
  813cb1:	48 ba e0 2b 82 00 00 	movabs $0x822be0,%rdx
  813cb8:	00 00 00 
  813cbb:	be 8e 01 00 00       	mov    $0x18e,%esi
  813cc0:	48 bf 87 2a 82 00 00 	movabs $0x822a87,%rdi
  813cc7:	00 00 00 
  813cca:	b8 00 00 00 00       	mov    $0x0,%eax
  813ccf:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  813cd6:	00 00 00 
  813cd9:	ff d1                	callq  *%rcx
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  813cdb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  813ce0:	48 83 c4 70          	add    $0x70,%rsp
  813ce4:	5b                   	pop    %rbx
  813ce5:	41 5c                	pop    %r12
  813ce7:	5d                   	pop    %rbp
  813ce8:	c3                   	retq   

0000000000813ce9 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  813ce9:	55                   	push   %rbp
  813cea:	48 89 e5             	mov    %rsp,%rbp
  813ced:	41 54                	push   %r12
  813cef:	53                   	push   %rbx
  813cf0:	48 83 ec 40          	sub    $0x40,%rsp
  813cf4:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  813cf8:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  813cff:	00 00 00 
  813d02:	48 8b 00             	mov    (%rax),%rax
  813d05:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  813d09:	75 0a                	jne    813d15 <tcp_output+0x2c>
    return ERR_OK;
  813d0b:	b8 00 00 00 00       	mov    $0x0,%eax
  813d10:	e9 cd 06 00 00       	jmpq   8143e2 <tcp_output+0x6f9>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  813d15:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d19:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  813d1d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d21:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  813d25:	66 39 c2             	cmp    %ax,%dx
  813d28:	0f 46 c2             	cmovbe %edx,%eax
  813d2b:	0f b7 c0             	movzwl %ax,%eax
  813d2e:	89 45 dc             	mov    %eax,-0x24(%rbp)

  seg = pcb->unsent;
  813d31:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d35:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813d3c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  813d40:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d44:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813d4b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  if (useg != NULL) {
  813d4f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  813d54:	74 19                	je     813d6f <tcp_output+0x86>
    for (; useg->next != NULL; useg = useg->next);
  813d56:	eb 0b                	jmp    813d63 <tcp_output+0x7a>
  813d58:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813d5c:	48 8b 00             	mov    (%rax),%rax
  813d5f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  813d63:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813d67:	48 8b 00             	mov    (%rax),%rax
  813d6a:	48 85 c0             	test   %rax,%rax
  813d6d:	75 e9                	jne    813d58 <tcp_output+0x6f>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  813d6f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d73:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813d77:	0f b6 c0             	movzbl %al,%eax
  813d7a:	83 e0 02             	and    $0x2,%eax
  813d7d:	85 c0                	test   %eax,%eax
  813d7f:	0f 84 91 05 00 00    	je     814316 <tcp_output+0x62d>
  813d85:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813d8a:	74 3a                	je     813dc6 <tcp_output+0xdd>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  813d8c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d90:	48 8b 40 20          	mov    0x20(%rax),%rax
  813d94:	8b 40 04             	mov    0x4(%rax),%eax
  813d97:	89 c7                	mov    %eax,%edi
  813d99:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  813da0:	00 00 00 
  813da3:	ff d0                	callq  *%rax
  813da5:	89 c2                	mov    %eax,%edx
  813da7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813dab:	8b 40 54             	mov    0x54(%rax),%eax
  813dae:	29 c2                	sub    %eax,%edx
  813db0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813db4:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813db8:	0f b7 c0             	movzwl %ax,%eax
  813dbb:	01 d0                	add    %edx,%eax
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
  813dbd:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  813dc0:	0f 86 50 05 00 00    	jbe    814316 <tcp_output+0x62d>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  813dc6:	ba 00 00 00 00       	mov    $0x0,%edx
  813dcb:	be 14 00 00 00       	mov    $0x14,%esi
  813dd0:	bf 01 00 00 00       	mov    $0x1,%edi
  813dd5:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  813ddc:	00 00 00 
  813ddf:	ff d0                	callq  *%rax
  813de1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (p == NULL) {
  813de5:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  813dea:	75 0a                	jne    813df6 <tcp_output+0x10d>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  813dec:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  813df1:	e9 ec 05 00 00       	jmpq   8143e2 <tcp_output+0x6f9>
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  813df6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813dfa:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813dfe:	83 e0 fc             	and    $0xfffffffc,%eax
  813e01:	89 c2                	mov    %eax,%edx
  813e03:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e07:	88 50 2c             	mov    %dl,0x2c(%rax)

    tcphdr = p->payload;
  813e0a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813e0e:	48 8b 40 08          	mov    0x8(%rax),%rax
  813e12:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    tcphdr->src = htons(pcb->local_port);
  813e16:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e1a:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  813e1e:	0f b7 c0             	movzwl %ax,%eax
  813e21:	89 c7                	mov    %eax,%edi
  813e23:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  813e2a:	00 00 00 
  813e2d:	ff d0                	callq  *%rax
  813e2f:	89 c2                	mov    %eax,%edx
  813e31:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813e35:	66 89 10             	mov    %dx,(%rax)
    tcphdr->dest = htons(pcb->remote_port);
  813e38:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e3c:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  813e40:	0f b7 c0             	movzwl %ax,%eax
  813e43:	89 c7                	mov    %eax,%edi
  813e45:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  813e4c:	00 00 00 
  813e4f:	ff d0                	callq  *%rax
  813e51:	89 c2                	mov    %eax,%edx
  813e53:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813e57:	66 89 50 02          	mov    %dx,0x2(%rax)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  813e5b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e5f:	8b 40 60             	mov    0x60(%rax),%eax
  813e62:	89 c7                	mov    %eax,%edi
  813e64:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  813e6b:	00 00 00 
  813e6e:	ff d0                	callq  *%rax
  813e70:	89 c2                	mov    %eax,%edx
  813e72:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813e76:	89 50 04             	mov    %edx,0x4(%rax)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  813e79:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e7d:	8b 40 30             	mov    0x30(%rax),%eax
  813e80:	89 c7                	mov    %eax,%edi
  813e82:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  813e89:	00 00 00 
  813e8c:	ff d0                	callq  *%rax
  813e8e:	89 c2                	mov    %eax,%edx
  813e90:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813e94:	89 50 08             	mov    %edx,0x8(%rax)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  813e97:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813e9b:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813e9f:	0f b7 c0             	movzwl %ax,%eax
  813ea2:	89 c7                	mov    %eax,%edi
  813ea4:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  813eab:	00 00 00 
  813eae:	ff d0                	callq  *%rax
  813eb0:	83 e0 c0             	and    $0xffffffc0,%eax
  813eb3:	83 c8 10             	or     $0x10,%eax
  813eb6:	0f b7 c0             	movzwl %ax,%eax
  813eb9:	89 c7                	mov    %eax,%edi
  813ebb:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  813ec2:	00 00 00 
  813ec5:	ff d0                	callq  *%rax
  813ec7:	89 c2                	mov    %eax,%edx
  813ec9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813ecd:	66 89 50 0c          	mov    %dx,0xc(%rax)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  813ed1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ed5:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  813ed9:	0f b7 c0             	movzwl %ax,%eax
  813edc:	89 c7                	mov    %eax,%edi
  813ede:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  813ee5:	00 00 00 
  813ee8:	ff d0                	callq  *%rax
  813eea:	89 c2                	mov    %eax,%edx
  813eec:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813ef0:	66 89 50 0e          	mov    %dx,0xe(%rax)
    tcphdr->urgp = 0;
  813ef4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813ef8:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
    TCPH_HDRLEN_SET(tcphdr, 5);
  813efe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813f02:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813f06:	0f b7 c0             	movzwl %ax,%eax
  813f09:	89 c7                	mov    %eax,%edi
  813f0b:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  813f12:	00 00 00 
  813f15:	ff d0                	callq  *%rax
  813f17:	83 e0 3f             	and    $0x3f,%eax
  813f1a:	80 cc 50             	or     $0x50,%ah
  813f1d:	0f b7 c0             	movzwl %ax,%eax
  813f20:	89 c7                	mov    %eax,%edi
  813f22:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  813f29:	00 00 00 
  813f2c:	ff d0                	callq  *%rax
  813f2e:	89 c2                	mov    %eax,%edx
  813f30:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813f34:	66 89 50 0c          	mov    %dx,0xc(%rax)

    tcphdr->chksum = 0;
  813f38:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813f3c:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
          IP_PROTO_TCP, p->tot_len);
  813f42:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813f46:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    tcphdr->urgp = 0;
    TCPH_HDRLEN_SET(tcphdr, 5);

    tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  813f4a:	0f b7 c8             	movzwl %ax,%ecx
  813f4d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813f51:	48 8d 50 04          	lea    0x4(%rax),%rdx
  813f55:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  813f59:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813f5d:	41 89 c8             	mov    %ecx,%r8d
  813f60:	b9 06 00 00 00       	mov    $0x6,%ecx
  813f65:	48 89 c7             	mov    %rax,%rdi
  813f68:	48 b8 18 28 81 00 00 	movabs $0x812818,%rax
  813f6f:	00 00 00 
  813f72:	ff d0                	callq  *%rax
  813f74:	89 c2                	mov    %eax,%edx
  813f76:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813f7a:	66 89 50 10          	mov    %dx,0x10(%rax)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  813f7e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813f82:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  813f86:	0f b6 c8             	movzbl %al,%ecx
  813f89:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813f8d:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  813f91:	0f b6 d0             	movzbl %al,%edx
  813f94:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813f98:	48 8d 78 04          	lea    0x4(%rax),%rdi
  813f9c:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  813fa0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813fa4:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  813faa:	41 89 c8             	mov    %ecx,%r8d
  813fad:	89 d1                	mov    %edx,%ecx
  813faf:	48 89 fa             	mov    %rdi,%rdx
  813fb2:	48 89 c7             	mov    %rax,%rdi
  813fb5:	48 b8 05 16 81 00 00 	movabs $0x811605,%rax
  813fbc:	00 00 00 
  813fbf:	ff d0                	callq  *%rax
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  813fc1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813fc5:	48 89 c7             	mov    %rax,%rdi
  813fc8:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  813fcf:	00 00 00 
  813fd2:	ff d0                	callq  *%rax

    return ERR_OK;
  813fd4:	b8 00 00 00 00       	mov    $0x0,%eax
  813fd9:	e9 04 04 00 00       	jmpq   8143e2 <tcp_output+0x6f9>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  813fde:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813fe2:	48 8b 40 20          	mov    0x20(%rax),%rax
  813fe6:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813fea:	0f b7 c0             	movzwl %ax,%eax
  813fed:	89 c7                	mov    %eax,%edi
  813fef:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  813ff6:	00 00 00 
  813ff9:	ff d0                	callq  *%rax
  813ffb:	0f b7 c0             	movzwl %ax,%eax
  813ffe:	83 e0 04             	and    $0x4,%eax
  814001:	85 c0                	test   %eax,%eax
  814003:	74 2a                	je     81402f <tcp_output+0x346>
  814005:	48 ba 00 2c 82 00 00 	movabs $0x822c00,%rdx
  81400c:	00 00 00 
  81400f:	be 06 02 00 00       	mov    $0x206,%esi
  814014:	48 bf 87 2a 82 00 00 	movabs $0x822a87,%rdi
  81401b:	00 00 00 
  81401e:	b8 00 00 00 00       	mov    $0x0,%eax
  814023:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81402a:	00 00 00 
  81402d:	ff d1                	callq  *%rcx
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  81402f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814033:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81403a:	48 85 c0             	test   %rax,%rax
  81403d:	74 35                	je     814074 <tcp_output+0x38b>
  81403f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814043:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  814047:	0f b6 c0             	movzbl %al,%eax
  81404a:	83 e0 40             	and    $0x40,%eax
  81404d:	85 c0                	test   %eax,%eax
  81404f:	75 23                	jne    814074 <tcp_output+0x38b>
  814051:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814055:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81405c:	48 85 c0             	test   %rax,%rax
  81405f:	74 1a                	je     81407b <tcp_output+0x392>
  814061:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814065:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81406c:	48 8b 00             	mov    (%rax),%rax
  81406f:	48 85 c0             	test   %rax,%rax
  814072:	74 07                	je     81407b <tcp_output+0x392>
  814074:	b8 01 00 00 00       	mov    $0x1,%eax
  814079:	eb 05                	jmp    814080 <tcp_output+0x397>
  81407b:	b8 00 00 00 00       	mov    $0x0,%eax
  814080:	85 c0                	test   %eax,%eax
  814082:	75 18                	jne    81409c <tcp_output+0x3b3>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
  814084:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814088:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81408c:	0f b6 c0             	movzbl %al,%eax
  81408f:	25 a0 00 00 00       	and    $0xa0,%eax
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  814094:	85 c0                	test   %eax,%eax
  814096:	0f 84 bd 02 00 00    	je     814359 <tcp_output+0x670>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  81409c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8140a0:	48 8b 10             	mov    (%rax),%rdx
  8140a3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8140a7:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)

    if (pcb->state != SYN_SENT) {
  8140ae:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8140b2:	8b 40 18             	mov    0x18(%rax),%eax
  8140b5:	83 f8 02             	cmp    $0x2,%eax
  8140b8:	74 51                	je     81410b <tcp_output+0x422>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  8140ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8140be:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8140c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8140c6:	48 8b 40 20          	mov    0x20(%rax),%rax
  8140ca:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8140ce:	0f b7 c0             	movzwl %ax,%eax
  8140d1:	89 c7                	mov    %eax,%edi
  8140d3:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  8140da:	00 00 00 
  8140dd:	ff d0                	callq  *%rax
  8140df:	83 c8 10             	or     $0x10,%eax
  8140e2:	0f b7 c0             	movzwl %ax,%eax
  8140e5:	89 c7                	mov    %eax,%edi
  8140e7:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  8140ee:	00 00 00 
  8140f1:	ff d0                	callq  *%rax
  8140f3:	66 89 43 0c          	mov    %ax,0xc(%rbx)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8140f7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8140fb:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8140ff:	83 e0 fc             	and    $0xfffffffc,%eax
  814102:	89 c2                	mov    %eax,%edx
  814104:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814108:	88 50 2c             	mov    %dl,0x2c(%rax)
    }

    tcp_output_segment(seg, pcb);
  81410b:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  81410f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814113:	48 89 d6             	mov    %rdx,%rsi
  814116:	48 89 c7             	mov    %rax,%rdi
  814119:	48 b8 eb 43 81 00 00 	movabs $0x8143eb,%rax
  814120:	00 00 00 
  814123:	ff d0                	callq  *%rax
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  814125:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814129:	48 8b 40 20          	mov    0x20(%rax),%rax
  81412d:	8b 40 04             	mov    0x4(%rax),%eax
  814130:	89 c7                	mov    %eax,%edi
  814132:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  814139:	00 00 00 
  81413c:	ff d0                	callq  *%rax
  81413e:	41 89 c4             	mov    %eax,%r12d
  814141:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814145:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  814149:	0f b7 d8             	movzwl %ax,%ebx
  81414c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814150:	48 8b 40 20          	mov    0x20(%rax),%rax
  814154:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814158:	0f b7 c0             	movzwl %ax,%eax
  81415b:	89 c7                	mov    %eax,%edi
  81415d:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  814164:	00 00 00 
  814167:	ff d0                	callq  *%rax
  814169:	0f b7 c0             	movzwl %ax,%eax
  81416c:	83 e0 01             	and    $0x1,%eax
  81416f:	85 c0                	test   %eax,%eax
  814171:	75 27                	jne    81419a <tcp_output+0x4b1>
  814173:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814177:	48 8b 40 20          	mov    0x20(%rax),%rax
  81417b:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81417f:	0f b7 c0             	movzwl %ax,%eax
  814182:	89 c7                	mov    %eax,%edi
  814184:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81418b:	00 00 00 
  81418e:	ff d0                	callq  *%rax
  814190:	0f b7 c0             	movzwl %ax,%eax
  814193:	83 e0 02             	and    $0x2,%eax
  814196:	85 c0                	test   %eax,%eax
  814198:	74 07                	je     8141a1 <tcp_output+0x4b8>
  81419a:	b8 01 00 00 00       	mov    $0x1,%eax
  81419f:	eb 05                	jmp    8141a6 <tcp_output+0x4bd>
  8141a1:	b8 00 00 00 00       	mov    $0x0,%eax
  8141a6:	01 d8                	add    %ebx,%eax
  8141a8:	41 8d 14 04          	lea    (%r12,%rax,1),%edx
  8141ac:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8141b0:	89 50 60             	mov    %edx,0x60(%rax)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  8141b3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8141b7:	8b 50 64             	mov    0x64(%rax),%edx
  8141ba:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8141be:	8b 40 60             	mov    0x60(%rax),%eax
  8141c1:	29 c2                	sub    %eax,%edx
  8141c3:	89 d0                	mov    %edx,%eax
  8141c5:	85 c0                	test   %eax,%eax
  8141c7:	79 0e                	jns    8141d7 <tcp_output+0x4ee>
      pcb->snd_max = pcb->snd_nxt;
  8141c9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8141cd:	8b 50 60             	mov    0x60(%rax),%edx
  8141d0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8141d4:	89 50 64             	mov    %edx,0x64(%rax)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  8141d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8141db:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8141df:	0f b7 d8             	movzwl %ax,%ebx
  8141e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8141e6:	48 8b 40 20          	mov    0x20(%rax),%rax
  8141ea:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8141ee:	0f b7 c0             	movzwl %ax,%eax
  8141f1:	89 c7                	mov    %eax,%edi
  8141f3:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  8141fa:	00 00 00 
  8141fd:	ff d0                	callq  *%rax
  8141ff:	0f b7 c0             	movzwl %ax,%eax
  814202:	83 e0 01             	and    $0x1,%eax
  814205:	85 c0                	test   %eax,%eax
  814207:	75 27                	jne    814230 <tcp_output+0x547>
  814209:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81420d:	48 8b 40 20          	mov    0x20(%rax),%rax
  814211:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814215:	0f b7 c0             	movzwl %ax,%eax
  814218:	89 c7                	mov    %eax,%edi
  81421a:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  814221:	00 00 00 
  814224:	ff d0                	callq  *%rax
  814226:	0f b7 c0             	movzwl %ax,%eax
  814229:	83 e0 02             	and    $0x2,%eax
  81422c:	85 c0                	test   %eax,%eax
  81422e:	74 07                	je     814237 <tcp_output+0x54e>
  814230:	b8 01 00 00 00       	mov    $0x1,%eax
  814235:	eb 05                	jmp    81423c <tcp_output+0x553>
  814237:	b8 00 00 00 00       	mov    $0x0,%eax
  81423c:	01 d8                	add    %ebx,%eax
  81423e:	85 c0                	test   %eax,%eax
  814240:	0f 8e ae 00 00 00    	jle    8142f4 <tcp_output+0x60b>
      seg->next = NULL;
  814246:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81424a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  814251:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814255:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81425c:	48 85 c0             	test   %rax,%rax
  81425f:	75 1c                	jne    81427d <tcp_output+0x594>
        pcb->unacked = seg;
  814261:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814265:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814269:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
        useg = seg;
  814270:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814274:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  814278:	e9 8a 00 00 00       	jmpq   814307 <tcp_output+0x61e>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  81427d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814281:	48 8b 40 20          	mov    0x20(%rax),%rax
  814285:	8b 40 04             	mov    0x4(%rax),%eax
  814288:	89 c7                	mov    %eax,%edi
  81428a:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  814291:	00 00 00 
  814294:	ff d0                	callq  *%rax
  814296:	89 c3                	mov    %eax,%ebx
  814298:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81429c:	48 8b 40 20          	mov    0x20(%rax),%rax
  8142a0:	8b 40 04             	mov    0x4(%rax),%eax
  8142a3:	89 c7                	mov    %eax,%edi
  8142a5:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  8142ac:	00 00 00 
  8142af:	ff d0                	callq  *%rax
  8142b1:	29 c3                	sub    %eax,%ebx
  8142b3:	89 d8                	mov    %ebx,%eax
  8142b5:	85 c0                	test   %eax,%eax
  8142b7:	79 23                	jns    8142dc <tcp_output+0x5f3>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  8142b9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8142bd:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  8142c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8142c8:	48 89 10             	mov    %rdx,(%rax)
          pcb->unacked = seg;
  8142cb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8142cf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8142d3:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
  8142da:	eb 2b                	jmp    814307 <tcp_output+0x61e>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  8142dc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8142e0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8142e4:	48 89 10             	mov    %rdx,(%rax)
          useg = useg->next;
  8142e7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8142eb:	48 8b 00             	mov    (%rax),%rax
  8142ee:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8142f2:	eb 13                	jmp    814307 <tcp_output+0x61e>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  8142f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8142f8:	48 89 c7             	mov    %rax,%rdi
  8142fb:	48 b8 a0 04 81 00 00 	movabs $0x8104a0,%rax
  814302:	00 00 00 
  814305:	ff d0                	callq  *%rax
    }
    seg = pcb->unsent;
  814307:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81430b:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  814312:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  814316:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81431b:	74 3d                	je     81435a <tcp_output+0x671>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  81431d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814321:	48 8b 40 20          	mov    0x20(%rax),%rax
  814325:	8b 40 04             	mov    0x4(%rax),%eax
  814328:	89 c7                	mov    %eax,%edi
  81432a:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  814331:	00 00 00 
  814334:	ff d0                	callq  *%rax
  814336:	89 c2                	mov    %eax,%edx
  814338:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81433c:	8b 40 54             	mov    0x54(%rax),%eax
  81433f:	29 c2                	sub    %eax,%edx
  814341:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814345:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  814349:	0f b7 c0             	movzwl %ax,%eax
  81434c:	01 d0                	add    %edx,%eax
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  81434e:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  814351:	0f 86 87 fc ff ff    	jbe    813fde <tcp_output+0x2f5>
  814357:	eb 01                	jmp    81435a <tcp_output+0x671>
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
      break;
  814359:	90                   	nop
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  81435a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81435f:	74 68                	je     8143c9 <tcp_output+0x6e0>
  814361:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814365:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  81436c:	84 c0                	test   %al,%al
  81436e:	75 59                	jne    8143c9 <tcp_output+0x6e0>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  814370:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814374:	48 8b 40 20          	mov    0x20(%rax),%rax
  814378:	8b 40 04             	mov    0x4(%rax),%eax
  81437b:	89 c7                	mov    %eax,%edi
  81437d:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  814384:	00 00 00 
  814387:	ff d0                	callq  *%rax
  814389:	89 c2                	mov    %eax,%edx
  81438b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81438f:	8b 40 54             	mov    0x54(%rax),%eax
  814392:	29 c2                	sub    %eax,%edx
  814394:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814398:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81439c:	0f b7 c0             	movzwl %ax,%eax
  81439f:	01 c2                	add    %eax,%edx
  8143a1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8143a5:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  8143a9:	0f b7 c0             	movzwl %ax,%eax
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  8143ac:	39 c2                	cmp    %eax,%edx
  8143ae:	76 19                	jbe    8143c9 <tcp_output+0x6e0>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  8143b0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8143b4:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8143bb:	00 00 00 
    pcb->persist_backoff = 1;
  8143be:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8143c2:	c6 80 d8 00 00 00 01 	movb   $0x1,0xd8(%rax)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  8143c9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8143cd:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8143d1:	83 e0 7f             	and    $0x7f,%eax
  8143d4:	89 c2                	mov    %eax,%edx
  8143d6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8143da:	88 50 2c             	mov    %dl,0x2c(%rax)
  return ERR_OK;
  8143dd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8143e2:	48 83 c4 40          	add    $0x40,%rsp
  8143e6:	5b                   	pop    %rbx
  8143e7:	41 5c                	pop    %r12
  8143e9:	5d                   	pop    %rbp
  8143ea:	c3                   	retq   

00000000008143eb <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
  8143eb:	55                   	push   %rbp
  8143ec:	48 89 e5             	mov    %rsp,%rbp
  8143ef:	53                   	push   %rbx
  8143f0:	48 83 ec 28          	sub    $0x28,%rsp
  8143f4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8143f8:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  8143fc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814400:	48 8b 58 20          	mov    0x20(%rax),%rbx
  814404:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814408:	8b 40 30             	mov    0x30(%rax),%eax
  81440b:	89 c7                	mov    %eax,%edi
  81440d:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  814414:	00 00 00 
  814417:	ff d0                	callq  *%rax
  814419:	89 43 08             	mov    %eax,0x8(%rbx)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  81441c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814420:	48 8b 58 20          	mov    0x20(%rax),%rbx
  814424:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814428:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  81442c:	0f b7 c0             	movzwl %ax,%eax
  81442f:	89 c7                	mov    %eax,%edi
  814431:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  814438:	00 00 00 
  81443b:	ff d0                	callq  *%rax
  81443d:	66 89 43 0e          	mov    %ax,0xe(%rbx)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  814441:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814445:	48 85 c0             	test   %rax,%rax
  814448:	74 0a                	je     814454 <tcp_output_segment+0x69>
  81444a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81444e:	8b 00                	mov    (%rax),%eax
  814450:	85 c0                	test   %eax,%eax
  814452:	75 47                	jne    81449b <tcp_output_segment+0xb0>
    netif = ip_route(&(pcb->remote_ip));
  814454:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814458:	48 83 c0 04          	add    $0x4,%rax
  81445c:	48 89 c7             	mov    %rax,%rdi
  81445f:	48 b8 0d 0e 81 00 00 	movabs $0x810e0d,%rax
  814466:	00 00 00 
  814469:	ff d0                	callq  *%rax
  81446b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (netif == NULL) {
  81446f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814474:	0f 84 83 01 00 00    	je     8145fd <tcp_output_segment+0x212>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  81447a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81447e:	48 83 c0 08          	add    $0x8,%rax
  814482:	48 85 c0             	test   %rax,%rax
  814485:	74 09                	je     814490 <tcp_output_segment+0xa5>
  814487:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81448b:	8b 40 08             	mov    0x8(%rax),%eax
  81448e:	eb 05                	jmp    814495 <tcp_output_segment+0xaa>
  814490:	b8 00 00 00 00       	mov    $0x0,%eax
  814495:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  814499:	89 02                	mov    %eax,(%rdx)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  81449b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81449f:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8144a3:	66 83 f8 ff          	cmp    $0xffff,%ax
  8144a7:	75 0a                	jne    8144b3 <tcp_output_segment+0xc8>
    pcb->rtime = 0;
  8144a9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8144ad:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

  if (pcb->rttest == 0) {
  8144b3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8144b7:	8b 40 44             	mov    0x44(%rax),%eax
  8144ba:	85 c0                	test   %eax,%eax
  8144bc:	75 35                	jne    8144f3 <tcp_output_segment+0x108>
    pcb->rttest = tcp_ticks;
  8144be:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  8144c5:	00 00 00 
  8144c8:	8b 10                	mov    (%rax),%edx
  8144ca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8144ce:	89 50 44             	mov    %edx,0x44(%rax)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  8144d1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8144d5:	48 8b 40 20          	mov    0x20(%rax),%rax
  8144d9:	8b 40 04             	mov    0x4(%rax),%eax
  8144dc:	89 c7                	mov    %eax,%edi
  8144de:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  8144e5:	00 00 00 
  8144e8:	ff d0                	callq  *%rax
  8144ea:	89 c2                	mov    %eax,%edx
  8144ec:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8144f0:	89 50 48             	mov    %edx,0x48(%rax)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  8144f3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8144f7:	48 8b 40 20          	mov    0x20(%rax),%rax
  8144fb:	48 89 c2             	mov    %rax,%rdx
  8144fe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814502:	48 8b 40 08          	mov    0x8(%rax),%rax
  814506:	48 8b 40 08          	mov    0x8(%rax),%rax
  81450a:	48 29 c2             	sub    %rax,%rdx
  81450d:	48 89 d0             	mov    %rdx,%rax
  814510:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)

  seg->p->len -= len;
  814514:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814518:	48 8b 40 08          	mov    0x8(%rax),%rax
  81451c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  814520:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  814524:	0f b7 52 12          	movzwl 0x12(%rdx),%edx
  814528:	66 2b 55 e6          	sub    -0x1a(%rbp),%dx
  81452c:	66 89 50 12          	mov    %dx,0x12(%rax)
  seg->p->tot_len -= len;
  814530:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814534:	48 8b 40 08          	mov    0x8(%rax),%rax
  814538:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81453c:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  814540:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  814544:	66 2b 55 e6          	sub    -0x1a(%rbp),%dx
  814548:	66 89 50 10          	mov    %dx,0x10(%rax)

  seg->p->payload = seg->tcphdr;
  81454c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814550:	48 8b 40 08          	mov    0x8(%rax),%rax
  814554:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  814558:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  81455c:	48 89 50 08          	mov    %rdx,0x8(%rax)

  seg->tcphdr->chksum = 0;
  814560:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814564:	48 8b 40 20          	mov    0x20(%rax),%rax
  814568:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  81456e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814572:	48 8b 58 20          	mov    0x20(%rax),%rbx
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  814576:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81457a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81457e:	0f b7 40 10          	movzwl 0x10(%rax),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  814582:	0f b7 c8             	movzwl %ax,%ecx
  814585:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814589:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81458d:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  814591:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814595:	48 8b 40 08          	mov    0x8(%rax),%rax
  814599:	41 89 c8             	mov    %ecx,%r8d
  81459c:	b9 06 00 00 00       	mov    $0x6,%ecx
  8145a1:	48 89 c7             	mov    %rax,%rdi
  8145a4:	48 b8 18 28 81 00 00 	movabs $0x812818,%rax
  8145ab:	00 00 00 
  8145ae:	ff d0                	callq  *%rax
  8145b0:	66 89 43 10          	mov    %ax,0x10(%rbx)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  8145b4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8145b8:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  8145bc:	0f b6 c8             	movzbl %al,%ecx
  8145bf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8145c3:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8145c7:	0f b6 d0             	movzbl %al,%edx
  8145ca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8145ce:	48 8d 78 04          	lea    0x4(%rax),%rdi
  8145d2:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8145d6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8145da:	48 8b 40 08          	mov    0x8(%rax),%rax
  8145de:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  8145e4:	41 89 c8             	mov    %ecx,%r8d
  8145e7:	89 d1                	mov    %edx,%ecx
  8145e9:	48 89 fa             	mov    %rdi,%rdx
  8145ec:	48 89 c7             	mov    %rax,%rdi
  8145ef:	48 b8 05 16 81 00 00 	movabs $0x811605,%rax
  8145f6:	00 00 00 
  8145f9:	ff d0                	callq  *%rax
  8145fb:	eb 01                	jmp    8145fe <tcp_output_segment+0x213>
  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
    netif = ip_route(&(pcb->remote_ip));
    if (netif == NULL) {
      return;
  8145fd:	90                   	nop
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
}
  8145fe:	48 83 c4 28          	add    $0x28,%rsp
  814602:	5b                   	pop    %rbx
  814603:	5d                   	pop    %rbp
  814604:	c3                   	retq   

0000000000814605 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  814605:	55                   	push   %rbp
  814606:	48 89 e5             	mov    %rsp,%rbp
  814609:	48 83 ec 30          	sub    $0x30,%rsp
  81460d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  814610:	89 75 e8             	mov    %esi,-0x18(%rbp)
  814613:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  814617:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
  81461b:	44 89 c2             	mov    %r8d,%edx
  81461e:	44 89 c8             	mov    %r9d,%eax
  814621:	66 89 55 d4          	mov    %dx,-0x2c(%rbp)
  814625:	66 89 45 d0          	mov    %ax,-0x30(%rbp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  814629:	ba 00 00 00 00       	mov    $0x0,%edx
  81462e:	be 14 00 00 00       	mov    $0x14,%esi
  814633:	bf 01 00 00 00       	mov    $0x1,%edi
  814638:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  81463f:	00 00 00 
  814642:	ff d0                	callq  *%rax
  814644:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (p == NULL) {
  814648:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81464d:	0f 84 cb 01 00 00    	je     81481e <tcp_rst+0x219>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  814653:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814657:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81465b:	66 83 f8 13          	cmp    $0x13,%ax
  81465f:	77 2a                	ja     81468b <tcp_rst+0x86>
  814661:	48 ba 18 2c 82 00 00 	movabs $0x822c18,%rdx
  814668:	00 00 00 
  81466b:	be bf 02 00 00       	mov    $0x2bf,%esi
  814670:	48 bf 87 2a 82 00 00 	movabs $0x822a87,%rdi
  814677:	00 00 00 
  81467a:	b8 00 00 00 00       	mov    $0x0,%eax
  81467f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  814686:	00 00 00 
  814689:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  81468b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81468f:	48 8b 40 08          	mov    0x8(%rax),%rax
  814693:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  tcphdr->src = htons(local_port);
  814697:	0f b7 45 d4          	movzwl -0x2c(%rbp),%eax
  81469b:	89 c7                	mov    %eax,%edi
  81469d:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  8146a4:	00 00 00 
  8146a7:	ff d0                	callq  *%rax
  8146a9:	89 c2                	mov    %eax,%edx
  8146ab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8146af:	66 89 10             	mov    %dx,(%rax)
  tcphdr->dest = htons(remote_port);
  8146b2:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8146b6:	89 c7                	mov    %eax,%edi
  8146b8:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  8146bf:	00 00 00 
  8146c2:	ff d0                	callq  *%rax
  8146c4:	89 c2                	mov    %eax,%edx
  8146c6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8146ca:	66 89 50 02          	mov    %dx,0x2(%rax)
  tcphdr->seqno = htonl(seqno);
  8146ce:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8146d1:	89 c7                	mov    %eax,%edi
  8146d3:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  8146da:	00 00 00 
  8146dd:	ff d0                	callq  *%rax
  8146df:	89 c2                	mov    %eax,%edx
  8146e1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8146e5:	89 50 04             	mov    %edx,0x4(%rax)
  tcphdr->ackno = htonl(ackno);
  8146e8:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8146eb:	89 c7                	mov    %eax,%edi
  8146ed:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  8146f4:	00 00 00 
  8146f7:	ff d0                	callq  *%rax
  8146f9:	89 c2                	mov    %eax,%edx
  8146fb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8146ff:	89 50 08             	mov    %edx,0x8(%rax)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  814702:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814706:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81470a:	0f b7 c0             	movzwl %ax,%eax
  81470d:	89 c7                	mov    %eax,%edi
  81470f:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  814716:	00 00 00 
  814719:	ff d0                	callq  *%rax
  81471b:	83 e0 c0             	and    $0xffffffc0,%eax
  81471e:	83 c8 14             	or     $0x14,%eax
  814721:	0f b7 c0             	movzwl %ax,%eax
  814724:	89 c7                	mov    %eax,%edi
  814726:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  81472d:	00 00 00 
  814730:	ff d0                	callq  *%rax
  814732:	89 c2                	mov    %eax,%edx
  814734:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814738:	66 89 50 0c          	mov    %dx,0xc(%rax)
  tcphdr->wnd = htons(TCP_WND);
  81473c:	bf c0 5d 00 00       	mov    $0x5dc0,%edi
  814741:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  814748:	00 00 00 
  81474b:	ff d0                	callq  *%rax
  81474d:	89 c2                	mov    %eax,%edx
  81474f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814753:	66 89 50 0e          	mov    %dx,0xe(%rax)
  tcphdr->urgp = 0;
  814757:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81475b:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  814761:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814765:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814769:	0f b7 c0             	movzwl %ax,%eax
  81476c:	89 c7                	mov    %eax,%edi
  81476e:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  814775:	00 00 00 
  814778:	ff d0                	callq  *%rax
  81477a:	83 e0 3f             	and    $0x3f,%eax
  81477d:	80 cc 50             	or     $0x50,%ah
  814780:	0f b7 c0             	movzwl %ax,%eax
  814783:	89 c7                	mov    %eax,%edi
  814785:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  81478c:	00 00 00 
  81478f:	ff d0                	callq  *%rax
  814791:	89 c2                	mov    %eax,%edx
  814793:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814797:	66 89 50 0c          	mov    %dx,0xc(%rax)

  tcphdr->chksum = 0;
  81479b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81479f:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
  8147a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8147a9:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  tcphdr->urgp = 0;
  TCPH_HDRLEN_SET(tcphdr, 5);

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  8147ad:	0f b7 c8             	movzwl %ax,%ecx
  8147b0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8147b4:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8147b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8147bc:	41 89 c8             	mov    %ecx,%r8d
  8147bf:	b9 06 00 00 00       	mov    $0x6,%ecx
  8147c4:	48 89 c7             	mov    %rax,%rdi
  8147c7:	48 b8 18 28 81 00 00 	movabs $0x812818,%rax
  8147ce:	00 00 00 
  8147d1:	ff d0                	callq  *%rax
  8147d3:	89 c2                	mov    %eax,%edx
  8147d5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8147d9:	66 89 50 10          	mov    %dx,0x10(%rax)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  8147dd:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8147e1:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8147e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8147e9:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  8147ef:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8147f5:	b9 ff 00 00 00       	mov    $0xff,%ecx
  8147fa:	48 89 c7             	mov    %rax,%rdi
  8147fd:	48 b8 05 16 81 00 00 	movabs $0x811605,%rax
  814804:	00 00 00 
  814807:	ff d0                	callq  *%rax
  pbuf_free(p);
  814809:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81480d:	48 89 c7             	mov    %rax,%rdi
  814810:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  814817:	00 00 00 
  81481a:	ff d0                	callq  *%rax
  81481c:	eb 01                	jmp    81481f <tcp_rst+0x21a>
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  if (p == NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  81481e:	90                   	nop
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  81481f:	c9                   	leaveq 
  814820:	c3                   	retq   

0000000000814821 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  814821:	55                   	push   %rbp
  814822:	48 89 e5             	mov    %rsp,%rbp
  814825:	48 83 ec 20          	sub    $0x20,%rsp
  814829:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  81482d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814831:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814838:	48 85 c0             	test   %rax,%rax
  81483b:	0f 84 ba 00 00 00    	je     8148fb <tcp_rexmit_rto+0xda>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  814841:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814845:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81484c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  814850:	eb 0b                	jmp    81485d <tcp_rexmit_rto+0x3c>
  814852:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814856:	48 8b 00             	mov    (%rax),%rax
  814859:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81485d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814861:	48 8b 00             	mov    (%rax),%rax
  814864:	48 85 c0             	test   %rax,%rax
  814867:	75 e9                	jne    814852 <tcp_rexmit_rto+0x31>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  814869:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81486d:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
  814874:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814878:	48 89 10             	mov    %rdx,(%rax)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  81487b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81487f:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  814886:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81488a:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  814891:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814895:	48 c7 80 88 00 00 00 	movq   $0x0,0x88(%rax)
  81489c:	00 00 00 00 

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  8148a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8148a4:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8148ab:	48 8b 40 20          	mov    0x20(%rax),%rax
  8148af:	8b 40 04             	mov    0x4(%rax),%eax
  8148b2:	89 c7                	mov    %eax,%edi
  8148b4:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  8148bb:	00 00 00 
  8148be:	ff d0                	callq  *%rax
  8148c0:	89 c2                	mov    %eax,%edx
  8148c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8148c6:	89 50 60             	mov    %edx,0x60(%rax)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  8148c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8148cd:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  8148d1:	8d 50 01             	lea    0x1(%rax),%edx
  8148d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8148d8:	88 50 52             	mov    %dl,0x52(%rax)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  8148db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8148df:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)

  /* Do the actual retransmission */
  tcp_output(pcb);
  8148e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8148ea:	48 89 c7             	mov    %rax,%rdi
  8148ed:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  8148f4:	00 00 00 
  8148f7:	ff d0                	callq  *%rax
  8148f9:	eb 01                	jmp    8148fc <tcp_rexmit_rto+0xdb>
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
  8148fb:	90                   	nop
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
}
  8148fc:	c9                   	leaveq 
  8148fd:	c3                   	retq   

00000000008148fe <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  8148fe:	55                   	push   %rbp
  8148ff:	48 89 e5             	mov    %rsp,%rbp
  814902:	48 83 ec 20          	sub    $0x20,%rsp
  814906:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  81490a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81490e:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814915:	48 85 c0             	test   %rax,%rax
  814918:	0f 84 ab 00 00 00    	je     8149c9 <tcp_rexmit+0xcb>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  81491e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814922:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814929:	48 8b 00             	mov    (%rax),%rax
  81492c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  pcb->unacked->next = pcb->unsent;
  814930:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814934:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81493b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81493f:	48 8b 92 80 00 00 00 	mov    0x80(%rdx),%rdx
  814946:	48 89 10             	mov    %rdx,(%rax)
  pcb->unsent = pcb->unacked;
  814949:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81494d:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  814954:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814958:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  pcb->unacked = seg;
  81495f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814963:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  814967:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  81496e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814972:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  814979:	48 8b 40 20          	mov    0x20(%rax),%rax
  81497d:	8b 40 04             	mov    0x4(%rax),%eax
  814980:	89 c7                	mov    %eax,%edi
  814982:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  814989:	00 00 00 
  81498c:	ff d0                	callq  *%rax
  81498e:	89 c2                	mov    %eax,%edx
  814990:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814994:	89 50 60             	mov    %edx,0x60(%rax)

  ++pcb->nrtx;
  814997:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81499b:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  81499f:	8d 50 01             	lea    0x1(%rax),%edx
  8149a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8149a6:	88 50 52             	mov    %dl,0x52(%rax)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  8149a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8149ad:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  8149b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8149b8:	48 89 c7             	mov    %rax,%rdi
  8149bb:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  8149c2:	00 00 00 
  8149c5:	ff d0                	callq  *%rax
  8149c7:	eb 01                	jmp    8149ca <tcp_rexmit+0xcc>
tcp_rexmit(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
  8149c9:	90                   	nop
  pcb->rttest = 0;

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
}
  8149ca:	c9                   	leaveq 
  8149cb:	c3                   	retq   

00000000008149cc <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  8149cc:	55                   	push   %rbp
  8149cd:	48 89 e5             	mov    %rsp,%rbp
  8149d0:	48 83 ec 20          	sub    $0x20,%rsp
  8149d4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8149d8:	ba 00 00 00 00       	mov    $0x0,%edx
  8149dd:	be 14 00 00 00       	mov    $0x14,%esi
  8149e2:	bf 01 00 00 00       	mov    $0x1,%edi
  8149e7:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  8149ee:	00 00 00 
  8149f1:	ff d0                	callq  *%rax
  8149f3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
   
  if(p == NULL) {
  8149f7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8149fc:	0f 84 fe 01 00 00    	je     814c00 <tcp_keepalive+0x234>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  814a02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814a06:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  814a0a:	66 83 f8 13          	cmp    $0x13,%ax
  814a0e:	77 2a                	ja     814a3a <tcp_keepalive+0x6e>
  814a10:	48 ba 18 2c 82 00 00 	movabs $0x822c18,%rdx
  814a17:	00 00 00 
  814a1a:	be 3b 03 00 00       	mov    $0x33b,%esi
  814a1f:	48 bf 87 2a 82 00 00 	movabs $0x822a87,%rdi
  814a26:	00 00 00 
  814a29:	b8 00 00 00 00       	mov    $0x0,%eax
  814a2e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  814a35:	00 00 00 
  814a38:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  814a3a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814a3e:	48 8b 40 08          	mov    0x8(%rax),%rax
  814a42:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  tcphdr->src = htons(pcb->local_port);
  814a46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814a4a:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  814a4e:	0f b7 c0             	movzwl %ax,%eax
  814a51:	89 c7                	mov    %eax,%edi
  814a53:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  814a5a:	00 00 00 
  814a5d:	ff d0                	callq  *%rax
  814a5f:	89 c2                	mov    %eax,%edx
  814a61:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814a65:	66 89 10             	mov    %dx,(%rax)
  tcphdr->dest = htons(pcb->remote_port);
  814a68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814a6c:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  814a70:	0f b7 c0             	movzwl %ax,%eax
  814a73:	89 c7                	mov    %eax,%edi
  814a75:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  814a7c:	00 00 00 
  814a7f:	ff d0                	callq  *%rax
  814a81:	89 c2                	mov    %eax,%edx
  814a83:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814a87:	66 89 50 02          	mov    %dx,0x2(%rax)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  814a8b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814a8f:	8b 40 60             	mov    0x60(%rax),%eax
  814a92:	83 e8 01             	sub    $0x1,%eax
  814a95:	89 c7                	mov    %eax,%edi
  814a97:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  814a9e:	00 00 00 
  814aa1:	ff d0                	callq  *%rax
  814aa3:	89 c2                	mov    %eax,%edx
  814aa5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814aa9:	89 50 04             	mov    %edx,0x4(%rax)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  814aac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814ab0:	8b 40 30             	mov    0x30(%rax),%eax
  814ab3:	89 c7                	mov    %eax,%edi
  814ab5:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  814abc:	00 00 00 
  814abf:	ff d0                	callq  *%rax
  814ac1:	89 c2                	mov    %eax,%edx
  814ac3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814ac7:	89 50 08             	mov    %edx,0x8(%rax)
  TCPH_FLAGS_SET(tcphdr, 0);
  814aca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814ace:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814ad2:	0f b7 c0             	movzwl %ax,%eax
  814ad5:	89 c7                	mov    %eax,%edi
  814ad7:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  814ade:	00 00 00 
  814ae1:	ff d0                	callq  *%rax
  814ae3:	0f b7 c0             	movzwl %ax,%eax
  814ae6:	25 c0 ff 00 00       	and    $0xffc0,%eax
  814aeb:	89 c7                	mov    %eax,%edi
  814aed:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  814af4:	00 00 00 
  814af7:	ff d0                	callq  *%rax
  814af9:	89 c2                	mov    %eax,%edx
  814afb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814aff:	66 89 50 0c          	mov    %dx,0xc(%rax)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  814b03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814b07:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  814b0b:	0f b7 c0             	movzwl %ax,%eax
  814b0e:	89 c7                	mov    %eax,%edi
  814b10:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  814b17:	00 00 00 
  814b1a:	ff d0                	callq  *%rax
  814b1c:	89 c2                	mov    %eax,%edx
  814b1e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814b22:	66 89 50 0e          	mov    %dx,0xe(%rax)
  tcphdr->urgp = 0;
  814b26:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814b2a:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  814b30:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814b34:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814b38:	0f b7 c0             	movzwl %ax,%eax
  814b3b:	89 c7                	mov    %eax,%edi
  814b3d:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  814b44:	00 00 00 
  814b47:	ff d0                	callq  *%rax
  814b49:	83 e0 3f             	and    $0x3f,%eax
  814b4c:	80 cc 50             	or     $0x50,%ah
  814b4f:	0f b7 c0             	movzwl %ax,%eax
  814b52:	89 c7                	mov    %eax,%edi
  814b54:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  814b5b:	00 00 00 
  814b5e:	ff d0                	callq  *%rax
  814b60:	89 c2                	mov    %eax,%edx
  814b62:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814b66:	66 89 50 0c          	mov    %dx,0xc(%rax)

  tcphdr->chksum = 0;
  814b6a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814b6e:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
  814b74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814b78:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  tcphdr->urgp = 0;
  TCPH_HDRLEN_SET(tcphdr, 5);

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  814b7c:	0f b7 c8             	movzwl %ax,%ecx
  814b7f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814b83:	48 8d 50 04          	lea    0x4(%rax),%rdx
  814b87:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  814b8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814b8f:	41 89 c8             	mov    %ecx,%r8d
  814b92:	b9 06 00 00 00       	mov    $0x6,%ecx
  814b97:	48 89 c7             	mov    %rax,%rdi
  814b9a:	48 b8 18 28 81 00 00 	movabs $0x812818,%rax
  814ba1:	00 00 00 
  814ba4:	ff d0                	callq  *%rax
  814ba6:	89 c2                	mov    %eax,%edx
  814ba8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814bac:	66 89 50 10          	mov    %dx,0x10(%rax)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  814bb0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814bb4:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  814bb8:	0f b6 d0             	movzbl %al,%edx
  814bbb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814bbf:	48 8d 78 04          	lea    0x4(%rax),%rdi
  814bc3:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  814bc7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814bcb:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  814bd1:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  814bd7:	89 d1                	mov    %edx,%ecx
  814bd9:	48 89 fa             	mov    %rdi,%rdx
  814bdc:	48 89 c7             	mov    %rax,%rdi
  814bdf:	48 b8 05 16 81 00 00 	movabs $0x811605,%rax
  814be6:	00 00 00 
  814be9:	ff d0                	callq  *%rax
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  814beb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814bef:	48 89 c7             	mov    %rax,%rdi
  814bf2:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  814bf9:	00 00 00 
  814bfc:	ff d0                	callq  *%rax
  814bfe:	eb 01                	jmp    814c01 <tcp_keepalive+0x235>
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
   
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  814c00:	90                   	nop

  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  814c01:	c9                   	leaveq 
  814c02:	c3                   	retq   

0000000000814c03 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  814c03:	55                   	push   %rbp
  814c04:	48 89 e5             	mov    %rsp,%rbp
  814c07:	48 83 ec 30          	sub    $0x30,%rsp
  814c0b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  814c0f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814c13:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814c1a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if(seg == NULL)
  814c1e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814c23:	75 0f                	jne    814c34 <tcp_zero_window_probe+0x31>
    seg = pcb->unsent;
  814c25:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814c29:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  814c30:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if(seg == NULL)
  814c34:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814c39:	0f 84 32 02 00 00    	je     814e71 <tcp_zero_window_probe+0x26e>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  814c3f:	ba 00 00 00 00       	mov    $0x0,%edx
  814c44:	be 15 00 00 00       	mov    $0x15,%esi
  814c49:	bf 01 00 00 00       	mov    $0x1,%edi
  814c4e:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  814c55:	00 00 00 
  814c58:	ff d0                	callq  *%rax
  814c5a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
   
  if(p == NULL) {
  814c5e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  814c63:	0f 84 0b 02 00 00    	je     814e74 <tcp_zero_window_probe+0x271>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  814c69:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814c6d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  814c71:	66 83 f8 13          	cmp    $0x13,%ax
  814c75:	77 2a                	ja     814ca1 <tcp_zero_window_probe+0x9e>
  814c77:	48 ba 18 2c 82 00 00 	movabs $0x822c18,%rdx
  814c7e:	00 00 00 
  814c81:	be 8e 03 00 00       	mov    $0x38e,%esi
  814c86:	48 bf 87 2a 82 00 00 	movabs $0x822a87,%rdi
  814c8d:	00 00 00 
  814c90:	b8 00 00 00 00       	mov    $0x0,%eax
  814c95:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  814c9c:	00 00 00 
  814c9f:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  814ca1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814ca5:	48 8b 40 08          	mov    0x8(%rax),%rax
  814ca9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  tcphdr->src = htons(pcb->local_port);
  814cad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814cb1:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  814cb5:	0f b7 c0             	movzwl %ax,%eax
  814cb8:	89 c7                	mov    %eax,%edi
  814cba:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  814cc1:	00 00 00 
  814cc4:	ff d0                	callq  *%rax
  814cc6:	89 c2                	mov    %eax,%edx
  814cc8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814ccc:	66 89 10             	mov    %dx,(%rax)
  tcphdr->dest = htons(pcb->remote_port);
  814ccf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814cd3:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  814cd7:	0f b7 c0             	movzwl %ax,%eax
  814cda:	89 c7                	mov    %eax,%edi
  814cdc:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  814ce3:	00 00 00 
  814ce6:	ff d0                	callq  *%rax
  814ce8:	89 c2                	mov    %eax,%edx
  814cea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814cee:	66 89 50 02          	mov    %dx,0x2(%rax)
  tcphdr->seqno = seg->tcphdr->seqno;
  814cf2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814cf6:	48 8b 40 20          	mov    0x20(%rax),%rax
  814cfa:	8b 50 04             	mov    0x4(%rax),%edx
  814cfd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814d01:	89 50 04             	mov    %edx,0x4(%rax)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  814d04:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814d08:	8b 40 30             	mov    0x30(%rax),%eax
  814d0b:	89 c7                	mov    %eax,%edi
  814d0d:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  814d14:	00 00 00 
  814d17:	ff d0                	callq  *%rax
  814d19:	89 c2                	mov    %eax,%edx
  814d1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814d1f:	89 50 08             	mov    %edx,0x8(%rax)
  TCPH_FLAGS_SET(tcphdr, 0);
  814d22:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814d26:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814d2a:	0f b7 c0             	movzwl %ax,%eax
  814d2d:	89 c7                	mov    %eax,%edi
  814d2f:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  814d36:	00 00 00 
  814d39:	ff d0                	callq  *%rax
  814d3b:	0f b7 c0             	movzwl %ax,%eax
  814d3e:	25 c0 ff 00 00       	and    $0xffc0,%eax
  814d43:	89 c7                	mov    %eax,%edi
  814d45:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  814d4c:	00 00 00 
  814d4f:	ff d0                	callq  *%rax
  814d51:	89 c2                	mov    %eax,%edx
  814d53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814d57:	66 89 50 0c          	mov    %dx,0xc(%rax)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  814d5b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814d5f:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  814d63:	0f b7 c0             	movzwl %ax,%eax
  814d66:	89 c7                	mov    %eax,%edi
  814d68:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  814d6f:	00 00 00 
  814d72:	ff d0                	callq  *%rax
  814d74:	89 c2                	mov    %eax,%edx
  814d76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814d7a:	66 89 50 0e          	mov    %dx,0xe(%rax)
  tcphdr->urgp = 0;
  814d7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814d82:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  814d88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814d8c:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814d90:	0f b7 c0             	movzwl %ax,%eax
  814d93:	89 c7                	mov    %eax,%edi
  814d95:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  814d9c:	00 00 00 
  814d9f:	ff d0                	callq  *%rax
  814da1:	83 e0 3f             	and    $0x3f,%eax
  814da4:	80 cc 50             	or     $0x50,%ah
  814da7:	0f b7 c0             	movzwl %ax,%eax
  814daa:	89 c7                	mov    %eax,%edi
  814dac:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  814db3:	00 00 00 
  814db6:	ff d0                	callq  *%rax
  814db8:	89 c2                	mov    %eax,%edx
  814dba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814dbe:	66 89 50 0c          	mov    %dx,0xc(%rax)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  814dc2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814dc6:	48 8b 40 08          	mov    0x8(%rax),%rax
  814dca:	48 8d 50 14          	lea    0x14(%rax),%rdx
  814dce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814dd2:	48 8b 40 10          	mov    0x10(%rax),%rax
  814dd6:	0f b6 00             	movzbl (%rax),%eax
  814dd9:	88 02                	mov    %al,(%rdx)

  tcphdr->chksum = 0;
  814ddb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814ddf:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
  814de5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814de9:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  814ded:	0f b7 c8             	movzwl %ax,%ecx
  814df0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814df4:	48 8d 50 04          	lea    0x4(%rax),%rdx
  814df8:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  814dfc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814e00:	41 89 c8             	mov    %ecx,%r8d
  814e03:	b9 06 00 00 00       	mov    $0x6,%ecx
  814e08:	48 89 c7             	mov    %rax,%rdi
  814e0b:	48 b8 18 28 81 00 00 	movabs $0x812818,%rax
  814e12:	00 00 00 
  814e15:	ff d0                	callq  *%rax
  814e17:	89 c2                	mov    %eax,%edx
  814e19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814e1d:	66 89 50 10          	mov    %dx,0x10(%rax)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  814e21:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814e25:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  814e29:	0f b6 d0             	movzbl %al,%edx
  814e2c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814e30:	48 8d 78 04          	lea    0x4(%rax),%rdi
  814e34:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  814e38:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814e3c:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  814e42:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  814e48:	89 d1                	mov    %edx,%ecx
  814e4a:	48 89 fa             	mov    %rdi,%rdx
  814e4d:	48 89 c7             	mov    %rax,%rdi
  814e50:	48 b8 05 16 81 00 00 	movabs $0x811605,%rax
  814e57:	00 00 00 
  814e5a:	ff d0                	callq  *%rax
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  814e5c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814e60:	48 89 c7             	mov    %rax,%rdi
  814e63:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  814e6a:	00 00 00 
  814e6d:	ff d0                	callq  *%rax
  814e6f:	eb 04                	jmp    814e75 <tcp_zero_window_probe+0x272>

  if(seg == NULL)
    seg = pcb->unsent;

  if(seg == NULL)
    return;
  814e71:	90                   	nop
  814e72:	eb 01                	jmp    814e75 <tcp_zero_window_probe+0x272>

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
   
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  814e74:	90                   	nop
  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  814e75:	c9                   	leaveq 
  814e76:	c3                   	retq   

0000000000814e77 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  814e77:	55                   	push   %rbp
  814e78:	48 89 e5             	mov    %rsp,%rbp
  814e7b:	53                   	push   %rbx
  814e7c:	48 83 ec 58          	sub    $0x58,%rsp
  814e80:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  814e84:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  814e88:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814e8c:	48 8b 40 08          	mov    0x8(%rax),%rax
  814e90:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  814e94:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814e98:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  814e9c:	0f b7 d8             	movzwl %ax,%ebx
  814e9f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814ea3:	0f b7 00             	movzwl (%rax),%eax
  814ea6:	0f b7 c0             	movzwl %ax,%eax
  814ea9:	89 c7                	mov    %eax,%edi
  814eab:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  814eb2:	00 00 00 
  814eb5:	ff d0                	callq  *%rax
  814eb7:	66 c1 e8 08          	shr    $0x8,%ax
  814ebb:	0f b7 c0             	movzwl %ax,%eax
  814ebe:	83 e0 0f             	and    $0xf,%eax
  814ec1:	83 c0 02             	add    $0x2,%eax
  814ec4:	c1 e0 02             	shl    $0x2,%eax
  814ec7:	39 c3                	cmp    %eax,%ebx
  814ec9:	7c 40                	jl     814f0b <udp_input+0x94>
  814ecb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814ecf:	0f b7 00             	movzwl (%rax),%eax
  814ed2:	0f b7 c0             	movzwl %ax,%eax
  814ed5:	89 c7                	mov    %eax,%edi
  814ed7:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  814ede:	00 00 00 
  814ee1:	ff d0                	callq  *%rax
  814ee3:	66 c1 e8 08          	shr    $0x8,%ax
  814ee7:	83 e0 0f             	and    $0xf,%eax
  814eea:	c1 e0 02             	shl    $0x2,%eax
  814eed:	f7 d8                	neg    %eax
  814eef:	0f bf d0             	movswl %ax,%edx
  814ef2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814ef6:	89 d6                	mov    %edx,%esi
  814ef8:	48 89 c7             	mov    %rax,%rdi
  814efb:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  814f02:	00 00 00 
  814f05:	ff d0                	callq  *%rax
  814f07:	84 c0                	test   %al,%al
  814f09:	74 18                	je     814f23 <udp_input+0xac>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  814f0b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814f0f:	48 89 c7             	mov    %rax,%rdi
  814f12:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  814f19:	00 00 00 
  814f1c:	ff d0                	callq  *%rax
    goto end;
  814f1e:	e9 65 04 00 00       	jmpq   815388 <udp_input+0x511>
  }

  udphdr = (struct udp_hdr *)p->payload;
  814f23:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814f27:	48 8b 40 08          	mov    0x8(%rax),%rax
  814f2b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  814f2f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  814f33:	0f b7 00             	movzwl (%rax),%eax
  814f36:	0f b7 c0             	movzwl %ax,%eax
  814f39:	89 c7                	mov    %eax,%edi
  814f3b:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  814f42:	00 00 00 
  814f45:	ff d0                	callq  *%rax
  814f47:	66 89 45 be          	mov    %ax,-0x42(%rbp)
  dest = ntohs(udphdr->dest);
  814f4b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  814f4f:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  814f53:	0f b7 c0             	movzwl %ax,%eax
  814f56:	89 c7                	mov    %eax,%edi
  814f58:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  814f5f:	00 00 00 
  814f62:	ff d0                	callq  *%rax
  814f64:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
               ip4_addr3(&iphdr->dest), ip4_addr4(&iphdr->dest), ntohs(udphdr->dest),
               ip4_addr1(&iphdr->src), ip4_addr2(&iphdr->src),
               ip4_addr3(&iphdr->src), ip4_addr4(&iphdr->src), ntohs(udphdr->src)));

#if LWIP_DHCP
  pcb = NULL;
  814f68:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  814f6f:	00 
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  814f70:	66 83 7d bc 44       	cmpw   $0x44,-0x44(%rbp)
  814f75:	0f 85 8c 00 00 00    	jne    815007 <udp_input+0x190>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  814f7b:	66 83 7d be 43       	cmpw   $0x43,-0x42(%rbp)
  814f80:	0f 85 d6 01 00 00    	jne    81515c <udp_input+0x2e5>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  814f86:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814f8a:	48 8b 40 38          	mov    0x38(%rax),%rax
  814f8e:	48 85 c0             	test   %rax,%rax
  814f91:	0f 84 c5 01 00 00    	je     81515c <udp_input+0x2e5>
  814f97:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814f9b:	48 8b 40 38          	mov    0x38(%rax),%rax
  814f9f:	48 8b 40 08          	mov    0x8(%rax),%rax
  814fa3:	48 85 c0             	test   %rax,%rax
  814fa6:	0f 84 b0 01 00 00    	je     81515c <udp_input+0x2e5>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  814fac:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814fb0:	48 8b 40 38          	mov    0x38(%rax),%rax
  814fb4:	48 8b 40 08          	mov    0x8(%rax),%rax
  814fb8:	48 83 c0 04          	add    $0x4,%rax
  814fbc:	48 85 c0             	test   %rax,%rax
  814fbf:	74 31                	je     814ff2 <udp_input+0x17b>
  814fc1:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814fc5:	48 8b 40 38          	mov    0x38(%rax),%rax
  814fc9:	48 8b 40 08          	mov    0x8(%rax),%rax
  814fcd:	8b 40 04             	mov    0x4(%rax),%eax
  814fd0:	85 c0                	test   %eax,%eax
  814fd2:	74 1e                	je     814ff2 <udp_input+0x17b>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
  814fd4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814fd8:	48 8b 40 38          	mov    0x38(%rax),%rax
  814fdc:	48 8b 40 08          	mov    0x8(%rax),%rax
  814fe0:	8b 50 04             	mov    0x4(%rax),%edx
  814fe3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814fe7:	8b 40 0c             	mov    0xc(%rax),%eax
    if (src == DHCP_SERVER_PORT) {
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  814fea:	39 c2                	cmp    %eax,%edx
  814fec:	0f 85 6a 01 00 00    	jne    81515c <udp_input+0x2e5>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
          pcb = inp->dhcp->pcb;
  814ff2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814ff6:	48 8b 40 38          	mov    0x38(%rax),%rax
  814ffa:	48 8b 40 08          	mov    0x8(%rax),%rax
  814ffe:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  815002:	e9 55 01 00 00       	jmpq   81515c <udp_input+0x2e5>
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  815007:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81500e:	00 
    local_match = 0;
  81500f:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
    uncon_pcb = NULL;
  815013:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  81501a:	00 
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  81501b:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815022:	00 00 00 
  815025:	48 8b 00             	mov    (%rax),%rax
  815028:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81502c:	e9 0e 01 00 00       	jmpq   81513f <udp_input+0x2c8>
      local_match = 0;
  815031:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  815035:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815039:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  81503d:	66 3b 45 bc          	cmp    -0x44(%rbp),%ax
  815041:	75 6b                	jne    8150ae <udp_input+0x237>
          (ip_addr_isany(&pcb->local_ip) ||
  815043:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  815047:	48 85 c0             	test   %rax,%rax
  81504a:	74 3d                	je     815089 <udp_input+0x212>
          (ip_addr_isany(&pcb->local_ip) ||
  81504c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815050:	8b 00                	mov    (%rax),%eax
  815052:	85 c0                	test   %eax,%eax
  815054:	74 33                	je     815089 <udp_input+0x212>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  815056:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81505a:	8b 10                	mov    (%rax),%edx
  81505c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815060:	8b 40 10             	mov    0x10(%rax),%eax
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
  815063:	39 c2                	cmp    %eax,%edx
  815065:	74 22                	je     815089 <udp_input+0x212>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  815067:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81506b:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81506f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  815073:	48 89 c6             	mov    %rax,%rsi
  815076:	48 89 d7             	mov    %rdx,%rdi
  815079:	48 b8 70 0d 81 00 00 	movabs $0x810d70,%rax
  815080:	00 00 00 
  815083:	ff d0                	callq  *%rax
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  815085:	84 c0                	test   %al,%al
  815087:	74 25                	je     8150ae <udp_input+0x237>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
  815089:	c6 45 d7 01          	movb   $0x1,-0x29(%rbp)
        if ((uncon_pcb == NULL) && 
  81508d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  815092:	75 1a                	jne    8150ae <udp_input+0x237>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
  815094:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815098:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81509c:	0f b6 c0             	movzbl %al,%eax
  81509f:	83 e0 04             	and    $0x4,%eax
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  8150a2:	85 c0                	test   %eax,%eax
  8150a4:	75 08                	jne    8150ae <udp_input+0x237>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
  8150a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8150aa:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  8150ae:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  8150b2:	74 77                	je     81512b <udp_input+0x2b4>
          (pcb->remote_port == src) &&
  8150b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8150b8:	0f b7 40 1c          	movzwl 0x1c(%rax),%eax
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  8150bc:	66 3b 45 be          	cmp    -0x42(%rbp),%ax
  8150c0:	75 69                	jne    81512b <udp_input+0x2b4>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  8150c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8150c6:	48 83 c0 04          	add    $0x4,%rax
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  8150ca:	48 85 c0             	test   %rax,%rax
  8150cd:	74 1d                	je     8150ec <udp_input+0x275>
          (ip_addr_isany(&pcb->remote_ip) ||
  8150cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8150d3:	8b 40 04             	mov    0x4(%rax),%eax
  8150d6:	85 c0                	test   %eax,%eax
  8150d8:	74 12                	je     8150ec <udp_input+0x275>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
  8150da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8150de:	8b 50 04             	mov    0x4(%rax),%edx
  8150e1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8150e5:	8b 40 0c             	mov    0xc(%rax),%eax
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  8150e8:	39 c2                	cmp    %eax,%edx
  8150ea:	75 3f                	jne    81512b <udp_input+0x2b4>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  8150ec:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8150f1:	74 59                	je     81514c <udp_input+0x2d5>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  8150f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8150f7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8150fb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8150ff:	48 89 50 10          	mov    %rdx,0x10(%rax)
          pcb->next = udp_pcbs;
  815103:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  81510a:	00 00 00 
  81510d:	48 8b 10             	mov    (%rax),%rdx
  815110:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815114:	48 89 50 10          	mov    %rdx,0x10(%rax)
          udp_pcbs = pcb;
  815118:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  81511f:	00 00 00 
  815122:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  815126:	48 89 10             	mov    %rdx,(%rax)
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
  815129:	eb 21                	jmp    81514c <udp_input+0x2d5>
      }
      prev = pcb;
  81512b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81512f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  815133:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815137:	48 8b 40 10          	mov    0x10(%rax),%rax
  81513b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81513f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815144:	0f 85 e7 fe ff ff    	jne    815031 <udp_input+0x1ba>
  81514a:	eb 01                	jmp    81514d <udp_input+0x2d6>
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
  81514c:	90                   	nop
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
  81514d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815152:	75 08                	jne    81515c <udp_input+0x2e5>
      pcb = uncon_pcb;
  815154:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815158:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  81515c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815161:	75 16                	jne    815179 <udp_input+0x302>
  815163:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  815167:	8b 50 08             	mov    0x8(%rax),%edx
  81516a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81516e:	8b 40 10             	mov    0x10(%rax),%eax
  815171:	39 c2                	cmp    %eax,%edx
  815173:	0f 85 fc 01 00 00    	jne    815375 <udp_input+0x4fe>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  815179:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81517d:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  815181:	66 85 c0             	test   %ax,%ax
  815184:	74 53                	je     8151d9 <udp_input+0x362>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
                               (struct ip_addr *)&(iphdr->dest),
                               IP_PROTO_UDP, p->tot_len) != 0) {
  815186:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81518a:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81518e:	0f b7 c8             	movzwl %ax,%ecx
  815191:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815195:	48 8d 50 10          	lea    0x10(%rax),%rdx
  815199:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81519d:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  8151a1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8151a5:	41 89 c8             	mov    %ecx,%r8d
  8151a8:	b9 11 00 00 00       	mov    $0x11,%ecx
  8151ad:	48 89 c7             	mov    %rax,%rdi
  8151b0:	48 b8 18 28 81 00 00 	movabs $0x812818,%rax
  8151b7:	00 00 00 
  8151ba:	ff d0                	callq  *%rax
  8151bc:	66 85 c0             	test   %ax,%ax
  8151bf:	74 18                	je     8151d9 <udp_input+0x362>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  8151c1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8151c5:	48 89 c7             	mov    %rax,%rdi
  8151c8:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  8151cf:	00 00 00 
  8151d2:	ff d0                	callq  *%rax
          goto end;
  8151d4:	e9 af 01 00 00       	jmpq   815388 <udp_input+0x511>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  8151d9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8151dd:	be f8 ff ff ff       	mov    $0xfffffff8,%esi
  8151e2:	48 89 c7             	mov    %rax,%rdi
  8151e5:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  8151ec:	00 00 00 
  8151ef:	ff d0                	callq  *%rax
  8151f1:	84 c0                	test   %al,%al
  8151f3:	74 2a                	je     81521f <udp_input+0x3a8>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  8151f5:	48 ba 48 2c 82 00 00 	movabs $0x822c48,%rdx
  8151fc:	00 00 00 
  8151ff:	be 0b 01 00 00       	mov    $0x10b,%esi
  815204:	48 bf 5c 2c 82 00 00 	movabs $0x822c5c,%rdi
  81520b:	00 00 00 
  81520e:	b8 00 00 00 00       	mov    $0x0,%eax
  815213:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81521a:	00 00 00 
  81521d:	ff d1                	callq  *%rcx
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  81521f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815224:	74 51                	je     815277 <udp_input+0x400>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  815226:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81522a:	48 8b 40 20          	mov    0x20(%rax),%rax
  81522e:	48 85 c0             	test   %rax,%rax
  815231:	74 2c                	je     81525f <udp_input+0x3e8>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  815233:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815237:	48 8b 40 20          	mov    0x20(%rax),%rax
  81523b:	44 0f b7 45 be       	movzwl -0x42(%rbp),%r8d
  815240:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  815244:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  815248:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81524c:	48 8b 7a 28          	mov    0x28(%rdx),%rdi
  815250:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  815254:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  815258:	ff d0                	callq  *%rax
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  81525a:	e9 29 01 00 00       	jmpq   815388 <udp_input+0x511>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  81525f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  815263:	48 89 c7             	mov    %rax,%rdi
  815266:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81526d:	00 00 00 
  815270:	ff d0                	callq  *%rax
        goto end;
  815272:	e9 11 01 00 00       	jmpq   815388 <udp_input+0x511>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  815277:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81527b:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81527f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  815283:	48 89 c6             	mov    %rax,%rsi
  815286:	48 89 d7             	mov    %rdx,%rdi
  815289:	48 b8 70 0d 81 00 00 	movabs $0x810d70,%rax
  815290:	00 00 00 
  815293:	ff d0                	callq  *%rax
  815295:	84 c0                	test   %al,%al
  815297:	0f 85 c3 00 00 00    	jne    815360 <udp_input+0x4e9>
          !ip_addr_ismulticast(&iphdr->dest)) {
  81529d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8152a1:	8b 58 10             	mov    0x10(%rax),%ebx
  8152a4:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  8152a9:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  8152b0:	00 00 00 
  8152b3:	ff d0                	callq  *%rax
  8152b5:	21 c3                	and    %eax,%ebx
  8152b7:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  8152bc:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  8152c3:	00 00 00 
  8152c6:	ff d0                	callq  *%rax
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  8152c8:	39 c3                	cmp    %eax,%ebx
  8152ca:	0f 84 90 00 00 00    	je     815360 <udp_input+0x4e9>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  8152d0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8152d4:	0f b7 00             	movzwl (%rax),%eax
  8152d7:	0f b7 c0             	movzwl %ax,%eax
  8152da:	89 c7                	mov    %eax,%edi
  8152dc:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  8152e3:	00 00 00 
  8152e6:	ff d0                	callq  *%rax
  8152e8:	66 c1 e8 08          	shr    $0x8,%ax
  8152ec:	0f b7 c0             	movzwl %ax,%eax
  8152ef:	83 e0 0f             	and    $0xf,%eax
  8152f2:	83 c0 02             	add    $0x2,%eax
  8152f5:	c1 e0 02             	shl    $0x2,%eax
  8152f8:	0f bf d0             	movswl %ax,%edx
  8152fb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8152ff:	89 d6                	mov    %edx,%esi
  815301:	48 89 c7             	mov    %rax,%rdi
  815304:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  81530b:	00 00 00 
  81530e:	ff d0                	callq  *%rax
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  815310:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  815314:	48 8b 40 08          	mov    0x8(%rax),%rax
  815318:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  81531c:	74 2a                	je     815348 <udp_input+0x4d1>
  81531e:	48 ba 70 2c 82 00 00 	movabs $0x822c70,%rdx
  815325:	00 00 00 
  815328:	be 26 01 00 00       	mov    $0x126,%esi
  81532d:	48 bf 5c 2c 82 00 00 	movabs $0x822c5c,%rdi
  815334:	00 00 00 
  815337:	b8 00 00 00 00       	mov    $0x0,%eax
  81533c:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  815343:	00 00 00 
  815346:	ff d1                	callq  *%rcx
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  815348:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81534c:	be 03 00 00 00       	mov    $0x3,%esi
  815351:	48 89 c7             	mov    %rax,%rdi
  815354:	48 b8 da 08 82 00 00 	movabs $0x8208da,%rax
  81535b:	00 00 00 
  81535e:	ff d0                	callq  *%rax
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  815360:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  815364:	48 89 c7             	mov    %rax,%rdi
  815367:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81536e:	00 00 00 
  815371:	ff d0                	callq  *%rax
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  815373:	eb 13                	jmp    815388 <udp_input+0x511>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
    }
  } else {
    pbuf_free(p);
  815375:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  815379:	48 89 c7             	mov    %rax,%rdi
  81537c:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  815383:	00 00 00 
  815386:	ff d0                	callq  *%rax
  }
end:
  PERF_STOP("udp_input");
}
  815388:	90                   	nop
  815389:	48 83 c4 58          	add    $0x58,%rsp
  81538d:	5b                   	pop    %rbx
  81538e:	5d                   	pop    %rbp
  81538f:	c3                   	retq   

0000000000815390 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  815390:	55                   	push   %rbp
  815391:	48 89 e5             	mov    %rsp,%rbp
  815394:	48 83 ec 10          	sub    $0x10,%rsp
  815398:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81539c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  8153a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8153a4:	0f b7 40 1c          	movzwl 0x1c(%rax),%eax
  8153a8:	0f b7 d0             	movzwl %ax,%edx
  8153ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8153af:	48 8d 78 04          	lea    0x4(%rax),%rdi
  8153b3:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8153b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8153bb:	89 d1                	mov    %edx,%ecx
  8153bd:	48 89 fa             	mov    %rdi,%rdx
  8153c0:	48 89 c7             	mov    %rax,%rdi
  8153c3:	48 b8 d1 53 81 00 00 	movabs $0x8153d1,%rax
  8153ca:	00 00 00 
  8153cd:	ff d0                	callq  *%rax
}
  8153cf:	c9                   	leaveq 
  8153d0:	c3                   	retq   

00000000008153d1 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  8153d1:	55                   	push   %rbp
  8153d2:	48 89 e5             	mov    %rsp,%rbp
  8153d5:	48 83 ec 30          	sub    $0x30,%rsp
  8153d9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8153dd:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8153e1:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8153e5:	89 c8                	mov    %ecx,%eax
  8153e7:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  8153eb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8153ef:	48 89 c7             	mov    %rax,%rdi
  8153f2:	48 b8 0d 0e 81 00 00 	movabs $0x810e0d,%rax
  8153f9:	00 00 00 
  8153fc:	ff d0                	callq  *%rax
  8153fe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  815402:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815407:	75 07                	jne    815410 <udp_sendto+0x3f>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  815409:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  81540e:	eb 26                	jmp    815436 <udp_sendto+0x65>
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  815410:	0f b7 4d d4          	movzwl -0x2c(%rbp),%ecx
  815414:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  815418:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81541c:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  815420:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815424:	49 89 f8             	mov    %rdi,%r8
  815427:	48 89 c7             	mov    %rax,%rdi
  81542a:	48 b8 38 54 81 00 00 	movabs $0x815438,%rax
  815431:	00 00 00 
  815434:	ff d0                	callq  *%rax
}
  815436:	c9                   	leaveq 
  815437:	c3                   	retq   

0000000000815438 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  815438:	55                   	push   %rbp
  815439:	48 89 e5             	mov    %rsp,%rbp
  81543c:	48 83 ec 50          	sub    $0x50,%rsp
  815440:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  815444:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  815448:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  81544c:	89 c8                	mov    %ecx,%eax
  81544e:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  815452:	66 89 45 c4          	mov    %ax,-0x3c(%rbp)
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  815456:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81545a:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  81545e:	66 85 c0             	test   %ax,%ax
  815461:	75 37                	jne    81549a <udp_sendto_if+0x62>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  815463:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815467:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  81546b:	0f b7 d0             	movzwl %ax,%edx
  81546e:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  815472:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815476:	48 89 ce             	mov    %rcx,%rsi
  815479:	48 89 c7             	mov    %rax,%rdi
  81547c:	48 b8 f6 56 81 00 00 	movabs $0x8156f6,%rax
  815483:	00 00 00 
  815486:	ff d0                	callq  *%rax
  815488:	88 45 ef             	mov    %al,-0x11(%rbp)
    if (err != ERR_OK) {
  81548b:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  81548f:	74 09                	je     81549a <udp_sendto_if+0x62>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: forced port bind failed\n"));
      return err;
  815491:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  815495:	e9 5a 02 00 00       	jmpq   8156f4 <udp_sendto_if+0x2bc>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  81549a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81549e:	be 08 00 00 00       	mov    $0x8,%esi
  8154a3:	48 89 c7             	mov    %rax,%rdi
  8154a6:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  8154ad:	00 00 00 
  8154b0:	ff d0                	callq  *%rax
  8154b2:	84 c0                	test   %al,%al
  8154b4:	74 4c                	je     815502 <udp_sendto_if+0xca>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  8154b6:	ba 00 00 00 00       	mov    $0x0,%edx
  8154bb:	be 08 00 00 00       	mov    $0x8,%esi
  8154c0:	bf 01 00 00 00       	mov    $0x1,%edi
  8154c5:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  8154cc:	00 00 00 
  8154cf:	ff d0                	callq  *%rax
  8154d1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  8154d5:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8154da:	75 0a                	jne    8154e6 <udp_sendto_if+0xae>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  8154dc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8154e1:	e9 0e 02 00 00       	jmpq   8156f4 <udp_sendto_if+0x2bc>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  8154e6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8154ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8154ee:	48 89 d6             	mov    %rdx,%rsi
  8154f1:	48 89 c7             	mov    %rax,%rdi
  8154f4:	48 b8 79 e0 80 00 00 	movabs $0x80e079,%rax
  8154fb:	00 00 00 
  8154fe:	ff d0                	callq  *%rax
  815500:	eb 08                	jmp    81550a <udp_sendto_if+0xd2>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  815502:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  815506:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  81550a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81550e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  815512:	66 83 f8 07          	cmp    $0x7,%ax
  815516:	77 2a                	ja     815542 <udp_sendto_if+0x10a>
  815518:	48 ba 88 2c 82 00 00 	movabs $0x822c88,%rdx
  81551f:	00 00 00 
  815522:	be b3 01 00 00       	mov    $0x1b3,%esi
  815527:	48 bf 5c 2c 82 00 00 	movabs $0x822c5c,%rdi
  81552e:	00 00 00 
  815531:	b8 00 00 00 00       	mov    $0x0,%eax
  815536:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81553d:	00 00 00 
  815540:	ff d1                	callq  *%rcx
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  815542:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815546:	48 8b 40 08          	mov    0x8(%rax),%rax
  81554a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  udphdr->src = htons(pcb->local_port);
  81554e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815552:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815556:	0f b7 c0             	movzwl %ax,%eax
  815559:	89 c7                	mov    %eax,%edi
  81555b:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  815562:	00 00 00 
  815565:	ff d0                	callq  *%rax
  815567:	89 c2                	mov    %eax,%edx
  815569:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81556d:	66 89 10             	mov    %dx,(%rax)
  udphdr->dest = htons(dst_port);
  815570:	0f b7 45 c4          	movzwl -0x3c(%rbp),%eax
  815574:	89 c7                	mov    %eax,%edi
  815576:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  81557d:	00 00 00 
  815580:	ff d0                	callq  *%rax
  815582:	89 c2                	mov    %eax,%edx
  815584:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815588:	66 89 50 02          	mov    %dx,0x2(%rax)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  81558c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815590:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  815596:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81559a:	48 85 c0             	test   %rax,%rax
  81559d:	74 0a                	je     8155a9 <udp_sendto_if+0x171>
  81559f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8155a3:	8b 00                	mov    (%rax),%eax
  8155a5:	85 c0                	test   %eax,%eax
  8155a7:	75 0e                	jne    8155b7 <udp_sendto_if+0x17f>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  8155a9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8155ad:	48 83 c0 08          	add    $0x8,%rax
  8155b1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8155b5:	eb 48                	jmp    8155ff <udp_sendto_if+0x1c7>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  8155b7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8155bb:	8b 10                	mov    (%rax),%edx
  8155bd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8155c1:	8b 40 08             	mov    0x8(%rax),%eax
  8155c4:	39 c2                	cmp    %eax,%edx
  8155c6:	74 2f                	je     8155f7 <udp_sendto_if+0x1bf>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  8155c8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8155cc:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8155d0:	74 1b                	je     8155ed <udp_sendto_if+0x1b5>
        /* free the header pbuf */
        pbuf_free(q);
  8155d2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8155d6:	48 89 c7             	mov    %rax,%rdi
  8155d9:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  8155e0:	00 00 00 
  8155e3:	ff d0                	callq  *%rax
        q = NULL;
  8155e5:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8155ec:	00 
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  8155ed:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8155f2:	e9 fd 00 00 00       	jmpq   8156f4 <udp_sendto_if+0x2bc>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  8155f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8155fb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  8155ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815603:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  815607:	0f b7 c0             	movzwl %ax,%eax
  81560a:	89 c7                	mov    %eax,%edi
  81560c:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  815613:	00 00 00 
  815616:	ff d0                	callq  *%rax
  815618:	89 c2                	mov    %eax,%edx
  81561a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81561e:	66 89 50 04          	mov    %dx,0x4(%rax)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  815622:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815626:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81562a:	0f b6 c0             	movzbl %al,%eax
  81562d:	83 e0 01             	and    $0x1,%eax
  815630:	85 c0                	test   %eax,%eax
  815632:	75 4f                	jne    815683 <udp_sendto_if+0x24b>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  815634:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815638:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81563c:	0f b7 c8             	movzwl %ax,%ecx
  81563f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  815643:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  815647:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81564b:	41 89 c8             	mov    %ecx,%r8d
  81564e:	b9 11 00 00 00       	mov    $0x11,%ecx
  815653:	48 89 c7             	mov    %rax,%rdi
  815656:	48 b8 18 28 81 00 00 	movabs $0x812818,%rax
  81565d:	00 00 00 
  815660:	ff d0                	callq  *%rax
  815662:	89 c2                	mov    %eax,%edx
  815664:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815668:	66 89 50 06          	mov    %dx,0x6(%rax)
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  81566c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815670:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  815674:	66 85 c0             	test   %ax,%ax
  815677:	75 0a                	jne    815683 <udp_sendto_if+0x24b>
  815679:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81567d:	66 c7 40 06 ff ff    	movw   $0xffff,0x6(%rax)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  815683:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815687:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  81568b:	0f b6 f8             	movzbl %al,%edi
  81568e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815692:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  815696:	0f b6 c8             	movzbl %al,%ecx
  815699:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81569d:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8156a1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8156a5:	48 83 ec 08          	sub    $0x8,%rsp
  8156a9:	ff 75 b8             	pushq  -0x48(%rbp)
  8156ac:	41 b9 11 00 00 00    	mov    $0x11,%r9d
  8156b2:	41 89 f8             	mov    %edi,%r8d
  8156b5:	48 89 c7             	mov    %rax,%rdi
  8156b8:	48 b8 43 13 81 00 00 	movabs $0x811343,%rax
  8156bf:	00 00 00 
  8156c2:	ff d0                	callq  *%rax
  8156c4:	48 83 c4 10          	add    $0x10,%rsp
  8156c8:	88 45 ef             	mov    %al,-0x11(%rbp)
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  8156cb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8156cf:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8156d3:	74 1b                	je     8156f0 <udp_sendto_if+0x2b8>
    /* free the header pbuf */
    pbuf_free(q);
  8156d5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8156d9:	48 89 c7             	mov    %rax,%rdi
  8156dc:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  8156e3:	00 00 00 
  8156e6:	ff d0                	callq  *%rax
    q = NULL;
  8156e8:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8156ef:	00 
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
  8156f0:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  8156f4:	c9                   	leaveq 
  8156f5:	c3                   	retq   

00000000008156f6 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8156f6:	55                   	push   %rbp
  8156f7:	48 89 e5             	mov    %rsp,%rbp
  8156fa:	48 83 ec 30          	sub    $0x30,%rsp
  8156fe:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  815702:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  815706:	89 d0                	mov    %edx,%eax
  815708:	66 89 45 dc          	mov    %ax,-0x24(%rbp)

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  81570c:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  815710:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815717:	00 00 00 
  81571a:	48 8b 00             	mov    (%rax),%rax
  81571d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  815721:	eb 4a                	jmp    81576d <udp_bind+0x77>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  815723:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815727:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  81572b:	75 34                	jne    815761 <udp_bind+0x6b>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  81572d:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  815731:	74 2a                	je     81575d <udp_bind+0x67>
  815733:	48 ba b6 2c 82 00 00 	movabs $0x822cb6,%rdx
  81573a:	00 00 00 
  81573d:	be 42 02 00 00       	mov    $0x242,%esi
  815742:	48 bf 5c 2c 82 00 00 	movabs $0x822c5c,%rdi
  815749:	00 00 00 
  81574c:	b8 00 00 00 00       	mov    $0x0,%eax
  815751:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  815758:	00 00 00 
  81575b:	ff d1                	callq  *%rcx
      /* pcb already in list, just rebind */
      rebind = 1;
  81575d:	c6 45 f7 01          	movb   $0x1,-0x9(%rbp)
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  815761:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815765:	48 8b 40 10          	mov    0x10(%rax),%rax
  815769:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81576d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815772:	75 af                	jne    815723 <udp_bind+0x2d>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  815774:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  815779:	74 08                	je     815783 <udp_bind+0x8d>
  81577b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81577f:	8b 00                	mov    (%rax),%eax
  815781:	eb 05                	jmp    815788 <udp_bind+0x92>
  815783:	b8 00 00 00 00       	mov    $0x0,%eax
  815788:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81578c:	89 02                	mov    %eax,(%rdx)

  /* no port specified? */
  if (port == 0) {
  81578e:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  815793:	75 6e                	jne    815803 <udp_bind+0x10d>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  815795:	66 c7 45 dc 00 10    	movw   $0x1000,-0x24(%rbp)
    ipcb = udp_pcbs;
  81579b:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8157a2:	00 00 00 
  8157a5:	48 8b 00             	mov    (%rax),%rax
  8157a8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  8157ac:	eb 38                	jmp    8157e6 <udp_bind+0xf0>
      if (ipcb->local_port == port) {
  8157ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8157b2:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  8157b6:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  8157ba:	75 1e                	jne    8157da <udp_bind+0xe4>
        /* port is already used by another udp_pcb */
        port++;
  8157bc:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8157c0:	83 c0 01             	add    $0x1,%eax
  8157c3:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  8157c7:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8157ce:	00 00 00 
  8157d1:	48 8b 00             	mov    (%rax),%rax
  8157d4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8157d8:	eb 0c                	jmp    8157e6 <udp_bind+0xf0>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  8157da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8157de:	48 8b 40 10          	mov    0x10(%rax),%rax
  8157e2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  8157e6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8157eb:	74 08                	je     8157f5 <udp_bind+0xff>
  8157ed:	66 81 7d dc ff 7f    	cmpw   $0x7fff,-0x24(%rbp)
  8157f3:	75 b9                	jne    8157ae <udp_bind+0xb8>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  8157f5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8157fa:	74 07                	je     815803 <udp_bind+0x10d>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  8157fc:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  815801:	eb 3d                	jmp    815840 <udp_bind+0x14a>
    }
  }
  pcb->local_port = port;
  815803:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815807:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  81580b:	66 89 50 1a          	mov    %dx,0x1a(%rax)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  81580f:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  815813:	75 26                	jne    81583b <udp_bind+0x145>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  815815:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  81581c:	00 00 00 
  81581f:	48 8b 10             	mov    (%rax),%rdx
  815822:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815826:	48 89 50 10          	mov    %rdx,0x10(%rax)
    udp_pcbs = pcb;
  81582a:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815831:	00 00 00 
  815834:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  815838:	48 89 10             	mov    %rdx,(%rax)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  81583b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  815840:	c9                   	leaveq 
  815841:	c3                   	retq   

0000000000815842 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  815842:	55                   	push   %rbp
  815843:	48 89 e5             	mov    %rsp,%rbp
  815846:	48 83 ec 30          	sub    $0x30,%rsp
  81584a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81584e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  815852:	89 d0                	mov    %edx,%eax
  815854:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  815858:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81585c:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815860:	66 85 c0             	test   %ax,%ax
  815863:	75 37                	jne    81589c <udp_connect+0x5a>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  815865:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815869:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  81586d:	0f b7 d0             	movzwl %ax,%edx
  815870:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  815874:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815878:	48 89 ce             	mov    %rcx,%rsi
  81587b:	48 89 c7             	mov    %rax,%rdi
  81587e:	48 b8 f6 56 81 00 00 	movabs $0x8156f6,%rax
  815885:	00 00 00 
  815888:	ff d0                	callq  *%rax
  81588a:	88 45 f7             	mov    %al,-0x9(%rbp)
    if (err != ERR_OK)
  81588d:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  815891:	74 09                	je     81589c <udp_connect+0x5a>
      return err;
  815893:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  815897:	e9 9d 00 00 00       	jmpq   815939 <udp_connect+0xf7>
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  81589c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8158a1:	74 08                	je     8158ab <udp_connect+0x69>
  8158a3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8158a7:	8b 00                	mov    (%rax),%eax
  8158a9:	eb 05                	jmp    8158b0 <udp_connect+0x6e>
  8158ab:	b8 00 00 00 00       	mov    $0x0,%eax
  8158b0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8158b4:	89 42 04             	mov    %eax,0x4(%rdx)
  pcb->remote_port = port;
  8158b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8158bb:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  8158bf:	66 89 50 1c          	mov    %dx,0x1c(%rax)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  8158c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8158c7:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8158cb:	83 c8 04             	or     $0x4,%eax
  8158ce:	89 c2                	mov    %eax,%edx
  8158d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8158d4:	88 50 18             	mov    %dl,0x18(%rax)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8158d7:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8158de:	00 00 00 
  8158e1:	48 8b 00             	mov    (%rax),%rax
  8158e4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8158e8:	eb 1d                	jmp    815907 <udp_connect+0xc5>
    if (pcb == ipcb) {
  8158ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8158ee:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8158f2:	75 07                	jne    8158fb <udp_connect+0xb9>
      /* already on the list, just return */
      return ERR_OK;
  8158f4:	b8 00 00 00 00       	mov    $0x0,%eax
  8158f9:	eb 3e                	jmp    815939 <udp_connect+0xf7>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8158fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8158ff:	48 8b 40 10          	mov    0x10(%rax),%rax
  815903:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  815907:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81590c:	75 dc                	jne    8158ea <udp_connect+0xa8>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  81590e:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815915:	00 00 00 
  815918:	48 8b 10             	mov    (%rax),%rdx
  81591b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81591f:	48 89 50 10          	mov    %rdx,0x10(%rax)
  udp_pcbs = pcb;
  815923:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  81592a:	00 00 00 
  81592d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  815931:	48 89 10             	mov    %rdx,(%rax)
  return ERR_OK;
  815934:	b8 00 00 00 00       	mov    $0x0,%eax
}
  815939:	c9                   	leaveq 
  81593a:	c3                   	retq   

000000000081593b <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  81593b:	55                   	push   %rbp
  81593c:	48 89 e5             	mov    %rsp,%rbp
  81593f:	48 83 ec 08          	sub    $0x8,%rsp
  815943:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  815947:	48 b8 68 28 82 00 00 	movabs $0x822868,%rax
  81594e:	00 00 00 
  815951:	8b 10                	mov    (%rax),%edx
  815953:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815957:	89 50 04             	mov    %edx,0x4(%rax)
  pcb->remote_port = 0;
  81595a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81595e:	66 c7 40 1c 00 00    	movw   $0x0,0x1c(%rax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  815964:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815968:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81596c:	83 e0 fb             	and    $0xfffffffb,%eax
  81596f:	89 c2                	mov    %eax,%edx
  815971:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815975:	88 50 18             	mov    %dl,0x18(%rax)
}
  815978:	90                   	nop
  815979:	c9                   	leaveq 
  81597a:	c3                   	retq   

000000000081597b <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  81597b:	55                   	push   %rbp
  81597c:	48 89 e5             	mov    %rsp,%rbp
  81597f:	48 83 ec 18          	sub    $0x18,%rsp
  815983:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  815987:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  81598b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
  81598f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815993:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  815997:	48 89 50 20          	mov    %rdx,0x20(%rax)
  pcb->recv_arg = recv_arg;
  81599b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81599f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8159a3:	48 89 50 28          	mov    %rdx,0x28(%rax)
}
  8159a7:	90                   	nop
  8159a8:	c9                   	leaveq 
  8159a9:	c3                   	retq   

00000000008159aa <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  8159aa:	55                   	push   %rbp
  8159ab:	48 89 e5             	mov    %rsp,%rbp
  8159ae:	48 83 ec 20          	sub    $0x20,%rsp
  8159b2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  8159b6:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8159bd:	00 00 00 
  8159c0:	48 8b 00             	mov    (%rax),%rax
  8159c3:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8159c7:	75 20                	jne    8159e9 <udp_remove+0x3f>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  8159c9:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8159d0:	00 00 00 
  8159d3:	48 8b 00             	mov    (%rax),%rax
  8159d6:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8159da:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8159e1:	00 00 00 
  8159e4:	48 89 10             	mov    %rdx,(%rax)
  8159e7:	eb 51                	jmp    815a3a <udp_remove+0x90>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  8159e9:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8159f0:	00 00 00 
  8159f3:	48 8b 00             	mov    (%rax),%rax
  8159f6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8159fa:	eb 37                	jmp    815a33 <udp_remove+0x89>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  8159fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815a00:	48 8b 40 10          	mov    0x10(%rax),%rax
  815a04:	48 85 c0             	test   %rax,%rax
  815a07:	74 1e                	je     815a27 <udp_remove+0x7d>
  815a09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815a0d:	48 8b 40 10          	mov    0x10(%rax),%rax
  815a11:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  815a15:	75 10                	jne    815a27 <udp_remove+0x7d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  815a17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815a1b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  815a1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815a23:	48 89 50 10          	mov    %rdx,0x10(%rax)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  815a27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815a2b:	48 8b 40 10          	mov    0x10(%rax),%rax
  815a2f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  815a33:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815a38:	75 c2                	jne    8159fc <udp_remove+0x52>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  815a3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815a3e:	48 89 c6             	mov    %rax,%rsi
  815a41:	bf 01 00 00 00       	mov    $0x1,%edi
  815a46:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  815a4d:	00 00 00 
  815a50:	ff d0                	callq  *%rax
}
  815a52:	90                   	nop
  815a53:	c9                   	leaveq 
  815a54:	c3                   	retq   

0000000000815a55 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  815a55:	55                   	push   %rbp
  815a56:	48 89 e5             	mov    %rsp,%rbp
  815a59:	48 83 ec 10          	sub    $0x10,%rsp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  815a5d:	bf 01 00 00 00       	mov    $0x1,%edi
  815a62:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  815a69:	00 00 00 
  815a6c:	ff d0                	callq  *%rax
  815a6e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  815a72:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815a77:	74 25                	je     815a9e <udp_new+0x49>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  815a79:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815a7d:	ba 30 00 00 00       	mov    $0x30,%edx
  815a82:	be 00 00 00 00       	mov    $0x0,%esi
  815a87:	48 89 c7             	mov    %rax,%rdi
  815a8a:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  815a91:	00 00 00 
  815a94:	ff d0                	callq  *%rax
    pcb->ttl = UDP_TTL;
  815a96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815a9a:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
  }
  return pcb;
  815a9e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  815aa2:	c9                   	leaveq 
  815aa3:	c3                   	retq   

0000000000815aa4 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  815aa4:	55                   	push   %rbp
  815aa5:	48 89 e5             	mov    %rsp,%rbp
  815aa8:	48 83 ec 20          	sub    $0x20,%rsp
  815aac:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  815ab0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815ab5:	75 2a                	jne    815ae1 <free_etharp_q+0x3d>
  815ab7:	48 ba d4 2c 82 00 00 	movabs $0x822cd4,%rdx
  815abe:	00 00 00 
  815ac1:	be 94 00 00 00       	mov    $0x94,%esi
  815ac6:	48 bf de 2c 82 00 00 	movabs $0x822cde,%rdi
  815acd:	00 00 00 
  815ad0:	b8 00 00 00 00       	mov    $0x0,%eax
  815ad5:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  815adc:	00 00 00 
  815adf:	ff d1                	callq  *%rcx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  815ae1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815ae5:	48 8b 40 08          	mov    0x8(%rax),%rax
  815ae9:	48 85 c0             	test   %rax,%rax
  815aec:	0f 85 a3 00 00 00    	jne    815b95 <free_etharp_q+0xf1>
  815af2:	48 ba f6 2c 82 00 00 	movabs $0x822cf6,%rdx
  815af9:	00 00 00 
  815afc:	be 95 00 00 00       	mov    $0x95,%esi
  815b01:	48 bf de 2c 82 00 00 	movabs $0x822cde,%rdi
  815b08:	00 00 00 
  815b0b:	b8 00 00 00 00       	mov    $0x0,%eax
  815b10:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  815b17:	00 00 00 
  815b1a:	ff d1                	callq  *%rcx
  while (q) {
    r = q;
  815b1c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815b20:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    q = q->next;
  815b24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815b28:	48 8b 00             	mov    (%rax),%rax
  815b2b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  815b2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815b33:	48 8b 40 08          	mov    0x8(%rax),%rax
  815b37:	48 85 c0             	test   %rax,%rax
  815b3a:	75 2a                	jne    815b66 <free_etharp_q+0xc2>
  815b3c:	48 ba 03 2d 82 00 00 	movabs $0x822d03,%rdx
  815b43:	00 00 00 
  815b46:	be 99 00 00 00       	mov    $0x99,%esi
  815b4b:	48 bf de 2c 82 00 00 	movabs $0x822cde,%rdi
  815b52:	00 00 00 
  815b55:	b8 00 00 00 00       	mov    $0x0,%eax
  815b5a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  815b61:	00 00 00 
  815b64:	ff d1                	callq  *%rcx
    pbuf_free(r->p);
  815b66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815b6a:	48 8b 40 08          	mov    0x8(%rax),%rax
  815b6e:	48 89 c7             	mov    %rax,%rdi
  815b71:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  815b78:	00 00 00 
  815b7b:	ff d0                	callq  *%rax
    memp_free(MEMP_ARP_QUEUE, r);
  815b7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815b81:	48 89 c6             	mov    %rax,%rsi
  815b84:	bf 0a 00 00 00       	mov    $0xa,%edi
  815b89:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  815b90:	00 00 00 
  815b93:	ff d0                	callq  *%rax
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  815b95:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815b9a:	75 80                	jne    815b1c <free_etharp_q+0x78>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  815b9c:	90                   	nop
  815b9d:	c9                   	leaveq 
  815b9e:	c3                   	retq   

0000000000815b9f <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  815b9f:	55                   	push   %rbp
  815ba0:	48 89 e5             	mov    %rsp,%rbp
  815ba3:	48 83 ec 10          	sub    $0x10,%rsp
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815ba7:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  815bab:	e9 d8 01 00 00       	jmpq   815d88 <etharp_tmr+0x1e9>
    arp_table[i].ctime++;
  815bb0:	0f b6 55 ff          	movzbl -0x1(%rbp),%edx
  815bb4:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815bbb:	00 00 00 
  815bbe:	48 63 ca             	movslq %edx,%rcx
  815bc1:	48 89 c8             	mov    %rcx,%rax
  815bc4:	48 c1 e0 02          	shl    $0x2,%rax
  815bc8:	48 01 c8             	add    %rcx,%rax
  815bcb:	48 c1 e0 03          	shl    $0x3,%rax
  815bcf:	48 01 f0             	add    %rsi,%rax
  815bd2:	48 83 c0 18          	add    $0x18,%rax
  815bd6:	0f b6 00             	movzbl (%rax),%eax
  815bd9:	8d 48 01             	lea    0x1(%rax),%ecx
  815bdc:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815be3:	00 00 00 
  815be6:	48 63 d2             	movslq %edx,%rdx
  815be9:	48 89 d0             	mov    %rdx,%rax
  815bec:	48 c1 e0 02          	shl    $0x2,%rax
  815bf0:	48 01 d0             	add    %rdx,%rax
  815bf3:	48 c1 e0 03          	shl    $0x3,%rax
  815bf7:	48 01 f0             	add    %rsi,%rax
  815bfa:	48 83 c0 18          	add    $0x18,%rax
  815bfe:	88 08                	mov    %cl,(%rax)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  815c00:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815c04:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815c0b:	00 00 00 
  815c0e:	48 63 d0             	movslq %eax,%rdx
  815c11:	48 89 d0             	mov    %rdx,%rax
  815c14:	48 c1 e0 02          	shl    $0x2,%rax
  815c18:	48 01 d0             	add    %rdx,%rax
  815c1b:	48 c1 e0 03          	shl    $0x3,%rax
  815c1f:	48 01 c8             	add    %rcx,%rax
  815c22:	48 83 c0 14          	add    $0x14,%rax
  815c26:	8b 00                	mov    (%rax),%eax
  815c28:	83 f8 02             	cmp    $0x2,%eax
  815c2b:	75 2d                	jne    815c5a <etharp_tmr+0xbb>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  815c2d:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815c31:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815c38:	00 00 00 
  815c3b:	48 63 d0             	movslq %eax,%rdx
  815c3e:	48 89 d0             	mov    %rdx,%rax
  815c41:	48 c1 e0 02          	shl    $0x2,%rax
  815c45:	48 01 d0             	add    %rdx,%rax
  815c48:	48 c1 e0 03          	shl    $0x3,%rax
  815c4c:	48 01 c8             	add    %rcx,%rax
  815c4f:	48 83 c0 18          	add    $0x18,%rax
  815c53:	0f b6 00             	movzbl (%rax),%eax

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  815c56:	3c ef                	cmp    $0xef,%al
  815c58:	77 62                	ja     815cbc <etharp_tmr+0x11d>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  815c5a:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815c5e:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815c65:	00 00 00 
  815c68:	48 63 d0             	movslq %eax,%rdx
  815c6b:	48 89 d0             	mov    %rdx,%rax
  815c6e:	48 c1 e0 02          	shl    $0x2,%rax
  815c72:	48 01 d0             	add    %rdx,%rax
  815c75:	48 c1 e0 03          	shl    $0x3,%rax
  815c79:	48 01 c8             	add    %rcx,%rax
  815c7c:	48 83 c0 14          	add    $0x14,%rax
  815c80:	8b 00                	mov    (%rax),%eax
  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  815c82:	83 f8 01             	cmp    $0x1,%eax
  815c85:	0f 85 e4 00 00 00    	jne    815d6f <etharp_tmr+0x1d0>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
         (arp_table[i].ctime >= ARP_MAXPENDING))) {
  815c8b:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815c8f:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815c96:	00 00 00 
  815c99:	48 63 d0             	movslq %eax,%rdx
  815c9c:	48 89 d0             	mov    %rdx,%rax
  815c9f:	48 c1 e0 02          	shl    $0x2,%rax
  815ca3:	48 01 d0             	add    %rdx,%rax
  815ca6:	48 c1 e0 03          	shl    $0x3,%rax
  815caa:	48 01 c8             	add    %rcx,%rax
  815cad:	48 83 c0 18          	add    $0x18,%rax
  815cb1:	0f b6 00             	movzbl (%rax),%eax
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  815cb4:	3c 01                	cmp    $0x1,%al
  815cb6:	0f 86 b3 00 00 00    	jbe    815d6f <etharp_tmr+0x1d0>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  815cbc:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815cc0:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815cc7:	00 00 00 
  815cca:	48 63 d0             	movslq %eax,%rdx
  815ccd:	48 89 d0             	mov    %rdx,%rax
  815cd0:	48 c1 e0 02          	shl    $0x2,%rax
  815cd4:	48 01 d0             	add    %rdx,%rax
  815cd7:	48 c1 e0 03          	shl    $0x3,%rax
  815cdb:	48 01 c8             	add    %rcx,%rax
  815cde:	48 8b 00             	mov    (%rax),%rax
  815ce1:	48 85 c0             	test   %rax,%rax
  815ce4:	74 5d                	je     815d43 <etharp_tmr+0x1a4>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  815ce6:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815cea:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815cf1:	00 00 00 
  815cf4:	48 63 d0             	movslq %eax,%rdx
  815cf7:	48 89 d0             	mov    %rdx,%rax
  815cfa:	48 c1 e0 02          	shl    $0x2,%rax
  815cfe:	48 01 d0             	add    %rdx,%rax
  815d01:	48 c1 e0 03          	shl    $0x3,%rax
  815d05:	48 01 c8             	add    %rcx,%rax
  815d08:	48 8b 00             	mov    (%rax),%rax
  815d0b:	48 89 c7             	mov    %rax,%rdi
  815d0e:	48 b8 a4 5a 81 00 00 	movabs $0x815aa4,%rax
  815d15:	00 00 00 
  815d18:	ff d0                	callq  *%rax
        arp_table[i].q = NULL;
  815d1a:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815d1e:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815d25:	00 00 00 
  815d28:	48 63 d0             	movslq %eax,%rdx
  815d2b:	48 89 d0             	mov    %rdx,%rax
  815d2e:	48 c1 e0 02          	shl    $0x2,%rax
  815d32:	48 01 d0             	add    %rdx,%rax
  815d35:	48 c1 e0 03          	shl    $0x3,%rax
  815d39:	48 01 c8             	add    %rcx,%rax
  815d3c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  815d43:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815d47:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815d4e:	00 00 00 
  815d51:	48 63 d0             	movslq %eax,%rdx
  815d54:	48 89 d0             	mov    %rdx,%rax
  815d57:	48 c1 e0 02          	shl    $0x2,%rax
  815d5b:	48 01 d0             	add    %rdx,%rax
  815d5e:	48 c1 e0 03          	shl    $0x3,%rax
  815d62:	48 01 c8             	add    %rcx,%rax
  815d65:	48 83 c0 14          	add    $0x14,%rax
  815d69:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
    }
#if ARP_QUEUEING
    /* still pending entry? (not expired) */
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
  815d6f:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815d73:	48 63 d0             	movslq %eax,%rdx
  815d76:	48 89 d0             	mov    %rdx,%rax
  815d79:	48 c1 e0 02          	shl    $0x2,%rax
  815d7d:	48 01 d0             	add    %rdx,%rax
  815d80:	48 c1 e0 03          	shl    $0x3,%rax
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815d84:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
  815d88:	80 7d ff 09          	cmpb   $0x9,-0x1(%rbp)
  815d8c:	0f 86 1e fe ff ff    	jbe    815bb0 <etharp_tmr+0x11>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  815d92:	90                   	nop
  815d93:	c9                   	leaveq 
  815d94:	c3                   	retq   

0000000000815d95 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  815d95:	55                   	push   %rbp
  815d96:	48 89 e5             	mov    %rsp,%rbp
  815d99:	48 83 ec 20          	sub    $0x20,%rsp
  815d9d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  815da1:	89 f0                	mov    %esi,%eax
  815da3:	88 45 e4             	mov    %al,-0x1c(%rbp)
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  815da6:	c6 45 ff 0a          	movb   $0xa,-0x1(%rbp)
  815daa:	c6 45 fe 0a          	movb   $0xa,-0x2(%rbp)
  s8_t empty = ARP_TABLE_SIZE;
  815dae:	c6 45 fd 0a          	movb   $0xa,-0x3(%rbp)
  u8_t i = 0, age_pending = 0, age_stable = 0;
  815db2:	c6 45 fc 00          	movb   $0x0,-0x4(%rbp)
  815db6:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  815dba:	c6 45 fa 00          	movb   $0x0,-0x6(%rbp)
#if ARP_QUEUEING
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  815dbe:	c6 45 f9 0a          	movb   $0xa,-0x7(%rbp)
  /* its age */
  u8_t age_queue = 0;
  815dc2:	c6 45 f8 00          	movb   $0x0,-0x8(%rbp)
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  815dc6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815dcb:	0f 84 89 00 00 00    	je     815e5a <find_entry+0xc5>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  815dd1:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815dd8:	00 00 00 
  815ddb:	0f b6 00             	movzbl (%rax),%eax
  815dde:	0f b6 c0             	movzbl %al,%eax
  815de1:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815de8:	00 00 00 
  815deb:	48 63 d0             	movslq %eax,%rdx
  815dee:	48 89 d0             	mov    %rdx,%rax
  815df1:	48 c1 e0 02          	shl    $0x2,%rax
  815df5:	48 01 d0             	add    %rdx,%rax
  815df8:	48 c1 e0 03          	shl    $0x3,%rax
  815dfc:	48 01 c8             	add    %rcx,%rax
  815dff:	48 83 c0 14          	add    $0x14,%rax
  815e03:	8b 00                	mov    (%rax),%eax
  815e05:	83 f8 02             	cmp    $0x2,%eax
  815e08:	75 50                	jne    815e5a <find_entry+0xc5>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  815e0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815e0e:	8b 08                	mov    (%rax),%ecx
  815e10:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815e17:	00 00 00 
  815e1a:	0f b6 00             	movzbl (%rax),%eax
  815e1d:	0f b6 c0             	movzbl %al,%eax
  815e20:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815e27:	00 00 00 
  815e2a:	48 63 d0             	movslq %eax,%rdx
  815e2d:	48 89 d0             	mov    %rdx,%rax
  815e30:	48 c1 e0 02          	shl    $0x2,%rax
  815e34:	48 01 d0             	add    %rdx,%rax
  815e37:	48 c1 e0 03          	shl    $0x3,%rax
  815e3b:	48 01 f0             	add    %rsi,%rax
  815e3e:	48 83 c0 08          	add    $0x8,%rax
  815e42:	8b 00                	mov    (%rax),%eax
  815e44:	39 c1                	cmp    %eax,%ecx
  815e46:	75 12                	jne    815e5a <find_entry+0xc5>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  815e48:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815e4f:	00 00 00 
  815e52:	0f b6 00             	movzbl (%rax),%eax
  815e55:	e9 cd 04 00 00       	jmpq   816327 <find_entry+0x592>
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815e5a:	c6 45 fc 00          	movb   $0x0,-0x4(%rbp)
  815e5e:	e9 a7 02 00 00       	jmpq   81610a <find_entry+0x375>
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  815e63:	80 7d fd 0a          	cmpb   $0xa,-0x3(%rbp)
  815e67:	75 38                	jne    815ea1 <find_entry+0x10c>
  815e69:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815e6d:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815e74:	00 00 00 
  815e77:	48 63 d0             	movslq %eax,%rdx
  815e7a:	48 89 d0             	mov    %rdx,%rax
  815e7d:	48 c1 e0 02          	shl    $0x2,%rax
  815e81:	48 01 d0             	add    %rdx,%rax
  815e84:	48 c1 e0 03          	shl    $0x3,%rax
  815e88:	48 01 c8             	add    %rcx,%rax
  815e8b:	48 83 c0 14          	add    $0x14,%rax
  815e8f:	8b 00                	mov    (%rax),%eax
  815e91:	85 c0                	test   %eax,%eax
  815e93:	75 0c                	jne    815ea1 <find_entry+0x10c>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  815e95:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815e99:	88 45 fd             	mov    %al,-0x3(%rbp)
  815e9c:	e9 65 02 00 00       	jmpq   816106 <find_entry+0x371>
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  815ea1:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815ea5:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815eac:	00 00 00 
  815eaf:	48 63 d0             	movslq %eax,%rdx
  815eb2:	48 89 d0             	mov    %rdx,%rax
  815eb5:	48 c1 e0 02          	shl    $0x2,%rax
  815eb9:	48 01 d0             	add    %rdx,%rax
  815ebc:	48 c1 e0 03          	shl    $0x3,%rax
  815ec0:	48 01 c8             	add    %rcx,%rax
  815ec3:	48 83 c0 14          	add    $0x14,%rax
  815ec7:	8b 00                	mov    (%rax),%eax
  815ec9:	83 f8 01             	cmp    $0x1,%eax
  815ecc:	0f 85 50 01 00 00    	jne    816022 <find_entry+0x28d>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  815ed2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815ed7:	74 4b                	je     815f24 <find_entry+0x18f>
  815ed9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815edd:	8b 08                	mov    (%rax),%ecx
  815edf:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815ee3:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815eea:	00 00 00 
  815eed:	48 63 d0             	movslq %eax,%rdx
  815ef0:	48 89 d0             	mov    %rdx,%rax
  815ef3:	48 c1 e0 02          	shl    $0x2,%rax
  815ef7:	48 01 d0             	add    %rdx,%rax
  815efa:	48 c1 e0 03          	shl    $0x3,%rax
  815efe:	48 01 f0             	add    %rsi,%rax
  815f01:	48 83 c0 08          	add    $0x8,%rax
  815f05:	8b 00                	mov    (%rax),%eax
  815f07:	39 c1                	cmp    %eax,%ecx
  815f09:	75 19                	jne    815f24 <find_entry+0x18f>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  815f0b:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815f12:	00 00 00 
  815f15:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  815f19:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  815f1b:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815f1f:	e9 03 04 00 00       	jmpq   816327 <find_entry+0x592>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  815f24:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815f28:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815f2f:	00 00 00 
  815f32:	48 63 d0             	movslq %eax,%rdx
  815f35:	48 89 d0             	mov    %rdx,%rax
  815f38:	48 c1 e0 02          	shl    $0x2,%rax
  815f3c:	48 01 d0             	add    %rdx,%rax
  815f3f:	48 c1 e0 03          	shl    $0x3,%rax
  815f43:	48 01 c8             	add    %rcx,%rax
  815f46:	48 8b 00             	mov    (%rax),%rax
  815f49:	48 85 c0             	test   %rax,%rax
  815f4c:	74 6a                	je     815fb8 <find_entry+0x223>
        if (arp_table[i].ctime >= age_queue) {
  815f4e:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815f52:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815f59:	00 00 00 
  815f5c:	48 63 d0             	movslq %eax,%rdx
  815f5f:	48 89 d0             	mov    %rdx,%rax
  815f62:	48 c1 e0 02          	shl    $0x2,%rax
  815f66:	48 01 d0             	add    %rdx,%rax
  815f69:	48 c1 e0 03          	shl    $0x3,%rax
  815f6d:	48 01 c8             	add    %rcx,%rax
  815f70:	48 83 c0 18          	add    $0x18,%rax
  815f74:	0f b6 00             	movzbl (%rax),%eax
  815f77:	3a 45 f8             	cmp    -0x8(%rbp),%al
  815f7a:	0f 82 86 01 00 00    	jb     816106 <find_entry+0x371>
          old_queue = i;
  815f80:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815f84:	88 45 f9             	mov    %al,-0x7(%rbp)
          age_queue = arp_table[i].ctime;
  815f87:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815f8b:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815f92:	00 00 00 
  815f95:	48 63 d0             	movslq %eax,%rdx
  815f98:	48 89 d0             	mov    %rdx,%rax
  815f9b:	48 c1 e0 02          	shl    $0x2,%rax
  815f9f:	48 01 d0             	add    %rdx,%rax
  815fa2:	48 c1 e0 03          	shl    $0x3,%rax
  815fa6:	48 01 c8             	add    %rcx,%rax
  815fa9:	48 83 c0 18          	add    $0x18,%rax
  815fad:	0f b6 00             	movzbl (%rax),%eax
  815fb0:	88 45 f8             	mov    %al,-0x8(%rbp)
  815fb3:	e9 4e 01 00 00       	jmpq   816106 <find_entry+0x371>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  815fb8:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815fbc:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815fc3:	00 00 00 
  815fc6:	48 63 d0             	movslq %eax,%rdx
  815fc9:	48 89 d0             	mov    %rdx,%rax
  815fcc:	48 c1 e0 02          	shl    $0x2,%rax
  815fd0:	48 01 d0             	add    %rdx,%rax
  815fd3:	48 c1 e0 03          	shl    $0x3,%rax
  815fd7:	48 01 c8             	add    %rcx,%rax
  815fda:	48 83 c0 18          	add    $0x18,%rax
  815fde:	0f b6 00             	movzbl (%rax),%eax
  815fe1:	3a 45 fb             	cmp    -0x5(%rbp),%al
  815fe4:	0f 82 1c 01 00 00    	jb     816106 <find_entry+0x371>
          old_pending = i;
  815fea:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815fee:	88 45 ff             	mov    %al,-0x1(%rbp)
          age_pending = arp_table[i].ctime;
  815ff1:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815ff5:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815ffc:	00 00 00 
  815fff:	48 63 d0             	movslq %eax,%rdx
  816002:	48 89 d0             	mov    %rdx,%rax
  816005:	48 c1 e0 02          	shl    $0x2,%rax
  816009:	48 01 d0             	add    %rdx,%rax
  81600c:	48 c1 e0 03          	shl    $0x3,%rax
  816010:	48 01 c8             	add    %rcx,%rax
  816013:	48 83 c0 18          	add    $0x18,%rax
  816017:	0f b6 00             	movzbl (%rax),%eax
  81601a:	88 45 fb             	mov    %al,-0x5(%rbp)
  81601d:	e9 e4 00 00 00       	jmpq   816106 <find_entry+0x371>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  816022:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  816026:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81602d:	00 00 00 
  816030:	48 63 d0             	movslq %eax,%rdx
  816033:	48 89 d0             	mov    %rdx,%rax
  816036:	48 c1 e0 02          	shl    $0x2,%rax
  81603a:	48 01 d0             	add    %rdx,%rax
  81603d:	48 c1 e0 03          	shl    $0x3,%rax
  816041:	48 01 c8             	add    %rcx,%rax
  816044:	48 83 c0 14          	add    $0x14,%rax
  816048:	8b 00                	mov    (%rax),%eax
  81604a:	83 f8 02             	cmp    $0x2,%eax
  81604d:	0f 85 b3 00 00 00    	jne    816106 <find_entry+0x371>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  816053:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  816058:	74 4b                	je     8160a5 <find_entry+0x310>
  81605a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81605e:	8b 08                	mov    (%rax),%ecx
  816060:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  816064:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  81606b:	00 00 00 
  81606e:	48 63 d0             	movslq %eax,%rdx
  816071:	48 89 d0             	mov    %rdx,%rax
  816074:	48 c1 e0 02          	shl    $0x2,%rax
  816078:	48 01 d0             	add    %rdx,%rax
  81607b:	48 c1 e0 03          	shl    $0x3,%rax
  81607f:	48 01 f0             	add    %rsi,%rax
  816082:	48 83 c0 08          	add    $0x8,%rax
  816086:	8b 00                	mov    (%rax),%eax
  816088:	39 c1                	cmp    %eax,%ecx
  81608a:	75 19                	jne    8160a5 <find_entry+0x310>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  81608c:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  816093:	00 00 00 
  816096:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  81609a:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  81609c:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8160a0:	e9 82 02 00 00       	jmpq   816327 <find_entry+0x592>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  8160a5:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8160a9:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8160b0:	00 00 00 
  8160b3:	48 63 d0             	movslq %eax,%rdx
  8160b6:	48 89 d0             	mov    %rdx,%rax
  8160b9:	48 c1 e0 02          	shl    $0x2,%rax
  8160bd:	48 01 d0             	add    %rdx,%rax
  8160c0:	48 c1 e0 03          	shl    $0x3,%rax
  8160c4:	48 01 c8             	add    %rcx,%rax
  8160c7:	48 83 c0 18          	add    $0x18,%rax
  8160cb:	0f b6 00             	movzbl (%rax),%eax
  8160ce:	3a 45 fa             	cmp    -0x6(%rbp),%al
  8160d1:	72 33                	jb     816106 <find_entry+0x371>
        old_stable = i;
  8160d3:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8160d7:	88 45 fe             	mov    %al,-0x2(%rbp)
        age_stable = arp_table[i].ctime;
  8160da:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8160de:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8160e5:	00 00 00 
  8160e8:	48 63 d0             	movslq %eax,%rdx
  8160eb:	48 89 d0             	mov    %rdx,%rax
  8160ee:	48 c1 e0 02          	shl    $0x2,%rax
  8160f2:	48 01 d0             	add    %rdx,%rax
  8160f5:	48 c1 e0 03          	shl    $0x3,%rax
  8160f9:	48 01 c8             	add    %rcx,%rax
  8160fc:	48 83 c0 18          	add    $0x18,%rax
  816100:	0f b6 00             	movzbl (%rax),%eax
  816103:	88 45 fa             	mov    %al,-0x6(%rbp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  816106:	80 45 fc 01          	addb   $0x1,-0x4(%rbp)
  81610a:	80 7d fc 09          	cmpb   $0x9,-0x4(%rbp)
  81610e:	0f 86 4f fd ff ff    	jbe    815e63 <find_entry+0xce>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  816114:	80 7d fd 0a          	cmpb   $0xa,-0x3(%rbp)
  816118:	75 0b                	jne    816125 <find_entry+0x390>
  81611a:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
  81611e:	83 e0 01             	and    $0x1,%eax
  816121:	85 c0                	test   %eax,%eax
  816123:	74 0b                	je     816130 <find_entry+0x39b>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  816125:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
  816129:	83 e0 02             	and    $0x2,%eax
  81612c:	85 c0                	test   %eax,%eax
  81612e:	74 0a                	je     81613a <find_entry+0x3a5>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  816130:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  816135:	e9 ed 01 00 00       	jmpq   816327 <find_entry+0x592>
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  81613a:	80 7d fd 09          	cmpb   $0x9,-0x3(%rbp)
  81613e:	7f 0c                	jg     81614c <find_entry+0x3b7>
    i = empty;
  816140:	0f b6 45 fd          	movzbl -0x3(%rbp),%eax
  816144:	88 45 fc             	mov    %al,-0x4(%rbp)
  816147:	e9 ea 00 00 00       	jmpq   816236 <find_entry+0x4a1>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  81614c:	80 7d fe 09          	cmpb   $0x9,-0x2(%rbp)
  816150:	7f 5f                	jg     8161b1 <find_entry+0x41c>
    /* recycle oldest stable*/
    i = old_stable;
  816152:	0f b6 45 fe          	movzbl -0x2(%rbp),%eax
  816156:	88 45 fc             	mov    %al,-0x4(%rbp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  816159:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  81615d:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816164:	00 00 00 
  816167:	48 63 d0             	movslq %eax,%rdx
  81616a:	48 89 d0             	mov    %rdx,%rax
  81616d:	48 c1 e0 02          	shl    $0x2,%rax
  816171:	48 01 d0             	add    %rdx,%rax
  816174:	48 c1 e0 03          	shl    $0x3,%rax
  816178:	48 01 c8             	add    %rcx,%rax
  81617b:	48 8b 00             	mov    (%rax),%rax
  81617e:	48 85 c0             	test   %rax,%rax
  816181:	0f 84 af 00 00 00    	je     816236 <find_entry+0x4a1>
  816187:	48 ba 10 2d 82 00 00 	movabs $0x822d10,%rdx
  81618e:	00 00 00 
  816191:	be 76 01 00 00       	mov    $0x176,%esi
  816196:	48 bf de 2c 82 00 00 	movabs $0x822cde,%rdi
  81619d:	00 00 00 
  8161a0:	b8 00 00 00 00       	mov    $0x0,%eax
  8161a5:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8161ac:	00 00 00 
  8161af:	ff d1                	callq  *%rcx
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  8161b1:	80 7d ff 09          	cmpb   $0x9,-0x1(%rbp)
  8161b5:	7f 09                	jg     8161c0 <find_entry+0x42b>
    /* recycle oldest pending */
    i = old_pending;
  8161b7:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8161bb:	88 45 fc             	mov    %al,-0x4(%rbp)
  8161be:	eb 76                	jmp    816236 <find_entry+0x4a1>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  8161c0:	80 7d f9 09          	cmpb   $0x9,-0x7(%rbp)
  8161c4:	7f 66                	jg     81622c <find_entry+0x497>
    /* recycle oldest pending */
    i = old_queue;
  8161c6:	0f b6 45 f9          	movzbl -0x7(%rbp),%eax
  8161ca:	88 45 fc             	mov    %al,-0x4(%rbp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  8161cd:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8161d1:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8161d8:	00 00 00 
  8161db:	48 63 d0             	movslq %eax,%rdx
  8161de:	48 89 d0             	mov    %rdx,%rax
  8161e1:	48 c1 e0 02          	shl    $0x2,%rax
  8161e5:	48 01 d0             	add    %rdx,%rax
  8161e8:	48 c1 e0 03          	shl    $0x3,%rax
  8161ec:	48 01 c8             	add    %rcx,%rax
  8161ef:	48 8b 00             	mov    (%rax),%rax
  8161f2:	48 89 c7             	mov    %rax,%rdi
  8161f5:	48 b8 a4 5a 81 00 00 	movabs $0x815aa4,%rax
  8161fc:	00 00 00 
  8161ff:	ff d0                	callq  *%rax
    arp_table[i].q = NULL;
  816201:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  816205:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81620c:	00 00 00 
  81620f:	48 63 d0             	movslq %eax,%rdx
  816212:	48 89 d0             	mov    %rdx,%rax
  816215:	48 c1 e0 02          	shl    $0x2,%rax
  816219:	48 01 d0             	add    %rdx,%rax
  81621c:	48 c1 e0 03          	shl    $0x3,%rax
  816220:	48 01 c8             	add    %rcx,%rax
  816223:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  81622a:	eb 0a                	jmp    816236 <find_entry+0x4a1>
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  81622c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  816231:	e9 f1 00 00 00       	jmpq   816327 <find_entry+0x592>
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  816236:	80 7d fc 09          	cmpb   $0x9,-0x4(%rbp)
  81623a:	76 2a                	jbe    816266 <find_entry+0x4d1>
  81623c:	48 ba 27 2d 82 00 00 	movabs $0x822d27,%rdx
  816243:	00 00 00 
  816246:	be 8c 01 00 00       	mov    $0x18c,%esi
  81624b:	48 bf de 2c 82 00 00 	movabs $0x822cde,%rdi
  816252:	00 00 00 
  816255:	b8 00 00 00 00       	mov    $0x0,%eax
  81625a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  816261:	00 00 00 
  816264:	ff d1                	callq  *%rcx

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  816266:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  81626a:	48 63 d0             	movslq %eax,%rdx
  81626d:	48 89 d0             	mov    %rdx,%rax
  816270:	48 c1 e0 02          	shl    $0x2,%rax
  816274:	48 01 d0             	add    %rdx,%rax
  816277:	48 c1 e0 03          	shl    $0x3,%rax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  81627b:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  81627f:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816286:	00 00 00 
  816289:	48 63 d0             	movslq %eax,%rdx
  81628c:	48 89 d0             	mov    %rdx,%rax
  81628f:	48 c1 e0 02          	shl    $0x2,%rax
  816293:	48 01 d0             	add    %rdx,%rax
  816296:	48 c1 e0 03          	shl    $0x3,%rax
  81629a:	48 01 c8             	add    %rcx,%rax
  81629d:	48 83 c0 14          	add    $0x14,%rax
  8162a1:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

  /* IP address given? */
  if (ipaddr != NULL) {
  8162a7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8162ac:	74 3c                	je     8162ea <find_entry+0x555>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  8162ae:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  8162b2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8162b7:	74 08                	je     8162c1 <find_entry+0x52c>
  8162b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8162bd:	8b 08                	mov    (%rax),%ecx
  8162bf:	eb 05                	jmp    8162c6 <find_entry+0x531>
  8162c1:	b9 00 00 00 00       	mov    $0x0,%ecx
  8162c6:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  8162cd:	00 00 00 
  8162d0:	48 63 d2             	movslq %edx,%rdx
  8162d3:	48 89 d0             	mov    %rdx,%rax
  8162d6:	48 c1 e0 02          	shl    $0x2,%rax
  8162da:	48 01 d0             	add    %rdx,%rax
  8162dd:	48 c1 e0 03          	shl    $0x3,%rax
  8162e1:	48 01 f0             	add    %rsi,%rax
  8162e4:	48 83 c0 08          	add    $0x8,%rax
  8162e8:	89 08                	mov    %ecx,(%rax)
  }
  arp_table[i].ctime = 0;
  8162ea:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8162ee:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8162f5:	00 00 00 
  8162f8:	48 63 d0             	movslq %eax,%rdx
  8162fb:	48 89 d0             	mov    %rdx,%rax
  8162fe:	48 c1 e0 02          	shl    $0x2,%rax
  816302:	48 01 d0             	add    %rdx,%rax
  816305:	48 c1 e0 03          	shl    $0x3,%rax
  816309:	48 01 c8             	add    %rcx,%rax
  81630c:	48 83 c0 18          	add    $0x18,%rax
  816310:	c6 00 00             	movb   $0x0,(%rax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  816313:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  81631a:	00 00 00 
  81631d:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  816321:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  816323:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
}
  816327:	c9                   	leaveq 
  816328:	c3                   	retq   

0000000000816329 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  816329:	55                   	push   %rbp
  81632a:	48 89 e5             	mov    %rsp,%rbp
  81632d:	48 83 ec 30          	sub    $0x30,%rsp
  816331:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  816335:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  816339:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81633d:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  struct eth_hdr *ethhdr = p->payload;
  816341:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816345:	48 8b 40 08          	mov    0x8(%rax),%rax
  816349:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  81634d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816351:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  816355:	3c 06                	cmp    $0x6,%al
  816357:	74 2a                	je     816383 <etharp_send_ip+0x5a>
  816359:	48 ba 40 2d 82 00 00 	movabs $0x822d40,%rdx
  816360:	00 00 00 
  816363:	be b4 01 00 00       	mov    $0x1b4,%esi
  816368:	48 bf de 2c 82 00 00 	movabs $0x822cde,%rdi
  81636f:	00 00 00 
  816372:	b8 00 00 00 00       	mov    $0x0,%eax
  816377:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81637e:	00 00 00 
  816381:	ff d1                	callq  *%rcx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  816383:	c6 45 ff 06          	movb   $0x6,-0x1(%rbp)
  while(k > 0) {
  816387:	eb 43                	jmp    8163cc <etharp_send_ip+0xa3>
    k--;
  816389:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81638d:	83 e8 01             	sub    $0x1,%eax
  816390:	88 45 ff             	mov    %al,-0x1(%rbp)
    ethhdr->dest.addr[k] = dst->addr[k];
  816393:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  816397:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81639b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81639f:	48 98                	cltq   
  8163a1:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8163a5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8163a9:	48 63 c6             	movslq %esi,%rax
  8163ac:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  8163af:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  8163b3:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8163b7:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8163bb:	48 98                	cltq   
  8163bd:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8163c1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8163c5:	48 63 c6             	movslq %esi,%rax
  8163c8:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  8163cc:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  8163d0:	75 b7                	jne    816389 <etharp_send_ip+0x60>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  8163d2:	bf 00 08 00 00       	mov    $0x800,%edi
  8163d7:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  8163de:	00 00 00 
  8163e1:	ff d0                	callq  *%rax
  8163e3:	89 c2                	mov    %eax,%edx
  8163e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8163e9:	66 89 50 0c          	mov    %dx,0xc(%rax)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  8163ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8163f1:	48 8b 40 28          	mov    0x28(%rax),%rax
  8163f5:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8163f9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8163fd:	48 89 ce             	mov    %rcx,%rsi
  816400:	48 89 d7             	mov    %rdx,%rdi
  816403:	ff d0                	callq  *%rax
}
  816405:	c9                   	leaveq 
  816406:	c3                   	retq   

0000000000816407 <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  816407:	55                   	push   %rbp
  816408:	48 89 e5             	mov    %rsp,%rbp
  81640b:	53                   	push   %rbx
  81640c:	48 83 ec 48          	sub    $0x48,%rsp
  816410:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  816414:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  816418:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  81641c:	89 c8                	mov    %ecx,%eax
  81641e:	88 45 b4             	mov    %al,-0x4c(%rbp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  816421:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816425:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  816429:	3c 06                	cmp    $0x6,%al
  81642b:	74 2a                	je     816457 <update_arp_entry+0x50>
  81642d:	48 ba 88 2d 82 00 00 	movabs $0x822d88,%rdx
  816434:	00 00 00 
  816437:	be da 01 00 00       	mov    $0x1da,%esi
  81643c:	48 bf de 2c 82 00 00 	movabs $0x822cde,%rdi
  816443:	00 00 00 
  816446:	b8 00 00 00 00       	mov    $0x0,%eax
  81644b:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  816452:	00 00 00 
  816455:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  816457:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  81645c:	74 56                	je     8164b4 <update_arp_entry+0xad>
  81645e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  816462:	8b 00                	mov    (%rax),%eax
  816464:	85 c0                	test   %eax,%eax
  816466:	74 4c                	je     8164b4 <update_arp_entry+0xad>
      ip_addr_isbroadcast(ipaddr, netif) ||
  816468:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81646c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  816470:	48 89 d6             	mov    %rdx,%rsi
  816473:	48 89 c7             	mov    %rax,%rdi
  816476:	48 b8 70 0d 81 00 00 	movabs $0x810d70,%rax
  81647d:	00 00 00 
  816480:	ff d0                	callq  *%rax
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  816482:	84 c0                	test   %al,%al
  816484:	75 2e                	jne    8164b4 <update_arp_entry+0xad>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  816486:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81648a:	8b 18                	mov    (%rax),%ebx
  81648c:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  816491:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  816498:	00 00 00 
  81649b:	ff d0                	callq  *%rax
  81649d:	21 c3                	and    %eax,%ebx
  81649f:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  8164a4:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  8164ab:	00 00 00 
  8164ae:	ff d0                	callq  *%rax
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
  8164b0:	39 c3                	cmp    %eax,%ebx
  8164b2:	75 0a                	jne    8164be <update_arp_entry+0xb7>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  8164b4:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8164b9:	e9 f1 01 00 00       	jmpq   8166af <update_arp_entry+0x2a8>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  8164be:	0f b6 55 b4          	movzbl -0x4c(%rbp),%edx
  8164c2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8164c6:	89 d6                	mov    %edx,%esi
  8164c8:	48 89 c7             	mov    %rax,%rdi
  8164cb:	48 b8 95 5d 81 00 00 	movabs $0x815d95,%rax
  8164d2:	00 00 00 
  8164d5:	ff d0                	callq  *%rax
  8164d7:	88 45 ee             	mov    %al,-0x12(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  8164da:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  8164de:	79 09                	jns    8164e9 <update_arp_entry+0xe2>
    return (err_t)i;
  8164e0:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  8164e4:	e9 c6 01 00 00       	jmpq   8166af <update_arp_entry+0x2a8>
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  8164e9:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  8164ed:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8164f4:	00 00 00 
  8164f7:	48 63 d0             	movslq %eax,%rdx
  8164fa:	48 89 d0             	mov    %rdx,%rax
  8164fd:	48 c1 e0 02          	shl    $0x2,%rax
  816501:	48 01 d0             	add    %rdx,%rax
  816504:	48 c1 e0 03          	shl    $0x3,%rax
  816508:	48 01 c8             	add    %rcx,%rax
  81650b:	48 83 c0 14          	add    $0x14,%rax
  81650f:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
  /* record network interface */
  arp_table[i].netif = netif;
  816515:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  816519:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816520:	00 00 00 
  816523:	48 63 d0             	movslq %eax,%rdx
  816526:	48 89 d0             	mov    %rdx,%rax
  816529:	48 c1 e0 02          	shl    $0x2,%rax
  81652d:	48 01 d0             	add    %rdx,%rax
  816530:	48 c1 e0 03          	shl    $0x3,%rax
  816534:	48 01 c8             	add    %rcx,%rax
  816537:	48 8d 50 20          	lea    0x20(%rax),%rdx
  81653b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81653f:	48 89 02             	mov    %rax,(%rdx)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  816542:	c6 45 ef 06          	movb   $0x6,-0x11(%rbp)
  while (k > 0) {
  816546:	eb 4b                	jmp    816593 <update_arp_entry+0x18c>
    k--;
  816548:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81654c:	83 e8 01             	sub    $0x1,%eax
  81654f:	88 45 ef             	mov    %al,-0x11(%rbp)
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  816552:	44 0f be 45 ee       	movsbl -0x12(%rbp),%r8d
  816557:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  81655b:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81655f:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  816563:	48 98                	cltq   
  816565:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816569:	48 bf 80 b6 b4 00 00 	movabs $0xb4b680,%rdi
  816570:	00 00 00 
  816573:	48 63 f6             	movslq %esi,%rsi
  816576:	49 63 d0             	movslq %r8d,%rdx
  816579:	48 89 d0             	mov    %rdx,%rax
  81657c:	48 c1 e0 02          	shl    $0x2,%rax
  816580:	48 01 d0             	add    %rdx,%rax
  816583:	48 c1 e0 03          	shl    $0x3,%rax
  816587:	48 01 f8             	add    %rdi,%rax
  81658a:	48 01 f0             	add    %rsi,%rax
  81658d:	48 83 c0 0c          	add    $0xc,%rax
  816591:	88 08                	mov    %cl,(%rax)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
  816593:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  816597:	75 af                	jne    816548 <update_arp_entry+0x141>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  816599:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  81659d:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8165a4:	00 00 00 
  8165a7:	48 63 d0             	movslq %eax,%rdx
  8165aa:	48 89 d0             	mov    %rdx,%rax
  8165ad:	48 c1 e0 02          	shl    $0x2,%rax
  8165b1:	48 01 d0             	add    %rdx,%rax
  8165b4:	48 c1 e0 03          	shl    $0x3,%rax
  8165b8:	48 01 c8             	add    %rcx,%rax
  8165bb:	48 83 c0 18          	add    $0x18,%rax
  8165bf:	c6 00 00             	movb   $0x0,(%rax)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  8165c2:	e9 b5 00 00 00       	jmpq   81667c <update_arp_entry+0x275>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
  8165c7:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  8165cb:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8165d2:	00 00 00 
  8165d5:	48 63 d0             	movslq %eax,%rdx
  8165d8:	48 89 d0             	mov    %rdx,%rax
  8165db:	48 c1 e0 02          	shl    $0x2,%rax
  8165df:	48 01 d0             	add    %rdx,%rax
  8165e2:	48 c1 e0 03          	shl    $0x3,%rax
  8165e6:	48 01 c8             	add    %rcx,%rax
  8165e9:	48 8b 00             	mov    (%rax),%rax
  8165ec:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  8165f0:	0f be 55 ee          	movsbl -0x12(%rbp),%edx
  8165f4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8165f8:	48 8b 08             	mov    (%rax),%rcx
  8165fb:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  816602:	00 00 00 
  816605:	48 63 d2             	movslq %edx,%rdx
  816608:	48 89 d0             	mov    %rdx,%rax
  81660b:	48 c1 e0 02          	shl    $0x2,%rax
  81660f:	48 01 d0             	add    %rdx,%rax
  816612:	48 c1 e0 03          	shl    $0x3,%rax
  816616:	48 01 f0             	add    %rsi,%rax
  816619:	48 89 08             	mov    %rcx,(%rax)
    /* get the packet pointer */
    p = q->p;
  81661c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816620:	48 8b 40 08          	mov    0x8(%rax),%rax
  816624:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  816628:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81662c:	48 89 c6             	mov    %rax,%rsi
  81662f:	bf 0a 00 00 00       	mov    $0xa,%edi
  816634:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  81663b:	00 00 00 
  81663e:	ff d0                	callq  *%rax
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  816640:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816644:	48 8d 78 41          	lea    0x41(%rax),%rdi
  816648:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  81664c:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  816650:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816654:	48 89 d1             	mov    %rdx,%rcx
  816657:	48 89 fa             	mov    %rdi,%rdx
  81665a:	48 89 c7             	mov    %rax,%rdi
  81665d:	48 b8 29 63 81 00 00 	movabs $0x816329,%rax
  816664:	00 00 00 
  816667:	ff d0                	callq  *%rax
    /* free the queued IP packet */
    pbuf_free(p);
  816669:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81666d:	48 89 c7             	mov    %rax,%rdi
  816670:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  816677:	00 00 00 
  81667a:	ff d0                	callq  *%rax
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  81667c:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  816680:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816687:	00 00 00 
  81668a:	48 63 d0             	movslq %eax,%rdx
  81668d:	48 89 d0             	mov    %rdx,%rax
  816690:	48 c1 e0 02          	shl    $0x2,%rax
  816694:	48 01 d0             	add    %rdx,%rax
  816697:	48 c1 e0 03          	shl    $0x3,%rax
  81669b:	48 01 c8             	add    %rcx,%rax
  81669e:	48 8b 00             	mov    (%rax),%rax
  8166a1:	48 85 c0             	test   %rax,%rax
  8166a4:	0f 85 1d ff ff ff    	jne    8165c7 <update_arp_entry+0x1c0>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
  8166aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8166af:	48 83 c4 48          	add    $0x48,%rsp
  8166b3:	5b                   	pop    %rbx
  8166b4:	5d                   	pop    %rbp
  8166b5:	c3                   	retq   

00000000008166b6 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  8166b6:	55                   	push   %rbp
  8166b7:	48 89 e5             	mov    %rsp,%rbp
  8166ba:	48 83 ec 30          	sub    $0x30,%rsp
  8166be:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8166c2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8166c6:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8166ca:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  8166ce:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8166d2:	be 02 00 00 00       	mov    $0x2,%esi
  8166d7:	48 89 c7             	mov    %rax,%rdi
  8166da:	48 b8 95 5d 81 00 00 	movabs $0x815d95,%rax
  8166e1:	00 00 00 
  8166e4:	ff d0                	callq  *%rax
  8166e6:	88 45 ff             	mov    %al,-0x1(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  8166e9:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  8166ed:	0f 88 8d 00 00 00    	js     816780 <etharp_find_addr+0xca>
  8166f3:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  8166f7:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8166fe:	00 00 00 
  816701:	48 63 d0             	movslq %eax,%rdx
  816704:	48 89 d0             	mov    %rdx,%rax
  816707:	48 c1 e0 02          	shl    $0x2,%rax
  81670b:	48 01 d0             	add    %rdx,%rax
  81670e:	48 c1 e0 03          	shl    $0x3,%rax
  816712:	48 01 c8             	add    %rcx,%rax
  816715:	48 83 c0 14          	add    $0x14,%rax
  816719:	8b 00                	mov    (%rax),%eax
  81671b:	83 f8 02             	cmp    $0x2,%eax
  81671e:	75 60                	jne    816780 <etharp_find_addr+0xca>
      *eth_ret = &arp_table[i].ethaddr;
  816720:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  816724:	48 63 d0             	movslq %eax,%rdx
  816727:	48 89 d0             	mov    %rdx,%rax
  81672a:	48 c1 e0 02          	shl    $0x2,%rax
  81672e:	48 01 d0             	add    %rdx,%rax
  816731:	48 c1 e0 03          	shl    $0x3,%rax
  816735:	48 ba 80 b6 b4 00 00 	movabs $0xb4b680,%rdx
  81673c:	00 00 00 
  81673f:	48 01 d0             	add    %rdx,%rax
  816742:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  816746:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81674a:	48 89 10             	mov    %rdx,(%rax)
      *ip_ret = &arp_table[i].ipaddr;
  81674d:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  816751:	48 63 d0             	movslq %eax,%rdx
  816754:	48 89 d0             	mov    %rdx,%rax
  816757:	48 c1 e0 02          	shl    $0x2,%rax
  81675b:	48 01 d0             	add    %rdx,%rax
  81675e:	48 c1 e0 03          	shl    $0x3,%rax
  816762:	48 ba 80 b6 b4 00 00 	movabs $0xb4b680,%rdx
  816769:	00 00 00 
  81676c:	48 01 d0             	add    %rdx,%rax
  81676f:	48 8d 50 08          	lea    0x8(%rax),%rdx
  816773:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816777:	48 89 10             	mov    %rdx,(%rax)
      return i;
  81677a:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81677e:	eb 05                	jmp    816785 <etharp_find_addr+0xcf>
  }
  return -1;
  816780:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  816785:	c9                   	leaveq 
  816786:	c3                   	retq   

0000000000816787 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  816787:	55                   	push   %rbp
  816788:	48 89 e5             	mov    %rsp,%rbp
  81678b:	48 83 ec 20          	sub    $0x20,%rsp
  81678f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  816793:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  816797:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81679c:	75 2a                	jne    8167c8 <etharp_ip_input+0x41>
  81679e:	48 ba af 2d 82 00 00 	movabs $0x822daf,%rdx
  8167a5:	00 00 00 
  8167a8:	be 49 02 00 00       	mov    $0x249,%esi
  8167ad:	48 bf de 2c 82 00 00 	movabs $0x822cde,%rdi
  8167b4:	00 00 00 
  8167b7:	b8 00 00 00 00       	mov    $0x0,%eax
  8167bc:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8167c3:	00 00 00 
  8167c6:	ff d1                	callq  *%rcx
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  8167c8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8167cc:	48 8b 40 08          	mov    0x8(%rax),%rax
  8167d0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  8167d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8167d8:	8b 50 1c             	mov    0x1c(%rax),%edx
  8167db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8167df:	8b 40 08             	mov    0x8(%rax),%eax
  8167e2:	31 c2                	xor    %eax,%edx
  8167e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8167e8:	8b 40 0c             	mov    0xc(%rax),%eax
  8167eb:	21 d0                	and    %edx,%eax
  8167ed:	85 c0                	test   %eax,%eax
  8167ef:	75 2a                	jne    81681b <etharp_ip_input+0x94>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  8167f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8167f5:	48 8d 50 06          	lea    0x6(%rax),%rdx
  8167f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8167fd:	48 8d 70 1c          	lea    0x1c(%rax),%rsi
  816801:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816805:	b9 00 00 00 00       	mov    $0x0,%ecx
  81680a:	48 89 c7             	mov    %rax,%rdi
  81680d:	48 b8 07 64 81 00 00 	movabs $0x816407,%rax
  816814:	00 00 00 
  816817:	ff d0                	callq  *%rax
  816819:	eb 01                	jmp    81681c <etharp_ip_input+0x95>
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
    /* do nothing */
    return;
  81681b:	90                   	nop
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
}
  81681c:	c9                   	leaveq 
  81681d:	c3                   	retq   

000000000081681e <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  81681e:	55                   	push   %rbp
  81681f:	48 89 e5             	mov    %rsp,%rbp
  816822:	53                   	push   %rbx
  816823:	48 83 ec 58          	sub    $0x58,%rsp
  816827:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  81682b:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  81682f:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  816833:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  816838:	75 2a                	jne    816864 <etharp_arp_input+0x46>
  81683a:	48 ba af 2d 82 00 00 	movabs $0x822daf,%rdx
  816841:	00 00 00 
  816844:	be 76 02 00 00       	mov    $0x276,%esi
  816849:	48 bf de 2c 82 00 00 	movabs $0x822cde,%rdi
  816850:	00 00 00 
  816853:	b8 00 00 00 00       	mov    $0x0,%eax
  816858:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81685f:	00 00 00 
  816862:	ff d1                	callq  *%rcx
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  816864:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816868:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81686c:	66 83 f8 29          	cmp    $0x29,%ax
  816870:	77 18                	ja     81688a <etharp_arp_input+0x6c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  816872:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816876:	48 89 c7             	mov    %rax,%rdi
  816879:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  816880:	00 00 00 
  816883:	ff d0                	callq  *%rax
    return;
  816885:	e9 d7 02 00 00       	jmpq   816b61 <etharp_arp_input+0x343>
  }

  hdr = p->payload;
  81688a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81688e:	48 8b 40 08          	mov    0x8(%rax),%rax
  816892:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  816896:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81689a:	0f b7 58 0e          	movzwl 0xe(%rax),%ebx
  81689e:	bf 01 00 00 00       	mov    $0x1,%edi
  8168a3:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  8168aa:	00 00 00 
  8168ad:	ff d0                	callq  *%rax
  8168af:	66 39 c3             	cmp    %ax,%bx
  8168b2:	75 5a                	jne    81690e <etharp_arp_input+0xf0>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  8168b4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8168b8:	0f b7 58 12          	movzwl 0x12(%rax),%ebx
  8168bc:	bf 04 06 00 00       	mov    $0x604,%edi
  8168c1:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  8168c8:	00 00 00 
  8168cb:	ff d0                	callq  *%rax
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8168cd:	66 39 c3             	cmp    %ax,%bx
  8168d0:	75 3c                	jne    81690e <etharp_arp_input+0xf0>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  8168d2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8168d6:	0f b7 58 10          	movzwl 0x10(%rax),%ebx
  8168da:	bf 00 08 00 00       	mov    $0x800,%edi
  8168df:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  8168e6:	00 00 00 
  8168e9:	ff d0                	callq  *%rax

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  8168eb:	66 39 c3             	cmp    %ax,%bx
  8168ee:	75 1e                	jne    81690e <etharp_arp_input+0xf0>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  8168f0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8168f4:	0f b7 58 0c          	movzwl 0xc(%rax),%ebx
  8168f8:	bf 06 08 00 00       	mov    $0x806,%edi
  8168fd:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  816904:	00 00 00 
  816907:	ff d0                	callq  *%rax
  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  816909:	66 39 c3             	cmp    %ax,%bx
  81690c:	74 18                	je     816926 <etharp_arp_input+0x108>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  81690e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816912:	48 89 c7             	mov    %rax,%rdi
  816915:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81691c:	00 00 00 
  81691f:	ff d0                	callq  *%rax
    return;
  816921:	e9 3b 02 00 00       	jmpq   816b61 <etharp_arp_input+0x343>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  816926:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81692a:	48 8d 48 1c          	lea    0x1c(%rax),%rcx
  81692e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  816932:	ba 04 00 00 00       	mov    $0x4,%edx
  816937:	48 89 ce             	mov    %rcx,%rsi
  81693a:	48 89 c7             	mov    %rax,%rdi
  81693d:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  816944:	00 00 00 
  816947:	ff d0                	callq  *%rax
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  816949:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81694d:	48 8d 48 26          	lea    0x26(%rax),%rcx
  816951:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  816955:	ba 04 00 00 00       	mov    $0x4,%edx
  81695a:	48 89 ce             	mov    %rcx,%rsi
  81695d:	48 89 c7             	mov    %rax,%rdi
  816960:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  816967:	00 00 00 
  81696a:	ff d0                	callq  *%rax

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  81696c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816970:	8b 40 08             	mov    0x8(%rax),%eax
  816973:	85 c0                	test   %eax,%eax
  816975:	75 06                	jne    81697d <etharp_arp_input+0x15f>
    for_us = 0;
  816977:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)
  81697b:	eb 12                	jmp    81698f <etharp_arp_input+0x171>
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  81697d:	8b 55 c0             	mov    -0x40(%rbp),%edx
  816980:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816984:	8b 40 08             	mov    0x8(%rax),%eax
  816987:	39 c2                	cmp    %eax,%edx
  816989:	0f 94 c0             	sete   %al
  81698c:	88 45 ee             	mov    %al,-0x12(%rbp)
  }

  /* ARP message directed to us? */
  if (for_us) {
  81698f:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  816993:	74 26                	je     8169bb <etharp_arp_input+0x19d>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  816995:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816999:	48 8d 50 16          	lea    0x16(%rax),%rdx
  81699d:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8169a1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8169a5:	b9 01 00 00 00       	mov    $0x1,%ecx
  8169aa:	48 89 c7             	mov    %rax,%rdi
  8169ad:	48 b8 07 64 81 00 00 	movabs $0x816407,%rax
  8169b4:	00 00 00 
  8169b7:	ff d0                	callq  *%rax
  8169b9:	eb 24                	jmp    8169df <etharp_arp_input+0x1c1>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  8169bb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8169bf:	48 8d 50 16          	lea    0x16(%rax),%rdx
  8169c3:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8169c7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8169cb:	b9 00 00 00 00       	mov    $0x0,%ecx
  8169d0:	48 89 c7             	mov    %rax,%rdi
  8169d3:	48 b8 07 64 81 00 00 	movabs $0x816407,%rax
  8169da:	00 00 00 
  8169dd:	ff d0                	callq  *%rax
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  8169df:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8169e3:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  8169e7:	0f b7 c0             	movzwl %ax,%eax
  8169ea:	89 c7                	mov    %eax,%edi
  8169ec:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  8169f3:	00 00 00 
  8169f6:	ff d0                	callq  *%rax
  8169f8:	0f b7 c0             	movzwl %ax,%eax
  8169fb:	83 f8 01             	cmp    $0x1,%eax
  8169fe:	74 0e                	je     816a0e <etharp_arp_input+0x1f0>
  816a00:	83 f8 02             	cmp    $0x2,%eax
  816a03:	0f 84 28 01 00 00    	je     816b31 <etharp_arp_input+0x313>
#endif
    break;
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  816a09:	e9 40 01 00 00       	jmpq   816b4e <etharp_arp_input+0x330>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  816a0e:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  816a12:	0f 84 35 01 00 00    	je     816b4d <etharp_arp_input+0x32f>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  816a18:	bf 02 00 00 00       	mov    $0x2,%edi
  816a1d:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  816a24:	00 00 00 
  816a27:	ff d0                	callq  *%rax
  816a29:	89 c2                	mov    %eax,%edx
  816a2b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816a2f:	66 89 50 14          	mov    %dx,0x14(%rax)

      hdr->dipaddr = hdr->sipaddr;
  816a33:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816a37:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816a3b:	8b 52 1c             	mov    0x1c(%rdx),%edx
  816a3e:	89 50 26             	mov    %edx,0x26(%rax)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  816a41:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816a45:	48 8d 50 08          	lea    0x8(%rax),%rdx
  816a49:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816a4d:	8b 12                	mov    (%rdx),%edx
  816a4f:	89 50 1c             	mov    %edx,0x1c(%rax)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  816a52:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816a56:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  816a5a:	3c 06                	cmp    $0x6,%al
  816a5c:	74 2a                	je     816a88 <etharp_arp_input+0x26a>
  816a5e:	48 ba 40 2d 82 00 00 	movabs $0x822d40,%rdx
  816a65:	00 00 00 
  816a68:	be c8 02 00 00       	mov    $0x2c8,%esi
  816a6d:	48 bf de 2c 82 00 00 	movabs $0x822cde,%rdi
  816a74:	00 00 00 
  816a77:	b8 00 00 00 00       	mov    $0x0,%eax
  816a7c:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  816a83:	00 00 00 
  816a86:	ff d1                	callq  *%rcx
                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
      i = ETHARP_HWADDR_LEN;
  816a88:	c6 45 ef 06          	movb   $0x6,-0x11(%rbp)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  816a8c:	eb 7f                	jmp    816b0d <etharp_arp_input+0x2ef>
        i--;
  816a8e:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816a92:	83 e8 01             	sub    $0x1,%eax
  816a95:	88 45 ef             	mov    %al,-0x11(%rbp)
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  816a98:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  816a9c:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816aa0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816aa4:	48 98                	cltq   
  816aa6:	0f b6 4c 02 16       	movzbl 0x16(%rdx,%rax,1),%ecx
  816aab:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816aaf:	48 63 c6             	movslq %esi,%rax
  816ab2:	88 4c 02 20          	mov    %cl,0x20(%rdx,%rax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  816ab6:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  816aba:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816abe:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816ac2:	48 98                	cltq   
  816ac4:	0f b6 4c 02 16       	movzbl 0x16(%rdx,%rax,1),%ecx
  816ac9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816acd:	48 63 c6             	movslq %esi,%rax
  816ad0:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  816ad3:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  816ad7:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816adb:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  816adf:	48 98                	cltq   
  816ae1:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816ae5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816ae9:	48 63 c6             	movslq %esi,%rax
  816aec:	88 4c 02 16          	mov    %cl,0x16(%rdx,%rax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  816af0:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  816af4:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816af8:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  816afc:	48 98                	cltq   
  816afe:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816b02:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816b06:	48 63 c6             	movslq %esi,%rax
  816b09:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  816b0d:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  816b11:	0f 85 77 ff ff ff    	jne    816a8e <etharp_arp_input+0x270>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  816b17:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816b1b:	48 8b 40 28          	mov    0x28(%rax),%rax
  816b1f:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  816b23:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  816b27:	48 89 ce             	mov    %rcx,%rsi
  816b2a:	48 89 d7             	mov    %rdx,%rdi
  816b2d:	ff d0                	callq  *%rax
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
  816b2f:	eb 1c                	jmp    816b4d <etharp_arp_input+0x32f>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  816b31:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  816b35:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816b39:	48 89 d6             	mov    %rdx,%rsi
  816b3c:	48 89 c7             	mov    %rax,%rdi
  816b3f:	48 b8 3c a3 80 00 00 	movabs $0x80a33c,%rax
  816b46:	00 00 00 
  816b49:	ff d0                	callq  *%rax
#endif
    break;
  816b4b:	eb 01                	jmp    816b4e <etharp_arp_input+0x330>
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
  816b4d:	90                   	nop
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  816b4e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816b52:	48 89 c7             	mov    %rax,%rdi
  816b55:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  816b5c:	00 00 00 
  816b5f:	ff d0                	callq  *%rax
}
  816b61:	48 83 c4 58          	add    $0x58,%rsp
  816b65:	5b                   	pop    %rbx
  816b66:	5d                   	pop    %rbp
  816b67:	c3                   	retq   

0000000000816b68 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  816b68:	55                   	push   %rbp
  816b69:	48 89 e5             	mov    %rsp,%rbp
  816b6c:	53                   	push   %rbx
  816b6d:	48 83 ec 38          	sub    $0x38,%rsp
  816b71:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  816b75:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  816b79:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  816b7d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816b81:	be 0e 00 00 00       	mov    $0xe,%esi
  816b86:	48 89 c7             	mov    %rax,%rdi
  816b89:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  816b90:	00 00 00 
  816b93:	ff d0                	callq  *%rax
  816b95:	84 c0                	test   %al,%al
  816b97:	74 0a                	je     816ba3 <etharp_output+0x3b>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  816b99:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  816b9e:	e9 50 01 00 00       	jmpq   816cf3 <etharp_output+0x18b>
  }

  /* assume unresolved Ethernet address */
  dest = NULL;
  816ba3:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  816baa:	00 
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  816bab:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  816baf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816bb3:	48 89 d6             	mov    %rdx,%rsi
  816bb6:	48 89 c7             	mov    %rax,%rdi
  816bb9:	48 b8 70 0d 81 00 00 	movabs $0x810d70,%rax
  816bc0:	00 00 00 
  816bc3:	ff d0                	callq  *%rax
  816bc5:	84 c0                	test   %al,%al
  816bc7:	74 13                	je     816bdc <etharp_output+0x74>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  816bc9:	48 b8 c8 2c 82 00 00 	movabs $0x822cc8,%rax
  816bd0:	00 00 00 
  816bd3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  816bd7:	e9 ee 00 00 00       	jmpq   816cca <etharp_output+0x162>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  816bdc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816be0:	8b 18                	mov    (%rax),%ebx
  816be2:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  816be7:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  816bee:	00 00 00 
  816bf1:	ff d0                	callq  *%rax
  816bf3:	21 c3                	and    %eax,%ebx
  816bf5:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  816bfa:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  816c01:	00 00 00 
  816c04:	ff d0                	callq  *%rax
  816c06:	39 c3                	cmp    %eax,%ebx
  816c08:	75 64                	jne    816c6e <etharp_output+0x106>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  816c0a:	c6 45 e0 01          	movb   $0x1,-0x20(%rbp)
    mcastaddr.addr[1] = 0x00;
  816c0e:	c6 45 e1 00          	movb   $0x0,-0x1f(%rbp)
    mcastaddr.addr[2] = 0x5e;
  816c12:	c6 45 e2 5e          	movb   $0x5e,-0x1e(%rbp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  816c16:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816c1a:	8b 00                	mov    (%rax),%eax
  816c1c:	89 c7                	mov    %eax,%edi
  816c1e:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  816c25:	00 00 00 
  816c28:	ff d0                	callq  *%rax
  816c2a:	c1 e8 10             	shr    $0x10,%eax
  816c2d:	83 e0 7f             	and    $0x7f,%eax
  816c30:	88 45 e3             	mov    %al,-0x1d(%rbp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  816c33:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816c37:	8b 00                	mov    (%rax),%eax
  816c39:	89 c7                	mov    %eax,%edi
  816c3b:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  816c42:	00 00 00 
  816c45:	ff d0                	callq  *%rax
  816c47:	c1 e8 08             	shr    $0x8,%eax
  816c4a:	88 45 e4             	mov    %al,-0x1c(%rbp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  816c4d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816c51:	8b 00                	mov    (%rax),%eax
  816c53:	89 c7                	mov    %eax,%edi
  816c55:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  816c5c:	00 00 00 
  816c5f:	ff d0                	callq  *%rax
  816c61:	88 45 e5             	mov    %al,-0x1b(%rbp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  816c64:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  816c68:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  816c6c:	eb 5c                	jmp    816cca <etharp_output+0x162>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  816c6e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816c72:	8b 10                	mov    (%rax),%edx
  816c74:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816c78:	8b 40 08             	mov    0x8(%rax),%eax
  816c7b:	31 c2                	xor    %eax,%edx
  816c7d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816c81:	8b 40 0c             	mov    0xc(%rax),%eax
  816c84:	21 d0                	and    %edx,%eax
  816c86:	85 c0                	test   %eax,%eax
  816c88:	74 20                	je     816caa <etharp_output+0x142>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  816c8a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816c8e:	8b 40 10             	mov    0x10(%rax),%eax
  816c91:	85 c0                	test   %eax,%eax
  816c93:	74 0e                	je     816ca3 <etharp_output+0x13b>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  816c95:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816c99:	48 83 c0 10          	add    $0x10,%rax
  816c9d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  816ca1:	eb 07                	jmp    816caa <etharp_output+0x142>
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  816ca3:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  816ca8:	eb 49                	jmp    816cf3 <etharp_output+0x18b>
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  816caa:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  816cae:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  816cb2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816cb6:	48 89 ce             	mov    %rcx,%rsi
  816cb9:	48 89 c7             	mov    %rax,%rdi
  816cbc:	48 b8 fa 6c 81 00 00 	movabs $0x816cfa,%rax
  816cc3:	00 00 00 
  816cc6:	ff d0                	callq  *%rax
  816cc8:	eb 29                	jmp    816cf3 <etharp_output+0x18b>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  816cca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816cce:	48 8d 78 41          	lea    0x41(%rax),%rdi
  816cd2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816cd6:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  816cda:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816cde:	48 89 d1             	mov    %rdx,%rcx
  816ce1:	48 89 fa             	mov    %rdi,%rdx
  816ce4:	48 89 c7             	mov    %rax,%rdi
  816ce7:	48 b8 29 63 81 00 00 	movabs $0x816329,%rax
  816cee:	00 00 00 
  816cf1:	ff d0                	callq  *%rax
}
  816cf3:	48 83 c4 38          	add    $0x38,%rsp
  816cf7:	5b                   	pop    %rbx
  816cf8:	5d                   	pop    %rbp
  816cf9:	c3                   	retq   

0000000000816cfa <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  816cfa:	55                   	push   %rbp
  816cfb:	48 89 e5             	mov    %rsp,%rbp
  816cfe:	53                   	push   %rbx
  816cff:	48 83 ec 68          	sub    $0x68,%rsp
  816d03:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  816d07:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  816d0b:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  816d0f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816d13:	48 83 c0 41          	add    $0x41,%rax
  816d17:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  err_t result = ERR_MEM;
  816d1b:	c6 45 ef ff          	movb   $0xff,-0x11(%rbp)
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  816d1f:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  816d23:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816d27:	48 89 d6             	mov    %rdx,%rsi
  816d2a:	48 89 c7             	mov    %rax,%rdi
  816d2d:	48 b8 70 0d 81 00 00 	movabs $0x810d70,%rax
  816d34:	00 00 00 
  816d37:	ff d0                	callq  *%rax
  816d39:	84 c0                	test   %al,%al
  816d3b:	75 3f                	jne    816d7c <etharp_query+0x82>
      ip_addr_ismulticast(ipaddr) ||
  816d3d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816d41:	8b 18                	mov    (%rax),%ebx
  816d43:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  816d48:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  816d4f:	00 00 00 
  816d52:	ff d0                	callq  *%rax
  816d54:	21 c3                	and    %eax,%ebx
  816d56:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  816d5b:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  816d62:	00 00 00 
  816d65:	ff d0                	callq  *%rax
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  816d67:	39 c3                	cmp    %eax,%ebx
  816d69:	74 11                	je     816d7c <etharp_query+0x82>
      ip_addr_ismulticast(ipaddr) ||
  816d6b:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  816d70:	74 0a                	je     816d7c <etharp_query+0x82>
      ip_addr_isany(ipaddr)) {
  816d72:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816d76:	8b 00                	mov    (%rax),%eax
  816d78:	85 c0                	test   %eax,%eax
  816d7a:	75 0a                	jne    816d86 <etharp_query+0x8c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  816d7c:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  816d81:	e9 18 04 00 00       	jmpq   81719e <etharp_query+0x4a4>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  816d86:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816d8a:	be 01 00 00 00       	mov    $0x1,%esi
  816d8f:	48 89 c7             	mov    %rax,%rdi
  816d92:	48 b8 95 5d 81 00 00 	movabs $0x815d95,%rax
  816d99:	00 00 00 
  816d9c:	ff d0                	callq  *%rax
  816d9e:	88 45 c7             	mov    %al,-0x39(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  816da1:	80 7d c7 00          	cmpb   $0x0,-0x39(%rbp)
  816da5:	79 09                	jns    816db0 <etharp_query+0xb6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
    }
    return (err_t)i;
  816da7:	0f b6 45 c7          	movzbl -0x39(%rbp),%eax
  816dab:	e9 ee 03 00 00       	jmpq   81719e <etharp_query+0x4a4>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  816db0:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816db4:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816dbb:	00 00 00 
  816dbe:	48 63 d0             	movslq %eax,%rdx
  816dc1:	48 89 d0             	mov    %rdx,%rax
  816dc4:	48 c1 e0 02          	shl    $0x2,%rax
  816dc8:	48 01 d0             	add    %rdx,%rax
  816dcb:	48 c1 e0 03          	shl    $0x3,%rax
  816dcf:	48 01 c8             	add    %rcx,%rax
  816dd2:	48 83 c0 14          	add    $0x14,%rax
  816dd6:	8b 00                	mov    (%rax),%eax
  816dd8:	85 c0                	test   %eax,%eax
  816dda:	75 2c                	jne    816e08 <etharp_query+0x10e>
    arp_table[i].state = ETHARP_STATE_PENDING;
  816ddc:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816de0:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816de7:	00 00 00 
  816dea:	48 63 d0             	movslq %eax,%rdx
  816ded:	48 89 d0             	mov    %rdx,%rax
  816df0:	48 c1 e0 02          	shl    $0x2,%rax
  816df4:	48 01 d0             	add    %rdx,%rax
  816df7:	48 c1 e0 03          	shl    $0x3,%rax
  816dfb:	48 01 c8             	add    %rcx,%rax
  816dfe:	48 83 c0 14          	add    $0x14,%rax
  816e02:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  816e08:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816e0c:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816e13:	00 00 00 
  816e16:	48 63 d0             	movslq %eax,%rdx
  816e19:	48 89 d0             	mov    %rdx,%rax
  816e1c:	48 c1 e0 02          	shl    $0x2,%rax
  816e20:	48 01 d0             	add    %rdx,%rax
  816e23:	48 c1 e0 03          	shl    $0x3,%rax
  816e27:	48 01 c8             	add    %rcx,%rax
  816e2a:	48 83 c0 14          	add    $0x14,%rax
  816e2e:	8b 00                	mov    (%rax),%eax
  816e30:	83 f8 01             	cmp    $0x1,%eax
  816e33:	74 57                	je     816e8c <etharp_query+0x192>
  816e35:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816e39:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816e40:	00 00 00 
  816e43:	48 63 d0             	movslq %eax,%rdx
  816e46:	48 89 d0             	mov    %rdx,%rax
  816e49:	48 c1 e0 02          	shl    $0x2,%rax
  816e4d:	48 01 d0             	add    %rdx,%rax
  816e50:	48 c1 e0 03          	shl    $0x3,%rax
  816e54:	48 01 c8             	add    %rcx,%rax
  816e57:	48 83 c0 14          	add    $0x14,%rax
  816e5b:	8b 00                	mov    (%rax),%eax
  816e5d:	83 f8 02             	cmp    $0x2,%eax
  816e60:	74 2a                	je     816e8c <etharp_query+0x192>
  816e62:	48 ba c0 2d 82 00 00 	movabs $0x822dc0,%rdx
  816e69:	00 00 00 
  816e6c:	be 93 03 00 00       	mov    $0x393,%esi
  816e71:	48 bf de 2c 82 00 00 	movabs $0x822cde,%rdi
  816e78:	00 00 00 
  816e7b:	b8 00 00 00 00       	mov    $0x0,%eax
  816e80:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  816e87:	00 00 00 
  816e8a:	ff d1                	callq  *%rcx
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  816e8c:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816e90:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816e97:	00 00 00 
  816e9a:	48 63 d0             	movslq %eax,%rdx
  816e9d:	48 89 d0             	mov    %rdx,%rax
  816ea0:	48 c1 e0 02          	shl    $0x2,%rax
  816ea4:	48 01 d0             	add    %rdx,%rax
  816ea7:	48 c1 e0 03          	shl    $0x3,%rax
  816eab:	48 01 c8             	add    %rcx,%rax
  816eae:	48 83 c0 14          	add    $0x14,%rax
  816eb2:	8b 00                	mov    (%rax),%eax
  816eb4:	83 f8 01             	cmp    $0x1,%eax
  816eb7:	74 07                	je     816ec0 <etharp_query+0x1c6>
  816eb9:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  816ebe:	75 1d                	jne    816edd <etharp_query+0x1e3>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  816ec0:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  816ec4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816ec8:	48 89 d6             	mov    %rdx,%rsi
  816ecb:	48 89 c7             	mov    %rax,%rdi
  816ece:	48 b8 e5 73 81 00 00 	movabs $0x8173e5,%rax
  816ed5:	00 00 00 
  816ed8:	ff d0                	callq  *%rax
  816eda:	88 45 ef             	mov    %al,-0x11(%rbp)
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  816edd:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  816ee2:	0f 84 b2 02 00 00    	je     81719a <etharp_query+0x4a0>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  816ee8:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816eec:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816ef3:	00 00 00 
  816ef6:	48 63 d0             	movslq %eax,%rdx
  816ef9:	48 89 d0             	mov    %rdx,%rax
  816efc:	48 c1 e0 02          	shl    $0x2,%rax
  816f00:	48 01 d0             	add    %rdx,%rax
  816f03:	48 c1 e0 03          	shl    $0x3,%rax
  816f07:	48 01 c8             	add    %rcx,%rax
  816f0a:	48 83 c0 14          	add    $0x14,%rax
  816f0e:	8b 00                	mov    (%rax),%eax
  816f10:	83 f8 02             	cmp    $0x2,%eax
  816f13:	75 49                	jne    816f5e <etharp_query+0x264>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  816f15:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816f19:	48 63 d0             	movslq %eax,%rdx
  816f1c:	48 89 d0             	mov    %rdx,%rax
  816f1f:	48 c1 e0 02          	shl    $0x2,%rax
  816f23:	48 01 d0             	add    %rdx,%rax
  816f26:	48 c1 e0 03          	shl    $0x3,%rax
  816f2a:	48 ba 80 b6 b4 00 00 	movabs $0xb4b680,%rdx
  816f31:	00 00 00 
  816f34:	48 01 d0             	add    %rdx,%rax
  816f37:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  816f3b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  816f3f:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  816f43:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816f47:	48 89 c7             	mov    %rax,%rdi
  816f4a:	48 b8 29 63 81 00 00 	movabs $0x816329,%rax
  816f51:	00 00 00 
  816f54:	ff d0                	callq  *%rax
  816f56:	88 45 ef             	mov    %al,-0x11(%rbp)
  816f59:	e9 3c 02 00 00       	jmpq   81719a <etharp_query+0x4a0>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  816f5e:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816f62:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816f69:	00 00 00 
  816f6c:	48 63 d0             	movslq %eax,%rdx
  816f6f:	48 89 d0             	mov    %rdx,%rax
  816f72:	48 c1 e0 02          	shl    $0x2,%rax
  816f76:	48 01 d0             	add    %rdx,%rax
  816f79:	48 c1 e0 03          	shl    $0x3,%rax
  816f7d:	48 01 c8             	add    %rcx,%rax
  816f80:	48 83 c0 14          	add    $0x14,%rax
  816f84:	8b 00                	mov    (%rax),%eax
  816f86:	83 f8 01             	cmp    $0x1,%eax
  816f89:	0f 85 0b 02 00 00    	jne    81719a <etharp_query+0x4a0>
#if ARP_QUEUEING /* queue the given q packet */
      struct pbuf *p;
      int copy_needed = 0;
  816f8f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
  816f96:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  816f9a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      while (p) {
  816f9e:	eb 6b                	jmp    81700b <etharp_query+0x311>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  816fa0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816fa4:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  816fa8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816fac:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  816fb0:	66 39 c2             	cmp    %ax,%dx
  816fb3:	75 36                	jne    816feb <etharp_query+0x2f1>
  816fb5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816fb9:	48 8b 00             	mov    (%rax),%rax
  816fbc:	48 85 c0             	test   %rax,%rax
  816fbf:	74 2a                	je     816feb <etharp_query+0x2f1>
  816fc1:	48 ba e8 2d 82 00 00 	movabs $0x822de8,%rdx
  816fc8:	00 00 00 
  816fcb:	be b2 03 00 00       	mov    $0x3b2,%esi
  816fd0:	48 bf de 2c 82 00 00 	movabs $0x822cde,%rdi
  816fd7:	00 00 00 
  816fda:	b8 00 00 00 00       	mov    $0x0,%eax
  816fdf:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  816fe6:	00 00 00 
  816fe9:	ff d1                	callq  *%rcx
        if(p->type != PBUF_ROM) {
  816feb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816fef:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  816ff3:	3c 01                	cmp    $0x1,%al
  816ff5:	74 09                	je     817000 <etharp_query+0x306>
          copy_needed = 1;
  816ff7:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)
          break;
  816ffe:	eb 12                	jmp    817012 <etharp_query+0x318>
        }
        p = p->next;
  817000:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817004:	48 8b 00             	mov    (%rax),%rax
  817007:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  81700b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  817010:	75 8e                	jne    816fa0 <etharp_query+0x2a6>
          copy_needed = 1;
          break;
        }
        p = p->next;
      }
      if(copy_needed) {
  817012:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  817016:	74 69                	je     817081 <etharp_query+0x387>
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  817018:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81701c:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  817020:	0f b7 c0             	movzwl %ax,%eax
  817023:	ba 00 00 00 00       	mov    $0x0,%edx
  817028:	89 c6                	mov    %eax,%esi
  81702a:	bf 03 00 00 00       	mov    $0x3,%edi
  81702f:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  817036:	00 00 00 
  817039:	ff d0                	callq  *%rax
  81703b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        if(p != NULL) {
  81703f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  817044:	74 56                	je     81709c <etharp_query+0x3a2>
          if (pbuf_copy(p, q) != ERR_OK) {
  817046:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81704a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81704e:	48 89 d6             	mov    %rdx,%rsi
  817051:	48 89 c7             	mov    %rax,%rdi
  817054:	48 b8 cf e1 80 00 00 	movabs $0x80e1cf,%rax
  81705b:	00 00 00 
  81705e:	ff d0                	callq  *%rax
  817060:	84 c0                	test   %al,%al
  817062:	74 38                	je     81709c <etharp_query+0x3a2>
            pbuf_free(p);
  817064:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817068:	48 89 c7             	mov    %rax,%rdi
  81706b:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  817072:	00 00 00 
  817075:	ff d0                	callq  *%rax
            p = NULL;
  817077:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81707e:	00 
  81707f:	eb 1b                	jmp    81709c <etharp_query+0x3a2>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
  817081:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  817085:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        pbuf_ref(p);
  817089:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81708d:	48 89 c7             	mov    %rax,%rdi
  817090:	48 b8 30 df 80 00 00 	movabs $0x80df30,%rax
  817097:	00 00 00 
  81709a:	ff d0                	callq  *%rax
      }
      /* packet could be taken over? */
      if (p != NULL) {
  81709c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8170a1:	0f 84 f3 00 00 00    	je     81719a <etharp_query+0x4a0>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  8170a7:	bf 0a 00 00 00       	mov    $0xa,%edi
  8170ac:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  8170b3:	00 00 00 
  8170b6:	ff d0                	callq  *%rax
  8170b8:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        if (new_entry != NULL) {
  8170bc:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8170c1:	0f 84 c0 00 00 00    	je     817187 <etharp_query+0x48d>
          new_entry->next = 0;
  8170c7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8170cb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
          new_entry->p = p;
  8170d2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8170d6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8170da:	48 89 50 08          	mov    %rdx,0x8(%rax)
          if(arp_table[i].q != NULL) {
  8170de:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  8170e2:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8170e9:	00 00 00 
  8170ec:	48 63 d0             	movslq %eax,%rdx
  8170ef:	48 89 d0             	mov    %rdx,%rax
  8170f2:	48 c1 e0 02          	shl    $0x2,%rax
  8170f6:	48 01 d0             	add    %rdx,%rax
  8170f9:	48 c1 e0 03          	shl    $0x3,%rax
  8170fd:	48 01 c8             	add    %rcx,%rax
  817100:	48 8b 00             	mov    (%rax),%rax
  817103:	48 85 c0             	test   %rax,%rax
  817106:	74 4f                	je     817157 <etharp_query+0x45d>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
  817108:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  81710c:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  817113:	00 00 00 
  817116:	48 63 d0             	movslq %eax,%rdx
  817119:	48 89 d0             	mov    %rdx,%rax
  81711c:	48 c1 e0 02          	shl    $0x2,%rax
  817120:	48 01 d0             	add    %rdx,%rax
  817123:	48 c1 e0 03          	shl    $0x3,%rax
  817127:	48 01 c8             	add    %rcx,%rax
  81712a:	48 8b 00             	mov    (%rax),%rax
  81712d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
            while (r->next != NULL) {
  817131:	eb 0b                	jmp    81713e <etharp_query+0x444>
              r = r->next;
  817133:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  817137:	48 8b 00             	mov    (%rax),%rax
  81713a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  81713e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  817142:	48 8b 00             	mov    (%rax),%rax
  817145:	48 85 c0             	test   %rax,%rax
  817148:	75 e9                	jne    817133 <etharp_query+0x439>
              r = r->next;
            }
            r->next = new_entry;
  81714a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81714e:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  817152:	48 89 10             	mov    %rdx,(%rax)
  817155:	eb 2a                	jmp    817181 <etharp_query+0x487>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  817157:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  81715b:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  817162:	00 00 00 
  817165:	48 63 d0             	movslq %eax,%rdx
  817168:	48 89 d0             	mov    %rdx,%rax
  81716b:	48 c1 e0 02          	shl    $0x2,%rax
  81716f:	48 01 d0             	add    %rdx,%rax
  817172:	48 c1 e0 03          	shl    $0x3,%rax
  817176:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  81717a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81717e:	48 89 02             	mov    %rax,(%rdx)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  817181:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  817185:	eb 13                	jmp    81719a <etharp_query+0x4a0>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  817187:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81718b:	48 89 c7             	mov    %rax,%rdi
  81718e:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  817195:	00 00 00 
  817198:	ff d0                	callq  *%rax
      /* { result == ERR_MEM } through initialization */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
  81719a:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  81719e:	48 83 c4 68          	add    $0x68,%rsp
  8171a2:	5b                   	pop    %rbx
  8171a3:	5d                   	pop    %rbp
  8171a4:	c3                   	retq   

00000000008171a5 <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const struct ip_addr *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const struct ip_addr *ipdst_addr,
           const u16_t opcode)
{
  8171a5:	55                   	push   %rbp
  8171a6:	48 89 e5             	mov    %rsp,%rbp
  8171a9:	48 83 ec 60          	sub    $0x60,%rsp
  8171ad:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8171b1:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8171b5:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8171b9:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8171bd:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  8171c1:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
  8171c5:	8b 45 18             	mov    0x18(%rbp),%eax
  8171c8:	66 89 45 ac          	mov    %ax,-0x54(%rbp)
  struct pbuf *p;
  err_t result = ERR_OK;
  8171cc:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  8171d0:	ba 00 00 00 00       	mov    $0x0,%edx
  8171d5:	be 2a 00 00 00       	mov    $0x2a,%esi
  8171da:	bf 02 00 00 00       	mov    $0x2,%edi
  8171df:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  8171e6:	00 00 00 
  8171e9:	ff d0                	callq  *%rax
  8171eb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  8171ef:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8171f4:	75 0a                	jne    817200 <etharp_raw+0x5b>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  8171f6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8171fb:	e9 e3 01 00 00       	jmpq   8173e3 <etharp_raw+0x23e>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  817200:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  817204:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  817208:	66 83 f8 29          	cmp    $0x29,%ax
  81720c:	77 2a                	ja     817238 <etharp_raw+0x93>
  81720e:	48 ba 08 2e 82 00 00 	movabs $0x822e08,%rdx
  817215:	00 00 00 
  817218:	be 1d 04 00 00       	mov    $0x41d,%esi
  81721d:	48 bf de 2c 82 00 00 	movabs $0x822cde,%rdi
  817224:	00 00 00 
  817227:	b8 00 00 00 00       	mov    $0x0,%eax
  81722c:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  817233:	00 00 00 
  817236:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  817238:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81723c:	48 8b 40 08          	mov    0x8(%rax),%rax
  817240:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  817244:	0f b7 45 ac          	movzwl -0x54(%rbp),%eax
  817248:	89 c7                	mov    %eax,%edi
  81724a:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  817251:	00 00 00 
  817254:	ff d0                	callq  *%rax
  817256:	89 c2                	mov    %eax,%edx
  817258:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81725c:	66 89 50 14          	mov    %dx,0x14(%rax)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  817260:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  817264:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  817268:	3c 06                	cmp    $0x6,%al
  81726a:	74 2a                	je     817296 <etharp_raw+0xf1>
  81726c:	48 ba 40 2d 82 00 00 	movabs $0x822d40,%rdx
  817273:	00 00 00 
  817276:	be 24 04 00 00       	mov    $0x424,%esi
  81727b:	48 bf de 2c 82 00 00 	movabs $0x822cde,%rdi
  817282:	00 00 00 
  817285:	b8 00 00 00 00       	mov    $0x0,%eax
  81728a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  817291:	00 00 00 
  817294:	ff d1                	callq  *%rcx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  817296:	c6 45 ff 06          	movb   $0x6,-0x1(%rbp)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  81729a:	eb 7d                	jmp    817319 <etharp_raw+0x174>
    k--;
  81729c:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8172a0:	83 e8 01             	sub    $0x1,%eax
  8172a3:	88 45 ff             	mov    %al,-0x1(%rbp)
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  8172a6:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  8172aa:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8172ae:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8172b2:	48 98                	cltq   
  8172b4:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8172b8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8172bc:	48 63 c6             	movslq %esi,%rax
  8172bf:	88 4c 02 16          	mov    %cl,0x16(%rdx,%rax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  8172c3:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  8172c7:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8172cb:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8172cf:	48 98                	cltq   
  8172d1:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8172d5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8172d9:	48 63 c6             	movslq %esi,%rax
  8172dc:	88 4c 02 20          	mov    %cl,0x20(%rdx,%rax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  8172e0:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  8172e4:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8172e8:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8172ec:	48 98                	cltq   
  8172ee:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8172f2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8172f6:	48 63 c6             	movslq %esi,%rax
  8172f9:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  8172fc:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  817300:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  817304:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  817308:	48 98                	cltq   
  81730a:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  81730e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  817312:	48 63 c6             	movslq %esi,%rax
  817315:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  817319:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  81731d:	0f 85 79 ff ff ff    	jne    81729c <etharp_raw+0xf7>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  817323:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817327:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  81732b:	8b 12                	mov    (%rdx),%edx
  81732d:	89 50 1c             	mov    %edx,0x1c(%rax)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  817330:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817334:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  817338:	8b 12                	mov    (%rdx),%edx
  81733a:	89 50 26             	mov    %edx,0x26(%rax)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  81733d:	bf 01 00 00 00       	mov    $0x1,%edi
  817342:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  817349:	00 00 00 
  81734c:	ff d0                	callq  *%rax
  81734e:	89 c2                	mov    %eax,%edx
  817350:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817354:	66 89 50 0e          	mov    %dx,0xe(%rax)
  hdr->proto = htons(ETHTYPE_IP);
  817358:	bf 00 08 00 00       	mov    $0x800,%edi
  81735d:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  817364:	00 00 00 
  817367:	ff d0                	callq  *%rax
  817369:	89 c2                	mov    %eax,%edx
  81736b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81736f:	66 89 50 10          	mov    %dx,0x10(%rax)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  817373:	bf 04 06 00 00       	mov    $0x604,%edi
  817378:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  81737f:	00 00 00 
  817382:	ff d0                	callq  *%rax
  817384:	89 c2                	mov    %eax,%edx
  817386:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81738a:	66 89 50 12          	mov    %dx,0x12(%rax)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  81738e:	bf 06 08 00 00       	mov    $0x806,%edi
  817393:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  81739a:	00 00 00 
  81739d:	ff d0                	callq  *%rax
  81739f:	89 c2                	mov    %eax,%edx
  8173a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8173a5:	66 89 50 0c          	mov    %dx,0xc(%rax)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  8173a9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8173ad:	48 8b 40 28          	mov    0x28(%rax),%rax
  8173b1:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8173b5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8173b9:	48 89 ce             	mov    %rcx,%rsi
  8173bc:	48 89 d7             	mov    %rdx,%rdi
  8173bf:	ff d0                	callq  *%rax
  8173c1:	88 45 fe             	mov    %al,-0x2(%rbp)
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  8173c4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8173c8:	48 89 c7             	mov    %rax,%rdi
  8173cb:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  8173d2:	00 00 00 
  8173d5:	ff d0                	callq  *%rax
  p = NULL;
  8173d7:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8173de:	00 
  /* could not allocate pbuf for ARP request */

  return result;
  8173df:	0f b6 45 fe          	movzbl -0x2(%rbp),%eax
}
  8173e3:	c9                   	leaveq 
  8173e4:	c3                   	retq   

00000000008173e5 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  8173e5:	55                   	push   %rbp
  8173e6:	48 89 e5             	mov    %rsp,%rbp
  8173e9:	48 83 ec 10          	sub    $0x10,%rsp
  8173ed:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8173f1:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
  8173f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8173f9:	48 8d 48 08          	lea    0x8(%rax),%rcx
  8173fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817401:	48 8d 50 41          	lea    0x41(%rax),%rdx
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  817405:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817409:	48 8d 70 41          	lea    0x41(%rax),%rsi
  81740d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817411:	6a 01                	pushq  $0x1
  817413:	ff 75 f0             	pushq  -0x10(%rbp)
  817416:	49 b9 ce 2c 82 00 00 	movabs $0x822cce,%r9
  81741d:	00 00 00 
  817420:	49 89 c8             	mov    %rcx,%r8
  817423:	48 89 d1             	mov    %rdx,%rcx
  817426:	48 ba c8 2c 82 00 00 	movabs $0x822cc8,%rdx
  81742d:	00 00 00 
  817430:	48 89 c7             	mov    %rax,%rdi
  817433:	48 b8 a5 71 81 00 00 	movabs $0x8171a5,%rax
  81743a:	00 00 00 
  81743d:	ff d0                	callq  *%rax
  81743f:	48 83 c4 10          	add    $0x10,%rsp
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  817443:	c9                   	leaveq 
  817444:	c3                   	retq   

0000000000817445 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  817445:	55                   	push   %rbp
  817446:	48 89 e5             	mov    %rsp,%rbp
  817449:	48 83 ec 20          	sub    $0x20,%rsp
  81744d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  817451:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct eth_hdr* ethhdr;

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
  817455:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817459:	48 8b 40 08          	mov    0x8(%rax),%rax
  81745d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  817461:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817465:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  817469:	0f b7 c0             	movzwl %ax,%eax
  81746c:	89 c7                	mov    %eax,%edi
  81746e:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  817475:	00 00 00 
  817478:	ff d0                	callq  *%rax
  81747a:	0f b7 c0             	movzwl %ax,%eax
  81747d:	3d 00 08 00 00       	cmp    $0x800,%eax
  817482:	74 10                	je     817494 <ethernet_input+0x4f>
  817484:	3d 06 08 00 00       	cmp    $0x806,%eax
  817489:	0f 84 81 00 00 00    	je     817510 <ethernet_input+0xcb>
  81748f:	e9 a0 00 00 00       	jmpq   817534 <ethernet_input+0xef>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  817494:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  817498:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81749c:	48 89 d6             	mov    %rdx,%rsi
  81749f:	48 89 c7             	mov    %rax,%rdi
  8174a2:	48 b8 87 67 81 00 00 	movabs $0x816787,%rax
  8174a9:	00 00 00 
  8174ac:	ff d0                	callq  *%rax
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  8174ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8174b2:	be f2 ff ff ff       	mov    $0xfffffff2,%esi
  8174b7:	48 89 c7             	mov    %rax,%rdi
  8174ba:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  8174c1:	00 00 00 
  8174c4:	ff d0                	callq  *%rax
  8174c6:	84 c0                	test   %al,%al
  8174c8:	74 2a                	je     8174f4 <ethernet_input+0xaf>
        LWIP_ASSERT("Can't move over header in packet", 0);
  8174ca:	48 ba 40 2e 82 00 00 	movabs $0x822e40,%rdx
  8174d1:	00 00 00 
  8174d4:	be 7f 04 00 00       	mov    $0x47f,%esi
  8174d9:	48 bf de 2c 82 00 00 	movabs $0x822cde,%rdi
  8174e0:	00 00 00 
  8174e3:	b8 00 00 00 00       	mov    $0x0,%eax
  8174e8:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8174ef:	00 00 00 
  8174f2:	ff d1                	callq  *%rcx
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  8174f4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8174f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8174fc:	48 89 d6             	mov    %rdx,%rsi
  8174ff:	48 89 c7             	mov    %rax,%rdi
  817502:	48 b8 bf 0e 81 00 00 	movabs $0x810ebf,%rax
  817509:	00 00 00 
  81750c:	ff d0                	callq  *%rax
      }
      break;
  81750e:	eb 40                	jmp    817550 <ethernet_input+0x10b>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  817510:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817514:	48 8d 48 41          	lea    0x41(%rax),%rcx
  817518:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81751c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817520:	48 89 ce             	mov    %rcx,%rsi
  817523:	48 89 c7             	mov    %rax,%rdi
  817526:	48 b8 1e 68 81 00 00 	movabs $0x81681e,%rax
  81752d:	00 00 00 
  817530:	ff d0                	callq  *%rax
      break;
  817532:	eb 1c                	jmp    817550 <ethernet_input+0x10b>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  817534:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817538:	48 89 c7             	mov    %rax,%rdi
  81753b:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  817542:	00 00 00 
  817545:	ff d0                	callq  *%rax
      p = NULL;
  817547:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  81754e:	00 
      break;
  81754f:	90                   	nop
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
  817550:	b8 00 00 00 00       	mov    $0x0,%eax
}
  817555:	c9                   	leaveq 
  817556:	c3                   	retq   

0000000000817557 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  817557:	55                   	push   %rbp
  817558:	48 89 e5             	mov    %rsp,%rbp
  81755b:	48 83 ec 10          	sub    $0x10,%rsp
    int i = 0;
  81755f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    for (i = 0; i < NSEM; i++) {
  817566:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  81756d:	e9 e9 00 00 00       	jmpq   81765b <sys_init+0x104>
	sems[i].freed = 1;
  817572:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817579:	00 00 00 
  81757c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81757f:	48 63 d2             	movslq %edx,%rdx
  817582:	48 c1 e2 05          	shl    $0x5,%rdx
  817586:	48 01 d0             	add    %rdx,%rax
  817589:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  81758f:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817596:	00 00 00 
  817599:	48 8b 00             	mov    (%rax),%rax
  81759c:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  8175a3:	00 00 00 
  8175a6:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8175a9:	48 63 c9             	movslq %ecx,%rcx
  8175ac:	48 c1 e1 05          	shl    $0x5,%rcx
  8175b0:	48 01 ca             	add    %rcx,%rdx
  8175b3:	48 83 c2 10          	add    $0x10,%rdx
  8175b7:	48 89 02             	mov    %rax,(%rdx)
  8175ba:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8175c1:	00 00 00 
  8175c4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8175c7:	48 63 d2             	movslq %edx,%rdx
  8175ca:	48 c1 e2 05          	shl    $0x5,%rdx
  8175ce:	48 01 d0             	add    %rdx,%rax
  8175d1:	48 83 c0 10          	add    $0x10,%rax
  8175d5:	48 8b 00             	mov    (%rax),%rax
  8175d8:	48 85 c0             	test   %rax,%rax
  8175db:	74 2c                	je     817609 <sys_init+0xb2>
  8175dd:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  8175e4:	00 00 00 
  8175e7:	48 8b 00             	mov    (%rax),%rax
  8175ea:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8175ed:	48 63 d2             	movslq %edx,%rdx
  8175f0:	48 c1 e2 05          	shl    $0x5,%rdx
  8175f4:	48 8d 4a 10          	lea    0x10(%rdx),%rcx
  8175f8:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  8175ff:	00 00 00 
  817602:	48 01 ca             	add    %rcx,%rdx
  817605:	48 89 50 18          	mov    %rdx,0x18(%rax)
  817609:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81760c:	48 98                	cltq   
  81760e:	48 c1 e0 05          	shl    $0x5,%rax
  817612:	48 89 c2             	mov    %rax,%rdx
  817615:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  81761c:	00 00 00 
  81761f:	48 01 c2             	add    %rax,%rdx
  817622:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817629:	00 00 00 
  81762c:	48 89 10             	mov    %rdx,(%rax)
  81762f:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817636:	00 00 00 
  817639:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81763c:	48 63 d2             	movslq %edx,%rdx
  81763f:	48 c1 e2 05          	shl    $0x5,%rdx
  817643:	48 01 d0             	add    %rdx,%rax
  817646:	48 83 c0 18          	add    $0x18,%rax
  81764a:	48 bf 20 d8 b4 00 00 	movabs $0xb4d820,%rdi
  817651:	00 00 00 
  817654:	48 89 38             	mov    %rdi,(%rax)

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  817657:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  81765b:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%rbp)
  817662:	0f 8e 0a ff ff ff    	jle    817572 <sys_init+0x1b>
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  817668:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  81766f:	e9 5d 01 00 00       	jmpq   8177d1 <sys_init+0x27a>
	mboxes[i].freed = 1;
  817674:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81767b:	00 00 00 
  81767e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817681:	48 63 d0             	movslq %eax,%rdx
  817684:	48 89 d0             	mov    %rdx,%rax
  817687:	48 c1 e0 03          	shl    $0x3,%rax
  81768b:	48 01 d0             	add    %rdx,%rax
  81768e:	48 c1 e0 02          	shl    $0x2,%rax
  817692:	48 01 d0             	add    %rdx,%rax
  817695:	48 c1 e0 03          	shl    $0x3,%rax
  817699:	48 01 c8             	add    %rcx,%rax
  81769c:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  8176a2:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  8176a9:	00 00 00 
  8176ac:	48 8b 08             	mov    (%rax),%rcx
  8176af:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  8176b6:	00 00 00 
  8176b9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8176bc:	48 63 d0             	movslq %eax,%rdx
  8176bf:	48 89 d0             	mov    %rdx,%rax
  8176c2:	48 c1 e0 03          	shl    $0x3,%rax
  8176c6:	48 01 d0             	add    %rdx,%rax
  8176c9:	48 c1 e0 02          	shl    $0x2,%rax
  8176cd:	48 01 d0             	add    %rdx,%rax
  8176d0:	48 c1 e0 03          	shl    $0x3,%rax
  8176d4:	48 01 f0             	add    %rsi,%rax
  8176d7:	48 05 18 01 00 00    	add    $0x118,%rax
  8176dd:	48 89 08             	mov    %rcx,(%rax)
  8176e0:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8176e7:	00 00 00 
  8176ea:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8176ed:	48 63 d0             	movslq %eax,%rdx
  8176f0:	48 89 d0             	mov    %rdx,%rax
  8176f3:	48 c1 e0 03          	shl    $0x3,%rax
  8176f7:	48 01 d0             	add    %rdx,%rax
  8176fa:	48 c1 e0 02          	shl    $0x2,%rax
  8176fe:	48 01 d0             	add    %rdx,%rax
  817701:	48 c1 e0 03          	shl    $0x3,%rax
  817705:	48 01 c8             	add    %rcx,%rax
  817708:	48 05 18 01 00 00    	add    $0x118,%rax
  81770e:	48 8b 00             	mov    (%rax),%rax
  817711:	48 85 c0             	test   %rax,%rax
  817714:	74 47                	je     81775d <sys_init+0x206>
  817716:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  81771d:	00 00 00 
  817720:	48 8b 08             	mov    (%rax),%rcx
  817723:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817726:	48 63 d0             	movslq %eax,%rdx
  817729:	48 89 d0             	mov    %rdx,%rax
  81772c:	48 c1 e0 03          	shl    $0x3,%rax
  817730:	48 01 d0             	add    %rdx,%rax
  817733:	48 c1 e0 02          	shl    $0x2,%rax
  817737:	48 01 d0             	add    %rdx,%rax
  81773a:	48 c1 e0 03          	shl    $0x3,%rax
  81773e:	48 8d 90 10 01 00 00 	lea    0x110(%rax),%rdx
  817745:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  81774c:	00 00 00 
  81774f:	48 01 d0             	add    %rdx,%rax
  817752:	48 83 c0 08          	add    $0x8,%rax
  817756:	48 89 81 20 01 00 00 	mov    %rax,0x120(%rcx)
  81775d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817760:	48 63 d0             	movslq %eax,%rdx
  817763:	48 89 d0             	mov    %rdx,%rax
  817766:	48 c1 e0 03          	shl    $0x3,%rax
  81776a:	48 01 d0             	add    %rdx,%rax
  81776d:	48 c1 e0 02          	shl    $0x2,%rax
  817771:	48 01 d0             	add    %rdx,%rax
  817774:	48 c1 e0 03          	shl    $0x3,%rax
  817778:	48 ba 40 d8 b4 00 00 	movabs $0xb4d840,%rdx
  81777f:	00 00 00 
  817782:	48 01 c2             	add    %rax,%rdx
  817785:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  81778c:	00 00 00 
  81778f:	48 89 10             	mov    %rdx,(%rax)
  817792:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817799:	00 00 00 
  81779c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81779f:	48 63 d0             	movslq %eax,%rdx
  8177a2:	48 89 d0             	mov    %rdx,%rax
  8177a5:	48 c1 e0 03          	shl    $0x3,%rax
  8177a9:	48 01 d0             	add    %rdx,%rax
  8177ac:	48 c1 e0 02          	shl    $0x2,%rax
  8177b0:	48 01 d0             	add    %rdx,%rax
  8177b3:	48 c1 e0 03          	shl    $0x3,%rax
  8177b7:	48 01 c8             	add    %rcx,%rax
  8177ba:	48 05 20 01 00 00    	add    $0x120,%rax
  8177c0:	48 be 40 6c b5 00 00 	movabs $0xb56c40,%rsi
  8177c7:	00 00 00 
  8177ca:	48 89 30             	mov    %rsi,(%rax)
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  8177cd:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8177d1:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%rbp)
  8177d5:	0f 8e 99 fe ff ff    	jle    817674 <sys_init+0x11d>
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  8177db:	90                   	nop
  8177dc:	c9                   	leaveq 
  8177dd:	c3                   	retq   

00000000008177de <sys_mbox_new>:

sys_mbox_t
sys_mbox_new(int size)
{
  8177de:	55                   	push   %rbp
  8177df:	48 89 e5             	mov    %rsp,%rbp
  8177e2:	48 83 ec 20          	sub    $0x20,%rsp
  8177e6:	89 7d ec             	mov    %edi,-0x14(%rbp)
    assert(size < MBOXSLOTS);
  8177e9:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  8177ed:	7e 35                	jle    817824 <sys_mbox_new+0x46>
  8177ef:	48 b9 68 2e 82 00 00 	movabs $0x822e68,%rcx
  8177f6:	00 00 00 
  8177f9:	48 ba 79 2e 82 00 00 	movabs $0x822e79,%rdx
  817800:	00 00 00 
  817803:	be 46 00 00 00       	mov    $0x46,%esi
  817808:	48 bf 8e 2e 82 00 00 	movabs $0x822e8e,%rdi
  81780f:	00 00 00 
  817812:	b8 00 00 00 00       	mov    $0x0,%eax
  817817:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  81781e:	00 00 00 
  817821:	41 ff d0             	callq  *%r8
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  817824:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  81782b:	00 00 00 
  81782e:	48 8b 00             	mov    (%rax),%rax
  817831:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!mbe) {
  817835:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81783a:	75 25                	jne    817861 <sys_mbox_new+0x83>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  81783c:	48 bf b0 2e 82 00 00 	movabs $0x822eb0,%rdi
  817843:	00 00 00 
  817846:	b8 00 00 00 00       	mov    $0x0,%eax
  81784b:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  817852:	00 00 00 
  817855:	ff d2                	callq  *%rdx
	return SYS_MBOX_NULL;
  817857:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81785c:	e9 5f 01 00 00       	jmpq   8179c0 <sys_mbox_new+0x1e2>
    }
    LIST_REMOVE(mbe, link);
  817861:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817865:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  81786c:	48 85 c0             	test   %rax,%rax
  81786f:	74 1d                	je     81788e <sys_mbox_new+0xb0>
  817871:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817875:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  81787c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817880:	48 8b 92 20 01 00 00 	mov    0x120(%rdx),%rdx
  817887:	48 89 90 20 01 00 00 	mov    %rdx,0x120(%rax)
  81788e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817892:	48 8b 80 20 01 00 00 	mov    0x120(%rax),%rax
  817899:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81789d:	48 8b 92 18 01 00 00 	mov    0x118(%rdx),%rdx
  8178a4:	48 89 10             	mov    %rdx,(%rax)
    assert(mbe->freed);
  8178a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8178ab:	8b 00                	mov    (%rax),%eax
  8178ad:	85 c0                	test   %eax,%eax
  8178af:	75 35                	jne    8178e6 <sys_mbox_new+0x108>
  8178b1:	48 b9 d6 2e 82 00 00 	movabs $0x822ed6,%rcx
  8178b8:	00 00 00 
  8178bb:	48 ba 79 2e 82 00 00 	movabs $0x822e79,%rdx
  8178c2:	00 00 00 
  8178c5:	be 4d 00 00 00       	mov    $0x4d,%esi
  8178ca:	48 bf 8e 2e 82 00 00 	movabs $0x822e8e,%rdi
  8178d1:	00 00 00 
  8178d4:	b8 00 00 00 00       	mov    $0x0,%eax
  8178d9:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  8178e0:	00 00 00 
  8178e3:	41 ff d0             	callq  *%r8
    mbe->freed = 0;
  8178e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8178ea:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

    int i = mbe - &mboxes[0];
  8178f0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8178f4:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  8178fb:	00 00 00 
  8178fe:	48 29 c2             	sub    %rax,%rdx
  817901:	48 89 d0             	mov    %rdx,%rax
  817904:	48 c1 f8 03          	sar    $0x3,%rax
  817908:	48 89 c2             	mov    %rax,%rdx
  81790b:	48 b8 ad 1b 4c 91 cf 	movabs $0x14c1bacf914c1bad,%rax
  817912:	ba c1 14 
  817915:	48 0f af c2          	imul   %rdx,%rax
  817919:	89 45 f4             	mov    %eax,-0xc(%rbp)
    mbe->head = -1;
  81791c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817920:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%rax)
    mbe->nextq = 0;
  817927:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81792b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
    mbe->queued_msg = sys_sem_new(0);
  817932:	bf 00 00 00 00       	mov    $0x0,%edi
  817937:	48 b8 e1 7e 81 00 00 	movabs $0x817ee1,%rax
  81793e:	00 00 00 
  817941:	ff d0                	callq  *%rax
  817943:	89 c2                	mov    %eax,%edx
  817945:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817949:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  81794f:	bf 20 00 00 00       	mov    $0x20,%edi
  817954:	48 b8 e1 7e 81 00 00 	movabs $0x817ee1,%rax
  81795b:	00 00 00 
  81795e:	ff d0                	callq  *%rax
  817960:	89 c2                	mov    %eax,%edx
  817962:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817966:	89 90 14 01 00 00    	mov    %edx,0x114(%rax)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  81796c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817970:	8b 80 10 01 00 00    	mov    0x110(%rax),%eax
  817976:	83 f8 ff             	cmp    $0xffffffff,%eax
  817979:	74 0f                	je     81798a <sys_mbox_new+0x1ac>
	mbe->free_msg == SYS_SEM_NULL)
  81797b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81797f:	8b 80 14 01 00 00    	mov    0x114(%rax),%eax
    mbe->head = -1;
    mbe->nextq = 0;
    mbe->queued_msg = sys_sem_new(0);
    mbe->free_msg = sys_sem_new(MBOXSLOTS);

    if (mbe->queued_msg == SYS_SEM_NULL ||
  817985:	83 f8 ff             	cmp    $0xffffffff,%eax
  817988:	75 33                	jne    8179bd <sys_mbox_new+0x1df>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  81798a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81798d:	89 c7                	mov    %eax,%edi
  81798f:	48 b8 c2 79 81 00 00 	movabs $0x8179c2,%rax
  817996:	00 00 00 
  817999:	ff d0                	callq  *%rax
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  81799b:	48 bf e8 2e 82 00 00 	movabs $0x822ee8,%rdi
  8179a2:	00 00 00 
  8179a5:	b8 00 00 00 00       	mov    $0x0,%eax
  8179aa:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8179b1:	00 00 00 
  8179b4:	ff d2                	callq  *%rdx
	return SYS_MBOX_NULL;
  8179b6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8179bb:	eb 03                	jmp    8179c0 <sys_mbox_new+0x1e2>
    }
    return i;
  8179bd:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  8179c0:	c9                   	leaveq 
  8179c1:	c3                   	retq   

00000000008179c2 <sys_mbox_free>:

void
sys_mbox_free(sys_mbox_t mbox)
{
  8179c2:	55                   	push   %rbp
  8179c3:	48 89 e5             	mov    %rsp,%rbp
  8179c6:	48 83 ec 10          	sub    $0x10,%rsp
  8179ca:	89 7d fc             	mov    %edi,-0x4(%rbp)
    assert(!mboxes[mbox].freed);
  8179cd:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8179d4:	00 00 00 
  8179d7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8179da:	48 63 d0             	movslq %eax,%rdx
  8179dd:	48 89 d0             	mov    %rdx,%rax
  8179e0:	48 c1 e0 03          	shl    $0x3,%rax
  8179e4:	48 01 d0             	add    %rdx,%rax
  8179e7:	48 c1 e0 02          	shl    $0x2,%rax
  8179eb:	48 01 d0             	add    %rdx,%rax
  8179ee:	48 c1 e0 03          	shl    $0x3,%rax
  8179f2:	48 01 c8             	add    %rcx,%rax
  8179f5:	8b 00                	mov    (%rax),%eax
  8179f7:	85 c0                	test   %eax,%eax
  8179f9:	74 35                	je     817a30 <sys_mbox_free+0x6e>
  8179fb:	48 b9 11 2f 82 00 00 	movabs $0x822f11,%rcx
  817a02:	00 00 00 
  817a05:	48 ba 79 2e 82 00 00 	movabs $0x822e79,%rdx
  817a0c:	00 00 00 
  817a0f:	be 63 00 00 00       	mov    $0x63,%esi
  817a14:	48 bf 8e 2e 82 00 00 	movabs $0x822e8e,%rdi
  817a1b:	00 00 00 
  817a1e:	b8 00 00 00 00       	mov    $0x0,%eax
  817a23:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  817a2a:	00 00 00 
  817a2d:	41 ff d0             	callq  *%r8
    sys_sem_free(mboxes[mbox].queued_msg);
  817a30:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817a37:	00 00 00 
  817a3a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817a3d:	48 63 d0             	movslq %eax,%rdx
  817a40:	48 89 d0             	mov    %rdx,%rax
  817a43:	48 c1 e0 03          	shl    $0x3,%rax
  817a47:	48 01 d0             	add    %rdx,%rax
  817a4a:	48 c1 e0 02          	shl    $0x2,%rax
  817a4e:	48 01 d0             	add    %rdx,%rax
  817a51:	48 c1 e0 03          	shl    $0x3,%rax
  817a55:	48 01 c8             	add    %rcx,%rax
  817a58:	48 05 10 01 00 00    	add    $0x110,%rax
  817a5e:	8b 00                	mov    (%rax),%eax
  817a60:	89 c7                	mov    %eax,%edi
  817a62:	48 b8 df 7f 81 00 00 	movabs $0x817fdf,%rax
  817a69:	00 00 00 
  817a6c:	ff d0                	callq  *%rax
    sys_sem_free(mboxes[mbox].free_msg);
  817a6e:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817a75:	00 00 00 
  817a78:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817a7b:	48 63 d0             	movslq %eax,%rdx
  817a7e:	48 89 d0             	mov    %rdx,%rax
  817a81:	48 c1 e0 03          	shl    $0x3,%rax
  817a85:	48 01 d0             	add    %rdx,%rax
  817a88:	48 c1 e0 02          	shl    $0x2,%rax
  817a8c:	48 01 d0             	add    %rdx,%rax
  817a8f:	48 c1 e0 03          	shl    $0x3,%rax
  817a93:	48 01 c8             	add    %rcx,%rax
  817a96:	48 05 14 01 00 00    	add    $0x114,%rax
  817a9c:	8b 00                	mov    (%rax),%eax
  817a9e:	89 c7                	mov    %eax,%edi
  817aa0:	48 b8 df 7f 81 00 00 	movabs $0x817fdf,%rax
  817aa7:	00 00 00 
  817aaa:	ff d0                	callq  *%rax
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  817aac:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817ab3:	00 00 00 
  817ab6:	48 8b 08             	mov    (%rax),%rcx
  817ab9:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  817ac0:	00 00 00 
  817ac3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817ac6:	48 63 d0             	movslq %eax,%rdx
  817ac9:	48 89 d0             	mov    %rdx,%rax
  817acc:	48 c1 e0 03          	shl    $0x3,%rax
  817ad0:	48 01 d0             	add    %rdx,%rax
  817ad3:	48 c1 e0 02          	shl    $0x2,%rax
  817ad7:	48 01 d0             	add    %rdx,%rax
  817ada:	48 c1 e0 03          	shl    $0x3,%rax
  817ade:	48 01 f0             	add    %rsi,%rax
  817ae1:	48 05 18 01 00 00    	add    $0x118,%rax
  817ae7:	48 89 08             	mov    %rcx,(%rax)
  817aea:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817af1:	00 00 00 
  817af4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817af7:	48 63 d0             	movslq %eax,%rdx
  817afa:	48 89 d0             	mov    %rdx,%rax
  817afd:	48 c1 e0 03          	shl    $0x3,%rax
  817b01:	48 01 d0             	add    %rdx,%rax
  817b04:	48 c1 e0 02          	shl    $0x2,%rax
  817b08:	48 01 d0             	add    %rdx,%rax
  817b0b:	48 c1 e0 03          	shl    $0x3,%rax
  817b0f:	48 01 c8             	add    %rcx,%rax
  817b12:	48 05 18 01 00 00    	add    $0x118,%rax
  817b18:	48 8b 00             	mov    (%rax),%rax
  817b1b:	48 85 c0             	test   %rax,%rax
  817b1e:	74 47                	je     817b67 <sys_mbox_free+0x1a5>
  817b20:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817b27:	00 00 00 
  817b2a:	48 8b 08             	mov    (%rax),%rcx
  817b2d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817b30:	48 63 d0             	movslq %eax,%rdx
  817b33:	48 89 d0             	mov    %rdx,%rax
  817b36:	48 c1 e0 03          	shl    $0x3,%rax
  817b3a:	48 01 d0             	add    %rdx,%rax
  817b3d:	48 c1 e0 02          	shl    $0x2,%rax
  817b41:	48 01 d0             	add    %rdx,%rax
  817b44:	48 c1 e0 03          	shl    $0x3,%rax
  817b48:	48 8d 90 10 01 00 00 	lea    0x110(%rax),%rdx
  817b4f:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  817b56:	00 00 00 
  817b59:	48 01 d0             	add    %rdx,%rax
  817b5c:	48 83 c0 08          	add    $0x8,%rax
  817b60:	48 89 81 20 01 00 00 	mov    %rax,0x120(%rcx)
  817b67:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817b6a:	48 63 d0             	movslq %eax,%rdx
  817b6d:	48 89 d0             	mov    %rdx,%rax
  817b70:	48 c1 e0 03          	shl    $0x3,%rax
  817b74:	48 01 d0             	add    %rdx,%rax
  817b77:	48 c1 e0 02          	shl    $0x2,%rax
  817b7b:	48 01 d0             	add    %rdx,%rax
  817b7e:	48 c1 e0 03          	shl    $0x3,%rax
  817b82:	48 ba 40 d8 b4 00 00 	movabs $0xb4d840,%rdx
  817b89:	00 00 00 
  817b8c:	48 01 c2             	add    %rax,%rdx
  817b8f:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817b96:	00 00 00 
  817b99:	48 89 10             	mov    %rdx,(%rax)
  817b9c:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817ba3:	00 00 00 
  817ba6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817ba9:	48 63 d0             	movslq %eax,%rdx
  817bac:	48 89 d0             	mov    %rdx,%rax
  817baf:	48 c1 e0 03          	shl    $0x3,%rax
  817bb3:	48 01 d0             	add    %rdx,%rax
  817bb6:	48 c1 e0 02          	shl    $0x2,%rax
  817bba:	48 01 d0             	add    %rdx,%rax
  817bbd:	48 c1 e0 03          	shl    $0x3,%rax
  817bc1:	48 01 c8             	add    %rcx,%rax
  817bc4:	48 05 20 01 00 00    	add    $0x120,%rax
  817bca:	48 be 40 6c b5 00 00 	movabs $0xb56c40,%rsi
  817bd1:	00 00 00 
  817bd4:	48 89 30             	mov    %rsi,(%rax)
    mboxes[mbox].freed = 1;
  817bd7:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817bde:	00 00 00 
  817be1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817be4:	48 63 d0             	movslq %eax,%rdx
  817be7:	48 89 d0             	mov    %rdx,%rax
  817bea:	48 c1 e0 03          	shl    $0x3,%rax
  817bee:	48 01 d0             	add    %rdx,%rax
  817bf1:	48 c1 e0 02          	shl    $0x2,%rax
  817bf5:	48 01 d0             	add    %rdx,%rax
  817bf8:	48 c1 e0 03          	shl    $0x3,%rax
  817bfc:	48 01 c8             	add    %rcx,%rax
  817bff:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
}
  817c05:	90                   	nop
  817c06:	c9                   	leaveq 
  817c07:	c3                   	retq   

0000000000817c08 <sys_mbox_post>:

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  817c08:	55                   	push   %rbp
  817c09:	48 89 e5             	mov    %rsp,%rbp
  817c0c:	48 83 ec 10          	sub    $0x10,%rsp
  817c10:	89 7d fc             	mov    %edi,-0x4(%rbp)
  817c13:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  817c17:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  817c1b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817c1e:	48 89 d6             	mov    %rdx,%rsi
  817c21:	89 c7                	mov    %eax,%edi
  817c23:	48 b8 6b 7c 81 00 00 	movabs $0x817c6b,%rax
  817c2a:	00 00 00 
  817c2d:	ff d0                	callq  *%rax
  817c2f:	84 c0                	test   %al,%al
  817c31:	74 35                	je     817c68 <sys_mbox_post+0x60>
  817c33:	48 b9 28 2f 82 00 00 	movabs $0x822f28,%rcx
  817c3a:	00 00 00 
  817c3d:	48 ba 79 2e 82 00 00 	movabs $0x822e79,%rdx
  817c44:	00 00 00 
  817c47:	be 6d 00 00 00       	mov    $0x6d,%esi
  817c4c:	48 bf 8e 2e 82 00 00 	movabs $0x822e8e,%rdi
  817c53:	00 00 00 
  817c56:	b8 00 00 00 00       	mov    $0x0,%eax
  817c5b:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  817c62:	00 00 00 
  817c65:	41 ff d0             	callq  *%r8
}
  817c68:	90                   	nop
  817c69:	c9                   	leaveq 
  817c6a:	c3                   	retq   

0000000000817c6b <sys_mbox_trypost>:

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  817c6b:	55                   	push   %rbp
  817c6c:	48 89 e5             	mov    %rsp,%rbp
  817c6f:	48 83 ec 20          	sub    $0x20,%rsp
  817c73:	89 7d ec             	mov    %edi,-0x14(%rbp)
  817c76:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    assert(!mboxes[mbox].freed);
  817c7a:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817c81:	00 00 00 
  817c84:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817c87:	48 63 d0             	movslq %eax,%rdx
  817c8a:	48 89 d0             	mov    %rdx,%rax
  817c8d:	48 c1 e0 03          	shl    $0x3,%rax
  817c91:	48 01 d0             	add    %rdx,%rax
  817c94:	48 c1 e0 02          	shl    $0x2,%rax
  817c98:	48 01 d0             	add    %rdx,%rax
  817c9b:	48 c1 e0 03          	shl    $0x3,%rax
  817c9f:	48 01 c8             	add    %rcx,%rax
  817ca2:	8b 00                	mov    (%rax),%eax
  817ca4:	85 c0                	test   %eax,%eax
  817ca6:	74 35                	je     817cdd <sys_mbox_trypost+0x72>
  817ca8:	48 b9 11 2f 82 00 00 	movabs $0x822f11,%rcx
  817caf:	00 00 00 
  817cb2:	48 ba 79 2e 82 00 00 	movabs $0x822e79,%rdx
  817cb9:	00 00 00 
  817cbc:	be 73 00 00 00       	mov    $0x73,%esi
  817cc1:	48 bf 8e 2e 82 00 00 	movabs $0x822e8e,%rdi
  817cc8:	00 00 00 
  817ccb:	b8 00 00 00 00       	mov    $0x0,%eax
  817cd0:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  817cd7:	00 00 00 
  817cda:	41 ff d0             	callq  *%r8

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  817cdd:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817ce4:	00 00 00 
  817ce7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817cea:	48 63 d0             	movslq %eax,%rdx
  817ced:	48 89 d0             	mov    %rdx,%rax
  817cf0:	48 c1 e0 03          	shl    $0x3,%rax
  817cf4:	48 01 d0             	add    %rdx,%rax
  817cf7:	48 c1 e0 02          	shl    $0x2,%rax
  817cfb:	48 01 d0             	add    %rdx,%rax
  817cfe:	48 c1 e0 03          	shl    $0x3,%rax
  817d02:	48 01 c8             	add    %rcx,%rax
  817d05:	48 05 14 01 00 00    	add    $0x114,%rax
  817d0b:	8b 00                	mov    (%rax),%eax
  817d0d:	be 00 00 00 00       	mov    $0x0,%esi
  817d12:	89 c7                	mov    %eax,%edi
  817d14:	48 b8 6f 82 81 00 00 	movabs $0x81826f,%rax
  817d1b:	00 00 00 
  817d1e:	ff d0                	callq  *%rax
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  817d20:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817d27:	00 00 00 
  817d2a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817d2d:	48 63 d0             	movslq %eax,%rdx
  817d30:	48 89 d0             	mov    %rdx,%rax
  817d33:	48 c1 e0 03          	shl    $0x3,%rax
  817d37:	48 01 d0             	add    %rdx,%rax
  817d3a:	48 c1 e0 02          	shl    $0x2,%rax
  817d3e:	48 01 d0             	add    %rdx,%rax
  817d41:	48 c1 e0 03          	shl    $0x3,%rax
  817d45:	48 01 c8             	add    %rcx,%rax
  817d48:	48 83 c0 08          	add    $0x8,%rax
  817d4c:	8b 08                	mov    (%rax),%ecx
  817d4e:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  817d55:	00 00 00 
  817d58:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817d5b:	48 63 d0             	movslq %eax,%rdx
  817d5e:	48 89 d0             	mov    %rdx,%rax
  817d61:	48 c1 e0 03          	shl    $0x3,%rax
  817d65:	48 01 d0             	add    %rdx,%rax
  817d68:	48 c1 e0 02          	shl    $0x2,%rax
  817d6c:	48 01 d0             	add    %rdx,%rax
  817d6f:	48 c1 e0 03          	shl    $0x3,%rax
  817d73:	48 01 f0             	add    %rsi,%rax
  817d76:	48 83 c0 04          	add    $0x4,%rax
  817d7a:	8b 00                	mov    (%rax),%eax
  817d7c:	39 c1                	cmp    %eax,%ecx
  817d7e:	75 0a                	jne    817d8a <sys_mbox_trypost+0x11f>
	return ERR_MEM;
  817d80:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817d85:	e9 55 01 00 00       	jmpq   817edf <sys_mbox_trypost+0x274>

    int slot = mboxes[mbox].nextq;
  817d8a:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817d91:	00 00 00 
  817d94:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817d97:	48 63 d0             	movslq %eax,%rdx
  817d9a:	48 89 d0             	mov    %rdx,%rax
  817d9d:	48 c1 e0 03          	shl    $0x3,%rax
  817da1:	48 01 d0             	add    %rdx,%rax
  817da4:	48 c1 e0 02          	shl    $0x2,%rax
  817da8:	48 01 d0             	add    %rdx,%rax
  817dab:	48 c1 e0 03          	shl    $0x3,%rax
  817daf:	48 01 c8             	add    %rcx,%rax
  817db2:	48 83 c0 08          	add    $0x8,%rax
  817db6:	8b 00                	mov    (%rax),%eax
  817db8:	89 45 fc             	mov    %eax,-0x4(%rbp)
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  817dbb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817dbe:	8d 50 01             	lea    0x1(%rax),%edx
  817dc1:	89 d0                	mov    %edx,%eax
  817dc3:	c1 f8 1f             	sar    $0x1f,%eax
  817dc6:	c1 e8 1b             	shr    $0x1b,%eax
  817dc9:	01 c2                	add    %eax,%edx
  817dcb:	83 e2 1f             	and    $0x1f,%edx
  817dce:	29 c2                	sub    %eax,%edx
  817dd0:	89 d0                	mov    %edx,%eax
  817dd2:	89 c6                	mov    %eax,%esi
  817dd4:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817ddb:	00 00 00 
  817dde:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817de1:	48 63 d0             	movslq %eax,%rdx
  817de4:	48 89 d0             	mov    %rdx,%rax
  817de7:	48 c1 e0 03          	shl    $0x3,%rax
  817deb:	48 01 d0             	add    %rdx,%rax
  817dee:	48 c1 e0 02          	shl    $0x2,%rax
  817df2:	48 01 d0             	add    %rdx,%rax
  817df5:	48 c1 e0 03          	shl    $0x3,%rax
  817df9:	48 01 c8             	add    %rcx,%rax
  817dfc:	48 83 c0 08          	add    $0x8,%rax
  817e00:	89 30                	mov    %esi,(%rax)
    mboxes[mbox].msg[slot] = msg;
  817e02:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817e09:	00 00 00 
  817e0c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817e0f:	48 63 f0             	movslq %eax,%rsi
  817e12:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817e15:	48 63 d0             	movslq %eax,%rdx
  817e18:	48 89 d0             	mov    %rdx,%rax
  817e1b:	48 c1 e0 03          	shl    $0x3,%rax
  817e1f:	48 01 d0             	add    %rdx,%rax
  817e22:	48 c1 e0 02          	shl    $0x2,%rax
  817e26:	48 01 d0             	add    %rdx,%rax
  817e29:	48 01 f0             	add    %rsi,%rax
  817e2c:	48 8d 50 02          	lea    0x2(%rax),%rdx
  817e30:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817e34:	48 89 04 d1          	mov    %rax,(%rcx,%rdx,8)

    if (mboxes[mbox].head == -1)
  817e38:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817e3f:	00 00 00 
  817e42:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817e45:	48 63 d0             	movslq %eax,%rdx
  817e48:	48 89 d0             	mov    %rdx,%rax
  817e4b:	48 c1 e0 03          	shl    $0x3,%rax
  817e4f:	48 01 d0             	add    %rdx,%rax
  817e52:	48 c1 e0 02          	shl    $0x2,%rax
  817e56:	48 01 d0             	add    %rdx,%rax
  817e59:	48 c1 e0 03          	shl    $0x3,%rax
  817e5d:	48 01 c8             	add    %rcx,%rax
  817e60:	48 83 c0 04          	add    $0x4,%rax
  817e64:	8b 00                	mov    (%rax),%eax
  817e66:	83 f8 ff             	cmp    $0xffffffff,%eax
  817e69:	75 31                	jne    817e9c <sys_mbox_trypost+0x231>
	mboxes[mbox].head = slot;
  817e6b:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817e72:	00 00 00 
  817e75:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817e78:	48 63 d0             	movslq %eax,%rdx
  817e7b:	48 89 d0             	mov    %rdx,%rax
  817e7e:	48 c1 e0 03          	shl    $0x3,%rax
  817e82:	48 01 d0             	add    %rdx,%rax
  817e85:	48 c1 e0 02          	shl    $0x2,%rax
  817e89:	48 01 d0             	add    %rdx,%rax
  817e8c:	48 c1 e0 03          	shl    $0x3,%rax
  817e90:	48 01 c8             	add    %rcx,%rax
  817e93:	48 8d 50 04          	lea    0x4(%rax),%rdx
  817e97:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817e9a:	89 02                	mov    %eax,(%rdx)

    sys_sem_signal(mboxes[mbox].queued_msg);
  817e9c:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817ea3:	00 00 00 
  817ea6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817ea9:	48 63 d0             	movslq %eax,%rdx
  817eac:	48 89 d0             	mov    %rdx,%rax
  817eaf:	48 c1 e0 03          	shl    $0x3,%rax
  817eb3:	48 01 d0             	add    %rdx,%rax
  817eb6:	48 c1 e0 02          	shl    $0x2,%rax
  817eba:	48 01 d0             	add    %rdx,%rax
  817ebd:	48 c1 e0 03          	shl    $0x3,%rax
  817ec1:	48 01 c8             	add    %rcx,%rax
  817ec4:	48 05 10 01 00 00    	add    $0x110,%rax
  817eca:	8b 00                	mov    (%rax),%eax
  817ecc:	89 c7                	mov    %eax,%edi
  817ece:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  817ed5:	00 00 00 
  817ed8:	ff d0                	callq  *%rax

    return ERR_OK;
  817eda:	b8 00 00 00 00       	mov    $0x0,%eax
}
  817edf:	c9                   	leaveq 
  817ee0:	c3                   	retq   

0000000000817ee1 <sys_sem_new>:

sys_sem_t
sys_sem_new(u8_t count)
{
  817ee1:	55                   	push   %rbp
  817ee2:	48 89 e5             	mov    %rsp,%rbp
  817ee5:	48 83 ec 20          	sub    $0x20,%rsp
  817ee9:	89 f8                	mov    %edi,%eax
  817eeb:	88 45 ec             	mov    %al,-0x14(%rbp)
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  817eee:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817ef5:	00 00 00 
  817ef8:	48 8b 00             	mov    (%rax),%rax
  817efb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!se) {
  817eff:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  817f04:	75 25                	jne    817f2b <sys_sem_new+0x4a>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  817f06:	48 bf 50 2f 82 00 00 	movabs $0x822f50,%rdi
  817f0d:	00 00 00 
  817f10:	b8 00 00 00 00       	mov    $0x0,%eax
  817f15:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  817f1c:	00 00 00 
  817f1f:	ff d2                	callq  *%rdx
	return SYS_SEM_NULL;
  817f21:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817f26:	e9 b2 00 00 00       	jmpq   817fdd <sys_sem_new+0xfc>
    }
    LIST_REMOVE(se, link);
  817f2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817f2f:	48 8b 40 10          	mov    0x10(%rax),%rax
  817f33:	48 85 c0             	test   %rax,%rax
  817f36:	74 14                	je     817f4c <sys_sem_new+0x6b>
  817f38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817f3c:	48 8b 40 10          	mov    0x10(%rax),%rax
  817f40:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817f44:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  817f48:	48 89 50 18          	mov    %rdx,0x18(%rax)
  817f4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817f50:	48 8b 40 18          	mov    0x18(%rax),%rax
  817f54:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817f58:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  817f5c:	48 89 10             	mov    %rdx,(%rax)
    assert(se->freed);
  817f5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817f63:	8b 00                	mov    (%rax),%eax
  817f65:	85 c0                	test   %eax,%eax
  817f67:	75 35                	jne    817f9e <sys_sem_new+0xbd>
  817f69:	48 b9 76 2f 82 00 00 	movabs $0x822f76,%rcx
  817f70:	00 00 00 
  817f73:	48 ba 79 2e 82 00 00 	movabs $0x822e79,%rdx
  817f7a:	00 00 00 
  817f7d:	be 8e 00 00 00       	mov    $0x8e,%esi
  817f82:	48 bf 8e 2e 82 00 00 	movabs $0x822e8e,%rdi
  817f89:	00 00 00 
  817f8c:	b8 00 00 00 00       	mov    $0x0,%eax
  817f91:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  817f98:	00 00 00 
  817f9b:	41 ff d0             	callq  *%r8
    se->freed = 0;
  817f9e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817fa2:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

    se->counter = count;
  817fa8:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  817fac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817fb0:	66 89 50 08          	mov    %dx,0x8(%rax)
    se->gen++;
  817fb4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817fb8:	8b 40 04             	mov    0x4(%rax),%eax
  817fbb:	8d 50 01             	lea    0x1(%rax),%edx
  817fbe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817fc2:	89 50 04             	mov    %edx,0x4(%rax)
    return se - &sems[0];
  817fc5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817fc9:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817fd0:	00 00 00 
  817fd3:	48 29 c2             	sub    %rax,%rdx
  817fd6:	48 89 d0             	mov    %rdx,%rax
  817fd9:	48 c1 f8 05          	sar    $0x5,%rax
}
  817fdd:	c9                   	leaveq 
  817fde:	c3                   	retq   

0000000000817fdf <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  817fdf:	55                   	push   %rbp
  817fe0:	48 89 e5             	mov    %rsp,%rbp
  817fe3:	48 83 ec 10          	sub    $0x10,%rsp
  817fe7:	89 7d fc             	mov    %edi,-0x4(%rbp)
    assert(!sems[sem].freed);
  817fea:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817ff1:	00 00 00 
  817ff4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817ff7:	48 63 d2             	movslq %edx,%rdx
  817ffa:	48 c1 e2 05          	shl    $0x5,%rdx
  817ffe:	48 01 d0             	add    %rdx,%rax
  818001:	8b 00                	mov    (%rax),%eax
  818003:	85 c0                	test   %eax,%eax
  818005:	74 35                	je     81803c <sys_sem_free+0x5d>
  818007:	48 b9 80 2f 82 00 00 	movabs $0x822f80,%rcx
  81800e:	00 00 00 
  818011:	48 ba 79 2e 82 00 00 	movabs $0x822e79,%rdx
  818018:	00 00 00 
  81801b:	be 99 00 00 00       	mov    $0x99,%esi
  818020:	48 bf 8e 2e 82 00 00 	movabs $0x822e8e,%rdi
  818027:	00 00 00 
  81802a:	b8 00 00 00 00       	mov    $0x0,%eax
  81802f:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  818036:	00 00 00 
  818039:	41 ff d0             	callq  *%r8
    sems[sem].freed = 1;
  81803c:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818043:	00 00 00 
  818046:	8b 55 fc             	mov    -0x4(%rbp),%edx
  818049:	48 63 d2             	movslq %edx,%rdx
  81804c:	48 c1 e2 05          	shl    $0x5,%rdx
  818050:	48 01 d0             	add    %rdx,%rax
  818053:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    sems[sem].gen++;
  818059:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818060:	00 00 00 
  818063:	8b 55 fc             	mov    -0x4(%rbp),%edx
  818066:	48 63 d2             	movslq %edx,%rdx
  818069:	48 c1 e2 05          	shl    $0x5,%rdx
  81806d:	48 01 d0             	add    %rdx,%rax
  818070:	48 83 c0 04          	add    $0x4,%rax
  818074:	8b 00                	mov    (%rax),%eax
  818076:	8d 50 01             	lea    0x1(%rax),%edx
  818079:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818080:	00 00 00 
  818083:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  818086:	48 63 c9             	movslq %ecx,%rcx
  818089:	48 c1 e1 05          	shl    $0x5,%rcx
  81808d:	48 01 c8             	add    %rcx,%rax
  818090:	48 83 c0 04          	add    $0x4,%rax
  818094:	89 10                	mov    %edx,(%rax)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  818096:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  81809d:	00 00 00 
  8180a0:	48 8b 00             	mov    (%rax),%rax
  8180a3:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  8180aa:	00 00 00 
  8180ad:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8180b0:	48 63 c9             	movslq %ecx,%rcx
  8180b3:	48 c1 e1 05          	shl    $0x5,%rcx
  8180b7:	48 01 ca             	add    %rcx,%rdx
  8180ba:	48 83 c2 10          	add    $0x10,%rdx
  8180be:	48 89 02             	mov    %rax,(%rdx)
  8180c1:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8180c8:	00 00 00 
  8180cb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8180ce:	48 63 d2             	movslq %edx,%rdx
  8180d1:	48 c1 e2 05          	shl    $0x5,%rdx
  8180d5:	48 01 d0             	add    %rdx,%rax
  8180d8:	48 83 c0 10          	add    $0x10,%rax
  8180dc:	48 8b 00             	mov    (%rax),%rax
  8180df:	48 85 c0             	test   %rax,%rax
  8180e2:	74 2c                	je     818110 <sys_sem_free+0x131>
  8180e4:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  8180eb:	00 00 00 
  8180ee:	48 8b 00             	mov    (%rax),%rax
  8180f1:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8180f4:	48 63 d2             	movslq %edx,%rdx
  8180f7:	48 c1 e2 05          	shl    $0x5,%rdx
  8180fb:	48 8d 4a 10          	lea    0x10(%rdx),%rcx
  8180ff:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  818106:	00 00 00 
  818109:	48 01 ca             	add    %rcx,%rdx
  81810c:	48 89 50 18          	mov    %rdx,0x18(%rax)
  818110:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818113:	48 98                	cltq   
  818115:	48 c1 e0 05          	shl    $0x5,%rax
  818119:	48 89 c2             	mov    %rax,%rdx
  81811c:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818123:	00 00 00 
  818126:	48 01 c2             	add    %rax,%rdx
  818129:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  818130:	00 00 00 
  818133:	48 89 10             	mov    %rdx,(%rax)
  818136:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  81813d:	00 00 00 
  818140:	8b 55 fc             	mov    -0x4(%rbp),%edx
  818143:	48 63 d2             	movslq %edx,%rdx
  818146:	48 c1 e2 05          	shl    $0x5,%rdx
  81814a:	48 01 d0             	add    %rdx,%rax
  81814d:	48 83 c0 18          	add    $0x18,%rax
  818151:	48 be 20 d8 b4 00 00 	movabs $0xb4d820,%rsi
  818158:	00 00 00 
  81815b:	48 89 30             	mov    %rsi,(%rax)
}
  81815e:	90                   	nop
  81815f:	c9                   	leaveq 
  818160:	c3                   	retq   

0000000000818161 <sys_sem_signal>:

void
sys_sem_signal(sys_sem_t sem)
{
  818161:	55                   	push   %rbp
  818162:	48 89 e5             	mov    %rsp,%rbp
  818165:	48 83 ec 10          	sub    $0x10,%rsp
  818169:	89 7d fc             	mov    %edi,-0x4(%rbp)
    assert(!sems[sem].freed);
  81816c:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818173:	00 00 00 
  818176:	8b 55 fc             	mov    -0x4(%rbp),%edx
  818179:	48 63 d2             	movslq %edx,%rdx
  81817c:	48 c1 e2 05          	shl    $0x5,%rdx
  818180:	48 01 d0             	add    %rdx,%rax
  818183:	8b 00                	mov    (%rax),%eax
  818185:	85 c0                	test   %eax,%eax
  818187:	74 35                	je     8181be <sys_sem_signal+0x5d>
  818189:	48 b9 80 2f 82 00 00 	movabs $0x822f80,%rcx
  818190:	00 00 00 
  818193:	48 ba 79 2e 82 00 00 	movabs $0x822e79,%rdx
  81819a:	00 00 00 
  81819d:	be a2 00 00 00       	mov    $0xa2,%esi
  8181a2:	48 bf 8e 2e 82 00 00 	movabs $0x822e8e,%rdi
  8181a9:	00 00 00 
  8181ac:	b8 00 00 00 00       	mov    $0x0,%eax
  8181b1:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  8181b8:	00 00 00 
  8181bb:	41 ff d0             	callq  *%r8
    sems[sem].counter++;
  8181be:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8181c5:	00 00 00 
  8181c8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8181cb:	48 63 d2             	movslq %edx,%rdx
  8181ce:	48 c1 e2 05          	shl    $0x5,%rdx
  8181d2:	48 01 d0             	add    %rdx,%rax
  8181d5:	48 83 c0 08          	add    $0x8,%rax
  8181d9:	0f b7 00             	movzwl (%rax),%eax
  8181dc:	8d 50 01             	lea    0x1(%rax),%edx
  8181df:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8181e6:	00 00 00 
  8181e9:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8181ec:	48 63 c9             	movslq %ecx,%rcx
  8181ef:	48 c1 e1 05          	shl    $0x5,%rcx
  8181f3:	48 01 c8             	add    %rcx,%rax
  8181f6:	48 83 c0 08          	add    $0x8,%rax
  8181fa:	66 89 10             	mov    %dx,(%rax)
    if (sems[sem].waiters) {
  8181fd:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818204:	00 00 00 
  818207:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81820a:	48 63 d2             	movslq %edx,%rdx
  81820d:	48 c1 e2 05          	shl    $0x5,%rdx
  818211:	48 01 d0             	add    %rdx,%rax
  818214:	48 83 c0 0a          	add    $0xa,%rax
  818218:	0f b7 00             	movzwl (%rax),%eax
  81821b:	66 85 c0             	test   %ax,%ax
  81821e:	74 4c                	je     81826c <sys_sem_signal+0x10b>
	sems[sem].waiters = 0;
  818220:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818227:	00 00 00 
  81822a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81822d:	48 63 d2             	movslq %edx,%rdx
  818230:	48 c1 e2 05          	shl    $0x5,%rdx
  818234:	48 01 d0             	add    %rdx,%rax
  818237:	48 83 c0 0a          	add    $0xa,%rax
  81823b:	66 c7 00 00 00       	movw   $0x0,(%rax)
	thread_wakeup(&sems[sem].v);
  818240:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818243:	48 98                	cltq   
  818245:	48 c1 e0 05          	shl    $0x5,%rax
  818249:	48 89 c2             	mov    %rax,%rdx
  81824c:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818253:	00 00 00 
  818256:	48 01 d0             	add    %rdx,%rax
  818259:	48 83 c0 08          	add    $0x8,%rax
  81825d:	48 89 c7             	mov    %rax,%rdi
  818260:	48 b8 10 8d 81 00 00 	movabs $0x818d10,%rax
  818267:	00 00 00 
  81826a:	ff d0                	callq  *%rax
    }
}
  81826c:	90                   	nop
  81826d:	c9                   	leaveq 
  81826e:	c3                   	retq   

000000000081826f <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  81826f:	55                   	push   %rbp
  818270:	48 89 e5             	mov    %rsp,%rbp
  818273:	48 83 ec 30          	sub    $0x30,%rsp
  818277:	89 7d dc             	mov    %edi,-0x24(%rbp)
  81827a:	89 75 d8             	mov    %esi,-0x28(%rbp)
    assert(!sems[sem].freed);
  81827d:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818284:	00 00 00 
  818287:	8b 55 dc             	mov    -0x24(%rbp),%edx
  81828a:	48 63 d2             	movslq %edx,%rdx
  81828d:	48 c1 e2 05          	shl    $0x5,%rdx
  818291:	48 01 d0             	add    %rdx,%rax
  818294:	8b 00                	mov    (%rax),%eax
  818296:	85 c0                	test   %eax,%eax
  818298:	74 35                	je     8182cf <sys_arch_sem_wait+0x60>
  81829a:	48 b9 80 2f 82 00 00 	movabs $0x822f80,%rcx
  8182a1:	00 00 00 
  8182a4:	48 ba 79 2e 82 00 00 	movabs $0x822e79,%rdx
  8182ab:	00 00 00 
  8182ae:	be ad 00 00 00       	mov    $0xad,%esi
  8182b3:	48 bf 8e 2e 82 00 00 	movabs $0x822e8e,%rdi
  8182ba:	00 00 00 
  8182bd:	b8 00 00 00 00       	mov    $0x0,%eax
  8182c2:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  8182c9:	00 00 00 
  8182cc:	41 ff d0             	callq  *%r8
    u32_t waited = 0;
  8182cf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

    int gen = sems[sem].gen;
  8182d6:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8182dd:	00 00 00 
  8182e0:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8182e3:	48 63 d2             	movslq %edx,%rdx
  8182e6:	48 c1 e2 05          	shl    $0x5,%rdx
  8182ea:	48 01 d0             	add    %rdx,%rax
  8182ed:	48 83 c0 04          	add    $0x4,%rax
  8182f1:	8b 00                	mov    (%rax),%eax
  8182f3:	89 45 f8             	mov    %eax,-0x8(%rbp)

    while (tm_msec == 0 || waited < tm_msec) {
  8182f6:	e9 8e 01 00 00       	jmpq   818489 <sys_arch_sem_wait+0x21a>
	if (sems[sem].counter > 0) {
  8182fb:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818302:	00 00 00 
  818305:	8b 55 dc             	mov    -0x24(%rbp),%edx
  818308:	48 63 d2             	movslq %edx,%rdx
  81830b:	48 c1 e2 05          	shl    $0x5,%rdx
  81830f:	48 01 d0             	add    %rdx,%rax
  818312:	48 83 c0 08          	add    $0x8,%rax
  818316:	0f b7 00             	movzwl (%rax),%eax
  818319:	66 85 c0             	test   %ax,%ax
  81831c:	74 47                	je     818365 <sys_arch_sem_wait+0xf6>
	    sems[sem].counter--;
  81831e:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818325:	00 00 00 
  818328:	8b 55 dc             	mov    -0x24(%rbp),%edx
  81832b:	48 63 d2             	movslq %edx,%rdx
  81832e:	48 c1 e2 05          	shl    $0x5,%rdx
  818332:	48 01 d0             	add    %rdx,%rax
  818335:	48 83 c0 08          	add    $0x8,%rax
  818339:	0f b7 00             	movzwl (%rax),%eax
  81833c:	8d 50 ff             	lea    -0x1(%rax),%edx
  81833f:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818346:	00 00 00 
  818349:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  81834c:	48 63 c9             	movslq %ecx,%rcx
  81834f:	48 c1 e1 05          	shl    $0x5,%rcx
  818353:	48 01 c8             	add    %rcx,%rax
  818356:	48 83 c0 08          	add    $0x8,%rax
  81835a:	66 89 10             	mov    %dx,(%rax)
	    return waited;
  81835d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818360:	e9 3f 01 00 00       	jmpq   8184a4 <sys_arch_sem_wait+0x235>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  818365:	83 7d d8 fe          	cmpl   $0xfffffffe,-0x28(%rbp)
  818369:	75 0a                	jne    818375 <sys_arch_sem_wait+0x106>
	    return SYS_ARCH_TIMEOUT;
  81836b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  818370:	e9 2f 01 00 00       	jmpq   8184a4 <sys_arch_sem_wait+0x235>
	} else {
	    uint32_t a = sys_time_msec();
  818375:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  81837c:	00 00 00 
  81837f:	ff d0                	callq  *%rax
  818381:	89 45 f4             	mov    %eax,-0xc(%rbp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  818384:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  818388:	74 0f                	je     818399 <sys_arch_sem_wait+0x12a>
  81838a:	8b 45 d8             	mov    -0x28(%rbp),%eax
  81838d:	2b 45 fc             	sub    -0x4(%rbp),%eax
  818390:	89 c2                	mov    %eax,%edx
  818392:	8b 45 f4             	mov    -0xc(%rbp),%eax
  818395:	01 d0                	add    %edx,%eax
  818397:	eb 05                	jmp    81839e <sys_arch_sem_wait+0x12f>
  818399:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81839e:	89 45 f0             	mov    %eax,-0x10(%rbp)
	    sems[sem].waiters = 1;
  8183a1:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8183a8:	00 00 00 
  8183ab:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8183ae:	48 63 d2             	movslq %edx,%rdx
  8183b1:	48 c1 e2 05          	shl    $0x5,%rdx
  8183b5:	48 01 d0             	add    %rdx,%rax
  8183b8:	48 83 c0 0a          	add    $0xa,%rax
  8183bc:	66 c7 00 01 00       	movw   $0x1,(%rax)
	    uint32_t cur_v = sems[sem].v;
  8183c1:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8183c8:	00 00 00 
  8183cb:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8183ce:	48 63 d2             	movslq %edx,%rdx
  8183d1:	48 c1 e2 05          	shl    $0x5,%rdx
  8183d5:	48 01 d0             	add    %rdx,%rax
  8183d8:	48 83 c0 08          	add    $0x8,%rax
  8183dc:	8b 00                	mov    (%rax),%eax
  8183de:	89 45 ec             	mov    %eax,-0x14(%rbp)
	    lwip_core_unlock();
  8183e1:	48 b8 ea 8b 81 00 00 	movabs $0x818bea,%rax
  8183e8:	00 00 00 
  8183eb:	ff d0                	callq  *%rax
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  8183ed:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8183f0:	48 98                	cltq   
  8183f2:	48 c1 e0 05          	shl    $0x5,%rax
  8183f6:	48 89 c2             	mov    %rax,%rdx
  8183f9:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818400:	00 00 00 
  818403:	48 01 d0             	add    %rdx,%rax
  818406:	48 8d 48 08          	lea    0x8(%rax),%rcx
  81840a:	8b 55 f0             	mov    -0x10(%rbp),%edx
  81840d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818410:	89 c6                	mov    %eax,%esi
  818412:	48 89 cf             	mov    %rcx,%rdi
  818415:	48 b8 64 8d 81 00 00 	movabs $0x818d64,%rax
  81841c:	00 00 00 
  81841f:	ff d0                	callq  *%rax
	    lwip_core_lock();
  818421:	48 b8 e3 8b 81 00 00 	movabs $0x818be3,%rax
  818428:	00 00 00 
  81842b:	ff d0                	callq  *%rax
	    if (gen != sems[sem].gen) {
  81842d:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818434:	00 00 00 
  818437:	8b 55 dc             	mov    -0x24(%rbp),%edx
  81843a:	48 63 d2             	movslq %edx,%rdx
  81843d:	48 c1 e2 05          	shl    $0x5,%rdx
  818441:	48 01 d0             	add    %rdx,%rax
  818444:	48 83 c0 04          	add    $0x4,%rax
  818448:	8b 00                	mov    (%rax),%eax
  81844a:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  81844d:	74 22                	je     818471 <sys_arch_sem_wait+0x202>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  81844f:	48 bf 98 2f 82 00 00 	movabs $0x822f98,%rdi
  818456:	00 00 00 
  818459:	b8 00 00 00 00       	mov    $0x0,%eax
  81845e:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  818465:	00 00 00 
  818468:	ff d2                	callq  *%rdx
		return SYS_ARCH_TIMEOUT;
  81846a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81846f:	eb 33                	jmp    8184a4 <sys_arch_sem_wait+0x235>
	    }
	    uint32_t b = sys_time_msec();
  818471:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  818478:	00 00 00 
  81847b:	ff d0                	callq  *%rax
  81847d:	89 45 e8             	mov    %eax,-0x18(%rbp)
	    waited += (b - a);
  818480:	8b 45 e8             	mov    -0x18(%rbp),%eax
  818483:	2b 45 f4             	sub    -0xc(%rbp),%eax
  818486:	01 45 fc             	add    %eax,-0x4(%rbp)
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  818489:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  81848d:	0f 84 68 fe ff ff    	je     8182fb <sys_arch_sem_wait+0x8c>
  818493:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818496:	3b 45 d8             	cmp    -0x28(%rbp),%eax
  818499:	0f 82 5c fe ff ff    	jb     8182fb <sys_arch_sem_wait+0x8c>
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
  81849f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8184a4:	c9                   	leaveq 
  8184a5:	c3                   	retq   

00000000008184a6 <sys_arch_mbox_fetch>:

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  8184a6:	55                   	push   %rbp
  8184a7:	48 89 e5             	mov    %rsp,%rbp
  8184aa:	48 83 ec 20          	sub    $0x20,%rsp
  8184ae:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8184b1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8184b5:	89 55 e8             	mov    %edx,-0x18(%rbp)
    assert(!mboxes[mbox].freed);
  8184b8:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8184bf:	00 00 00 
  8184c2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8184c5:	48 63 d0             	movslq %eax,%rdx
  8184c8:	48 89 d0             	mov    %rdx,%rax
  8184cb:	48 c1 e0 03          	shl    $0x3,%rax
  8184cf:	48 01 d0             	add    %rdx,%rax
  8184d2:	48 c1 e0 02          	shl    $0x2,%rax
  8184d6:	48 01 d0             	add    %rdx,%rax
  8184d9:	48 c1 e0 03          	shl    $0x3,%rax
  8184dd:	48 01 c8             	add    %rcx,%rax
  8184e0:	8b 00                	mov    (%rax),%eax
  8184e2:	85 c0                	test   %eax,%eax
  8184e4:	74 35                	je     81851b <sys_arch_mbox_fetch+0x75>
  8184e6:	48 b9 11 2f 82 00 00 	movabs $0x822f11,%rcx
  8184ed:	00 00 00 
  8184f0:	48 ba 79 2e 82 00 00 	movabs $0x822e79,%rdx
  8184f7:	00 00 00 
  8184fa:	be cf 00 00 00       	mov    $0xcf,%esi
  8184ff:	48 bf 8e 2e 82 00 00 	movabs $0x822e8e,%rdi
  818506:	00 00 00 
  818509:	b8 00 00 00 00       	mov    $0x0,%eax
  81850e:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  818515:	00 00 00 
  818518:	41 ff d0             	callq  *%r8

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  81851b:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  818522:	00 00 00 
  818525:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818528:	48 63 d0             	movslq %eax,%rdx
  81852b:	48 89 d0             	mov    %rdx,%rax
  81852e:	48 c1 e0 03          	shl    $0x3,%rax
  818532:	48 01 d0             	add    %rdx,%rax
  818535:	48 c1 e0 02          	shl    $0x2,%rax
  818539:	48 01 d0             	add    %rdx,%rax
  81853c:	48 c1 e0 03          	shl    $0x3,%rax
  818540:	48 01 c8             	add    %rcx,%rax
  818543:	48 05 10 01 00 00    	add    $0x110,%rax
  818549:	8b 00                	mov    (%rax),%eax
  81854b:	8b 55 e8             	mov    -0x18(%rbp),%edx
  81854e:	89 d6                	mov    %edx,%esi
  818550:	89 c7                	mov    %eax,%edi
  818552:	48 b8 6f 82 81 00 00 	movabs $0x81826f,%rax
  818559:	00 00 00 
  81855c:	ff d0                	callq  *%rax
  81855e:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (waited == SYS_ARCH_TIMEOUT)
  818561:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  818565:	75 08                	jne    81856f <sys_arch_mbox_fetch+0xc9>
	return waited;
  818567:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81856a:	e9 bb 01 00 00       	jmpq   81872a <sys_arch_mbox_fetch+0x284>

    int slot = mboxes[mbox].head;
  81856f:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  818576:	00 00 00 
  818579:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81857c:	48 63 d0             	movslq %eax,%rdx
  81857f:	48 89 d0             	mov    %rdx,%rax
  818582:	48 c1 e0 03          	shl    $0x3,%rax
  818586:	48 01 d0             	add    %rdx,%rax
  818589:	48 c1 e0 02          	shl    $0x2,%rax
  81858d:	48 01 d0             	add    %rdx,%rax
  818590:	48 c1 e0 03          	shl    $0x3,%rax
  818594:	48 01 c8             	add    %rcx,%rax
  818597:	48 83 c0 04          	add    $0x4,%rax
  81859b:	8b 00                	mov    (%rax),%eax
  81859d:	89 45 f8             	mov    %eax,-0x8(%rbp)
    if (slot == -1)
  8185a0:	83 7d f8 ff          	cmpl   $0xffffffff,-0x8(%rbp)
  8185a4:	75 2a                	jne    8185d0 <sys_arch_mbox_fetch+0x12a>
	panic("lwip: sys_arch_mbox_fetch: no message");
  8185a6:	48 ba c8 2f 82 00 00 	movabs $0x822fc8,%rdx
  8185ad:	00 00 00 
  8185b0:	be d7 00 00 00       	mov    $0xd7,%esi
  8185b5:	48 bf 8e 2e 82 00 00 	movabs $0x822e8e,%rdi
  8185bc:	00 00 00 
  8185bf:	b8 00 00 00 00       	mov    $0x0,%eax
  8185c4:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8185cb:	00 00 00 
  8185ce:	ff d1                	callq  *%rcx
    if (msg)
  8185d0:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8185d5:	74 39                	je     818610 <sys_arch_mbox_fetch+0x16a>
	*msg = mboxes[mbox].msg[slot];
  8185d7:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8185de:	00 00 00 
  8185e1:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8185e4:	48 63 f0             	movslq %eax,%rsi
  8185e7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8185ea:	48 63 d0             	movslq %eax,%rdx
  8185ed:	48 89 d0             	mov    %rdx,%rax
  8185f0:	48 c1 e0 03          	shl    $0x3,%rax
  8185f4:	48 01 d0             	add    %rdx,%rax
  8185f7:	48 c1 e0 02          	shl    $0x2,%rax
  8185fb:	48 01 d0             	add    %rdx,%rax
  8185fe:	48 01 f0             	add    %rsi,%rax
  818601:	48 83 c0 02          	add    $0x2,%rax
  818605:	48 8b 14 c1          	mov    (%rcx,%rax,8),%rdx
  818609:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81860d:	48 89 10             	mov    %rdx,(%rax)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  818610:	8b 45 f8             	mov    -0x8(%rbp),%eax
  818613:	8d 50 01             	lea    0x1(%rax),%edx
  818616:	89 d0                	mov    %edx,%eax
  818618:	c1 f8 1f             	sar    $0x1f,%eax
  81861b:	c1 e8 1b             	shr    $0x1b,%eax
  81861e:	01 c2                	add    %eax,%edx
  818620:	83 e2 1f             	and    $0x1f,%edx
  818623:	29 c2                	sub    %eax,%edx
  818625:	89 d0                	mov    %edx,%eax
  818627:	89 c6                	mov    %eax,%esi
  818629:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  818630:	00 00 00 
  818633:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818636:	48 63 d0             	movslq %eax,%rdx
  818639:	48 89 d0             	mov    %rdx,%rax
  81863c:	48 c1 e0 03          	shl    $0x3,%rax
  818640:	48 01 d0             	add    %rdx,%rax
  818643:	48 c1 e0 02          	shl    $0x2,%rax
  818647:	48 01 d0             	add    %rdx,%rax
  81864a:	48 c1 e0 03          	shl    $0x3,%rax
  81864e:	48 01 c8             	add    %rcx,%rax
  818651:	48 83 c0 04          	add    $0x4,%rax
  818655:	89 30                	mov    %esi,(%rax)
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  818657:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81865e:	00 00 00 
  818661:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818664:	48 63 d0             	movslq %eax,%rdx
  818667:	48 89 d0             	mov    %rdx,%rax
  81866a:	48 c1 e0 03          	shl    $0x3,%rax
  81866e:	48 01 d0             	add    %rdx,%rax
  818671:	48 c1 e0 02          	shl    $0x2,%rax
  818675:	48 01 d0             	add    %rdx,%rax
  818678:	48 c1 e0 03          	shl    $0x3,%rax
  81867c:	48 01 c8             	add    %rcx,%rax
  81867f:	48 83 c0 04          	add    $0x4,%rax
  818683:	8b 08                	mov    (%rax),%ecx
  818685:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  81868c:	00 00 00 
  81868f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818692:	48 63 d0             	movslq %eax,%rdx
  818695:	48 89 d0             	mov    %rdx,%rax
  818698:	48 c1 e0 03          	shl    $0x3,%rax
  81869c:	48 01 d0             	add    %rdx,%rax
  81869f:	48 c1 e0 02          	shl    $0x2,%rax
  8186a3:	48 01 d0             	add    %rdx,%rax
  8186a6:	48 c1 e0 03          	shl    $0x3,%rax
  8186aa:	48 01 f0             	add    %rsi,%rax
  8186ad:	48 83 c0 08          	add    $0x8,%rax
  8186b1:	8b 00                	mov    (%rax),%eax
  8186b3:	39 c1                	cmp    %eax,%ecx
  8186b5:	75 32                	jne    8186e9 <sys_arch_mbox_fetch+0x243>
	mboxes[mbox].head = -1;
  8186b7:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8186be:	00 00 00 
  8186c1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8186c4:	48 63 d0             	movslq %eax,%rdx
  8186c7:	48 89 d0             	mov    %rdx,%rax
  8186ca:	48 c1 e0 03          	shl    $0x3,%rax
  8186ce:	48 01 d0             	add    %rdx,%rax
  8186d1:	48 c1 e0 02          	shl    $0x2,%rax
  8186d5:	48 01 d0             	add    %rdx,%rax
  8186d8:	48 c1 e0 03          	shl    $0x3,%rax
  8186dc:	48 01 c8             	add    %rcx,%rax
  8186df:	48 83 c0 04          	add    $0x4,%rax
  8186e3:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%rax)

    sys_sem_signal(mboxes[mbox].free_msg);
  8186e9:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8186f0:	00 00 00 
  8186f3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8186f6:	48 63 d0             	movslq %eax,%rdx
  8186f9:	48 89 d0             	mov    %rdx,%rax
  8186fc:	48 c1 e0 03          	shl    $0x3,%rax
  818700:	48 01 d0             	add    %rdx,%rax
  818703:	48 c1 e0 02          	shl    $0x2,%rax
  818707:	48 01 d0             	add    %rdx,%rax
  81870a:	48 c1 e0 03          	shl    $0x3,%rax
  81870e:	48 01 c8             	add    %rcx,%rax
  818711:	48 05 14 01 00 00    	add    $0x114,%rax
  818717:	8b 00                	mov    (%rax),%eax
  818719:	89 c7                	mov    %eax,%edi
  81871b:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  818722:	00 00 00 
  818725:	ff d0                	callq  *%rax
    return waited;
  818727:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  81872a:	c9                   	leaveq 
  81872b:	c3                   	retq   

000000000081872c <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  81872c:	55                   	push   %rbp
  81872d:	48 89 e5             	mov    %rsp,%rbp
  818730:	48 83 ec 10          	sub    $0x10,%rsp
  818734:	89 7d fc             	mov    %edi,-0x4(%rbp)
  818737:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  81873b:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81873f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818742:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
  818747:	48 89 ce             	mov    %rcx,%rsi
  81874a:	89 c7                	mov    %eax,%edi
  81874c:	48 b8 a6 84 81 00 00 	movabs $0x8184a6,%rax
  818753:	00 00 00 
  818756:	ff d0                	callq  *%rax
}
  818758:	c9                   	leaveq 
  818759:	c3                   	retq   

000000000081875a <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint64_t arg)
{
  81875a:	55                   	push   %rbp
  81875b:	48 89 e5             	mov    %rsp,%rbp
  81875e:	48 83 ec 20          	sub    $0x20,%rsp
  818762:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct lwip_thread *lt = (struct lwip_thread *)arg;
  818766:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81876a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    lwip_core_lock();
  81876e:	48 b8 e3 8b 81 00 00 	movabs $0x818be3,%rax
  818775:	00 00 00 
  818778:	ff d0                	callq  *%rax
    lt->func(lt->arg);
  81877a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81877e:	48 8b 00             	mov    (%rax),%rax
  818781:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818785:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  818789:	48 89 d7             	mov    %rdx,%rdi
  81878c:	ff d0                	callq  *%rax
    lwip_core_unlock();
  81878e:	48 b8 ea 8b 81 00 00 	movabs $0x818bea,%rax
  818795:	00 00 00 
  818798:	ff d0                	callq  *%rax
    free(lt);
  81879a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81879e:	48 89 c7             	mov    %rax,%rdi
  8187a1:	48 b8 1f 51 80 00 00 	movabs $0x80511f,%rax
  8187a8:	00 00 00 
  8187ab:	ff d0                	callq  *%rax
}
  8187ad:	90                   	nop
  8187ae:	c9                   	leaveq 
  8187af:	c3                   	retq   

00000000008187b0 <sys_thread_new>:

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  8187b0:	55                   	push   %rbp
  8187b1:	48 89 e5             	mov    %rsp,%rbp
  8187b4:	48 83 ec 30          	sub    $0x30,%rsp
  8187b8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8187bc:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8187c0:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8187c4:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  8187c7:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
    struct lwip_thread *lt = malloc(sizeof(*lt));
  8187cb:	bf 10 00 00 00       	mov    $0x10,%edi
  8187d0:	48 b8 ae 4d 80 00 00 	movabs $0x804dae,%rax
  8187d7:	00 00 00 
  8187da:	ff d0                	callq  *%rax
  8187dc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (lt == 0)
  8187e0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8187e5:	75 2a                	jne    818811 <sys_thread_new+0x61>
	panic("sys_thread_new: cannot allocate thread struct");
  8187e7:	48 ba f0 2f 82 00 00 	movabs $0x822ff0,%rdx
  8187ee:	00 00 00 
  8187f1:	be fe 00 00 00       	mov    $0xfe,%esi
  8187f6:	48 bf 8e 2e 82 00 00 	movabs $0x822e8e,%rdi
  8187fd:	00 00 00 
  818800:	b8 00 00 00 00       	mov    $0x0,%eax
  818805:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81880c:	00 00 00 
  81880f:	ff d1                	callq  *%rcx

    if (stacksize > PGSIZE)
  818811:	81 7d d4 00 10 00 00 	cmpl   $0x1000,-0x2c(%rbp)
  818818:	7e 30                	jle    81884a <sys_thread_new+0x9a>
	panic("large stack %d", stacksize);
  81881a:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  81881d:	89 c1                	mov    %eax,%ecx
  81881f:	48 ba 1e 30 82 00 00 	movabs $0x82301e,%rdx
  818826:	00 00 00 
  818829:	be 01 01 00 00       	mov    $0x101,%esi
  81882e:	48 bf 8e 2e 82 00 00 	movabs $0x822e8e,%rdi
  818835:	00 00 00 
  818838:	b8 00 00 00 00       	mov    $0x0,%eax
  81883d:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  818844:	00 00 00 
  818847:	41 ff d0             	callq  *%r8

    lt->func = thread;
  81884a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81884e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  818852:	48 89 10             	mov    %rdx,(%rax)
    lt->arg = arg;
  818855:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818859:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81885d:	48 89 50 08          	mov    %rdx,0x8(%rax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint64_t)lt);
  818861:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818865:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  818869:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  81886d:	48 89 d1             	mov    %rdx,%rcx
  818870:	48 ba 5a 87 81 00 00 	movabs $0x81875a,%rdx
  818877:	00 00 00 
  81887a:	48 89 c7             	mov    %rax,%rdi
  81887d:	48 b8 df 8f 81 00 00 	movabs $0x818fdf,%rax
  818884:	00 00 00 
  818887:	ff d0                	callq  *%rax
  818889:	89 45 f4             	mov    %eax,-0xc(%rbp)

    if (r < 0)
  81888c:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  818890:	79 3f                	jns    8188d1 <sys_thread_new+0x121>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  818892:	8b 45 f4             	mov    -0xc(%rbp),%eax
  818895:	89 c7                	mov    %eax,%edi
  818897:	48 b8 76 96 81 00 00 	movabs $0x819676,%rax
  81889e:	00 00 00 
  8188a1:	ff d0                	callq  *%rax
  8188a3:	48 89 c1             	mov    %rax,%rcx
  8188a6:	48 ba 30 30 82 00 00 	movabs $0x823030,%rdx
  8188ad:	00 00 00 
  8188b0:	be 0a 01 00 00       	mov    $0x10a,%esi
  8188b5:	48 bf 8e 2e 82 00 00 	movabs $0x822e8e,%rdi
  8188bc:	00 00 00 
  8188bf:	b8 00 00 00 00       	mov    $0x0,%eax
  8188c4:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  8188cb:	00 00 00 
  8188ce:	41 ff d0             	callq  *%r8

    return tid;
  8188d1:	8b 45 f0             	mov    -0x10(%rbp),%eax
}
  8188d4:	c9                   	leaveq 
  8188d5:	c3                   	retq   

00000000008188d6 <timeout_cleanup>:

static void
timeout_cleanup(thread_id_t tid)
{
  8188d6:	55                   	push   %rbp
  8188d7:	48 89 e5             	mov    %rsp,%rbp
  8188da:	48 83 ec 20          	sub    $0x20,%rsp
  8188de:	89 7d ec             	mov    %edi,-0x14(%rbp)
    lwip_core_lock();
  8188e1:	48 b8 e3 8b 81 00 00 	movabs $0x818be3,%rax
  8188e8:	00 00 00 
  8188eb:	ff d0                	callq  *%rax

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  8188ed:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  8188f0:	89 ca                	mov    %ecx,%edx
  8188f2:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  8188f7:	48 0f af c2          	imul   %rdx,%rax
  8188fb:	48 c1 e8 20          	shr    $0x20,%rax
  8188ff:	89 c2                	mov    %eax,%edx
  818901:	c1 ea 08             	shr    $0x8,%edx
  818904:	89 d0                	mov    %edx,%eax
  818906:	c1 e0 08             	shl    $0x8,%eax
  818909:	01 d0                	add    %edx,%eax
  81890b:	29 c1                	sub    %eax,%ecx
  81890d:	89 ca                	mov    %ecx,%edx
  81890f:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818916:	00 00 00 
  818919:	89 d2                	mov    %edx,%edx
  81891b:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  81891f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  818923:	eb 60                	jmp    818985 <timeout_cleanup+0xaf>
	if (t->tid == tid) {
  818925:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818929:	8b 00                	mov    (%rax),%eax
  81892b:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  81892e:	75 49                	jne    818979 <timeout_cleanup+0xa3>
	    LIST_REMOVE(t, link);
  818930:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818934:	48 8b 40 10          	mov    0x10(%rax),%rax
  818938:	48 85 c0             	test   %rax,%rax
  81893b:	74 14                	je     818951 <timeout_cleanup+0x7b>
  81893d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818941:	48 8b 40 10          	mov    0x10(%rax),%rax
  818945:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818949:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  81894d:	48 89 50 18          	mov    %rdx,0x18(%rax)
  818951:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818955:	48 8b 40 18          	mov    0x18(%rax),%rax
  818959:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81895d:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  818961:	48 89 10             	mov    %rdx,(%rax)
	    free(t);
  818964:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818968:	48 89 c7             	mov    %rax,%rdi
  81896b:	48 b8 1f 51 80 00 00 	movabs $0x80511f,%rax
  818972:	00 00 00 
  818975:	ff d0                	callq  *%rax
	    goto done;
  818977:	eb 13                	jmp    81898c <timeout_cleanup+0xb6>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  818979:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81897d:	48 8b 40 10          	mov    0x10(%rax),%rax
  818981:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  818985:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81898a:	75 99                	jne    818925 <timeout_cleanup+0x4f>
	    goto done;
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
  81898c:	48 b8 ea 8b 81 00 00 	movabs $0x818bea,%rax
  818993:	00 00 00 
  818996:	ff d0                	callq  *%rax
}
  818998:	90                   	nop
  818999:	c9                   	leaveq 
  81899a:	c3                   	retq   

000000000081899b <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  81899b:	55                   	push   %rbp
  81899c:	48 89 e5             	mov    %rsp,%rbp
  81899f:	48 83 ec 10          	sub    $0x10,%rsp
    thread_id_t tid = thread_id();
  8189a3:	48 b8 fb 8c 81 00 00 	movabs $0x818cfb,%rax
  8189aa:	00 00 00 
  8189ad:	ff d0                	callq  *%rax
  8189af:	89 45 f4             	mov    %eax,-0xc(%rbp)

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  8189b2:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8189b5:	89 ca                	mov    %ecx,%edx
  8189b7:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  8189bc:	48 0f af c2          	imul   %rdx,%rax
  8189c0:	48 c1 e8 20          	shr    $0x20,%rax
  8189c4:	89 c2                	mov    %eax,%edx
  8189c6:	c1 ea 08             	shr    $0x8,%edx
  8189c9:	89 d0                	mov    %edx,%eax
  8189cb:	c1 e0 08             	shl    $0x8,%eax
  8189ce:	01 d0                	add    %edx,%eax
  8189d0:	29 c1                	sub    %eax,%ecx
  8189d2:	89 ca                	mov    %ecx,%edx
  8189d4:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  8189db:	00 00 00 
  8189de:	89 d2                	mov    %edx,%edx
  8189e0:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8189e4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8189e8:	eb 1b                	jmp    818a05 <sys_arch_timeouts+0x6a>
	if (t->tid == tid)
  8189ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189ee:	8b 00                	mov    (%rax),%eax
  8189f0:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8189f3:	0f 84 df 01 00 00    	je     818bd8 <sys_arch_timeouts+0x23d>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  8189f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189fd:	48 8b 40 10          	mov    0x10(%rax),%rax
  818a01:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  818a05:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818a0a:	75 de                	jne    8189ea <sys_arch_timeouts+0x4f>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  818a0c:	bf 20 00 00 00       	mov    $0x20,%edi
  818a11:	48 b8 ae 4d 80 00 00 	movabs $0x804dae,%rax
  818a18:	00 00 00 
  818a1b:	ff d0                	callq  *%rax
  818a1d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (t == 0)
  818a21:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818a26:	75 2a                	jne    818a52 <sys_arch_timeouts+0xb7>
	panic("sys_arch_timeouts: cannot malloc");
  818a28:	48 ba 60 30 82 00 00 	movabs $0x823060,%rdx
  818a2f:	00 00 00 
  818a32:	be 2d 01 00 00       	mov    $0x12d,%esi
  818a37:	48 bf 8e 2e 82 00 00 	movabs $0x822e8e,%rdi
  818a3e:	00 00 00 
  818a41:	b8 00 00 00 00       	mov    $0x0,%eax
  818a46:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  818a4d:	00 00 00 
  818a50:	ff d1                	callq  *%rcx

    int r = thread_onhalt(timeout_cleanup);
  818a52:	48 bf d6 88 81 00 00 	movabs $0x8188d6,%rdi
  818a59:	00 00 00 
  818a5c:	48 b8 96 8e 81 00 00 	movabs $0x818e96,%rax
  818a63:	00 00 00 
  818a66:	ff d0                	callq  *%rax
  818a68:	89 45 f0             	mov    %eax,-0x10(%rbp)
    if (r < 0)
  818a6b:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  818a6f:	79 3f                	jns    818ab0 <sys_arch_timeouts+0x115>
	panic("thread_onhalt failed: %s", e2s(r));
  818a71:	8b 45 f0             	mov    -0x10(%rbp),%eax
  818a74:	89 c7                	mov    %eax,%edi
  818a76:	48 b8 76 96 81 00 00 	movabs $0x819676,%rax
  818a7d:	00 00 00 
  818a80:	ff d0                	callq  *%rax
  818a82:	48 89 c1             	mov    %rax,%rcx
  818a85:	48 ba 81 30 82 00 00 	movabs $0x823081,%rdx
  818a8c:	00 00 00 
  818a8f:	be 31 01 00 00       	mov    $0x131,%esi
  818a94:	48 bf 8e 2e 82 00 00 	movabs $0x822e8e,%rdi
  818a9b:	00 00 00 
  818a9e:	b8 00 00 00 00       	mov    $0x0,%eax
  818aa3:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  818aaa:	00 00 00 
  818aad:	41 ff d0             	callq  *%r8

    t->tid = tid;
  818ab0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ab4:	8b 55 f4             	mov    -0xc(%rbp),%edx
  818ab7:	89 10                	mov    %edx,(%rax)
    memset(&t->tmo, 0, sizeof(t->tmo));
  818ab9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818abd:	48 83 c0 08          	add    $0x8,%rax
  818ac1:	ba 08 00 00 00       	mov    $0x8,%edx
  818ac6:	be 00 00 00 00       	mov    $0x0,%esi
  818acb:	48 89 c7             	mov    %rax,%rdi
  818ace:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  818ad5:	00 00 00 
  818ad8:	ff d0                	callq  *%rax
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  818ada:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818add:	89 ca                	mov    %ecx,%edx
  818adf:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818ae4:	48 0f af c2          	imul   %rdx,%rax
  818ae8:	48 c1 e8 20          	shr    $0x20,%rax
  818aec:	89 c2                	mov    %eax,%edx
  818aee:	c1 ea 08             	shr    $0x8,%edx
  818af1:	89 d0                	mov    %edx,%eax
  818af3:	c1 e0 08             	shl    $0x8,%eax
  818af6:	01 d0                	add    %edx,%eax
  818af8:	29 c1                	sub    %eax,%ecx
  818afa:	89 ca                	mov    %ecx,%edx
  818afc:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818b03:	00 00 00 
  818b06:	89 d2                	mov    %edx,%edx
  818b08:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  818b0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818b10:	48 89 50 10          	mov    %rdx,0x10(%rax)
  818b14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818b18:	48 8b 40 10          	mov    0x10(%rax),%rax
  818b1c:	48 85 c0             	test   %rax,%rax
  818b1f:	74 3e                	je     818b5f <sys_arch_timeouts+0x1c4>
  818b21:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818b24:	89 ca                	mov    %ecx,%edx
  818b26:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818b2b:	48 0f af c2          	imul   %rdx,%rax
  818b2f:	48 c1 e8 20          	shr    $0x20,%rax
  818b33:	89 c2                	mov    %eax,%edx
  818b35:	c1 ea 08             	shr    $0x8,%edx
  818b38:	89 d0                	mov    %edx,%eax
  818b3a:	c1 e0 08             	shl    $0x8,%eax
  818b3d:	01 d0                	add    %edx,%eax
  818b3f:	29 c1                	sub    %eax,%ecx
  818b41:	89 ca                	mov    %ecx,%edx
  818b43:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818b4a:	00 00 00 
  818b4d:	89 d2                	mov    %edx,%edx
  818b4f:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  818b53:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818b57:	48 83 c2 10          	add    $0x10,%rdx
  818b5b:	48 89 50 18          	mov    %rdx,0x18(%rax)
  818b5f:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818b62:	89 ca                	mov    %ecx,%edx
  818b64:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818b69:	48 0f af c2          	imul   %rdx,%rax
  818b6d:	48 c1 e8 20          	shr    $0x20,%rax
  818b71:	89 c2                	mov    %eax,%edx
  818b73:	c1 ea 08             	shr    $0x8,%edx
  818b76:	89 d0                	mov    %edx,%eax
  818b78:	c1 e0 08             	shl    $0x8,%eax
  818b7b:	01 d0                	add    %edx,%eax
  818b7d:	29 c1                	sub    %eax,%ecx
  818b7f:	89 ca                	mov    %ecx,%edx
  818b81:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818b88:	00 00 00 
  818b8b:	89 d1                	mov    %edx,%ecx
  818b8d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818b91:	48 89 14 c8          	mov    %rdx,(%rax,%rcx,8)
  818b95:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818b98:	89 ca                	mov    %ecx,%edx
  818b9a:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818b9f:	48 0f af c2          	imul   %rdx,%rax
  818ba3:	48 c1 e8 20          	shr    $0x20,%rax
  818ba7:	89 c2                	mov    %eax,%edx
  818ba9:	c1 ea 08             	shr    $0x8,%edx
  818bac:	89 d0                	mov    %edx,%eax
  818bae:	c1 e0 08             	shl    $0x8,%eax
  818bb1:	01 d0                	add    %edx,%eax
  818bb3:	29 c1                	sub    %eax,%ecx
  818bb5:	89 ca                	mov    %ecx,%edx
  818bb7:	89 d0                	mov    %edx,%eax
  818bb9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  818bc0:	00 
  818bc1:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818bc8:	00 00 00 
  818bcb:	48 01 c2             	add    %rax,%rdx
  818bce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818bd2:	48 89 50 18          	mov    %rdx,0x18(%rax)
  818bd6:	eb 01                	jmp    818bd9 <sys_arch_timeouts+0x23e>
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
	if (t->tid == tid)
	    goto out;
  818bd8:	90                   	nop
    t->tid = tid;
    memset(&t->tmo, 0, sizeof(t->tmo));
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);

out:
    return &t->tmo;
  818bd9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818bdd:	48 83 c0 08          	add    $0x8,%rax
}
  818be1:	c9                   	leaveq 
  818be2:	c3                   	retq   

0000000000818be3 <lwip_core_lock>:

void
lwip_core_lock(void)
{
  818be3:	55                   	push   %rbp
  818be4:	48 89 e5             	mov    %rsp,%rbp
}
  818be7:	90                   	nop
  818be8:	5d                   	pop    %rbp
  818be9:	c3                   	retq   

0000000000818bea <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  818bea:	55                   	push   %rbp
  818beb:	48 89 e5             	mov    %rsp,%rbp
}
  818bee:	90                   	nop
  818bef:	5d                   	pop    %rbp
  818bf0:	c3                   	retq   

0000000000818bf1 <threadq_init>:
    struct thread_context *tc_queue_link;
};

static inline void 
threadq_init(struct thread_queue *tq)
{
  818bf1:	55                   	push   %rbp
  818bf2:	48 89 e5             	mov    %rsp,%rbp
  818bf5:	48 83 ec 08          	sub    $0x8,%rsp
  818bf9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    tq->tq_first = 0;
  818bfd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c01:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    tq->tq_last = 0;
  818c08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c0c:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  818c13:	00 
}
  818c14:	90                   	nop
  818c15:	c9                   	leaveq 
  818c16:	c3                   	retq   

0000000000818c17 <threadq_push>:

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
  818c17:	55                   	push   %rbp
  818c18:	48 89 e5             	mov    %rsp,%rbp
  818c1b:	48 83 ec 10          	sub    $0x10,%rsp
  818c1f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  818c23:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    tc->tc_queue_link = 0;
  818c27:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818c2b:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  818c32:	00 00 00 00 
    if (!tq->tq_first) {
  818c36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c3a:	48 8b 00             	mov    (%rax),%rax
  818c3d:	48 85 c0             	test   %rax,%rax
  818c40:	75 19                	jne    818c5b <threadq_push+0x44>
	tq->tq_first = tc;
  818c42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c46:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818c4a:	48 89 10             	mov    %rdx,(%rax)
	tq->tq_last = tc;
  818c4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c51:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818c55:	48 89 50 08          	mov    %rdx,0x8(%rax)
    } else {
	tq->tq_last->tc_queue_link = tc;
	tq->tq_last = tc;
    }
}
  818c59:	eb 1f                	jmp    818c7a <threadq_push+0x63>
    tc->tc_queue_link = 0;
    if (!tq->tq_first) {
	tq->tq_first = tc;
	tq->tq_last = tc;
    } else {
	tq->tq_last->tc_queue_link = tc;
  818c5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c5f:	48 8b 40 08          	mov    0x8(%rax),%rax
  818c63:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818c67:	48 89 90 e8 00 00 00 	mov    %rdx,0xe8(%rax)
	tq->tq_last = tc;
  818c6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c72:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818c76:	48 89 50 08          	mov    %rdx,0x8(%rax)
    }
}
  818c7a:	90                   	nop
  818c7b:	c9                   	leaveq 
  818c7c:	c3                   	retq   

0000000000818c7d <threadq_pop>:

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
  818c7d:	55                   	push   %rbp
  818c7e:	48 89 e5             	mov    %rsp,%rbp
  818c81:	48 83 ec 18          	sub    $0x18,%rsp
  818c85:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    if (!tq->tq_first)
  818c89:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818c8d:	48 8b 00             	mov    (%rax),%rax
  818c90:	48 85 c0             	test   %rax,%rax
  818c93:	75 07                	jne    818c9c <threadq_pop+0x1f>
	return 0;
  818c95:	b8 00 00 00 00       	mov    $0x0,%eax
  818c9a:	eb 30                	jmp    818ccc <threadq_pop+0x4f>

    struct thread_context *tc = tq->tq_first;
  818c9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818ca0:	48 8b 00             	mov    (%rax),%rax
  818ca3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    tq->tq_first = tc->tc_queue_link;
  818ca7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818cab:	48 8b 90 e8 00 00 00 	mov    0xe8(%rax),%rdx
  818cb2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818cb6:	48 89 10             	mov    %rdx,(%rax)
    tc->tc_queue_link = 0;
  818cb9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818cbd:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  818cc4:	00 00 00 00 
    return tc;
  818cc8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  818ccc:	c9                   	leaveq 
  818ccd:	c3                   	retq   

0000000000818cce <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  818cce:	55                   	push   %rbp
  818ccf:	48 89 e5             	mov    %rsp,%rbp
    threadq_init(&thread_queue);
  818cd2:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  818cd9:	00 00 00 
  818cdc:	48 b8 f1 8b 81 00 00 	movabs $0x818bf1,%rax
  818ce3:	00 00 00 
  818ce6:	ff d0                	callq  *%rax
    max_tid = 0;
  818ce8:	48 b8 70 74 b5 00 00 	movabs $0xb57470,%rax
  818cef:	00 00 00 
  818cf2:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
  818cf8:	90                   	nop
  818cf9:	5d                   	pop    %rbp
  818cfa:	c3                   	retq   

0000000000818cfb <thread_id>:

uint32_t
thread_id(void) {
  818cfb:	55                   	push   %rbp
  818cfc:	48 89 e5             	mov    %rsp,%rbp
    return cur_tc->tc_tid;
  818cff:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818d06:	00 00 00 
  818d09:	48 8b 00             	mov    (%rax),%rax
  818d0c:	8b 00                	mov    (%rax),%eax
}
  818d0e:	5d                   	pop    %rbp
  818d0f:	c3                   	retq   

0000000000818d10 <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  818d10:	55                   	push   %rbp
  818d11:	48 89 e5             	mov    %rsp,%rbp
  818d14:	48 83 ec 18          	sub    $0x18,%rsp
  818d18:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct thread_context *tc = thread_queue.tq_first;
  818d1c:	48 b8 80 74 b5 00 00 	movabs $0xb57480,%rax
  818d23:	00 00 00 
  818d26:	48 8b 00             	mov    (%rax),%rax
  818d29:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (tc) {
  818d2d:	eb 2b                	jmp    818d5a <thread_wakeup+0x4a>
	if (tc->tc_wait_addr == addr)
  818d2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818d33:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  818d3a:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  818d3e:	75 0b                	jne    818d4b <thread_wakeup+0x3b>
	    tc->tc_wakeup = 1;
  818d40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818d44:	c6 80 b8 00 00 00 01 	movb   $0x1,0xb8(%rax)
	tc = tc->tc_queue_link;
  818d4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818d4f:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  818d56:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  818d5a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818d5f:	75 ce                	jne    818d2f <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  818d61:	90                   	nop
  818d62:	c9                   	leaveq 
  818d63:	c3                   	retq   

0000000000818d64 <thread_wait>:

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  818d64:	55                   	push   %rbp
  818d65:	48 89 e5             	mov    %rsp,%rbp
  818d68:	48 83 ec 20          	sub    $0x20,%rsp
  818d6c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  818d70:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  818d73:	89 55 e0             	mov    %edx,-0x20(%rbp)
    uint32_t s = sys_time_msec();
  818d76:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  818d7d:	00 00 00 
  818d80:	ff d0                	callq  *%rax
  818d82:	89 45 f8             	mov    %eax,-0x8(%rbp)
    uint32_t p = s;
  818d85:	8b 45 f8             	mov    -0x8(%rbp),%eax
  818d88:	89 45 fc             	mov    %eax,-0x4(%rbp)

    cur_tc->tc_wait_addr = addr;
  818d8b:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818d92:	00 00 00 
  818d95:	48 8b 00             	mov    (%rax),%rax
  818d98:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  818d9c:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
    cur_tc->tc_wakeup = 0;
  818da3:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818daa:	00 00 00 
  818dad:	48 8b 00             	mov    (%rax),%rax
  818db0:	c6 80 b8 00 00 00 00 	movb   $0x0,0xb8(%rax)

    while (p < msec) {
  818db7:	eb 4d                	jmp    818e06 <thread_wait+0xa2>
	if (p < s)
  818db9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818dbc:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  818dbf:	72 4f                	jb     818e10 <thread_wait+0xac>
	    break;
	if (addr && *addr != val)
  818dc1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  818dc6:	74 0b                	je     818dd3 <thread_wait+0x6f>
  818dc8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818dcc:	8b 00                	mov    (%rax),%eax
  818dce:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  818dd1:	75 40                	jne    818e13 <thread_wait+0xaf>
	    break;
	if (cur_tc->tc_wakeup)
  818dd3:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818dda:	00 00 00 
  818ddd:	48 8b 00             	mov    (%rax),%rax
  818de0:	0f b6 80 b8 00 00 00 	movzbl 0xb8(%rax),%eax
  818de7:	84 c0                	test   %al,%al
  818de9:	75 2b                	jne    818e16 <thread_wait+0xb2>
	    break;

	thread_yield();
  818deb:	48 b8 66 92 81 00 00 	movabs $0x819266,%rax
  818df2:	00 00 00 
  818df5:	ff d0                	callq  *%rax
	p = sys_time_msec();
  818df7:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  818dfe:	00 00 00 
  818e01:	ff d0                	callq  *%rax
  818e03:	89 45 fc             	mov    %eax,-0x4(%rbp)
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  818e06:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818e09:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  818e0c:	72 ab                	jb     818db9 <thread_wait+0x55>
  818e0e:	eb 07                	jmp    818e17 <thread_wait+0xb3>
	if (p < s)
	    break;
  818e10:	90                   	nop
  818e11:	eb 04                	jmp    818e17 <thread_wait+0xb3>
	if (addr && *addr != val)
	    break;
  818e13:	90                   	nop
  818e14:	eb 01                	jmp    818e17 <thread_wait+0xb3>
	if (cur_tc->tc_wakeup)
	    break;
  818e16:	90                   	nop

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  818e17:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818e1e:	00 00 00 
  818e21:	48 8b 00             	mov    (%rax),%rax
  818e24:	48 c7 80 b0 00 00 00 	movq   $0x0,0xb0(%rax)
  818e2b:	00 00 00 00 
    cur_tc->tc_wakeup = 0;
  818e2f:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818e36:	00 00 00 
  818e39:	48 8b 00             	mov    (%rax),%rax
  818e3c:	c6 80 b8 00 00 00 00 	movb   $0x0,0xb8(%rax)
}
  818e43:	90                   	nop
  818e44:	c9                   	leaveq 
  818e45:	c3                   	retq   

0000000000818e46 <thread_wakeups_pending>:

int
thread_wakeups_pending(void)
{
  818e46:	55                   	push   %rbp
  818e47:	48 89 e5             	mov    %rsp,%rbp
  818e4a:	48 83 ec 10          	sub    $0x10,%rsp
    struct thread_context *tc = thread_queue.tq_first;
  818e4e:	48 b8 80 74 b5 00 00 	movabs $0xb57480,%rax
  818e55:	00 00 00 
  818e58:	48 8b 00             	mov    (%rax),%rax
  818e5b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    int n = 0;
  818e5f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    while (tc) {
  818e66:	eb 22                	jmp    818e8a <thread_wakeups_pending+0x44>
	if (tc->tc_wakeup)
  818e68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818e6c:	0f b6 80 b8 00 00 00 	movzbl 0xb8(%rax),%eax
  818e73:	84 c0                	test   %al,%al
  818e75:	74 04                	je     818e7b <thread_wakeups_pending+0x35>
	    ++n;
  818e77:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
	tc = tc->tc_queue_link;
  818e7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818e7f:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  818e86:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  818e8a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818e8f:	75 d7                	jne    818e68 <thread_wakeups_pending+0x22>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
  818e91:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  818e94:	c9                   	leaveq 
  818e95:	c3                   	retq   

0000000000818e96 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  818e96:	55                   	push   %rbp
  818e97:	48 89 e5             	mov    %rsp,%rbp
  818e9a:	48 83 ec 08          	sub    $0x8,%rsp
  818e9e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  818ea2:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818ea9:	00 00 00 
  818eac:	48 8b 00             	mov    (%rax),%rax
  818eaf:	8b 80 e0 00 00 00    	mov    0xe0(%rax),%eax
  818eb5:	83 f8 03             	cmp    $0x3,%eax
  818eb8:	7e 07                	jle    818ec1 <thread_onhalt+0x2b>
	return -E_NO_MEM;
  818eba:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  818ebf:	eb 3d                	jmp    818efe <thread_onhalt+0x68>

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  818ec1:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818ec8:	00 00 00 
  818ecb:	48 8b 08             	mov    (%rax),%rcx
  818ece:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818ed5:	00 00 00 
  818ed8:	48 8b 00             	mov    (%rax),%rax
  818edb:	8b 90 e0 00 00 00    	mov    0xe0(%rax),%edx
  818ee1:	8d 72 01             	lea    0x1(%rdx),%esi
  818ee4:	89 b0 e0 00 00 00    	mov    %esi,0xe0(%rax)
  818eea:	48 63 c2             	movslq %edx,%rax
  818eed:	48 8d 50 18          	lea    0x18(%rax),%rdx
  818ef1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ef5:	48 89 04 d1          	mov    %rax,(%rcx,%rdx,8)
    return 0;
  818ef9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  818efe:	c9                   	leaveq 
  818eff:	c3                   	retq   

0000000000818f00 <alloc_tid>:

static thread_id_t
alloc_tid(void) {
  818f00:	55                   	push   %rbp
  818f01:	48 89 e5             	mov    %rsp,%rbp
  818f04:	48 83 ec 10          	sub    $0x10,%rsp
    int tid = max_tid++;
  818f08:	48 b8 70 74 b5 00 00 	movabs $0xb57470,%rax
  818f0f:	00 00 00 
  818f12:	8b 00                	mov    (%rax),%eax
  818f14:	8d 48 01             	lea    0x1(%rax),%ecx
  818f17:	48 ba 70 74 b5 00 00 	movabs $0xb57470,%rdx
  818f1e:	00 00 00 
  818f21:	89 0a                	mov    %ecx,(%rdx)
  818f23:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (max_tid == (uint32_t)~0)
  818f26:	48 b8 70 74 b5 00 00 	movabs $0xb57470,%rax
  818f2d:	00 00 00 
  818f30:	8b 00                	mov    (%rax),%eax
  818f32:	83 f8 ff             	cmp    $0xffffffff,%eax
  818f35:	75 2a                	jne    818f61 <alloc_tid+0x61>
	panic("alloc_tid: no more thread ids");
  818f37:	48 ba 9a 30 82 00 00 	movabs $0x82309a,%rdx
  818f3e:	00 00 00 
  818f41:	be 55 00 00 00       	mov    $0x55,%esi
  818f46:	48 bf b8 30 82 00 00 	movabs $0x8230b8,%rdi
  818f4d:	00 00 00 
  818f50:	b8 00 00 00 00       	mov    $0x0,%eax
  818f55:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  818f5c:	00 00 00 
  818f5f:	ff d1                	callq  *%rcx
    return tid;
  818f61:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  818f64:	c9                   	leaveq 
  818f65:	c3                   	retq   

0000000000818f66 <thread_set_name>:

static void
thread_set_name(struct thread_context *tc, const char *name)
{
  818f66:	55                   	push   %rbp
  818f67:	48 89 e5             	mov    %rsp,%rbp
  818f6a:	48 83 ec 10          	sub    $0x10,%rsp
  818f6e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  818f72:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    strncpy(tc->tc_name, name, name_size - 1);
  818f76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f7a:	48 8d 48 10          	lea    0x10(%rax),%rcx
  818f7e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818f82:	ba 1f 00 00 00       	mov    $0x1f,%edx
  818f87:	48 89 c6             	mov    %rax,%rsi
  818f8a:	48 89 cf             	mov    %rcx,%rdi
  818f8d:	48 b8 54 1f 80 00 00 	movabs $0x801f54,%rax
  818f94:	00 00 00 
  818f97:	ff d0                	callq  *%rax
    tc->tc_name[name_size - 1] = 0;
  818f99:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f9d:	c6 40 2f 00          	movb   $0x0,0x2f(%rax)
}
  818fa1:	90                   	nop
  818fa2:	c9                   	leaveq 
  818fa3:	c3                   	retq   

0000000000818fa4 <thread_entry>:

static void
thread_entry(void) {
  818fa4:	55                   	push   %rbp
  818fa5:	48 89 e5             	mov    %rsp,%rbp
    cur_tc->tc_entry(cur_tc->tc_arg);
  818fa8:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818faf:	00 00 00 
  818fb2:	48 8b 00             	mov    (%rax),%rax
  818fb5:	48 8b 40 30          	mov    0x30(%rax),%rax
  818fb9:	48 ba 78 74 b5 00 00 	movabs $0xb57478,%rdx
  818fc0:	00 00 00 
  818fc3:	48 8b 12             	mov    (%rdx),%rdx
  818fc6:	8b 52 38             	mov    0x38(%rdx),%edx
  818fc9:	89 d2                	mov    %edx,%edx
  818fcb:	48 89 d7             	mov    %rdx,%rdi
  818fce:	ff d0                	callq  *%rax
    thread_halt();
  818fd0:	48 b8 eb 91 81 00 00 	movabs $0x8191eb,%rax
  818fd7:	00 00 00 
  818fda:	ff d0                	callq  *%rax
}
  818fdc:	90                   	nop
  818fdd:	5d                   	pop    %rbp
  818fde:	c3                   	retq   

0000000000818fdf <thread_create>:

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint64_t), uint64_t arg) {
  818fdf:	55                   	push   %rbp
  818fe0:	48 89 e5             	mov    %rsp,%rbp
  818fe3:	48 83 ec 30          	sub    $0x30,%rsp
  818fe7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  818feb:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  818fef:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  818ff3:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  818ff7:	bf f0 00 00 00       	mov    $0xf0,%edi
  818ffc:	48 b8 ae 4d 80 00 00 	movabs $0x804dae,%rax
  819003:	00 00 00 
  819006:	ff d0                	callq  *%rax
  819008:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!tc)
  81900c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819011:	75 0a                	jne    81901d <thread_create+0x3e>
	return -E_NO_MEM;
  819013:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  819018:	e9 52 01 00 00       	jmpq   81916f <thread_create+0x190>

    memset(tc, 0, sizeof(struct thread_context));
  81901d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819021:	ba f0 00 00 00       	mov    $0xf0,%edx
  819026:	be 00 00 00 00       	mov    $0x0,%esi
  81902b:	48 89 c7             	mov    %rax,%rdi
  81902e:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  819035:	00 00 00 
  819038:	ff d0                	callq  *%rax
    
    thread_set_name(tc, name);
  81903a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81903e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819042:	48 89 d6             	mov    %rdx,%rsi
  819045:	48 89 c7             	mov    %rax,%rdi
  819048:	48 b8 66 8f 81 00 00 	movabs $0x818f66,%rax
  81904f:	00 00 00 
  819052:	ff d0                	callq  *%rax
    tc->tc_tid = alloc_tid();
  819054:	48 b8 00 8f 81 00 00 	movabs $0x818f00,%rax
  81905b:	00 00 00 
  81905e:	ff d0                	callq  *%rax
  819060:	89 c2                	mov    %eax,%edx
  819062:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819066:	89 10                	mov    %edx,(%rax)

    tc->tc_stack_bottom = malloc(stack_size);
  819068:	bf 00 10 00 00       	mov    $0x1000,%edi
  81906d:	48 b8 ae 4d 80 00 00 	movabs $0x804dae,%rax
  819074:	00 00 00 
  819077:	ff d0                	callq  *%rax
  819079:	48 89 c2             	mov    %rax,%rdx
  81907c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819080:	48 89 50 08          	mov    %rdx,0x8(%rax)
    if (!tc->tc_stack_bottom) {
  819084:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819088:	48 8b 40 08          	mov    0x8(%rax),%rax
  81908c:	48 85 c0             	test   %rax,%rax
  81908f:	75 1d                	jne    8190ae <thread_create+0xcf>
	free(tc);
  819091:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819095:	48 89 c7             	mov    %rax,%rdi
  819098:	48 b8 1f 51 80 00 00 	movabs $0x80511f,%rax
  81909f:	00 00 00 
  8190a2:	ff d0                	callq  *%rax
	return -E_NO_MEM;
  8190a4:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8190a9:	e9 c1 00 00 00       	jmpq   81916f <thread_create+0x190>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
  8190ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8190b2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8190b6:	48 05 00 10 00 00    	add    $0x1000,%rax
  8190bc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    // Terminate stack unwinding
    stacktop = stacktop - 8;
  8190c0:	48 83 6d f0 08       	subq   $0x8,-0x10(%rbp)
    memset(stacktop, 0, 8);
  8190c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8190c9:	ba 08 00 00 00       	mov    $0x8,%edx
  8190ce:	be 00 00 00 00       	mov    $0x0,%esi
  8190d3:	48 89 c7             	mov    %rax,%rdi
  8190d6:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  8190dd:	00 00 00 
  8190e0:	ff d0                	callq  *%rax
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  8190e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8190e6:	48 83 c0 40          	add    $0x40,%rax
  8190ea:	ba 70 00 00 00       	mov    $0x70,%edx
  8190ef:	be 00 00 00 00       	mov    $0x0,%esi
  8190f4:	48 89 c7             	mov    %rax,%rdi
  8190f7:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  8190fe:	00 00 00 
  819101:	ff d0                	callq  *%rax
    tc->tc_jb.jb_rsp = (uint64_t)stacktop;
  819103:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  819107:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81910b:	48 89 50 48          	mov    %rdx,0x48(%rax)
    tc->tc_jb.jb_rip = (uint64_t)&thread_entry;
  81910f:	48 ba a4 8f 81 00 00 	movabs $0x818fa4,%rdx
  819116:	00 00 00 
  819119:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81911d:	48 89 50 40          	mov    %rdx,0x40(%rax)
    tc->tc_entry = entry;
  819121:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819125:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  819129:	48 89 50 30          	mov    %rdx,0x30(%rax)
    tc->tc_arg = arg;
  81912d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  819131:	89 c2                	mov    %eax,%edx
  819133:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819137:	89 50 38             	mov    %edx,0x38(%rax)

    threadq_push(&thread_queue, tc);
  81913a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81913e:	48 89 c6             	mov    %rax,%rsi
  819141:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  819148:	00 00 00 
  81914b:	48 b8 17 8c 81 00 00 	movabs $0x818c17,%rax
  819152:	00 00 00 
  819155:	ff d0                	callq  *%rax

    if (tid)
  819157:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81915c:	74 0c                	je     81916a <thread_create+0x18b>
	*tid = tc->tc_tid;
  81915e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819162:	8b 10                	mov    (%rax),%edx
  819164:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819168:	89 10                	mov    %edx,(%rax)
    return 0;
  81916a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81916f:	c9                   	leaveq 
  819170:	c3                   	retq   

0000000000819171 <thread_clean>:

static void
thread_clean(struct thread_context *tc) {
  819171:	55                   	push   %rbp
  819172:	48 89 e5             	mov    %rsp,%rbp
  819175:	48 83 ec 20          	sub    $0x20,%rsp
  819179:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    if (!tc) return;
  81917d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  819182:	74 64                	je     8191e8 <thread_clean+0x77>

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  819184:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  81918b:	eb 20                	jmp    8191ad <thread_clean+0x3c>
	tc->tc_onhalt[i](tc->tc_tid);
  81918d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819191:	8b 55 fc             	mov    -0x4(%rbp),%edx
  819194:	48 63 d2             	movslq %edx,%rdx
  819197:	48 83 c2 18          	add    $0x18,%rdx
  81919b:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  81919f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8191a3:	8b 12                	mov    (%rdx),%edx
  8191a5:	89 d7                	mov    %edx,%edi
  8191a7:	ff d0                	callq  *%rax
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  8191a9:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8191ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8191b1:	8b 80 e0 00 00 00    	mov    0xe0(%rax),%eax
  8191b7:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8191ba:	7f d1                	jg     81918d <thread_clean+0x1c>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  8191bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8191c0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8191c4:	48 89 c7             	mov    %rax,%rdi
  8191c7:	48 b8 1f 51 80 00 00 	movabs $0x80511f,%rax
  8191ce:	00 00 00 
  8191d1:	ff d0                	callq  *%rax
    free(tc);
  8191d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8191d7:	48 89 c7             	mov    %rax,%rdi
  8191da:	48 b8 1f 51 80 00 00 	movabs $0x80511f,%rax
  8191e1:	00 00 00 
  8191e4:	ff d0                	callq  *%rax
  8191e6:	eb 01                	jmp    8191e9 <thread_clean+0x78>
    return 0;
}

static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;
  8191e8:	90                   	nop
    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
    free(tc);
}
  8191e9:	c9                   	leaveq 
  8191ea:	c3                   	retq   

00000000008191eb <thread_halt>:

void
thread_halt() {
  8191eb:	55                   	push   %rbp
  8191ec:	48 89 e5             	mov    %rsp,%rbp
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));
  8191ef:	48 bf 90 74 b5 00 00 	movabs $0xb57490,%rdi
  8191f6:	00 00 00 
  8191f9:	48 b8 7d 8c 81 00 00 	movabs $0x818c7d,%rax
  819200:	00 00 00 
  819203:	ff d0                	callq  *%rax
  819205:	48 89 c7             	mov    %rax,%rdi
  819208:	48 b8 71 91 81 00 00 	movabs $0x819171,%rax
  81920f:	00 00 00 
  819212:	ff d0                	callq  *%rax

    threadq_push(&kill_queue, cur_tc);
  819214:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  81921b:	00 00 00 
  81921e:	48 8b 00             	mov    (%rax),%rax
  819221:	48 89 c6             	mov    %rax,%rsi
  819224:	48 bf 90 74 b5 00 00 	movabs $0xb57490,%rdi
  81922b:	00 00 00 
  81922e:	48 b8 17 8c 81 00 00 	movabs $0x818c17,%rax
  819235:	00 00 00 
  819238:	ff d0                	callq  *%rax
    cur_tc = NULL;
  81923a:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  819241:	00 00 00 
  819244:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    thread_yield();
  81924b:	48 b8 66 92 81 00 00 	movabs $0x819266,%rax
  819252:	00 00 00 
  819255:	ff d0                	callq  *%rax
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  819257:	48 b8 d4 10 80 00 00 	movabs $0x8010d4,%rax
  81925e:	00 00 00 
  819261:	ff d0                	callq  *%rax
}
  819263:	90                   	nop
  819264:	5d                   	pop    %rbp
  819265:	c3                   	retq   

0000000000819266 <thread_yield>:

void
thread_yield(void) {
  819266:	55                   	push   %rbp
  819267:	48 89 e5             	mov    %rsp,%rbp
  81926a:	48 83 ec 10          	sub    $0x10,%rsp
    struct thread_context *next_tc = threadq_pop(&thread_queue);
  81926e:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  819275:	00 00 00 
  819278:	48 b8 7d 8c 81 00 00 	movabs $0x818c7d,%rax
  81927f:	00 00 00 
  819282:	ff d0                	callq  *%rax
  819284:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    if (!next_tc)
  819288:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81928d:	0f 84 92 00 00 00    	je     819325 <thread_yield+0xbf>
	return;

    if (cur_tc) {
  819293:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  81929a:	00 00 00 
  81929d:	48 8b 00             	mov    (%rax),%rax
  8192a0:	48 85 c0             	test   %rax,%rax
  8192a3:	74 4a                	je     8192ef <thread_yield+0x89>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  8192a5:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  8192ac:	00 00 00 
  8192af:	48 8b 00             	mov    (%rax),%rax
  8192b2:	48 83 c0 40          	add    $0x40,%rax
  8192b6:	48 89 c7             	mov    %rax,%rdi
  8192b9:	48 b8 90 95 81 00 00 	movabs $0x819590,%rax
  8192c0:	00 00 00 
  8192c3:	ff d0                	callq  *%rax
  8192c5:	85 c0                	test   %eax,%eax
  8192c7:	75 5f                	jne    819328 <thread_yield+0xc2>
	    return;
	threadq_push(&thread_queue, cur_tc);
  8192c9:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  8192d0:	00 00 00 
  8192d3:	48 8b 00             	mov    (%rax),%rax
  8192d6:	48 89 c6             	mov    %rax,%rsi
  8192d9:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  8192e0:	00 00 00 
  8192e3:	48 b8 17 8c 81 00 00 	movabs $0x818c17,%rax
  8192ea:	00 00 00 
  8192ed:	ff d0                	callq  *%rax
    }

    cur_tc = next_tc;
  8192ef:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  8192f6:	00 00 00 
  8192f9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8192fd:	48 89 10             	mov    %rdx,(%rax)
    jos_longjmp(&cur_tc->tc_jb, 1);
  819300:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  819307:	00 00 00 
  81930a:	48 8b 00             	mov    (%rax),%rax
  81930d:	48 83 c0 40          	add    $0x40,%rax
  819311:	be 01 00 00 00       	mov    $0x1,%esi
  819316:	48 89 c7             	mov    %rax,%rdi
  819319:	48 b8 e0 95 81 00 00 	movabs $0x8195e0,%rax
  819320:	00 00 00 
  819323:	ff d0                	callq  *%rax
void
thread_yield(void) {
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;
  819325:	90                   	nop
  819326:	eb 01                	jmp    819329 <thread_yield+0xc3>

    if (cur_tc) {
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
	    return;
  819328:	90                   	nop
	threadq_push(&thread_queue, cur_tc);
    }

    cur_tc = next_tc;
    jos_longjmp(&cur_tc->tc_jb, 1);
}
  819329:	c9                   	leaveq 
  81932a:	c3                   	retq   

000000000081932b <print_jb>:

static void
print_jb(struct thread_context *tc) {
  81932b:	55                   	push   %rbp
  81932c:	48 89 e5             	mov    %rsp,%rbp
  81932f:	48 83 ec 10          	sub    $0x10,%rsp
  819333:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    cprintf("jump buffer for thread %s:\n", tc->tc_name);
  819337:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81933b:	48 83 c0 10          	add    $0x10,%rax
  81933f:	48 89 c6             	mov    %rax,%rsi
  819342:	48 bf d3 30 82 00 00 	movabs $0x8230d3,%rdi
  819349:	00 00 00 
  81934c:	b8 00 00 00 00       	mov    $0x0,%eax
  819351:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  819358:	00 00 00 
  81935b:	ff d2                	callq  *%rdx
    cprintf("\trip: %x\n", tc->tc_jb.jb_rip);
  81935d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819361:	48 8b 40 40          	mov    0x40(%rax),%rax
  819365:	48 89 c6             	mov    %rax,%rsi
  819368:	48 bf ef 30 82 00 00 	movabs $0x8230ef,%rdi
  81936f:	00 00 00 
  819372:	b8 00 00 00 00       	mov    $0x0,%eax
  819377:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  81937e:	00 00 00 
  819381:	ff d2                	callq  *%rdx
    cprintf("\trsp: %x\n", tc->tc_jb.jb_rsp);
  819383:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819387:	48 8b 40 48          	mov    0x48(%rax),%rax
  81938b:	48 89 c6             	mov    %rax,%rsi
  81938e:	48 bf f9 30 82 00 00 	movabs $0x8230f9,%rdi
  819395:	00 00 00 
  819398:	b8 00 00 00 00       	mov    $0x0,%eax
  81939d:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8193a4:	00 00 00 
  8193a7:	ff d2                	callq  *%rdx
    cprintf("\trbp: %x\n", tc->tc_jb.jb_rbp);
  8193a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8193ad:	48 8b 40 50          	mov    0x50(%rax),%rax
  8193b1:	48 89 c6             	mov    %rax,%rsi
  8193b4:	48 bf 03 31 82 00 00 	movabs $0x823103,%rdi
  8193bb:	00 00 00 
  8193be:	b8 00 00 00 00       	mov    $0x0,%eax
  8193c3:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8193ca:	00 00 00 
  8193cd:	ff d2                	callq  *%rdx
    cprintf("\trbx: %x\n", tc->tc_jb.jb_rbx);
  8193cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8193d3:	48 8b 40 58          	mov    0x58(%rax),%rax
  8193d7:	48 89 c6             	mov    %rax,%rsi
  8193da:	48 bf 0d 31 82 00 00 	movabs $0x82310d,%rdi
  8193e1:	00 00 00 
  8193e4:	b8 00 00 00 00       	mov    $0x0,%eax
  8193e9:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8193f0:	00 00 00 
  8193f3:	ff d2                	callq  *%rdx
    cprintf("\trsi: %x\n", tc->tc_jb.jb_rsi);
  8193f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8193f9:	48 8b 40 60          	mov    0x60(%rax),%rax
  8193fd:	48 89 c6             	mov    %rax,%rsi
  819400:	48 bf 17 31 82 00 00 	movabs $0x823117,%rdi
  819407:	00 00 00 
  81940a:	b8 00 00 00 00       	mov    $0x0,%eax
  81940f:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  819416:	00 00 00 
  819419:	ff d2                	callq  *%rdx
    cprintf("\trdi: %x\n", tc->tc_jb.jb_rdi);
  81941b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81941f:	48 8b 40 68          	mov    0x68(%rax),%rax
  819423:	48 89 c6             	mov    %rax,%rsi
  819426:	48 bf 21 31 82 00 00 	movabs $0x823121,%rdi
  81942d:	00 00 00 
  819430:	b8 00 00 00 00       	mov    $0x0,%eax
  819435:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  81943c:	00 00 00 
  81943f:	ff d2                	callq  *%rdx
    cprintf("\tr15: %x\n", tc->tc_jb.jb_r15);
  819441:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819445:	48 8b 40 70          	mov    0x70(%rax),%rax
  819449:	48 89 c6             	mov    %rax,%rsi
  81944c:	48 bf 2b 31 82 00 00 	movabs $0x82312b,%rdi
  819453:	00 00 00 
  819456:	b8 00 00 00 00       	mov    $0x0,%eax
  81945b:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  819462:	00 00 00 
  819465:	ff d2                	callq  *%rdx
    cprintf("\tr14: %x\n", tc->tc_jb.jb_r14);
  819467:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81946b:	48 8b 40 78          	mov    0x78(%rax),%rax
  81946f:	48 89 c6             	mov    %rax,%rsi
  819472:	48 bf 35 31 82 00 00 	movabs $0x823135,%rdi
  819479:	00 00 00 
  81947c:	b8 00 00 00 00       	mov    $0x0,%eax
  819481:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  819488:	00 00 00 
  81948b:	ff d2                	callq  *%rdx
    cprintf("\tr13: %x\n", tc->tc_jb.jb_r13);
  81948d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819491:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  819498:	48 89 c6             	mov    %rax,%rsi
  81949b:	48 bf 3f 31 82 00 00 	movabs $0x82313f,%rdi
  8194a2:	00 00 00 
  8194a5:	b8 00 00 00 00       	mov    $0x0,%eax
  8194aa:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8194b1:	00 00 00 
  8194b4:	ff d2                	callq  *%rdx
    cprintf("\tr12: %x\n", tc->tc_jb.jb_r12);
  8194b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8194ba:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8194c1:	48 89 c6             	mov    %rax,%rsi
  8194c4:	48 bf 49 31 82 00 00 	movabs $0x823149,%rdi
  8194cb:	00 00 00 
  8194ce:	b8 00 00 00 00       	mov    $0x0,%eax
  8194d3:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8194da:	00 00 00 
  8194dd:	ff d2                	callq  *%rdx
    cprintf("\tr11: %x\n", tc->tc_jb.jb_r11);
  8194df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8194e3:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  8194ea:	48 89 c6             	mov    %rax,%rsi
  8194ed:	48 bf 53 31 82 00 00 	movabs $0x823153,%rdi
  8194f4:	00 00 00 
  8194f7:	b8 00 00 00 00       	mov    $0x0,%eax
  8194fc:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  819503:	00 00 00 
  819506:	ff d2                	callq  *%rdx
    cprintf("\tr10: %x\n", tc->tc_jb.jb_r10);
  819508:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81950c:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  819513:	48 89 c6             	mov    %rax,%rsi
  819516:	48 bf 5d 31 82 00 00 	movabs $0x82315d,%rdi
  81951d:	00 00 00 
  819520:	b8 00 00 00 00       	mov    $0x0,%eax
  819525:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  81952c:	00 00 00 
  81952f:	ff d2                	callq  *%rdx
    cprintf("\tr9: %x\n", tc->tc_jb.jb_r9);
  819531:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819535:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  81953c:	48 89 c6             	mov    %rax,%rsi
  81953f:	48 bf 67 31 82 00 00 	movabs $0x823167,%rdi
  819546:	00 00 00 
  819549:	b8 00 00 00 00       	mov    $0x0,%eax
  81954e:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  819555:	00 00 00 
  819558:	ff d2                	callq  *%rdx
    cprintf("\tr8: %x\n", tc->tc_jb.jb_r8);
  81955a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81955e:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  819565:	48 89 c6             	mov    %rax,%rsi
  819568:	48 bf 70 31 82 00 00 	movabs $0x823170,%rdi
  81956f:	00 00 00 
  819572:	b8 00 00 00 00       	mov    $0x0,%eax
  819577:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  81957e:	00 00 00 
  819581:	ff d2                	callq  *%rdx
}
  819583:	90                   	nop
  819584:	c9                   	leaveq 
  819585:	c3                   	retq   
  819586:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  81958d:	00 00 00 

0000000000819590 <jos_setjmp>:


ENTRY(jos_setjmp)
	//movq	4(%esp), %ecx	// jos_jmp_buf

	movq	%rdi, %rcx	// jos_jmp_buf
  819590:	48 89 f9             	mov    %rdi,%rcx
	movq	0(%rsp), %rdx	// %rip as pushed by call
  819593:	48 8b 14 24          	mov    (%rsp),%rdx
	movq	%rdx,  0(%rcx)
  819597:	48 89 11             	mov    %rdx,(%rcx)

	leaq	8(%rsp), %rdx	// where %esp will point when we return
  81959a:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
	movq	%rdx,  8(%rcx)
  81959f:	48 89 51 08          	mov    %rdx,0x8(%rcx)

	movq	%rbp,  16(%rcx)
  8195a3:	48 89 69 10          	mov    %rbp,0x10(%rcx)
	movq	%rbx, 24(%rcx)
  8195a7:	48 89 59 18          	mov    %rbx,0x18(%rcx)
	movq	%rsi, 32(%rcx)
  8195ab:	48 89 71 20          	mov    %rsi,0x20(%rcx)
	movq	%rdi, 40(%rcx)
  8195af:	48 89 79 28          	mov    %rdi,0x28(%rcx)
	movq	%r15, 48(%rcx)
  8195b3:	4c 89 79 30          	mov    %r15,0x30(%rcx)
	movq	%r14, 56(%rcx)
  8195b7:	4c 89 71 38          	mov    %r14,0x38(%rcx)
	movq	%r13, 64(%rcx)
  8195bb:	4c 89 69 40          	mov    %r13,0x40(%rcx)
	movq	%r12, 72(%rcx)
  8195bf:	4c 89 61 48          	mov    %r12,0x48(%rcx)
	movq	%r11, 80(%rcx)
  8195c3:	4c 89 59 50          	mov    %r11,0x50(%rcx)
	movq	%r10, 88(%rcx)
  8195c7:	4c 89 51 58          	mov    %r10,0x58(%rcx)
	movq	%r9, 96(%rcx)
  8195cb:	4c 89 49 60          	mov    %r9,0x60(%rcx)
	movq	%r8, 104(%rcx)
  8195cf:	4c 89 41 68          	mov    %r8,0x68(%rcx)

	movq	$0, %rax
  8195d3:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
	ret
  8195da:	c3                   	retq   
  8195db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000008195e0 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value
	movq     %rdi, %rax
  8195e0:	48 89 f8             	mov    %rdi,%rax
	movq	 %rsi, %rdx
  8195e3:	48 89 f2             	mov    %rsi,%rdx
	movq	 0(%rax), %rcx	// %rip
  8195e6:	48 8b 08             	mov    (%rax),%rcx
	movq	 8(%rax), %rsp
  8195e9:	48 8b 60 08          	mov    0x8(%rax),%rsp
	movq	 16(%rax), %rbp
  8195ed:	48 8b 68 10          	mov    0x10(%rax),%rbp
	movq	24(%rax), %rbx
  8195f1:	48 8b 58 18          	mov    0x18(%rax),%rbx
	movq	32(%rax), %rsi
  8195f5:	48 8b 70 20          	mov    0x20(%rax),%rsi
	movq	40(%rax), %rdi
  8195f9:	48 8b 78 28          	mov    0x28(%rax),%rdi
	movq	48(%rax), %r15
  8195fd:	4c 8b 78 30          	mov    0x30(%rax),%r15
	movq	56(%rax), %r14
  819601:	4c 8b 70 38          	mov    0x38(%rax),%r14
	movq	64(%rax), %r13
  819605:	4c 8b 68 40          	mov    0x40(%rax),%r13
	movq	72(%rax), %r12
  819609:	4c 8b 60 48          	mov    0x48(%rax),%r12
	movq	80(%rax), %r11
  81960d:	4c 8b 58 50          	mov    0x50(%rax),%r11
	movq	88(%rax), %r10
  819611:	4c 8b 50 58          	mov    0x58(%rax),%r10
	movq	96(%rax), %r9
  819615:	4c 8b 48 60          	mov    0x60(%rax),%r9
	movq	104(%rax), %r8
  819619:	4c 8b 40 68          	mov    0x68(%rax),%r8

	movq	%rdx, %rax
  81961d:	48 89 d0             	mov    %rdx,%rax
	jmp	*%rcx
  819620:	ff e1                	jmpq   *%rcx

0000000000819622 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  819622:	55                   	push   %rbp
  819623:	48 89 e5             	mov    %rsp,%rbp
  819626:	48 83 ec 20          	sub    $0x20,%rsp
  81962a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int err = errno;
  81962e:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  819635:	00 00 00 
  819638:	8b 00                	mov    (%rax),%eax
  81963a:	89 45 fc             	mov    %eax,-0x4(%rbp)
	cprintf("%s: %s\n", s, e2s(err));
  81963d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  819640:	89 c7                	mov    %eax,%edi
  819642:	48 b8 76 96 81 00 00 	movabs $0x819676,%rax
  819649:	00 00 00 
  81964c:	ff d0                	callq  *%rax
  81964e:	48 89 c2             	mov    %rax,%rdx
  819651:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819655:	48 89 c6             	mov    %rax,%rsi
  819658:	48 bf 5d 36 82 00 00 	movabs $0x82365d,%rdi
  81965f:	00 00 00 
  819662:	b8 00 00 00 00       	mov    $0x0,%eax
  819667:	48 b9 32 13 80 00 00 	movabs $0x801332,%rcx
  81966e:	00 00 00 
  819671:	ff d1                	callq  *%rcx
}
  819673:	90                   	nop
  819674:	c9                   	leaveq 
  819675:	c3                   	retq   

0000000000819676 <e2s>:

const char *
e2s(int err) {
  819676:	55                   	push   %rbp
  819677:	48 89 e5             	mov    %rsp,%rbp
  81967a:	48 83 ec 08          	sub    $0x8,%rsp
  81967e:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return sys_errlist[err];
  819681:	48 b8 00 82 82 00 00 	movabs $0x828200,%rax
  819688:	00 00 00 
  81968b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81968e:	48 63 d2             	movslq %edx,%rdx
  819691:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
}
  819695:	c9                   	leaveq 
  819696:	c3                   	retq   

0000000000819697 <low_level_init>:
    envid_t envid;
};

static void
low_level_init(struct netif *netif)
{
  819697:	55                   	push   %rbp
  819698:	48 89 e5             	mov    %rsp,%rbp
  81969b:	48 83 ec 08          	sub    $0x8,%rsp
  81969f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    int r;

    netif->hwaddr_len = 6;
  8196a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8196a7:	c6 40 40 06          	movb   $0x6,0x40(%rax)
    netif->mtu = 1500;
  8196ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8196af:	66 c7 40 48 dc 05    	movw   $0x5dc,0x48(%rax)
    netif->flags = NETIF_FLAG_BROADCAST;
  8196b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8196b9:	c6 40 4a 02          	movb   $0x2,0x4a(%rax)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  8196bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8196c1:	c6 40 41 52          	movb   $0x52,0x41(%rax)
    netif->hwaddr[1] = 0x54;
  8196c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8196c9:	c6 40 42 54          	movb   $0x54,0x42(%rax)
    netif->hwaddr[2] = 0x00;
  8196cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8196d1:	c6 40 43 00          	movb   $0x0,0x43(%rax)
    netif->hwaddr[3] = 0x12;
  8196d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8196d9:	c6 40 44 12          	movb   $0x12,0x44(%rax)
    netif->hwaddr[4] = 0x34;
  8196dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8196e1:	c6 40 45 34          	movb   $0x34,0x45(%rax)
    netif->hwaddr[5] = 0x56;
  8196e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8196e9:	c6 40 46 56          	movb   $0x56,0x46(%rax)
}
  8196ed:	90                   	nop
  8196ee:	c9                   	leaveq 
  8196ef:	c3                   	retq   

00000000008196f0 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  8196f0:	55                   	push   %rbp
  8196f1:	48 89 e5             	mov    %rsp,%rbp
  8196f4:	48 83 ec 40          	sub    $0x40,%rsp
  8196f8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8196fc:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  819700:	ba 07 00 00 00       	mov    $0x7,%edx
  819705:	be 00 00 00 10       	mov    $0x10000000,%esi
  81970a:	bf 00 00 00 00       	mov    $0x0,%edi
  81970f:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  819716:	00 00 00 
  819719:	ff d0                	callq  *%rax
  81971b:	89 45 ec             	mov    %eax,-0x14(%rbp)
    if (r < 0)
  81971e:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  819722:	79 2a                	jns    81974e <low_level_output+0x5e>
	panic("jif: could not allocate page of memory");
  819724:	48 ba 68 36 82 00 00 	movabs $0x823668,%rdx
  81972b:	00 00 00 
  81972e:	be 56 00 00 00       	mov    $0x56,%esi
  819733:	48 bf 8f 36 82 00 00 	movabs $0x82368f,%rdi
  81973a:	00 00 00 
  81973d:	b8 00 00 00 00       	mov    $0x0,%eax
  819742:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819749:	00 00 00 
  81974c:	ff d1                	callq  *%rcx
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;
  81974e:	48 c7 45 e0 00 00 00 	movq   $0x10000000,-0x20(%rbp)
  819755:	10 

    struct jif *jif;
    jif = netif->state;
  819756:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81975a:	48 8b 40 30          	mov    0x30(%rax),%rax
  81975e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    char *txbuf = pkt->jp_data;
  819762:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  819766:	48 83 c0 04          	add    $0x4,%rax
  81976a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    int txsize = 0;
  81976e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  819775:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819779:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  81977d:	e9 a0 00 00 00       	jmpq   819822 <low_level_output+0x132>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  819782:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819786:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81978a:	0f b7 d0             	movzwl %ax,%edx
  81978d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  819790:	01 d0                	add    %edx,%eax
  819792:	3d d0 07 00 00       	cmp    $0x7d0,%eax
  819797:	7e 3e                	jle    8197d7 <low_level_output+0xe7>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  819799:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81979d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8197a1:	0f b7 c0             	movzwl %ax,%eax
  8197a4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8197a7:	41 89 d0             	mov    %edx,%r8d
  8197aa:	89 c1                	mov    %eax,%ecx
  8197ac:	48 ba a8 36 82 00 00 	movabs $0x8236a8,%rdx
  8197b3:	00 00 00 
  8197b6:	be 65 00 00 00       	mov    $0x65,%esi
  8197bb:	48 bf 8f 36 82 00 00 	movabs $0x82368f,%rdi
  8197c2:	00 00 00 
  8197c5:	b8 00 00 00 00       	mov    $0x0,%eax
  8197ca:	49 b9 f8 10 80 00 00 	movabs $0x8010f8,%r9
  8197d1:	00 00 00 
  8197d4:	41 ff d1             	callq  *%r9
	memcpy(&txbuf[txsize], q->payload, q->len);
  8197d7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8197db:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8197df:	0f b7 d0             	movzwl %ax,%edx
  8197e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8197e6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8197ea:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8197ed:	48 63 f1             	movslq %ecx,%rsi
  8197f0:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8197f4:	48 01 f1             	add    %rsi,%rcx
  8197f7:	48 89 c6             	mov    %rax,%rsi
  8197fa:	48 89 cf             	mov    %rcx,%rdi
  8197fd:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  819804:	00 00 00 
  819807:	ff d0                	callq  *%rax
	txsize += q->len;
  819809:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81980d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  819811:	0f b7 c0             	movzwl %ax,%eax
  819814:	01 45 fc             	add    %eax,-0x4(%rbp)
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  819817:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81981b:	48 8b 00             	mov    (%rax),%rax
  81981e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  819822:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  819827:	0f 85 55 ff ff ff    	jne    819782 <low_level_output+0x92>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  81982d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  819831:	8b 55 fc             	mov    -0x4(%rbp),%edx
  819834:	89 10                	mov    %edx,(%rax)

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  819836:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81983a:	8b 40 08             	mov    0x8(%rax),%eax
  81983d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  819841:	b9 07 00 00 00       	mov    $0x7,%ecx
  819846:	be 0b 00 00 00       	mov    $0xb,%esi
  81984b:	89 c7                	mov    %eax,%edi
  81984d:	48 b8 c9 33 80 00 00 	movabs $0x8033c9,%rax
  819854:	00 00 00 
  819857:	ff d0                	callq  *%rax
    sys_page_unmap(0, (void *)pkt);
  819859:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81985d:	48 89 c6             	mov    %rax,%rsi
  819860:	bf 00 00 00 00       	mov    $0x0,%edi
  819865:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  81986c:	00 00 00 
  81986f:	ff d0                	callq  *%rax

    return ERR_OK;
  819871:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819876:	c9                   	leaveq 
  819877:	c3                   	retq   

0000000000819878 <low_level_input>:
 * packet from the interface into the pbuf.
 *
 */
static struct pbuf *
low_level_input(void *va)
{
  819878:	55                   	push   %rbp
  819879:	48 89 e5             	mov    %rsp,%rbp
  81987c:	48 83 ec 50          	sub    $0x50,%rsp
  819880:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    struct jif_pkt *pkt = (struct jif_pkt *)va;
  819884:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819888:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    s16_t len = pkt->jp_len;
  81988c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  819890:	8b 00                	mov    (%rax),%eax
  819892:	66 89 45 de          	mov    %ax,-0x22(%rbp)

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  819896:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
  81989a:	0f b7 c0             	movzwl %ax,%eax
  81989d:	ba 03 00 00 00       	mov    $0x3,%edx
  8198a2:	89 c6                	mov    %eax,%esi
  8198a4:	bf 03 00 00 00       	mov    $0x3,%edi
  8198a9:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  8198b0:	00 00 00 
  8198b3:	ff d0                	callq  *%rax
  8198b5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (p == 0)
  8198b9:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8198be:	75 0a                	jne    8198ca <low_level_input+0x52>
	return 0;
  8198c0:	b8 00 00 00 00       	mov    $0x0,%eax
  8198c5:	e9 8a 00 00 00       	jmpq   819954 <low_level_input+0xdc>

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  8198ca:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8198ce:	48 83 c0 04          	add    $0x4,%rax
  8198d2:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    int copied = 0;
  8198d6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  8198dd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8198e1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8198e5:	eb 62                	jmp    819949 <low_level_input+0xd1>
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  8198e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8198eb:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8198ef:	0f b7 c0             	movzwl %ax,%eax
  8198f2:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if (bytes > (len - copied))
  8198f5:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  8198f9:	2b 45 fc             	sub    -0x4(%rbp),%eax
  8198fc:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8198ff:	7d 0a                	jge    81990b <low_level_input+0x93>
	    bytes = len - copied;
  819901:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  819905:	2b 45 fc             	sub    -0x4(%rbp),%eax
  819908:	89 45 ec             	mov    %eax,-0x14(%rbp)
	memcpy(q->payload, rxbuf + copied, bytes);
  81990b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81990e:	48 63 d0             	movslq %eax,%rdx
  819911:	8b 45 fc             	mov    -0x4(%rbp),%eax
  819914:	48 63 c8             	movslq %eax,%rcx
  819917:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81991b:	48 01 c1             	add    %rax,%rcx
  81991e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819922:	48 8b 40 08          	mov    0x8(%rax),%rax
  819926:	48 89 ce             	mov    %rcx,%rsi
  819929:	48 89 c7             	mov    %rax,%rdi
  81992c:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  819933:	00 00 00 
  819936:	ff d0                	callq  *%rax
	copied += bytes;
  819938:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81993b:	01 45 fc             	add    %eax,-0x4(%rbp)
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  81993e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819942:	48 8b 00             	mov    (%rax),%rax
  819945:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  819949:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81994e:	75 97                	jne    8198e7 <low_level_input+0x6f>
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
	copied += bytes;
    }

    return p;
  819950:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
}
  819954:	c9                   	leaveq 
  819955:	c3                   	retq   

0000000000819956 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  819956:	55                   	push   %rbp
  819957:	48 89 e5             	mov    %rsp,%rbp
  81995a:	48 83 ec 20          	sub    $0x20,%rsp
  81995e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  819962:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  819966:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  81996a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81996e:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  819972:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819976:	48 89 ce             	mov    %rcx,%rsi
  819979:	48 89 c7             	mov    %rax,%rdi
  81997c:	48 b8 68 6b 81 00 00 	movabs $0x816b68,%rax
  819983:	00 00 00 
  819986:	ff d0                	callq  *%rax
}
  819988:	c9                   	leaveq 
  819989:	c3                   	retq   

000000000081998a <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  81998a:	55                   	push   %rbp
  81998b:	48 89 e5             	mov    %rsp,%rbp
  81998e:	48 83 ec 30          	sub    $0x30,%rsp
  819992:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  819996:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  81999a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81999e:	48 8b 40 30          	mov    0x30(%rax),%rax
  8199a2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
    /* move received packet into a new pbuf */
    p = low_level_input(va);
  8199a6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8199aa:	48 89 c7             	mov    %rax,%rdi
  8199ad:	48 b8 78 98 81 00 00 	movabs $0x819878,%rax
  8199b4:	00 00 00 
  8199b7:	ff d0                	callq  *%rax
  8199b9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
  8199bd:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8199c2:	0f 84 bc 00 00 00    	je     819a84 <jif_input+0xfa>
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;
  8199c8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8199cc:	48 8b 40 08          	mov    0x8(%rax),%rax
  8199d0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    switch (htons(ethhdr->type)) {
  8199d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8199d8:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8199dc:	0f b7 c0             	movzwl %ax,%eax
  8199df:	89 c7                	mov    %eax,%edi
  8199e1:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  8199e8:	00 00 00 
  8199eb:	ff d0                	callq  *%rax
  8199ed:	0f b7 c0             	movzwl %ax,%eax
  8199f0:	3d 00 08 00 00       	cmp    $0x800,%eax
  8199f5:	74 09                	je     819a00 <jif_input+0x76>
  8199f7:	3d 06 08 00 00       	cmp    $0x806,%eax
  8199fc:	74 4e                	je     819a4c <jif_input+0xc2>
  8199fe:	eb 6f                	jmp    819a6f <jif_input+0xe5>
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  819a00:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  819a04:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819a08:	48 89 d6             	mov    %rdx,%rsi
  819a0b:	48 89 c7             	mov    %rax,%rdi
  819a0e:	48 b8 87 67 81 00 00 	movabs $0x816787,%rax
  819a15:	00 00 00 
  819a18:	ff d0                	callq  *%rax
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  819a1a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819a1e:	be f2 ff ff ff       	mov    $0xfffffff2,%esi
  819a23:	48 89 c7             	mov    %rax,%rdi
  819a26:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  819a2d:	00 00 00 
  819a30:	ff d0                	callq  *%rax
	/* pass to network layer */
	netif->input(p, netif);
  819a32:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819a36:	48 8b 40 18          	mov    0x18(%rax),%rax
  819a3a:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  819a3e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  819a42:	48 89 ce             	mov    %rcx,%rsi
  819a45:	48 89 d7             	mov    %rdx,%rdi
  819a48:	ff d0                	callq  *%rax
	break;
  819a4a:	eb 39                	jmp    819a85 <jif_input+0xfb>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  819a4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819a50:	48 8b 08             	mov    (%rax),%rcx
  819a53:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  819a57:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819a5b:	48 89 ce             	mov    %rcx,%rsi
  819a5e:	48 89 c7             	mov    %rax,%rdi
  819a61:	48 b8 1e 68 81 00 00 	movabs $0x81681e,%rax
  819a68:	00 00 00 
  819a6b:	ff d0                	callq  *%rax
	break;
  819a6d:	eb 16                	jmp    819a85 <jif_input+0xfb>

    default:
	pbuf_free(p);
  819a6f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819a73:	48 89 c7             	mov    %rax,%rdi
  819a76:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  819a7d:	00 00 00 
  819a80:	ff d0                	callq  *%rax
  819a82:	eb 01                	jmp    819a85 <jif_input+0xfb>
  
    /* move received packet into a new pbuf */
    p = low_level_input(va);

    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
  819a84:	90                   	nop
	break;

    default:
	pbuf_free(p);
    }
}
  819a85:	c9                   	leaveq 
  819a86:	c3                   	retq   

0000000000819a87 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  819a87:	55                   	push   %rbp
  819a88:	48 89 e5             	mov    %rsp,%rbp
  819a8b:	48 83 ec 30          	sub    $0x30,%rsp
  819a8f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  819a93:	bf 10 00 00 00       	mov    $0x10,%edi
  819a98:	48 b8 95 c9 80 00 00 	movabs $0x80c995,%rax
  819a9f:	00 00 00 
  819aa2:	ff d0                	callq  *%rax
  819aa4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    if (jif == NULL) {
  819aa8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819aad:	75 0a                	jne    819ab9 <jif_init+0x32>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  819aaf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  819ab4:	e9 ce 00 00 00       	jmpq   819b87 <jif_init+0x100>
    }

    output_envid = (envid_t *)netif->state;
  819ab9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819abd:	48 8b 40 30          	mov    0x30(%rax),%rax
  819ac1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

    netif->state = jif;
  819ac5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819ac9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  819acd:	48 89 50 30          	mov    %rdx,0x30(%rax)
    netif->output = jif_output;
  819ad1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819ad5:	48 b9 56 99 81 00 00 	movabs $0x819956,%rcx
  819adc:	00 00 00 
  819adf:	48 89 48 20          	mov    %rcx,0x20(%rax)
    netif->linkoutput = low_level_output;
  819ae3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819ae7:	48 be f0 96 81 00 00 	movabs $0x8196f0,%rsi
  819aee:	00 00 00 
  819af1:	48 89 70 28          	mov    %rsi,0x28(%rax)
    memcpy(&netif->name[0], "en", 2);
  819af5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819af9:	48 83 c0 4b          	add    $0x4b,%rax
  819afd:	ba 02 00 00 00       	mov    $0x2,%edx
  819b02:	48 be d1 36 82 00 00 	movabs $0x8236d1,%rsi
  819b09:	00 00 00 
  819b0c:	48 89 c7             	mov    %rax,%rdi
  819b0f:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  819b16:	00 00 00 
  819b19:	ff d0                	callq  *%rax

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  819b1b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819b1f:	48 8d 50 41          	lea    0x41(%rax),%rdx
  819b23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819b27:	48 89 10             	mov    %rdx,(%rax)
    jif->envid = *output_envid; 
  819b2a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819b2e:	8b 10                	mov    (%rax),%edx
  819b30:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819b34:	89 50 08             	mov    %edx,0x8(%rax)

    low_level_init(netif);
  819b37:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819b3b:	48 89 c7             	mov    %rax,%rdi
  819b3e:	48 b8 97 96 81 00 00 	movabs $0x819697,%rax
  819b45:	00 00 00 
  819b48:	ff d0                	callq  *%rax
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  819b4a:	48 bf d4 36 82 00 00 	movabs $0x8236d4,%rdi
  819b51:	00 00 00 
  819b54:	48 b8 4d 2c 81 00 00 	movabs $0x812c4d,%rax
  819b5b:	00 00 00 
  819b5e:	ff d0                	callq  *%rax
  819b60:	89 45 ec             	mov    %eax,-0x14(%rbp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  819b63:	48 8d 4d ec          	lea    -0x14(%rbp),%rcx
  819b67:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819b6b:	ba 00 00 00 00       	mov    $0x0,%edx
  819b70:	48 89 ce             	mov    %rcx,%rsi
  819b73:	48 89 c7             	mov    %rax,%rdi
  819b76:	48 b8 fa 6c 81 00 00 	movabs $0x816cfa,%rax
  819b7d:	00 00 00 
  819b80:	ff d0                	callq  *%rax

    return ERR_OK;
  819b82:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819b87:	c9                   	leaveq 
  819b88:	c3                   	retq   

0000000000819b89 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  819b89:	55                   	push   %rbp
  819b8a:	48 89 e5             	mov    %rsp,%rbp
  819b8d:	48 83 ec 40          	sub    $0x40,%rsp
  819b91:	89 7d cc             	mov    %edi,-0x34(%rbp)
  819b94:	89 f0                	mov    %esi,%eax
  819b96:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  819b9a:	88 45 c8             	mov    %al,-0x38(%rbp)
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  819b9d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  819ba1:	8b 45 cc             	mov    -0x34(%rbp),%eax
  819ba4:	48 89 d6             	mov    %rdx,%rsi
  819ba7:	89 c7                	mov    %eax,%edi
  819ba9:	48 b8 0e b2 81 00 00 	movabs $0x81b20e,%rax
  819bb0:	00 00 00 
  819bb3:	ff d0                	callq  *%rax
  819bb5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
  if (conn != NULL ) {
  819bb9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819bbe:	0f 84 62 01 00 00    	je     819d26 <netconn_new_with_proto_and_callback+0x19d>
    msg.function = do_newconn;
  819bc4:	48 b8 c4 b1 81 00 00 	movabs $0x81b1c4,%rax
  819bcb:	00 00 00 
  819bce:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    msg.msg.msg.n.proto = proto;
  819bd2:	0f b6 45 c8          	movzbl -0x38(%rbp),%eax
  819bd6:	88 45 e0             	mov    %al,-0x20(%rbp)
    msg.msg.conn = conn;
  819bd9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819bdd:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    TCPIP_APIMSG(&msg);
  819be1:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819be5:	48 89 c7             	mov    %rax,%rdi
  819be8:	48 b8 75 8c 80 00 00 	movabs $0x808c75,%rax
  819bef:	00 00 00 
  819bf2:	ff d0                	callq  *%rax

    if (conn->err != ERR_OK) {
  819bf4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819bf8:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  819bfc:	84 c0                	test   %al,%al
  819bfe:	0f 84 22 01 00 00    	je     819d26 <netconn_new_with_proto_and_callback+0x19d>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  819c04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819c08:	48 8b 40 08          	mov    0x8(%rax),%rax
  819c0c:	48 85 c0             	test   %rax,%rax
  819c0f:	74 2a                	je     819c3b <netconn_new_with_proto_and_callback+0xb2>
  819c11:	48 ba e0 36 82 00 00 	movabs $0x8236e0,%rdx
  819c18:	00 00 00 
  819c1b:	be 53 00 00 00       	mov    $0x53,%esi
  819c20:	48 bf 01 37 82 00 00 	movabs $0x823701,%rdi
  819c27:	00 00 00 
  819c2a:	b8 00 00 00 00       	mov    $0x0,%eax
  819c2f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819c36:	00 00 00 
  819c39:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  819c3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819c3f:	8b 40 14             	mov    0x14(%rax),%eax
  819c42:	83 f8 ff             	cmp    $0xffffffff,%eax
  819c45:	75 2a                	jne    819c71 <netconn_new_with_proto_and_callback+0xe8>
  819c47:	48 ba 18 37 82 00 00 	movabs $0x823718,%rdx
  819c4e:	00 00 00 
  819c51:	be 54 00 00 00       	mov    $0x54,%esi
  819c56:	48 bf 01 37 82 00 00 	movabs $0x823701,%rdi
  819c5d:	00 00 00 
  819c60:	b8 00 00 00 00       	mov    $0x0,%eax
  819c65:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819c6c:	00 00 00 
  819c6f:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  819c71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819c75:	8b 40 18             	mov    0x18(%rax),%eax
  819c78:	83 f8 ff             	cmp    $0xffffffff,%eax
  819c7b:	75 2a                	jne    819ca7 <netconn_new_with_proto_and_callback+0x11e>
  819c7d:	48 ba 31 37 82 00 00 	movabs $0x823731,%rdx
  819c84:	00 00 00 
  819c87:	be 55 00 00 00       	mov    $0x55,%esi
  819c8c:	48 bf 01 37 82 00 00 	movabs $0x823701,%rdi
  819c93:	00 00 00 
  819c96:	b8 00 00 00 00       	mov    $0x0,%eax
  819c9b:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819ca2:	00 00 00 
  819ca5:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  819ca7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819cab:	8b 40 1c             	mov    0x1c(%rax),%eax
  819cae:	83 f8 ff             	cmp    $0xffffffff,%eax
  819cb1:	74 2a                	je     819cdd <netconn_new_with_proto_and_callback+0x154>
  819cb3:	48 ba 48 37 82 00 00 	movabs $0x823748,%rdx
  819cba:	00 00 00 
  819cbd:	be 56 00 00 00       	mov    $0x56,%esi
  819cc2:	48 bf 01 37 82 00 00 	movabs $0x823701,%rdi
  819cc9:	00 00 00 
  819ccc:	b8 00 00 00 00       	mov    $0x0,%eax
  819cd1:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819cd8:	00 00 00 
  819cdb:	ff d1                	callq  *%rcx
      sys_sem_free(conn->op_completed);
  819cdd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819ce1:	8b 40 14             	mov    0x14(%rax),%eax
  819ce4:	89 c7                	mov    %eax,%edi
  819ce6:	48 b8 df 7f 81 00 00 	movabs $0x817fdf,%rax
  819ced:	00 00 00 
  819cf0:	ff d0                	callq  *%rax
      sys_mbox_free(conn->recvmbox);
  819cf2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819cf6:	8b 40 18             	mov    0x18(%rax),%eax
  819cf9:	89 c7                	mov    %eax,%edi
  819cfb:	48 b8 c2 79 81 00 00 	movabs $0x8179c2,%rax
  819d02:	00 00 00 
  819d05:	ff d0                	callq  *%rax
      memp_free(MEMP_NETCONN, conn);
  819d07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819d0b:	48 89 c6             	mov    %rax,%rsi
  819d0e:	bf 07 00 00 00       	mov    $0x7,%edi
  819d13:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  819d1a:	00 00 00 
  819d1d:	ff d0                	callq  *%rax
      return NULL;
  819d1f:	b8 00 00 00 00       	mov    $0x0,%eax
  819d24:	eb 04                	jmp    819d2a <netconn_new_with_proto_and_callback+0x1a1>
    }
  }
  return conn;
  819d26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  819d2a:	c9                   	leaveq 
  819d2b:	c3                   	retq   

0000000000819d2c <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  819d2c:	55                   	push   %rbp
  819d2d:	48 89 e5             	mov    %rsp,%rbp
  819d30:	48 83 ec 40          	sub    $0x40,%rsp
  819d34:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  819d38:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819d3d:	75 07                	jne    819d46 <netconn_delete+0x1a>
    return ERR_OK;
  819d3f:	b8 00 00 00 00       	mov    $0x0,%eax
  819d44:	eb 4d                	jmp    819d93 <netconn_delete+0x67>
  }

  msg.function = do_delconn;
  819d46:	48 b8 de b7 81 00 00 	movabs $0x81b7de,%rax
  819d4d:	00 00 00 
  819d50:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819d54:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819d58:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  tcpip_apimsg(&msg);
  819d5c:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819d60:	48 89 c7             	mov    %rax,%rdi
  819d63:	48 b8 75 8c 80 00 00 	movabs $0x808c75,%rax
  819d6a:	00 00 00 
  819d6d:	ff d0                	callq  *%rax

  conn->pcb.tcp = NULL;
  819d6f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819d73:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  819d7a:	00 
  netconn_free(conn);
  819d7b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819d7f:	48 89 c7             	mov    %rax,%rdi
  819d82:	48 b8 46 b3 81 00 00 	movabs $0x81b346,%rax
  819d89:	00 00 00 
  819d8c:	ff d0                	callq  *%rax

  return ERR_OK;
  819d8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819d93:	c9                   	leaveq 
  819d94:	c3                   	retq   

0000000000819d95 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  819d95:	55                   	push   %rbp
  819d96:	48 89 e5             	mov    %rsp,%rbp
  819d99:	48 83 ec 10          	sub    $0x10,%rsp
  819d9d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  819da1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819da6:	75 2a                	jne    819dd2 <netconn_type+0x3d>
  819da8:	48 ba 69 37 82 00 00 	movabs $0x823769,%rdx
  819daf:	00 00 00 
  819db2:	be 85 00 00 00       	mov    $0x85,%esi
  819db7:	48 bf 01 37 82 00 00 	movabs $0x823701,%rdi
  819dbe:	00 00 00 
  819dc1:	b8 00 00 00 00       	mov    $0x0,%eax
  819dc6:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819dcd:	00 00 00 
  819dd0:	ff d1                	callq  *%rcx
  return conn->type;
  819dd2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819dd6:	8b 00                	mov    (%rax),%eax
}
  819dd8:	c9                   	leaveq 
  819dd9:	c3                   	retq   

0000000000819dda <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  819dda:	55                   	push   %rbp
  819ddb:	48 89 e5             	mov    %rsp,%rbp
  819dde:	48 83 ec 50          	sub    $0x50,%rsp
  819de2:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819de6:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819dea:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  819dee:	89 c8                	mov    %ecx,%eax
  819df0:	88 45 b4             	mov    %al,-0x4c(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  819df3:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819df8:	75 2a                	jne    819e24 <netconn_getaddr+0x4a>
  819dfa:	48 ba 84 37 82 00 00 	movabs $0x823784,%rdx
  819e01:	00 00 00 
  819e04:	be 99 00 00 00       	mov    $0x99,%esi
  819e09:	48 bf 01 37 82 00 00 	movabs $0x823701,%rdi
  819e10:	00 00 00 
  819e13:	b8 00 00 00 00       	mov    $0x0,%eax
  819e18:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819e1f:	00 00 00 
  819e22:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  819e24:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  819e29:	75 2a                	jne    819e55 <netconn_getaddr+0x7b>
  819e2b:	48 ba a2 37 82 00 00 	movabs $0x8237a2,%rdx
  819e32:	00 00 00 
  819e35:	be 9a 00 00 00       	mov    $0x9a,%esi
  819e3a:	48 bf 01 37 82 00 00 	movabs $0x823701,%rdi
  819e41:	00 00 00 
  819e44:	b8 00 00 00 00       	mov    $0x0,%eax
  819e49:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819e50:	00 00 00 
  819e53:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  819e55:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  819e5a:	75 2a                	jne    819e86 <netconn_getaddr+0xac>
  819e5c:	48 ba c0 37 82 00 00 	movabs $0x8237c0,%rdx
  819e63:	00 00 00 
  819e66:	be 9b 00 00 00       	mov    $0x9b,%esi
  819e6b:	48 bf 01 37 82 00 00 	movabs $0x823701,%rdi
  819e72:	00 00 00 
  819e75:	b8 00 00 00 00       	mov    $0x0,%eax
  819e7a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819e81:	00 00 00 
  819e84:	ff d1                	callq  *%rcx

  msg.function = do_getaddr;
  819e86:	48 b8 8b c3 81 00 00 	movabs $0x81c38b,%rax
  819e8d:	00 00 00 
  819e90:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819e94:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819e98:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.ad.ipaddr = addr;
  819e9c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819ea0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.ad.port = port;
  819ea4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819ea8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  msg.msg.msg.ad.local = local;
  819eac:	0f b6 45 b4          	movzbl -0x4c(%rbp),%eax
  819eb0:	88 45 f0             	mov    %al,-0x10(%rbp)
  TCPIP_APIMSG(&msg);
  819eb3:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819eb7:	48 89 c7             	mov    %rax,%rdi
  819eba:	48 b8 75 8c 80 00 00 	movabs $0x808c75,%rax
  819ec1:	00 00 00 
  819ec4:	ff d0                	callq  *%rax

  return conn->err;
  819ec6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819eca:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819ece:	c9                   	leaveq 
  819ecf:	c3                   	retq   

0000000000819ed0 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  819ed0:	55                   	push   %rbp
  819ed1:	48 89 e5             	mov    %rsp,%rbp
  819ed4:	48 83 ec 50          	sub    $0x50,%rsp
  819ed8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819edc:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819ee0:	89 d0                	mov    %edx,%eax
  819ee2:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  819ee6:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819eeb:	75 2a                	jne    819f17 <netconn_bind+0x47>
  819eed:	48 ba de 37 82 00 00 	movabs $0x8237de,%rdx
  819ef4:	00 00 00 
  819ef7:	be b6 00 00 00       	mov    $0xb6,%esi
  819efc:	48 bf 01 37 82 00 00 	movabs $0x823701,%rdi
  819f03:	00 00 00 
  819f06:	b8 00 00 00 00       	mov    $0x0,%eax
  819f0b:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819f12:	00 00 00 
  819f15:	ff d1                	callq  *%rcx

  msg.function = do_bind;
  819f17:	48 b8 1c b9 81 00 00 	movabs $0x81b91c,%rax
  819f1e:	00 00 00 
  819f21:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819f25:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819f29:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.bc.ipaddr = addr;
  819f2d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819f31:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.bc.port = port;
  819f35:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  819f39:	66 89 45 e8          	mov    %ax,-0x18(%rbp)
  TCPIP_APIMSG(&msg);
  819f3d:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819f41:	48 89 c7             	mov    %rax,%rdi
  819f44:	48 b8 75 8c 80 00 00 	movabs $0x808c75,%rax
  819f4b:	00 00 00 
  819f4e:	ff d0                	callq  *%rax
  return conn->err;
  819f50:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819f54:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819f58:	c9                   	leaveq 
  819f59:	c3                   	retq   

0000000000819f5a <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  819f5a:	55                   	push   %rbp
  819f5b:	48 89 e5             	mov    %rsp,%rbp
  819f5e:	48 83 ec 50          	sub    $0x50,%rsp
  819f62:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819f66:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819f6a:	89 d0                	mov    %edx,%eax
  819f6c:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  819f70:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819f75:	75 2a                	jne    819fa1 <netconn_connect+0x47>
  819f77:	48 ba f9 37 82 00 00 	movabs $0x8237f9,%rdx
  819f7e:	00 00 00 
  819f81:	be cd 00 00 00       	mov    $0xcd,%esi
  819f86:	48 bf 01 37 82 00 00 	movabs $0x823701,%rdi
  819f8d:	00 00 00 
  819f90:	b8 00 00 00 00       	mov    $0x0,%eax
  819f95:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819f9c:	00 00 00 
  819f9f:	ff d1                	callq  *%rcx

  msg.function = do_connect;
  819fa1:	48 b8 ca ba 81 00 00 	movabs $0x81baca,%rax
  819fa8:	00 00 00 
  819fab:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819faf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819fb3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.bc.ipaddr = addr;
  819fb7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819fbb:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.bc.port = port;
  819fbf:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  819fc3:	66 89 45 e8          	mov    %ax,-0x18(%rbp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  819fc7:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819fcb:	48 89 c7             	mov    %rax,%rdi
  819fce:	48 b8 75 8c 80 00 00 	movabs $0x808c75,%rax
  819fd5:	00 00 00 
  819fd8:	ff d0                	callq  *%rax
  return conn->err;
  819fda:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819fde:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819fe2:	c9                   	leaveq 
  819fe3:	c3                   	retq   

0000000000819fe4 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  819fe4:	55                   	push   %rbp
  819fe5:	48 89 e5             	mov    %rsp,%rbp
  819fe8:	48 83 ec 40          	sub    $0x40,%rsp
  819fec:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  819ff0:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819ff5:	75 2a                	jne    81a021 <netconn_disconnect+0x3d>
  819ff7:	48 ba 18 38 82 00 00 	movabs $0x823818,%rdx
  819ffe:	00 00 00 
  81a001:	be e3 00 00 00       	mov    $0xe3,%esi
  81a006:	48 bf 01 37 82 00 00 	movabs $0x823701,%rdi
  81a00d:	00 00 00 
  81a010:	b8 00 00 00 00       	mov    $0x0,%eax
  81a015:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a01c:	00 00 00 
  81a01f:	ff d1                	callq  *%rcx

  msg.function = do_disconnect;
  81a021:	48 b8 37 bc 81 00 00 	movabs $0x81bc37,%rax
  81a028:	00 00 00 
  81a02b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a02f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a033:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  TCPIP_APIMSG(&msg);
  81a037:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a03b:	48 89 c7             	mov    %rax,%rdi
  81a03e:	48 b8 75 8c 80 00 00 	movabs $0x808c75,%rax
  81a045:	00 00 00 
  81a048:	ff d0                	callq  *%rax
  return conn->err;
  81a04a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a04e:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a052:	c9                   	leaveq 
  81a053:	c3                   	retq   

000000000081a054 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  81a054:	55                   	push   %rbp
  81a055:	48 89 e5             	mov    %rsp,%rbp
  81a058:	48 83 ec 40          	sub    $0x40,%rsp
  81a05c:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81a060:	89 f0                	mov    %esi,%eax
  81a062:	88 45 c4             	mov    %al,-0x3c(%rbp)
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  81a065:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81a06a:	75 2a                	jne    81a096 <netconn_listen_with_backlog+0x42>
  81a06c:	48 ba 39 38 82 00 00 	movabs $0x823839,%rdx
  81a073:	00 00 00 
  81a076:	be fb 00 00 00       	mov    $0xfb,%esi
  81a07b:	48 bf 01 37 82 00 00 	movabs $0x823701,%rdi
  81a082:	00 00 00 
  81a085:	b8 00 00 00 00       	mov    $0x0,%eax
  81a08a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a091:	00 00 00 
  81a094:	ff d1                	callq  *%rcx

  msg.function = do_listen;
  81a096:	48 b8 8b bc 81 00 00 	movabs $0x81bc8b,%rax
  81a09d:	00 00 00 
  81a0a0:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a0a4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a0a8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  81a0ac:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a0b0:	48 89 c7             	mov    %rax,%rdi
  81a0b3:	48 b8 75 8c 80 00 00 	movabs $0x808c75,%rax
  81a0ba:	00 00 00 
  81a0bd:	ff d0                	callq  *%rax
  return conn->err;
  81a0bf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a0c3:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a0c7:	c9                   	leaveq 
  81a0c8:	c3                   	retq   

000000000081a0c9 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  81a0c9:	55                   	push   %rbp
  81a0ca:	48 89 e5             	mov    %rsp,%rbp
  81a0cd:	48 83 ec 20          	sub    $0x20,%rsp
  81a0d1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  81a0d5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a0da:	75 2a                	jne    81a106 <netconn_accept+0x3d>
  81a0dc:	48 ba 56 38 82 00 00 	movabs $0x823856,%rdx
  81a0e3:	00 00 00 
  81a0e6:	be 11 01 00 00       	mov    $0x111,%esi
  81a0eb:	48 bf 01 37 82 00 00 	movabs $0x823701,%rdi
  81a0f2:	00 00 00 
  81a0f5:	b8 00 00 00 00       	mov    $0x0,%eax
  81a0fa:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a101:	00 00 00 
  81a104:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  81a106:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a10a:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a10d:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a110:	75 2a                	jne    81a13c <netconn_accept+0x73>
  81a112:	48 ba 78 38 82 00 00 	movabs $0x823878,%rdx
  81a119:	00 00 00 
  81a11c:	be 12 01 00 00       	mov    $0x112,%esi
  81a121:	48 bf 01 37 82 00 00 	movabs $0x823701,%rdi
  81a128:	00 00 00 
  81a12b:	b8 00 00 00 00       	mov    $0x0,%eax
  81a130:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a137:	00 00 00 
  81a13a:	ff d1                	callq  *%rcx
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  81a13c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a140:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a143:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  81a147:	ba 00 00 00 00       	mov    $0x0,%edx
  81a14c:	48 89 ce             	mov    %rcx,%rsi
  81a14f:	89 c7                	mov    %eax,%edi
  81a151:	48 b8 a6 84 81 00 00 	movabs $0x8184a6,%rax
  81a158:	00 00 00 
  81a15b:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  81a15d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a161:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a165:	48 85 c0             	test   %rax,%rax
  81a168:	74 1b                	je     81a185 <netconn_accept+0xbc>
  81a16a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a16e:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a172:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81a176:	ba 00 00 00 00       	mov    $0x0,%edx
  81a17b:	be 01 00 00 00       	mov    $0x1,%esi
  81a180:	48 89 cf             	mov    %rcx,%rdi
  81a183:	ff d0                	callq  *%rax
      TCPIP_APIMSG(&msg);
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
  81a185:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81a189:	c9                   	leaveq 
  81a18a:	c3                   	retq   

000000000081a18b <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  81a18b:	55                   	push   %rbp
  81a18c:	48 89 e5             	mov    %rsp,%rbp
  81a18f:	48 83 ec 50          	sub    $0x50,%rsp
  81a193:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  struct api_msg msg;
  struct netbuf *buf = NULL;
  81a197:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  81a19e:	00 
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  81a19f:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  81a1a4:	75 2a                	jne    81a1d0 <netconn_recv+0x45>
  81a1a6:	48 ba 9b 38 82 00 00 	movabs $0x82389b,%rdx
  81a1ad:	00 00 00 
  81a1b0:	be 3b 01 00 00       	mov    $0x13b,%esi
  81a1b5:	48 bf 01 37 82 00 00 	movabs $0x823701,%rdi
  81a1bc:	00 00 00 
  81a1bf:	b8 00 00 00 00       	mov    $0x0,%eax
  81a1c4:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a1cb:	00 00 00 
  81a1ce:	ff d1                	callq  *%rcx

  if (conn->recvmbox == SYS_MBOX_NULL) {
  81a1d0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a1d4:	8b 40 18             	mov    0x18(%rax),%eax
  81a1d7:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a1da:	75 12                	jne    81a1ee <netconn_recv+0x63>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  81a1dc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a1e0:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
    return NULL;
  81a1e4:	b8 00 00 00 00       	mov    $0x0,%eax
  81a1e9:	e9 21 02 00 00       	jmpq   81a40f <netconn_recv+0x284>
  }

  if (ERR_IS_FATAL(conn->err)) {
  81a1ee:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a1f2:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81a1f6:	3c fc                	cmp    $0xfc,%al
  81a1f8:	7d 0a                	jge    81a204 <netconn_recv+0x79>
    return NULL;
  81a1fa:	b8 00 00 00 00       	mov    $0x0,%eax
  81a1ff:	e9 0b 02 00 00       	jmpq   81a40f <netconn_recv+0x284>
  }

  if (conn->type == NETCONN_TCP) {
  81a204:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a208:	8b 00                	mov    (%rax),%eax
  81a20a:	83 f8 10             	cmp    $0x10,%eax
  81a20d:	0f 85 80 01 00 00    	jne    81a393 <netconn_recv+0x208>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  81a213:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a217:	8b 40 04             	mov    0x4(%rax),%eax
  81a21a:	83 f8 02             	cmp    $0x2,%eax
  81a21d:	75 12                	jne    81a231 <netconn_recv+0xa6>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  81a21f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a223:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
      return NULL;
  81a227:	b8 00 00 00 00       	mov    $0x0,%eax
  81a22c:	e9 de 01 00 00       	jmpq   81a40f <netconn_recv+0x284>
    }

    buf = memp_malloc(MEMP_NETBUF);
  81a231:	bf 06 00 00 00       	mov    $0x6,%edi
  81a236:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  81a23d:	00 00 00 
  81a240:	ff d0                	callq  *%rax
  81a242:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

    if (buf == NULL) {
  81a246:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a24a:	48 85 c0             	test   %rax,%rax
  81a24d:	75 12                	jne    81a261 <netconn_recv+0xd6>
      conn->err = ERR_MEM;
  81a24f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a253:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
      return NULL;
  81a257:	b8 00 00 00 00       	mov    $0x0,%eax
  81a25c:	e9 ae 01 00 00       	jmpq   81a40f <netconn_recv+0x284>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  81a261:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a265:	8b 40 18             	mov    0x18(%rax),%eax
  81a268:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  81a26c:	ba 00 00 00 00       	mov    $0x0,%edx
  81a271:	48 89 ce             	mov    %rcx,%rsi
  81a274:	89 c7                	mov    %eax,%edi
  81a276:	48 b8 a6 84 81 00 00 	movabs $0x8184a6,%rax
  81a27d:	00 00 00 
  81a280:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  81a282:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a286:	48 85 c0             	test   %rax,%rax
  81a289:	74 24                	je     81a2af <netconn_recv+0x124>
      len = p->tot_len;
  81a28b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a28f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a293:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
      SYS_ARCH_DEC(conn->recv_avail, len);
  81a297:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a29b:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  81a29f:	66 2b 45 fe          	sub    -0x2(%rbp),%ax
  81a2a3:	89 c2                	mov    %eax,%edx
  81a2a5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a2a9:	66 89 50 24          	mov    %dx,0x24(%rax)
  81a2ad:	eb 06                	jmp    81a2b5 <netconn_recv+0x12a>
    } else {
      len = 0;
  81a2af:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  81a2b5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a2b9:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a2bd:	48 85 c0             	test   %rax,%rax
  81a2c0:	74 1a                	je     81a2dc <netconn_recv+0x151>
  81a2c2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a2c6:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a2ca:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81a2ce:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  81a2d2:	be 01 00 00 00       	mov    $0x1,%esi
  81a2d7:	48 89 cf             	mov    %rcx,%rdi
  81a2da:	ff d0                	callq  *%rax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  81a2dc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a2e0:	48 85 c0             	test   %rax,%rax
  81a2e3:	75 36                	jne    81a31b <netconn_recv+0x190>
      memp_free(MEMP_NETBUF, buf);
  81a2e5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a2e9:	48 89 c6             	mov    %rax,%rsi
  81a2ec:	bf 06 00 00 00       	mov    $0x6,%edi
  81a2f1:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  81a2f8:	00 00 00 
  81a2fb:	ff d0                	callq  *%rax
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  81a2fd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a301:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81a305:	84 c0                	test   %al,%al
  81a307:	75 08                	jne    81a311 <netconn_recv+0x186>
        conn->err = ERR_CLSD;
  81a309:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a30d:	c6 40 10 f9          	movb   $0xf9,0x10(%rax)
      }
      return NULL;
  81a311:	b8 00 00 00 00       	mov    $0x0,%eax
  81a316:	e9 f4 00 00 00       	jmpq   81a40f <netconn_recv+0x284>
    }

    buf->p = p;
  81a31b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a31f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  81a323:	48 89 10             	mov    %rdx,(%rax)
    buf->ptr = p;
  81a326:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a32a:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  81a32e:	48 89 50 08          	mov    %rdx,0x8(%rax)
    buf->port = 0;
  81a332:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a336:	66 c7 40 18 00 00    	movw   $0x0,0x18(%rax)
    buf->addr = NULL;
  81a33c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a340:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81a347:	00 

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  81a348:	48 b8 c4 bf 81 00 00 	movabs $0x81bfc4,%rax
  81a34f:	00 00 00 
  81a352:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    msg.msg.conn = conn;
  81a356:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a35a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    if (buf != NULL) {
  81a35e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a362:	48 85 c0             	test   %rax,%rax
  81a365:	74 11                	je     81a378 <netconn_recv+0x1ed>
      msg.msg.msg.r.len = buf->p->tot_len;
  81a367:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a36b:	48 8b 00             	mov    (%rax),%rax
  81a36e:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a372:	66 89 45 e0          	mov    %ax,-0x20(%rbp)
  81a376:	eb 06                	jmp    81a37e <netconn_recv+0x1f3>
    } else {
      msg.msg.msg.r.len = 1;
  81a378:	66 c7 45 e0 01 00    	movw   $0x1,-0x20(%rbp)
    }
    TCPIP_APIMSG(&msg);
  81a37e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a382:	48 89 c7             	mov    %rax,%rdi
  81a385:	48 b8 75 8c 80 00 00 	movabs $0x808c75,%rax
  81a38c:	00 00 00 
  81a38f:	ff d0                	callq  *%rax
  81a391:	eb 78                	jmp    81a40b <netconn_recv+0x280>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  81a393:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a397:	8b 40 18             	mov    0x18(%rax),%eax
  81a39a:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
  81a39e:	ba 00 00 00 00       	mov    $0x0,%edx
  81a3a3:	48 89 ce             	mov    %rcx,%rsi
  81a3a6:	89 c7                	mov    %eax,%edi
  81a3a8:	48 b8 a6 84 81 00 00 	movabs $0x8184a6,%rax
  81a3af:	00 00 00 
  81a3b2:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  81a3b4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a3b8:	48 85 c0             	test   %rax,%rax
  81a3bb:	74 4e                	je     81a40b <netconn_recv+0x280>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  81a3bd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a3c1:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a3c5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a3c9:	48 8b 00             	mov    (%rax),%rax
  81a3cc:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a3d0:	29 c2                	sub    %eax,%edx
  81a3d2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a3d6:	66 89 50 24          	mov    %dx,0x24(%rax)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  81a3da:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a3de:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a3e2:	48 85 c0             	test   %rax,%rax
  81a3e5:	74 24                	je     81a40b <netconn_recv+0x280>
  81a3e7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a3eb:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a3ef:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81a3f3:	48 8b 12             	mov    (%rdx),%rdx
  81a3f6:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  81a3fa:	0f b7 d2             	movzwl %dx,%edx
  81a3fd:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  81a401:	be 01 00 00 00       	mov    $0x1,%esi
  81a406:	48 89 cf             	mov    %rcx,%rdi
  81a409:	ff d0                	callq  *%rax
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  81a40b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  81a40f:	c9                   	leaveq 
  81a410:	c3                   	retq   

000000000081a411 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  81a411:	55                   	push   %rbp
  81a412:	48 89 e5             	mov    %rsp,%rbp
  81a415:	48 83 ec 20          	sub    $0x20,%rsp
  81a419:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81a41d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  81a421:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  81a425:	89 c8                	mov    %ecx,%eax
  81a427:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  if (buf != NULL) {
  81a42b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a430:	74 34                	je     81a466 <netconn_sendto+0x55>
    buf->addr = addr;
  81a432:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a436:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81a43a:	48 89 50 10          	mov    %rdx,0x10(%rax)
    buf->port = port;
  81a43e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a442:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  81a446:	66 89 50 18          	mov    %dx,0x18(%rax)
    return netconn_send(conn, buf);
  81a44a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81a44e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a452:	48 89 d6             	mov    %rdx,%rsi
  81a455:	48 89 c7             	mov    %rax,%rdi
  81a458:	48 b8 6d a4 81 00 00 	movabs $0x81a46d,%rax
  81a45f:	00 00 00 
  81a462:	ff d0                	callq  *%rax
  81a464:	eb 05                	jmp    81a46b <netconn_sendto+0x5a>
  }
  return ERR_VAL;
  81a466:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  81a46b:	c9                   	leaveq 
  81a46c:	c3                   	retq   

000000000081a46d <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  81a46d:	55                   	push   %rbp
  81a46e:	48 89 e5             	mov    %rsp,%rbp
  81a471:	48 83 ec 40          	sub    $0x40,%rsp
  81a475:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81a479:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  81a47d:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81a482:	75 2a                	jne    81a4ae <netconn_send+0x41>
  81a484:	48 ba b6 38 82 00 00 	movabs $0x8238b6,%rdx
  81a48b:	00 00 00 
  81a48e:	be ba 01 00 00       	mov    $0x1ba,%esi
  81a493:	48 bf 01 37 82 00 00 	movabs $0x823701,%rdi
  81a49a:	00 00 00 
  81a49d:	b8 00 00 00 00       	mov    $0x0,%eax
  81a4a2:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a4a9:	00 00 00 
  81a4ac:	ff d1                	callq  *%rcx

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  81a4ae:	48 b8 34 be 81 00 00 	movabs $0x81be34,%rax
  81a4b5:	00 00 00 
  81a4b8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a4bc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a4c0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.b = buf;
  81a4c4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a4c8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  TCPIP_APIMSG(&msg);
  81a4cc:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a4d0:	48 89 c7             	mov    %rax,%rdi
  81a4d3:	48 b8 75 8c 80 00 00 	movabs $0x808c75,%rax
  81a4da:	00 00 00 
  81a4dd:	ff d0                	callq  *%rax
  return conn->err;
  81a4df:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a4e3:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a4e7:	c9                   	leaveq 
  81a4e8:	c3                   	retq   

000000000081a4e9 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  81a4e9:	55                   	push   %rbp
  81a4ea:	48 89 e5             	mov    %rsp,%rbp
  81a4ed:	48 83 ec 50          	sub    $0x50,%rsp
  81a4f1:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81a4f5:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  81a4f9:	89 55 bc             	mov    %edx,-0x44(%rbp)
  81a4fc:	89 c8                	mov    %ecx,%eax
  81a4fe:	88 45 b8             	mov    %al,-0x48(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  81a501:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81a506:	75 2a                	jne    81a532 <netconn_write+0x49>
  81a508:	48 ba d1 38 82 00 00 	movabs $0x8238d1,%rdx
  81a50f:	00 00 00 
  81a512:	be d4 01 00 00       	mov    $0x1d4,%esi
  81a517:	48 bf 01 37 82 00 00 	movabs $0x823701,%rdi
  81a51e:	00 00 00 
  81a521:	b8 00 00 00 00       	mov    $0x0,%eax
  81a526:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a52d:	00 00 00 
  81a530:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  81a532:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a536:	8b 00                	mov    (%rax),%eax
  81a538:	83 f8 10             	cmp    $0x10,%eax
  81a53b:	74 2a                	je     81a567 <netconn_write+0x7e>
  81a53d:	48 ba f0 38 82 00 00 	movabs $0x8238f0,%rdx
  81a544:	00 00 00 
  81a547:	be d5 01 00 00       	mov    $0x1d5,%esi
  81a54c:	48 bf 01 37 82 00 00 	movabs $0x823701,%rdi
  81a553:	00 00 00 
  81a556:	b8 00 00 00 00       	mov    $0x0,%eax
  81a55b:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a562:	00 00 00 
  81a565:	ff d1                	callq  *%rcx

  msg.function = do_write;
  81a567:	48 b8 ea c2 81 00 00 	movabs $0x81c2ea,%rax
  81a56e:	00 00 00 
  81a571:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a575:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a579:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.w.dataptr = dataptr;
  81a57d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a581:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.w.apiflags = apiflags;
  81a585:	0f b6 45 b8          	movzbl -0x48(%rbp),%eax
  81a589:	88 45 ec             	mov    %al,-0x14(%rbp)
  msg.msg.msg.w.len = size;
  81a58c:	8b 45 bc             	mov    -0x44(%rbp),%eax
  81a58f:	89 45 e8             	mov    %eax,-0x18(%rbp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  81a592:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a596:	48 89 c7             	mov    %rax,%rdi
  81a599:	48 b8 75 8c 80 00 00 	movabs $0x808c75,%rax
  81a5a0:	00 00 00 
  81a5a3:	ff d0                	callq  *%rax
  return conn->err;
  81a5a5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a5a9:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a5ad:	c9                   	leaveq 
  81a5ae:	c3                   	retq   

000000000081a5af <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  81a5af:	55                   	push   %rbp
  81a5b0:	48 89 e5             	mov    %rsp,%rbp
  81a5b3:	48 83 ec 40          	sub    $0x40,%rsp
  81a5b7:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  81a5bb:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81a5c0:	75 2a                	jne    81a5ec <netconn_close+0x3d>
  81a5c2:	48 ba 12 39 82 00 00 	movabs $0x823912,%rdx
  81a5c9:	00 00 00 
  81a5cc:	be ee 01 00 00       	mov    $0x1ee,%esi
  81a5d1:	48 bf 01 37 82 00 00 	movabs $0x823701,%rdi
  81a5d8:	00 00 00 
  81a5db:	b8 00 00 00 00       	mov    $0x0,%eax
  81a5e0:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a5e7:	00 00 00 
  81a5ea:	ff d1                	callq  *%rcx

  msg.function = do_close;
  81a5ec:	48 b8 11 c5 81 00 00 	movabs $0x81c511,%rax
  81a5f3:	00 00 00 
  81a5f6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a5fa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a5fe:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  tcpip_apimsg(&msg);
  81a602:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a606:	48 89 c7             	mov    %rax,%rdi
  81a609:	48 b8 75 8c 80 00 00 	movabs $0x808c75,%rax
  81a610:	00 00 00 
  81a613:	ff d0                	callq  *%rax
  return conn->err;
  81a615:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a619:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a61d:	c9                   	leaveq 
  81a61e:	c3                   	retq   

000000000081a61f <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  81a61f:	55                   	push   %rbp
  81a620:	48 89 e5             	mov    %rsp,%rbp
  81a623:	48 83 ec 40          	sub    $0x40,%rsp
  81a627:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81a62b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  81a62f:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  81a633:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(addr);
  conn = arg;
  81a637:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a63b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  81a63f:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a644:	0f 84 74 01 00 00    	je     81a7be <recv_raw+0x19f>
  81a64a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a64e:	8b 40 18             	mov    0x18(%rax),%eax
  81a651:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a654:	0f 84 64 01 00 00    	je     81a7be <recv_raw+0x19f>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  81a65a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a65e:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a662:	0f b7 c0             	movzwl %ax,%eax
  81a665:	ba 00 00 00 00       	mov    $0x0,%edx
  81a66a:	89 c6                	mov    %eax,%esi
  81a66c:	bf 03 00 00 00       	mov    $0x3,%edi
  81a671:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  81a678:	00 00 00 
  81a67b:	ff d0                	callq  *%rax
  81a67d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if(q != NULL) {
  81a681:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a686:	74 39                	je     81a6c1 <recv_raw+0xa2>
      if (pbuf_copy(q, p) != ERR_OK) {
  81a688:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81a68c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a690:	48 89 d6             	mov    %rdx,%rsi
  81a693:	48 89 c7             	mov    %rax,%rdi
  81a696:	48 b8 cf e1 80 00 00 	movabs $0x80e1cf,%rax
  81a69d:	00 00 00 
  81a6a0:	ff d0                	callq  *%rax
  81a6a2:	84 c0                	test   %al,%al
  81a6a4:	74 1b                	je     81a6c1 <recv_raw+0xa2>
        pbuf_free(q);
  81a6a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6aa:	48 89 c7             	mov    %rax,%rdi
  81a6ad:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81a6b4:	00 00 00 
  81a6b7:	ff d0                	callq  *%rax
        q = NULL;
  81a6b9:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  81a6c0:	00 
      }
    }

    if(q != NULL) {
  81a6c1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a6c6:	0f 84 f2 00 00 00    	je     81a7be <recv_raw+0x19f>
      buf = memp_malloc(MEMP_NETBUF);
  81a6cc:	bf 06 00 00 00       	mov    $0x6,%edi
  81a6d1:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  81a6d8:	00 00 00 
  81a6db:	ff d0                	callq  *%rax
  81a6dd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      if (buf == NULL) {
  81a6e1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a6e6:	75 1d                	jne    81a705 <recv_raw+0xe6>
        pbuf_free(q);
  81a6e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6ec:	48 89 c7             	mov    %rax,%rdi
  81a6ef:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81a6f6:	00 00 00 
  81a6f9:	ff d0                	callq  *%rax
        return 0;
  81a6fb:	b8 00 00 00 00       	mov    $0x0,%eax
  81a700:	e9 be 00 00 00       	jmpq   81a7c3 <recv_raw+0x1a4>
      }

      buf->p = q;
  81a705:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a709:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81a70d:	48 89 10             	mov    %rdx,(%rax)
      buf->ptr = q;
  81a710:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a714:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81a718:	48 89 50 08          	mov    %rdx,0x8(%rax)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  81a71c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a720:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a724:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  81a728:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a72c:	48 89 50 10          	mov    %rdx,0x10(%rax)
      buf->port = pcb->protocol;
  81a730:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81a734:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81a738:	0f b6 d0             	movzbl %al,%edx
  81a73b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a73f:	66 89 50 18          	mov    %dx,0x18(%rax)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  81a743:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a747:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a74b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a74f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a753:	01 c2                	add    %eax,%edx
  81a755:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a759:	66 89 50 24          	mov    %dx,0x24(%rax)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  81a75d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a761:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a765:	48 85 c0             	test   %rax,%rax
  81a768:	74 21                	je     81a78b <recv_raw+0x16c>
  81a76a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a76e:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a772:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81a776:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  81a77a:	0f b7 d2             	movzwl %dx,%edx
  81a77d:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81a781:	be 00 00 00 00       	mov    $0x0,%esi
  81a786:	48 89 cf             	mov    %rcx,%rdi
  81a789:	ff d0                	callq  *%rax
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  81a78b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a78f:	8b 40 18             	mov    0x18(%rax),%eax
  81a792:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81a796:	48 89 d6             	mov    %rdx,%rsi
  81a799:	89 c7                	mov    %eax,%edi
  81a79b:	48 b8 6b 7c 81 00 00 	movabs $0x817c6b,%rax
  81a7a2:	00 00 00 
  81a7a5:	ff d0                	callq  *%rax
  81a7a7:	84 c0                	test   %al,%al
  81a7a9:	74 13                	je     81a7be <recv_raw+0x19f>
        netbuf_delete(buf);
  81a7ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a7af:	48 89 c7             	mov    %rax,%rdi
  81a7b2:	48 b8 5c 8e 80 00 00 	movabs $0x808e5c,%rax
  81a7b9:	00 00 00 
  81a7bc:	ff d0                	callq  *%rax
      }
    }
  }

  return 0; /* do not eat the packet */
  81a7be:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a7c3:	c9                   	leaveq 
  81a7c4:	c3                   	retq   

000000000081a7c5 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  81a7c5:	55                   	push   %rbp
  81a7c6:	48 89 e5             	mov    %rsp,%rbp
  81a7c9:	48 83 ec 40          	sub    $0x40,%rsp
  81a7cd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a7d1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a7d5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81a7d9:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  81a7dd:	44 89 c0             	mov    %r8d,%eax
  81a7e0:	66 89 45 cc          	mov    %ax,-0x34(%rbp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  81a7e4:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81a7e9:	75 2a                	jne    81a815 <recv_udp+0x50>
  81a7eb:	48 ba 30 39 82 00 00 	movabs $0x823930,%rdx
  81a7f2:	00 00 00 
  81a7f5:	be 8f 00 00 00       	mov    $0x8f,%esi
  81a7fa:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81a801:	00 00 00 
  81a804:	b8 00 00 00 00       	mov    $0x0,%eax
  81a809:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a810:	00 00 00 
  81a813:	ff d1                	callq  *%rcx
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  81a815:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a81a:	75 2a                	jne    81a846 <recv_udp+0x81>
  81a81c:	48 ba 70 39 82 00 00 	movabs $0x823970,%rdx
  81a823:	00 00 00 
  81a826:	be 90 00 00 00       	mov    $0x90,%esi
  81a82b:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81a832:	00 00 00 
  81a835:	b8 00 00 00 00       	mov    $0x0,%eax
  81a83a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a841:	00 00 00 
  81a844:	ff d1                	callq  *%rcx
  conn = arg;
  81a846:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a84a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  81a84e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a852:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a856:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  81a85a:	74 2a                	je     81a886 <recv_udp+0xc1>
  81a85c:	48 ba 8f 39 82 00 00 	movabs $0x82398f,%rdx
  81a863:	00 00 00 
  81a866:	be 92 00 00 00       	mov    $0x92,%esi
  81a86b:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81a872:	00 00 00 
  81a875:	b8 00 00 00 00       	mov    $0x0,%eax
  81a87a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a881:	00 00 00 
  81a884:	ff d1                	callq  *%rcx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  81a886:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a88b:	74 0c                	je     81a899 <recv_udp+0xd4>
  81a88d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a891:	8b 40 18             	mov    0x18(%rax),%eax
  81a894:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a897:	75 18                	jne    81a8b1 <recv_udp+0xec>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  81a899:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a89d:	48 89 c7             	mov    %rax,%rdi
  81a8a0:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81a8a7:	00 00 00 
  81a8aa:	ff d0                	callq  *%rax
    return;
  81a8ac:	e9 df 00 00 00       	jmpq   81a990 <recv_udp+0x1cb>
  }

  buf = memp_malloc(MEMP_NETBUF);
  81a8b1:	bf 06 00 00 00       	mov    $0x6,%edi
  81a8b6:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  81a8bd:	00 00 00 
  81a8c0:	ff d0                	callq  *%rax
  81a8c2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (buf == NULL) {
  81a8c6:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a8cb:	75 18                	jne    81a8e5 <recv_udp+0x120>
    pbuf_free(p);
  81a8cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a8d1:	48 89 c7             	mov    %rax,%rdi
  81a8d4:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81a8db:	00 00 00 
  81a8de:	ff d0                	callq  *%rax
    return;
  81a8e0:	e9 ab 00 00 00       	jmpq   81a990 <recv_udp+0x1cb>
  } else {
    buf->p = p;
  81a8e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a8e9:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a8ed:	48 89 10             	mov    %rdx,(%rax)
    buf->ptr = p;
  81a8f0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a8f4:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a8f8:	48 89 50 08          	mov    %rdx,0x8(%rax)
    buf->addr = addr;
  81a8fc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a900:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81a904:	48 89 50 10          	mov    %rdx,0x10(%rax)
    buf->port = port;
  81a908:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a90c:	0f b7 55 cc          	movzwl -0x34(%rbp),%edx
  81a910:	66 89 50 18          	mov    %dx,0x18(%rax)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  81a914:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a918:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a91c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a920:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a924:	01 c2                	add    %eax,%edx
  81a926:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a92a:	66 89 50 24          	mov    %dx,0x24(%rax)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  81a92e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a932:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a936:	48 85 c0             	test   %rax,%rax
  81a939:	74 21                	je     81a95c <recv_udp+0x197>
  81a93b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a93f:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a943:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a947:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  81a94b:	0f b7 d2             	movzwl %dx,%edx
  81a94e:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81a952:	be 00 00 00 00       	mov    $0x0,%esi
  81a957:	48 89 cf             	mov    %rcx,%rdi
  81a95a:	ff d0                	callq  *%rax
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  81a95c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a960:	8b 40 18             	mov    0x18(%rax),%eax
  81a963:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81a967:	48 89 d6             	mov    %rdx,%rsi
  81a96a:	89 c7                	mov    %eax,%edi
  81a96c:	48 b8 6b 7c 81 00 00 	movabs $0x817c6b,%rax
  81a973:	00 00 00 
  81a976:	ff d0                	callq  *%rax
  81a978:	84 c0                	test   %al,%al
  81a97a:	74 14                	je     81a990 <recv_udp+0x1cb>
    netbuf_delete(buf);
  81a97c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a980:	48 89 c7             	mov    %rax,%rdi
  81a983:	48 b8 5c 8e 80 00 00 	movabs $0x808e5c,%rax
  81a98a:	00 00 00 
  81a98d:	ff d0                	callq  *%rax
    return;
  81a98f:	90                   	nop
  }
}
  81a990:	c9                   	leaveq 
  81a991:	c3                   	retq   

000000000081a992 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  81a992:	55                   	push   %rbp
  81a993:	48 89 e5             	mov    %rsp,%rbp
  81a996:	48 83 ec 30          	sub    $0x30,%rsp
  81a99a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a99e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a9a2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81a9a6:	89 c8                	mov    %ecx,%eax
  81a9a8:	88 45 d4             	mov    %al,-0x2c(%rbp)
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  81a9ab:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81a9b0:	75 2a                	jne    81a9dc <recv_tcp+0x4a>
  81a9b2:	48 ba b0 39 82 00 00 	movabs $0x8239b0,%rdx
  81a9b9:	00 00 00 
  81a9bc:	be c2 00 00 00       	mov    $0xc2,%esi
  81a9c1:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81a9c8:	00 00 00 
  81a9cb:	b8 00 00 00 00       	mov    $0x0,%eax
  81a9d0:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a9d7:	00 00 00 
  81a9da:	ff d1                	callq  *%rcx
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  81a9dc:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a9e1:	75 2a                	jne    81aa0d <recv_tcp+0x7b>
  81a9e3:	48 ba d8 39 82 00 00 	movabs $0x8239d8,%rdx
  81a9ea:	00 00 00 
  81a9ed:	be c3 00 00 00       	mov    $0xc3,%esi
  81a9f2:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81a9f9:	00 00 00 
  81a9fc:	b8 00 00 00 00       	mov    $0x0,%eax
  81aa01:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81aa08:	00 00 00 
  81aa0b:	ff d1                	callq  *%rcx
  conn = arg;
  81aa0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aa11:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  81aa15:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aa19:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aa1d:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  81aa21:	74 2a                	je     81aa4d <recv_tcp+0xbb>
  81aa23:	48 ba f7 39 82 00 00 	movabs $0x8239f7,%rdx
  81aa2a:	00 00 00 
  81aa2d:	be c5 00 00 00       	mov    $0xc5,%esi
  81aa32:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81aa39:	00 00 00 
  81aa3c:	b8 00 00 00 00       	mov    $0x0,%eax
  81aa41:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81aa48:	00 00 00 
  81aa4b:	ff d1                	callq  *%rcx

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  81aa4d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81aa52:	74 0c                	je     81aa60 <recv_tcp+0xce>
  81aa54:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aa58:	8b 40 18             	mov    0x18(%rax),%eax
  81aa5b:	83 f8 ff             	cmp    $0xffffffff,%eax
  81aa5e:	75 0a                	jne    81aa6a <recv_tcp+0xd8>
    return ERR_VAL;
  81aa60:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  81aa65:	e9 8f 00 00 00       	jmpq   81aaf9 <recv_tcp+0x167>
  }

  conn->err = err;
  81aa6a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aa6e:	0f b6 55 d4          	movzbl -0x2c(%rbp),%edx
  81aa72:	88 50 10             	mov    %dl,0x10(%rax)
  if (p != NULL) {
  81aa75:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81aa7a:	74 24                	je     81aaa0 <recv_tcp+0x10e>
    len = p->tot_len;
  81aa7c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81aa80:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81aa84:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    SYS_ARCH_INC(conn->recv_avail, len);
  81aa88:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aa8c:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81aa90:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81aa94:	01 c2                	add    %eax,%edx
  81aa96:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aa9a:	66 89 50 24          	mov    %dx,0x24(%rax)
  81aa9e:	eb 06                	jmp    81aaa6 <recv_tcp+0x114>
  } else {
    len = 0;
  81aaa0:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  81aaa6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aaaa:	48 8b 40 38          	mov    0x38(%rax),%rax
  81aaae:	48 85 c0             	test   %rax,%rax
  81aab1:	74 1a                	je     81aacd <recv_tcp+0x13b>
  81aab3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aab7:	48 8b 40 38          	mov    0x38(%rax),%rax
  81aabb:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81aabf:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81aac3:	be 00 00 00 00       	mov    $0x0,%esi
  81aac8:	48 89 cf             	mov    %rcx,%rdi
  81aacb:	ff d0                	callq  *%rax
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  81aacd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aad1:	8b 40 18             	mov    0x18(%rax),%eax
  81aad4:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81aad8:	48 89 d6             	mov    %rdx,%rsi
  81aadb:	89 c7                	mov    %eax,%edi
  81aadd:	48 b8 6b 7c 81 00 00 	movabs $0x817c6b,%rax
  81aae4:	00 00 00 
  81aae7:	ff d0                	callq  *%rax
  81aae9:	84 c0                	test   %al,%al
  81aaeb:	74 07                	je     81aaf4 <recv_tcp+0x162>
    return ERR_MEM;
  81aaed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81aaf2:	eb 05                	jmp    81aaf9 <recv_tcp+0x167>
  }

  return ERR_OK;
  81aaf4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81aaf9:	c9                   	leaveq 
  81aafa:	c3                   	retq   

000000000081aafb <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  81aafb:	55                   	push   %rbp
  81aafc:	48 89 e5             	mov    %rsp,%rbp
  81aaff:	48 83 ec 20          	sub    $0x20,%rsp
  81ab03:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81ab07:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct netconn *conn = arg;
  81ab0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ab0f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81ab13:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81ab18:	75 2a                	jne    81ab44 <poll_tcp+0x49>
  81ab1a:	48 ba 15 3a 82 00 00 	movabs $0x823a15,%rdx
  81ab21:	00 00 00 
  81ab24:	be ec 00 00 00       	mov    $0xec,%esi
  81ab29:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81ab30:	00 00 00 
  81ab33:	b8 00 00 00 00       	mov    $0x0,%eax
  81ab38:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81ab3f:	00 00 00 
  81ab42:	ff d1                	callq  *%rcx

  if (conn->state == NETCONN_WRITE) {
  81ab44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab48:	8b 40 04             	mov    0x4(%rax),%eax
  81ab4b:	83 f8 01             	cmp    $0x1,%eax
  81ab4e:	75 15                	jne    81ab65 <poll_tcp+0x6a>
    do_writemore(conn);
  81ab50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab54:	48 89 c7             	mov    %rax,%rdi
  81ab57:	48 b8 3f c0 81 00 00 	movabs $0x81c03f,%rax
  81ab5e:	00 00 00 
  81ab61:	ff d0                	callq  *%rax
  81ab63:	eb 1f                	jmp    81ab84 <poll_tcp+0x89>
  } else if (conn->state == NETCONN_CLOSE) {
  81ab65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab69:	8b 40 04             	mov    0x4(%rax),%eax
  81ab6c:	83 f8 04             	cmp    $0x4,%eax
  81ab6f:	75 13                	jne    81ab84 <poll_tcp+0x89>
    do_close_internal(conn);
  81ab71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab75:	48 89 c7             	mov    %rax,%rdi
  81ab78:	48 b8 b1 b4 81 00 00 	movabs $0x81b4b1,%rax
  81ab7f:	00 00 00 
  81ab82:	ff d0                	callq  *%rax
  }

  return ERR_OK;
  81ab84:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81ab89:	c9                   	leaveq 
  81ab8a:	c3                   	retq   

000000000081ab8b <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  81ab8b:	55                   	push   %rbp
  81ab8c:	48 89 e5             	mov    %rsp,%rbp
  81ab8f:	48 83 ec 30          	sub    $0x30,%rsp
  81ab93:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81ab97:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81ab9b:	89 d0                	mov    %edx,%eax
  81ab9d:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct netconn *conn = arg;
  81aba1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aba5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81aba9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81abae:	75 2a                	jne    81abda <sent_tcp+0x4f>
  81abb0:	48 ba 15 3a 82 00 00 	movabs $0x823a15,%rdx
  81abb7:	00 00 00 
  81abba:	be 04 01 00 00       	mov    $0x104,%esi
  81abbf:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81abc6:	00 00 00 
  81abc9:	b8 00 00 00 00       	mov    $0x0,%eax
  81abce:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81abd5:	00 00 00 
  81abd8:	ff d1                	callq  *%rcx

  if (conn->state == NETCONN_WRITE) {
  81abda:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abde:	8b 40 04             	mov    0x4(%rax),%eax
  81abe1:	83 f8 01             	cmp    $0x1,%eax
  81abe4:	75 4c                	jne    81ac32 <sent_tcp+0xa7>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  81abe6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abea:	48 8b 40 08          	mov    0x8(%rax),%rax
  81abee:	48 85 c0             	test   %rax,%rax
  81abf1:	75 2a                	jne    81ac1d <sent_tcp+0x92>
  81abf3:	48 ba 22 3a 82 00 00 	movabs $0x823a22,%rdx
  81abfa:	00 00 00 
  81abfd:	be 07 01 00 00       	mov    $0x107,%esi
  81ac02:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81ac09:	00 00 00 
  81ac0c:	b8 00 00 00 00       	mov    $0x0,%eax
  81ac11:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81ac18:	00 00 00 
  81ac1b:	ff d1                	callq  *%rcx
    do_writemore(conn);
  81ac1d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac21:	48 89 c7             	mov    %rax,%rdi
  81ac24:	48 b8 3f c0 81 00 00 	movabs $0x81c03f,%rax
  81ac2b:	00 00 00 
  81ac2e:	ff d0                	callq  *%rax
  81ac30:	eb 1f                	jmp    81ac51 <sent_tcp+0xc6>
  } else if (conn->state == NETCONN_CLOSE) {
  81ac32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac36:	8b 40 04             	mov    0x4(%rax),%eax
  81ac39:	83 f8 04             	cmp    $0x4,%eax
  81ac3c:	75 13                	jne    81ac51 <sent_tcp+0xc6>
    do_close_internal(conn);
  81ac3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac42:	48 89 c7             	mov    %rax,%rdi
  81ac45:	48 b8 b1 b4 81 00 00 	movabs $0x81b4b1,%rax
  81ac4c:	00 00 00 
  81ac4f:	ff d0                	callq  *%rax
  }

  if (conn) {
  81ac51:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81ac56:	74 46                	je     81ac9e <sent_tcp+0x113>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  81ac58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac5c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ac60:	48 85 c0             	test   %rax,%rax
  81ac63:	74 39                	je     81ac9e <sent_tcp+0x113>
  81ac65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac69:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ac6d:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81ac71:	66 3d a0 2d          	cmp    $0x2da0,%ax
  81ac75:	76 27                	jbe    81ac9e <sent_tcp+0x113>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  81ac77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac7b:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ac7f:	48 85 c0             	test   %rax,%rax
  81ac82:	74 1a                	je     81ac9e <sent_tcp+0x113>
  81ac84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac88:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ac8c:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  81ac90:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81ac94:	be 02 00 00 00       	mov    $0x2,%esi
  81ac99:	48 89 cf             	mov    %rcx,%rdi
  81ac9c:	ff d0                	callq  *%rax
    }
  }
  
  return ERR_OK;
  81ac9e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81aca3:	c9                   	leaveq 
  81aca4:	c3                   	retq   

000000000081aca5 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  81aca5:	55                   	push   %rbp
  81aca6:	48 89 e5             	mov    %rsp,%rbp
  81aca9:	48 83 ec 20          	sub    $0x20,%rsp
  81acad:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81acb1:	89 f0                	mov    %esi,%eax
  81acb3:	88 45 e4             	mov    %al,-0x1c(%rbp)
  struct netconn *conn;

  conn = arg;
  81acb6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81acba:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81acbe:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81acc3:	75 2a                	jne    81acef <err_tcp+0x4a>
  81acc5:	48 ba 15 3a 82 00 00 	movabs $0x823a15,%rdx
  81accc:	00 00 00 
  81accf:	be 23 01 00 00       	mov    $0x123,%esi
  81acd4:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81acdb:	00 00 00 
  81acde:	b8 00 00 00 00       	mov    $0x0,%eax
  81ace3:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81acea:	00 00 00 
  81aced:	ff d1                	callq  *%rcx

  conn->pcb.tcp = NULL;
  81acef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81acf3:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81acfa:	00 

  conn->err = err;
  81acfb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81acff:	0f b6 55 e4          	movzbl -0x1c(%rbp),%edx
  81ad03:	88 50 10             	mov    %dl,0x10(%rax)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  81ad06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad0a:	8b 40 18             	mov    0x18(%rax),%eax
  81ad0d:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ad10:	74 42                	je     81ad54 <err_tcp+0xaf>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81ad12:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad16:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ad1a:	48 85 c0             	test   %rax,%rax
  81ad1d:	74 1b                	je     81ad3a <err_tcp+0x95>
  81ad1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad23:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ad27:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81ad2b:	ba 00 00 00 00       	mov    $0x0,%edx
  81ad30:	be 00 00 00 00       	mov    $0x0,%esi
  81ad35:	48 89 cf             	mov    %rcx,%rdi
  81ad38:	ff d0                	callq  *%rax
    sys_mbox_post(conn->recvmbox, NULL);
  81ad3a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad3e:	8b 40 18             	mov    0x18(%rax),%eax
  81ad41:	be 00 00 00 00       	mov    $0x0,%esi
  81ad46:	89 c7                	mov    %eax,%edi
  81ad48:	48 b8 08 7c 81 00 00 	movabs $0x817c08,%rax
  81ad4f:	00 00 00 
  81ad52:	ff d0                	callq  *%rax
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  81ad54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad58:	8b 40 14             	mov    0x14(%rax),%eax
  81ad5b:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ad5e:	74 2c                	je     81ad8c <err_tcp+0xe7>
  81ad60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad64:	8b 40 04             	mov    0x4(%rax),%eax
  81ad67:	83 f8 03             	cmp    $0x3,%eax
  81ad6a:	75 20                	jne    81ad8c <err_tcp+0xe7>
    conn->state = NETCONN_NONE;
  81ad6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad70:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    sys_sem_signal(conn->op_completed);
  81ad77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad7b:	8b 40 14             	mov    0x14(%rax),%eax
  81ad7e:	89 c7                	mov    %eax,%edi
  81ad80:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  81ad87:	00 00 00 
  81ad8a:	ff d0                	callq  *%rax
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  81ad8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad90:	8b 40 1c             	mov    0x1c(%rax),%eax
  81ad93:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ad96:	74 42                	je     81adda <err_tcp+0x135>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81ad98:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad9c:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ada0:	48 85 c0             	test   %rax,%rax
  81ada3:	74 1b                	je     81adc0 <err_tcp+0x11b>
  81ada5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ada9:	48 8b 40 38          	mov    0x38(%rax),%rax
  81adad:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81adb1:	ba 00 00 00 00       	mov    $0x0,%edx
  81adb6:	be 00 00 00 00       	mov    $0x0,%esi
  81adbb:	48 89 cf             	mov    %rcx,%rdi
  81adbe:	ff d0                	callq  *%rax
    sys_mbox_post(conn->acceptmbox, NULL);
  81adc0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81adc4:	8b 40 1c             	mov    0x1c(%rax),%eax
  81adc7:	be 00 00 00 00       	mov    $0x0,%esi
  81adcc:	89 c7                	mov    %eax,%edi
  81adce:	48 b8 08 7c 81 00 00 	movabs $0x817c08,%rax
  81add5:	00 00 00 
  81add8:	ff d0                	callq  *%rax
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  81adda:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81adde:	8b 40 04             	mov    0x4(%rax),%eax
  81ade1:	83 f8 01             	cmp    $0x1,%eax
  81ade4:	74 0c                	je     81adf2 <err_tcp+0x14d>
  81ade6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81adea:	8b 40 04             	mov    0x4(%rax),%eax
  81aded:	83 f8 04             	cmp    $0x4,%eax
  81adf0:	75 20                	jne    81ae12 <err_tcp+0x16d>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  81adf2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81adf6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  81adfd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae01:	8b 40 14             	mov    0x14(%rax),%eax
  81ae04:	89 c7                	mov    %eax,%edi
  81ae06:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  81ae0d:	00 00 00 
  81ae10:	ff d0                	callq  *%rax
  }
}
  81ae12:	90                   	nop
  81ae13:	c9                   	leaveq 
  81ae14:	c3                   	retq   

000000000081ae15 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  81ae15:	55                   	push   %rbp
  81ae16:	48 89 e5             	mov    %rsp,%rbp
  81ae19:	48 83 ec 20          	sub    $0x20,%rsp
  81ae1d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  81ae21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae25:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ae29:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  tcp_arg(pcb, conn);
  81ae2d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81ae31:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae35:	48 89 d6             	mov    %rdx,%rsi
  81ae38:	48 89 c7             	mov    %rax,%rdi
  81ae3b:	48 b8 fe 08 81 00 00 	movabs $0x8108fe,%rax
  81ae42:	00 00 00 
  81ae45:	ff d0                	callq  *%rax
  tcp_recv(pcb, recv_tcp);
  81ae47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae4b:	48 be 92 a9 81 00 00 	movabs $0x81a992,%rsi
  81ae52:	00 00 00 
  81ae55:	48 89 c7             	mov    %rax,%rdi
  81ae58:	48 b8 1d 09 81 00 00 	movabs $0x81091d,%rax
  81ae5f:	00 00 00 
  81ae62:	ff d0                	callq  *%rax
  tcp_sent(pcb, sent_tcp);
  81ae64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae68:	48 be 8b ab 81 00 00 	movabs $0x81ab8b,%rsi
  81ae6f:	00 00 00 
  81ae72:	48 89 c7             	mov    %rax,%rdi
  81ae75:	48 b8 3f 09 81 00 00 	movabs $0x81093f,%rax
  81ae7c:	00 00 00 
  81ae7f:	ff d0                	callq  *%rax
  tcp_poll(pcb, poll_tcp, 4);
  81ae81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae85:	ba 04 00 00 00       	mov    $0x4,%edx
  81ae8a:	48 be fb aa 81 00 00 	movabs $0x81aafb,%rsi
  81ae91:	00 00 00 
  81ae94:	48 89 c7             	mov    %rax,%rdi
  81ae97:	48 b8 a2 09 81 00 00 	movabs $0x8109a2,%rax
  81ae9e:	00 00 00 
  81aea1:	ff d0                	callq  *%rax
  tcp_err(pcb, err_tcp);
  81aea3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aea7:	48 be a5 ac 81 00 00 	movabs $0x81aca5,%rsi
  81aeae:	00 00 00 
  81aeb1:	48 89 c7             	mov    %rax,%rdi
  81aeb4:	48 b8 61 09 81 00 00 	movabs $0x810961,%rax
  81aebb:	00 00 00 
  81aebe:	ff d0                	callq  *%rax
}
  81aec0:	90                   	nop
  81aec1:	c9                   	leaveq 
  81aec2:	c3                   	retq   

000000000081aec3 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  81aec3:	55                   	push   %rbp
  81aec4:	48 89 e5             	mov    %rsp,%rbp
  81aec7:	48 83 ec 30          	sub    $0x30,%rsp
  81aecb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81aecf:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81aed3:	89 d0                	mov    %edx,%eax
  81aed5:	88 45 dc             	mov    %al,-0x24(%rbp)
#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
  81aed8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aedc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  81aee0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aee4:	8b 40 1c             	mov    0x1c(%rax),%eax
  81aee7:	83 f8 ff             	cmp    $0xffffffff,%eax
  81aeea:	75 2a                	jne    81af16 <accept_function+0x53>
  81aeec:	48 ba 38 3a 82 00 00 	movabs $0x823a38,%rdx
  81aef3:	00 00 00 
  81aef6:	be 66 01 00 00       	mov    $0x166,%esi
  81aefb:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81af02:	00 00 00 
  81af05:	b8 00 00 00 00       	mov    $0x0,%eax
  81af0a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81af11:	00 00 00 
  81af14:	ff d1                	callq  *%rcx
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  81af16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81af1a:	48 8b 50 38          	mov    0x38(%rax),%rdx
  81af1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81af22:	8b 00                	mov    (%rax),%eax
  81af24:	48 89 d6             	mov    %rdx,%rsi
  81af27:	89 c7                	mov    %eax,%edi
  81af29:	48 b8 0e b2 81 00 00 	movabs $0x81b20e,%rax
  81af30:	00 00 00 
  81af33:	ff d0                	callq  *%rax
  81af35:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (newconn == NULL) {
  81af39:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81af3e:	75 0a                	jne    81af4a <accept_function+0x87>
    return ERR_MEM;
  81af40:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81af45:	e9 9d 00 00 00       	jmpq   81afe7 <accept_function+0x124>
  }
  newconn->pcb.tcp = newpcb;
  81af4a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81af4e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81af52:	48 89 50 08          	mov    %rdx,0x8(%rax)
  setup_tcp(newconn);
  81af56:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81af5a:	48 89 c7             	mov    %rax,%rdi
  81af5d:	48 b8 15 ae 81 00 00 	movabs $0x81ae15,%rax
  81af64:	00 00 00 
  81af67:	ff d0                	callq  *%rax
  newconn->err = err;
  81af69:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81af6d:	0f b6 55 dc          	movzbl -0x24(%rbp),%edx
  81af71:	88 50 10             	mov    %dl,0x10(%rax)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81af74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81af78:	48 8b 40 38          	mov    0x38(%rax),%rax
  81af7c:	48 85 c0             	test   %rax,%rax
  81af7f:	74 1b                	je     81af9c <accept_function+0xd9>
  81af81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81af85:	48 8b 40 38          	mov    0x38(%rax),%rax
  81af89:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81af8d:	ba 00 00 00 00       	mov    $0x0,%edx
  81af92:	be 00 00 00 00       	mov    $0x0,%esi
  81af97:	48 89 cf             	mov    %rcx,%rdi
  81af9a:	ff d0                	callq  *%rax

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  81af9c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81afa0:	8b 40 1c             	mov    0x1c(%rax),%eax
  81afa3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81afa7:	48 89 d6             	mov    %rdx,%rsi
  81afaa:	89 c7                	mov    %eax,%edi
  81afac:	48 b8 6b 7c 81 00 00 	movabs $0x817c6b,%rax
  81afb3:	00 00 00 
  81afb6:	ff d0                	callq  *%rax
  81afb8:	84 c0                	test   %al,%al
  81afba:	74 26                	je     81afe2 <accept_function+0x11f>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  81afbc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81afc0:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81afc7:	00 
    netconn_free(newconn);
  81afc8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81afcc:	48 89 c7             	mov    %rax,%rdi
  81afcf:	48 b8 46 b3 81 00 00 	movabs $0x81b346,%rax
  81afd6:	00 00 00 
  81afd9:	ff d0                	callq  *%rax
    return ERR_MEM;
  81afdb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81afe0:	eb 05                	jmp    81afe7 <accept_function+0x124>
  }
  return ERR_OK;
  81afe2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81afe7:	c9                   	leaveq 
  81afe8:	c3                   	retq   

000000000081afe9 <pcb_new>:
 * @param msg the api_msg_msg describing the connection type
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
  81afe9:	55                   	push   %rbp
  81afea:	48 89 e5             	mov    %rsp,%rbp
  81afed:	53                   	push   %rbx
  81afee:	48 83 ec 18          	sub    $0x18,%rsp
  81aff2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   msg->conn->err = ERR_OK;
  81aff6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81affa:	48 8b 00             	mov    (%rax),%rax
  81affd:	c6 40 10 00          	movb   $0x0,0x10(%rax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  81b001:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b005:	48 8b 00             	mov    (%rax),%rax
  81b008:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b00c:	48 85 c0             	test   %rax,%rax
  81b00f:	74 2a                	je     81b03b <pcb_new+0x52>
  81b011:	48 ba 68 3a 82 00 00 	movabs $0x823a68,%rdx
  81b018:	00 00 00 
  81b01b:	be 8b 01 00 00       	mov    $0x18b,%esi
  81b020:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81b027:	00 00 00 
  81b02a:	b8 00 00 00 00       	mov    $0x0,%eax
  81b02f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81b036:	00 00 00 
  81b039:	ff d1                	callq  *%rcx

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  81b03b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b03f:	48 8b 00             	mov    (%rax),%rax
  81b042:	8b 00                	mov    (%rax),%eax
  81b044:	25 f0 00 00 00       	and    $0xf0,%eax
  81b049:	83 f8 20             	cmp    $0x20,%eax
  81b04c:	0f 84 87 00 00 00    	je     81b0d9 <pcb_new+0xf0>
  81b052:	83 f8 40             	cmp    $0x40,%eax
  81b055:	74 0e                	je     81b065 <pcb_new+0x7c>
  81b057:	83 f8 10             	cmp    $0x10,%eax
  81b05a:	0f 84 fa 00 00 00    	je     81b15a <pcb_new+0x171>
  81b060:	e9 41 01 00 00       	jmpq   81b1a6 <pcb_new+0x1bd>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  81b065:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b069:	48 8b 18             	mov    (%rax),%rbx
  81b06c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b070:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  81b074:	0f b6 c0             	movzbl %al,%eax
  81b077:	89 c7                	mov    %eax,%edi
  81b079:	48 b8 21 03 82 00 00 	movabs $0x820321,%rax
  81b080:	00 00 00 
  81b083:	ff d0                	callq  *%rax
  81b085:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.raw == NULL) {
  81b089:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b08d:	48 8b 00             	mov    (%rax),%rax
  81b090:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b094:	48 85 c0             	test   %rax,%rax
  81b097:	75 10                	jne    81b0a9 <pcb_new+0xc0>
       msg->conn->err = ERR_MEM;
  81b099:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b09d:	48 8b 00             	mov    (%rax),%rax
  81b0a0:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81b0a4:	e9 09 01 00 00       	jmpq   81b1b2 <pcb_new+0x1c9>
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  81b0a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b0ad:	48 8b 10             	mov    (%rax),%rdx
  81b0b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b0b4:	48 8b 00             	mov    (%rax),%rax
  81b0b7:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b0bb:	48 be 1f a6 81 00 00 	movabs $0x81a61f,%rsi
  81b0c2:	00 00 00 
  81b0c5:	48 89 c7             	mov    %rax,%rdi
  81b0c8:	48 b8 67 00 82 00 00 	movabs $0x820067,%rax
  81b0cf:	00 00 00 
  81b0d2:	ff d0                	callq  *%rax
     break;
  81b0d4:	e9 d9 00 00 00       	jmpq   81b1b2 <pcb_new+0x1c9>
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  81b0d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b0dd:	48 8b 18             	mov    (%rax),%rbx
  81b0e0:	48 b8 55 5a 81 00 00 	movabs $0x815a55,%rax
  81b0e7:	00 00 00 
  81b0ea:	ff d0                	callq  *%rax
  81b0ec:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.udp == NULL) {
  81b0f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b0f4:	48 8b 00             	mov    (%rax),%rax
  81b0f7:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b0fb:	48 85 c0             	test   %rax,%rax
  81b0fe:	75 10                	jne    81b110 <pcb_new+0x127>
       msg->conn->err = ERR_MEM;
  81b100:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b104:	48 8b 00             	mov    (%rax),%rax
  81b107:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81b10b:	e9 a2 00 00 00       	jmpq   81b1b2 <pcb_new+0x1c9>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  81b110:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b114:	48 8b 00             	mov    (%rax),%rax
  81b117:	8b 00                	mov    (%rax),%eax
  81b119:	83 f8 22             	cmp    $0x22,%eax
  81b11c:	75 0f                	jne    81b12d <pcb_new+0x144>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  81b11e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b122:	48 8b 00             	mov    (%rax),%rax
  81b125:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b129:	c6 40 18 01          	movb   $0x1,0x18(%rax)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  81b12d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b131:	48 8b 10             	mov    (%rax),%rdx
  81b134:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b138:	48 8b 00             	mov    (%rax),%rax
  81b13b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b13f:	48 be c5 a7 81 00 00 	movabs $0x81a7c5,%rsi
  81b146:	00 00 00 
  81b149:	48 89 c7             	mov    %rax,%rdi
  81b14c:	48 b8 7b 59 81 00 00 	movabs $0x81597b,%rax
  81b153:	00 00 00 
  81b156:	ff d0                	callq  *%rax
     break;
  81b158:	eb 58                	jmp    81b1b2 <pcb_new+0x1c9>
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  81b15a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b15e:	48 8b 18             	mov    (%rax),%rbx
  81b161:	48 b8 e7 08 81 00 00 	movabs $0x8108e7,%rax
  81b168:	00 00 00 
  81b16b:	ff d0                	callq  *%rax
  81b16d:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.tcp == NULL) {
  81b171:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b175:	48 8b 00             	mov    (%rax),%rax
  81b178:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b17c:	48 85 c0             	test   %rax,%rax
  81b17f:	75 0d                	jne    81b18e <pcb_new+0x1a5>
       msg->conn->err = ERR_MEM;
  81b181:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b185:	48 8b 00             	mov    (%rax),%rax
  81b188:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81b18c:	eb 24                	jmp    81b1b2 <pcb_new+0x1c9>
     }
     setup_tcp(msg->conn);
  81b18e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b192:	48 8b 00             	mov    (%rax),%rax
  81b195:	48 89 c7             	mov    %rax,%rdi
  81b198:	48 b8 15 ae 81 00 00 	movabs $0x81ae15,%rax
  81b19f:	00 00 00 
  81b1a2:	ff d0                	callq  *%rax
     break;
  81b1a4:	eb 0c                	jmp    81b1b2 <pcb_new+0x1c9>
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  81b1a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1aa:	48 8b 00             	mov    (%rax),%rax
  81b1ad:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
     break;
  81b1b1:	90                   	nop
   }

  return msg->conn->err;
  81b1b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1b6:	48 8b 00             	mov    (%rax),%rax
  81b1b9:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81b1bd:	48 83 c4 18          	add    $0x18,%rsp
  81b1c1:	5b                   	pop    %rbx
  81b1c2:	5d                   	pop    %rbp
  81b1c3:	c3                   	retq   

000000000081b1c4 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  81b1c4:	55                   	push   %rbp
  81b1c5:	48 89 e5             	mov    %rsp,%rbp
  81b1c8:	48 83 ec 10          	sub    $0x10,%rsp
  81b1cc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   if(msg->conn->pcb.tcp == NULL) {
  81b1d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b1d4:	48 8b 00             	mov    (%rax),%rax
  81b1d7:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b1db:	48 85 c0             	test   %rax,%rax
  81b1de:	75 13                	jne    81b1f3 <do_newconn+0x2f>
     pcb_new(msg);
  81b1e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b1e4:	48 89 c7             	mov    %rax,%rdi
  81b1e7:	48 b8 e9 af 81 00 00 	movabs $0x81afe9,%rax
  81b1ee:	00 00 00 
  81b1f1:	ff d0                	callq  *%rax
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  81b1f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b1f7:	48 8b 00             	mov    (%rax),%rax
  81b1fa:	8b 40 14             	mov    0x14(%rax),%eax
  81b1fd:	89 c7                	mov    %eax,%edi
  81b1ff:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  81b206:	00 00 00 
  81b209:	ff d0                	callq  *%rax
}
  81b20b:	90                   	nop
  81b20c:	c9                   	leaveq 
  81b20d:	c3                   	retq   

000000000081b20e <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  81b20e:	55                   	push   %rbp
  81b20f:	48 89 e5             	mov    %rsp,%rbp
  81b212:	48 83 ec 20          	sub    $0x20,%rsp
  81b216:	89 7d ec             	mov    %edi,-0x14(%rbp)
  81b219:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  81b21d:	bf 07 00 00 00       	mov    $0x7,%edi
  81b222:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  81b229:	00 00 00 
  81b22c:	ff d0                	callq  *%rax
  81b22e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (conn == NULL) {
  81b232:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81b237:	75 0a                	jne    81b243 <netconn_alloc+0x35>
    return NULL;
  81b239:	b8 00 00 00 00       	mov    $0x0,%eax
  81b23e:	e9 01 01 00 00       	jmpq   81b344 <netconn_alloc+0x136>
  }

  conn->err = ERR_OK;
  81b243:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b247:	c6 40 10 00          	movb   $0x0,0x10(%rax)
  conn->type = t;
  81b24b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b24f:	8b 55 ec             	mov    -0x14(%rbp),%edx
  81b252:	89 10                	mov    %edx,(%rax)
  conn->pcb.tcp = NULL;
  81b254:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b258:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81b25f:	00 

#if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
    (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
  size = DEFAULT_RAW_RECVMBOX_SIZE;
  81b260:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  81b267:	bf 00 00 00 00       	mov    $0x0,%edi
  81b26c:	48 b8 e1 7e 81 00 00 	movabs $0x817ee1,%rax
  81b273:	00 00 00 
  81b276:	ff d0                	callq  *%rax
  81b278:	89 c2                	mov    %eax,%edx
  81b27a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b27e:	89 50 14             	mov    %edx,0x14(%rax)
  81b281:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b285:	8b 40 14             	mov    0x14(%rax),%eax
  81b288:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b28b:	75 22                	jne    81b2af <netconn_alloc+0xa1>
    memp_free(MEMP_NETCONN, conn);
  81b28d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b291:	48 89 c6             	mov    %rax,%rsi
  81b294:	bf 07 00 00 00       	mov    $0x7,%edi
  81b299:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  81b2a0:	00 00 00 
  81b2a3:	ff d0                	callq  *%rax
    return NULL;
  81b2a5:	b8 00 00 00 00       	mov    $0x0,%eax
  81b2aa:	e9 95 00 00 00       	jmpq   81b344 <netconn_alloc+0x136>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  81b2af:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81b2b2:	89 c7                	mov    %eax,%edi
  81b2b4:	48 b8 de 77 81 00 00 	movabs $0x8177de,%rax
  81b2bb:	00 00 00 
  81b2be:	ff d0                	callq  *%rax
  81b2c0:	89 c2                	mov    %eax,%edx
  81b2c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b2c6:	89 50 18             	mov    %edx,0x18(%rax)
  81b2c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b2cd:	8b 40 18             	mov    0x18(%rax),%eax
  81b2d0:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b2d3:	75 34                	jne    81b309 <netconn_alloc+0xfb>
    sys_sem_free(conn->op_completed);
  81b2d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b2d9:	8b 40 14             	mov    0x14(%rax),%eax
  81b2dc:	89 c7                	mov    %eax,%edi
  81b2de:	48 b8 df 7f 81 00 00 	movabs $0x817fdf,%rax
  81b2e5:	00 00 00 
  81b2e8:	ff d0                	callq  *%rax
    memp_free(MEMP_NETCONN, conn);
  81b2ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b2ee:	48 89 c6             	mov    %rax,%rsi
  81b2f1:	bf 07 00 00 00       	mov    $0x7,%edi
  81b2f6:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  81b2fd:	00 00 00 
  81b300:	ff d0                	callq  *%rax
    return NULL;
  81b302:	b8 00 00 00 00       	mov    $0x0,%eax
  81b307:	eb 3b                	jmp    81b344 <netconn_alloc+0x136>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  81b309:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b30d:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%rax)
  conn->state        = NETCONN_NONE;
  81b314:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b318:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  81b31f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b323:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%rax)
  conn->callback     = callback;
  81b32a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b32e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81b332:	48 89 50 38          	mov    %rdx,0x38(%rax)
  conn->recv_avail   = 0;
  81b336:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b33a:	66 c7 40 24 00 00    	movw   $0x0,0x24(%rax)
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
  81b340:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81b344:	c9                   	leaveq 
  81b345:	c3                   	retq   

000000000081b346 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  81b346:	55                   	push   %rbp
  81b347:	48 89 e5             	mov    %rsp,%rbp
  81b34a:	48 83 ec 20          	sub    $0x20,%rsp
  81b34e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  81b352:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b356:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b35a:	48 85 c0             	test   %rax,%rax
  81b35d:	74 2a                	je     81b389 <netconn_free+0x43>
  81b35f:	48 ba 88 3a 82 00 00 	movabs $0x823a88,%rdx
  81b366:	00 00 00 
  81b369:	be 27 02 00 00       	mov    $0x227,%esi
  81b36e:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81b375:	00 00 00 
  81b378:	b8 00 00 00 00       	mov    $0x0,%eax
  81b37d:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81b384:	00 00 00 
  81b387:	ff d1                	callq  *%rcx

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  81b389:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b38d:	8b 40 18             	mov    0x18(%rax),%eax
  81b390:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b393:	74 7f                	je     81b414 <netconn_free+0xce>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  81b395:	eb 3c                	jmp    81b3d3 <netconn_free+0x8d>
      if (conn->type == NETCONN_TCP) {
  81b397:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b39b:	8b 00                	mov    (%rax),%eax
  81b39d:	83 f8 10             	cmp    $0x10,%eax
  81b3a0:	75 1e                	jne    81b3c0 <netconn_free+0x7a>
        if(mem != NULL) {
  81b3a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b3a6:	48 85 c0             	test   %rax,%rax
  81b3a9:	74 28                	je     81b3d3 <netconn_free+0x8d>
          pbuf_free((struct pbuf *)mem);
  81b3ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b3af:	48 89 c7             	mov    %rax,%rdi
  81b3b2:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81b3b9:	00 00 00 
  81b3bc:	ff d0                	callq  *%rax
  81b3be:	eb 13                	jmp    81b3d3 <netconn_free+0x8d>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  81b3c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b3c4:	48 89 c7             	mov    %rax,%rdi
  81b3c7:	48 b8 5c 8e 80 00 00 	movabs $0x808e5c,%rax
  81b3ce:	00 00 00 
  81b3d1:	ff d0                	callq  *%rax
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  81b3d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b3d7:	8b 40 18             	mov    0x18(%rax),%eax
  81b3da:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  81b3de:	48 89 d6             	mov    %rdx,%rsi
  81b3e1:	89 c7                	mov    %eax,%edi
  81b3e3:	48 b8 2c 87 81 00 00 	movabs $0x81872c,%rax
  81b3ea:	00 00 00 
  81b3ed:	ff d0                	callq  *%rax
  81b3ef:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b3f2:	75 a3                	jne    81b397 <netconn_free+0x51>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  81b3f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b3f8:	8b 40 18             	mov    0x18(%rax),%eax
  81b3fb:	89 c7                	mov    %eax,%edi
  81b3fd:	48 b8 c2 79 81 00 00 	movabs $0x8179c2,%rax
  81b404:	00 00 00 
  81b407:	ff d0                	callq  *%rax
    conn->recvmbox = SYS_MBOX_NULL;
  81b409:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b40d:	c7 40 18 ff ff ff ff 	movl   $0xffffffff,0x18(%rax)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  81b414:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b418:	8b 40 1c             	mov    0x1c(%rax),%eax
  81b41b:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b41e:	74 56                	je     81b476 <netconn_free+0x130>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  81b420:	eb 13                	jmp    81b435 <netconn_free+0xef>
      netconn_delete((struct netconn *)mem);
  81b422:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b426:	48 89 c7             	mov    %rax,%rdi
  81b429:	48 b8 2c 9d 81 00 00 	movabs $0x819d2c,%rax
  81b430:	00 00 00 
  81b433:	ff d0                	callq  *%rax
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  81b435:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b439:	8b 40 1c             	mov    0x1c(%rax),%eax
  81b43c:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  81b440:	48 89 d6             	mov    %rdx,%rsi
  81b443:	89 c7                	mov    %eax,%edi
  81b445:	48 b8 2c 87 81 00 00 	movabs $0x81872c,%rax
  81b44c:	00 00 00 
  81b44f:	ff d0                	callq  *%rax
  81b451:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b454:	75 cc                	jne    81b422 <netconn_free+0xdc>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  81b456:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b45a:	8b 40 1c             	mov    0x1c(%rax),%eax
  81b45d:	89 c7                	mov    %eax,%edi
  81b45f:	48 b8 c2 79 81 00 00 	movabs $0x8179c2,%rax
  81b466:	00 00 00 
  81b469:	ff d0                	callq  *%rax
    conn->acceptmbox = SYS_MBOX_NULL;
  81b46b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b46f:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%rax)
  }

  sys_sem_free(conn->op_completed);
  81b476:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b47a:	8b 40 14             	mov    0x14(%rax),%eax
  81b47d:	89 c7                	mov    %eax,%edi
  81b47f:	48 b8 df 7f 81 00 00 	movabs $0x817fdf,%rax
  81b486:	00 00 00 
  81b489:	ff d0                	callq  *%rax
  conn->op_completed = SYS_SEM_NULL;
  81b48b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b48f:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%rax)

  memp_free(MEMP_NETCONN, conn);
  81b496:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b49a:	48 89 c6             	mov    %rax,%rsi
  81b49d:	bf 07 00 00 00       	mov    $0x7,%edi
  81b4a2:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  81b4a9:	00 00 00 
  81b4ac:	ff d0                	callq  *%rax
}
  81b4ae:	90                   	nop
  81b4af:	c9                   	leaveq 
  81b4b0:	c3                   	retq   

000000000081b4b1 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  81b4b1:	55                   	push   %rbp
  81b4b2:	48 89 e5             	mov    %rsp,%rbp
  81b4b5:	48 83 ec 20          	sub    $0x20,%rsp
  81b4b9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  81b4bd:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81b4c2:	75 2a                	jne    81b4ee <do_close_internal+0x3d>
  81b4c4:	48 ba b6 3a 82 00 00 	movabs $0x823ab6,%rdx
  81b4cb:	00 00 00 
  81b4ce:	be 54 02 00 00       	mov    $0x254,%esi
  81b4d3:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81b4da:	00 00 00 
  81b4dd:	b8 00 00 00 00       	mov    $0x0,%eax
  81b4e2:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81b4e9:	00 00 00 
  81b4ec:	ff d1                	callq  *%rcx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  81b4ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4f2:	8b 00                	mov    (%rax),%eax
  81b4f4:	83 f8 10             	cmp    $0x10,%eax
  81b4f7:	74 2a                	je     81b523 <do_close_internal+0x72>
  81b4f9:	48 ba c3 3a 82 00 00 	movabs $0x823ac3,%rdx
  81b500:	00 00 00 
  81b503:	be 55 02 00 00       	mov    $0x255,%esi
  81b508:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81b50f:	00 00 00 
  81b512:	b8 00 00 00 00       	mov    $0x0,%eax
  81b517:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81b51e:	00 00 00 
  81b521:	ff d1                	callq  *%rcx
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  81b523:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b527:	8b 40 04             	mov    0x4(%rax),%eax
  81b52a:	83 f8 04             	cmp    $0x4,%eax
  81b52d:	74 2a                	je     81b559 <do_close_internal+0xa8>
  81b52f:	48 ba e8 3a 82 00 00 	movabs $0x823ae8,%rdx
  81b536:	00 00 00 
  81b539:	be 56 02 00 00       	mov    $0x256,%esi
  81b53e:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81b545:	00 00 00 
  81b548:	b8 00 00 00 00       	mov    $0x0,%eax
  81b54d:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81b554:	00 00 00 
  81b557:	ff d1                	callq  *%rcx
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  81b559:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b55d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b561:	48 85 c0             	test   %rax,%rax
  81b564:	75 2a                	jne    81b590 <do_close_internal+0xdf>
  81b566:	48 ba 0c 3b 82 00 00 	movabs $0x823b0c,%rdx
  81b56d:	00 00 00 
  81b570:	be 57 02 00 00       	mov    $0x257,%esi
  81b575:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81b57c:	00 00 00 
  81b57f:	b8 00 00 00 00       	mov    $0x0,%eax
  81b584:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81b58b:	00 00 00 
  81b58e:	ff d1                	callq  *%rcx

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  81b590:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b594:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b598:	be 00 00 00 00       	mov    $0x0,%esi
  81b59d:	48 89 c7             	mov    %rax,%rdi
  81b5a0:	48 b8 fe 08 81 00 00 	movabs $0x8108fe,%rax
  81b5a7:	00 00 00 
  81b5aa:	ff d0                	callq  *%rax
  if (conn->pcb.tcp->state == LISTEN) {
  81b5ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b5b0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b5b4:	8b 40 18             	mov    0x18(%rax),%eax
  81b5b7:	83 f8 01             	cmp    $0x1,%eax
  81b5ba:	75 21                	jne    81b5dd <do_close_internal+0x12c>
    tcp_accept(conn->pcb.tcp, NULL);
  81b5bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b5c0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b5c4:	be 00 00 00 00       	mov    $0x0,%esi
  81b5c9:	48 89 c7             	mov    %rax,%rdi
  81b5cc:	48 b8 83 09 81 00 00 	movabs $0x810983,%rax
  81b5d3:	00 00 00 
  81b5d6:	ff d0                	callq  *%rax
  81b5d8:	e9 91 00 00 00       	jmpq   81b66e <do_close_internal+0x1bd>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  81b5dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b5e1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b5e5:	be 00 00 00 00       	mov    $0x0,%esi
  81b5ea:	48 89 c7             	mov    %rax,%rdi
  81b5ed:	48 b8 1d 09 81 00 00 	movabs $0x81091d,%rax
  81b5f4:	00 00 00 
  81b5f7:	ff d0                	callq  *%rax
    tcp_accept(conn->pcb.tcp, NULL);
  81b5f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b5fd:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b601:	be 00 00 00 00       	mov    $0x0,%esi
  81b606:	48 89 c7             	mov    %rax,%rdi
  81b609:	48 b8 83 09 81 00 00 	movabs $0x810983,%rax
  81b610:	00 00 00 
  81b613:	ff d0                	callq  *%rax
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  81b615:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b619:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b61d:	be 00 00 00 00       	mov    $0x0,%esi
  81b622:	48 89 c7             	mov    %rax,%rdi
  81b625:	48 b8 3f 09 81 00 00 	movabs $0x81093f,%rax
  81b62c:	00 00 00 
  81b62f:	ff d0                	callq  *%rax
    tcp_poll(conn->pcb.tcp, NULL, 4);
  81b631:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b635:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b639:	ba 04 00 00 00       	mov    $0x4,%edx
  81b63e:	be 00 00 00 00       	mov    $0x0,%esi
  81b643:	48 89 c7             	mov    %rax,%rdi
  81b646:	48 b8 a2 09 81 00 00 	movabs $0x8109a2,%rax
  81b64d:	00 00 00 
  81b650:	ff d0                	callq  *%rax
    tcp_err(conn->pcb.tcp, NULL);
  81b652:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b656:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b65a:	be 00 00 00 00       	mov    $0x0,%esi
  81b65f:	48 89 c7             	mov    %rax,%rdi
  81b662:	48 b8 61 09 81 00 00 	movabs $0x810961,%rax
  81b669:	00 00 00 
  81b66c:	ff d0                	callq  *%rax
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  81b66e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b672:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b676:	48 89 c7             	mov    %rax,%rdi
  81b679:	48 b8 94 ec 80 00 00 	movabs $0x80ec94,%rax
  81b680:	00 00 00 
  81b683:	ff d0                	callq  *%rax
  81b685:	88 45 ff             	mov    %al,-0x1(%rbp)
  if (err == ERR_OK) {
  81b688:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  81b68c:	0f 85 89 00 00 00    	jne    81b71b <do_close_internal+0x26a>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  81b692:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b696:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  81b69d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6a1:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81b6a8:	00 
    conn->err = ERR_OK;
  81b6a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6ad:	c6 40 10 00          	movb   $0x0,0x10(%rax)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81b6b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6b5:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b6b9:	48 85 c0             	test   %rax,%rax
  81b6bc:	74 1b                	je     81b6d9 <do_close_internal+0x228>
  81b6be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6c2:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b6c6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81b6ca:	ba 00 00 00 00       	mov    $0x0,%edx
  81b6cf:	be 00 00 00 00       	mov    $0x0,%esi
  81b6d4:	48 89 cf             	mov    %rcx,%rdi
  81b6d7:	ff d0                	callq  *%rax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  81b6d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6dd:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b6e1:	48 85 c0             	test   %rax,%rax
  81b6e4:	74 1b                	je     81b701 <do_close_internal+0x250>
  81b6e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6ea:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b6ee:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81b6f2:	ba 00 00 00 00       	mov    $0x0,%edx
  81b6f7:	be 02 00 00 00       	mov    $0x2,%esi
  81b6fc:	48 89 cf             	mov    %rcx,%rdi
  81b6ff:	ff d0                	callq  *%rax
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  81b701:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b705:	8b 40 14             	mov    0x14(%rax),%eax
  81b708:	89 c7                	mov    %eax,%edi
  81b70a:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  81b711:	00 00 00 
  81b714:	ff d0                	callq  *%rax
    tcp_err(conn->pcb.tcp, err_tcp);
    tcp_arg(conn->pcb.tcp, conn);
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  81b716:	e9 c0 00 00 00       	jmpq   81b7db <do_close_internal+0x32a>
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  81b71b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b71f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b723:	8b 40 18             	mov    0x18(%rax),%eax
  81b726:	83 f8 01             	cmp    $0x1,%eax
  81b729:	75 2a                	jne    81b755 <do_close_internal+0x2a4>
  81b72b:	48 ba 20 3b 82 00 00 	movabs $0x823b20,%rdx
  81b732:	00 00 00 
  81b735:	be 76 02 00 00       	mov    $0x276,%esi
  81b73a:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81b741:	00 00 00 
  81b744:	b8 00 00 00 00       	mov    $0x0,%eax
  81b749:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81b750:	00 00 00 
  81b753:	ff d1                	callq  *%rcx
    tcp_sent(conn->pcb.tcp, sent_tcp);
  81b755:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b759:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b75d:	48 be 8b ab 81 00 00 	movabs $0x81ab8b,%rsi
  81b764:	00 00 00 
  81b767:	48 89 c7             	mov    %rax,%rdi
  81b76a:	48 b8 3f 09 81 00 00 	movabs $0x81093f,%rax
  81b771:	00 00 00 
  81b774:	ff d0                	callq  *%rax
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  81b776:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b77a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b77e:	ba 04 00 00 00       	mov    $0x4,%edx
  81b783:	48 be fb aa 81 00 00 	movabs $0x81aafb,%rsi
  81b78a:	00 00 00 
  81b78d:	48 89 c7             	mov    %rax,%rdi
  81b790:	48 b8 a2 09 81 00 00 	movabs $0x8109a2,%rax
  81b797:	00 00 00 
  81b79a:	ff d0                	callq  *%rax
    tcp_err(conn->pcb.tcp, err_tcp);
  81b79c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b7a0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b7a4:	48 be a5 ac 81 00 00 	movabs $0x81aca5,%rsi
  81b7ab:	00 00 00 
  81b7ae:	48 89 c7             	mov    %rax,%rdi
  81b7b1:	48 b8 61 09 81 00 00 	movabs $0x810961,%rax
  81b7b8:	00 00 00 
  81b7bb:	ff d0                	callq  *%rax
    tcp_arg(conn->pcb.tcp, conn);
  81b7bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b7c1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b7c5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81b7c9:	48 89 d6             	mov    %rdx,%rsi
  81b7cc:	48 89 c7             	mov    %rax,%rdi
  81b7cf:	48 b8 fe 08 81 00 00 	movabs $0x8108fe,%rax
  81b7d6:	00 00 00 
  81b7d9:	ff d0                	callq  *%rax
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  81b7db:	90                   	nop
  81b7dc:	c9                   	leaveq 
  81b7dd:	c3                   	retq   

000000000081b7de <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  81b7de:	55                   	push   %rbp
  81b7df:	48 89 e5             	mov    %rsp,%rbp
  81b7e2:	48 83 ec 10          	sub    $0x10,%rsp
  81b7e6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (msg->conn->pcb.tcp != NULL) {
  81b7ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b7ee:	48 8b 00             	mov    (%rax),%rax
  81b7f1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b7f5:	48 85 c0             	test   %rax,%rax
  81b7f8:	0f 84 93 00 00 00    	je     81b891 <do_delconn+0xb3>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b7fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b802:	48 8b 00             	mov    (%rax),%rax
  81b805:	8b 00                	mov    (%rax),%eax
  81b807:	25 f0 00 00 00       	and    $0xf0,%eax
  81b80c:	83 f8 20             	cmp    $0x20,%eax
  81b80f:	74 28                	je     81b839 <do_delconn+0x5b>
  81b811:	83 f8 40             	cmp    $0x40,%eax
  81b814:	74 07                	je     81b81d <do_delconn+0x3f>
  81b816:	83 f8 10             	cmp    $0x10,%eax
  81b819:	74 4d                	je     81b868 <do_delconn+0x8a>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
#endif /* LWIP_TCP */
    default:
      break;
  81b81b:	eb 74                	jmp    81b891 <do_delconn+0xb3>
{
  if (msg->conn->pcb.tcp != NULL) {
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  81b81d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b821:	48 8b 00             	mov    (%rax),%rax
  81b824:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b828:	48 89 c7             	mov    %rax,%rdi
  81b82b:	48 b8 76 02 82 00 00 	movabs $0x820276,%rax
  81b832:	00 00 00 
  81b835:	ff d0                	callq  *%rax
      break;
  81b837:	eb 58                	jmp    81b891 <do_delconn+0xb3>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  81b839:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b83d:	48 8b 00             	mov    (%rax),%rax
  81b840:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b844:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  81b84b:	00 
      udp_remove(msg->conn->pcb.udp);
  81b84c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b850:	48 8b 00             	mov    (%rax),%rax
  81b853:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b857:	48 89 c7             	mov    %rax,%rdi
  81b85a:	48 b8 aa 59 81 00 00 	movabs $0x8159aa,%rax
  81b861:	00 00 00 
  81b864:	ff d0                	callq  *%rax
      break;
  81b866:	eb 29                	jmp    81b891 <do_delconn+0xb3>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  81b868:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b86c:	48 8b 00             	mov    (%rax),%rax
  81b86f:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%rax)
      do_close_internal(msg->conn);
  81b876:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b87a:	48 8b 00             	mov    (%rax),%rax
  81b87d:	48 89 c7             	mov    %rax,%rdi
  81b880:	48 b8 b1 b4 81 00 00 	movabs $0x81b4b1,%rax
  81b887:	00 00 00 
  81b88a:	ff d0                	callq  *%rax
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  81b88c:	e9 89 00 00 00       	jmpq   81b91a <do_delconn+0x13c>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  81b891:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b895:	48 8b 00             	mov    (%rax),%rax
  81b898:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b89c:	48 85 c0             	test   %rax,%rax
  81b89f:	74 21                	je     81b8c2 <do_delconn+0xe4>
  81b8a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b8a5:	48 8b 00             	mov    (%rax),%rax
  81b8a8:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b8ac:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b8b0:	48 8b 0a             	mov    (%rdx),%rcx
  81b8b3:	ba 00 00 00 00       	mov    $0x0,%edx
  81b8b8:	be 00 00 00 00       	mov    $0x0,%esi
  81b8bd:	48 89 cf             	mov    %rcx,%rdi
  81b8c0:	ff d0                	callq  *%rax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  81b8c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b8c6:	48 8b 00             	mov    (%rax),%rax
  81b8c9:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b8cd:	48 85 c0             	test   %rax,%rax
  81b8d0:	74 21                	je     81b8f3 <do_delconn+0x115>
  81b8d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b8d6:	48 8b 00             	mov    (%rax),%rax
  81b8d9:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b8dd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b8e1:	48 8b 0a             	mov    (%rdx),%rcx
  81b8e4:	ba 00 00 00 00       	mov    $0x0,%edx
  81b8e9:	be 02 00 00 00       	mov    $0x2,%esi
  81b8ee:	48 89 cf             	mov    %rcx,%rdi
  81b8f1:	ff d0                	callq  *%rax

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  81b8f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b8f7:	48 8b 00             	mov    (%rax),%rax
  81b8fa:	8b 40 14             	mov    0x14(%rax),%eax
  81b8fd:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b900:	74 18                	je     81b91a <do_delconn+0x13c>
    sys_sem_signal(msg->conn->op_completed);
  81b902:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b906:	48 8b 00             	mov    (%rax),%rax
  81b909:	8b 40 14             	mov    0x14(%rax),%eax
  81b90c:	89 c7                	mov    %eax,%edi
  81b90e:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  81b915:	00 00 00 
  81b918:	ff d0                	callq  *%rax
  }
}
  81b91a:	c9                   	leaveq 
  81b91b:	c3                   	retq   

000000000081b91c <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  81b91c:	55                   	push   %rbp
  81b91d:	48 89 e5             	mov    %rsp,%rbp
  81b920:	53                   	push   %rbx
  81b921:	48 83 ec 18          	sub    $0x18,%rsp
  81b925:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81b929:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b92d:	48 8b 00             	mov    (%rax),%rax
  81b930:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b934:	3c fc                	cmp    $0xfc,%al
  81b936:	0f 8c ed 00 00 00    	jl     81ba29 <do_bind+0x10d>
    if (msg->conn->pcb.tcp != NULL) {
  81b93c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b940:	48 8b 00             	mov    (%rax),%rax
  81b943:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b947:	48 85 c0             	test   %rax,%rax
  81b94a:	0f 84 ce 00 00 00    	je     81ba1e <do_bind+0x102>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b950:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b954:	48 8b 00             	mov    (%rax),%rax
  81b957:	8b 00                	mov    (%rax),%eax
  81b959:	25 f0 00 00 00       	and    $0xf0,%eax
  81b95e:	83 f8 20             	cmp    $0x20,%eax
  81b961:	74 43                	je     81b9a6 <do_bind+0x8a>
  81b963:	83 f8 40             	cmp    $0x40,%eax
  81b966:	74 0a                	je     81b972 <do_bind+0x56>
  81b968:	83 f8 10             	cmp    $0x10,%eax
  81b96b:	74 75                	je     81b9e2 <do_bind+0xc6>
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
        break;
#endif /* LWIP_TCP */
      default:
        break;
  81b96d:	e9 b7 00 00 00       	jmpq   81ba29 <do_bind+0x10d>
  if (!ERR_IS_FATAL(msg->conn->err)) {
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  81b972:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b976:	48 8b 18             	mov    (%rax),%rbx
  81b979:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b97d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81b981:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b985:	48 8b 00             	mov    (%rax),%rax
  81b988:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b98c:	48 89 d6             	mov    %rdx,%rsi
  81b98f:	48 89 c7             	mov    %rax,%rdi
  81b992:	48 b8 04 00 82 00 00 	movabs $0x820004,%rax
  81b999:	00 00 00 
  81b99c:	ff d0                	callq  *%rax
  81b99e:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b9a1:	e9 83 00 00 00       	jmpq   81ba29 <do_bind+0x10d>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81b9a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9aa:	48 8b 18             	mov    (%rax),%rbx
  81b9ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9b1:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b9b5:	0f b7 d0             	movzwl %ax,%edx
  81b9b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9bc:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81b9c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9c4:	48 8b 00             	mov    (%rax),%rax
  81b9c7:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b9cb:	48 89 ce             	mov    %rcx,%rsi
  81b9ce:	48 89 c7             	mov    %rax,%rdi
  81b9d1:	48 b8 f6 56 81 00 00 	movabs $0x8156f6,%rax
  81b9d8:	00 00 00 
  81b9db:	ff d0                	callq  *%rax
  81b9dd:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b9e0:	eb 47                	jmp    81ba29 <do_bind+0x10d>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81b9e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9e6:	48 8b 18             	mov    (%rax),%rbx
  81b9e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9ed:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b9f1:	0f b7 d0             	movzwl %ax,%edx
  81b9f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9f8:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81b9fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba00:	48 8b 00             	mov    (%rax),%rax
  81ba03:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba07:	48 89 ce             	mov    %rcx,%rsi
  81ba0a:	48 89 c7             	mov    %rax,%rdi
  81ba0d:	48 b8 e6 f0 80 00 00 	movabs $0x80f0e6,%rax
  81ba14:	00 00 00 
  81ba17:	ff d0                	callq  *%rax
  81ba19:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81ba1c:	eb 0b                	jmp    81ba29 <do_bind+0x10d>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  81ba1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba22:	48 8b 00             	mov    (%rax),%rax
  81ba25:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81ba29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba2d:	48 8b 00             	mov    (%rax),%rax
  81ba30:	8b 40 14             	mov    0x14(%rax),%eax
  81ba33:	89 c7                	mov    %eax,%edi
  81ba35:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  81ba3c:	00 00 00 
  81ba3f:	ff d0                	callq  *%rax
}
  81ba41:	90                   	nop
  81ba42:	48 83 c4 18          	add    $0x18,%rsp
  81ba46:	5b                   	pop    %rbx
  81ba47:	5d                   	pop    %rbp
  81ba48:	c3                   	retq   

000000000081ba49 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  81ba49:	55                   	push   %rbp
  81ba4a:	48 89 e5             	mov    %rsp,%rbp
  81ba4d:	48 83 ec 30          	sub    $0x30,%rsp
  81ba51:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81ba55:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81ba59:	89 d0                	mov    %edx,%eax
  81ba5b:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct netconn *conn;

  LWIP_UNUSED_ARG(pcb);

  conn = arg;
  81ba5e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba62:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if (conn == NULL) {
  81ba66:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81ba6b:	75 07                	jne    81ba74 <do_connected+0x2b>
    return ERR_VAL;
  81ba6d:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  81ba72:	eb 54                	jmp    81bac8 <do_connected+0x7f>
  }

  conn->err = err;
  81ba74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ba78:	0f b6 55 dc          	movzbl -0x24(%rbp),%edx
  81ba7c:	88 50 10             	mov    %dl,0x10(%rax)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  81ba7f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ba83:	8b 00                	mov    (%rax),%eax
  81ba85:	83 f8 10             	cmp    $0x10,%eax
  81ba88:	75 19                	jne    81baa3 <do_connected+0x5a>
  81ba8a:	80 7d dc 00          	cmpb   $0x0,-0x24(%rbp)
  81ba8e:	75 13                	jne    81baa3 <do_connected+0x5a>
    setup_tcp(conn);
  81ba90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ba94:	48 89 c7             	mov    %rax,%rdi
  81ba97:	48 b8 15 ae 81 00 00 	movabs $0x81ae15,%rax
  81ba9e:	00 00 00 
  81baa1:	ff d0                	callq  *%rax
  }
  conn->state = NETCONN_NONE;
  81baa3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81baa7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  sys_sem_signal(conn->op_completed);
  81baae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bab2:	8b 40 14             	mov    0x14(%rax),%eax
  81bab5:	89 c7                	mov    %eax,%edi
  81bab7:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  81babe:	00 00 00 
  81bac1:	ff d0                	callq  *%rax
  return ERR_OK;
  81bac3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81bac8:	c9                   	leaveq 
  81bac9:	c3                   	retq   

000000000081baca <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  81baca:	55                   	push   %rbp
  81bacb:	48 89 e5             	mov    %rsp,%rbp
  81bace:	53                   	push   %rbx
  81bacf:	48 83 ec 18          	sub    $0x18,%rsp
  81bad3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (msg->conn->pcb.tcp == NULL) {
  81bad7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81badb:	48 8b 00             	mov    (%rax),%rax
  81bade:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bae2:	48 85 c0             	test   %rax,%rax
  81bae5:	75 1d                	jne    81bb04 <do_connect+0x3a>
    sys_sem_signal(msg->conn->op_completed);
  81bae7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81baeb:	48 8b 00             	mov    (%rax),%rax
  81baee:	8b 40 14             	mov    0x14(%rax),%eax
  81baf1:	89 c7                	mov    %eax,%edi
  81baf3:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  81bafa:	00 00 00 
  81bafd:	ff d0                	callq  *%rax
    return;
  81baff:	e9 2c 01 00 00       	jmpq   81bc30 <do_connect+0x166>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81bb04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bb08:	48 8b 00             	mov    (%rax),%rax
  81bb0b:	8b 00                	mov    (%rax),%eax
  81bb0d:	25 f0 00 00 00       	and    $0xf0,%eax
  81bb12:	83 f8 20             	cmp    $0x20,%eax
  81bb15:	74 5f                	je     81bb76 <do_connect+0xac>
  81bb17:	83 f8 40             	cmp    $0x40,%eax
  81bb1a:	74 0e                	je     81bb2a <do_connect+0x60>
  81bb1c:	83 f8 10             	cmp    $0x10,%eax
  81bb1f:	0f 84 a5 00 00 00    	je     81bbca <do_connect+0x100>
    /* sys_sem_signal() is called from do_connected (or err_tcp()),
     * when the connection is established! */
    break;
#endif /* LWIP_TCP */
  default:
    break;
  81bb25:	e9 06 01 00 00       	jmpq   81bc30 <do_connect+0x166>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  81bb2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bb2e:	48 8b 18             	mov    (%rax),%rbx
  81bb31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bb35:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81bb39:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bb3d:	48 8b 00             	mov    (%rax),%rax
  81bb40:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bb44:	48 89 d6             	mov    %rdx,%rsi
  81bb47:	48 89 c7             	mov    %rax,%rdi
  81bb4a:	48 b8 35 00 82 00 00 	movabs $0x820035,%rax
  81bb51:	00 00 00 
  81bb54:	ff d0                	callq  *%rax
  81bb56:	88 43 10             	mov    %al,0x10(%rbx)
    sys_sem_signal(msg->conn->op_completed);
  81bb59:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bb5d:	48 8b 00             	mov    (%rax),%rax
  81bb60:	8b 40 14             	mov    0x14(%rax),%eax
  81bb63:	89 c7                	mov    %eax,%edi
  81bb65:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  81bb6c:	00 00 00 
  81bb6f:	ff d0                	callq  *%rax
    break;
  81bb71:	e9 ba 00 00 00       	jmpq   81bc30 <do_connect+0x166>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81bb76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bb7a:	48 8b 18             	mov    (%rax),%rbx
  81bb7d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bb81:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81bb85:	0f b7 d0             	movzwl %ax,%edx
  81bb88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bb8c:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81bb90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bb94:	48 8b 00             	mov    (%rax),%rax
  81bb97:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bb9b:	48 89 ce             	mov    %rcx,%rsi
  81bb9e:	48 89 c7             	mov    %rax,%rdi
  81bba1:	48 b8 42 58 81 00 00 	movabs $0x815842,%rax
  81bba8:	00 00 00 
  81bbab:	ff d0                	callq  *%rax
  81bbad:	88 43 10             	mov    %al,0x10(%rbx)
    sys_sem_signal(msg->conn->op_completed);
  81bbb0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bbb4:	48 8b 00             	mov    (%rax),%rax
  81bbb7:	8b 40 14             	mov    0x14(%rax),%eax
  81bbba:	89 c7                	mov    %eax,%edi
  81bbbc:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  81bbc3:	00 00 00 
  81bbc6:	ff d0                	callq  *%rax
    break;
  81bbc8:	eb 66                	jmp    81bc30 <do_connect+0x166>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  81bbca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bbce:	48 8b 00             	mov    (%rax),%rax
  81bbd1:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%rax)
    setup_tcp(msg->conn);
  81bbd8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bbdc:	48 8b 00             	mov    (%rax),%rax
  81bbdf:	48 89 c7             	mov    %rax,%rdi
  81bbe2:	48 b8 15 ae 81 00 00 	movabs $0x81ae15,%rax
  81bbe9:	00 00 00 
  81bbec:	ff d0                	callq  *%rax
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  81bbee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bbf2:	48 8b 18             	mov    (%rax),%rbx
  81bbf5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bbf9:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81bbfd:	0f b7 d0             	movzwl %ax,%edx
  81bc00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc04:	48 8b 70 08          	mov    0x8(%rax),%rsi
  81bc08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc0c:	48 8b 00             	mov    (%rax),%rax
  81bc0f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bc13:	48 b9 49 ba 81 00 00 	movabs $0x81ba49,%rcx
  81bc1a:	00 00 00 
  81bc1d:	48 89 c7             	mov    %rax,%rdi
  81bc20:	48 b8 1b f8 80 00 00 	movabs $0x80f81b,%rax
  81bc27:	00 00 00 
  81bc2a:	ff d0                	callq  *%rax
  81bc2c:	88 43 10             	mov    %al,0x10(%rbx)
                                 do_connected);
    /* sys_sem_signal() is called from do_connected (or err_tcp()),
     * when the connection is established! */
    break;
  81bc2f:	90                   	nop
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  81bc30:	48 83 c4 18          	add    $0x18,%rsp
  81bc34:	5b                   	pop    %rbx
  81bc35:	5d                   	pop    %rbp
  81bc36:	c3                   	retq   

000000000081bc37 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  81bc37:	55                   	push   %rbp
  81bc38:	48 89 e5             	mov    %rsp,%rbp
  81bc3b:	48 83 ec 10          	sub    $0x10,%rsp
  81bc3f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  81bc43:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bc47:	48 8b 00             	mov    (%rax),%rax
  81bc4a:	8b 00                	mov    (%rax),%eax
  81bc4c:	25 f0 00 00 00       	and    $0xf0,%eax
  81bc51:	83 f8 20             	cmp    $0x20,%eax
  81bc54:	75 1a                	jne    81bc70 <do_disconnect+0x39>
    udp_disconnect(msg->conn->pcb.udp);
  81bc56:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bc5a:	48 8b 00             	mov    (%rax),%rax
  81bc5d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bc61:	48 89 c7             	mov    %rax,%rdi
  81bc64:	48 b8 3b 59 81 00 00 	movabs $0x81593b,%rax
  81bc6b:	00 00 00 
  81bc6e:	ff d0                	callq  *%rax
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  81bc70:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bc74:	48 8b 00             	mov    (%rax),%rax
  81bc77:	8b 40 14             	mov    0x14(%rax),%eax
  81bc7a:	89 c7                	mov    %eax,%edi
  81bc7c:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  81bc83:	00 00 00 
  81bc86:	ff d0                	callq  *%rax
}
  81bc88:	90                   	nop
  81bc89:	c9                   	leaveq 
  81bc8a:	c3                   	retq   

000000000081bc8b <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  81bc8b:	55                   	push   %rbp
  81bc8c:	48 89 e5             	mov    %rsp,%rbp
  81bc8f:	53                   	push   %rbx
  81bc90:	48 83 ec 28          	sub    $0x28,%rsp
  81bc94:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81bc98:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc9c:	48 8b 00             	mov    (%rax),%rax
  81bc9f:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81bca3:	3c fc                	cmp    $0xfc,%al
  81bca5:	0f 8c 69 01 00 00    	jl     81be14 <do_listen+0x189>
    if (msg->conn->pcb.tcp != NULL) {
  81bcab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bcaf:	48 8b 00             	mov    (%rax),%rax
  81bcb2:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bcb6:	48 85 c0             	test   %rax,%rax
  81bcb9:	0f 84 55 01 00 00    	je     81be14 <do_listen+0x189>
      if (msg->conn->type == NETCONN_TCP) {
  81bcbf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bcc3:	48 8b 00             	mov    (%rax),%rax
  81bcc6:	8b 00                	mov    (%rax),%eax
  81bcc8:	83 f8 10             	cmp    $0x10,%eax
  81bccb:	0f 85 43 01 00 00    	jne    81be14 <do_listen+0x189>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  81bcd1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bcd5:	48 8b 00             	mov    (%rax),%rax
  81bcd8:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bcdc:	8b 40 18             	mov    0x18(%rax),%eax
  81bcdf:	85 c0                	test   %eax,%eax
  81bce1:	0f 85 22 01 00 00    	jne    81be09 <do_listen+0x17e>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  81bce7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bceb:	48 8b 00             	mov    (%rax),%rax
  81bcee:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bcf2:	be ff 00 00 00       	mov    $0xff,%esi
  81bcf7:	48 89 c7             	mov    %rax,%rdi
  81bcfa:	48 b8 67 f3 80 00 00 	movabs $0x80f367,%rax
  81bd01:	00 00 00 
  81bd04:	ff d0                	callq  *%rax
  81bd06:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  81bd0a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81bd0f:	75 10                	jne    81bd21 <do_listen+0x96>
            msg->conn->err = ERR_MEM;
  81bd11:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd15:	48 8b 00             	mov    (%rax),%rax
  81bd18:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
  81bd1c:	e9 f3 00 00 00       	jmpq   81be14 <do_listen+0x189>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  81bd21:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd25:	48 8b 00             	mov    (%rax),%rax
  81bd28:	8b 40 18             	mov    0x18(%rax),%eax
  81bd2b:	83 f8 ff             	cmp    $0xffffffff,%eax
  81bd2e:	74 26                	je     81bd56 <do_listen+0xcb>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  81bd30:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd34:	48 8b 00             	mov    (%rax),%rax
  81bd37:	8b 40 18             	mov    0x18(%rax),%eax
  81bd3a:	89 c7                	mov    %eax,%edi
  81bd3c:	48 b8 c2 79 81 00 00 	movabs $0x8179c2,%rax
  81bd43:	00 00 00 
  81bd46:	ff d0                	callq  *%rax
              msg->conn->recvmbox = SYS_MBOX_NULL;
  81bd48:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd4c:	48 8b 00             	mov    (%rax),%rax
  81bd4f:	c7 40 18 ff ff ff ff 	movl   $0xffffffff,0x18(%rax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  81bd56:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd5a:	48 8b 00             	mov    (%rax),%rax
  81bd5d:	8b 40 1c             	mov    0x1c(%rax),%eax
  81bd60:	83 f8 ff             	cmp    $0xffffffff,%eax
  81bd63:	75 2e                	jne    81bd93 <do_listen+0x108>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  81bd65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd69:	48 8b 18             	mov    (%rax),%rbx
  81bd6c:	bf 00 00 00 00       	mov    $0x0,%edi
  81bd71:	48 b8 de 77 81 00 00 	movabs $0x8177de,%rax
  81bd78:	00 00 00 
  81bd7b:	ff d0                	callq  *%rax
  81bd7d:	89 43 1c             	mov    %eax,0x1c(%rbx)
  81bd80:	8b 43 1c             	mov    0x1c(%rbx),%eax
  81bd83:	83 f8 ff             	cmp    $0xffffffff,%eax
  81bd86:	75 0b                	jne    81bd93 <do_listen+0x108>
                msg->conn->err = ERR_MEM;
  81bd88:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd8c:	48 8b 00             	mov    (%rax),%rax
  81bd8f:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  81bd93:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd97:	48 8b 00             	mov    (%rax),%rax
  81bd9a:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81bd9e:	84 c0                	test   %al,%al
  81bda0:	75 72                	jne    81be14 <do_listen+0x189>
              msg->conn->state = NETCONN_LISTEN;
  81bda2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bda6:	48 8b 00             	mov    (%rax),%rax
  81bda9:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%rax)
              msg->conn->pcb.tcp = lpcb;
  81bdb0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bdb4:	48 8b 00             	mov    (%rax),%rax
  81bdb7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81bdbb:	48 89 50 08          	mov    %rdx,0x8(%rax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  81bdbf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bdc3:	48 8b 10             	mov    (%rax),%rdx
  81bdc6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bdca:	48 8b 00             	mov    (%rax),%rax
  81bdcd:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bdd1:	48 89 d6             	mov    %rdx,%rsi
  81bdd4:	48 89 c7             	mov    %rax,%rdi
  81bdd7:	48 b8 fe 08 81 00 00 	movabs $0x8108fe,%rax
  81bdde:	00 00 00 
  81bde1:	ff d0                	callq  *%rax
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  81bde3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bde7:	48 8b 00             	mov    (%rax),%rax
  81bdea:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bdee:	48 be c3 ae 81 00 00 	movabs $0x81aec3,%rsi
  81bdf5:	00 00 00 
  81bdf8:	48 89 c7             	mov    %rax,%rdi
  81bdfb:	48 b8 83 09 81 00 00 	movabs $0x810983,%rax
  81be02:	00 00 00 
  81be05:	ff d0                	callq  *%rax
  81be07:	eb 0b                	jmp    81be14 <do_listen+0x189>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  81be09:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be0d:	48 8b 00             	mov    (%rax),%rax
  81be10:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  81be14:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be18:	48 8b 00             	mov    (%rax),%rax
  81be1b:	8b 40 14             	mov    0x14(%rax),%eax
  81be1e:	89 c7                	mov    %eax,%edi
  81be20:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  81be27:	00 00 00 
  81be2a:	ff d0                	callq  *%rax
}
  81be2c:	90                   	nop
  81be2d:	48 83 c4 28          	add    $0x28,%rsp
  81be31:	5b                   	pop    %rbx
  81be32:	5d                   	pop    %rbp
  81be33:	c3                   	retq   

000000000081be34 <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  81be34:	55                   	push   %rbp
  81be35:	48 89 e5             	mov    %rsp,%rbp
  81be38:	53                   	push   %rbx
  81be39:	48 83 ec 18          	sub    $0x18,%rsp
  81be3d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81be41:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81be45:	48 8b 00             	mov    (%rax),%rax
  81be48:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81be4c:	3c fc                	cmp    $0xfc,%al
  81be4e:	0f 8c 50 01 00 00    	jl     81bfa4 <do_send+0x170>
    if (msg->conn->pcb.tcp != NULL) {
  81be54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81be58:	48 8b 00             	mov    (%rax),%rax
  81be5b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81be5f:	48 85 c0             	test   %rax,%rax
  81be62:	0f 84 3c 01 00 00    	je     81bfa4 <do_send+0x170>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81be68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81be6c:	48 8b 00             	mov    (%rax),%rax
  81be6f:	8b 00                	mov    (%rax),%eax
  81be71:	25 f0 00 00 00       	and    $0xf0,%eax
  81be76:	83 f8 20             	cmp    $0x20,%eax
  81be79:	0f 84 95 00 00 00    	je     81bf14 <do_send+0xe0>
  81be7f:	83 f8 40             	cmp    $0x40,%eax
  81be82:	74 05                	je     81be89 <do_send+0x55>
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
        }
        break;
#endif /* LWIP_UDP */
      default:
        break;
  81be84:	e9 1b 01 00 00       	jmpq   81bfa4 <do_send+0x170>
  if (!ERR_IS_FATAL(msg->conn->err)) {
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  81be89:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81be8d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81be91:	48 8b 40 10          	mov    0x10(%rax),%rax
  81be95:	48 85 c0             	test   %rax,%rax
  81be98:	75 37                	jne    81bed1 <do_send+0x9d>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  81be9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81be9e:	48 8b 18             	mov    (%rax),%rbx
  81bea1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bea5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bea9:	48 8b 10             	mov    (%rax),%rdx
  81beac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81beb0:	48 8b 00             	mov    (%rax),%rax
  81beb3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81beb7:	48 89 d6             	mov    %rdx,%rsi
  81beba:	48 89 c7             	mov    %rax,%rdi
  81bebd:	48 b8 42 02 82 00 00 	movabs $0x820242,%rax
  81bec4:	00 00 00 
  81bec7:	ff d0                	callq  *%rax
  81bec9:	88 43 10             	mov    %al,0x10(%rbx)
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
        }
        break;
  81becc:	e9 d3 00 00 00       	jmpq   81bfa4 <do_send+0x170>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  81bed1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bed5:	48 8b 18             	mov    (%rax),%rbx
  81bed8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bedc:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bee0:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81bee4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bee8:	48 8b 40 08          	mov    0x8(%rax),%rax
  81beec:	48 8b 08             	mov    (%rax),%rcx
  81beef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bef3:	48 8b 00             	mov    (%rax),%rax
  81bef6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81befa:	48 89 ce             	mov    %rcx,%rsi
  81befd:	48 89 c7             	mov    %rax,%rdi
  81bf00:	48 b8 96 00 82 00 00 	movabs $0x820096,%rax
  81bf07:	00 00 00 
  81bf0a:	ff d0                	callq  *%rax
  81bf0c:	88 43 10             	mov    %al,0x10(%rbx)
        }
        break;
  81bf0f:	e9 90 00 00 00       	jmpq   81bfa4 <do_send+0x170>
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  81bf14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf18:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf1c:	48 8b 40 10          	mov    0x10(%rax),%rax
  81bf20:	48 85 c0             	test   %rax,%rax
  81bf23:	75 34                	jne    81bf59 <do_send+0x125>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  81bf25:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf29:	48 8b 18             	mov    (%rax),%rbx
  81bf2c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf30:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf34:	48 8b 10             	mov    (%rax),%rdx
  81bf37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf3b:	48 8b 00             	mov    (%rax),%rax
  81bf3e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf42:	48 89 d6             	mov    %rdx,%rsi
  81bf45:	48 89 c7             	mov    %rax,%rdi
  81bf48:	48 b8 90 53 81 00 00 	movabs $0x815390,%rax
  81bf4f:	00 00 00 
  81bf52:	ff d0                	callq  *%rax
  81bf54:	88 43 10             	mov    %al,0x10(%rbx)
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
        }
        break;
  81bf57:	eb 4a                	jmp    81bfa3 <do_send+0x16f>
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  81bf59:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf5d:	48 8b 18             	mov    (%rax),%rbx
  81bf60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf64:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf68:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81bf6c:	0f b7 c8             	movzwl %ax,%ecx
  81bf6f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf73:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf77:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81bf7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf7f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf83:	48 8b 30             	mov    (%rax),%rsi
  81bf86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf8a:	48 8b 00             	mov    (%rax),%rax
  81bf8d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf91:	48 89 c7             	mov    %rax,%rdi
  81bf94:	48 b8 d1 53 81 00 00 	movabs $0x8153d1,%rax
  81bf9b:	00 00 00 
  81bf9e:	ff d0                	callq  *%rax
  81bfa0:	88 43 10             	mov    %al,0x10(%rbx)
        }
        break;
  81bfa3:	90                   	nop
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81bfa4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bfa8:	48 8b 00             	mov    (%rax),%rax
  81bfab:	8b 40 14             	mov    0x14(%rax),%eax
  81bfae:	89 c7                	mov    %eax,%edi
  81bfb0:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  81bfb7:	00 00 00 
  81bfba:	ff d0                	callq  *%rax
}
  81bfbc:	90                   	nop
  81bfbd:	48 83 c4 18          	add    $0x18,%rsp
  81bfc1:	5b                   	pop    %rbx
  81bfc2:	5d                   	pop    %rbp
  81bfc3:	c3                   	retq   

000000000081bfc4 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  81bfc4:	55                   	push   %rbp
  81bfc5:	48 89 e5             	mov    %rsp,%rbp
  81bfc8:	48 83 ec 10          	sub    $0x10,%rsp
  81bfcc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81bfd0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bfd4:	48 8b 00             	mov    (%rax),%rax
  81bfd7:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81bfdb:	3c fc                	cmp    $0xfc,%al
  81bfdd:	7c 45                	jl     81c024 <do_recv+0x60>
    if (msg->conn->pcb.tcp != NULL) {
  81bfdf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bfe3:	48 8b 00             	mov    (%rax),%rax
  81bfe6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bfea:	48 85 c0             	test   %rax,%rax
  81bfed:	74 35                	je     81c024 <do_recv+0x60>
      if (msg->conn->type == NETCONN_TCP) {
  81bfef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bff3:	48 8b 00             	mov    (%rax),%rax
  81bff6:	8b 00                	mov    (%rax),%eax
  81bff8:	83 f8 10             	cmp    $0x10,%eax
  81bffb:	75 27                	jne    81c024 <do_recv+0x60>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  81bffd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c001:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81c005:	0f b7 d0             	movzwl %ax,%edx
  81c008:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c00c:	48 8b 00             	mov    (%rax),%rax
  81c00f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c013:	89 d6                	mov    %edx,%esi
  81c015:	48 89 c7             	mov    %rax,%rdi
  81c018:	48 b8 aa f5 80 00 00 	movabs $0x80f5aa,%rax
  81c01f:	00 00 00 
  81c022:	ff d0                	callq  *%rax
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  81c024:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c028:	48 8b 00             	mov    (%rax),%rax
  81c02b:	8b 40 14             	mov    0x14(%rax),%eax
  81c02e:	89 c7                	mov    %eax,%edi
  81c030:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  81c037:	00 00 00 
  81c03a:	ff d0                	callq  *%rax
}
  81c03c:	90                   	nop
  81c03d:	c9                   	leaveq 
  81c03e:	c3                   	retq   

000000000081c03f <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  81c03f:	55                   	push   %rbp
  81c040:	48 89 e5             	mov    %rsp,%rbp
  81c043:	48 83 ec 30          	sub    $0x30,%rsp
  81c047:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  81c04b:	c6 45 fd 00          	movb   $0x0,-0x3(%rbp)

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  81c04f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c053:	8b 40 04             	mov    0x4(%rax),%eax
  81c056:	83 f8 01             	cmp    $0x1,%eax
  81c059:	74 2a                	je     81c085 <do_writemore+0x46>
  81c05b:	48 ba 43 3b 82 00 00 	movabs $0x823b43,%rdx
  81c062:	00 00 00 
  81c065:	be b9 03 00 00       	mov    $0x3b9,%esi
  81c06a:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81c071:	00 00 00 
  81c074:	b8 00 00 00 00       	mov    $0x0,%eax
  81c079:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81c080:	00 00 00 
  81c083:	ff d1                	callq  *%rcx

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  81c085:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c089:	48 8b 40 28          	mov    0x28(%rax),%rax
  81c08d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81c091:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c095:	8b 40 30             	mov    0x30(%rax),%eax
  81c098:	48 98                	cltq   
  81c09a:	48 01 d0             	add    %rdx,%rax
  81c09d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  81c0a1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c0a5:	48 8b 40 28          	mov    0x28(%rax),%rax
  81c0a9:	8b 50 10             	mov    0x10(%rax),%edx
  81c0ac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c0b0:	8b 40 30             	mov    0x30(%rax),%eax
  81c0b3:	29 c2                	sub    %eax,%edx
  81c0b5:	89 d0                	mov    %edx,%eax
  81c0b7:	3d ff ff 00 00       	cmp    $0xffff,%eax
  81c0bc:	7e 08                	jle    81c0c6 <do_writemore+0x87>
    len = 0xffff;
  81c0be:	66 c7 45 fe ff ff    	movw   $0xffff,-0x2(%rbp)
  81c0c4:	eb 1c                	jmp    81c0e2 <do_writemore+0xa3>
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  81c0c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c0ca:	48 8b 40 28          	mov    0x28(%rax),%rax
  81c0ce:	8b 40 10             	mov    0x10(%rax),%eax
  81c0d1:	89 c2                	mov    %eax,%edx
  81c0d3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c0d7:	8b 40 30             	mov    0x30(%rax),%eax
  81c0da:	29 c2                	sub    %eax,%edx
  81c0dc:	89 d0                	mov    %edx,%eax
  81c0de:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  81c0e2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c0e6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c0ea:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81c0ee:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  if (available < len) {
  81c0f2:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  81c0f6:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  81c0fa:	73 08                	jae    81c104 <do_writemore+0xc5>
    /* don't try to write more than sendbuf */
    len = available;
  81c0fc:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  81c100:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  81c104:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c108:	48 8b 40 28          	mov    0x28(%rax),%rax
  81c10c:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  81c110:	0f b6 c8             	movzbl %al,%ecx
  81c113:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81c117:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c11b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c11f:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  81c123:	48 89 c7             	mov    %rax,%rdi
  81c126:	48 b8 84 31 81 00 00 	movabs $0x813184,%rax
  81c12d:	00 00 00 
  81c130:	ff d0                	callq  *%rax
  81c132:	88 45 ed             	mov    %al,-0x13(%rbp)
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  81c135:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c139:	8b 50 30             	mov    0x30(%rax),%edx
  81c13c:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81c140:	01 c2                	add    %eax,%edx
  81c142:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c146:	48 8b 40 28          	mov    0x28(%rax),%rax
  81c14a:	8b 40 10             	mov    0x10(%rax),%eax
  81c14d:	39 c2                	cmp    %eax,%edx
  81c14f:	7e 2a                	jle    81c17b <do_writemore+0x13c>
  81c151:	48 ba 60 3b 82 00 00 	movabs $0x823b60,%rdx
  81c158:	00 00 00 
  81c15b:	be ce 03 00 00       	mov    $0x3ce,%esi
  81c160:	48 bf 52 39 82 00 00 	movabs $0x823952,%rdi
  81c167:	00 00 00 
  81c16a:	b8 00 00 00 00       	mov    $0x0,%eax
  81c16f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81c176:	00 00 00 
  81c179:	ff d1                	callq  *%rcx
  if (err == ERR_OK) {
  81c17b:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81c17f:	0f 85 07 01 00 00    	jne    81c28c <do_writemore+0x24d>
    conn->write_offset += len;
  81c185:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c189:	8b 50 30             	mov    0x30(%rax),%edx
  81c18c:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81c190:	01 c2                	add    %eax,%edx
  81c192:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c196:	89 50 30             	mov    %edx,0x30(%rax)
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  81c199:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c19d:	8b 50 30             	mov    0x30(%rax),%edx
  81c1a0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c1a4:	48 8b 40 28          	mov    0x28(%rax),%rax
  81c1a8:	8b 40 10             	mov    0x10(%rax),%eax
  81c1ab:	39 c2                	cmp    %eax,%edx
  81c1ad:	75 1b                	jne    81c1ca <do_writemore+0x18b>
      /* everything was written */
      write_finished = 1;
  81c1af:	c6 45 fd 01          	movb   $0x1,-0x3(%rbp)
      conn->write_msg = NULL;
  81c1b3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c1b7:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  81c1be:	00 
      conn->write_offset = 0;
  81c1bf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c1c3:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  81c1ca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c1ce:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c1d2:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81c1d9:	48 85 c0             	test   %rax,%rax
  81c1dc:	74 41                	je     81c21f <do_writemore+0x1e0>
  81c1de:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c1e2:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c1e6:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81c1ea:	0f b6 c0             	movzbl %al,%eax
  81c1ed:	83 e0 40             	and    $0x40,%eax
  81c1f0:	85 c0                	test   %eax,%eax
  81c1f2:	75 2b                	jne    81c21f <do_writemore+0x1e0>
  81c1f4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c1f8:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c1fc:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81c203:	48 85 c0             	test   %rax,%rax
  81c206:	74 30                	je     81c238 <do_writemore+0x1f9>
  81c208:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c20c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c210:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81c217:	48 8b 00             	mov    (%rax),%rax
  81c21a:	48 85 c0             	test   %rax,%rax
  81c21d:	74 19                	je     81c238 <do_writemore+0x1f9>
  81c21f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c223:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c227:	48 89 c7             	mov    %rax,%rdi
  81c22a:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  81c231:	00 00 00 
  81c234:	ff d0                	callq  *%rax
  81c236:	eb 05                	jmp    81c23d <do_writemore+0x1fe>
  81c238:	b8 00 00 00 00       	mov    $0x0,%eax
  81c23d:	88 45 ed             	mov    %al,-0x13(%rbp)
    conn->err = err;
  81c240:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c244:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  81c248:	88 50 10             	mov    %dl,0x10(%rax)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  81c24b:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81c24f:	75 6c                	jne    81c2bd <do_writemore+0x27e>
  81c251:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c255:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c259:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81c25d:	66 3d a0 2d          	cmp    $0x2da0,%ax
  81c261:	77 5a                	ja     81c2bd <do_writemore+0x27e>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  81c263:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c267:	48 8b 40 38          	mov    0x38(%rax),%rax
  81c26b:	48 85 c0             	test   %rax,%rax
  81c26e:	74 4d                	je     81c2bd <do_writemore+0x27e>
  81c270:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c274:	48 8b 40 38          	mov    0x38(%rax),%rax
  81c278:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81c27c:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  81c280:	be 03 00 00 00       	mov    $0x3,%esi
  81c285:	48 89 cf             	mov    %rcx,%rdi
  81c288:	ff d0                	callq  *%rax
  81c28a:	eb 31                	jmp    81c2bd <do_writemore+0x27e>
    }
  } else if (err == ERR_MEM) {
  81c28c:	80 7d ed ff          	cmpb   $0xff,-0x13(%rbp)
  81c290:	75 1c                	jne    81c2ae <do_writemore+0x26f>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  81c292:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c296:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c29a:	48 89 c7             	mov    %rax,%rdi
  81c29d:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  81c2a4:	00 00 00 
  81c2a7:	ff d0                	callq  *%rax
  81c2a9:	88 45 ed             	mov    %al,-0x13(%rbp)
  81c2ac:	eb 0f                	jmp    81c2bd <do_writemore+0x27e>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  81c2ae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c2b2:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  81c2b6:	88 50 10             	mov    %dl,0x10(%rax)
    write_finished = 1;
  81c2b9:	c6 45 fd 01          	movb   $0x1,-0x3(%rbp)
  }

  if (write_finished) {
  81c2bd:	80 7d fd 00          	cmpb   $0x0,-0x3(%rbp)
  81c2c1:	74 20                	je     81c2e3 <do_writemore+0x2a4>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  81c2c3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c2c7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  81c2ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c2d2:	8b 40 14             	mov    0x14(%rax),%eax
  81c2d5:	89 c7                	mov    %eax,%edi
  81c2d7:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  81c2de:	00 00 00 
  81c2e1:	ff d0                	callq  *%rax
  }
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
  81c2e3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81c2e8:	c9                   	leaveq 
  81c2e9:	c3                   	retq   

000000000081c2ea <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  81c2ea:	55                   	push   %rbp
  81c2eb:	48 89 e5             	mov    %rsp,%rbp
  81c2ee:	48 83 ec 10          	sub    $0x10,%rsp
  81c2f2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81c2f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c2fa:	48 8b 00             	mov    (%rax),%rax
  81c2fd:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81c301:	3c fc                	cmp    $0xfc,%al
  81c303:	7c 6c                	jl     81c371 <do_write+0x87>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  81c305:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c309:	48 8b 00             	mov    (%rax),%rax
  81c30c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c310:	48 85 c0             	test   %rax,%rax
  81c313:	74 51                	je     81c366 <do_write+0x7c>
  81c315:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c319:	48 8b 00             	mov    (%rax),%rax
  81c31c:	8b 00                	mov    (%rax),%eax
  81c31e:	83 f8 10             	cmp    $0x10,%eax
  81c321:	75 43                	jne    81c366 <do_write+0x7c>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  81c323:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c327:	48 8b 00             	mov    (%rax),%rax
  81c32a:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  81c331:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c335:	48 8b 00             	mov    (%rax),%rax
  81c338:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c33c:	48 89 50 28          	mov    %rdx,0x28(%rax)
      msg->conn->write_offset = 0;
  81c340:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c344:	48 8b 00             	mov    (%rax),%rax
  81c347:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  81c34e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c352:	48 8b 00             	mov    (%rax),%rax
  81c355:	48 89 c7             	mov    %rax,%rdi
  81c358:	48 b8 3f c0 81 00 00 	movabs $0x81c03f,%rax
  81c35f:	00 00 00 
  81c362:	ff d0                	callq  *%rax
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  81c364:	eb 23                	jmp    81c389 <do_write+0x9f>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  81c366:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c36a:	48 8b 00             	mov    (%rax),%rax
  81c36d:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81c371:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c375:	48 8b 00             	mov    (%rax),%rax
  81c378:	8b 40 14             	mov    0x14(%rax),%eax
  81c37b:	89 c7                	mov    %eax,%edi
  81c37d:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  81c384:	00 00 00 
  81c387:	ff d0                	callq  *%rax
}
  81c389:	c9                   	leaveq 
  81c38a:	c3                   	retq   

000000000081c38b <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  81c38b:	55                   	push   %rbp
  81c38c:	48 89 e5             	mov    %rsp,%rbp
  81c38f:	48 83 ec 10          	sub    $0x10,%rsp
  81c393:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (msg->conn->pcb.ip != NULL) {
  81c397:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c39b:	48 8b 00             	mov    (%rax),%rax
  81c39e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c3a2:	48 85 c0             	test   %rax,%rax
  81c3a5:	0f 84 40 01 00 00    	je     81c4eb <do_getaddr+0x160>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  81c3ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c3af:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c3b3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c3b7:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  81c3bb:	84 d2                	test   %dl,%dl
  81c3bd:	74 11                	je     81c3d0 <do_getaddr+0x45>
  81c3bf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c3c3:	48 8b 12             	mov    (%rdx),%rdx
  81c3c6:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c3ca:	8b 12                	mov    (%rdx),%edx
  81c3cc:	89 10                	mov    %edx,(%rax)
  81c3ce:	eb 10                	jmp    81c3e0 <do_getaddr+0x55>
  81c3d0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c3d4:	48 8b 12             	mov    (%rdx),%rdx
  81c3d7:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c3db:	8b 52 04             	mov    0x4(%rdx),%edx
  81c3de:	89 10                	mov    %edx,(%rax)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81c3e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c3e4:	48 8b 00             	mov    (%rax),%rax
  81c3e7:	8b 00                	mov    (%rax),%eax
  81c3e9:	25 f0 00 00 00       	and    $0xf0,%eax
  81c3ee:	83 f8 20             	cmp    $0x20,%eax
  81c3f1:	74 51                	je     81c444 <do_getaddr+0xb9>
  81c3f3:	83 f8 40             	cmp    $0x40,%eax
  81c3f6:	74 0e                	je     81c406 <do_getaddr+0x7b>
  81c3f8:	83 f8 10             	cmp    $0x10,%eax
  81c3fb:	0f 84 b0 00 00 00    	je     81c4b1 <do_getaddr+0x126>
  81c401:	e9 f0 00 00 00       	jmpq   81c4f6 <do_getaddr+0x16b>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  81c406:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c40a:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81c40e:	84 c0                	test   %al,%al
  81c410:	74 22                	je     81c434 <do_getaddr+0xa9>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  81c412:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c416:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c41a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c41e:	48 8b 12             	mov    (%rdx),%rdx
  81c421:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c425:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  81c429:	0f b6 d2             	movzbl %dl,%edx
  81c42c:	66 89 10             	mov    %dx,(%rax)
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
      }
      break;
  81c42f:	e9 c2 00 00 00       	jmpq   81c4f6 <do_getaddr+0x16b>
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  81c434:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c438:	48 8b 00             	mov    (%rax),%rax
  81c43b:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
      }
      break;
  81c43f:	e9 b2 00 00 00       	jmpq   81c4f6 <do_getaddr+0x16b>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  81c444:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c448:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81c44c:	84 c0                	test   %al,%al
  81c44e:	74 1f                	je     81c46f <do_getaddr+0xe4>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  81c450:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c454:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c458:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c45c:	48 8b 12             	mov    (%rdx),%rdx
  81c45f:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c463:	0f b7 52 1a          	movzwl 0x1a(%rdx),%edx
  81c467:	66 89 10             	mov    %dx,(%rax)
          msg->conn->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
  81c46a:	e9 87 00 00 00       	jmpq   81c4f6 <do_getaddr+0x16b>
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  81c46f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c473:	48 8b 00             	mov    (%rax),%rax
  81c476:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c47a:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81c47e:	0f b6 c0             	movzbl %al,%eax
  81c481:	83 e0 04             	and    $0x4,%eax
  81c484:	85 c0                	test   %eax,%eax
  81c486:	75 0d                	jne    81c495 <do_getaddr+0x10a>
          msg->conn->err = ERR_CONN;
  81c488:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c48c:	48 8b 00             	mov    (%rax),%rax
  81c48f:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
  81c493:	eb 61                	jmp    81c4f6 <do_getaddr+0x16b>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
          msg->conn->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  81c495:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c499:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c49d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c4a1:	48 8b 12             	mov    (%rdx),%rdx
  81c4a4:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c4a8:	0f b7 52 1c          	movzwl 0x1c(%rdx),%edx
  81c4ac:	66 89 10             	mov    %dx,(%rax)
        }
      }
      break;
  81c4af:	eb 45                	jmp    81c4f6 <do_getaddr+0x16b>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  81c4b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c4b5:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81c4b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c4bd:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81c4c1:	84 c0                	test   %al,%al
  81c4c3:	74 11                	je     81c4d6 <do_getaddr+0x14b>
  81c4c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c4c9:	48 8b 00             	mov    (%rax),%rax
  81c4cc:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c4d0:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  81c4d4:	eb 0f                	jmp    81c4e5 <do_getaddr+0x15a>
  81c4d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c4da:	48 8b 00             	mov    (%rax),%rax
  81c4dd:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c4e1:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  81c4e5:	66 89 02             	mov    %ax,(%rdx)
      break;
  81c4e8:	90                   	nop
  81c4e9:	eb 0b                	jmp    81c4f6 <do_getaddr+0x16b>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  81c4eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c4ef:	48 8b 00             	mov    (%rax),%rax
  81c4f2:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
  }
  TCPIP_APIMSG_ACK(msg);
  81c4f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c4fa:	48 8b 00             	mov    (%rax),%rax
  81c4fd:	8b 40 14             	mov    0x14(%rax),%eax
  81c500:	89 c7                	mov    %eax,%edi
  81c502:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  81c509:	00 00 00 
  81c50c:	ff d0                	callq  *%rax
}
  81c50e:	90                   	nop
  81c50f:	c9                   	leaveq 
  81c510:	c3                   	retq   

000000000081c511 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  81c511:	55                   	push   %rbp
  81c512:	48 89 e5             	mov    %rsp,%rbp
  81c515:	48 83 ec 10          	sub    $0x10,%rsp
  81c519:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  81c51d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c521:	48 8b 00             	mov    (%rax),%rax
  81c524:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c528:	48 85 c0             	test   %rax,%rax
  81c52b:	74 34                	je     81c561 <do_close+0x50>
  81c52d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c531:	48 8b 00             	mov    (%rax),%rax
  81c534:	8b 00                	mov    (%rax),%eax
  81c536:	83 f8 10             	cmp    $0x10,%eax
  81c539:	75 26                	jne    81c561 <do_close+0x50>
      msg->conn->state = NETCONN_CLOSE;
  81c53b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c53f:	48 8b 00             	mov    (%rax),%rax
  81c542:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%rax)
      do_close_internal(msg->conn);
  81c549:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c54d:	48 8b 00             	mov    (%rax),%rax
  81c550:	48 89 c7             	mov    %rax,%rdi
  81c553:	48 b8 b1 b4 81 00 00 	movabs $0x81b4b1,%rax
  81c55a:	00 00 00 
  81c55d:	ff d0                	callq  *%rax
  81c55f:	eb 23                	jmp    81c584 <do_close+0x73>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  81c561:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c565:	48 8b 00             	mov    (%rax),%rax
  81c568:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
    TCPIP_APIMSG_ACK(msg);
  81c56c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c570:	48 8b 00             	mov    (%rax),%rax
  81c573:	8b 40 14             	mov    0x14(%rax),%eax
  81c576:	89 c7                	mov    %eax,%edi
  81c578:	48 b8 61 81 81 00 00 	movabs $0x818161,%rax
  81c57f:	00 00 00 
  81c582:	ff d0                	callq  *%rax
  }
}
  81c584:	90                   	nop
  81c585:	c9                   	leaveq 
  81c586:	c3                   	retq   

000000000081c587 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  81c587:	55                   	push   %rbp
  81c588:	48 89 e5             	mov    %rsp,%rbp
  81c58b:	53                   	push   %rbx
  81c58c:	48 83 ec 38          	sub    $0x38,%rsp
  81c590:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81c594:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  81c598:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c59c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81c5a0:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c5a7:	00 00 00 
  81c5aa:	48 89 10             	mov    %rdx,(%rax)
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  81c5ad:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c5b1:	48 8b 58 08          	mov    0x8(%rax),%rbx
  81c5b5:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c5bc:	00 00 00 
  81c5bf:	48 8b 00             	mov    (%rax),%rax
  81c5c2:	0f b7 00             	movzwl (%rax),%eax
  81c5c5:	0f b7 c0             	movzwl %ax,%eax
  81c5c8:	89 c7                	mov    %eax,%edi
  81c5ca:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81c5d1:	00 00 00 
  81c5d4:	ff d0                	callq  *%rax
  81c5d6:	66 c1 e8 08          	shr    $0x8,%ax
  81c5da:	0f b7 c0             	movzwl %ax,%eax
  81c5dd:	83 e0 0f             	and    $0xf,%eax
  81c5e0:	c1 e0 02             	shl    $0x2,%eax
  81c5e3:	48 98                	cltq   
  81c5e5:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  81c5e9:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c5f0:	00 00 00 
  81c5f3:	48 89 10             	mov    %rdx,(%rax)
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  81c5f6:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c5fd:	00 00 00 
  81c600:	48 8b 00             	mov    (%rax),%rax
  81c603:	0f b7 00             	movzwl (%rax),%eax
  81c606:	0f b7 c0             	movzwl %ax,%eax
  81c609:	89 c7                	mov    %eax,%edi
  81c60b:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81c612:	00 00 00 
  81c615:	ff d0                	callq  *%rax
  81c617:	66 c1 e8 08          	shr    $0x8,%ax
  81c61b:	83 e0 0f             	and    $0xf,%eax
  81c61e:	c1 e0 02             	shl    $0x2,%eax
  81c621:	f7 d8                	neg    %eax
  81c623:	0f bf d0             	movswl %ax,%edx
  81c626:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c62a:	89 d6                	mov    %edx,%esi
  81c62c:	48 89 c7             	mov    %rax,%rdi
  81c62f:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  81c636:	00 00 00 
  81c639:	ff d0                	callq  *%rax
  81c63b:	84 c0                	test   %al,%al
  81c63d:	75 0e                	jne    81c64d <tcp_input+0xc6>
  81c63f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c643:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81c647:	66 83 f8 13          	cmp    $0x13,%ax
  81c64b:	77 18                	ja     81c665 <tcp_input+0xde>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c64d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c651:	48 89 c7             	mov    %rax,%rdi
  81c654:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81c65b:	00 00 00 
  81c65e:	ff d0                	callq  *%rax
    return;
  81c660:	e9 ec 0b 00 00       	jmpq   81d251 <tcp_input+0xcca>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  81c665:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c66c:	00 00 00 
  81c66f:	48 8b 00             	mov    (%rax),%rax
  81c672:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81c676:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81c67a:	48 89 c6             	mov    %rax,%rsi
  81c67d:	48 89 d7             	mov    %rdx,%rdi
  81c680:	48 b8 70 0d 81 00 00 	movabs $0x810d70,%rax
  81c687:	00 00 00 
  81c68a:	ff d0                	callq  *%rax
  81c68c:	84 c0                	test   %al,%al
  81c68e:	75 38                	jne    81c6c8 <tcp_input+0x141>
      ip_addr_ismulticast(&(iphdr->dest))) {
  81c690:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c697:	00 00 00 
  81c69a:	48 8b 00             	mov    (%rax),%rax
  81c69d:	8b 58 10             	mov    0x10(%rax),%ebx
  81c6a0:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  81c6a5:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  81c6ac:	00 00 00 
  81c6af:	ff d0                	callq  *%rax
  81c6b1:	21 c3                	and    %eax,%ebx
  81c6b3:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81c6b8:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  81c6bf:	00 00 00 
  81c6c2:	ff d0                	callq  *%rax
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  81c6c4:	39 c3                	cmp    %eax,%ebx
  81c6c6:	75 18                	jne    81c6e0 <tcp_input+0x159>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c6c8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c6cc:	48 89 c7             	mov    %rax,%rdi
  81c6cf:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81c6d6:	00 00 00 
  81c6d9:	ff d0                	callq  *%rax
    return;
  81c6db:	e9 71 0b 00 00       	jmpq   81d251 <tcp_input+0xcca>

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len) != 0) {
  81c6e0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c6e4:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81c6e8:	0f b7 c8             	movzwl %ax,%ecx
      (struct ip_addr *)&(iphdr->dest),
  81c6eb:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c6f2:	00 00 00 
  81c6f5:	48 8b 00             	mov    (%rax),%rax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81c6f8:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81c6fc:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c703:	00 00 00 
  81c706:	48 8b 00             	mov    (%rax),%rax
  81c709:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  81c70d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c711:	41 89 c8             	mov    %ecx,%r8d
  81c714:	b9 06 00 00 00       	mov    $0x6,%ecx
  81c719:	48 89 c7             	mov    %rax,%rdi
  81c71c:	48 b8 18 28 81 00 00 	movabs $0x812818,%rax
  81c723:	00 00 00 
  81c726:	ff d0                	callq  *%rax
  81c728:	66 85 c0             	test   %ax,%ax
  81c72b:	74 18                	je     81c745 <tcp_input+0x1be>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c72d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c731:	48 89 c7             	mov    %rax,%rdi
  81c734:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81c73b:	00 00 00 
  81c73e:	ff d0                	callq  *%rax
    return;
  81c740:	e9 0c 0b 00 00       	jmpq   81d251 <tcp_input+0xcca>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  81c745:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c74c:	00 00 00 
  81c74f:	48 8b 00             	mov    (%rax),%rax
  81c752:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81c756:	0f b7 c0             	movzwl %ax,%eax
  81c759:	89 c7                	mov    %eax,%edi
  81c75b:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81c762:	00 00 00 
  81c765:	ff d0                	callq  *%rax
  81c767:	66 c1 e8 0c          	shr    $0xc,%ax
  81c76b:	88 45 d6             	mov    %al,-0x2a(%rbp)
  if(pbuf_header(p, -(hdrlen * 4))){
  81c76e:	0f b6 55 d6          	movzbl -0x2a(%rbp),%edx
  81c772:	b8 00 00 00 00       	mov    $0x0,%eax
  81c777:	29 d0                	sub    %edx,%eax
  81c779:	c1 e0 02             	shl    $0x2,%eax
  81c77c:	0f bf d0             	movswl %ax,%edx
  81c77f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c783:	89 d6                	mov    %edx,%esi
  81c785:	48 89 c7             	mov    %rax,%rdi
  81c788:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  81c78f:	00 00 00 
  81c792:	ff d0                	callq  *%rax
  81c794:	84 c0                	test   %al,%al
  81c796:	74 18                	je     81c7b0 <tcp_input+0x229>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c798:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c79c:	48 89 c7             	mov    %rax,%rdi
  81c79f:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81c7a6:	00 00 00 
  81c7a9:	ff d0                	callq  *%rax
    return;
  81c7ab:	e9 a1 0a 00 00       	jmpq   81d251 <tcp_input+0xcca>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  81c7b0:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c7b7:	00 00 00 
  81c7ba:	48 8b 18             	mov    (%rax),%rbx
  81c7bd:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c7c4:	00 00 00 
  81c7c7:	48 8b 00             	mov    (%rax),%rax
  81c7ca:	0f b7 00             	movzwl (%rax),%eax
  81c7cd:	0f b7 c0             	movzwl %ax,%eax
  81c7d0:	89 c7                	mov    %eax,%edi
  81c7d2:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81c7d9:	00 00 00 
  81c7dc:	ff d0                	callq  *%rax
  81c7de:	66 89 03             	mov    %ax,(%rbx)
  tcphdr->dest = ntohs(tcphdr->dest);
  81c7e1:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c7e8:	00 00 00 
  81c7eb:	48 8b 18             	mov    (%rax),%rbx
  81c7ee:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c7f5:	00 00 00 
  81c7f8:	48 8b 00             	mov    (%rax),%rax
  81c7fb:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  81c7ff:	0f b7 c0             	movzwl %ax,%eax
  81c802:	89 c7                	mov    %eax,%edi
  81c804:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81c80b:	00 00 00 
  81c80e:	ff d0                	callq  *%rax
  81c810:	66 89 43 02          	mov    %ax,0x2(%rbx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  81c814:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c81b:	00 00 00 
  81c81e:	48 8b 18             	mov    (%rax),%rbx
  81c821:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c828:	00 00 00 
  81c82b:	48 8b 00             	mov    (%rax),%rax
  81c82e:	8b 40 04             	mov    0x4(%rax),%eax
  81c831:	89 c7                	mov    %eax,%edi
  81c833:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  81c83a:	00 00 00 
  81c83d:	ff d0                	callq  *%rax
  81c83f:	89 43 04             	mov    %eax,0x4(%rbx)
  81c842:	8b 53 04             	mov    0x4(%rbx),%edx
  81c845:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81c84c:	00 00 00 
  81c84f:	89 10                	mov    %edx,(%rax)
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  81c851:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c858:	00 00 00 
  81c85b:	48 8b 18             	mov    (%rax),%rbx
  81c85e:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c865:	00 00 00 
  81c868:	48 8b 00             	mov    (%rax),%rax
  81c86b:	8b 40 08             	mov    0x8(%rax),%eax
  81c86e:	89 c7                	mov    %eax,%edi
  81c870:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  81c877:	00 00 00 
  81c87a:	ff d0                	callq  *%rax
  81c87c:	89 43 08             	mov    %eax,0x8(%rbx)
  81c87f:	8b 53 08             	mov    0x8(%rbx),%edx
  81c882:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81c889:	00 00 00 
  81c88c:	89 10                	mov    %edx,(%rax)
  tcphdr->wnd = ntohs(tcphdr->wnd);
  81c88e:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c895:	00 00 00 
  81c898:	48 8b 18             	mov    (%rax),%rbx
  81c89b:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c8a2:	00 00 00 
  81c8a5:	48 8b 00             	mov    (%rax),%rax
  81c8a8:	0f b7 40 0e          	movzwl 0xe(%rax),%eax
  81c8ac:	0f b7 c0             	movzwl %ax,%eax
  81c8af:	89 c7                	mov    %eax,%edi
  81c8b1:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81c8b8:	00 00 00 
  81c8bb:	ff d0                	callq  *%rax
  81c8bd:	66 89 43 0e          	mov    %ax,0xe(%rbx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  81c8c1:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c8c8:	00 00 00 
  81c8cb:	48 8b 00             	mov    (%rax),%rax
  81c8ce:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81c8d2:	0f b7 c0             	movzwl %ax,%eax
  81c8d5:	89 c7                	mov    %eax,%edi
  81c8d7:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81c8de:	00 00 00 
  81c8e1:	ff d0                	callq  *%rax
  81c8e3:	83 e0 3f             	and    $0x3f,%eax
  81c8e6:	89 c2                	mov    %eax,%edx
  81c8e8:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81c8ef:	00 00 00 
  81c8f2:	88 10                	mov    %dl,(%rax)
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  81c8f4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c8f8:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81c8fc:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81c903:	00 00 00 
  81c906:	0f b6 00             	movzbl (%rax),%eax
  81c909:	0f b6 c0             	movzbl %al,%eax
  81c90c:	83 e0 01             	and    $0x1,%eax
  81c90f:	85 c0                	test   %eax,%eax
  81c911:	75 17                	jne    81c92a <tcp_input+0x3a3>
  81c913:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81c91a:	00 00 00 
  81c91d:	0f b6 00             	movzbl (%rax),%eax
  81c920:	0f b6 c0             	movzbl %al,%eax
  81c923:	83 e0 02             	and    $0x2,%eax
  81c926:	85 c0                	test   %eax,%eax
  81c928:	74 07                	je     81c931 <tcp_input+0x3aa>
  81c92a:	b8 01 00 00 00       	mov    $0x1,%eax
  81c92f:	eb 05                	jmp    81c936 <tcp_input+0x3af>
  81c931:	b8 00 00 00 00       	mov    $0x0,%eax
  81c936:	01 c2                	add    %eax,%edx
  81c938:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81c93f:	00 00 00 
  81c942:	66 89 10             	mov    %dx,(%rax)

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  81c945:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81c94c:	00 

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81c94d:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81c954:	00 00 00 
  81c957:	48 8b 00             	mov    (%rax),%rax
  81c95a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c95e:	e9 e2 01 00 00       	jmpq   81cb45 <tcp_input+0x5be>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  81c963:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c967:	8b 40 18             	mov    0x18(%rax),%eax
  81c96a:	85 c0                	test   %eax,%eax
  81c96c:	75 2a                	jne    81c998 <tcp_input+0x411>
  81c96e:	48 ba 80 3b 82 00 00 	movabs $0x823b80,%rdx
  81c975:	00 00 00 
  81c978:	be b6 00 00 00       	mov    $0xb6,%esi
  81c97d:	48 bf a7 3b 82 00 00 	movabs $0x823ba7,%rdi
  81c984:	00 00 00 
  81c987:	b8 00 00 00 00       	mov    $0x0,%eax
  81c98c:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81c993:	00 00 00 
  81c996:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  81c998:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c99c:	8b 40 18             	mov    0x18(%rax),%eax
  81c99f:	83 f8 0a             	cmp    $0xa,%eax
  81c9a2:	75 2a                	jne    81c9ce <tcp_input+0x447>
  81c9a4:	48 ba c0 3b 82 00 00 	movabs $0x823bc0,%rdx
  81c9ab:	00 00 00 
  81c9ae:	be b7 00 00 00       	mov    $0xb7,%esi
  81c9b3:	48 bf a7 3b 82 00 00 	movabs $0x823ba7,%rdi
  81c9ba:	00 00 00 
  81c9bd:	b8 00 00 00 00       	mov    $0x0,%eax
  81c9c2:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81c9c9:	00 00 00 
  81c9cc:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  81c9ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c9d2:	8b 40 18             	mov    0x18(%rax),%eax
  81c9d5:	83 f8 01             	cmp    $0x1,%eax
  81c9d8:	75 2a                	jne    81ca04 <tcp_input+0x47d>
  81c9da:	48 ba f0 3b 82 00 00 	movabs $0x823bf0,%rdx
  81c9e1:	00 00 00 
  81c9e4:	be b8 00 00 00       	mov    $0xb8,%esi
  81c9e9:	48 bf a7 3b 82 00 00 	movabs $0x823ba7,%rdi
  81c9f0:	00 00 00 
  81c9f3:	b8 00 00 00 00       	mov    $0x0,%eax
  81c9f8:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81c9ff:	00 00 00 
  81ca02:	ff d1                	callq  *%rcx
    if (pcb->remote_port == tcphdr->src &&
  81ca04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca08:	0f b7 50 2a          	movzwl 0x2a(%rax),%edx
  81ca0c:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81ca13:	00 00 00 
  81ca16:	48 8b 00             	mov    (%rax),%rax
  81ca19:	0f b7 00             	movzwl (%rax),%eax
  81ca1c:	66 39 c2             	cmp    %ax,%dx
  81ca1f:	0f 85 0c 01 00 00    	jne    81cb31 <tcp_input+0x5aa>
       pcb->local_port == tcphdr->dest &&
  81ca25:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca29:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81ca2d:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81ca34:	00 00 00 
  81ca37:	48 8b 00             	mov    (%rax),%rax
  81ca3a:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  81ca3e:	66 39 c2             	cmp    %ax,%dx
  81ca41:	0f 85 ea 00 00 00    	jne    81cb31 <tcp_input+0x5aa>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81ca47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca4b:	8b 50 04             	mov    0x4(%rax),%edx
  81ca4e:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81ca55:	00 00 00 
  81ca58:	48 8b 00             	mov    (%rax),%rax
  81ca5b:	8b 40 0c             	mov    0xc(%rax),%eax
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
  81ca5e:	39 c2                	cmp    %eax,%edx
  81ca60:	0f 85 cb 00 00 00    	jne    81cb31 <tcp_input+0x5aa>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  81ca66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca6a:	8b 10                	mov    (%rax),%edx
  81ca6c:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81ca73:	00 00 00 
  81ca76:	48 8b 00             	mov    (%rax),%rax
  81ca79:	8b 40 10             	mov    0x10(%rax),%eax
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81ca7c:	39 c2                	cmp    %eax,%edx
  81ca7e:	0f 85 ad 00 00 00    	jne    81cb31 <tcp_input+0x5aa>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  81ca84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca88:	48 8b 40 10          	mov    0x10(%rax),%rax
  81ca8c:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81ca90:	75 2a                	jne    81cabc <tcp_input+0x535>
  81ca92:	48 ba 18 3c 82 00 00 	movabs $0x823c18,%rdx
  81ca99:	00 00 00 
  81ca9c:	be c1 00 00 00       	mov    $0xc1,%esi
  81caa1:	48 bf a7 3b 82 00 00 	movabs $0x823ba7,%rdi
  81caa8:	00 00 00 
  81caab:	b8 00 00 00 00       	mov    $0x0,%eax
  81cab0:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81cab7:	00 00 00 
  81caba:	ff d1                	callq  *%rcx
      if (prev != NULL) {
  81cabc:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81cac1:	74 36                	je     81caf9 <tcp_input+0x572>
        prev->next = pcb->next;
  81cac3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cac7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81cacb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81cacf:	48 89 50 10          	mov    %rdx,0x10(%rax)
        pcb->next = tcp_active_pcbs;
  81cad3:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81cada:	00 00 00 
  81cadd:	48 8b 10             	mov    (%rax),%rdx
  81cae0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cae4:	48 89 50 10          	mov    %rdx,0x10(%rax)
        tcp_active_pcbs = pcb;
  81cae8:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81caef:	00 00 00 
  81caf2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81caf6:	48 89 10             	mov    %rdx,(%rax)
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  81caf9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cafd:	48 8b 40 10          	mov    0x10(%rax),%rax
  81cb01:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81cb05:	75 4b                	jne    81cb52 <tcp_input+0x5cb>
  81cb07:	48 ba 48 3c 82 00 00 	movabs $0x823c48,%rdx
  81cb0e:	00 00 00 
  81cb11:	be c7 00 00 00       	mov    $0xc7,%esi
  81cb16:	48 bf a7 3b 82 00 00 	movabs $0x823ba7,%rdi
  81cb1d:	00 00 00 
  81cb20:	b8 00 00 00 00       	mov    $0x0,%eax
  81cb25:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81cb2c:	00 00 00 
  81cb2f:	ff d1                	callq  *%rcx
      break;
    }
    prev = pcb;
  81cb31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb35:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81cb39:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb3d:	48 8b 40 10          	mov    0x10(%rax),%rax
  81cb41:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81cb45:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81cb4a:	0f 85 13 fe ff ff    	jne    81c963 <tcp_input+0x3dc>
  81cb50:	eb 01                	jmp    81cb53 <tcp_input+0x5cc>
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
  81cb52:	90                   	nop
    }
    prev = pcb;
  }

  if (pcb == NULL) {
  81cb53:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81cb58:	0f 85 f2 01 00 00    	jne    81cd50 <tcp_input+0x7c9>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  81cb5e:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81cb65:	00 00 00 
  81cb68:	48 8b 00             	mov    (%rax),%rax
  81cb6b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81cb6f:	e9 dd 00 00 00       	jmpq   81cc51 <tcp_input+0x6ca>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  81cb74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb78:	8b 40 18             	mov    0x18(%rax),%eax
  81cb7b:	83 f8 0a             	cmp    $0xa,%eax
  81cb7e:	74 2a                	je     81cbaa <tcp_input+0x623>
  81cb80:	48 ba 78 3c 82 00 00 	movabs $0x823c78,%rdx
  81cb87:	00 00 00 
  81cb8a:	be d1 00 00 00       	mov    $0xd1,%esi
  81cb8f:	48 bf a7 3b 82 00 00 	movabs $0x823ba7,%rdi
  81cb96:	00 00 00 
  81cb99:	b8 00 00 00 00       	mov    $0x0,%eax
  81cb9e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81cba5:	00 00 00 
  81cba8:	ff d1                	callq  *%rcx
      if (pcb->remote_port == tcphdr->src &&
  81cbaa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cbae:	0f b7 50 2a          	movzwl 0x2a(%rax),%edx
  81cbb2:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cbb9:	00 00 00 
  81cbbc:	48 8b 00             	mov    (%rax),%rax
  81cbbf:	0f b7 00             	movzwl (%rax),%eax
  81cbc2:	66 39 c2             	cmp    %ax,%dx
  81cbc5:	75 7e                	jne    81cc45 <tcp_input+0x6be>
         pcb->local_port == tcphdr->dest &&
  81cbc7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cbcb:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81cbcf:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cbd6:	00 00 00 
  81cbd9:	48 8b 00             	mov    (%rax),%rax
  81cbdc:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
  81cbe0:	66 39 c2             	cmp    %ax,%dx
  81cbe3:	75 60                	jne    81cc45 <tcp_input+0x6be>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81cbe5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cbe9:	8b 50 04             	mov    0x4(%rax),%edx
  81cbec:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cbf3:	00 00 00 
  81cbf6:	48 8b 00             	mov    (%rax),%rax
  81cbf9:	8b 40 0c             	mov    0xc(%rax),%eax
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
  81cbfc:	39 c2                	cmp    %eax,%edx
  81cbfe:	75 45                	jne    81cc45 <tcp_input+0x6be>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  81cc00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc04:	8b 10                	mov    (%rax),%edx
  81cc06:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cc0d:	00 00 00 
  81cc10:	48 8b 00             	mov    (%rax),%rax
  81cc13:	8b 40 10             	mov    0x10(%rax),%eax
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81cc16:	39 c2                	cmp    %eax,%edx
  81cc18:	75 2b                	jne    81cc45 <tcp_input+0x6be>
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
  81cc1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc1e:	48 89 c7             	mov    %rax,%rdi
  81cc21:	48 b8 5c d5 81 00 00 	movabs $0x81d55c,%rax
  81cc28:	00 00 00 
  81cc2b:	ff d0                	callq  *%rax
        pbuf_free(p);
  81cc2d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81cc31:	48 89 c7             	mov    %rax,%rdi
  81cc34:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81cc3b:	00 00 00 
  81cc3e:	ff d0                	callq  *%rax
        return;
  81cc40:	e9 0c 06 00 00       	jmpq   81d251 <tcp_input+0xcca>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  81cc45:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc49:	48 8b 40 10          	mov    0x10(%rax),%rax
  81cc4d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81cc51:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81cc56:	0f 85 18 ff ff ff    	jne    81cb74 <tcp_input+0x5ed>
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  81cc5c:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81cc63:	00 
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  81cc64:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81cc6b:	00 00 00 
  81cc6e:	48 8b 00             	mov    (%rax),%rax
  81cc71:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81cc75:	e9 cb 00 00 00       	jmpq   81cd45 <tcp_input+0x7be>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  81cc7a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cc7e:	48 85 c0             	test   %rax,%rax
  81cc81:	74 28                	je     81ccab <tcp_input+0x724>
  81cc83:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cc87:	8b 00                	mov    (%rax),%eax
  81cc89:	85 c0                	test   %eax,%eax
  81cc8b:	74 1e                	je     81ccab <tcp_input+0x724>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  81cc8d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cc91:	8b 10                	mov    (%rax),%edx
  81cc93:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cc9a:	00 00 00 
  81cc9d:	48 8b 00             	mov    (%rax),%rax
  81cca0:	8b 40 10             	mov    0x10(%rax),%eax

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  81cca3:	39 c2                	cmp    %eax,%edx
  81cca5:	0f 85 86 00 00 00    	jne    81cd31 <tcp_input+0x7aa>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
        lpcb->local_port == tcphdr->dest) {
  81ccab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ccaf:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81ccb3:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81ccba:	00 00 00 
  81ccbd:	48 8b 00             	mov    (%rax),%rax
  81ccc0:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  81ccc4:	66 39 c2             	cmp    %ax,%dx
  81ccc7:	75 68                	jne    81cd31 <tcp_input+0x7aa>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  81ccc9:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81ccce:	74 36                	je     81cd06 <tcp_input+0x77f>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  81ccd0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ccd4:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81ccd8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81ccdc:	48 89 50 10          	mov    %rdx,0x10(%rax)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  81cce0:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81cce7:	00 00 00 
  81ccea:	48 8b 10             	mov    (%rax),%rdx
  81cced:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ccf1:	48 89 50 10          	mov    %rdx,0x10(%rax)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  81ccf5:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81ccfc:	00 00 00 
  81ccff:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81cd03:	48 89 10             	mov    %rdx,(%rax)
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
  81cd06:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cd0a:	48 89 c7             	mov    %rax,%rdi
  81cd0d:	48 b8 58 d2 81 00 00 	movabs $0x81d258,%rax
  81cd14:	00 00 00 
  81cd17:	ff d0                	callq  *%rax
        pbuf_free(p);
  81cd19:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81cd1d:	48 89 c7             	mov    %rax,%rdi
  81cd20:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81cd27:	00 00 00 
  81cd2a:	ff d0                	callq  *%rax
        return;
  81cd2c:	e9 20 05 00 00       	jmpq   81d251 <tcp_input+0xcca>
      }
      prev = (struct tcp_pcb *)lpcb;
  81cd31:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cd35:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  81cd39:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cd3d:	48 8b 40 10          	mov    0x10(%rax),%rax
  81cd41:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81cd45:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81cd4a:	0f 85 2a ff ff ff    	jne    81cc7a <tcp_input+0x6f3>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  81cd50:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81cd55:	0f 84 2b 04 00 00    	je     81d186 <tcp_input+0xbff>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  81cd5b:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cd62:	00 00 00 
  81cd65:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    inseg.len = p->tot_len;
  81cd6c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81cd70:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81cd74:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cd7b:	00 00 00 
  81cd7e:	66 89 50 18          	mov    %dx,0x18(%rax)
    inseg.dataptr = p->payload;
  81cd82:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81cd86:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81cd8a:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cd91:	00 00 00 
  81cd94:	48 89 50 10          	mov    %rdx,0x10(%rax)
    inseg.p = p;
  81cd98:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cd9f:	00 00 00 
  81cda2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81cda6:	48 89 50 08          	mov    %rdx,0x8(%rax)
    inseg.tcphdr = tcphdr;
  81cdaa:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cdb1:	00 00 00 
  81cdb4:	48 8b 10             	mov    (%rax),%rdx
  81cdb7:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cdbe:	00 00 00 
  81cdc1:	48 89 50 20          	mov    %rdx,0x20(%rax)

    recv_data = NULL;
  81cdc5:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81cdcc:	00 00 00 
  81cdcf:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    recv_flags = 0;
  81cdd6:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81cddd:	00 00 00 
  81cde0:	c6 00 00             	movb   $0x0,(%rax)

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  81cde3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cde7:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81cdee:	48 85 c0             	test   %rax,%rax
  81cdf1:	0f 84 9b 00 00 00    	je     81ce92 <tcp_input+0x90b>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  81cdf7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cdfb:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81ce02:	48 85 c0             	test   %rax,%rax
  81ce05:	74 2e                	je     81ce35 <tcp_input+0x8ae>
  81ce07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce0b:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81ce12:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81ce16:	48 8b 92 98 00 00 00 	mov    0x98(%rdx),%rdx
  81ce1d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81ce21:	48 8b 79 20          	mov    0x20(%rcx),%rdi
  81ce25:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81ce29:	b9 00 00 00 00       	mov    $0x0,%ecx
  81ce2e:	ff d0                	callq  *%rax
  81ce30:	88 45 d7             	mov    %al,-0x29(%rbp)
  81ce33:	eb 2e                	jmp    81ce63 <tcp_input+0x8dc>
  81ce35:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
  81ce39:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce3d:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81ce44:	48 85 c0             	test   %rax,%rax
  81ce47:	74 1a                	je     81ce63 <tcp_input+0x8dc>
  81ce49:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce4d:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81ce54:	48 89 c7             	mov    %rax,%rdi
  81ce57:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81ce5e:	00 00 00 
  81ce61:	ff d0                	callq  *%rax
      if (err == ERR_OK) {
  81ce63:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81ce67:	75 11                	jne    81ce7a <tcp_input+0x8f3>
        pcb->refused_data = NULL;
  81ce69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce6d:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  81ce74:	00 00 00 00 
  81ce78:	eb 18                	jmp    81ce92 <tcp_input+0x90b>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  81ce7a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ce7e:	48 89 c7             	mov    %rax,%rdi
  81ce81:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81ce88:	00 00 00 
  81ce8b:	ff d0                	callq  *%rax
        return;
  81ce8d:	e9 bf 03 00 00       	jmpq   81d251 <tcp_input+0xcca>
      }
    }

    tcp_input_pcb = pcb;
  81ce92:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  81ce99:	00 00 00 
  81ce9c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81cea0:	48 89 10             	mov    %rdx,(%rax)
    err = tcp_process(pcb);
  81cea3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cea7:	48 89 c7             	mov    %rax,%rdi
  81ceaa:	48 b8 08 d6 81 00 00 	movabs $0x81d608,%rax
  81ceb1:	00 00 00 
  81ceb4:	ff d0                	callq  *%rax
  81ceb6:	88 45 d7             	mov    %al,-0x29(%rbp)
    tcp_input_pcb = NULL;
  81ceb9:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  81cec0:	00 00 00 
  81cec3:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
  81ceca:	80 7d d7 fb          	cmpb   $0xfb,-0x29(%rbp)
  81cece:	0f 84 67 02 00 00    	je     81d13b <tcp_input+0xbb4>
      if (recv_flags & TF_RESET) {
  81ced4:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81cedb:	00 00 00 
  81cede:	0f b6 00             	movzbl (%rax),%eax
  81cee1:	0f b6 c0             	movzbl %al,%eax
  81cee4:	83 e0 08             	and    $0x8,%eax
  81cee7:	85 c0                	test   %eax,%eax
  81cee9:	74 67                	je     81cf52 <tcp_input+0x9cb>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  81ceeb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ceef:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  81cef6:	48 85 c0             	test   %rax,%rax
  81cef9:	74 1d                	je     81cf18 <tcp_input+0x991>
  81cefb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ceff:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  81cf06:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81cf0a:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  81cf0e:	be fa ff ff ff       	mov    $0xfffffffa,%esi
  81cf13:	48 89 d7             	mov    %rdx,%rdi
  81cf16:	ff d0                	callq  *%rax
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81cf18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cf1c:	48 89 c6             	mov    %rax,%rsi
  81cf1f:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  81cf26:	00 00 00 
  81cf29:	48 b8 d7 0a 81 00 00 	movabs $0x810ad7,%rax
  81cf30:	00 00 00 
  81cf33:	ff d0                	callq  *%rax
        memp_free(MEMP_TCP_PCB, pcb);
  81cf35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cf39:	48 89 c6             	mov    %rax,%rsi
  81cf3c:	bf 02 00 00 00       	mov    $0x2,%edi
  81cf41:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  81cf48:	00 00 00 
  81cf4b:	ff d0                	callq  *%rax
  81cf4d:	e9 e9 01 00 00       	jmpq   81d13b <tcp_input+0xbb4>
      } else if (recv_flags & TF_CLOSED) {
  81cf52:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81cf59:	00 00 00 
  81cf5c:	0f b6 00             	movzbl (%rax),%eax
  81cf5f:	0f b6 c0             	movzbl %al,%eax
  81cf62:	83 e0 10             	and    $0x10,%eax
  81cf65:	85 c0                	test   %eax,%eax
  81cf67:	74 3a                	je     81cfa3 <tcp_input+0xa1c>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81cf69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cf6d:	48 89 c6             	mov    %rax,%rsi
  81cf70:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  81cf77:	00 00 00 
  81cf7a:	48 b8 d7 0a 81 00 00 	movabs $0x810ad7,%rax
  81cf81:	00 00 00 
  81cf84:	ff d0                	callq  *%rax
        memp_free(MEMP_TCP_PCB, pcb);
  81cf86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cf8a:	48 89 c6             	mov    %rax,%rsi
  81cf8d:	bf 02 00 00 00       	mov    $0x2,%edi
  81cf92:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  81cf99:	00 00 00 
  81cf9c:	ff d0                	callq  *%rax
  81cf9e:	e9 98 01 00 00       	jmpq   81d13b <tcp_input+0xbb4>
      } else {
        err = ERR_OK;
  81cfa3:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  81cfa7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cfab:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  81cfaf:	66 85 c0             	test   %ax,%ax
  81cfb2:	74 3a                	je     81cfee <tcp_input+0xa67>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  81cfb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cfb8:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  81cfbf:	48 85 c0             	test   %rax,%rax
  81cfc2:	74 2a                	je     81cfee <tcp_input+0xa67>
  81cfc4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cfc8:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  81cfcf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81cfd3:	0f b7 52 78          	movzwl 0x78(%rdx),%edx
  81cfd7:	0f b7 d2             	movzwl %dx,%edx
  81cfda:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81cfde:	48 8b 49 20          	mov    0x20(%rcx),%rcx
  81cfe2:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81cfe6:	48 89 cf             	mov    %rcx,%rdi
  81cfe9:	ff d0                	callq  *%rax
  81cfeb:	88 45 d7             	mov    %al,-0x29(%rbp)
        }
      
        if (recv_data != NULL) {
  81cfee:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81cff5:	00 00 00 
  81cff8:	48 8b 00             	mov    (%rax),%rax
  81cffb:	48 85 c0             	test   %rax,%rax
  81cffe:	0f 84 cb 00 00 00    	je     81d0cf <tcp_input+0xb48>
          if(flags & TCP_PSH) {
  81d004:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d00b:	00 00 00 
  81d00e:	0f b6 00             	movzbl (%rax),%eax
  81d011:	0f b6 c0             	movzbl %al,%eax
  81d014:	83 e0 08             	and    $0x8,%eax
  81d017:	85 c0                	test   %eax,%eax
  81d019:	74 24                	je     81d03f <tcp_input+0xab8>
            recv_data->flags |= PBUF_FLAG_PUSH;
  81d01b:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81d022:	00 00 00 
  81d025:	48 8b 00             	mov    (%rax),%rax
  81d028:	48 ba e8 74 b5 00 00 	movabs $0xb574e8,%rdx
  81d02f:	00 00 00 
  81d032:	48 8b 12             	mov    (%rdx),%rdx
  81d035:	0f b6 52 15          	movzbl 0x15(%rdx),%edx
  81d039:	83 ca 01             	or     $0x1,%edx
  81d03c:	88 50 15             	mov    %dl,0x15(%rax)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  81d03f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d043:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81d04a:	48 85 c0             	test   %rax,%rax
  81d04d:	74 30                	je     81d07f <tcp_input+0xaf8>
  81d04f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d053:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81d05a:	48 ba e8 74 b5 00 00 	movabs $0xb574e8,%rdx
  81d061:	00 00 00 
  81d064:	48 8b 12             	mov    (%rdx),%rdx
  81d067:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81d06b:	48 8b 79 20          	mov    0x20(%rcx),%rdi
  81d06f:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81d073:	b9 00 00 00 00       	mov    $0x0,%ecx
  81d078:	ff d0                	callq  *%rax
  81d07a:	88 45 d7             	mov    %al,-0x29(%rbp)
  81d07d:	eb 32                	jmp    81d0b1 <tcp_input+0xb2a>
  81d07f:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
  81d083:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81d08a:	00 00 00 
  81d08d:	48 8b 00             	mov    (%rax),%rax
  81d090:	48 85 c0             	test   %rax,%rax
  81d093:	74 1c                	je     81d0b1 <tcp_input+0xb2a>
  81d095:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81d09c:	00 00 00 
  81d09f:	48 8b 00             	mov    (%rax),%rax
  81d0a2:	48 89 c7             	mov    %rax,%rdi
  81d0a5:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81d0ac:	00 00 00 
  81d0af:	ff d0                	callq  *%rax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  81d0b1:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81d0b5:	74 18                	je     81d0cf <tcp_input+0xb48>
            pcb->refused_data = recv_data;
  81d0b7:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81d0be:	00 00 00 
  81d0c1:	48 8b 10             	mov    (%rax),%rdx
  81d0c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d0c8:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  81d0cf:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81d0d6:	00 00 00 
  81d0d9:	0f b6 00             	movzbl (%rax),%eax
  81d0dc:	0f b6 c0             	movzbl %al,%eax
  81d0df:	83 e0 20             	and    $0x20,%eax
  81d0e2:	85 c0                	test   %eax,%eax
  81d0e4:	74 3c                	je     81d122 <tcp_input+0xb9b>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  81d0e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d0ea:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81d0f1:	48 85 c0             	test   %rax,%rax
  81d0f4:	74 28                	je     81d11e <tcp_input+0xb97>
  81d0f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d0fa:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81d101:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81d105:	48 8b 7a 20          	mov    0x20(%rdx),%rdi
  81d109:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81d10d:	b9 00 00 00 00       	mov    $0x0,%ecx
  81d112:	ba 00 00 00 00       	mov    $0x0,%edx
  81d117:	ff d0                	callq  *%rax
  81d119:	88 45 d7             	mov    %al,-0x29(%rbp)
  81d11c:	eb 04                	jmp    81d122 <tcp_input+0xb9b>
  81d11e:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  81d122:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81d126:	75 13                	jne    81d13b <tcp_input+0xbb4>
          tcp_output(pcb);
  81d128:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d12c:	48 89 c7             	mov    %rax,%rdi
  81d12f:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  81d136:	00 00 00 
  81d139:	ff d0                	callq  *%rax
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  81d13b:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81d142:	00 00 00 
  81d145:	48 8b 40 08          	mov    0x8(%rax),%rax
  81d149:	48 85 c0             	test   %rax,%rax
  81d14c:	0f 84 ff 00 00 00    	je     81d251 <tcp_input+0xcca>
    {
      pbuf_free(inseg.p);
  81d152:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81d159:	00 00 00 
  81d15c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81d160:	48 89 c7             	mov    %rax,%rdi
  81d163:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81d16a:	00 00 00 
  81d16d:	ff d0                	callq  *%rax
      inseg.p = NULL;
  81d16f:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81d176:	00 00 00 
  81d179:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81d180:	00 
  81d181:	e9 cb 00 00 00       	jmpq   81d251 <tcp_input+0xcca>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  81d186:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d18d:	00 00 00 
  81d190:	48 8b 00             	mov    (%rax),%rax
  81d193:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81d197:	0f b7 c0             	movzwl %ax,%eax
  81d19a:	89 c7                	mov    %eax,%edi
  81d19c:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81d1a3:	00 00 00 
  81d1a6:	ff d0                	callq  *%rax
  81d1a8:	0f b7 c0             	movzwl %ax,%eax
  81d1ab:	83 e0 04             	and    $0x4,%eax
  81d1ae:	85 c0                	test   %eax,%eax
  81d1b0:	0f 85 88 00 00 00    	jne    81d23e <tcp_input+0xcb7>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81d1b6:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d1bd:	00 00 00 
  81d1c0:	48 8b 00             	mov    (%rax),%rax
  81d1c3:	0f b7 00             	movzwl (%rax),%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81d1c6:	44 0f b7 c0          	movzwl %ax,%r8d
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81d1ca:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d1d1:	00 00 00 
  81d1d4:	48 8b 00             	mov    (%rax),%rax
  81d1d7:	0f b7 40 02          	movzwl 0x2(%rax),%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81d1db:	0f b7 f8             	movzwl %ax,%edi
        &(iphdr->dest), &(iphdr->src),
  81d1de:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d1e5:	00 00 00 
  81d1e8:	48 8b 00             	mov    (%rax),%rax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81d1eb:	48 8d 48 0c          	lea    0xc(%rax),%rcx
        &(iphdr->dest), &(iphdr->src),
  81d1ef:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d1f6:	00 00 00 
  81d1f9:	48 8b 00             	mov    (%rax),%rax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81d1fc:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81d200:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d207:	00 00 00 
  81d20a:	0f b7 00             	movzwl (%rax),%eax
  81d20d:	0f b7 f0             	movzwl %ax,%esi
  81d210:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d217:	00 00 00 
  81d21a:	8b 00                	mov    (%rax),%eax
  81d21c:	01 c6                	add    %eax,%esi
  81d21e:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d225:	00 00 00 
  81d228:	8b 00                	mov    (%rax),%eax
  81d22a:	45 89 c1             	mov    %r8d,%r9d
  81d22d:	41 89 f8             	mov    %edi,%r8d
  81d230:	89 c7                	mov    %eax,%edi
  81d232:	48 b8 05 46 81 00 00 	movabs $0x814605,%rax
  81d239:	00 00 00 
  81d23c:	ff d0                	callq  *%rax
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  81d23e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81d242:	48 89 c7             	mov    %rax,%rdi
  81d245:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  81d24c:	00 00 00 
  81d24f:	ff d0                	callq  *%rax
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  81d251:	48 83 c4 38          	add    $0x38,%rsp
  81d255:	5b                   	pop    %rbx
  81d256:	5d                   	pop    %rbp
  81d257:	c3                   	retq   

000000000081d258 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
  81d258:	55                   	push   %rbp
  81d259:	48 89 e5             	mov    %rsp,%rbp
  81d25c:	48 83 ec 20          	sub    $0x20,%rsp
  81d260:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  81d264:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d26b:	00 00 00 
  81d26e:	0f b6 00             	movzbl (%rax),%eax
  81d271:	0f b6 c0             	movzbl %al,%eax
  81d274:	83 e0 10             	and    $0x10,%eax
  81d277:	85 c0                	test   %eax,%eax
  81d279:	0f 84 90 00 00 00    	je     81d30f <tcp_listen_input+0xb7>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  81d27f:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d286:	00 00 00 
  81d289:	48 8b 00             	mov    (%rax),%rax
  81d28c:	0f b7 00             	movzwl (%rax),%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81d28f:	44 0f b7 c0          	movzwl %ax,%r8d
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  81d293:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d29a:	00 00 00 
  81d29d:	48 8b 00             	mov    (%rax),%rax
  81d2a0:	0f b7 40 02          	movzwl 0x2(%rax),%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81d2a4:	0f b7 f8             	movzwl %ax,%edi
      &(iphdr->dest), &(iphdr->src),
  81d2a7:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d2ae:	00 00 00 
  81d2b1:	48 8b 00             	mov    (%rax),%rax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81d2b4:	48 8d 48 0c          	lea    0xc(%rax),%rcx
      &(iphdr->dest), &(iphdr->src),
  81d2b8:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d2bf:	00 00 00 
  81d2c2:	48 8b 00             	mov    (%rax),%rax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81d2c5:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81d2c9:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d2d0:	00 00 00 
  81d2d3:	0f b7 00             	movzwl (%rax),%eax
  81d2d6:	0f b7 f0             	movzwl %ax,%esi
  81d2d9:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d2e0:	00 00 00 
  81d2e3:	8b 00                	mov    (%rax),%eax
  81d2e5:	01 c6                	add    %eax,%esi
  81d2e7:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d2ee:	00 00 00 
  81d2f1:	8b 00                	mov    (%rax),%eax
  81d2f3:	83 c0 01             	add    $0x1,%eax
  81d2f6:	45 89 c1             	mov    %r8d,%r9d
  81d2f9:	41 89 f8             	mov    %edi,%r8d
  81d2fc:	89 c7                	mov    %eax,%edi
  81d2fe:	48 b8 05 46 81 00 00 	movabs $0x814605,%rax
  81d305:	00 00 00 
  81d308:	ff d0                	callq  *%rax
  81d30a:	e9 46 02 00 00       	jmpq   81d555 <tcp_listen_input+0x2fd>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  81d30f:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d316:	00 00 00 
  81d319:	0f b6 00             	movzbl (%rax),%eax
  81d31c:	0f b6 c0             	movzbl %al,%eax
  81d31f:	83 e0 02             	and    $0x2,%eax
  81d322:	85 c0                	test   %eax,%eax
  81d324:	0f 84 2b 02 00 00    	je     81d555 <tcp_listen_input+0x2fd>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  81d32a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d32e:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  81d332:	0f b6 c0             	movzbl %al,%eax
  81d335:	89 c7                	mov    %eax,%edi
  81d337:	48 b8 3b 07 81 00 00 	movabs $0x81073b,%rax
  81d33e:	00 00 00 
  81d341:	ff d0                	callq  *%rax
  81d343:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  81d347:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81d34c:	75 0a                	jne    81d358 <tcp_listen_input+0x100>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
      return ERR_MEM;
  81d34e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81d353:	e9 02 02 00 00       	jmpq   81d55a <tcp_listen_input+0x302>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  81d358:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d35f:	00 00 00 
  81d362:	48 8b 00             	mov    (%rax),%rax
  81d365:	48 83 c0 10          	add    $0x10,%rax
  81d369:	48 85 c0             	test   %rax,%rax
  81d36c:	74 12                	je     81d380 <tcp_listen_input+0x128>
  81d36e:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d375:	00 00 00 
  81d378:	48 8b 00             	mov    (%rax),%rax
  81d37b:	8b 40 10             	mov    0x10(%rax),%eax
  81d37e:	eb 05                	jmp    81d385 <tcp_listen_input+0x12d>
  81d380:	b8 00 00 00 00       	mov    $0x0,%eax
  81d385:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81d389:	89 02                	mov    %eax,(%rdx)
    npcb->local_port = pcb->local_port;
  81d38b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d38f:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81d393:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d397:	66 89 50 28          	mov    %dx,0x28(%rax)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  81d39b:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d3a2:	00 00 00 
  81d3a5:	48 8b 00             	mov    (%rax),%rax
  81d3a8:	48 83 c0 0c          	add    $0xc,%rax
  81d3ac:	48 85 c0             	test   %rax,%rax
  81d3af:	74 12                	je     81d3c3 <tcp_listen_input+0x16b>
  81d3b1:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d3b8:	00 00 00 
  81d3bb:	48 8b 00             	mov    (%rax),%rax
  81d3be:	8b 40 0c             	mov    0xc(%rax),%eax
  81d3c1:	eb 05                	jmp    81d3c8 <tcp_listen_input+0x170>
  81d3c3:	b8 00 00 00 00       	mov    $0x0,%eax
  81d3c8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81d3cc:	89 42 04             	mov    %eax,0x4(%rdx)
    npcb->remote_port = tcphdr->src;
  81d3cf:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d3d6:	00 00 00 
  81d3d9:	48 8b 00             	mov    (%rax),%rax
  81d3dc:	0f b7 10             	movzwl (%rax),%edx
  81d3df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d3e3:	66 89 50 2a          	mov    %dx,0x2a(%rax)
    npcb->state = SYN_RCVD;
  81d3e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d3eb:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%rax)
    npcb->rcv_nxt = seqno + 1;
  81d3f2:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d3f9:	00 00 00 
  81d3fc:	8b 00                	mov    (%rax),%eax
  81d3fe:	8d 50 01             	lea    0x1(%rax),%edx
  81d401:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d405:	89 50 30             	mov    %edx,0x30(%rax)
    npcb->snd_wnd = tcphdr->wnd;
  81d408:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d40f:	00 00 00 
  81d412:	48 8b 00             	mov    (%rax),%rax
  81d415:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81d419:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d41d:	66 89 50 68          	mov    %dx,0x68(%rax)
    npcb->ssthresh = npcb->snd_wnd;
  81d421:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d425:	0f b7 50 68          	movzwl 0x68(%rax),%edx
  81d429:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d42d:	66 89 50 5c          	mov    %dx,0x5c(%rax)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  81d431:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d438:	00 00 00 
  81d43b:	8b 00                	mov    (%rax),%eax
  81d43d:	8d 50 ff             	lea    -0x1(%rax),%edx
  81d440:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d444:	89 50 6c             	mov    %edx,0x6c(%rax)
    npcb->callback_arg = pcb->callback_arg;
  81d447:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d44b:	48 8b 50 20          	mov    0x20(%rax),%rdx
  81d44f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d453:	48 89 50 20          	mov    %rdx,0x20(%rax)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  81d457:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d45b:	48 8b 50 30          	mov    0x30(%rax),%rdx
  81d45f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d463:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  81d46a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d46e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81d472:	66 25 99 01          	and    $0x199,%ax
  81d476:	89 c2                	mov    %eax,%edx
  81d478:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d47c:	66 89 50 08          	mov    %dx,0x8(%rax)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  81d480:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d487:	00 00 00 
  81d48a:	48 8b 10             	mov    (%rax),%rdx
  81d48d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d491:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81d495:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d49c:	00 00 00 
  81d49f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81d4a3:	48 89 10             	mov    %rdx,(%rax)
  81d4a6:	48 b8 8f 86 80 00 00 	movabs $0x80868f,%rax
  81d4ad:	00 00 00 
  81d4b0:	ff d0                	callq  *%rax

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  81d4b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d4b6:	48 89 c7             	mov    %rax,%rdi
  81d4b9:	48 b8 7d fd 81 00 00 	movabs $0x81fd7d,%rax
  81d4c0:	00 00 00 
  81d4c3:	ff d0                	callq  *%rax
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  81d4c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d4c9:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81d4cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d4d1:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d4d5:	0f b7 c0             	movzwl %ax,%eax
  81d4d8:	48 89 d6             	mov    %rdx,%rsi
  81d4db:	89 c7                	mov    %eax,%edi
  81d4dd:	48 b8 0d 0d 81 00 00 	movabs $0x810d0d,%rax
  81d4e4:	00 00 00 
  81d4e7:	ff d0                	callq  *%rax
  81d4e9:	89 c2                	mov    %eax,%edx
  81d4eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d4ef:	66 89 50 40          	mov    %dx,0x40(%rax)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  81d4f3:	bf b4 05 04 02       	mov    $0x20405b4,%edi
  81d4f8:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  81d4ff:	00 00 00 
  81d502:	ff d0                	callq  *%rax
  81d504:	89 45 f4             	mov    %eax,-0xc(%rbp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  81d507:	48 8d 55 f4          	lea    -0xc(%rbp),%rdx
  81d50b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d50f:	48 83 ec 08          	sub    $0x8,%rsp
  81d513:	6a 04                	pushq  $0x4
  81d515:	49 89 d1             	mov    %rdx,%r9
  81d518:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  81d51e:	b9 12 00 00 00       	mov    $0x12,%ecx
  81d523:	ba 00 00 00 00       	mov    $0x0,%edx
  81d528:	be 00 00 00 00       	mov    $0x0,%esi
  81d52d:	48 89 c7             	mov    %rax,%rdi
  81d530:	48 b8 1b 32 81 00 00 	movabs $0x81321b,%rax
  81d537:	00 00 00 
  81d53a:	ff d0                	callq  *%rax
  81d53c:	48 83 c4 10          	add    $0x10,%rsp
    return tcp_output(npcb);
  81d540:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d544:	48 89 c7             	mov    %rax,%rdi
  81d547:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  81d54e:	00 00 00 
  81d551:	ff d0                	callq  *%rax
  81d553:	eb 05                	jmp    81d55a <tcp_listen_input+0x302>
  }
  return ERR_OK;
  81d555:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81d55a:	c9                   	leaveq 
  81d55b:	c3                   	retq   

000000000081d55c <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  81d55c:	55                   	push   %rbp
  81d55d:	48 89 e5             	mov    %rsp,%rbp
  81d560:	48 83 ec 10          	sub    $0x10,%rsp
  81d564:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  81d568:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d56f:	00 00 00 
  81d572:	0f b7 00             	movzwl (%rax),%eax
  81d575:	0f b7 d0             	movzwl %ax,%edx
  81d578:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d57f:	00 00 00 
  81d582:	8b 00                	mov    (%rax),%eax
  81d584:	01 c2                	add    %eax,%edx
  81d586:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d58a:	8b 40 30             	mov    0x30(%rax),%eax
  81d58d:	29 c2                	sub    %eax,%edx
  81d58f:	89 d0                	mov    %edx,%eax
  81d591:	85 c0                	test   %eax,%eax
  81d593:	7e 25                	jle    81d5ba <tcp_timewait_input+0x5e>
    pcb->rcv_nxt = seqno + tcplen;
  81d595:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d59c:	00 00 00 
  81d59f:	0f b7 00             	movzwl (%rax),%eax
  81d5a2:	0f b7 d0             	movzwl %ax,%edx
  81d5a5:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d5ac:	00 00 00 
  81d5af:	8b 00                	mov    (%rax),%eax
  81d5b1:	01 c2                	add    %eax,%edx
  81d5b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d5b7:	89 50 30             	mov    %edx,0x30(%rax)
  }
  if (tcplen > 0) {
  81d5ba:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d5c1:	00 00 00 
  81d5c4:	0f b7 00             	movzwl (%rax),%eax
  81d5c7:	66 85 c0             	test   %ax,%ax
  81d5ca:	74 27                	je     81d5f3 <tcp_timewait_input+0x97>
    tcp_ack_now(pcb);
  81d5cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d5d0:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d5d4:	83 c8 02             	or     $0x2,%eax
  81d5d7:	89 c2                	mov    %eax,%edx
  81d5d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d5dd:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d5e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d5e4:	48 89 c7             	mov    %rax,%rdi
  81d5e7:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  81d5ee:	00 00 00 
  81d5f1:	ff d0                	callq  *%rax
  }
  return tcp_output(pcb);
  81d5f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d5f7:	48 89 c7             	mov    %rax,%rdi
  81d5fa:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  81d601:	00 00 00 
  81d604:	ff d0                	callq  *%rax
}
  81d606:	c9                   	leaveq 
  81d607:	c3                   	retq   

000000000081d608 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
  81d608:	55                   	push   %rbp
  81d609:	48 89 e5             	mov    %rsp,%rbp
  81d60c:	48 83 ec 20          	sub    $0x20,%rsp
  81d610:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
  81d614:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  err_t err;
  u8_t accepted_inseq;

  err = ERR_OK;
  81d618:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  81d61c:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d623:	00 00 00 
  81d626:	0f b6 00             	movzbl (%rax),%eax
  81d629:	0f b6 c0             	movzbl %al,%eax
  81d62c:	83 e0 04             	and    $0x4,%eax
  81d62f:	85 c0                	test   %eax,%eax
  81d631:	0f 84 e0 00 00 00    	je     81d717 <tcp_process+0x10f>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  81d637:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d63b:	8b 40 18             	mov    0x18(%rax),%eax
  81d63e:	83 f8 02             	cmp    $0x2,%eax
  81d641:	75 1d                	jne    81d660 <tcp_process+0x58>
      if (ackno == pcb->snd_nxt) {
  81d643:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d647:	8b 50 60             	mov    0x60(%rax),%edx
  81d64a:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d651:	00 00 00 
  81d654:	8b 00                	mov    (%rax),%eax
  81d656:	39 c2                	cmp    %eax,%edx
  81d658:	75 4d                	jne    81d6a7 <tcp_process+0x9f>
        acceptable = 1;
  81d65a:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  81d65e:	eb 47                	jmp    81d6a7 <tcp_process+0x9f>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  81d660:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d667:	00 00 00 
  81d66a:	8b 10                	mov    (%rax),%edx
  81d66c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d670:	8b 40 30             	mov    0x30(%rax),%eax
  81d673:	29 c2                	sub    %eax,%edx
  81d675:	89 d0                	mov    %edx,%eax
  81d677:	85 c0                	test   %eax,%eax
  81d679:	78 2c                	js     81d6a7 <tcp_process+0x9f>
  81d67b:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d682:	00 00 00 
  81d685:	8b 10                	mov    (%rax),%edx
  81d687:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d68b:	8b 48 30             	mov    0x30(%rax),%ecx
  81d68e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d692:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81d696:	0f b7 c0             	movzwl %ax,%eax
  81d699:	01 c8                	add    %ecx,%eax
  81d69b:	29 c2                	sub    %eax,%edx
  81d69d:	89 d0                	mov    %edx,%eax
  81d69f:	85 c0                	test   %eax,%eax
  81d6a1:	7f 04                	jg     81d6a7 <tcp_process+0x9f>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
  81d6a3:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
      }
    }

    if (acceptable) {
  81d6a7:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  81d6ab:	74 60                	je     81d70d <tcp_process+0x105>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  81d6ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d6b1:	8b 40 18             	mov    0x18(%rax),%eax
  81d6b4:	85 c0                	test   %eax,%eax
  81d6b6:	75 2a                	jne    81d6e2 <tcp_process+0xda>
  81d6b8:	48 ba a8 3c 82 00 00 	movabs $0x823ca8,%rdx
  81d6bf:	00 00 00 
  81d6c2:	be 0a 02 00 00       	mov    $0x20a,%esi
  81d6c7:	48 bf a7 3b 82 00 00 	movabs $0x823ba7,%rdi
  81d6ce:	00 00 00 
  81d6d1:	b8 00 00 00 00       	mov    $0x0,%eax
  81d6d6:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81d6dd:	00 00 00 
  81d6e0:	ff d1                	callq  *%rcx
      recv_flags = TF_RESET;
  81d6e2:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81d6e9:	00 00 00 
  81d6ec:	c6 00 08             	movb   $0x8,(%rax)
      pcb->flags &= ~TF_ACK_DELAY;
  81d6ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d6f3:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d6f7:	83 e0 fe             	and    $0xfffffffe,%eax
  81d6fa:	89 c2                	mov    %eax,%edx
  81d6fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d700:	88 50 2c             	mov    %dl,0x2c(%rax)
      return ERR_RST;
  81d703:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  81d708:	e9 e0 0b 00 00       	jmpq   81e2ed <tcp_process+0xce5>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
  81d70d:	b8 00 00 00 00       	mov    $0x0,%eax
  81d712:	e9 d6 0b 00 00       	jmpq   81e2ed <tcp_process+0xce5>
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  81d717:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81d71e:	00 00 00 
  81d721:	8b 10                	mov    (%rax),%edx
  81d723:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d727:	89 50 38             	mov    %edx,0x38(%rax)
  pcb->keep_cnt_sent = 0;
  81d72a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d72e:	c6 80 d9 00 00 00 00 	movb   $0x0,0xd9(%rax)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  81d735:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d739:	8b 40 18             	mov    0x18(%rax),%eax
  81d73c:	83 f8 09             	cmp    $0x9,%eax
  81d73f:	0f 87 8d 0b 00 00    	ja     81e2d2 <tcp_process+0xcca>
  81d745:	89 c0                	mov    %eax,%eax
  81d747:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  81d74e:	00 
  81d74f:	48 b8 f8 3c 82 00 00 	movabs $0x823cf8,%rax
  81d756:	00 00 00 
  81d759:	48 01 d0             	add    %rdx,%rax
  81d75c:	48 8b 00             	mov    (%rax),%rax
  81d75f:	ff e0                	jmpq   *%rax
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  81d761:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d768:	00 00 00 
  81d76b:	0f b6 00             	movzbl (%rax),%eax
  81d76e:	0f b6 c0             	movzbl %al,%eax
  81d771:	83 e0 10             	and    $0x10,%eax
  81d774:	85 c0                	test   %eax,%eax
  81d776:	0f 84 5a 02 00 00    	je     81d9d6 <tcp_process+0x3ce>
  81d77c:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d783:	00 00 00 
  81d786:	0f b6 00             	movzbl (%rax),%eax
  81d789:	0f b6 c0             	movzbl %al,%eax
  81d78c:	83 e0 02             	and    $0x2,%eax
  81d78f:	85 c0                	test   %eax,%eax
  81d791:	0f 84 3f 02 00 00    	je     81d9d6 <tcp_process+0x3ce>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  81d797:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d79b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d7a2:	48 8b 40 20          	mov    0x20(%rax),%rax
  81d7a6:	8b 40 04             	mov    0x4(%rax),%eax
  81d7a9:	89 c7                	mov    %eax,%edi
  81d7ab:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  81d7b2:	00 00 00 
  81d7b5:	ff d0                	callq  *%rax
  81d7b7:	8d 50 01             	lea    0x1(%rax),%edx
  81d7ba:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d7c1:	00 00 00 
  81d7c4:	8b 00                	mov    (%rax),%eax
  81d7c6:	39 c2                	cmp    %eax,%edx
  81d7c8:	0f 85 08 02 00 00    	jne    81d9d6 <tcp_process+0x3ce>
      pcb->snd_buf++;
  81d7ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d7d2:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81d7d6:	8d 50 01             	lea    0x1(%rax),%edx
  81d7d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d7dd:	66 89 50 7a          	mov    %dx,0x7a(%rax)
      pcb->rcv_nxt = seqno + 1;
  81d7e1:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d7e8:	00 00 00 
  81d7eb:	8b 00                	mov    (%rax),%eax
  81d7ed:	8d 50 01             	lea    0x1(%rax),%edx
  81d7f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d7f4:	89 50 30             	mov    %edx,0x30(%rax)
      pcb->lastack = ackno;
  81d7f7:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d7fe:	00 00 00 
  81d801:	8b 10                	mov    (%rax),%edx
  81d803:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d807:	89 50 54             	mov    %edx,0x54(%rax)
      pcb->snd_wnd = tcphdr->wnd;
  81d80a:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d811:	00 00 00 
  81d814:	48 8b 00             	mov    (%rax),%rax
  81d817:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81d81b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d81f:	66 89 50 68          	mov    %dx,0x68(%rax)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  81d823:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d82a:	00 00 00 
  81d82d:	8b 00                	mov    (%rax),%eax
  81d82f:	8d 50 ff             	lea    -0x1(%rax),%edx
  81d832:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d836:	89 50 6c             	mov    %edx,0x6c(%rax)
      pcb->state = ESTABLISHED;
  81d839:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d83d:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%rax)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  81d844:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d848:	48 89 c7             	mov    %rax,%rdi
  81d84b:	48 b8 7d fd 81 00 00 	movabs $0x81fd7d,%rax
  81d852:	00 00 00 
  81d855:	ff d0                	callq  *%rax
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  81d857:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d85b:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81d85f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d863:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d867:	0f b7 c0             	movzwl %ax,%eax
  81d86a:	48 89 d6             	mov    %rdx,%rsi
  81d86d:	89 c7                	mov    %eax,%edi
  81d86f:	48 b8 0d 0d 81 00 00 	movabs $0x810d0d,%rax
  81d876:	00 00 00 
  81d879:	ff d0                	callq  *%rax
  81d87b:	89 c2                	mov    %eax,%edx
  81d87d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d881:	66 89 50 40          	mov    %dx,0x40(%rax)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  81d885:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d889:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81d88d:	89 d0                	mov    %edx,%eax
  81d88f:	c1 e0 02             	shl    $0x2,%eax
  81d892:	01 d0                	add    %edx,%eax
  81d894:	01 c0                	add    %eax,%eax
  81d896:	89 c2                	mov    %eax,%edx
  81d898:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d89c:	66 89 50 5c          	mov    %dx,0x5c(%rax)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  81d8a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d8a4:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81d8a8:	66 83 f8 01          	cmp    $0x1,%ax
  81d8ac:	75 0c                	jne    81d8ba <tcp_process+0x2b2>
  81d8ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d8b2:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d8b6:	01 c0                	add    %eax,%eax
  81d8b8:	eb 08                	jmp    81d8c2 <tcp_process+0x2ba>
  81d8ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d8be:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d8c2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81d8c6:	66 89 42 5a          	mov    %ax,0x5a(%rdx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  81d8ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d8ce:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81d8d2:	66 85 c0             	test   %ax,%ax
  81d8d5:	75 2a                	jne    81d901 <tcp_process+0x2f9>
  81d8d7:	48 ba c8 3c 82 00 00 	movabs $0x823cc8,%rdx
  81d8de:	00 00 00 
  81d8e1:	be 36 02 00 00       	mov    $0x236,%esi
  81d8e6:	48 bf a7 3b 82 00 00 	movabs $0x823ba7,%rdi
  81d8ed:	00 00 00 
  81d8f0:	b8 00 00 00 00       	mov    $0x0,%eax
  81d8f5:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81d8fc:	00 00 00 
  81d8ff:	ff d1                	callq  *%rcx
      --pcb->snd_queuelen;
  81d901:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d905:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81d909:	8d 50 ff             	lea    -0x1(%rax),%edx
  81d90c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d910:	66 89 50 7c          	mov    %dx,0x7c(%rax)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  81d914:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d918:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d91f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb->unacked = rseg->next;
  81d923:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81d927:	48 8b 10             	mov    (%rax),%rdx
  81d92a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d92e:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  81d935:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d939:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d940:	48 85 c0             	test   %rax,%rax
  81d943:	75 0c                	jne    81d951 <tcp_process+0x349>
        pcb->rtime = -1;
  81d945:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d949:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
  81d94f:	eb 12                	jmp    81d963 <tcp_process+0x35b>
      else {
        pcb->rtime = 0;
  81d951:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d955:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)
        pcb->nrtx = 0;
  81d95b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d95f:	c6 40 52 00          	movb   $0x0,0x52(%rax)
      }

      tcp_seg_free(rseg);
  81d963:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81d967:	48 89 c7             	mov    %rax,%rdi
  81d96a:	48 b8 a0 04 81 00 00 	movabs $0x8104a0,%rax
  81d971:	00 00 00 
  81d974:	ff d0                	callq  *%rax

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  81d976:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d97a:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  81d981:	48 85 c0             	test   %rax,%rax
  81d984:	74 24                	je     81d9aa <tcp_process+0x3a2>
  81d986:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d98a:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  81d991:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81d995:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  81d999:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81d99d:	ba 00 00 00 00       	mov    $0x0,%edx
  81d9a2:	48 89 cf             	mov    %rcx,%rdi
  81d9a5:	ff d0                	callq  *%rax
  81d9a7:	88 45 fe             	mov    %al,-0x2(%rbp)
      tcp_ack_now(pcb);
  81d9aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d9ae:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d9b2:	83 c8 02             	or     $0x2,%eax
  81d9b5:	89 c2                	mov    %eax,%edx
  81d9b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d9bb:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d9be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d9c2:	48 89 c7             	mov    %rax,%rdi
  81d9c5:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  81d9cc:	00 00 00 
  81d9cf:	ff d0                	callq  *%rax
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
  81d9d1:	e9 ff 08 00 00       	jmpq   81e2d5 <tcp_process+0xccd>
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  81d9d6:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d9dd:	00 00 00 
  81d9e0:	0f b6 00             	movzbl (%rax),%eax
  81d9e3:	0f b6 c0             	movzbl %al,%eax
  81d9e6:	83 e0 10             	and    $0x10,%eax
  81d9e9:	85 c0                	test   %eax,%eax
  81d9eb:	0f 84 e4 08 00 00    	je     81e2d5 <tcp_process+0xccd>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81d9f1:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d9f8:	00 00 00 
  81d9fb:	48 8b 00             	mov    (%rax),%rax
  81d9fe:	0f b7 00             	movzwl (%rax),%eax
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81da01:	44 0f b7 c0          	movzwl %ax,%r8d
        tcphdr->dest, tcphdr->src);
  81da05:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81da0c:	00 00 00 
  81da0f:	48 8b 00             	mov    (%rax),%rax
  81da12:	0f b7 40 02          	movzwl 0x2(%rax),%eax
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81da16:	0f b7 f8             	movzwl %ax,%edi
  81da19:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81da20:	00 00 00 
  81da23:	48 8b 00             	mov    (%rax),%rax
  81da26:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  81da2a:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81da31:	00 00 00 
  81da34:	48 8b 00             	mov    (%rax),%rax
  81da37:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81da3b:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81da42:	00 00 00 
  81da45:	0f b7 00             	movzwl (%rax),%eax
  81da48:	0f b7 f0             	movzwl %ax,%esi
  81da4b:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81da52:	00 00 00 
  81da55:	8b 00                	mov    (%rax),%eax
  81da57:	01 c6                	add    %eax,%esi
  81da59:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81da60:	00 00 00 
  81da63:	8b 00                	mov    (%rax),%eax
  81da65:	45 89 c1             	mov    %r8d,%r9d
  81da68:	41 89 f8             	mov    %edi,%r8d
  81da6b:	89 c7                	mov    %eax,%edi
  81da6d:	48 b8 05 46 81 00 00 	movabs $0x814605,%rax
  81da74:	00 00 00 
  81da77:	ff d0                	callq  *%rax
        tcphdr->dest, tcphdr->src);
    }
    break;
  81da79:	e9 57 08 00 00       	jmpq   81e2d5 <tcp_process+0xccd>
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  81da7e:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81da85:	00 00 00 
  81da88:	0f b6 00             	movzbl (%rax),%eax
  81da8b:	0f b6 c0             	movzbl %al,%eax
  81da8e:	83 e0 10             	and    $0x10,%eax
  81da91:	85 c0                	test   %eax,%eax
  81da93:	0f 84 3f 08 00 00    	je     81e2d8 <tcp_process+0xcd0>
       !(flags & TCP_RST)) {
  81da99:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81daa0:	00 00 00 
  81daa3:	0f b6 00             	movzbl (%rax),%eax
  81daa6:	0f b6 c0             	movzbl %al,%eax
  81daa9:	83 e0 04             	and    $0x4,%eax
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  81daac:	85 c0                	test   %eax,%eax
  81daae:	0f 85 24 08 00 00    	jne    81e2d8 <tcp_process+0xcd0>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81dab4:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81dabb:	00 00 00 
  81dabe:	8b 10                	mov    (%rax),%edx
  81dac0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dac4:	8b 40 54             	mov    0x54(%rax),%eax
  81dac7:	29 c2                	sub    %eax,%edx
  81dac9:	89 d0                	mov    %edx,%eax
  81dacb:	83 e8 01             	sub    $0x1,%eax
  81dace:	85 c0                	test   %eax,%eax
  81dad0:	0f 88 5c 01 00 00    	js     81dc32 <tcp_process+0x62a>
  81dad6:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81dadd:	00 00 00 
  81dae0:	8b 10                	mov    (%rax),%edx
  81dae2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dae6:	8b 40 60             	mov    0x60(%rax),%eax
  81dae9:	29 c2                	sub    %eax,%edx
  81daeb:	89 d0                	mov    %edx,%eax
  81daed:	85 c0                	test   %eax,%eax
  81daef:	0f 8f 3d 01 00 00    	jg     81dc32 <tcp_process+0x62a>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  81daf5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81daf9:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%rax)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  81db00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81db04:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81db0b:	48 85 c0             	test   %rax,%rax
  81db0e:	75 2a                	jne    81db3a <tcp_process+0x532>
  81db10:	48 ba de 3c 82 00 00 	movabs $0x823cde,%rdx
  81db17:	00 00 00 
  81db1a:	be 5c 02 00 00       	mov    $0x25c,%esi
  81db1f:	48 bf a7 3b 82 00 00 	movabs $0x823ba7,%rdi
  81db26:	00 00 00 
  81db29:	b8 00 00 00 00       	mov    $0x0,%eax
  81db2e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81db35:	00 00 00 
  81db38:	ff d1                	callq  *%rcx
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  81db3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81db3e:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81db45:	48 85 c0             	test   %rax,%rax
  81db48:	74 24                	je     81db6e <tcp_process+0x566>
  81db4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81db4e:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81db55:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81db59:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  81db5d:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81db61:	ba 00 00 00 00       	mov    $0x0,%edx
  81db66:	48 89 cf             	mov    %rcx,%rdi
  81db69:	ff d0                	callq  *%rax
  81db6b:	88 45 fe             	mov    %al,-0x2(%rbp)
        if (err != ERR_OK) {
  81db6e:	80 7d fe 00          	cmpb   $0x0,-0x2(%rbp)
  81db72:	74 1d                	je     81db91 <tcp_process+0x589>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  81db74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81db78:	48 89 c7             	mov    %rax,%rdi
  81db7b:	48 b8 1c ef 80 00 00 	movabs $0x80ef1c,%rax
  81db82:	00 00 00 
  81db85:	ff d0                	callq  *%rax
          return ERR_ABRT;
  81db87:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  81db8c:	e9 5c 07 00 00       	jmpq   81e2ed <tcp_process+0xce5>
        }
        old_cwnd = pcb->cwnd;
  81db91:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81db95:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81db99:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  81db9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dba1:	48 89 c7             	mov    %rax,%rdi
  81dba4:	48 b8 ef e2 81 00 00 	movabs $0x81e2ef,%rax
  81dbab:	00 00 00 
  81dbae:	ff d0                	callq  *%rax
  81dbb0:	88 45 fb             	mov    %al,-0x5(%rbp)

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  81dbb3:	66 83 7d fc 01       	cmpw   $0x1,-0x4(%rbp)
  81dbb8:	75 0c                	jne    81dbc6 <tcp_process+0x5be>
  81dbba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dbbe:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81dbc2:	01 c0                	add    %eax,%eax
  81dbc4:	eb 08                	jmp    81dbce <tcp_process+0x5c6>
  81dbc6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dbca:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81dbce:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81dbd2:	66 89 42 5a          	mov    %ax,0x5a(%rdx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  81dbd6:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81dbdd:	00 00 00 
  81dbe0:	0f b6 00             	movzbl (%rax),%eax
  81dbe3:	0f b6 c0             	movzbl %al,%eax
  81dbe6:	83 e0 01             	and    $0x1,%eax
  81dbe9:	85 c0                	test   %eax,%eax
  81dbeb:	0f 84 ce 00 00 00    	je     81dcbf <tcp_process+0x6b7>
  81dbf1:	80 7d fb 00          	cmpb   $0x0,-0x5(%rbp)
  81dbf5:	0f 84 c4 00 00 00    	je     81dcbf <tcp_process+0x6b7>
          tcp_ack_now(pcb);
  81dbfb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dbff:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81dc03:	83 c8 02             	or     $0x2,%eax
  81dc06:	89 c2                	mov    %eax,%edx
  81dc08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dc0c:	88 50 2c             	mov    %dl,0x2c(%rax)
  81dc0f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dc13:	48 89 c7             	mov    %rax,%rdi
  81dc16:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  81dc1d:	00 00 00 
  81dc20:	ff d0                	callq  *%rax
          pcb->state = CLOSE_WAIT;
  81dc22:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dc26:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81dc2d:	e9 8d 00 00 00       	jmpq   81dcbf <tcp_process+0x6b7>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  81dc32:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81dc39:	00 00 00 
  81dc3c:	48 8b 00             	mov    (%rax),%rax
  81dc3f:	0f b7 00             	movzwl (%rax),%eax
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81dc42:	44 0f b7 c0          	movzwl %ax,%r8d
                tcphdr->dest, tcphdr->src);
  81dc46:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81dc4d:	00 00 00 
  81dc50:	48 8b 00             	mov    (%rax),%rax
  81dc53:	0f b7 40 02          	movzwl 0x2(%rax),%eax
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81dc57:	0f b7 f8             	movzwl %ax,%edi
  81dc5a:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81dc61:	00 00 00 
  81dc64:	48 8b 00             	mov    (%rax),%rax
  81dc67:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  81dc6b:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81dc72:	00 00 00 
  81dc75:	48 8b 00             	mov    (%rax),%rax
  81dc78:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81dc7c:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81dc83:	00 00 00 
  81dc86:	0f b7 00             	movzwl (%rax),%eax
  81dc89:	0f b7 f0             	movzwl %ax,%esi
  81dc8c:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81dc93:	00 00 00 
  81dc96:	8b 00                	mov    (%rax),%eax
  81dc98:	01 c6                	add    %eax,%esi
  81dc9a:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81dca1:	00 00 00 
  81dca4:	8b 00                	mov    (%rax),%eax
  81dca6:	45 89 c1             	mov    %r8d,%r9d
  81dca9:	41 89 f8             	mov    %edi,%r8d
  81dcac:	89 c7                	mov    %eax,%edi
  81dcae:	48 b8 05 46 81 00 00 	movabs $0x814605,%rax
  81dcb5:	00 00 00 
  81dcb8:	ff d0                	callq  *%rax
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
  81dcba:	e9 19 06 00 00       	jmpq   81e2d8 <tcp_process+0xcd0>
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81dcbf:	90                   	nop
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
  81dcc0:	e9 13 06 00 00       	jmpq   81e2d8 <tcp_process+0xcd0>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  81dcc5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dcc9:	48 89 c7             	mov    %rax,%rdi
  81dccc:	48 b8 ef e2 81 00 00 	movabs $0x81e2ef,%rax
  81dcd3:	00 00 00 
  81dcd6:	ff d0                	callq  *%rax
  81dcd8:	88 45 fb             	mov    %al,-0x5(%rbp)
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  81dcdb:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81dce2:	00 00 00 
  81dce5:	0f b6 00             	movzbl (%rax),%eax
  81dce8:	0f b6 c0             	movzbl %al,%eax
  81dceb:	83 e0 01             	and    $0x1,%eax
  81dcee:	85 c0                	test   %eax,%eax
  81dcf0:	0f 84 e5 05 00 00    	je     81e2db <tcp_process+0xcd3>
  81dcf6:	80 7d fb 00          	cmpb   $0x0,-0x5(%rbp)
  81dcfa:	0f 84 db 05 00 00    	je     81e2db <tcp_process+0xcd3>
      tcp_ack_now(pcb);
  81dd00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dd04:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81dd08:	83 c8 02             	or     $0x2,%eax
  81dd0b:	89 c2                	mov    %eax,%edx
  81dd0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dd11:	88 50 2c             	mov    %dl,0x2c(%rax)
  81dd14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dd18:	48 89 c7             	mov    %rax,%rdi
  81dd1b:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  81dd22:	00 00 00 
  81dd25:	ff d0                	callq  *%rax
      pcb->state = CLOSE_WAIT;
  81dd27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dd2b:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
    }
    break;
  81dd32:	e9 a4 05 00 00       	jmpq   81e2db <tcp_process+0xcd3>
  case FIN_WAIT_1:
    tcp_receive(pcb);
  81dd37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dd3b:	48 89 c7             	mov    %rax,%rdi
  81dd3e:	48 b8 ef e2 81 00 00 	movabs $0x81e2ef,%rax
  81dd45:	00 00 00 
  81dd48:	ff d0                	callq  *%rax
    if (flags & TCP_FIN) {
  81dd4a:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81dd51:	00 00 00 
  81dd54:	0f b6 00             	movzbl (%rax),%eax
  81dd57:	0f b6 c0             	movzbl %al,%eax
  81dd5a:	83 e0 01             	and    $0x1,%eax
  81dd5d:	85 c0                	test   %eax,%eax
  81dd5f:	0f 84 bf 01 00 00    	je     81df24 <tcp_process+0x91c>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81dd65:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81dd6c:	00 00 00 
  81dd6f:	0f b6 00             	movzbl (%rax),%eax
  81dd72:	0f b6 c0             	movzbl %al,%eax
  81dd75:	83 e0 10             	and    $0x10,%eax
  81dd78:	85 c0                	test   %eax,%eax
  81dd7a:	0f 84 6d 01 00 00    	je     81deed <tcp_process+0x8e5>
  81dd80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dd84:	8b 50 60             	mov    0x60(%rax),%edx
  81dd87:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81dd8e:	00 00 00 
  81dd91:	8b 00                	mov    (%rax),%eax
  81dd93:	39 c2                	cmp    %eax,%edx
  81dd95:	0f 85 52 01 00 00    	jne    81deed <tcp_process+0x8e5>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  81dd9b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dd9f:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81dda3:	83 c8 02             	or     $0x2,%eax
  81dda6:	89 c2                	mov    %eax,%edx
  81dda8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ddac:	88 50 2c             	mov    %dl,0x2c(%rax)
  81ddaf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ddb3:	48 89 c7             	mov    %rax,%rdi
  81ddb6:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  81ddbd:	00 00 00 
  81ddc0:	ff d0                	callq  *%rax
        tcp_pcb_purge(pcb);
  81ddc2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ddc6:	48 89 c7             	mov    %rax,%rdi
  81ddc9:	48 b8 d4 09 81 00 00 	movabs $0x8109d4,%rax
  81ddd0:	00 00 00 
  81ddd3:	ff d0                	callq  *%rax
        TCP_RMV(&tcp_active_pcbs, pcb);
  81ddd5:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dddc:	00 00 00 
  81dddf:	48 8b 00             	mov    (%rax),%rax
  81dde2:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81dde6:	75 23                	jne    81de0b <tcp_process+0x803>
  81dde8:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81ddef:	00 00 00 
  81ddf2:	48 8b 00             	mov    (%rax),%rax
  81ddf5:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81ddf9:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81de00:	00 00 00 
  81de03:	48 89 10             	mov    %rdx,(%rax)
  81de06:	e9 94 00 00 00       	jmpq   81de9f <tcp_process+0x897>
  81de0b:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81de12:	00 00 00 
  81de15:	48 8b 10             	mov    (%rax),%rdx
  81de18:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81de1f:	00 00 00 
  81de22:	48 89 10             	mov    %rdx,(%rax)
  81de25:	eb 66                	jmp    81de8d <tcp_process+0x885>
  81de27:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81de2e:	00 00 00 
  81de31:	48 8b 00             	mov    (%rax),%rax
  81de34:	48 8b 40 10          	mov    0x10(%rax),%rax
  81de38:	48 85 c0             	test   %rax,%rax
  81de3b:	74 32                	je     81de6f <tcp_process+0x867>
  81de3d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81de44:	00 00 00 
  81de47:	48 8b 00             	mov    (%rax),%rax
  81de4a:	48 8b 40 10          	mov    0x10(%rax),%rax
  81de4e:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81de52:	75 1b                	jne    81de6f <tcp_process+0x867>
  81de54:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81de5b:	00 00 00 
  81de5e:	48 8b 00             	mov    (%rax),%rax
  81de61:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81de65:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81de69:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81de6d:	eb 30                	jmp    81de9f <tcp_process+0x897>
  81de6f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81de76:	00 00 00 
  81de79:	48 8b 00             	mov    (%rax),%rax
  81de7c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81de80:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81de87:	00 00 00 
  81de8a:	48 89 10             	mov    %rdx,(%rax)
  81de8d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81de94:	00 00 00 
  81de97:	48 8b 00             	mov    (%rax),%rax
  81de9a:	48 85 c0             	test   %rax,%rax
  81de9d:	75 88                	jne    81de27 <tcp_process+0x81f>
  81de9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dea3:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81deaa:	00 
        pcb->state = TIME_WAIT;
  81deab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81deaf:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
        TCP_REG(&tcp_tw_pcbs, pcb);
  81deb6:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81debd:	00 00 00 
  81dec0:	48 8b 10             	mov    (%rax),%rdx
  81dec3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dec7:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81decb:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81ded2:	00 00 00 
  81ded5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81ded9:	48 89 10             	mov    %rdx,(%rax)
  81dedc:	48 b8 8f 86 80 00 00 	movabs $0x80868f,%rax
  81dee3:	00 00 00 
  81dee6:	ff d0                	callq  *%rax
        pcb->state = CLOSING;
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      pcb->state = FIN_WAIT_2;
    }
    break;
  81dee8:	e9 f1 03 00 00       	jmpq   81e2de <tcp_process+0xcd6>
        tcp_pcb_purge(pcb);
        TCP_RMV(&tcp_active_pcbs, pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
  81deed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81def1:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81def5:	83 c8 02             	or     $0x2,%eax
  81def8:	89 c2                	mov    %eax,%edx
  81defa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81defe:	88 50 2c             	mov    %dl,0x2c(%rax)
  81df01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81df05:	48 89 c7             	mov    %rax,%rdi
  81df08:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  81df0f:	00 00 00 
  81df12:	ff d0                	callq  *%rax
        pcb->state = CLOSING;
  81df14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81df18:	c7 40 18 08 00 00 00 	movl   $0x8,0x18(%rax)
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      pcb->state = FIN_WAIT_2;
    }
    break;
  81df1f:	e9 ba 03 00 00       	jmpq   81e2de <tcp_process+0xcd6>
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
        pcb->state = CLOSING;
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81df24:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81df2b:	00 00 00 
  81df2e:	0f b6 00             	movzbl (%rax),%eax
  81df31:	0f b6 c0             	movzbl %al,%eax
  81df34:	83 e0 10             	and    $0x10,%eax
  81df37:	85 c0                	test   %eax,%eax
  81df39:	0f 84 9f 03 00 00    	je     81e2de <tcp_process+0xcd6>
  81df3f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81df43:	8b 50 60             	mov    0x60(%rax),%edx
  81df46:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81df4d:	00 00 00 
  81df50:	8b 00                	mov    (%rax),%eax
  81df52:	39 c2                	cmp    %eax,%edx
  81df54:	0f 85 84 03 00 00    	jne    81e2de <tcp_process+0xcd6>
      pcb->state = FIN_WAIT_2;
  81df5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81df5e:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%rax)
    }
    break;
  81df65:	e9 74 03 00 00       	jmpq   81e2de <tcp_process+0xcd6>
  case FIN_WAIT_2:
    tcp_receive(pcb);
  81df6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81df6e:	48 89 c7             	mov    %rax,%rdi
  81df71:	48 b8 ef e2 81 00 00 	movabs $0x81e2ef,%rax
  81df78:	00 00 00 
  81df7b:	ff d0                	callq  *%rax
    if (flags & TCP_FIN) {
  81df7d:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81df84:	00 00 00 
  81df87:	0f b6 00             	movzbl (%rax),%eax
  81df8a:	0f b6 c0             	movzbl %al,%eax
  81df8d:	83 e0 01             	and    $0x1,%eax
  81df90:	85 c0                	test   %eax,%eax
  81df92:	0f 84 49 03 00 00    	je     81e2e1 <tcp_process+0xcd9>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  81df98:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81df9c:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81dfa0:	83 c8 02             	or     $0x2,%eax
  81dfa3:	89 c2                	mov    %eax,%edx
  81dfa5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dfa9:	88 50 2c             	mov    %dl,0x2c(%rax)
  81dfac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dfb0:	48 89 c7             	mov    %rax,%rdi
  81dfb3:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  81dfba:	00 00 00 
  81dfbd:	ff d0                	callq  *%rax
      tcp_pcb_purge(pcb);
  81dfbf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dfc3:	48 89 c7             	mov    %rax,%rdi
  81dfc6:	48 b8 d4 09 81 00 00 	movabs $0x8109d4,%rax
  81dfcd:	00 00 00 
  81dfd0:	ff d0                	callq  *%rax
      TCP_RMV(&tcp_active_pcbs, pcb);
  81dfd2:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dfd9:	00 00 00 
  81dfdc:	48 8b 00             	mov    (%rax),%rax
  81dfdf:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81dfe3:	75 23                	jne    81e008 <tcp_process+0xa00>
  81dfe5:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dfec:	00 00 00 
  81dfef:	48 8b 00             	mov    (%rax),%rax
  81dff2:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81dff6:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dffd:	00 00 00 
  81e000:	48 89 10             	mov    %rdx,(%rax)
  81e003:	e9 94 00 00 00       	jmpq   81e09c <tcp_process+0xa94>
  81e008:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81e00f:	00 00 00 
  81e012:	48 8b 10             	mov    (%rax),%rdx
  81e015:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e01c:	00 00 00 
  81e01f:	48 89 10             	mov    %rdx,(%rax)
  81e022:	eb 66                	jmp    81e08a <tcp_process+0xa82>
  81e024:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e02b:	00 00 00 
  81e02e:	48 8b 00             	mov    (%rax),%rax
  81e031:	48 8b 40 10          	mov    0x10(%rax),%rax
  81e035:	48 85 c0             	test   %rax,%rax
  81e038:	74 32                	je     81e06c <tcp_process+0xa64>
  81e03a:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e041:	00 00 00 
  81e044:	48 8b 00             	mov    (%rax),%rax
  81e047:	48 8b 40 10          	mov    0x10(%rax),%rax
  81e04b:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81e04f:	75 1b                	jne    81e06c <tcp_process+0xa64>
  81e051:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e058:	00 00 00 
  81e05b:	48 8b 00             	mov    (%rax),%rax
  81e05e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81e062:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81e066:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81e06a:	eb 30                	jmp    81e09c <tcp_process+0xa94>
  81e06c:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e073:	00 00 00 
  81e076:	48 8b 00             	mov    (%rax),%rax
  81e079:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81e07d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e084:	00 00 00 
  81e087:	48 89 10             	mov    %rdx,(%rax)
  81e08a:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e091:	00 00 00 
  81e094:	48 8b 00             	mov    (%rax),%rax
  81e097:	48 85 c0             	test   %rax,%rax
  81e09a:	75 88                	jne    81e024 <tcp_process+0xa1c>
  81e09c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e0a0:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81e0a7:	00 
      pcb->state = TIME_WAIT;
  81e0a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e0ac:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81e0b3:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81e0ba:	00 00 00 
  81e0bd:	48 8b 10             	mov    (%rax),%rdx
  81e0c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e0c4:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81e0c8:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81e0cf:	00 00 00 
  81e0d2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81e0d6:	48 89 10             	mov    %rdx,(%rax)
  81e0d9:	48 b8 8f 86 80 00 00 	movabs $0x80868f,%rax
  81e0e0:	00 00 00 
  81e0e3:	ff d0                	callq  *%rax
    }
    break;
  81e0e5:	e9 f7 01 00 00       	jmpq   81e2e1 <tcp_process+0xcd9>
  case CLOSING:
    tcp_receive(pcb);
  81e0ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e0ee:	48 89 c7             	mov    %rax,%rdi
  81e0f1:	48 b8 ef e2 81 00 00 	movabs $0x81e2ef,%rax
  81e0f8:	00 00 00 
  81e0fb:	ff d0                	callq  *%rax
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81e0fd:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81e104:	00 00 00 
  81e107:	0f b6 00             	movzbl (%rax),%eax
  81e10a:	0f b6 c0             	movzbl %al,%eax
  81e10d:	83 e0 10             	and    $0x10,%eax
  81e110:	85 c0                	test   %eax,%eax
  81e112:	0f 84 cc 01 00 00    	je     81e2e4 <tcp_process+0xcdc>
  81e118:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e11c:	8b 50 60             	mov    0x60(%rax),%edx
  81e11f:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e126:	00 00 00 
  81e129:	8b 00                	mov    (%rax),%eax
  81e12b:	39 c2                	cmp    %eax,%edx
  81e12d:	0f 85 b1 01 00 00    	jne    81e2e4 <tcp_process+0xcdc>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  81e133:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e137:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e13b:	83 c8 02             	or     $0x2,%eax
  81e13e:	89 c2                	mov    %eax,%edx
  81e140:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e144:	88 50 2c             	mov    %dl,0x2c(%rax)
  81e147:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e14b:	48 89 c7             	mov    %rax,%rdi
  81e14e:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  81e155:	00 00 00 
  81e158:	ff d0                	callq  *%rax
      tcp_pcb_purge(pcb);
  81e15a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e15e:	48 89 c7             	mov    %rax,%rdi
  81e161:	48 b8 d4 09 81 00 00 	movabs $0x8109d4,%rax
  81e168:	00 00 00 
  81e16b:	ff d0                	callq  *%rax
      TCP_RMV(&tcp_active_pcbs, pcb);
  81e16d:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81e174:	00 00 00 
  81e177:	48 8b 00             	mov    (%rax),%rax
  81e17a:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81e17e:	75 23                	jne    81e1a3 <tcp_process+0xb9b>
  81e180:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81e187:	00 00 00 
  81e18a:	48 8b 00             	mov    (%rax),%rax
  81e18d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81e191:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81e198:	00 00 00 
  81e19b:	48 89 10             	mov    %rdx,(%rax)
  81e19e:	e9 94 00 00 00       	jmpq   81e237 <tcp_process+0xc2f>
  81e1a3:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81e1aa:	00 00 00 
  81e1ad:	48 8b 10             	mov    (%rax),%rdx
  81e1b0:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e1b7:	00 00 00 
  81e1ba:	48 89 10             	mov    %rdx,(%rax)
  81e1bd:	eb 66                	jmp    81e225 <tcp_process+0xc1d>
  81e1bf:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e1c6:	00 00 00 
  81e1c9:	48 8b 00             	mov    (%rax),%rax
  81e1cc:	48 8b 40 10          	mov    0x10(%rax),%rax
  81e1d0:	48 85 c0             	test   %rax,%rax
  81e1d3:	74 32                	je     81e207 <tcp_process+0xbff>
  81e1d5:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e1dc:	00 00 00 
  81e1df:	48 8b 00             	mov    (%rax),%rax
  81e1e2:	48 8b 40 10          	mov    0x10(%rax),%rax
  81e1e6:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81e1ea:	75 1b                	jne    81e207 <tcp_process+0xbff>
  81e1ec:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e1f3:	00 00 00 
  81e1f6:	48 8b 00             	mov    (%rax),%rax
  81e1f9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81e1fd:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81e201:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81e205:	eb 30                	jmp    81e237 <tcp_process+0xc2f>
  81e207:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e20e:	00 00 00 
  81e211:	48 8b 00             	mov    (%rax),%rax
  81e214:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81e218:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e21f:	00 00 00 
  81e222:	48 89 10             	mov    %rdx,(%rax)
  81e225:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e22c:	00 00 00 
  81e22f:	48 8b 00             	mov    (%rax),%rax
  81e232:	48 85 c0             	test   %rax,%rax
  81e235:	75 88                	jne    81e1bf <tcp_process+0xbb7>
  81e237:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e23b:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81e242:	00 
      pcb->state = TIME_WAIT;
  81e243:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e247:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81e24e:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81e255:	00 00 00 
  81e258:	48 8b 10             	mov    (%rax),%rdx
  81e25b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e25f:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81e263:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81e26a:	00 00 00 
  81e26d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81e271:	48 89 10             	mov    %rdx,(%rax)
  81e274:	48 b8 8f 86 80 00 00 	movabs $0x80868f,%rax
  81e27b:	00 00 00 
  81e27e:	ff d0                	callq  *%rax
    }
    break;
  81e280:	eb 62                	jmp    81e2e4 <tcp_process+0xcdc>
  case LAST_ACK:
    tcp_receive(pcb);
  81e282:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e286:	48 89 c7             	mov    %rax,%rdi
  81e289:	48 b8 ef e2 81 00 00 	movabs $0x81e2ef,%rax
  81e290:	00 00 00 
  81e293:	ff d0                	callq  *%rax
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81e295:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81e29c:	00 00 00 
  81e29f:	0f b6 00             	movzbl (%rax),%eax
  81e2a2:	0f b6 c0             	movzbl %al,%eax
  81e2a5:	83 e0 10             	and    $0x10,%eax
  81e2a8:	85 c0                	test   %eax,%eax
  81e2aa:	74 3b                	je     81e2e7 <tcp_process+0xcdf>
  81e2ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e2b0:	8b 50 60             	mov    0x60(%rax),%edx
  81e2b3:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e2ba:	00 00 00 
  81e2bd:	8b 00                	mov    (%rax),%eax
  81e2bf:	39 c2                	cmp    %eax,%edx
  81e2c1:	75 24                	jne    81e2e7 <tcp_process+0xcdf>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  81e2c3:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81e2ca:	00 00 00 
  81e2cd:	c6 00 10             	movb   $0x10,(%rax)
    }
    break;
  81e2d0:	eb 15                	jmp    81e2e7 <tcp_process+0xcdf>
  default:
    break;
  81e2d2:	90                   	nop
  81e2d3:	eb 13                	jmp    81e2e8 <tcp_process+0xce0>
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
  81e2d5:	90                   	nop
  81e2d6:	eb 10                	jmp    81e2e8 <tcp_process+0xce0>
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
  81e2d8:	90                   	nop
  81e2d9:	eb 0d                	jmp    81e2e8 <tcp_process+0xce0>
    accepted_inseq = tcp_receive(pcb);
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
      tcp_ack_now(pcb);
      pcb->state = CLOSE_WAIT;
    }
    break;
  81e2db:	90                   	nop
  81e2dc:	eb 0a                	jmp    81e2e8 <tcp_process+0xce0>
        pcb->state = CLOSING;
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      pcb->state = FIN_WAIT_2;
    }
    break;
  81e2de:	90                   	nop
  81e2df:	eb 07                	jmp    81e2e8 <tcp_process+0xce0>
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
  81e2e1:	90                   	nop
  81e2e2:	eb 04                	jmp    81e2e8 <tcp_process+0xce0>
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
  81e2e4:	90                   	nop
  81e2e5:	eb 01                	jmp    81e2e8 <tcp_process+0xce0>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
    }
    break;
  81e2e7:	90                   	nop
  default:
    break;
  }
  return ERR_OK;
  81e2e8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81e2ed:	c9                   	leaveq 
  81e2ee:	c3                   	retq   

000000000081e2ef <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  81e2ef:	55                   	push   %rbp
  81e2f0:	48 89 e5             	mov    %rsp,%rbp
  81e2f3:	41 55                	push   %r13
  81e2f5:	41 54                	push   %r12
  81e2f7:	53                   	push   %rbx
  81e2f8:	48 83 ec 58          	sub    $0x58,%rsp
  81e2fc:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  81e300:	c6 45 c1 00          	movb   $0x0,-0x3f(%rbp)

  if (flags & TCP_ACK) {
  81e304:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81e30b:	00 00 00 
  81e30e:	0f b6 00             	movzbl (%rax),%eax
  81e311:	0f b6 c0             	movzbl %al,%eax
  81e314:	83 e0 10             	and    $0x10,%eax
  81e317:	85 c0                	test   %eax,%eax
  81e319:	0f 84 85 09 00 00    	je     81eca4 <tcp_receive+0x9b5>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  81e31f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e323:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e327:	0f b7 d0             	movzwl %ax,%edx
  81e32a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e32e:	8b 40 6c             	mov    0x6c(%rax),%eax
  81e331:	01 d0                	add    %edx,%eax
  81e333:	89 45 bc             	mov    %eax,-0x44(%rbp)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  81e336:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e33a:	8b 50 6c             	mov    0x6c(%rax),%edx
  81e33d:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e344:	00 00 00 
  81e347:	8b 00                	mov    (%rax),%eax
  81e349:	29 c2                	sub    %eax,%edx
  81e34b:	89 d0                	mov    %edx,%eax
  81e34d:	85 c0                	test   %eax,%eax
  81e34f:	78 6b                	js     81e3bc <tcp_receive+0xcd>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81e351:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e355:	8b 50 6c             	mov    0x6c(%rax),%edx
  81e358:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e35f:	00 00 00 
  81e362:	8b 00                	mov    (%rax),%eax

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  81e364:	39 c2                	cmp    %eax,%edx
  81e366:	75 1b                	jne    81e383 <tcp_receive+0x94>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81e368:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e36c:	8b 50 70             	mov    0x70(%rax),%edx
  81e36f:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e376:	00 00 00 
  81e379:	8b 00                	mov    (%rax),%eax
  81e37b:	29 c2                	sub    %eax,%edx
  81e37d:	89 d0                	mov    %edx,%eax
  81e37f:	85 c0                	test   %eax,%eax
  81e381:	78 39                	js     81e3bc <tcp_receive+0xcd>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  81e383:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e387:	8b 50 70             	mov    0x70(%rax),%edx
  81e38a:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e391:	00 00 00 
  81e394:	8b 00                	mov    (%rax),%eax
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81e396:	39 c2                	cmp    %eax,%edx
  81e398:	0f 85 84 00 00 00    	jne    81e422 <tcp_receive+0x133>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  81e39e:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81e3a5:	00 00 00 
  81e3a8:	48 8b 00             	mov    (%rax),%rax
  81e3ab:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81e3af:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3b3:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e3b7:	66 39 c2             	cmp    %ax,%dx
  81e3ba:	76 66                	jbe    81e422 <tcp_receive+0x133>
      pcb->snd_wnd = tcphdr->wnd;
  81e3bc:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81e3c3:	00 00 00 
  81e3c6:	48 8b 00             	mov    (%rax),%rax
  81e3c9:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81e3cd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3d1:	66 89 50 68          	mov    %dx,0x68(%rax)
      pcb->snd_wl1 = seqno;
  81e3d5:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e3dc:	00 00 00 
  81e3df:	8b 10                	mov    (%rax),%edx
  81e3e1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3e5:	89 50 6c             	mov    %edx,0x6c(%rax)
      pcb->snd_wl2 = ackno;
  81e3e8:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e3ef:	00 00 00 
  81e3f2:	8b 10                	mov    (%rax),%edx
  81e3f4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3f8:	89 50 70             	mov    %edx,0x70(%rax)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  81e3fb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3ff:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e403:	66 85 c0             	test   %ax,%ax
  81e406:	74 1a                	je     81e422 <tcp_receive+0x133>
  81e408:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e40c:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  81e413:	84 c0                	test   %al,%al
  81e415:	74 0b                	je     81e422 <tcp_receive+0x133>
          pcb->persist_backoff = 0;
  81e417:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e41b:	c6 80 d8 00 00 00 00 	movb   $0x0,0xd8(%rax)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  81e422:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e426:	8b 50 54             	mov    0x54(%rax),%edx
  81e429:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e430:	00 00 00 
  81e433:	8b 00                	mov    (%rax),%eax
  81e435:	39 c2                	cmp    %eax,%edx
  81e437:	0f 85 72 01 00 00    	jne    81e5af <tcp_receive+0x2c0>
      pcb->acked = 0;
  81e43d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e441:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  81e447:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e44b:	8b 50 6c             	mov    0x6c(%rax),%edx
  81e44e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e452:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e456:	0f b7 c0             	movzwl %ax,%eax
  81e459:	01 d0                	add    %edx,%eax
  81e45b:	3b 45 bc             	cmp    -0x44(%rbp),%eax
  81e45e:	0f 85 68 06 00 00    	jne    81eacc <tcp_receive+0x7dd>
        ++pcb->dupacks;
  81e464:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e468:	0f b6 40 58          	movzbl 0x58(%rax),%eax
  81e46c:	8d 50 01             	lea    0x1(%rax),%edx
  81e46f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e473:	88 50 58             	mov    %dl,0x58(%rax)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  81e476:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e47a:	0f b6 40 58          	movzbl 0x58(%rax),%eax
  81e47e:	3c 02                	cmp    $0x2,%al
  81e480:	0f 86 46 06 00 00    	jbe    81eacc <tcp_receive+0x7dd>
  81e486:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e48a:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e491:	48 85 c0             	test   %rax,%rax
  81e494:	0f 84 32 06 00 00    	je     81eacc <tcp_receive+0x7dd>
          if (!(pcb->flags & TF_INFR)) {
  81e49a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e49e:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e4a2:	0f b6 c0             	movzbl %al,%eax
  81e4a5:	83 e0 04             	and    $0x4,%eax
  81e4a8:	85 c0                	test   %eax,%eax
  81e4aa:	0f 85 bd 00 00 00    	jne    81e56d <tcp_receive+0x27e>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  81e4b0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4b4:	48 89 c7             	mov    %rax,%rdi
  81e4b7:	48 b8 fe 48 81 00 00 	movabs $0x8148fe,%rax
  81e4be:	00 00 00 
  81e4c1:	ff d0                	callq  *%rax
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  81e4c3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4c7:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e4cb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4cf:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e4d3:	66 39 c2             	cmp    %ax,%dx
  81e4d6:	76 17                	jbe    81e4ef <tcp_receive+0x200>
              pcb->ssthresh = pcb->snd_wnd / 2;
  81e4d8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4dc:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e4e0:	66 d1 e8             	shr    %ax
  81e4e3:	89 c2                	mov    %eax,%edx
  81e4e5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4e9:	66 89 50 5c          	mov    %dx,0x5c(%rax)
  81e4ed:	eb 15                	jmp    81e504 <tcp_receive+0x215>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  81e4ef:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4f3:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e4f7:	66 d1 e8             	shr    %ax
  81e4fa:	89 c2                	mov    %eax,%edx
  81e4fc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e500:	66 89 50 5c          	mov    %dx,0x5c(%rax)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  81e504:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e508:	0f b7 40 5c          	movzwl 0x5c(%rax),%eax
  81e50c:	0f b7 d0             	movzwl %ax,%edx
  81e50f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e513:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e517:	0f b7 c0             	movzwl %ax,%eax
  81e51a:	01 c0                	add    %eax,%eax
  81e51c:	39 c2                	cmp    %eax,%edx
  81e51e:	7d 13                	jge    81e533 <tcp_receive+0x244>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  81e520:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e524:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e528:	8d 14 00             	lea    (%rax,%rax,1),%edx
  81e52b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e52f:	66 89 50 5c          	mov    %dx,0x5c(%rax)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  81e533:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e537:	0f b7 48 5c          	movzwl 0x5c(%rax),%ecx
  81e53b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e53f:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81e543:	89 d0                	mov    %edx,%eax
  81e545:	01 c0                	add    %eax,%eax
  81e547:	01 d0                	add    %edx,%eax
  81e549:	8d 14 01             	lea    (%rcx,%rax,1),%edx
  81e54c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e550:	66 89 50 5a          	mov    %dx,0x5a(%rax)
            pcb->flags |= TF_INFR;
  81e554:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e558:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e55c:	83 c8 04             	or     $0x4,%eax
  81e55f:	89 c2                	mov    %eax,%edx
  81e561:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e565:	88 50 2c             	mov    %dl,0x2c(%rax)
  81e568:	e9 5f 05 00 00       	jmpq   81eacc <tcp_receive+0x7dd>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81e56d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e571:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e575:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e579:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e57d:	01 c2                	add    %eax,%edx
  81e57f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e583:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e587:	66 39 c2             	cmp    %ax,%dx
  81e58a:	0f 86 3c 05 00 00    	jbe    81eacc <tcp_receive+0x7dd>
              pcb->cwnd += pcb->mss;
  81e590:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e594:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e598:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e59c:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e5a0:	01 c2                	add    %eax,%edx
  81e5a2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5a6:	66 89 50 5a          	mov    %dx,0x5a(%rax)
  81e5aa:	e9 1d 05 00 00       	jmpq   81eacc <tcp_receive+0x7dd>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  81e5af:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e5b6:	00 00 00 
  81e5b9:	8b 10                	mov    (%rax),%edx
  81e5bb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5bf:	8b 40 54             	mov    0x54(%rax),%eax
  81e5c2:	29 c2                	sub    %eax,%edx
  81e5c4:	89 d0                	mov    %edx,%eax
  81e5c6:	83 e8 01             	sub    $0x1,%eax
  81e5c9:	85 c0                	test   %eax,%eax
  81e5cb:	0f 88 a2 03 00 00    	js     81e973 <tcp_receive+0x684>
  81e5d1:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e5d8:	00 00 00 
  81e5db:	8b 10                	mov    (%rax),%edx
  81e5dd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5e1:	8b 40 64             	mov    0x64(%rax),%eax
  81e5e4:	29 c2                	sub    %eax,%edx
  81e5e6:	89 d0                	mov    %edx,%eax
  81e5e8:	85 c0                	test   %eax,%eax
  81e5ea:	0f 8f 83 03 00 00    	jg     81e973 <tcp_receive+0x684>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  81e5f0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5f4:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e5f8:	0f b6 c0             	movzbl %al,%eax
  81e5fb:	83 e0 04             	and    $0x4,%eax
  81e5fe:	85 c0                	test   %eax,%eax
  81e600:	74 24                	je     81e626 <tcp_receive+0x337>
        pcb->flags &= ~TF_INFR;
  81e602:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e606:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e60a:	83 e0 fb             	and    $0xfffffffb,%eax
  81e60d:	89 c2                	mov    %eax,%edx
  81e60f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e613:	88 50 2c             	mov    %dl,0x2c(%rax)
        pcb->cwnd = pcb->ssthresh;
  81e616:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e61a:	0f b7 50 5c          	movzwl 0x5c(%rax),%edx
  81e61e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e622:	66 89 50 5a          	mov    %dx,0x5a(%rax)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  81e626:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e62a:	c6 40 52 00          	movb   $0x0,0x52(%rax)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  81e62e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e632:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81e636:	66 c1 f8 03          	sar    $0x3,%ax
  81e63a:	89 c2                	mov    %eax,%edx
  81e63c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e640:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81e644:	01 d0                	add    %edx,%eax
  81e646:	89 c2                	mov    %eax,%edx
  81e648:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e64c:	66 89 50 50          	mov    %dx,0x50(%rax)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  81e650:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e657:	00 00 00 
  81e65a:	8b 00                	mov    (%rax),%eax
  81e65c:	89 c2                	mov    %eax,%edx
  81e65e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e662:	8b 40 54             	mov    0x54(%rax),%eax
  81e665:	29 c2                	sub    %eax,%edx
  81e667:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e66b:	66 89 50 78          	mov    %dx,0x78(%rax)

      pcb->snd_buf += pcb->acked;
  81e66f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e673:	0f b7 50 7a          	movzwl 0x7a(%rax),%edx
  81e677:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e67b:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  81e67f:	01 c2                	add    %eax,%edx
  81e681:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e685:	66 89 50 7a          	mov    %dx,0x7a(%rax)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  81e689:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e68d:	c6 40 58 00          	movb   $0x0,0x58(%rax)
      pcb->lastack = ackno;
  81e691:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e698:	00 00 00 
  81e69b:	8b 10                	mov    (%rax),%edx
  81e69d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6a1:	89 50 54             	mov    %edx,0x54(%rax)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  81e6a4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6a8:	8b 40 18             	mov    0x18(%rax),%eax
  81e6ab:	83 f8 03             	cmp    $0x3,%eax
  81e6ae:	0f 86 c0 01 00 00    	jbe    81e874 <tcp_receive+0x585>
        if (pcb->cwnd < pcb->ssthresh) {
  81e6b4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6b8:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e6bc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6c0:	0f b7 40 5c          	movzwl 0x5c(%rax),%eax
  81e6c4:	66 39 c2             	cmp    %ax,%dx
  81e6c7:	73 42                	jae    81e70b <tcp_receive+0x41c>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81e6c9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6cd:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e6d1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6d5:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e6d9:	01 c2                	add    %eax,%edx
  81e6db:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6df:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e6e3:	66 39 c2             	cmp    %ax,%dx
  81e6e6:	0f 86 88 01 00 00    	jbe    81e874 <tcp_receive+0x585>
            pcb->cwnd += pcb->mss;
  81e6ec:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6f0:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e6f4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6f8:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e6fc:	01 c2                	add    %eax,%edx
  81e6fe:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e702:	66 89 50 5a          	mov    %dx,0x5a(%rax)
  81e706:	e9 69 01 00 00       	jmpq   81e874 <tcp_receive+0x585>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  81e70b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e70f:	0f b7 48 5a          	movzwl 0x5a(%rax),%ecx
  81e713:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e717:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e71b:	0f b7 d0             	movzwl %ax,%edx
  81e71e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e722:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e726:	0f b7 c0             	movzwl %ax,%eax
  81e729:	0f af c2             	imul   %edx,%eax
  81e72c:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81e730:	0f b7 52 5a          	movzwl 0x5a(%rdx),%edx
  81e734:	0f b7 f2             	movzwl %dx,%esi
  81e737:	99                   	cltd   
  81e738:	f7 fe                	idiv   %esi
  81e73a:	01 c8                	add    %ecx,%eax
  81e73c:	66 89 45 ba          	mov    %ax,-0x46(%rbp)
          if (new_cwnd > pcb->cwnd) {
  81e740:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e744:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e748:	66 3b 45 ba          	cmp    -0x46(%rbp),%ax
  81e74c:	0f 83 22 01 00 00    	jae    81e874 <tcp_receive+0x585>
            pcb->cwnd = new_cwnd;
  81e752:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e756:	0f b7 55 ba          	movzwl -0x46(%rbp),%edx
  81e75a:	66 89 50 5a          	mov    %dx,0x5a(%rax)
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e75e:	e9 11 01 00 00       	jmpq   81e874 <tcp_receive+0x585>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  81e763:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e767:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e76e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        pcb->unacked = pcb->unacked->next;
  81e772:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e776:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e77d:	48 8b 10             	mov    (%rax),%rdx
  81e780:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e784:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  81e78b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e78f:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e793:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e797:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e79b:	48 89 c7             	mov    %rax,%rdi
  81e79e:	48 b8 02 df 80 00 00 	movabs $0x80df02,%rax
  81e7a5:	00 00 00 
  81e7a8:	ff d0                	callq  *%rax
  81e7aa:	0f b6 c0             	movzbl %al,%eax
  81e7ad:	66 39 c3             	cmp    %ax,%bx
  81e7b0:	73 2a                	jae    81e7dc <tcp_receive+0x4ed>
  81e7b2:	48 ba 48 3d 82 00 00 	movabs $0x823d48,%rdx
  81e7b9:	00 00 00 
  81e7bc:	be 56 03 00 00       	mov    $0x356,%esi
  81e7c1:	48 bf a7 3b 82 00 00 	movabs $0x823ba7,%rdi
  81e7c8:	00 00 00 
  81e7cb:	b8 00 00 00 00       	mov    $0x0,%eax
  81e7d0:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81e7d7:	00 00 00 
  81e7da:	ff d1                	callq  *%rcx
        pcb->snd_queuelen -= pbuf_clen(next->p);
  81e7dc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e7e0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e7e4:	48 89 c7             	mov    %rax,%rdi
  81e7e7:	48 b8 02 df 80 00 00 	movabs $0x80df02,%rax
  81e7ee:	00 00 00 
  81e7f1:	ff d0                	callq  *%rax
  81e7f3:	89 c1                	mov    %eax,%ecx
  81e7f5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7f9:	0f b7 50 7c          	movzwl 0x7c(%rax),%edx
  81e7fd:	0f b6 c1             	movzbl %cl,%eax
  81e800:	29 c2                	sub    %eax,%edx
  81e802:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e806:	66 89 50 7c          	mov    %dx,0x7c(%rax)
        tcp_seg_free(next);
  81e80a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e80e:	48 89 c7             	mov    %rax,%rdi
  81e811:	48 b8 a0 04 81 00 00 	movabs $0x8104a0,%rax
  81e818:	00 00 00 
  81e81b:	ff d0                	callq  *%rax

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  81e81d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e821:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81e825:	66 85 c0             	test   %ax,%ax
  81e828:	74 4a                	je     81e874 <tcp_receive+0x585>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  81e82a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e82e:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e835:	48 85 c0             	test   %rax,%rax
  81e838:	75 3a                	jne    81e874 <tcp_receive+0x585>
  81e83a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e83e:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e845:	48 85 c0             	test   %rax,%rax
  81e848:	75 2a                	jne    81e874 <tcp_receive+0x585>
  81e84a:	48 ba 70 3d 82 00 00 	movabs $0x823d70,%rdx
  81e851:	00 00 00 
  81e854:	be 5d 03 00 00       	mov    $0x35d,%esi
  81e859:	48 bf a7 3b 82 00 00 	movabs $0x823ba7,%rdi
  81e860:	00 00 00 
  81e863:	b8 00 00 00 00       	mov    $0x0,%eax
  81e868:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81e86f:	00 00 00 
  81e872:	ff d1                	callq  *%rcx
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e874:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e878:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e87f:	48 85 c0             	test   %rax,%rax
  81e882:	0f 84 bb 00 00 00    	je     81e943 <tcp_receive+0x654>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  81e888:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e88c:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e893:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e897:	8b 40 04             	mov    0x4(%rax),%eax
  81e89a:	89 c7                	mov    %eax,%edi
  81e89c:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  81e8a3:	00 00 00 
  81e8a6:	ff d0                	callq  *%rax
  81e8a8:	41 89 c4             	mov    %eax,%r12d
  81e8ab:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e8af:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e8b6:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e8ba:	0f b7 d8             	movzwl %ax,%ebx
  81e8bd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e8c1:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e8c8:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e8cc:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e8d0:	0f b7 c0             	movzwl %ax,%eax
  81e8d3:	89 c7                	mov    %eax,%edi
  81e8d5:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81e8dc:	00 00 00 
  81e8df:	ff d0                	callq  *%rax
  81e8e1:	0f b7 c0             	movzwl %ax,%eax
  81e8e4:	83 e0 01             	and    $0x1,%eax
  81e8e7:	85 c0                	test   %eax,%eax
  81e8e9:	75 2e                	jne    81e919 <tcp_receive+0x62a>
  81e8eb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e8ef:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e8f6:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e8fa:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e8fe:	0f b7 c0             	movzwl %ax,%eax
  81e901:	89 c7                	mov    %eax,%edi
  81e903:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81e90a:	00 00 00 
  81e90d:	ff d0                	callq  *%rax
  81e90f:	0f b7 c0             	movzwl %ax,%eax
  81e912:	83 e0 02             	and    $0x2,%eax
  81e915:	85 c0                	test   %eax,%eax
  81e917:	74 07                	je     81e920 <tcp_receive+0x631>
  81e919:	b8 01 00 00 00       	mov    $0x1,%eax
  81e91e:	eb 05                	jmp    81e925 <tcp_receive+0x636>
  81e920:	b8 00 00 00 00       	mov    $0x0,%eax
  81e925:	01 d8                	add    %ebx,%eax
  81e927:	41 8d 14 04          	lea    (%r12,%rax,1),%edx
  81e92b:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e932:	00 00 00 
  81e935:	8b 00                	mov    (%rax),%eax
  81e937:	29 c2                	sub    %eax,%edx
  81e939:	89 d0                	mov    %edx,%eax
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e93b:	85 c0                	test   %eax,%eax
  81e93d:	0f 8e 20 fe ff ff    	jle    81e763 <tcp_receive+0x474>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  81e943:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e947:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e94e:	48 85 c0             	test   %rax,%rax
  81e951:	75 0c                	jne    81e95f <tcp_receive+0x670>
        pcb->rtime = -1;
  81e953:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e957:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
  81e95d:	eb 0a                	jmp    81e969 <tcp_receive+0x67a>
      else
        pcb->rtime = 0;
  81e95f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e963:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

      pcb->polltmr = 0;
  81e969:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e96d:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)
  81e971:	eb 0a                	jmp    81e97d <tcp_receive+0x68e>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  81e973:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e977:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e97d:	e9 4a 01 00 00       	jmpq   81eacc <tcp_receive+0x7dd>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  81e982:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e986:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e98d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      pcb->unsent = pcb->unsent->next;
  81e991:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e995:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e99c:	48 8b 10             	mov    (%rax),%rdx
  81e99f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9a3:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  81e9aa:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9ae:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e9b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e9b6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e9ba:	48 89 c7             	mov    %rax,%rdi
  81e9bd:	48 b8 02 df 80 00 00 	movabs $0x80df02,%rax
  81e9c4:	00 00 00 
  81e9c7:	ff d0                	callq  *%rax
  81e9c9:	0f b6 c0             	movzbl %al,%eax
  81e9cc:	66 39 c3             	cmp    %ax,%bx
  81e9cf:	73 2a                	jae    81e9fb <tcp_receive+0x70c>
  81e9d1:	48 ba 48 3d 82 00 00 	movabs $0x823d48,%rdx
  81e9d8:	00 00 00 
  81e9db:	be 80 03 00 00       	mov    $0x380,%esi
  81e9e0:	48 bf a7 3b 82 00 00 	movabs $0x823ba7,%rdi
  81e9e7:	00 00 00 
  81e9ea:	b8 00 00 00 00       	mov    $0x0,%eax
  81e9ef:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81e9f6:	00 00 00 
  81e9f9:	ff d1                	callq  *%rcx
      pcb->snd_queuelen -= pbuf_clen(next->p);
  81e9fb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e9ff:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ea03:	48 89 c7             	mov    %rax,%rdi
  81ea06:	48 b8 02 df 80 00 00 	movabs $0x80df02,%rax
  81ea0d:	00 00 00 
  81ea10:	ff d0                	callq  *%rax
  81ea12:	89 c1                	mov    %eax,%ecx
  81ea14:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea18:	0f b7 50 7c          	movzwl 0x7c(%rax),%edx
  81ea1c:	0f b6 c1             	movzbl %cl,%eax
  81ea1f:	29 c2                	sub    %eax,%edx
  81ea21:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea25:	66 89 50 7c          	mov    %dx,0x7c(%rax)
      tcp_seg_free(next);
  81ea29:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ea2d:	48 89 c7             	mov    %rax,%rdi
  81ea30:	48 b8 a0 04 81 00 00 	movabs $0x8104a0,%rax
  81ea37:	00 00 00 
  81ea3a:	ff d0                	callq  *%rax
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  81ea3c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea40:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81ea44:	66 85 c0             	test   %ax,%ax
  81ea47:	74 4a                	je     81ea93 <tcp_receive+0x7a4>
        LWIP_ASSERT("tcp_receive: valid queue length",
  81ea49:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea4d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81ea54:	48 85 c0             	test   %rax,%rax
  81ea57:	75 3a                	jne    81ea93 <tcp_receive+0x7a4>
  81ea59:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea5d:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81ea64:	48 85 c0             	test   %rax,%rax
  81ea67:	75 2a                	jne    81ea93 <tcp_receive+0x7a4>
  81ea69:	48 ba 70 3d 82 00 00 	movabs $0x823d70,%rdx
  81ea70:	00 00 00 
  81ea73:	be 86 03 00 00       	mov    $0x386,%esi
  81ea78:	48 bf a7 3b 82 00 00 	movabs $0x823ba7,%rdi
  81ea7f:	00 00 00 
  81ea82:	b8 00 00 00 00       	mov    $0x0,%eax
  81ea87:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81ea8e:	00 00 00 
  81ea91:	ff d1                	callq  *%rcx
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  81ea93:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea97:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81ea9e:	48 85 c0             	test   %rax,%rax
  81eaa1:	74 29                	je     81eacc <tcp_receive+0x7dd>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  81eaa3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eaa7:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81eaae:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eab2:	8b 40 04             	mov    0x4(%rax),%eax
  81eab5:	89 c7                	mov    %eax,%edi
  81eab7:	48 b8 e2 30 81 00 00 	movabs $0x8130e2,%rax
  81eabe:	00 00 00 
  81eac1:	ff d0                	callq  *%rax
  81eac3:	89 c2                	mov    %eax,%edx
  81eac5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eac9:	89 50 60             	mov    %edx,0x60(%rax)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81eacc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ead0:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81ead7:	48 85 c0             	test   %rax,%rax
  81eada:	0f 84 d7 00 00 00    	je     81ebb7 <tcp_receive+0x8c8>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  81eae0:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81eae7:	00 00 00 
  81eaea:	8b 18                	mov    (%rax),%ebx
  81eaec:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eaf0:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81eaf7:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eafb:	8b 40 04             	mov    0x4(%rax),%eax
  81eafe:	89 c7                	mov    %eax,%edi
  81eb00:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  81eb07:	00 00 00 
  81eb0a:	ff d0                	callq  *%rax
  81eb0c:	41 89 c5             	mov    %eax,%r13d
  81eb0f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb13:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81eb1a:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81eb1e:	44 0f b7 e0          	movzwl %ax,%r12d
  81eb22:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb26:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81eb2d:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eb31:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81eb35:	0f b7 c0             	movzwl %ax,%eax
  81eb38:	89 c7                	mov    %eax,%edi
  81eb3a:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81eb41:	00 00 00 
  81eb44:	ff d0                	callq  *%rax
  81eb46:	0f b7 c0             	movzwl %ax,%eax
  81eb49:	83 e0 01             	and    $0x1,%eax
  81eb4c:	85 c0                	test   %eax,%eax
  81eb4e:	75 2e                	jne    81eb7e <tcp_receive+0x88f>
  81eb50:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb54:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81eb5b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eb5f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81eb63:	0f b7 c0             	movzwl %ax,%eax
  81eb66:	89 c7                	mov    %eax,%edi
  81eb68:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81eb6f:	00 00 00 
  81eb72:	ff d0                	callq  *%rax
  81eb74:	0f b7 c0             	movzwl %ax,%eax
  81eb77:	83 e0 02             	and    $0x2,%eax
  81eb7a:	85 c0                	test   %eax,%eax
  81eb7c:	74 07                	je     81eb85 <tcp_receive+0x896>
  81eb7e:	b8 01 00 00 00       	mov    $0x1,%eax
  81eb83:	eb 05                	jmp    81eb8a <tcp_receive+0x89b>
  81eb85:	b8 00 00 00 00       	mov    $0x0,%eax
  81eb8a:	44 01 e0             	add    %r12d,%eax
  81eb8d:	44 01 e8             	add    %r13d,%eax
  81eb90:	29 c3                	sub    %eax,%ebx
  81eb92:	89 d8                	mov    %ebx,%eax
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81eb94:	85 c0                	test   %eax,%eax
  81eb96:	78 1f                	js     81ebb7 <tcp_receive+0x8c8>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  81eb98:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81eb9f:	00 00 00 
  81eba2:	8b 10                	mov    (%rax),%edx
  81eba4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eba8:	8b 40 64             	mov    0x64(%rax),%eax
  81ebab:	29 c2                	sub    %eax,%edx
  81ebad:	89 d0                	mov    %edx,%eax
  81ebaf:	85 c0                	test   %eax,%eax
  81ebb1:	0f 8e cb fd ff ff    	jle    81e982 <tcp_receive+0x693>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  81ebb7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ebbb:	8b 40 44             	mov    0x44(%rax),%eax
  81ebbe:	85 c0                	test   %eax,%eax
  81ebc0:	0f 84 de 00 00 00    	je     81eca4 <tcp_receive+0x9b5>
  81ebc6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ebca:	8b 50 48             	mov    0x48(%rax),%edx
  81ebcd:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81ebd4:	00 00 00 
  81ebd7:	8b 00                	mov    (%rax),%eax
  81ebd9:	29 c2                	sub    %eax,%edx
  81ebdb:	89 d0                	mov    %edx,%eax
  81ebdd:	85 c0                	test   %eax,%eax
  81ebdf:	0f 89 bf 00 00 00    	jns    81eca4 <tcp_receive+0x9b5>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
  81ebe5:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81ebec:	00 00 00 
  81ebef:	8b 00                	mov    (%rax),%eax
  81ebf1:	89 c2                	mov    %eax,%edx
  81ebf3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ebf7:	8b 40 44             	mov    0x44(%rax),%eax
  81ebfa:	29 c2                	sub    %eax,%edx
  81ebfc:	89 d0                	mov    %edx,%eax
  81ebfe:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  81ec02:	0f b7 55 c2          	movzwl -0x3e(%rbp),%edx
  81ec06:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec0a:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81ec0e:	66 c1 f8 03          	sar    $0x3,%ax
  81ec12:	29 c2                	sub    %eax,%edx
  81ec14:	89 d0                	mov    %edx,%eax
  81ec16:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      pcb->sa += m;
  81ec1a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec1e:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81ec22:	89 c2                	mov    %eax,%edx
  81ec24:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81ec28:	01 d0                	add    %edx,%eax
  81ec2a:	89 c2                	mov    %eax,%edx
  81ec2c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec30:	66 89 50 4c          	mov    %dx,0x4c(%rax)
      if (m < 0) {
  81ec34:	66 83 7d c2 00       	cmpw   $0x0,-0x3e(%rbp)
  81ec39:	79 0a                	jns    81ec45 <tcp_receive+0x956>
        m = -m;
  81ec3b:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81ec3f:	f7 d8                	neg    %eax
  81ec41:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      }
      m = m - (pcb->sv >> 2);
  81ec45:	0f b7 55 c2          	movzwl -0x3e(%rbp),%edx
  81ec49:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec4d:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81ec51:	66 c1 f8 02          	sar    $0x2,%ax
  81ec55:	29 c2                	sub    %eax,%edx
  81ec57:	89 d0                	mov    %edx,%eax
  81ec59:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      pcb->sv += m;
  81ec5d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec61:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81ec65:	89 c2                	mov    %eax,%edx
  81ec67:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81ec6b:	01 d0                	add    %edx,%eax
  81ec6d:	89 c2                	mov    %eax,%edx
  81ec6f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec73:	66 89 50 4e          	mov    %dx,0x4e(%rax)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  81ec77:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec7b:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81ec7f:	66 c1 f8 03          	sar    $0x3,%ax
  81ec83:	89 c2                	mov    %eax,%edx
  81ec85:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec89:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81ec8d:	01 d0                	add    %edx,%eax
  81ec8f:	89 c2                	mov    %eax,%edx
  81ec91:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec95:	66 89 50 50          	mov    %dx,0x50(%rax)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  81ec99:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec9d:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  81eca4:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81ecab:	00 00 00 
  81ecae:	0f b7 00             	movzwl (%rax),%eax
  81ecb1:	66 85 c0             	test   %ax,%ax
  81ecb4:	0f 84 47 10 00 00    	je     81fd01 <tcp_receive+0x1a12>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  81ecba:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ecbe:	8b 50 30             	mov    0x30(%rax),%edx
  81ecc1:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ecc8:	00 00 00 
  81eccb:	8b 00                	mov    (%rax),%eax
  81eccd:	29 c2                	sub    %eax,%edx
  81eccf:	89 d0                	mov    %edx,%eax
  81ecd1:	83 e8 01             	sub    $0x1,%eax
  81ecd4:	85 c0                	test   %eax,%eax
  81ecd6:	0f 88 ad 02 00 00    	js     81ef89 <tcp_receive+0xc9a>
  81ecdc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ece0:	8b 50 30             	mov    0x30(%rax),%edx
  81ece3:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81ecea:	00 00 00 
  81eced:	0f b7 00             	movzwl (%rax),%eax
  81ecf0:	0f b7 c8             	movzwl %ax,%ecx
  81ecf3:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ecfa:	00 00 00 
  81ecfd:	8b 00                	mov    (%rax),%eax
  81ecff:	01 c8                	add    %ecx,%eax
  81ed01:	29 c2                	sub    %eax,%edx
  81ed03:	89 d0                	mov    %edx,%eax
  81ed05:	83 c0 01             	add    $0x1,%eax
  81ed08:	85 c0                	test   %eax,%eax
  81ed0a:	0f 8f 79 02 00 00    	jg     81ef89 <tcp_receive+0xc9a>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  81ed10:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed14:	8b 50 30             	mov    0x30(%rax),%edx
  81ed17:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ed1e:	00 00 00 
  81ed21:	8b 00                	mov    (%rax),%eax
  81ed23:	29 c2                	sub    %eax,%edx
  81ed25:	89 d0                	mov    %edx,%eax
  81ed27:	89 45 c4             	mov    %eax,-0x3c(%rbp)
      p = inseg.p;
  81ed2a:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ed31:	00 00 00 
  81ed34:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ed38:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  81ed3c:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ed43:	00 00 00 
  81ed46:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ed4a:	48 85 c0             	test   %rax,%rax
  81ed4d:	75 2a                	jne    81ed79 <tcp_receive+0xa8a>
  81ed4f:	48 ba 90 3d 82 00 00 	movabs $0x823d90,%rdx
  81ed56:	00 00 00 
  81ed59:	be e6 03 00 00       	mov    $0x3e6,%esi
  81ed5e:	48 bf a7 3b 82 00 00 	movabs $0x823ba7,%rdi
  81ed65:	00 00 00 
  81ed68:	b8 00 00 00 00       	mov    $0x0,%eax
  81ed6d:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81ed74:	00 00 00 
  81ed77:	ff d1                	callq  *%rcx
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  81ed79:	81 7d c4 fe 7f 00 00 	cmpl   $0x7ffe,-0x3c(%rbp)
  81ed80:	7e 2a                	jle    81edac <tcp_receive+0xabd>
  81ed82:	48 ba a0 3d 82 00 00 	movabs $0x823da0,%rdx
  81ed89:	00 00 00 
  81ed8c:	be e7 03 00 00       	mov    $0x3e7,%esi
  81ed91:	48 bf a7 3b 82 00 00 	movabs $0x823ba7,%rdi
  81ed98:	00 00 00 
  81ed9b:	b8 00 00 00 00       	mov    $0x0,%eax
  81eda0:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81eda7:	00 00 00 
  81edaa:	ff d1                	callq  *%rcx
      if (inseg.p->len < off) {
  81edac:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81edb3:	00 00 00 
  81edb6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81edba:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81edbe:	0f b7 c0             	movzwl %ax,%eax
  81edc1:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81edc4:	0f 8d eb 00 00 00    	jge    81eeb5 <tcp_receive+0xbc6>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  81edca:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81edd1:	00 00 00 
  81edd4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81edd8:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81eddc:	0f b7 c0             	movzwl %ax,%eax
  81eddf:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81ede2:	7d 2a                	jge    81ee0e <tcp_receive+0xb1f>
  81ede4:	48 ba af 3d 82 00 00 	movabs $0x823daf,%rdx
  81edeb:	00 00 00 
  81edee:	be e9 03 00 00       	mov    $0x3e9,%esi
  81edf3:	48 bf a7 3b 82 00 00 	movabs $0x823ba7,%rdi
  81edfa:	00 00 00 
  81edfd:	b8 00 00 00 00       	mov    $0x0,%eax
  81ee02:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81ee09:	00 00 00 
  81ee0c:	ff d1                	callq  *%rcx
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  81ee0e:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ee15:	00 00 00 
  81ee18:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ee1c:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81ee20:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  81ee23:	29 d0                	sub    %edx,%eax
  81ee25:	66 89 45 b8          	mov    %ax,-0x48(%rbp)
        while (p->len < off) {
  81ee29:	eb 2f                	jmp    81ee5a <tcp_receive+0xb6b>
          off -= p->len;
  81ee2b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ee2f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81ee33:	0f b7 c0             	movzwl %ax,%eax
  81ee36:	29 45 c4             	sub    %eax,-0x3c(%rbp)
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  81ee39:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ee3d:	0f b7 55 b8          	movzwl -0x48(%rbp),%edx
  81ee41:	66 89 50 10          	mov    %dx,0x10(%rax)
          p->len = 0;
  81ee45:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ee49:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
          p = p->next;
  81ee4f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ee53:	48 8b 00             	mov    (%rax),%rax
  81ee56:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  81ee5a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ee5e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81ee62:	0f b7 c0             	movzwl %ax,%eax
  81ee65:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81ee68:	7c c1                	jl     81ee2b <tcp_receive+0xb3c>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  81ee6a:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81ee6d:	f7 d8                	neg    %eax
  81ee6f:	0f bf d0             	movswl %ax,%edx
  81ee72:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ee76:	89 d6                	mov    %edx,%esi
  81ee78:	48 89 c7             	mov    %rax,%rdi
  81ee7b:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  81ee82:	00 00 00 
  81ee85:	ff d0                	callq  *%rax
  81ee87:	84 c0                	test   %al,%al
  81ee89:	74 7f                	je     81ef0a <tcp_receive+0xc1b>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  81ee8b:	48 ba bf 3d 82 00 00 	movabs $0x823dbf,%rdx
  81ee92:	00 00 00 
  81ee95:	be f6 03 00 00       	mov    $0x3f6,%esi
  81ee9a:	48 bf a7 3b 82 00 00 	movabs $0x823ba7,%rdi
  81eea1:	00 00 00 
  81eea4:	b8 00 00 00 00       	mov    $0x0,%eax
  81eea9:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81eeb0:	00 00 00 
  81eeb3:	ff d1                	callq  *%rcx
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  81eeb5:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81eeb8:	f7 d8                	neg    %eax
  81eeba:	0f bf d0             	movswl %ax,%edx
  81eebd:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81eec4:	00 00 00 
  81eec7:	48 8b 40 08          	mov    0x8(%rax),%rax
  81eecb:	89 d6                	mov    %edx,%esi
  81eecd:	48 89 c7             	mov    %rax,%rdi
  81eed0:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  81eed7:	00 00 00 
  81eeda:	ff d0                	callq  *%rax
  81eedc:	84 c0                	test   %al,%al
  81eede:	74 2a                	je     81ef0a <tcp_receive+0xc1b>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  81eee0:	48 ba bf 3d 82 00 00 	movabs $0x823dbf,%rdx
  81eee7:	00 00 00 
  81eeea:	be fb 03 00 00       	mov    $0x3fb,%esi
  81eeef:	48 bf a7 3b 82 00 00 	movabs $0x823ba7,%rdi
  81eef6:	00 00 00 
  81eef9:	b8 00 00 00 00       	mov    $0x0,%eax
  81eefe:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81ef05:	00 00 00 
  81ef08:	ff d1                	callq  *%rcx
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  81ef0a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ef0e:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81ef12:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ef19:	00 00 00 
  81ef1c:	48 89 50 10          	mov    %rdx,0x10(%rax)
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  81ef20:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ef27:	00 00 00 
  81ef2a:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  81ef2e:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ef35:	00 00 00 
  81ef38:	8b 00                	mov    (%rax),%eax
  81ef3a:	89 c1                	mov    %eax,%ecx
  81ef3c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ef40:	8b 40 30             	mov    0x30(%rax),%eax
  81ef43:	29 c1                	sub    %eax,%ecx
  81ef45:	89 c8                	mov    %ecx,%eax
  81ef47:	01 c2                	add    %eax,%edx
  81ef49:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ef50:	00 00 00 
  81ef53:	66 89 50 18          	mov    %dx,0x18(%rax)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  81ef57:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ef5e:	00 00 00 
  81ef61:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ef65:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81ef69:	8b 4a 30             	mov    0x30(%rdx),%ecx
  81ef6c:	48 ba d8 74 b5 00 00 	movabs $0xb574d8,%rdx
  81ef73:	00 00 00 
  81ef76:	89 0a                	mov    %ecx,(%rdx)
  81ef78:	48 ba d8 74 b5 00 00 	movabs $0xb574d8,%rdx
  81ef7f:	00 00 00 
  81ef82:	8b 12                	mov    (%rdx),%edx
  81ef84:	89 50 04             	mov    %edx,0x4(%rax)
  81ef87:	eb 42                	jmp    81efcb <tcp_receive+0xcdc>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  81ef89:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ef90:	00 00 00 
  81ef93:	8b 10                	mov    (%rax),%edx
  81ef95:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ef99:	8b 40 30             	mov    0x30(%rax),%eax
  81ef9c:	29 c2                	sub    %eax,%edx
  81ef9e:	89 d0                	mov    %edx,%eax
  81efa0:	85 c0                	test   %eax,%eax
  81efa2:	79 27                	jns    81efcb <tcp_receive+0xcdc>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  81efa4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efa8:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81efac:	83 c8 02             	or     $0x2,%eax
  81efaf:	89 c2                	mov    %eax,%edx
  81efb1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efb5:	88 50 2c             	mov    %dl,0x2c(%rax)
  81efb8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efbc:	48 89 c7             	mov    %rax,%rdi
  81efbf:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  81efc6:	00 00 00 
  81efc9:	ff d0                	callq  *%rax
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  81efcb:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81efd2:	00 00 00 
  81efd5:	8b 10                	mov    (%rax),%edx
  81efd7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efdb:	8b 40 30             	mov    0x30(%rax),%eax
  81efde:	29 c2                	sub    %eax,%edx
  81efe0:	89 d0                	mov    %edx,%eax
  81efe2:	85 c0                	test   %eax,%eax
  81efe4:	0f 88 ee 0c 00 00    	js     81fcd8 <tcp_receive+0x19e9>
  81efea:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81eff1:	00 00 00 
  81eff4:	8b 10                	mov    (%rax),%edx
  81eff6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81effa:	8b 48 30             	mov    0x30(%rax),%ecx
  81effd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f001:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81f005:	0f b7 c0             	movzwl %ax,%eax
  81f008:	01 c8                	add    %ecx,%eax
  81f00a:	29 c2                	sub    %eax,%edx
  81f00c:	89 d0                	mov    %edx,%eax
  81f00e:	83 c0 01             	add    $0x1,%eax
  81f011:	85 c0                	test   %eax,%eax
  81f013:	0f 8f bf 0c 00 00    	jg     81fcd8 <tcp_receive+0x19e9>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f019:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f01d:	8b 50 30             	mov    0x30(%rax),%edx
  81f020:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f027:	00 00 00 
  81f02a:	8b 00                	mov    (%rax),%eax
  81f02c:	39 c2                	cmp    %eax,%edx
  81f02e:	0f 85 42 07 00 00    	jne    81f776 <tcp_receive+0x1487>
        accepted_inseq = 1; 
  81f034:	c6 45 c1 01          	movb   $0x1,-0x3f(%rbp)
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  81f038:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f03c:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f043:	48 85 c0             	test   %rax,%rax
  81f046:	0f 84 4b 01 00 00    	je     81f197 <tcp_receive+0xea8>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  81f04c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f050:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f057:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f05b:	8b 50 04             	mov    0x4(%rax),%edx
  81f05e:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f065:	00 00 00 
  81f068:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f06c:	0f b7 c8             	movzwl %ax,%ecx
  81f06f:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f076:	00 00 00 
  81f079:	8b 00                	mov    (%rax),%eax
  81f07b:	01 c8                	add    %ecx,%eax
  81f07d:	29 c2                	sub    %eax,%edx
  81f07f:	89 d0                	mov    %edx,%eax
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  81f081:	85 c0                	test   %eax,%eax
  81f083:	0f 8f 0e 01 00 00    	jg     81f197 <tcp_receive+0xea8>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  81f089:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f08d:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f094:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f098:	66 85 c0             	test   %ax,%ax
  81f09b:	74 65                	je     81f102 <tcp_receive+0xe13>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  81f09d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f0a1:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f0a8:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f0ac:	8b 40 04             	mov    0x4(%rax),%eax
  81f0af:	89 c2                	mov    %eax,%edx
  81f0b1:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f0b8:	00 00 00 
  81f0bb:	8b 00                	mov    (%rax),%eax
  81f0bd:	29 c2                	sub    %eax,%edx
  81f0bf:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f0c6:	00 00 00 
  81f0c9:	66 89 50 18          	mov    %dx,0x18(%rax)
            pbuf_realloc(inseg.p, inseg.len);
  81f0cd:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f0d4:	00 00 00 
  81f0d7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f0db:	0f b7 d0             	movzwl %ax,%edx
  81f0de:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f0e5:	00 00 00 
  81f0e8:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f0ec:	89 d6                	mov    %edx,%esi
  81f0ee:	48 89 c7             	mov    %rax,%rdi
  81f0f1:	48 b8 3f d9 80 00 00 	movabs $0x80d93f,%rax
  81f0f8:	00 00 00 
  81f0fb:	ff d0                	callq  *%rax
  81f0fd:	e9 95 00 00 00       	jmpq   81f197 <tcp_receive+0xea8>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81f102:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f109:	00 00 00 
  81f10c:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f110:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f114:	0f b7 c0             	movzwl %ax,%eax
  81f117:	89 c7                	mov    %eax,%edi
  81f119:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81f120:	00 00 00 
  81f123:	ff d0                	callq  *%rax
  81f125:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  81f127:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f12b:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f132:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f136:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f13a:	0f b7 c0             	movzwl %ax,%eax
  81f13d:	89 c7                	mov    %eax,%edi
  81f13f:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81f146:	00 00 00 
  81f149:	ff d0                	callq  *%rax
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81f14b:	31 d8                	xor    %ebx,%eax
  81f14d:	0f b7 c0             	movzwl %ax,%eax
  81f150:	83 e0 03             	and    $0x3,%eax
  81f153:	85 c0                	test   %eax,%eax
  81f155:	75 40                	jne    81f197 <tcp_receive+0xea8>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  81f157:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f15b:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f162:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
              pcb->ooseq = pcb->ooseq->next;
  81f166:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f16a:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f171:	48 8b 10             	mov    (%rax),%rdx
  81f174:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f178:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  81f17f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  81f183:	48 89 c6             	mov    %rax,%rsi
  81f186:	bf 04 00 00 00       	mov    $0x4,%edi
  81f18b:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  81f192:	00 00 00 
  81f195:	ff d0                	callq  *%rax
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  81f197:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f19e:	00 00 00 
  81f1a1:	0f b7 58 18          	movzwl 0x18(%rax),%ebx
  81f1a5:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f1ac:	00 00 00 
  81f1af:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f1b3:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f1b7:	0f b7 c0             	movzwl %ax,%eax
  81f1ba:	89 c7                	mov    %eax,%edi
  81f1bc:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81f1c3:	00 00 00 
  81f1c6:	ff d0                	callq  *%rax
  81f1c8:	0f b7 c0             	movzwl %ax,%eax
  81f1cb:	83 e0 01             	and    $0x1,%eax
  81f1ce:	85 c0                	test   %eax,%eax
  81f1d0:	75 2d                	jne    81f1ff <tcp_receive+0xf10>
  81f1d2:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f1d9:	00 00 00 
  81f1dc:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f1e0:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f1e4:	0f b7 c0             	movzwl %ax,%eax
  81f1e7:	89 c7                	mov    %eax,%edi
  81f1e9:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81f1f0:	00 00 00 
  81f1f3:	ff d0                	callq  *%rax
  81f1f5:	0f b7 c0             	movzwl %ax,%eax
  81f1f8:	83 e0 02             	and    $0x2,%eax
  81f1fb:	85 c0                	test   %eax,%eax
  81f1fd:	74 07                	je     81f206 <tcp_receive+0xf17>
  81f1ff:	b8 01 00 00 00       	mov    $0x1,%eax
  81f204:	eb 05                	jmp    81f20b <tcp_receive+0xf1c>
  81f206:	b8 00 00 00 00       	mov    $0x0,%eax
  81f20b:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81f20e:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81f215:	00 00 00 
  81f218:	66 89 10             	mov    %dx,(%rax)

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  81f21b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f21f:	8b 40 18             	mov    0x18(%rax),%eax
  81f222:	83 f8 07             	cmp    $0x7,%eax
  81f225:	74 20                	je     81f247 <tcp_receive+0xf58>
          pcb->rcv_nxt += tcplen;
  81f227:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f22b:	8b 50 30             	mov    0x30(%rax),%edx
  81f22e:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81f235:	00 00 00 
  81f238:	0f b7 00             	movzwl (%rax),%eax
  81f23b:	0f b7 c0             	movzwl %ax,%eax
  81f23e:	01 c2                	add    %eax,%edx
  81f240:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f244:	89 50 30             	mov    %edx,0x30(%rax)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  81f247:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f24b:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  81f24f:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81f256:	00 00 00 
  81f259:	0f b7 00             	movzwl (%rax),%eax
  81f25c:	66 39 c2             	cmp    %ax,%dx
  81f25f:	73 0c                	jae    81f26d <tcp_receive+0xf7e>
          pcb->rcv_wnd = 0;
  81f261:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f265:	66 c7 40 34 00 00    	movw   $0x0,0x34(%rax)
  81f26b:	eb 1f                	jmp    81f28c <tcp_receive+0xf9d>
        } else {
          pcb->rcv_wnd -= tcplen;
  81f26d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f271:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  81f275:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81f27c:	00 00 00 
  81f27f:	0f b7 00             	movzwl (%rax),%eax
  81f282:	29 c2                	sub    %eax,%edx
  81f284:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f288:	66 89 50 34          	mov    %dx,0x34(%rax)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  81f28c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f290:	0f b7 50 36          	movzwl 0x36(%rax),%edx
  81f294:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81f29b:	00 00 00 
  81f29e:	0f b7 00             	movzwl (%rax),%eax
  81f2a1:	66 39 c2             	cmp    %ax,%dx
  81f2a4:	73 0c                	jae    81f2b2 <tcp_receive+0xfc3>
          pcb->rcv_ann_wnd = 0;
  81f2a6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2aa:	66 c7 40 36 00 00    	movw   $0x0,0x36(%rax)
  81f2b0:	eb 1f                	jmp    81f2d1 <tcp_receive+0xfe2>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  81f2b2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2b6:	0f b7 50 36          	movzwl 0x36(%rax),%edx
  81f2ba:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81f2c1:	00 00 00 
  81f2c4:	0f b7 00             	movzwl (%rax),%eax
  81f2c7:	29 c2                	sub    %eax,%edx
  81f2c9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2cd:	66 89 50 36          	mov    %dx,0x36(%rax)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  81f2d1:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f2d8:	00 00 00 
  81f2db:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f2df:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81f2e3:	66 85 c0             	test   %ax,%ax
  81f2e6:	74 2d                	je     81f315 <tcp_receive+0x1026>
          recv_data = inseg.p;
  81f2e8:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f2ef:	00 00 00 
  81f2f2:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81f2f6:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81f2fd:	00 00 00 
  81f300:	48 89 10             	mov    %rdx,(%rax)
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  81f303:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f30a:	00 00 00 
  81f30d:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81f314:	00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  81f315:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f31c:	00 00 00 
  81f31f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f323:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f327:	0f b7 c0             	movzwl %ax,%eax
  81f32a:	89 c7                	mov    %eax,%edi
  81f32c:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81f333:	00 00 00 
  81f336:	ff d0                	callq  *%rax
  81f338:	0f b7 c0             	movzwl %ax,%eax
  81f33b:	83 e0 01             	and    $0x1,%eax
  81f33e:	85 c0                	test   %eax,%eax
  81f340:	0f 84 94 03 00 00    	je     81f6da <tcp_receive+0x13eb>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  81f346:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81f34d:	00 00 00 
  81f350:	c6 00 20             	movb   $0x20,(%rax)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81f353:	e9 82 03 00 00       	jmpq   81f6da <tcp_receive+0x13eb>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
  81f358:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f35c:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f363:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
          seqno = pcb->ooseq->tcphdr->seqno;
  81f367:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f36b:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f372:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f376:	8b 50 04             	mov    0x4(%rax),%edx
  81f379:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f380:	00 00 00 
  81f383:	89 10                	mov    %edx,(%rax)

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  81f385:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f389:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f38d:	0f b7 d8             	movzwl %ax,%ebx
  81f390:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f394:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f398:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f39c:	0f b7 c0             	movzwl %ax,%eax
  81f39f:	89 c7                	mov    %eax,%edi
  81f3a1:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81f3a8:	00 00 00 
  81f3ab:	ff d0                	callq  *%rax
  81f3ad:	0f b7 c0             	movzwl %ax,%eax
  81f3b0:	83 e0 01             	and    $0x1,%eax
  81f3b3:	85 c0                	test   %eax,%eax
  81f3b5:	75 27                	jne    81f3de <tcp_receive+0x10ef>
  81f3b7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f3bb:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f3bf:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f3c3:	0f b7 c0             	movzwl %ax,%eax
  81f3c6:	89 c7                	mov    %eax,%edi
  81f3c8:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81f3cf:	00 00 00 
  81f3d2:	ff d0                	callq  *%rax
  81f3d4:	0f b7 c0             	movzwl %ax,%eax
  81f3d7:	83 e0 02             	and    $0x2,%eax
  81f3da:	85 c0                	test   %eax,%eax
  81f3dc:	74 07                	je     81f3e5 <tcp_receive+0x10f6>
  81f3de:	b8 01 00 00 00       	mov    $0x1,%eax
  81f3e3:	eb 05                	jmp    81f3ea <tcp_receive+0x10fb>
  81f3e5:	b8 00 00 00 00       	mov    $0x0,%eax
  81f3ea:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81f3ed:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f3f1:	8b 40 30             	mov    0x30(%rax),%eax
  81f3f4:	01 c2                	add    %eax,%edx
  81f3f6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f3fa:	89 50 30             	mov    %edx,0x30(%rax)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  81f3fd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f401:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81f405:	0f b7 d8             	movzwl %ax,%ebx
  81f408:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f40c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f410:	44 0f b7 e0          	movzwl %ax,%r12d
  81f414:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f418:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f41c:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f420:	0f b7 c0             	movzwl %ax,%eax
  81f423:	89 c7                	mov    %eax,%edi
  81f425:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81f42c:	00 00 00 
  81f42f:	ff d0                	callq  *%rax
  81f431:	0f b7 c0             	movzwl %ax,%eax
  81f434:	83 e0 01             	and    $0x1,%eax
  81f437:	85 c0                	test   %eax,%eax
  81f439:	75 27                	jne    81f462 <tcp_receive+0x1173>
  81f43b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f43f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f443:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f447:	0f b7 c0             	movzwl %ax,%eax
  81f44a:	89 c7                	mov    %eax,%edi
  81f44c:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81f453:	00 00 00 
  81f456:	ff d0                	callq  *%rax
  81f458:	0f b7 c0             	movzwl %ax,%eax
  81f45b:	83 e0 02             	and    $0x2,%eax
  81f45e:	85 c0                	test   %eax,%eax
  81f460:	74 07                	je     81f469 <tcp_receive+0x117a>
  81f462:	b8 01 00 00 00       	mov    $0x1,%eax
  81f467:	eb 05                	jmp    81f46e <tcp_receive+0x117f>
  81f469:	b8 00 00 00 00       	mov    $0x0,%eax
  81f46e:	44 01 e0             	add    %r12d,%eax
  81f471:	39 c3                	cmp    %eax,%ebx
  81f473:	7d 0c                	jge    81f481 <tcp_receive+0x1192>
            pcb->rcv_wnd = 0;
  81f475:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f479:	66 c7 40 34 00 00    	movw   $0x0,0x34(%rax)
  81f47f:	eb 7c                	jmp    81f4fd <tcp_receive+0x120e>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  81f481:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f485:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f489:	0f b7 d8             	movzwl %ax,%ebx
  81f48c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f490:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f494:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f498:	0f b7 c0             	movzwl %ax,%eax
  81f49b:	89 c7                	mov    %eax,%edi
  81f49d:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81f4a4:	00 00 00 
  81f4a7:	ff d0                	callq  *%rax
  81f4a9:	0f b7 c0             	movzwl %ax,%eax
  81f4ac:	83 e0 01             	and    $0x1,%eax
  81f4af:	85 c0                	test   %eax,%eax
  81f4b1:	75 27                	jne    81f4da <tcp_receive+0x11eb>
  81f4b3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f4b7:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f4bb:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f4bf:	0f b7 c0             	movzwl %ax,%eax
  81f4c2:	89 c7                	mov    %eax,%edi
  81f4c4:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81f4cb:	00 00 00 
  81f4ce:	ff d0                	callq  *%rax
  81f4d0:	0f b7 c0             	movzwl %ax,%eax
  81f4d3:	83 e0 02             	and    $0x2,%eax
  81f4d6:	85 c0                	test   %eax,%eax
  81f4d8:	74 07                	je     81f4e1 <tcp_receive+0x11f2>
  81f4da:	b8 01 00 00 00       	mov    $0x1,%eax
  81f4df:	eb 05                	jmp    81f4e6 <tcp_receive+0x11f7>
  81f4e1:	b8 00 00 00 00       	mov    $0x0,%eax
  81f4e6:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81f4e9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f4ed:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81f4f1:	29 d0                	sub    %edx,%eax
  81f4f3:	89 c2                	mov    %eax,%edx
  81f4f5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f4f9:	66 89 50 34          	mov    %dx,0x34(%rax)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  81f4fd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f501:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  81f505:	0f b7 d8             	movzwl %ax,%ebx
  81f508:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f50c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f510:	44 0f b7 e0          	movzwl %ax,%r12d
  81f514:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f518:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f51c:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f520:	0f b7 c0             	movzwl %ax,%eax
  81f523:	89 c7                	mov    %eax,%edi
  81f525:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81f52c:	00 00 00 
  81f52f:	ff d0                	callq  *%rax
  81f531:	0f b7 c0             	movzwl %ax,%eax
  81f534:	83 e0 01             	and    $0x1,%eax
  81f537:	85 c0                	test   %eax,%eax
  81f539:	75 27                	jne    81f562 <tcp_receive+0x1273>
  81f53b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f53f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f543:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f547:	0f b7 c0             	movzwl %ax,%eax
  81f54a:	89 c7                	mov    %eax,%edi
  81f54c:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81f553:	00 00 00 
  81f556:	ff d0                	callq  *%rax
  81f558:	0f b7 c0             	movzwl %ax,%eax
  81f55b:	83 e0 02             	and    $0x2,%eax
  81f55e:	85 c0                	test   %eax,%eax
  81f560:	74 07                	je     81f569 <tcp_receive+0x127a>
  81f562:	b8 01 00 00 00       	mov    $0x1,%eax
  81f567:	eb 05                	jmp    81f56e <tcp_receive+0x127f>
  81f569:	b8 00 00 00 00       	mov    $0x0,%eax
  81f56e:	44 01 e0             	add    %r12d,%eax
  81f571:	39 c3                	cmp    %eax,%ebx
  81f573:	7d 0c                	jge    81f581 <tcp_receive+0x1292>
            pcb->rcv_ann_wnd = 0;
  81f575:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f579:	66 c7 40 36 00 00    	movw   $0x0,0x36(%rax)
  81f57f:	eb 7c                	jmp    81f5fd <tcp_receive+0x130e>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  81f581:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f585:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f589:	0f b7 d8             	movzwl %ax,%ebx
  81f58c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f590:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f594:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f598:	0f b7 c0             	movzwl %ax,%eax
  81f59b:	89 c7                	mov    %eax,%edi
  81f59d:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81f5a4:	00 00 00 
  81f5a7:	ff d0                	callq  *%rax
  81f5a9:	0f b7 c0             	movzwl %ax,%eax
  81f5ac:	83 e0 01             	and    $0x1,%eax
  81f5af:	85 c0                	test   %eax,%eax
  81f5b1:	75 27                	jne    81f5da <tcp_receive+0x12eb>
  81f5b3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f5b7:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f5bb:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f5bf:	0f b7 c0             	movzwl %ax,%eax
  81f5c2:	89 c7                	mov    %eax,%edi
  81f5c4:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81f5cb:	00 00 00 
  81f5ce:	ff d0                	callq  *%rax
  81f5d0:	0f b7 c0             	movzwl %ax,%eax
  81f5d3:	83 e0 02             	and    $0x2,%eax
  81f5d6:	85 c0                	test   %eax,%eax
  81f5d8:	74 07                	je     81f5e1 <tcp_receive+0x12f2>
  81f5da:	b8 01 00 00 00       	mov    $0x1,%eax
  81f5df:	eb 05                	jmp    81f5e6 <tcp_receive+0x12f7>
  81f5e1:	b8 00 00 00 00       	mov    $0x0,%eax
  81f5e6:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81f5e9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f5ed:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  81f5f1:	29 d0                	sub    %edx,%eax
  81f5f3:	89 c2                	mov    %eax,%edx
  81f5f5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f5f9:	66 89 50 36          	mov    %dx,0x36(%rax)
          }

          if (cseg->p->tot_len > 0) {
  81f5fd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f601:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f605:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81f609:	66 85 c0             	test   %ax,%ax
  81f60c:	74 5c                	je     81f66a <tcp_receive+0x137b>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  81f60e:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81f615:	00 00 00 
  81f618:	48 8b 00             	mov    (%rax),%rax
  81f61b:	48 85 c0             	test   %rax,%rax
  81f61e:	74 29                	je     81f649 <tcp_receive+0x135a>
              pbuf_cat(recv_data, cseg->p);
  81f620:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f624:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81f628:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81f62f:	00 00 00 
  81f632:	48 8b 00             	mov    (%rax),%rax
  81f635:	48 89 d6             	mov    %rdx,%rsi
  81f638:	48 89 c7             	mov    %rax,%rdi
  81f63b:	48 b8 59 df 80 00 00 	movabs $0x80df59,%rax
  81f642:	00 00 00 
  81f645:	ff d0                	callq  *%rax
  81f647:	eb 15                	jmp    81f65e <tcp_receive+0x136f>
            } else {
              recv_data = cseg->p;
  81f649:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f64d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81f651:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81f658:	00 00 00 
  81f65b:	48 89 10             	mov    %rdx,(%rax)
            }
            cseg->p = NULL;
  81f65e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f662:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81f669:	00 
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  81f66a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f66e:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f672:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f676:	0f b7 c0             	movzwl %ax,%eax
  81f679:	89 c7                	mov    %eax,%edi
  81f67b:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81f682:	00 00 00 
  81f685:	ff d0                	callq  *%rax
  81f687:	0f b7 c0             	movzwl %ax,%eax
  81f68a:	83 e0 01             	and    $0x1,%eax
  81f68d:	85 c0                	test   %eax,%eax
  81f68f:	74 24                	je     81f6b5 <tcp_receive+0x13c6>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  81f691:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81f698:	00 00 00 
  81f69b:	c6 00 20             	movb   $0x20,(%rax)
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  81f69e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f6a2:	8b 40 18             	mov    0x18(%rax),%eax
  81f6a5:	83 f8 04             	cmp    $0x4,%eax
  81f6a8:	75 0b                	jne    81f6b5 <tcp_receive+0x13c6>
              pcb->state = CLOSE_WAIT;
  81f6aa:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f6ae:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
            } 
          }


          pcb->ooseq = cseg->next;
  81f6b5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f6b9:	48 8b 10             	mov    (%rax),%rdx
  81f6bc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f6c0:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
          tcp_seg_free(cseg);
  81f6c7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f6cb:	48 89 c7             	mov    %rax,%rdi
  81f6ce:	48 b8 a0 04 81 00 00 	movabs $0x8104a0,%rax
  81f6d5:	00 00 00 
  81f6d8:	ff d0                	callq  *%rax
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81f6da:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f6de:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f6e5:	48 85 c0             	test   %rax,%rax
  81f6e8:	74 21                	je     81f70b <tcp_receive+0x141c>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  81f6ea:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f6ee:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f6f5:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f6f9:	8b 50 04             	mov    0x4(%rax),%edx
  81f6fc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f700:	8b 40 30             	mov    0x30(%rax),%eax
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81f703:	39 c2                	cmp    %eax,%edx
  81f705:	0f 84 4d fc ff ff    	je     81f358 <tcp_receive+0x1069>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  81f70b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f70f:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f713:	0f b6 c0             	movzbl %al,%eax
  81f716:	83 e0 01             	and    $0x1,%eax
  81f719:	85 c0                	test   %eax,%eax
  81f71b:	74 40                	je     81f75d <tcp_receive+0x146e>
  81f71d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f721:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f725:	83 e0 fe             	and    $0xfffffffe,%eax
  81f728:	89 c2                	mov    %eax,%edx
  81f72a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f72e:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f731:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f735:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f739:	83 c8 02             	or     $0x2,%eax
  81f73c:	89 c2                	mov    %eax,%edx
  81f73e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f742:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f745:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f749:	48 89 c7             	mov    %rax,%rdi
  81f74c:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  81f753:	00 00 00 
  81f756:	ff d0                	callq  *%rax
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f758:	e9 11 06 00 00       	jmpq   81fd6e <tcp_receive+0x1a7f>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  81f75d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f761:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f765:	83 c8 01             	or     $0x1,%eax
  81f768:	89 c2                	mov    %eax,%edx
  81f76a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f76e:	88 50 2c             	mov    %dl,0x2c(%rax)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f771:	e9 f8 05 00 00       	jmpq   81fd6e <tcp_receive+0x1a7f>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  81f776:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f77a:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f77e:	83 c8 02             	or     $0x2,%eax
  81f781:	89 c2                	mov    %eax,%edx
  81f783:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f787:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f78a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f78e:	48 89 c7             	mov    %rax,%rdi
  81f791:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  81f798:	00 00 00 
  81f79b:	ff d0                	callq  *%rax
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  81f79d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f7a1:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f7a8:	48 85 c0             	test   %rax,%rax
  81f7ab:	75 29                	jne    81f7d6 <tcp_receive+0x14e7>
          pcb->ooseq = tcp_seg_copy(&inseg);
  81f7ad:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f7b4:	00 00 00 
  81f7b7:	48 b8 1b 05 81 00 00 	movabs $0x81051b,%rax
  81f7be:	00 00 00 
  81f7c1:	ff d0                	callq  *%rax
  81f7c3:	48 89 c2             	mov    %rax,%rdx
  81f7c6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f7ca:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f7d1:	e9 98 05 00 00       	jmpq   81fd6e <tcp_receive+0x1a7f>

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
  81f7d6:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  81f7dd:	00 
          for(next = pcb->ooseq; next != NULL; next = next->next) {
  81f7de:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f7e2:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f7e9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81f7ed:	e9 b8 04 00 00       	jmpq   81fcaa <tcp_receive+0x19bb>
            if (seqno == next->tcphdr->seqno) {
  81f7f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f7f6:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f7fa:	8b 50 04             	mov    0x4(%rax),%edx
  81f7fd:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f804:	00 00 00 
  81f807:	8b 00                	mov    (%rax),%eax
  81f809:	39 c2                	cmp    %eax,%edx
  81f80b:	0f 85 1f 01 00 00    	jne    81f930 <tcp_receive+0x1641>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  81f811:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f818:	00 00 00 
  81f81b:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  81f81f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f823:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f827:	66 39 c2             	cmp    %ax,%dx
  81f82a:	0f 86 8a 04 00 00    	jbe    81fcba <tcp_receive+0x19cb>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  81f830:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f837:	00 00 00 
  81f83a:	48 b8 1b 05 81 00 00 	movabs $0x81051b,%rax
  81f841:	00 00 00 
  81f844:	ff d0                	callq  *%rax
  81f846:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                if (cseg != NULL) {
  81f84a:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81f84f:	0f 84 6b 04 00 00    	je     81fcc0 <tcp_receive+0x19d1>
                  cseg->next = next->next;
  81f855:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f859:	48 8b 10             	mov    (%rax),%rdx
  81f85c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f860:	48 89 10             	mov    %rdx,(%rax)
                  if (prev != NULL) {
  81f863:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81f868:	74 0d                	je     81f877 <tcp_receive+0x1588>
                    prev->next = cseg;
  81f86a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f86e:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f872:	48 89 10             	mov    %rdx,(%rax)
  81f875:	eb 0f                	jmp    81f886 <tcp_receive+0x1597>
                  } else {
                    pcb->ooseq = cseg;
  81f877:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f87b:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f87f:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
                  }
                  tcp_seg_free(next);
  81f886:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f88a:	48 89 c7             	mov    %rax,%rdi
  81f88d:	48 b8 a0 04 81 00 00 	movabs $0x8104a0,%rax
  81f894:	00 00 00 
  81f897:	ff d0                	callq  *%rax
                  if (cseg->next != NULL) {
  81f899:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f89d:	48 8b 00             	mov    (%rax),%rax
  81f8a0:	48 85 c0             	test   %rax,%rax
  81f8a3:	0f 84 17 04 00 00    	je     81fcc0 <tcp_receive+0x19d1>
                    next = cseg->next;
  81f8a9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f8ad:	48 8b 00             	mov    (%rax),%rax
  81f8b0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  81f8b4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f8b8:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f8bc:	0f b7 d0             	movzwl %ax,%edx
  81f8bf:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f8c6:	00 00 00 
  81f8c9:	8b 00                	mov    (%rax),%eax
  81f8cb:	01 c2                	add    %eax,%edx
  81f8cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f8d1:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f8d5:	8b 40 04             	mov    0x4(%rax),%eax
  81f8d8:	29 c2                	sub    %eax,%edx
  81f8da:	89 d0                	mov    %edx,%eax
  81f8dc:	85 c0                	test   %eax,%eax
  81f8de:	0f 8e dc 03 00 00    	jle    81fcc0 <tcp_receive+0x19d1>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  81f8e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f8e8:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f8ec:	8b 40 04             	mov    0x4(%rax),%eax
  81f8ef:	89 c2                	mov    %eax,%edx
  81f8f1:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f8f8:	00 00 00 
  81f8fb:	8b 00                	mov    (%rax),%eax
  81f8fd:	29 c2                	sub    %eax,%edx
  81f8ff:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f903:	66 89 50 18          	mov    %dx,0x18(%rax)
                      pbuf_realloc(cseg->p, cseg->len);
  81f907:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f90b:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f90f:	0f b7 d0             	movzwl %ax,%edx
  81f912:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f916:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f91a:	89 d6                	mov    %edx,%esi
  81f91c:	48 89 c7             	mov    %rax,%rdi
  81f91f:	48 b8 3f d9 80 00 00 	movabs $0x80d93f,%rax
  81f926:	00 00 00 
  81f929:	ff d0                	callq  *%rax
                    }
                  }
                }
                break;
  81f92b:	e9 90 03 00 00       	jmpq   81fcc0 <tcp_receive+0x19d1>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  81f930:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81f935:	0f 85 f2 00 00 00    	jne    81fa2d <tcp_receive+0x173e>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  81f93b:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f942:	00 00 00 
  81f945:	8b 10                	mov    (%rax),%edx
  81f947:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f94b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f94f:	8b 40 04             	mov    0x4(%rax),%eax
  81f952:	29 c2                	sub    %eax,%edx
  81f954:	89 d0                	mov    %edx,%eax
  81f956:	85 c0                	test   %eax,%eax
  81f958:	0f 89 5d 02 00 00    	jns    81fbbb <tcp_receive+0x18cc>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  81f95e:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f965:	00 00 00 
  81f968:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f96c:	0f b7 d0             	movzwl %ax,%edx
  81f96f:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f976:	00 00 00 
  81f979:	8b 00                	mov    (%rax),%eax
  81f97b:	01 c2                	add    %eax,%edx
  81f97d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f981:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f985:	8b 40 04             	mov    0x4(%rax),%eax
  81f988:	29 c2                	sub    %eax,%edx
  81f98a:	89 d0                	mov    %edx,%eax
  81f98c:	85 c0                	test   %eax,%eax
  81f98e:	7e 59                	jle    81f9e9 <tcp_receive+0x16fa>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  81f990:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f994:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f998:	8b 40 04             	mov    0x4(%rax),%eax
  81f99b:	89 c2                	mov    %eax,%edx
  81f99d:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f9a4:	00 00 00 
  81f9a7:	8b 00                	mov    (%rax),%eax
  81f9a9:	29 c2                	sub    %eax,%edx
  81f9ab:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f9b2:	00 00 00 
  81f9b5:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(inseg.p, inseg.len);
  81f9b9:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f9c0:	00 00 00 
  81f9c3:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f9c7:	0f b7 d0             	movzwl %ax,%edx
  81f9ca:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f9d1:	00 00 00 
  81f9d4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f9d8:	89 d6                	mov    %edx,%esi
  81f9da:	48 89 c7             	mov    %rax,%rdi
  81f9dd:	48 b8 3f d9 80 00 00 	movabs $0x80d93f,%rax
  81f9e4:	00 00 00 
  81f9e7:	ff d0                	callq  *%rax
                  }
                  cseg = tcp_seg_copy(&inseg);
  81f9e9:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f9f0:	00 00 00 
  81f9f3:	48 b8 1b 05 81 00 00 	movabs $0x81051b,%rax
  81f9fa:	00 00 00 
  81f9fd:	ff d0                	callq  *%rax
  81f9ff:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                  if (cseg != NULL) {
  81fa03:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81fa08:	0f 84 b8 02 00 00    	je     81fcc6 <tcp_receive+0x19d7>
                    cseg->next = next;
  81fa0e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81fa12:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81fa16:	48 89 10             	mov    %rdx,(%rax)
                    pcb->ooseq = cseg;
  81fa19:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fa1d:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81fa21:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
                  }
                  break;
  81fa28:	e9 99 02 00 00       	jmpq   81fcc6 <tcp_receive+0x19d7>
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  81fa2d:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fa34:	00 00 00 
  81fa37:	8b 10                	mov    (%rax),%edx
  81fa39:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fa3d:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fa41:	8b 40 04             	mov    0x4(%rax),%eax
  81fa44:	29 c2                	sub    %eax,%edx
  81fa46:	89 d0                	mov    %edx,%eax
  81fa48:	83 e8 01             	sub    $0x1,%eax
  81fa4b:	85 c0                	test   %eax,%eax
  81fa4d:	0f 88 68 01 00 00    	js     81fbbb <tcp_receive+0x18cc>
  81fa53:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fa5a:	00 00 00 
  81fa5d:	8b 10                	mov    (%rax),%edx
  81fa5f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fa63:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fa67:	8b 40 04             	mov    0x4(%rax),%eax
  81fa6a:	29 c2                	sub    %eax,%edx
  81fa6c:	89 d0                	mov    %edx,%eax
  81fa6e:	83 c0 01             	add    $0x1,%eax
  81fa71:	85 c0                	test   %eax,%eax
  81fa73:	0f 8f 42 01 00 00    	jg     81fbbb <tcp_receive+0x18cc>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  81fa79:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81fa80:	00 00 00 
  81fa83:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81fa87:	0f b7 d0             	movzwl %ax,%edx
  81fa8a:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fa91:	00 00 00 
  81fa94:	8b 00                	mov    (%rax),%eax
  81fa96:	01 c2                	add    %eax,%edx
  81fa98:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fa9c:	48 8b 40 20          	mov    0x20(%rax),%rax
  81faa0:	8b 40 04             	mov    0x4(%rax),%eax
  81faa3:	29 c2                	sub    %eax,%edx
  81faa5:	89 d0                	mov    %edx,%eax
  81faa7:	85 c0                	test   %eax,%eax
  81faa9:	7e 59                	jle    81fb04 <tcp_receive+0x1815>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  81faab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81faaf:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fab3:	8b 40 04             	mov    0x4(%rax),%eax
  81fab6:	89 c2                	mov    %eax,%edx
  81fab8:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fabf:	00 00 00 
  81fac2:	8b 00                	mov    (%rax),%eax
  81fac4:	29 c2                	sub    %eax,%edx
  81fac6:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81facd:	00 00 00 
  81fad0:	66 89 50 18          	mov    %dx,0x18(%rax)
                  pbuf_realloc(inseg.p, inseg.len);
  81fad4:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81fadb:	00 00 00 
  81fade:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81fae2:	0f b7 d0             	movzwl %ax,%edx
  81fae5:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81faec:	00 00 00 
  81faef:	48 8b 40 08          	mov    0x8(%rax),%rax
  81faf3:	89 d6                	mov    %edx,%esi
  81faf5:	48 89 c7             	mov    %rax,%rdi
  81faf8:	48 b8 3f d9 80 00 00 	movabs $0x80d93f,%rax
  81faff:	00 00 00 
  81fb02:	ff d0                	callq  *%rax
                }

                cseg = tcp_seg_copy(&inseg);
  81fb04:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81fb0b:	00 00 00 
  81fb0e:	48 b8 1b 05 81 00 00 	movabs $0x81051b,%rax
  81fb15:	00 00 00 
  81fb18:	ff d0                	callq  *%rax
  81fb1a:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                if (cseg != NULL) {
  81fb1e:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81fb23:	0f 84 a3 01 00 00    	je     81fccc <tcp_receive+0x19dd>
                  cseg->next = next;
  81fb29:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81fb2d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81fb31:	48 89 10             	mov    %rdx,(%rax)
                  prev->next = cseg;
  81fb34:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fb38:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81fb3c:	48 89 10             	mov    %rdx,(%rax)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  81fb3f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fb43:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fb47:	8b 50 04             	mov    0x4(%rax),%edx
  81fb4a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fb4e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81fb52:	0f b7 c0             	movzwl %ax,%eax
  81fb55:	01 c2                	add    %eax,%edx
  81fb57:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fb5e:	00 00 00 
  81fb61:	8b 00                	mov    (%rax),%eax
  81fb63:	29 c2                	sub    %eax,%edx
  81fb65:	89 d0                	mov    %edx,%eax
  81fb67:	85 c0                	test   %eax,%eax
  81fb69:	0f 8e 5d 01 00 00    	jle    81fccc <tcp_receive+0x19dd>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  81fb6f:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fb76:	00 00 00 
  81fb79:	8b 00                	mov    (%rax),%eax
  81fb7b:	89 c2                	mov    %eax,%edx
  81fb7d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fb81:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fb85:	8b 40 04             	mov    0x4(%rax),%eax
  81fb88:	29 c2                	sub    %eax,%edx
  81fb8a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fb8e:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(prev->p, prev->len);
  81fb92:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fb96:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81fb9a:	0f b7 d0             	movzwl %ax,%edx
  81fb9d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fba1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fba5:	89 d6                	mov    %edx,%esi
  81fba7:	48 89 c7             	mov    %rax,%rdi
  81fbaa:	48 b8 3f d9 80 00 00 	movabs $0x80d93f,%rax
  81fbb1:	00 00 00 
  81fbb4:	ff d0                	callq  *%rax
                  }
                }
                break;
  81fbb6:	e9 11 01 00 00       	jmpq   81fccc <tcp_receive+0x19dd>
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  81fbbb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fbbf:	48 8b 00             	mov    (%rax),%rax
  81fbc2:	48 85 c0             	test   %rax,%rax
  81fbc5:	0f 85 cc 00 00 00    	jne    81fc97 <tcp_receive+0x19a8>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  81fbcb:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fbd2:	00 00 00 
  81fbd5:	8b 10                	mov    (%rax),%edx
  81fbd7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fbdb:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fbdf:	8b 40 04             	mov    0x4(%rax),%eax
  81fbe2:	29 c2                	sub    %eax,%edx
  81fbe4:	89 d0                	mov    %edx,%eax
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  81fbe6:	85 c0                	test   %eax,%eax
  81fbe8:	0f 8e a9 00 00 00    	jle    81fc97 <tcp_receive+0x19a8>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  81fbee:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81fbf5:	00 00 00 
  81fbf8:	48 b8 1b 05 81 00 00 	movabs $0x81051b,%rax
  81fbff:	00 00 00 
  81fc02:	ff d0                	callq  *%rax
  81fc04:	48 89 c2             	mov    %rax,%rdx
  81fc07:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fc0b:	48 89 10             	mov    %rdx,(%rax)
                if (next->next != NULL) {
  81fc0e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fc12:	48 8b 00             	mov    (%rax),%rax
  81fc15:	48 85 c0             	test   %rax,%rax
  81fc18:	0f 84 b4 00 00 00    	je     81fcd2 <tcp_receive+0x19e3>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  81fc1e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fc22:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fc26:	8b 50 04             	mov    0x4(%rax),%edx
  81fc29:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fc2d:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81fc31:	0f b7 c0             	movzwl %ax,%eax
  81fc34:	01 c2                	add    %eax,%edx
  81fc36:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fc3d:	00 00 00 
  81fc40:	8b 00                	mov    (%rax),%eax
  81fc42:	29 c2                	sub    %eax,%edx
  81fc44:	89 d0                	mov    %edx,%eax
  81fc46:	85 c0                	test   %eax,%eax
  81fc48:	0f 8e 84 00 00 00    	jle    81fcd2 <tcp_receive+0x19e3>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  81fc4e:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fc55:	00 00 00 
  81fc58:	8b 00                	mov    (%rax),%eax
  81fc5a:	89 c2                	mov    %eax,%edx
  81fc5c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fc60:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fc64:	8b 40 04             	mov    0x4(%rax),%eax
  81fc67:	29 c2                	sub    %eax,%edx
  81fc69:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fc6d:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(next->p, next->len);
  81fc71:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fc75:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81fc79:	0f b7 d0             	movzwl %ax,%edx
  81fc7c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fc80:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fc84:	89 d6                	mov    %edx,%esi
  81fc86:	48 89 c7             	mov    %rax,%rdi
  81fc89:	48 b8 3f d9 80 00 00 	movabs $0x80d93f,%rax
  81fc90:	00 00 00 
  81fc93:	ff d0                	callq  *%rax
                  }
                }
                break;
  81fc95:	eb 3b                	jmp    81fcd2 <tcp_receive+0x19e3>
              }
            }
            prev = next;
  81fc97:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fc9b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
  81fc9f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fca3:	48 8b 00             	mov    (%rax),%rax
  81fca6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81fcaa:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81fcaf:	0f 85 3d fb ff ff    	jne    81f7f2 <tcp_receive+0x1503>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81fcb5:	e9 b4 00 00 00       	jmpq   81fd6e <tcp_receive+0x1a7f>
                break;
              } else {
                /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
  81fcba:	90                   	nop
  81fcbb:	e9 ae 00 00 00       	jmpq   81fd6e <tcp_receive+0x1a7f>
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
                      pbuf_realloc(cseg->p, cseg->len);
                    }
                  }
                }
                break;
  81fcc0:	90                   	nop
  81fcc1:	e9 a8 00 00 00       	jmpq   81fd6e <tcp_receive+0x1a7f>
                  cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
                    cseg->next = next;
                    pcb->ooseq = cseg;
                  }
                  break;
  81fcc6:	90                   	nop
  81fcc7:	e9 a2 00 00 00       	jmpq   81fd6e <tcp_receive+0x1a7f>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
                    pbuf_realloc(prev->p, prev->len);
                  }
                }
                break;
  81fccc:	90                   	nop
  81fccd:	e9 9c 00 00 00       	jmpq   81fd6e <tcp_receive+0x1a7f>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
                    pbuf_realloc(next->p, next->len);
                  }
                }
                break;
  81fcd2:	90                   	nop
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81fcd3:	e9 96 00 00 00       	jmpq   81fd6e <tcp_receive+0x1a7f>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  81fcd8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fcdc:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81fce0:	83 c8 02             	or     $0x2,%eax
  81fce3:	89 c2                	mov    %eax,%edx
  81fce5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fce9:	88 50 2c             	mov    %dl,0x2c(%rax)
  81fcec:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fcf0:	48 89 c7             	mov    %rax,%rdi
  81fcf3:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  81fcfa:	00 00 00 
  81fcfd:	ff d0                	callq  *%rax
  81fcff:	eb 6d                	jmp    81fd6e <tcp_receive+0x1a7f>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  81fd01:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fd08:	00 00 00 
  81fd0b:	8b 10                	mov    (%rax),%edx
  81fd0d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fd11:	8b 40 30             	mov    0x30(%rax),%eax
  81fd14:	29 c2                	sub    %eax,%edx
  81fd16:	89 d0                	mov    %edx,%eax
  81fd18:	85 c0                	test   %eax,%eax
  81fd1a:	78 2b                	js     81fd47 <tcp_receive+0x1a58>
  81fd1c:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fd23:	00 00 00 
  81fd26:	8b 10                	mov    (%rax),%edx
  81fd28:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fd2c:	8b 48 30             	mov    0x30(%rax),%ecx
  81fd2f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fd33:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81fd37:	0f b7 c0             	movzwl %ax,%eax
  81fd3a:	01 c8                	add    %ecx,%eax
  81fd3c:	29 c2                	sub    %eax,%edx
  81fd3e:	89 d0                	mov    %edx,%eax
  81fd40:	83 c0 01             	add    $0x1,%eax
  81fd43:	85 c0                	test   %eax,%eax
  81fd45:	7e 27                	jle    81fd6e <tcp_receive+0x1a7f>
      tcp_ack_now(pcb);
  81fd47:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fd4b:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81fd4f:	83 c8 02             	or     $0x2,%eax
  81fd52:	89 c2                	mov    %eax,%edx
  81fd54:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fd58:	88 50 2c             	mov    %dl,0x2c(%rax)
  81fd5b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fd5f:	48 89 c7             	mov    %rax,%rdi
  81fd62:	48 b8 e9 3c 81 00 00 	movabs $0x813ce9,%rax
  81fd69:	00 00 00 
  81fd6c:	ff d0                	callq  *%rax
    }
  }
  return accepted_inseq;
  81fd6e:	0f b6 45 c1          	movzbl -0x3f(%rbp),%eax
}
  81fd72:	48 83 c4 58          	add    $0x58,%rsp
  81fd76:	5b                   	pop    %rbx
  81fd77:	41 5c                	pop    %r12
  81fd79:	41 5d                	pop    %r13
  81fd7b:	5d                   	pop    %rbp
  81fd7c:	c3                   	retq   

000000000081fd7d <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  81fd7d:	55                   	push   %rbp
  81fd7e:	48 89 e5             	mov    %rsp,%rbp
  81fd81:	53                   	push   %rbx
  81fd82:	48 83 ec 38          	sub    $0x38,%rsp
  81fd86:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  81fd8a:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81fd91:	00 00 00 
  81fd94:	48 8b 00             	mov    (%rax),%rax
  81fd97:	48 83 c0 14          	add    $0x14,%rax
  81fd9b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  81fd9f:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81fda6:	00 00 00 
  81fda9:	48 8b 00             	mov    (%rax),%rax
  81fdac:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81fdb0:	0f b7 c0             	movzwl %ax,%eax
  81fdb3:	89 c7                	mov    %eax,%edi
  81fdb5:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81fdbc:	00 00 00 
  81fdbf:	ff d0                	callq  *%rax
  81fdc1:	66 c1 e8 0c          	shr    $0xc,%ax
  81fdc5:	66 83 f8 05          	cmp    $0x5,%ax
  81fdc9:	0f 86 14 01 00 00    	jbe    81fee3 <tcp_parseopt+0x166>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  81fdcf:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  81fdd3:	e9 ca 00 00 00       	jmpq   81fea2 <tcp_parseopt+0x125>
      opt = opts[c];
  81fdd8:	0f b6 55 ef          	movzbl -0x11(%rbp),%edx
  81fddc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fde0:	48 01 d0             	add    %rdx,%rax
  81fde3:	0f b6 00             	movzbl (%rax),%eax
  81fde6:	88 45 df             	mov    %al,-0x21(%rbp)
      if (opt == 0x00) {
  81fde9:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  81fded:	0f 84 ec 00 00 00    	je     81fedf <tcp_parseopt+0x162>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  81fdf3:	80 7d df 01          	cmpb   $0x1,-0x21(%rbp)
  81fdf7:	75 09                	jne    81fe02 <tcp_parseopt+0x85>
        ++c;
  81fdf9:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  81fdfd:	e9 a0 00 00 00       	jmpq   81fea2 <tcp_parseopt+0x125>
        /* NOP option. */
      } else if (opt == 0x02 &&
  81fe02:	80 7d df 02          	cmpb   $0x2,-0x21(%rbp)
  81fe06:	75 6f                	jne    81fe77 <tcp_parseopt+0xfa>
        opts[c + 1] == 0x04) {
  81fe08:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81fe0c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  81fe10:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fe14:	48 01 d0             	add    %rdx,%rax
  81fe17:	0f b6 00             	movzbl (%rax),%eax
        /* End of options. */
        break;
      } else if (opt == 0x01) {
        ++c;
        /* NOP option. */
      } else if (opt == 0x02 &&
  81fe1a:	3c 04                	cmp    $0x4,%al
  81fe1c:	75 59                	jne    81fe77 <tcp_parseopt+0xfa>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  81fe1e:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81fe22:	48 8d 50 02          	lea    0x2(%rax),%rdx
  81fe26:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fe2a:	48 01 d0             	add    %rdx,%rax
  81fe2d:	0f b6 00             	movzbl (%rax),%eax
  81fe30:	0f b6 c0             	movzbl %al,%eax
  81fe33:	c1 e0 08             	shl    $0x8,%eax
  81fe36:	89 c1                	mov    %eax,%ecx
  81fe38:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81fe3c:	48 8d 50 03          	lea    0x3(%rax),%rdx
  81fe40:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fe44:	48 01 d0             	add    %rdx,%rax
  81fe47:	0f b6 00             	movzbl (%rax),%eax
  81fe4a:	0f b6 c0             	movzbl %al,%eax
  81fe4d:	09 c8                	or     %ecx,%eax
  81fe4f:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  81fe53:	66 81 7d dc b4 05    	cmpw   $0x5b4,-0x24(%rbp)
  81fe59:	77 0d                	ja     81fe68 <tcp_parseopt+0xeb>
  81fe5b:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  81fe60:	74 06                	je     81fe68 <tcp_parseopt+0xeb>
  81fe62:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  81fe66:	eb 05                	jmp    81fe6d <tcp_parseopt+0xf0>
  81fe68:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  81fe6d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81fe71:	66 89 42 40          	mov    %ax,0x40(%rdx)

        /* And we are done processing options. */
        break;
  81fe75:	eb 6c                	jmp    81fee3 <tcp_parseopt+0x166>
      } else {
        if (opts[c + 1] == 0) {
  81fe77:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81fe7b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  81fe7f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fe83:	48 01 d0             	add    %rdx,%rax
  81fe86:	0f b6 00             	movzbl (%rax),%eax
  81fe89:	84 c0                	test   %al,%al
  81fe8b:	74 55                	je     81fee2 <tcp_parseopt+0x165>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  81fe8d:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81fe91:	48 8d 50 01          	lea    0x1(%rax),%rdx
  81fe95:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fe99:	48 01 d0             	add    %rdx,%rax
  81fe9c:	0f b6 00             	movzbl (%rax),%eax
  81fe9f:	00 45 ef             	add    %al,-0x11(%rbp)

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  81fea2:	0f b6 5d ef          	movzbl -0x11(%rbp),%ebx
  81fea6:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81fead:	00 00 00 
  81feb0:	48 8b 00             	mov    (%rax),%rax
  81feb3:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81feb7:	0f b7 c0             	movzwl %ax,%eax
  81feba:	89 c7                	mov    %eax,%edi
  81febc:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81fec3:	00 00 00 
  81fec6:	ff d0                	callq  *%rax
  81fec8:	66 c1 e8 0c          	shr    $0xc,%ax
  81fecc:	0f b7 c0             	movzwl %ax,%eax
  81fecf:	83 e8 05             	sub    $0x5,%eax
  81fed2:	c1 e0 02             	shl    $0x2,%eax
  81fed5:	39 c3                	cmp    %eax,%ebx
  81fed7:	0f 8c fb fe ff ff    	jl     81fdd8 <tcp_parseopt+0x5b>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  81fedd:	eb 04                	jmp    81fee3 <tcp_parseopt+0x166>
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
      if (opt == 0x00) {
        /* End of options. */
        break;
  81fedf:	90                   	nop
  81fee0:	eb 01                	jmp    81fee3 <tcp_parseopt+0x166>
        break;
      } else {
        if (opts[c + 1] == 0) {
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          break;
  81fee2:	90                   	nop
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  81fee3:	90                   	nop
  81fee4:	48 83 c4 38          	add    $0x38,%rsp
  81fee8:	5b                   	pop    %rbx
  81fee9:	5d                   	pop    %rbp
  81feea:	c3                   	retq   

000000000081feeb <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  81feeb:	55                   	push   %rbp
  81feec:	48 89 e5             	mov    %rsp,%rbp
  81feef:	48 83 ec 40          	sub    $0x40,%rsp
  81fef3:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81fef7:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
  81fefb:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  81feff:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ff03:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ff07:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  proto = IPH_PROTO(iphdr);
  81ff0b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81ff0f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81ff13:	0f b7 c0             	movzwl %ax,%eax
  81ff16:	89 c7                	mov    %eax,%edi
  81ff18:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  81ff1f:	00 00 00 
  81ff22:	ff d0                	callq  *%rax
  81ff24:	66 25 ff 00          	and    $0xff,%ax
  81ff28:	66 89 45 de          	mov    %ax,-0x22(%rbp)

  prev = NULL;
  81ff2c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  81ff33:	00 
  pcb = raw_pcbs;
  81ff34:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81ff3b:	00 00 00 
  81ff3e:	48 8b 00             	mov    (%rax),%rax
  81ff41:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  81ff45:	e9 a3 00 00 00       	jmpq   81ffed <raw_input+0x102>
    if (pcb->protocol == proto) {
  81ff4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ff4e:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81ff52:	0f b6 d0             	movzbl %al,%edx
  81ff55:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  81ff59:	39 c2                	cmp    %eax,%edx
  81ff5b:	75 7c                	jne    81ffd9 <raw_input+0xee>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  81ff5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ff61:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ff65:	48 85 c0             	test   %rax,%rax
  81ff68:	74 6f                	je     81ffd9 <raw_input+0xee>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  81ff6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ff6e:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ff72:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81ff76:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  81ff7a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81ff7e:	48 8b 7a 28          	mov    0x28(%rdx),%rdi
  81ff82:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81ff86:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81ff8a:	ff d0                	callq  *%rax
  81ff8c:	84 c0                	test   %al,%al
  81ff8e:	74 49                	je     81ffd9 <raw_input+0xee>
        {
          /* receive function ate the packet */
          p = NULL;
  81ff90:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  81ff97:	00 
          eaten = 1;
  81ff98:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
          if (prev != NULL) {
  81ff9c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81ffa1:	74 36                	je     81ffd9 <raw_input+0xee>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  81ffa3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ffa7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81ffab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ffaf:	48 89 50 10          	mov    %rdx,0x10(%rax)
            pcb->next = raw_pcbs;
  81ffb3:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81ffba:	00 00 00 
  81ffbd:	48 8b 10             	mov    (%rax),%rdx
  81ffc0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ffc4:	48 89 50 10          	mov    %rdx,0x10(%rax)
            raw_pcbs = pcb;
  81ffc8:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81ffcf:	00 00 00 
  81ffd2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81ffd6:	48 89 10             	mov    %rdx,(%rax)
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  81ffd9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ffdd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    pcb = pcb->next;
  81ffe1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ffe5:	48 8b 40 10          	mov    0x10(%rax),%rax
  81ffe9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  81ffed:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  81fff1:	75 0b                	jne    81fffe <raw_input+0x113>
  81fff3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81fff8:	0f 85 4c ff ff ff    	jne    81ff4a <raw_input+0x5f>
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
  81fffe:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  820002:	c9                   	leaveq 
  820003:	c3                   	retq   

0000000000820004 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  820004:	55                   	push   %rbp
  820005:	48 89 e5             	mov    %rsp,%rbp
  820008:	48 83 ec 10          	sub    $0x10,%rsp
  82000c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  820010:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&pcb->local_ip, ipaddr);
  820014:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  820019:	74 08                	je     820023 <raw_bind+0x1f>
  82001b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  82001f:	8b 00                	mov    (%rax),%eax
  820021:	eb 05                	jmp    820028 <raw_bind+0x24>
  820023:	b8 00 00 00 00       	mov    $0x0,%eax
  820028:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  82002c:	89 02                	mov    %eax,(%rdx)
  return ERR_OK;
  82002e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  820033:	c9                   	leaveq 
  820034:	c3                   	retq   

0000000000820035 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  820035:	55                   	push   %rbp
  820036:	48 89 e5             	mov    %rsp,%rbp
  820039:	48 83 ec 10          	sub    $0x10,%rsp
  82003d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  820041:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&pcb->remote_ip, ipaddr);
  820045:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  82004a:	74 08                	je     820054 <raw_connect+0x1f>
  82004c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  820050:	8b 00                	mov    (%rax),%eax
  820052:	eb 05                	jmp    820059 <raw_connect+0x24>
  820054:	b8 00 00 00 00       	mov    $0x0,%eax
  820059:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  82005d:	89 42 04             	mov    %eax,0x4(%rdx)
  return ERR_OK;
  820060:	b8 00 00 00 00       	mov    $0x0,%eax
}
  820065:	c9                   	leaveq 
  820066:	c3                   	retq   

0000000000820067 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  820067:	55                   	push   %rbp
  820068:	48 89 e5             	mov    %rsp,%rbp
  82006b:	48 83 ec 18          	sub    $0x18,%rsp
  82006f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  820073:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  820077:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
  82007b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82007f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  820083:	48 89 50 20          	mov    %rdx,0x20(%rax)
  pcb->recv_arg = recv_arg;
  820087:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82008b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  82008f:	48 89 50 28          	mov    %rdx,0x28(%rax)
}
  820093:	90                   	nop
  820094:	c9                   	leaveq 
  820095:	c3                   	retq   

0000000000820096 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  820096:	55                   	push   %rbp
  820097:	48 89 e5             	mov    %rsp,%rbp
  82009a:	48 83 ec 40          	sub    $0x40,%rsp
  82009e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8200a2:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8200a6:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  8200aa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8200ae:	be 14 00 00 00       	mov    $0x14,%esi
  8200b3:	48 89 c7             	mov    %rax,%rdi
  8200b6:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  8200bd:	00 00 00 
  8200c0:	ff d0                	callq  *%rax
  8200c2:	84 c0                	test   %al,%al
  8200c4:	74 4c                	je     820112 <raw_sendto+0x7c>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  8200c6:	ba 00 00 00 00       	mov    $0x0,%edx
  8200cb:	be 00 00 00 00       	mov    $0x0,%esi
  8200d0:	bf 01 00 00 00       	mov    $0x1,%edi
  8200d5:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  8200dc:	00 00 00 
  8200df:	ff d0                	callq  *%rax
  8200e1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  8200e5:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8200ea:	75 0a                	jne    8200f6 <raw_sendto+0x60>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  8200ec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8200f1:	e9 4a 01 00 00       	jmpq   820240 <raw_sendto+0x1aa>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  8200f6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8200fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8200fe:	48 89 d6             	mov    %rdx,%rsi
  820101:	48 89 c7             	mov    %rax,%rdi
  820104:	48 b8 79 e0 80 00 00 	movabs $0x80e079,%rax
  82010b:	00 00 00 
  82010e:	ff d0                	callq  *%rax
  820110:	eb 4e                	jmp    820160 <raw_sendto+0xca>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  820112:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  820116:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    if(pbuf_header(q, -IP_HLEN)) {
  82011a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  82011e:	be ec ff ff ff       	mov    $0xffffffec,%esi
  820123:	48 89 c7             	mov    %rax,%rdi
  820126:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  82012d:	00 00 00 
  820130:	ff d0                	callq  *%rax
  820132:	84 c0                	test   %al,%al
  820134:	74 2a                	je     820160 <raw_sendto+0xca>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  820136:	48 ba d8 3d 82 00 00 	movabs $0x823dd8,%rdx
  82013d:	00 00 00 
  820140:	be e4 00 00 00       	mov    $0xe4,%esi
  820145:	48 bf fe 3d 82 00 00 	movabs $0x823dfe,%rdi
  82014c:	00 00 00 
  82014f:	b8 00 00 00 00       	mov    $0x0,%eax
  820154:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  82015b:	00 00 00 
  82015e:	ff d1                	callq  *%rcx
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  820160:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  820164:	48 89 c7             	mov    %rax,%rdi
  820167:	48 b8 0d 0e 81 00 00 	movabs $0x810e0d,%rax
  82016e:	00 00 00 
  820171:	ff d0                	callq  *%rax
  820173:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  820177:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  82017c:	75 27                	jne    8201a5 <raw_sendto+0x10f>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  82017e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  820182:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  820186:	74 13                	je     82019b <raw_sendto+0x105>
      pbuf_free(q);
  820188:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  82018c:	48 89 c7             	mov    %rax,%rdi
  82018f:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  820196:	00 00 00 
  820199:	ff d0                	callq  *%rax
    }
    return ERR_RTE;
  82019b:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8201a0:	e9 9b 00 00 00       	jmpq   820240 <raw_sendto+0x1aa>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  8201a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8201a9:	48 85 c0             	test   %rax,%rax
  8201ac:	74 0a                	je     8201b8 <raw_sendto+0x122>
  8201ae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8201b2:	8b 00                	mov    (%rax),%eax
  8201b4:	85 c0                	test   %eax,%eax
  8201b6:	75 0e                	jne    8201c6 <raw_sendto+0x130>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  8201b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8201bc:	48 83 c0 08          	add    $0x8,%rax
  8201c0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8201c4:	eb 08                	jmp    8201ce <raw_sendto+0x138>
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  8201c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8201ca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  8201ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8201d2:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8201d6:	44 0f b6 c0          	movzbl %al,%r8d
  8201da:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8201de:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  8201e2:	0f b6 f8             	movzbl %al,%edi
  8201e5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8201e9:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8201ed:	0f b6 c8             	movzbl %al,%ecx
  8201f0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8201f4:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8201f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8201fc:	48 83 ec 08          	sub    $0x8,%rsp
  820200:	ff 75 e8             	pushq  -0x18(%rbp)
  820203:	45 89 c1             	mov    %r8d,%r9d
  820206:	41 89 f8             	mov    %edi,%r8d
  820209:	48 89 c7             	mov    %rax,%rdi
  82020c:	48 b8 43 13 81 00 00 	movabs $0x811343,%rax
  820213:	00 00 00 
  820216:	ff d0                	callq  *%rax
  820218:	48 83 c4 10          	add    $0x10,%rsp
  82021c:	88 45 e7             	mov    %al,-0x19(%rbp)
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  82021f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  820223:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  820227:	74 13                	je     82023c <raw_sendto+0x1a6>
    /* free the header */
    pbuf_free(q);
  820229:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  82022d:	48 89 c7             	mov    %rax,%rdi
  820230:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  820237:	00 00 00 
  82023a:	ff d0                	callq  *%rax
  }
  return err;
  82023c:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
}
  820240:	c9                   	leaveq 
  820241:	c3                   	retq   

0000000000820242 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  820242:	55                   	push   %rbp
  820243:	48 89 e5             	mov    %rsp,%rbp
  820246:	48 83 ec 10          	sub    $0x10,%rsp
  82024a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  82024e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  return raw_sendto(pcb, p, &pcb->remote_ip);
  820252:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820256:	48 8d 50 04          	lea    0x4(%rax),%rdx
  82025a:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  82025e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820262:	48 89 ce             	mov    %rcx,%rsi
  820265:	48 89 c7             	mov    %rax,%rdi
  820268:	48 b8 96 00 82 00 00 	movabs $0x820096,%rax
  82026f:	00 00 00 
  820272:	ff d0                	callq  *%rax
}
  820274:	c9                   	leaveq 
  820275:	c3                   	retq   

0000000000820276 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  820276:	55                   	push   %rbp
  820277:	48 89 e5             	mov    %rsp,%rbp
  82027a:	48 83 ec 20          	sub    $0x20,%rsp
  82027e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  820282:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  820289:	00 00 00 
  82028c:	48 8b 00             	mov    (%rax),%rax
  82028f:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  820293:	75 20                	jne    8202b5 <raw_remove+0x3f>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  820295:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  82029c:	00 00 00 
  82029f:	48 8b 00             	mov    (%rax),%rax
  8202a2:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8202a6:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  8202ad:	00 00 00 
  8202b0:	48 89 10             	mov    %rdx,(%rax)
  8202b3:	eb 51                	jmp    820306 <raw_remove+0x90>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  8202b5:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  8202bc:	00 00 00 
  8202bf:	48 8b 00             	mov    (%rax),%rax
  8202c2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8202c6:	eb 37                	jmp    8202ff <raw_remove+0x89>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  8202c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8202cc:	48 8b 40 10          	mov    0x10(%rax),%rax
  8202d0:	48 85 c0             	test   %rax,%rax
  8202d3:	74 1e                	je     8202f3 <raw_remove+0x7d>
  8202d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8202d9:	48 8b 40 10          	mov    0x10(%rax),%rax
  8202dd:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8202e1:	75 10                	jne    8202f3 <raw_remove+0x7d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  8202e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8202e7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8202eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8202ef:	48 89 50 10          	mov    %rdx,0x10(%rax)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  8202f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8202f7:	48 8b 40 10          	mov    0x10(%rax),%rax
  8202fb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8202ff:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  820304:	75 c2                	jne    8202c8 <raw_remove+0x52>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  820306:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82030a:	48 89 c6             	mov    %rax,%rsi
  82030d:	bf 00 00 00 00       	mov    $0x0,%edi
  820312:	48 b8 ff ce 80 00 00 	movabs $0x80ceff,%rax
  820319:	00 00 00 
  82031c:	ff d0                	callq  *%rax
}
  82031e:	90                   	nop
  82031f:	c9                   	leaveq 
  820320:	c3                   	retq   

0000000000820321 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  820321:	55                   	push   %rbp
  820322:	48 89 e5             	mov    %rsp,%rbp
  820325:	48 83 ec 20          	sub    $0x20,%rsp
  820329:	89 f8                	mov    %edi,%eax
  82032b:	88 45 ec             	mov    %al,-0x14(%rbp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  82032e:	bf 00 00 00 00       	mov    $0x0,%edi
  820333:	48 b8 54 ce 80 00 00 	movabs $0x80ce54,%rax
  82033a:	00 00 00 
  82033d:	ff d0                	callq  *%rax
  82033f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  820343:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  820348:	74 56                	je     8203a0 <raw_new+0x7f>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  82034a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82034e:	ba 30 00 00 00       	mov    $0x30,%edx
  820353:	be 00 00 00 00       	mov    $0x0,%esi
  820358:	48 89 c7             	mov    %rax,%rdi
  82035b:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  820362:	00 00 00 
  820365:	ff d0                	callq  *%rax
    pcb->protocol = proto;
  820367:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82036b:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  82036f:	88 50 18             	mov    %dl,0x18(%rax)
    pcb->ttl = RAW_TTL;
  820372:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820376:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
    pcb->next = raw_pcbs;
  82037a:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  820381:	00 00 00 
  820384:	48 8b 10             	mov    (%rax),%rdx
  820387:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82038b:	48 89 50 10          	mov    %rdx,0x10(%rax)
    raw_pcbs = pcb;
  82038f:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  820396:	00 00 00 
  820399:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  82039d:	48 89 10             	mov    %rdx,(%rax)
  }
  return pcb;
  8203a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8203a4:	c9                   	leaveq 
  8203a5:	c3                   	retq   

00000000008203a6 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  8203a6:	55                   	push   %rbp
  8203a7:	48 89 e5             	mov    %rsp,%rbp
  8203aa:	53                   	push   %rbx
  8203ab:	48 83 ec 48          	sub    $0x48,%rsp
  8203af:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8203b3:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  8203b7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8203bb:	48 8b 40 08          	mov    0x8(%rax),%rax
  8203bf:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  hlen = IPH_HL(iphdr) * 4;
  8203c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8203c7:	0f b7 00             	movzwl (%rax),%eax
  8203ca:	0f b7 c0             	movzwl %ax,%eax
  8203cd:	89 c7                	mov    %eax,%edi
  8203cf:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  8203d6:	00 00 00 
  8203d9:	ff d0                	callq  *%rax
  8203db:	66 c1 e8 08          	shr    $0x8,%ax
  8203df:	83 e0 0f             	and    $0xf,%eax
  8203e2:	c1 e0 02             	shl    $0x2,%eax
  8203e5:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  8203e9:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
  8203ed:	f7 d8                	neg    %eax
  8203ef:	0f bf d0             	movswl %ax,%edx
  8203f2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8203f6:	89 d6                	mov    %edx,%esi
  8203f8:	48 89 c7             	mov    %rax,%rdi
  8203fb:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  820402:	00 00 00 
  820405:	ff d0                	callq  *%rax
  820407:	84 c0                	test   %al,%al
  820409:	0f 85 97 04 00 00    	jne    8208a6 <icmp_input+0x500>
  82040f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820413:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  820417:	66 83 f8 03          	cmp    $0x3,%ax
  82041b:	0f 86 85 04 00 00    	jbe    8208a6 <icmp_input+0x500>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  820421:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820425:	48 8b 40 08          	mov    0x8(%rax),%rax
  820429:	0f b6 00             	movzbl (%rax),%eax
  82042c:	88 45 e5             	mov    %al,-0x1b(%rbp)
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
  82042f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820433:	48 8b 40 08          	mov    0x8(%rax),%rax
  820437:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  82043b:	88 45 e4             	mov    %al,-0x1c(%rbp)
#endif /* LWIP_DEBUG */
  switch (type) {
  82043e:	0f b6 45 e5          	movzbl -0x1b(%rbp),%eax
  820442:	83 f8 08             	cmp    $0x8,%eax
  820445:	0f 85 46 04 00 00    	jne    820891 <icmp_input+0x4eb>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  82044b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82044f:	48 8d 50 10          	lea    0x10(%rax),%rdx
  820453:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  820457:	48 89 c6             	mov    %rax,%rsi
  82045a:	48 89 d7             	mov    %rdx,%rdi
  82045d:	48 b8 70 0d 81 00 00 	movabs $0x810d70,%rax
  820464:	00 00 00 
  820467:	ff d0                	callq  *%rax
  820469:	84 c0                	test   %al,%al
  82046b:	75 2f                	jne    82049c <icmp_input+0xf6>
  82046d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820471:	8b 58 10             	mov    0x10(%rax),%ebx
  820474:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  820479:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  820480:	00 00 00 
  820483:	ff d0                	callq  *%rax
  820485:	21 c3                	and    %eax,%ebx
  820487:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  82048c:	48 b8 1a 31 81 00 00 	movabs $0x81311a,%rax
  820493:	00 00 00 
  820496:	ff d0                	callq  *%rax
  820498:	39 c3                	cmp    %eax,%ebx
  82049a:	75 18                	jne    8204b4 <icmp_input+0x10e>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  82049c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8204a0:	48 89 c7             	mov    %rax,%rdi
  8204a3:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  8204aa:	00 00 00 
  8204ad:	ff d0                	callq  *%rax
      return;
  8204af:	e9 20 04 00 00       	jmpq   8208d4 <icmp_input+0x52e>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  8204b4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8204b8:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8204bc:	66 83 f8 07          	cmp    $0x7,%ax
  8204c0:	0f 86 e3 03 00 00    	jbe    8208a9 <icmp_input+0x503>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  8204c6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8204ca:	48 89 c7             	mov    %rax,%rdi
  8204cd:	48 b8 7d 2b 81 00 00 	movabs $0x812b7d,%rax
  8204d4:	00 00 00 
  8204d7:	ff d0                	callq  *%rax
  8204d9:	66 85 c0             	test   %ax,%ax
  8204dc:	74 18                	je     8204f6 <icmp_input+0x150>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  8204de:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8204e2:	48 89 c7             	mov    %rax,%rdi
  8204e5:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  8204ec:	00 00 00 
  8204ef:	ff d0                	callq  *%rax
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  8204f1:	e9 de 03 00 00       	jmpq   8208d4 <icmp_input+0x52e>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  8204f6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8204fa:	be 22 00 00 00       	mov    $0x22,%esi
  8204ff:	48 89 c7             	mov    %rax,%rdi
  820502:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  820509:	00 00 00 
  82050c:	ff d0                	callq  *%rax
  82050e:	84 c0                	test   %al,%al
  820510:	0f 84 79 01 00 00    	je     82068f <icmp_input+0x2e9>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  820516:	0f bf 55 e6          	movswl -0x1a(%rbp),%edx
  82051a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82051e:	89 d6                	mov    %edx,%esi
  820520:	48 89 c7             	mov    %rax,%rdi
  820523:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  82052a:	00 00 00 
  82052d:	ff d0                	callq  *%rax
  82052f:	84 c0                	test   %al,%al
  820531:	74 2a                	je     82055d <icmp_input+0x1b7>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  820533:	48 ba 18 3e 82 00 00 	movabs $0x823e18,%rdx
  82053a:	00 00 00 
  82053d:	be 7c 00 00 00       	mov    $0x7c,%esi
  820542:	48 bf 4b 3e 82 00 00 	movabs $0x823e4b,%rdi
  820549:	00 00 00 
  82054c:	b8 00 00 00 00       	mov    $0x0,%eax
  820551:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  820558:	00 00 00 
  82055b:	ff d1                	callq  *%rcx
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  82055d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820561:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  820565:	0f b7 c0             	movzwl %ax,%eax
  820568:	ba 00 00 00 00       	mov    $0x0,%edx
  82056d:	89 c6                	mov    %eax,%esi
  82056f:	bf 02 00 00 00       	mov    $0x2,%edi
  820574:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  82057b:	00 00 00 
  82057e:	ff d0                	callq  *%rax
  820580:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      if (r == NULL) {
  820584:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  820589:	0f 84 30 03 00 00    	je     8208bf <icmp_input+0x519>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  82058f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820593:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  820597:	0f b7 c0             	movzwl %ax,%eax
  82059a:	48 0f bf 55 e6       	movswq -0x1a(%rbp),%rdx
  82059f:	48 83 c2 08          	add    $0x8,%rdx
  8205a3:	48 39 d0             	cmp    %rdx,%rax
  8205a6:	73 2a                	jae    8205d2 <icmp_input+0x22c>
  8205a8:	48 ba 68 3e 82 00 00 	movabs $0x823e68,%rdx
  8205af:	00 00 00 
  8205b2:	be 86 00 00 00       	mov    $0x86,%esi
  8205b7:	48 bf 4b 3e 82 00 00 	movabs $0x823e4b,%rdi
  8205be:	00 00 00 
  8205c1:	b8 00 00 00 00       	mov    $0x0,%eax
  8205c6:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8205cd:	00 00 00 
  8205d0:	ff d1                	callq  *%rcx
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  8205d2:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8205d6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8205da:	48 89 d6             	mov    %rdx,%rsi
  8205dd:	48 89 c7             	mov    %rax,%rdi
  8205e0:	48 b8 cf e1 80 00 00 	movabs $0x80e1cf,%rax
  8205e7:	00 00 00 
  8205ea:	ff d0                	callq  *%rax
  8205ec:	84 c0                	test   %al,%al
  8205ee:	74 2a                	je     82061a <icmp_input+0x274>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  8205f0:	48 ba a0 3e 82 00 00 	movabs $0x823ea0,%rdx
  8205f7:	00 00 00 
  8205fa:	be 89 00 00 00       	mov    $0x89,%esi
  8205ff:	48 bf 4b 3e 82 00 00 	movabs $0x823e4b,%rdi
  820606:	00 00 00 
  820609:	b8 00 00 00 00       	mov    $0x0,%eax
  82060e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  820615:	00 00 00 
  820618:	ff d1                	callq  *%rcx
        goto memerr;
      }
      iphdr = r->payload;
  82061a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  82061e:	48 8b 40 08          	mov    0x8(%rax),%rax
  820622:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  820626:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
  82062a:	f7 d8                	neg    %eax
  82062c:	0f bf d0             	movswl %ax,%edx
  82062f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820633:	89 d6                	mov    %edx,%esi
  820635:	48 89 c7             	mov    %rax,%rdi
  820638:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  82063f:	00 00 00 
  820642:	ff d0                	callq  *%rax
  820644:	84 c0                	test   %al,%al
  820646:	74 2a                	je     820672 <icmp_input+0x2cc>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  820648:	48 ba c8 3e 82 00 00 	movabs $0x823ec8,%rdx
  82064f:	00 00 00 
  820652:	be 8f 00 00 00       	mov    $0x8f,%esi
  820657:	48 bf 4b 3e 82 00 00 	movabs $0x823e4b,%rdi
  82065e:	00 00 00 
  820661:	b8 00 00 00 00       	mov    $0x0,%eax
  820666:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  82066d:	00 00 00 
  820670:	ff d1                	callq  *%rcx
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  820672:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820676:	48 89 c7             	mov    %rax,%rdi
  820679:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  820680:	00 00 00 
  820683:	ff d0                	callq  *%rax
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  820685:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820689:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  82068d:	eb 46                	jmp    8206d5 <icmp_input+0x32f>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  82068f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820693:	be de ff ff ff       	mov    $0xffffffde,%esi
  820698:	48 89 c7             	mov    %rax,%rdi
  82069b:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  8206a2:	00 00 00 
  8206a5:	ff d0                	callq  *%rax
  8206a7:	84 c0                	test   %al,%al
  8206a9:	74 2a                	je     8206d5 <icmp_input+0x32f>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  8206ab:	48 ba c8 3e 82 00 00 	movabs $0x823ec8,%rdx
  8206b2:	00 00 00 
  8206b5:	be 99 00 00 00       	mov    $0x99,%esi
  8206ba:	48 bf 4b 3e 82 00 00 	movabs $0x823e4b,%rdi
  8206c1:	00 00 00 
  8206c4:	b8 00 00 00 00       	mov    $0x0,%eax
  8206c9:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8206d0:	00 00 00 
  8206d3:	ff d1                	callq  *%rcx
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  8206d5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8206d9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8206dd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    tmpaddr.addr = iphdr->src.addr;
  8206e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8206e5:	8b 40 0c             	mov    0xc(%rax),%eax
  8206e8:	89 45 c0             	mov    %eax,-0x40(%rbp)
    iphdr->src.addr = iphdr->dest.addr;
  8206eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8206ef:	8b 50 10             	mov    0x10(%rax),%edx
  8206f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8206f6:	89 50 0c             	mov    %edx,0xc(%rax)
    iphdr->dest.addr = tmpaddr.addr;
  8206f9:	8b 55 c0             	mov    -0x40(%rbp),%edx
  8206fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820700:	89 50 10             	mov    %edx,0x10(%rax)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  820703:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  820707:	0f b7 00             	movzwl (%rax),%eax
  82070a:	0f b7 c0             	movzwl %ax,%eax
  82070d:	89 c7                	mov    %eax,%edi
  82070f:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  820716:	00 00 00 
  820719:	ff d0                	callq  *%rax
  82071b:	0f b7 c0             	movzwl %ax,%eax
  82071e:	0f b6 c0             	movzbl %al,%eax
  820721:	89 c7                	mov    %eax,%edi
  820723:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  82072a:	00 00 00 
  82072d:	ff d0                	callq  *%rax
  82072f:	89 c2                	mov    %eax,%edx
  820731:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  820735:	66 89 10             	mov    %dx,(%rax)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  820738:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  82073c:	0f b7 58 02          	movzwl 0x2(%rax),%ebx
  820740:	bf ff f7 00 00       	mov    $0xf7ff,%edi
  820745:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  82074c:	00 00 00 
  82074f:	ff d0                	callq  *%rax
  820751:	66 39 c3             	cmp    %ax,%bx
  820754:	72 2b                	jb     820781 <icmp_input+0x3db>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  820756:	bf 00 08 00 00       	mov    $0x800,%edi
  82075b:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  820762:	00 00 00 
  820765:	ff d0                	callq  *%rax
  820767:	0f b7 c0             	movzwl %ax,%eax
  82076a:	8d 50 01             	lea    0x1(%rax),%edx
  82076d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  820771:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  820775:	01 c2                	add    %eax,%edx
  820777:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  82077b:	66 89 50 02          	mov    %dx,0x2(%rax)
  82077f:	eb 25                	jmp    8207a6 <icmp_input+0x400>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  820781:	bf 00 08 00 00       	mov    $0x800,%edi
  820786:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  82078d:	00 00 00 
  820790:	ff d0                	callq  *%rax
  820792:	89 c2                	mov    %eax,%edx
  820794:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  820798:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  82079c:	01 c2                	add    %eax,%edx
  82079e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8207a2:	66 89 50 02          	mov    %dx,0x2(%rax)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  8207a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8207aa:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8207ae:	0f b7 c0             	movzwl %ax,%eax
  8207b1:	89 c7                	mov    %eax,%edi
  8207b3:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  8207ba:	00 00 00 
  8207bd:	ff d0                	callq  *%rax
  8207bf:	66 0d 00 ff          	or     $0xff00,%ax
  8207c3:	0f b7 c0             	movzwl %ax,%eax
  8207c6:	89 c7                	mov    %eax,%edi
  8207c8:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  8207cf:	00 00 00 
  8207d2:	ff d0                	callq  *%rax
  8207d4:	89 c2                	mov    %eax,%edx
  8207d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8207da:	66 89 50 08          	mov    %dx,0x8(%rax)
    IPH_CHKSUM_SET(iphdr, 0);
  8207de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8207e2:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8207e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8207ec:	be 14 00 00 00       	mov    $0x14,%esi
  8207f1:	48 89 c7             	mov    %rax,%rdi
  8207f4:	48 b8 4e 2b 81 00 00 	movabs $0x812b4e,%rax
  8207fb:	00 00 00 
  8207fe:	ff d0                	callq  *%rax
  820800:	89 c2                	mov    %eax,%edx
  820802:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820806:	66 89 50 0a          	mov    %dx,0xa(%rax)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  82080a:	0f bf 55 e6          	movswl -0x1a(%rbp),%edx
  82080e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820812:	89 d6                	mov    %edx,%esi
  820814:	48 89 c7             	mov    %rax,%rdi
  820817:	48 b8 8a db 80 00 00 	movabs $0x80db8a,%rax
  82081e:	00 00 00 
  820821:	ff d0                	callq  *%rax
  820823:	84 c0                	test   %al,%al
  820825:	74 2a                	je     820851 <icmp_input+0x4ab>
      LWIP_ASSERT("Can't move over header in packet", 0);
  820827:	48 ba 00 3f 82 00 00 	movabs $0x823f00,%rdx
  82082e:	00 00 00 
  820831:	be ba 00 00 00       	mov    $0xba,%esi
  820836:	48 bf 4b 3e 82 00 00 	movabs $0x823e4b,%rdi
  82083d:	00 00 00 
  820840:	b8 00 00 00 00       	mov    $0x0,%eax
  820845:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  82084c:	00 00 00 
  82084f:	ff d1                	callq  *%rcx
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  820851:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820855:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  820859:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82085d:	48 83 ec 08          	sub    $0x8,%rsp
  820861:	ff 75 b0             	pushq  -0x50(%rbp)
  820864:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  82086a:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  820870:	b9 ff 00 00 00       	mov    $0xff,%ecx
  820875:	ba 00 00 00 00       	mov    $0x0,%edx
  82087a:	48 89 c7             	mov    %rax,%rdi
  82087d:	48 b8 43 13 81 00 00 	movabs $0x811343,%rax
  820884:	00 00 00 
  820887:	ff d0                	callq  *%rax
  820889:	48 83 c4 10          	add    $0x10,%rsp
  82088d:	88 45 cf             	mov    %al,-0x31(%rbp)
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
  820890:	90                   	nop
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  820891:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820895:	48 89 c7             	mov    %rax,%rdi
  820898:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  82089f:	00 00 00 
  8208a2:	ff d0                	callq  *%rax
  return;
  8208a4:	eb 2e                	jmp    8208d4 <icmp_input+0x52e>

  iphdr = p->payload;
  hlen = IPH_HL(iphdr) * 4;
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  8208a6:	90                   	nop
  8208a7:	eb 01                	jmp    8208aa <icmp_input+0x504>
      return;
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
  8208a9:	90                   	nop
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  return;
lenerr:
  pbuf_free(p);
  8208aa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8208ae:	48 89 c7             	mov    %rax,%rdi
  8208b1:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  8208b8:	00 00 00 
  8208bb:	ff d0                	callq  *%rax
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  8208bd:	eb 15                	jmp    8208d4 <icmp_input+0x52e>
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
  8208bf:	90                   	nop
  pbuf_free(p);
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
memerr:
  pbuf_free(p);
  8208c0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8208c4:	48 89 c7             	mov    %rax,%rdi
  8208c7:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  8208ce:	00 00 00 
  8208d1:	ff d0                	callq  *%rax
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
  8208d3:	90                   	nop
}
  8208d4:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8208d8:	c9                   	leaveq 
  8208d9:	c3                   	retq   

00000000008208da <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  8208da:	55                   	push   %rbp
  8208db:	48 89 e5             	mov    %rsp,%rbp
  8208de:	48 83 ec 30          	sub    $0x30,%rsp
  8208e2:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8208e6:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  8208e9:	ba 00 00 00 00       	mov    $0x0,%edx
  8208ee:	be 24 00 00 00       	mov    $0x24,%esi
  8208f3:	bf 01 00 00 00       	mov    $0x1,%edi
  8208f8:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  8208ff:	00 00 00 
  820902:	ff d0                	callq  *%rax
  820904:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 PBUF_RAM);
  if (q == NULL) {
  820908:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  82090d:	0f 84 68 01 00 00    	je     820a7b <icmp_dest_unreach+0x1a1>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  820913:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820917:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  82091b:	66 83 f8 23          	cmp    $0x23,%ax
  82091f:	77 2a                	ja     82094b <icmp_dest_unreach+0x71>
  820921:	48 ba 28 3f 82 00 00 	movabs $0x823f28,%rdx
  820928:	00 00 00 
  82092b:	be f0 00 00 00       	mov    $0xf0,%esi
  820930:	48 bf 4b 3e 82 00 00 	movabs $0x823e4b,%rdi
  820937:	00 00 00 
  82093a:	b8 00 00 00 00       	mov    $0x0,%eax
  82093f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  820946:	00 00 00 
  820949:	ff d1                	callq  *%rcx
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  82094b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  82094f:	48 8b 40 08          	mov    0x8(%rax),%rax
  820953:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  idur = q->payload;
  820957:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82095b:	48 8b 40 08          	mov    0x8(%rax),%rax
  82095f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  820963:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820967:	0f b7 00             	movzwl (%rax),%eax
  82096a:	0f b7 c0             	movzwl %ax,%eax
  82096d:	89 c7                	mov    %eax,%edi
  82096f:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  820976:	00 00 00 
  820979:	ff d0                	callq  *%rax
  82097b:	0f b6 c0             	movzbl %al,%eax
  82097e:	80 cc 03             	or     $0x3,%ah
  820981:	0f b7 c0             	movzwl %ax,%eax
  820984:	89 c7                	mov    %eax,%edi
  820986:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  82098d:	00 00 00 
  820990:	ff d0                	callq  *%rax
  820992:	89 c2                	mov    %eax,%edx
  820994:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820998:	66 89 10             	mov    %dx,(%rax)
  ICMPH_CODE_SET(idur, t);
  82099b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82099f:	0f b7 00             	movzwl (%rax),%eax
  8209a2:	0f b7 c0             	movzwl %ax,%eax
  8209a5:	89 c7                	mov    %eax,%edi
  8209a7:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  8209ae:	00 00 00 
  8209b1:	ff d0                	callq  *%rax
  8209b3:	b0 00                	mov    $0x0,%al
  8209b5:	89 c2                	mov    %eax,%edx
  8209b7:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8209ba:	09 d0                	or     %edx,%eax
  8209bc:	0f b7 c0             	movzwl %ax,%eax
  8209bf:	89 c7                	mov    %eax,%edi
  8209c1:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  8209c8:	00 00 00 
  8209cb:	ff d0                	callq  *%rax
  8209cd:	89 c2                	mov    %eax,%edx
  8209cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8209d3:	66 89 10             	mov    %dx,(%rax)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  8209d6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8209da:	48 8b 40 08          	mov    0x8(%rax),%rax
  8209de:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8209e2:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8209e6:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  8209ea:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8209ef:	48 89 c6             	mov    %rax,%rsi
  8209f2:	48 89 cf             	mov    %rcx,%rdi
  8209f5:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  8209fc:	00 00 00 
  8209ff:	ff d0                	callq  *%rax
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  820a01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820a05:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
  idur->chksum = inet_chksum(idur, q->len);
  820a0b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820a0f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  820a13:	0f b7 d0             	movzwl %ax,%edx
  820a16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820a1a:	89 d6                	mov    %edx,%esi
  820a1c:	48 89 c7             	mov    %rax,%rdi
  820a1f:	48 b8 4e 2b 81 00 00 	movabs $0x812b4e,%rax
  820a26:	00 00 00 
  820a29:	ff d0                	callq  *%rax
  820a2b:	89 c2                	mov    %eax,%edx
  820a2d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820a31:	66 89 50 02          	mov    %dx,0x2(%rax)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  820a35:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  820a39:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  820a3d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820a41:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  820a47:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  820a4d:	b9 ff 00 00 00       	mov    $0xff,%ecx
  820a52:	be 00 00 00 00       	mov    $0x0,%esi
  820a57:	48 89 c7             	mov    %rax,%rdi
  820a5a:	48 b8 05 16 81 00 00 	movabs $0x811605,%rax
  820a61:	00 00 00 
  820a64:	ff d0                	callq  *%rax
  pbuf_free(q);
  820a66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820a6a:	48 89 c7             	mov    %rax,%rdi
  820a6d:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  820a74:	00 00 00 
  820a77:	ff d0                	callq  *%rax
  820a79:	eb 01                	jmp    820a7c <icmp_dest_unreach+0x1a2>
  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
                 PBUF_RAM);
  if (q == NULL) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  820a7b:	90                   	nop
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
}
  820a7c:	c9                   	leaveq 
  820a7d:	c3                   	retq   

0000000000820a7e <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  820a7e:	55                   	push   %rbp
  820a7f:	48 89 e5             	mov    %rsp,%rbp
  820a82:	48 83 ec 30          	sub    $0x30,%rsp
  820a86:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  820a8a:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  820a8d:	ba 00 00 00 00       	mov    $0x0,%edx
  820a92:	be 24 00 00 00       	mov    $0x24,%esi
  820a97:	bf 01 00 00 00       	mov    $0x1,%edi
  820a9c:	48 b8 6c d4 80 00 00 	movabs $0x80d46c,%rax
  820aa3:	00 00 00 
  820aa6:	ff d0                	callq  *%rax
  820aa8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 PBUF_RAM);
  if (q == NULL) {
  820aac:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  820ab1:	0f 84 68 01 00 00    	je     820c1f <icmp_time_exceeded+0x1a1>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  820ab7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820abb:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  820abf:	66 83 f8 23          	cmp    $0x23,%ax
  820ac3:	77 2a                	ja     820aef <icmp_time_exceeded+0x71>
  820ac5:	48 ba 28 3f 82 00 00 	movabs $0x823f28,%rdx
  820acc:	00 00 00 
  820acf:	be 1f 01 00 00       	mov    $0x11f,%esi
  820ad4:	48 bf 4b 3e 82 00 00 	movabs $0x823e4b,%rdi
  820adb:	00 00 00 
  820ade:	b8 00 00 00 00       	mov    $0x0,%eax
  820ae3:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  820aea:	00 00 00 
  820aed:	ff d1                	callq  *%rcx
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  820aef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820af3:	48 8b 40 08          	mov    0x8(%rax),%rax
  820af7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  820afb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820aff:	48 8b 40 08          	mov    0x8(%rax),%rax
  820b03:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  820b07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820b0b:	0f b7 00             	movzwl (%rax),%eax
  820b0e:	0f b7 c0             	movzwl %ax,%eax
  820b11:	89 c7                	mov    %eax,%edi
  820b13:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  820b1a:	00 00 00 
  820b1d:	ff d0                	callq  *%rax
  820b1f:	0f b6 c0             	movzbl %al,%eax
  820b22:	80 cc 0b             	or     $0xb,%ah
  820b25:	0f b7 c0             	movzwl %ax,%eax
  820b28:	89 c7                	mov    %eax,%edi
  820b2a:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  820b31:	00 00 00 
  820b34:	ff d0                	callq  *%rax
  820b36:	89 c2                	mov    %eax,%edx
  820b38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820b3c:	66 89 10             	mov    %dx,(%rax)
  ICMPH_CODE_SET(tehdr, t);
  820b3f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820b43:	0f b7 00             	movzwl (%rax),%eax
  820b46:	0f b7 c0             	movzwl %ax,%eax
  820b49:	89 c7                	mov    %eax,%edi
  820b4b:	48 b8 c0 30 81 00 00 	movabs $0x8130c0,%rax
  820b52:	00 00 00 
  820b55:	ff d0                	callq  *%rax
  820b57:	b0 00                	mov    $0x0,%al
  820b59:	89 c2                	mov    %eax,%edx
  820b5b:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  820b5e:	09 d0                	or     %edx,%eax
  820b60:	0f b7 c0             	movzwl %ax,%eax
  820b63:	89 c7                	mov    %eax,%edi
  820b65:	48 b8 9d 30 81 00 00 	movabs $0x81309d,%rax
  820b6c:	00 00 00 
  820b6f:	ff d0                	callq  *%rax
  820b71:	89 c2                	mov    %eax,%edx
  820b73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820b77:	66 89 10             	mov    %dx,(%rax)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  820b7a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820b7e:	48 8b 40 08          	mov    0x8(%rax),%rax
  820b82:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  820b86:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  820b8a:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  820b8e:	ba 1c 00 00 00       	mov    $0x1c,%edx
  820b93:	48 89 c6             	mov    %rax,%rsi
  820b96:	48 89 cf             	mov    %rcx,%rdi
  820b99:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  820ba0:	00 00 00 
  820ba3:	ff d0                	callq  *%rax
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  820ba5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820ba9:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  820baf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820bb3:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  820bb7:	0f b7 d0             	movzwl %ax,%edx
  820bba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820bbe:	89 d6                	mov    %edx,%esi
  820bc0:	48 89 c7             	mov    %rax,%rdi
  820bc3:	48 b8 4e 2b 81 00 00 	movabs $0x812b4e,%rax
  820bca:	00 00 00 
  820bcd:	ff d0                	callq  *%rax
  820bcf:	89 c2                	mov    %eax,%edx
  820bd1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820bd5:	66 89 50 02          	mov    %dx,0x2(%rax)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  820bd9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  820bdd:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  820be1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820be5:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  820beb:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  820bf1:	b9 ff 00 00 00       	mov    $0xff,%ecx
  820bf6:	be 00 00 00 00       	mov    $0x0,%esi
  820bfb:	48 89 c7             	mov    %rax,%rdi
  820bfe:	48 b8 05 16 81 00 00 	movabs $0x811605,%rax
  820c05:	00 00 00 
  820c08:	ff d0                	callq  *%rax
  pbuf_free(q);
  820c0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820c0e:	48 89 c7             	mov    %rax,%rdi
  820c11:	48 b8 4d dd 80 00 00 	movabs $0x80dd4d,%rax
  820c18:	00 00 00 
  820c1b:	ff d0                	callq  *%rax
  820c1d:	eb 01                	jmp    820c20 <icmp_time_exceeded+0x1a2>
  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
                 PBUF_RAM);
  if (q == NULL) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  820c1f:	90                   	nop
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
}
  820c20:	c9                   	leaveq 
  820c21:	c3                   	retq   
