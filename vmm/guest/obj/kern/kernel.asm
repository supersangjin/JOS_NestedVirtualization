
vmm/guest/obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .bootstrap:

0000000000100000 <_head64>:
_head64:

# Save multiboot_info addr passed by bootloader
#ifdef VMM_GUEST
// VMCALL to the VMM to get a multiboot map.
    movl $VMX_VMCALL_MBMAP, %eax
  100000:	b8 01 00 00 00       	mov    $0x1,%eax
    vmcall
  100005:	0f 01 c1             	vmcall 
#endif
	
    movl $multiboot_info, %eax
  100008:	b8 00 70 10 00       	mov    $0x107000,%eax
    movl %ebx, (%eax)
  10000d:	89 18                	mov    %ebx,(%rax)
#ifndef VMM_GUEST
    movw $0x1234,0x472			# warm boot
#endif
	
# Reset the stack pointer in case we didn't come from the loader
    movl $0x7c00,%esp
  10000f:	bc 00 7c 00 00       	mov    $0x7c00,%esp

    call verify_cpu   #check if CPU supports long mode
  100014:	e8 cc 00 00 00       	callq  1000e5 <verify_cpu>
#ifndef VMM_GUEST
    movl $CR4_PAE,%eax
#else
    movl $(CR4_PAE|CR4_VMXE),%eax
  100019:	b8 20 20 00 00       	mov    $0x2020,%eax
#endif
    movl %eax,%cr4
  10001e:	0f 22 e0             	mov    %rax,%cr4

# build an early boot pml4 at physical address pml4phys 

    #initializing the page tables
    movl $pml4,%edi
  100021:	bf 00 20 10 00       	mov    $0x102000,%edi
    xorl %eax,%eax
  100026:	31 c0                	xor    %eax,%eax
    movl $((4096/4)*5),%ecx  # moving these many words to the 6 pages with 4 second level pages + 1 3rd level + 1 4th level pages 
  100028:	b9 00 14 00 00       	mov    $0x1400,%ecx
    rep stosl
  10002d:	f3 ab                	rep stos %eax,%es:(%rdi)
    # creating a 4G boot page table
    # setting the 4th level page table only the second entry needed (PML4)
    movl $pml4,%eax
  10002f:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl $pdpt1, %ebx
  100034:	bb 00 30 10 00       	mov    $0x103000,%ebx
    orl $PTE_P,%ebx
  100039:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10003c:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%eax)
  10003f:	89 18                	mov    %ebx,(%rax)

    movl $pdpt2, %ebx
  100041:	bb 00 40 10 00       	mov    $0x104000,%ebx
    orl $PTE_P,%ebx
  100046:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  100049:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,0x8(%eax)
  10004c:	89 58 08             	mov    %ebx,0x8(%rax)

    # setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xa0000--0xd000
    movl $pdpt1,%edi
  10004f:	bf 00 30 10 00       	mov    $0x103000,%edi
    movl $pde1,%ebx
  100054:	bb 00 50 10 00       	mov    $0x105000,%ebx
    orl $PTE_P,%ebx
  100059:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10005c:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  10005f:	89 1f                	mov    %ebx,(%rdi)

    movl $pdpt2,%edi
  100061:	bf 00 40 10 00       	mov    $0x104000,%edi
    movl $pde2,%ebx
  100066:	bb 00 60 10 00       	mov    $0x106000,%ebx
    orl $PTE_P,%ebx
  10006b:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10006e:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100071:	89 1f                	mov    %ebx,(%rdi)
    
    # setting the pgdir so that the LA=PA
    # mapping first 1G of mem at KERNBASE
    movl $128,%ecx
  100073:	b9 80 00 00 00       	mov    $0x80,%ecx
    # Start at the end and work backwards
    #leal (pml4 + 5*0x1000 - 0x8),%edi
    movl $pde1,%edi
  100078:	bf 00 50 10 00       	mov    $0x105000,%edi
    movl $pde2,%ebx
  10007d:	bb 00 60 10 00       	mov    $0x106000,%ebx
    #64th entry - 0x8004000000
    addl $256,%ebx 
  100082:	81 c3 00 01 00 00    	add    $0x100,%ebx
    # PTE_P|PTE_W|PTE_MBZ
    movl $0x00000183,%eax
  100088:	b8 83 01 00 00       	mov    $0x183,%eax
  1:
     movl %eax,(%edi)
  10008d:	89 07                	mov    %eax,(%rdi)
     movl %eax,(%ebx)
  10008f:	89 03                	mov    %eax,(%rbx)
     addl $0x8,%edi
  100091:	83 c7 08             	add    $0x8,%edi
     addl $0x8,%ebx
  100094:	83 c3 08             	add    $0x8,%ebx
     addl $0x00200000,%eax
  100097:	05 00 00 20 00       	add    $0x200000,%eax
     subl $1,%ecx
  10009c:	83 e9 01             	sub    $0x1,%ecx
     cmp $0x0,%ecx
  10009f:	83 f9 00             	cmp    $0x0,%ecx
     jne 1b
  1000a2:	75 e9                	jne    10008d <_head64+0x8d>
 /*    subl $1,%ecx */
 /*    cmp $0x0,%ecx */
 /*    jne 1b */

    # set the cr3 register
    movl $pml4,%eax
  1000a4:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl %eax, %cr3
  1000a9:	0f 22 d8             	mov    %rax,%cr3

	
    # enable the long mode in MSR
    movl $EFER_MSR,%ecx
  1000ac:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    rdmsr
  1000b1:	0f 32                	rdmsr  
    btsl $EFER_LME,%eax
  1000b3:	0f ba e8 08          	bts    $0x8,%eax
    wrmsr
  1000b7:	0f 30                	wrmsr  
    
    # enable paging 
    movl %cr0,%eax
  1000b9:	0f 20 c0             	mov    %cr0,%rax
    orl $CR0_PE,%eax
  1000bc:	83 c8 01             	or     $0x1,%eax
    orl $CR0_PG,%eax
  1000bf:	0d 00 00 00 80       	or     $0x80000000,%eax
    orl $CR0_AM,%eax
  1000c4:	0d 00 00 04 00       	or     $0x40000,%eax
    orl $CR0_WP,%eax
  1000c9:	0d 00 00 01 00       	or     $0x10000,%eax
    orl $CR0_MP,%eax
  1000ce:	83 c8 02             	or     $0x2,%eax
    movl %eax,%cr0
  1000d1:	0f 22 c0             	mov    %rax,%cr0
    #jump to long mode with CS=0 and

    movl $gdtdesc_64,%eax
  1000d4:	b8 18 10 10 00       	mov    $0x101018,%eax
    lgdt (%eax)
  1000d9:	0f 01 10             	lgdt   (%rax)
    pushl $0x8
  1000dc:	6a 08                	pushq  $0x8
    movl $_start,%eax
  1000de:	b8 0c 00 20 00       	mov    $0x20000c,%eax
    pushl %eax
  1000e3:	50                   	push   %rax

00000000001000e4 <jumpto_longmode>:
    
    .globl jumpto_longmode
    .type jumpto_longmode,@function
jumpto_longmode:
    lret
  1000e4:	cb                   	lret   

00000000001000e5 <verify_cpu>:
/*     movabs $_back_from_head64, %rax */
/*     pushq %rax */
/*     lretq */

verify_cpu:
    pushfl                   # get eflags in eax -- standardard way to check for cpuid
  1000e5:	9c                   	pushfq 
    popl %eax
  1000e6:	58                   	pop    %rax
    movl %eax,%ecx
  1000e7:	89 c1                	mov    %eax,%ecx
    xorl $0x200000, %eax
  1000e9:	35 00 00 20 00       	xor    $0x200000,%eax
    pushl %eax
  1000ee:	50                   	push   %rax
    popfl
  1000ef:	9d                   	popfq  
    pushfl
  1000f0:	9c                   	pushfq 
    popl %eax
  1000f1:	58                   	pop    %rax
    cmpl %eax,%ebx
  1000f2:	39 c3                	cmp    %eax,%ebx
    jz verify_cpu_no_longmode   # no cpuid -- no long mode
  1000f4:	74 1c                	je     100112 <verify_cpu_no_longmode>

    movl $0x0,%eax              # see if cpuid 1 is implemented
  1000f6:	b8 00 00 00 00       	mov    $0x0,%eax
    cpuid
  1000fb:	0f a2                	cpuid  
    cmpl $0x1,%eax
  1000fd:	83 f8 01             	cmp    $0x1,%eax
    jb verify_cpu_no_longmode    # cpuid 1 is not implemented
  100100:	72 10                	jb     100112 <verify_cpu_no_longmode>


    mov $0x80000001, %eax
  100102:	b8 01 00 00 80       	mov    $0x80000001,%eax
    cpuid                 
  100107:	0f a2                	cpuid  
    test $(1 << 29),%edx                 #Test if the LM-bit, is set or not.
  100109:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    jz verify_cpu_no_longmode
  10010f:	74 01                	je     100112 <verify_cpu_no_longmode>

    ret
  100111:	c3                   	retq   

0000000000100112 <verify_cpu_no_longmode>:

verify_cpu_no_longmode:
    jmp verify_cpu_no_longmode
  100112:	eb fe                	jmp    100112 <verify_cpu_no_longmode>
  100114:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10011b:	00 00 00 
  10011e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100125:	00 00 00 
  100128:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10012f:	00 00 00 
  100132:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100139:	00 00 00 
  10013c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100143:	00 00 00 
  100146:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10014d:	00 00 00 
  100150:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100157:	00 00 00 
  10015a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100161:	00 00 00 
  100164:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10016b:	00 00 00 
  10016e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100175:	00 00 00 
  100178:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10017f:	00 00 00 
  100182:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100189:	00 00 00 
  10018c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100193:	00 00 00 
  100196:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10019d:	00 00 00 
  1001a0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001a7:	00 00 00 
  1001aa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001b1:	00 00 00 
  1001b4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001bb:	00 00 00 
  1001be:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001c5:	00 00 00 
  1001c8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001cf:	00 00 00 
  1001d2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001d9:	00 00 00 
  1001dc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001e3:	00 00 00 
  1001e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001ed:	00 00 00 
  1001f0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001f7:	00 00 00 
  1001fa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100201:	00 00 00 
  100204:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10020b:	00 00 00 
  10020e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100215:	00 00 00 
  100218:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10021f:	00 00 00 
  100222:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100229:	00 00 00 
  10022c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100233:	00 00 00 
  100236:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10023d:	00 00 00 
  100240:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100247:	00 00 00 
  10024a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100251:	00 00 00 
  100254:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10025b:	00 00 00 
  10025e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100265:	00 00 00 
  100268:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10026f:	00 00 00 
  100272:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100279:	00 00 00 
  10027c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100283:	00 00 00 
  100286:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10028d:	00 00 00 
  100290:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100297:	00 00 00 
  10029a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002a1:	00 00 00 
  1002a4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ab:	00 00 00 
  1002ae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002b5:	00 00 00 
  1002b8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002bf:	00 00 00 
  1002c2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002c9:	00 00 00 
  1002cc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002d3:	00 00 00 
  1002d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002dd:	00 00 00 
  1002e0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002e7:	00 00 00 
  1002ea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002f1:	00 00 00 
  1002f4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002fb:	00 00 00 
  1002fe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100305:	00 00 00 
  100308:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10030f:	00 00 00 
  100312:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100319:	00 00 00 
  10031c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100323:	00 00 00 
  100326:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10032d:	00 00 00 
  100330:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100337:	00 00 00 
  10033a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100341:	00 00 00 
  100344:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10034b:	00 00 00 
  10034e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100355:	00 00 00 
  100358:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10035f:	00 00 00 
  100362:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100369:	00 00 00 
  10036c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100373:	00 00 00 
  100376:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10037d:	00 00 00 
  100380:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100387:	00 00 00 
  10038a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100391:	00 00 00 
  100394:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10039b:	00 00 00 
  10039e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003a5:	00 00 00 
  1003a8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003af:	00 00 00 
  1003b2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003b9:	00 00 00 
  1003bc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003c3:	00 00 00 
  1003c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003cd:	00 00 00 
  1003d0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003d7:	00 00 00 
  1003da:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003e1:	00 00 00 
  1003e4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003eb:	00 00 00 
  1003ee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003f5:	00 00 00 
  1003f8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ff:	00 00 00 
  100402:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100409:	00 00 00 
  10040c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100413:	00 00 00 
  100416:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10041d:	00 00 00 
  100420:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100427:	00 00 00 
  10042a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100431:	00 00 00 
  100434:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10043b:	00 00 00 
  10043e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100445:	00 00 00 
  100448:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10044f:	00 00 00 
  100452:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100459:	00 00 00 
  10045c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100463:	00 00 00 
  100466:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10046d:	00 00 00 
  100470:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100477:	00 00 00 
  10047a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100481:	00 00 00 
  100484:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10048b:	00 00 00 
  10048e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100495:	00 00 00 
  100498:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10049f:	00 00 00 
  1004a2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004a9:	00 00 00 
  1004ac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004b3:	00 00 00 
  1004b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004bd:	00 00 00 
  1004c0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004c7:	00 00 00 
  1004ca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004d1:	00 00 00 
  1004d4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004db:	00 00 00 
  1004de:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004e5:	00 00 00 
  1004e8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004ef:	00 00 00 
  1004f2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004f9:	00 00 00 
  1004fc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100503:	00 00 00 
  100506:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10050d:	00 00 00 
  100510:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100517:	00 00 00 
  10051a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100521:	00 00 00 
  100524:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10052b:	00 00 00 
  10052e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100535:	00 00 00 
  100538:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10053f:	00 00 00 
  100542:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100549:	00 00 00 
  10054c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100553:	00 00 00 
  100556:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10055d:	00 00 00 
  100560:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100567:	00 00 00 
  10056a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100571:	00 00 00 
  100574:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10057b:	00 00 00 
  10057e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100585:	00 00 00 
  100588:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10058f:	00 00 00 
  100592:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100599:	00 00 00 
  10059c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005a3:	00 00 00 
  1005a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ad:	00 00 00 
  1005b0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005b7:	00 00 00 
  1005ba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005c1:	00 00 00 
  1005c4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005cb:	00 00 00 
  1005ce:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005d5:	00 00 00 
  1005d8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005df:	00 00 00 
  1005e2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005e9:	00 00 00 
  1005ec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005f3:	00 00 00 
  1005f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005fd:	00 00 00 
  100600:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100607:	00 00 00 
  10060a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100611:	00 00 00 
  100614:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10061b:	00 00 00 
  10061e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100625:	00 00 00 
  100628:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10062f:	00 00 00 
  100632:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100639:	00 00 00 
  10063c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100643:	00 00 00 
  100646:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10064d:	00 00 00 
  100650:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100657:	00 00 00 
  10065a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100661:	00 00 00 
  100664:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10066b:	00 00 00 
  10066e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100675:	00 00 00 
  100678:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10067f:	00 00 00 
  100682:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100689:	00 00 00 
  10068c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100693:	00 00 00 
  100696:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10069d:	00 00 00 
  1006a0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006a7:	00 00 00 
  1006aa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006b1:	00 00 00 
  1006b4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006bb:	00 00 00 
  1006be:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006c5:	00 00 00 
  1006c8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006cf:	00 00 00 
  1006d2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006d9:	00 00 00 
  1006dc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006e3:	00 00 00 
  1006e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006ed:	00 00 00 
  1006f0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006f7:	00 00 00 
  1006fa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100701:	00 00 00 
  100704:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10070b:	00 00 00 
  10070e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100715:	00 00 00 
  100718:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10071f:	00 00 00 
  100722:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100729:	00 00 00 
  10072c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100733:	00 00 00 
  100736:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10073d:	00 00 00 
  100740:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100747:	00 00 00 
  10074a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100751:	00 00 00 
  100754:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10075b:	00 00 00 
  10075e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100765:	00 00 00 
  100768:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10076f:	00 00 00 
  100772:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100779:	00 00 00 
  10077c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100783:	00 00 00 
  100786:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10078d:	00 00 00 
  100790:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100797:	00 00 00 
  10079a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007a1:	00 00 00 
  1007a4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ab:	00 00 00 
  1007ae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007b5:	00 00 00 
  1007b8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007bf:	00 00 00 
  1007c2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007c9:	00 00 00 
  1007cc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007d3:	00 00 00 
  1007d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007dd:	00 00 00 
  1007e0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007e7:	00 00 00 
  1007ea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007f1:	00 00 00 
  1007f4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007fb:	00 00 00 
  1007fe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100805:	00 00 00 
  100808:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10080f:	00 00 00 
  100812:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100819:	00 00 00 
  10081c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100823:	00 00 00 
  100826:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10082d:	00 00 00 
  100830:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100837:	00 00 00 
  10083a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100841:	00 00 00 
  100844:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10084b:	00 00 00 
  10084e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100855:	00 00 00 
  100858:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10085f:	00 00 00 
  100862:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100869:	00 00 00 
  10086c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100873:	00 00 00 
  100876:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10087d:	00 00 00 
  100880:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100887:	00 00 00 
  10088a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100891:	00 00 00 
  100894:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10089b:	00 00 00 
  10089e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008a5:	00 00 00 
  1008a8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008af:	00 00 00 
  1008b2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008b9:	00 00 00 
  1008bc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008c3:	00 00 00 
  1008c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008cd:	00 00 00 
  1008d0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008d7:	00 00 00 
  1008da:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008e1:	00 00 00 
  1008e4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008eb:	00 00 00 
  1008ee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008f5:	00 00 00 
  1008f8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ff:	00 00 00 
  100902:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100909:	00 00 00 
  10090c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100913:	00 00 00 
  100916:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10091d:	00 00 00 
  100920:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100927:	00 00 00 
  10092a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100931:	00 00 00 
  100934:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10093b:	00 00 00 
  10093e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100945:	00 00 00 
  100948:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10094f:	00 00 00 
  100952:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100959:	00 00 00 
  10095c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100963:	00 00 00 
  100966:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10096d:	00 00 00 
  100970:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100977:	00 00 00 
  10097a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100981:	00 00 00 
  100984:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10098b:	00 00 00 
  10098e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100995:	00 00 00 
  100998:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10099f:	00 00 00 
  1009a2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009a9:	00 00 00 
  1009ac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009b3:	00 00 00 
  1009b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009bd:	00 00 00 
  1009c0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009c7:	00 00 00 
  1009ca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009d1:	00 00 00 
  1009d4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009db:	00 00 00 
  1009de:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009e5:	00 00 00 
  1009e8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009ef:	00 00 00 
  1009f2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009f9:	00 00 00 
  1009fc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a03:	00 00 00 
  100a06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a0d:	00 00 00 
  100a10:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a17:	00 00 00 
  100a1a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a21:	00 00 00 
  100a24:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a2b:	00 00 00 
  100a2e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a35:	00 00 00 
  100a38:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a3f:	00 00 00 
  100a42:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a49:	00 00 00 
  100a4c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a53:	00 00 00 
  100a56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a5d:	00 00 00 
  100a60:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a67:	00 00 00 
  100a6a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a71:	00 00 00 
  100a74:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a7b:	00 00 00 
  100a7e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a85:	00 00 00 
  100a88:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a8f:	00 00 00 
  100a92:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a99:	00 00 00 
  100a9c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aa3:	00 00 00 
  100aa6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aad:	00 00 00 
  100ab0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ab7:	00 00 00 
  100aba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ac1:	00 00 00 
  100ac4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100acb:	00 00 00 
  100ace:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ad5:	00 00 00 
  100ad8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100adf:	00 00 00 
  100ae2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ae9:	00 00 00 
  100aec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100af3:	00 00 00 
  100af6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100afd:	00 00 00 
  100b00:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b07:	00 00 00 
  100b0a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b11:	00 00 00 
  100b14:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b1b:	00 00 00 
  100b1e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b25:	00 00 00 
  100b28:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b2f:	00 00 00 
  100b32:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b39:	00 00 00 
  100b3c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b43:	00 00 00 
  100b46:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b4d:	00 00 00 
  100b50:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b57:	00 00 00 
  100b5a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b61:	00 00 00 
  100b64:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b6b:	00 00 00 
  100b6e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b75:	00 00 00 
  100b78:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b7f:	00 00 00 
  100b82:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b89:	00 00 00 
  100b8c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b93:	00 00 00 
  100b96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b9d:	00 00 00 
  100ba0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ba7:	00 00 00 
  100baa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bb1:	00 00 00 
  100bb4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bbb:	00 00 00 
  100bbe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bc5:	00 00 00 
  100bc8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bcf:	00 00 00 
  100bd2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bd9:	00 00 00 
  100bdc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100be3:	00 00 00 
  100be6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bed:	00 00 00 
  100bf0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bf7:	00 00 00 
  100bfa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c01:	00 00 00 
  100c04:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c0b:	00 00 00 
  100c0e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c15:	00 00 00 
  100c18:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c1f:	00 00 00 
  100c22:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c29:	00 00 00 
  100c2c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c33:	00 00 00 
  100c36:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c3d:	00 00 00 
  100c40:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c47:	00 00 00 
  100c4a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c51:	00 00 00 
  100c54:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c5b:	00 00 00 
  100c5e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c65:	00 00 00 
  100c68:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c6f:	00 00 00 
  100c72:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c79:	00 00 00 
  100c7c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c83:	00 00 00 
  100c86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c8d:	00 00 00 
  100c90:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c97:	00 00 00 
  100c9a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ca1:	00 00 00 
  100ca4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cab:	00 00 00 
  100cae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cb5:	00 00 00 
  100cb8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cbf:	00 00 00 
  100cc2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cc9:	00 00 00 
  100ccc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cd3:	00 00 00 
  100cd6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cdd:	00 00 00 
  100ce0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ce7:	00 00 00 
  100cea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cf1:	00 00 00 
  100cf4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cfb:	00 00 00 
  100cfe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d05:	00 00 00 
  100d08:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d0f:	00 00 00 
  100d12:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d19:	00 00 00 
  100d1c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d23:	00 00 00 
  100d26:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d2d:	00 00 00 
  100d30:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d37:	00 00 00 
  100d3a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d41:	00 00 00 
  100d44:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d4b:	00 00 00 
  100d4e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d55:	00 00 00 
  100d58:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d5f:	00 00 00 
  100d62:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d69:	00 00 00 
  100d6c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d73:	00 00 00 
  100d76:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d7d:	00 00 00 
  100d80:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d87:	00 00 00 
  100d8a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d91:	00 00 00 
  100d94:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d9b:	00 00 00 
  100d9e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100da5:	00 00 00 
  100da8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100daf:	00 00 00 
  100db2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100db9:	00 00 00 
  100dbc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dc3:	00 00 00 
  100dc6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dcd:	00 00 00 
  100dd0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dd7:	00 00 00 
  100dda:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100de1:	00 00 00 
  100de4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100deb:	00 00 00 
  100dee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100df5:	00 00 00 
  100df8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dff:	00 00 00 
  100e02:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e09:	00 00 00 
  100e0c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e13:	00 00 00 
  100e16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e1d:	00 00 00 
  100e20:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e27:	00 00 00 
  100e2a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e31:	00 00 00 
  100e34:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e3b:	00 00 00 
  100e3e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e45:	00 00 00 
  100e48:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e4f:	00 00 00 
  100e52:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e59:	00 00 00 
  100e5c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e63:	00 00 00 
  100e66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e6d:	00 00 00 
  100e70:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e77:	00 00 00 
  100e7a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e81:	00 00 00 
  100e84:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e8b:	00 00 00 
  100e8e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e95:	00 00 00 
  100e98:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e9f:	00 00 00 
  100ea2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ea9:	00 00 00 
  100eac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eb3:	00 00 00 
  100eb6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ebd:	00 00 00 
  100ec0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ec7:	00 00 00 
  100eca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ed1:	00 00 00 
  100ed4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100edb:	00 00 00 
  100ede:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ee5:	00 00 00 
  100ee8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eef:	00 00 00 
  100ef2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ef9:	00 00 00 
  100efc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f03:	00 00 00 
  100f06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f0d:	00 00 00 
  100f10:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f17:	00 00 00 
  100f1a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f21:	00 00 00 
  100f24:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f2b:	00 00 00 
  100f2e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f35:	00 00 00 
  100f38:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f3f:	00 00 00 
  100f42:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f49:	00 00 00 
  100f4c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f53:	00 00 00 
  100f56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f5d:	00 00 00 
  100f60:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f67:	00 00 00 
  100f6a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f71:	00 00 00 
  100f74:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f7b:	00 00 00 
  100f7e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f85:	00 00 00 
  100f88:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f8f:	00 00 00 
  100f92:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f99:	00 00 00 
  100f9c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fa3:	00 00 00 
  100fa6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fad:	00 00 00 
  100fb0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fb7:	00 00 00 
  100fba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fc1:	00 00 00 
  100fc4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fcb:	00 00 00 
  100fce:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fd5:	00 00 00 
  100fd8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fdf:	00 00 00 
  100fe2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fe9:	00 00 00 
  100fec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ff3:	00 00 00 
  100ff6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ffd:	00 00 00 

0000000000101000 <gdt_64>:
	...
  101008:	ff                   	(bad)  
  101009:	ff 00                	incl   (%rax)
  10100b:	00 00                	add    %al,(%rax)
  10100d:	9a                   	(bad)  
  10100e:	af                   	scas   %es:(%rdi),%eax
  10100f:	00 ff                	add    %bh,%bh
  101011:	ff 00                	incl   (%rax)
  101013:	00 00                	add    %al,(%rax)
  101015:	92                   	xchg   %eax,%edx
  101016:	cf                   	iret   
	...

0000000000101018 <gdtdesc_64>:
  101018:	17                   	(bad)  
  101019:	00 00                	add    %al,(%rax)
  10101b:	10 10                	adc    %dl,(%rax)
	...

0000000000102000 <pml4phys>:
	...

0000000000103000 <pdpt1>:
	...

0000000000104000 <pdpt2>:
	...

0000000000105000 <pde1>:
	...

0000000000106000 <pde2>:
	...

0000000000107000 <multiboot_info>:
  107000:	00 00                	add    %al,(%rax)
	...

Disassembly of section .text:

0000008004200000 <_start+0x8003fffff4>:
  8004200000:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  8004200006:	00 00                	add    %al,(%rax)
  8004200008:	fe 4f 52             	decb   0x52(%rdi)
  800420000b:	e4                   	.byte 0xe4

000000800420000c <entry>:
entry:

/* .globl _back_from_head64 */
/* _back_from_head64: */

    movabs   $gdtdesc_64,%rax
  800420000c:	48 b8 38 30 23 04 80 	movabs $0x8004233038,%rax
  8004200013:	00 00 00 
    lgdt     (%rax)
  8004200016:	0f 01 10             	lgdt   (%rax)
    movw    $DATA_SEL,%ax
  8004200019:	66 b8 10 00          	mov    $0x10,%ax
    movw    %ax,%ds
  800420001d:	8e d8                	mov    %eax,%ds
    movw    %ax,%ss
  800420001f:	8e d0                	mov    %eax,%ss
    movw    %ax,%fs
  8004200021:	8e e0                	mov    %eax,%fs
    movw    %ax,%gs
  8004200023:	8e e8                	mov    %eax,%gs
    movw    %ax,%es
  8004200025:	8e c0                	mov    %eax,%es
    pushq   $CODE_SEL
  8004200027:	6a 08                	pushq  $0x8
    movabs  $relocated,%rax
  8004200029:	48 b8 36 00 20 04 80 	movabs $0x8004200036,%rax
  8004200030:	00 00 00 
    pushq   %rax
  8004200033:	50                   	push   %rax
    lretq
  8004200034:	48 cb                	lretq  

0000008004200036 <relocated>:
relocated:

	# Clear the frame pointer register (RBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movq	$0x0,%rbp			# nuke frame pointer
  8004200036:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Set the stack pointer
	movabs	$(bootstacktop),%rax
  800420003d:	48 b8 00 30 23 04 80 	movabs $0x8004233000,%rax
  8004200044:	00 00 00 
	movq  %rax,%rsp
  8004200047:	48 89 c4             	mov    %rax,%rsp

	# now to C code
    movabs $i386_init, %rax
  800420004a:	48 b8 29 01 20 04 80 	movabs $0x8004200129,%rax
  8004200051:	00 00 00 
	call *%rax
  8004200054:	ff d0                	callq  *%rax

0000008004200056 <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
  8004200056:	eb fe                	jmp    8004200056 <spin>

0000008004200058 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004200058:	55                   	push   %rbp
  8004200059:	48 89 e5             	mov    %rsp,%rbp
  800420005c:	48 83 ec 20          	sub    $0x20,%rsp
  8004200060:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004200064:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004200067:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420006b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420006e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004200072:	f0 87 02             	lock xchg %eax,(%rdx)
  8004200075:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004200078:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420007b:	c9                   	leaveq 
  800420007c:	c3                   	retq   

000000800420007d <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  800420007d:	55                   	push   %rbp
  800420007e:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004200081:	48 bf 60 37 23 04 80 	movabs $0x8004233760,%rdi
  8004200088:	00 00 00 
  800420008b:	48 b8 5e 82 21 04 80 	movabs $0x800421825e,%rax
  8004200092:	00 00 00 
  8004200095:	ff d0                	callq  *%rax
}
  8004200097:	90                   	nop
  8004200098:	5d                   	pop    %rbp
  8004200099:	c3                   	retq   

000000800420009a <vmcall>:
#ifdef VMM_GUEST

static void boot_virtual_aps(void);

int64_t vmcall(int num, int check, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420009a:	55                   	push   %rbp
  800420009b:	48 89 e5             	mov    %rsp,%rbp
  800420009e:	53                   	push   %rbx
  800420009f:	48 83 ec 48          	sub    $0x48,%rsp
  80042000a3:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80042000a6:	89 75 d8             	mov    %esi,-0x28(%rbp)
  80042000a9:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  80042000ad:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  80042000b1:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
  80042000b5:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
    int64_t ret;
    asm volatile("vmcall\n" : "=a" (ret) : "a" (num), "d" (a1), "c" (a2), "b" (a3), "D" (a4), "S" (a5) : "cc", "memory");
  80042000b9:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042000bc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042000c0:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80042000c4:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
  80042000c8:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042000cc:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  80042000d0:	4c 89 c3             	mov    %r8,%rbx
  80042000d3:	0f 01 c1             	vmcall 
  80042000d6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if(check && ret > 0) panic("vmcall %d returned %d (> 0)", num, ret);
  80042000da:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  80042000de:	74 3e                	je     800420011e <vmcall+0x84>
  80042000e0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042000e5:	7e 37                	jle    800420011e <vmcall+0x84>
  80042000e7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042000eb:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042000ee:	49 89 d0             	mov    %rdx,%r8
  80042000f1:	89 c1                	mov    %eax,%ecx
  80042000f3:	48 ba c0 ed 21 04 80 	movabs $0x800421edc0,%rdx
  80042000fa:	00 00 00 
  80042000fd:	be 31 00 00 00       	mov    $0x31,%esi
  8004200102:	48 bf dc ed 21 04 80 	movabs $0x800421eddc,%rdi
  8004200109:	00 00 00 
  800420010c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200111:	49 b9 f3 04 20 04 80 	movabs $0x80042004f3,%r9
  8004200118:	00 00 00 
  800420011b:	41 ff d1             	callq  *%r9
    return ret;
  800420011e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004200122:	48 83 c4 48          	add    $0x48,%rsp
  8004200126:	5b                   	pop    %rbx
  8004200127:	5d                   	pop    %rbp
  8004200128:	c3                   	retq   

0000008004200129 <i386_init>:



void
i386_init(void)
{
  8004200129:	55                   	push   %rbp
  800420012a:	48 89 e5             	mov    %rsp,%rbp
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);
  800420012d:	48 ba 10 f0 71 04 80 	movabs $0x800471f010,%rdx
  8004200134:	00 00 00 
  8004200137:	48 b8 b8 c0 4d 04 80 	movabs $0x80044dc0b8,%rax
  800420013e:	00 00 00 
  8004200141:	48 29 c2             	sub    %rax,%rdx
  8004200144:	48 89 d0             	mov    %rdx,%rax
  8004200147:	48 89 c2             	mov    %rax,%rdx
  800420014a:	be 00 00 00 00       	mov    $0x0,%esi
  800420014f:	48 bf b8 c0 4d 04 80 	movabs $0x80044dc0b8,%rdi
  8004200156:	00 00 00 
  8004200159:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  8004200160:	00 00 00 
  8004200163:	ff d0                	callq  *%rax

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();
  8004200165:	48 b8 01 12 20 04 80 	movabs $0x8004201201,%rax
  800420016c:	00 00 00 
  800420016f:	ff d0                	callq  *%rax


	cprintf("6828 decimal is %o octal!\n", 6828);
  8004200171:	be ac 1a 00 00       	mov    $0x1aac,%esi
  8004200176:	48 bf e8 ed 21 04 80 	movabs $0x800421ede8,%rdi
  800420017d:	00 00 00 
  8004200180:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200185:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420018c:	00 00 00 
  800420018f:	ff d2                	callq  *%rdx
	extern char end[];
	end_debug = read_section_headers((0x10000+KERNBASE), (uintptr_t)end);
#endif

	// Lab 2 memory management initialization functions
	x64_vm_init();
  8004200191:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200196:	48 ba 8f 26 20 04 80 	movabs $0x800420268f,%rdx
  800420019d:	00 00 00 
  80042001a0:	ff d2                	callq  *%rdx


	// Lab 3 user environment initialization functions
	env_init();
  80042001a2:	48 b8 de 7f 20 04 80 	movabs $0x8004207fde,%rax
  80042001a9:	00 00 00 
  80042001ac:	ff d0                	callq  *%rax
	trap_init();
  80042001ae:	48 b8 82 9e 20 04 80 	movabs $0x8004209e82,%rax
  80042001b5:	00 00 00 
  80042001b8:	ff d0                	callq  *%rax
	mp_init();
	lapic_init();
#endif

	// Lab 4 multitasking initialization functions
	pic_init();
  80042001ba:	48 b8 04 9a 20 04 80 	movabs $0x8004209a04,%rax
  80042001c1:	00 00 00 
  80042001c4:	ff d0                	callq  *%rax
#endif 

	// Acquire the big kernel lock before waking up APs
	// Your code here:

	lock_kernel();
  80042001c6:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  80042001cd:	00 00 00 
  80042001d0:	ff d0                	callq  *%rax
	// Starting non-boot CPUs
	boot_aps();
#endif

	// Start fs.
	ENV_CREATE(fs_fs, ENV_TYPE_FS);
  80042001d2:	be 01 00 00 00       	mov    $0x1,%esi
  80042001d7:	48 bf 68 cf 2b 04 80 	movabs $0x80042bcf68,%rdi
  80042001de:	00 00 00 
  80042001e1:	48 b8 65 90 20 04 80 	movabs $0x8004209065,%rax
  80042001e8:	00 00 00 
  80042001eb:	ff d0                	callq  *%rax
#if defined(TEST_EPT_MAP)
	test_ept_map();
#endif
#endif

	ENV_CREATE(user_icode, ENV_TYPE_USER);
  80042001ed:	be 00 00 00 00       	mov    $0x0,%esi
  80042001f2:	48 bf 98 4d 2a 04 80 	movabs $0x80042a4d98,%rdi
  80042001f9:	00 00 00 
  80042001fc:	48 b8 65 90 20 04 80 	movabs $0x8004209065,%rax
  8004200203:	00 00 00 
  8004200206:	ff d0                	callq  *%rax

#endif // TEST*


	// Should not be necessary - drains keyboard because interrupt has given up.
	kbd_intr();
  8004200208:	48 b8 2f 10 20 04 80 	movabs $0x800420102f,%rax
  800420020f:	00 00 00 
  8004200212:	ff d0                	callq  *%rax



	// Schedule and run the first user environment!
	sched_yield();
  8004200214:	48 b8 16 da 20 04 80 	movabs $0x800420da16,%rax
  800420021b:	00 00 00 
  800420021e:	ff d0                	callq  *%rax

0000008004200220 <boot_aps>:
void *mpentry_kstack;

// Start the non-boot (AP) processors.
static void
boot_aps(void)
{
  8004200220:	55                   	push   %rbp
  8004200221:	48 89 e5             	mov    %rsp,%rbp
  8004200224:	48 83 ec 30          	sub    $0x30,%rsp
	extern unsigned char mpentry_start[], mpentry_end[];
	void *code;
	struct CpuInfo *c;

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
  8004200228:	48 c7 45 f0 00 70 00 	movq   $0x7000,-0x10(%rbp)
  800420022f:	00 
  8004200230:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200234:	48 c1 e8 0c          	shr    $0xc,%rax
  8004200238:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420023b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420023e:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004200245:	00 00 00 
  8004200248:	48 8b 00             	mov    (%rax),%rax
  800420024b:	48 39 c2             	cmp    %rax,%rdx
  800420024e:	72 32                	jb     8004200282 <boot_aps+0x62>
  8004200250:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200254:	48 89 c1             	mov    %rax,%rcx
  8004200257:	48 ba 08 ee 21 04 80 	movabs $0x800421ee08,%rdx
  800420025e:	00 00 00 
  8004200261:	be ac 00 00 00       	mov    $0xac,%esi
  8004200266:	48 bf dc ed 21 04 80 	movabs $0x800421eddc,%rdi
  800420026d:	00 00 00 
  8004200270:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200275:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420027c:	00 00 00 
  800420027f:	41 ff d0             	callq  *%r8
  8004200282:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004200289:	00 00 00 
  800420028c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200290:	48 01 d0             	add    %rdx,%rax
  8004200293:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
  8004200297:	48 ba 9e 73 21 04 80 	movabs $0x800421739e,%rdx
  800420029e:	00 00 00 
  80042002a1:	48 b8 b8 72 21 04 80 	movabs $0x80042172b8,%rax
  80042002a8:	00 00 00 
  80042002ab:	48 29 c2             	sub    %rax,%rdx
  80042002ae:	48 89 d0             	mov    %rdx,%rax
  80042002b1:	48 89 c2             	mov    %rax,%rdx
  80042002b4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042002b8:	48 be b8 72 21 04 80 	movabs $0x80042172b8,%rsi
  80042002bf:	00 00 00 
  80042002c2:	48 89 c7             	mov    %rax,%rdi
  80042002c5:	48 b8 16 10 21 04 80 	movabs $0x8004211016,%rax
  80042002cc:	00 00 00 
  80042002cf:	ff d0                	callq  *%rax
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  80042002d1:	48 b8 20 e0 6d 04 80 	movabs $0x80046de020,%rax
  80042002d8:	00 00 00 
  80042002db:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042002df:	e9 13 01 00 00       	jmpq   80042003f7 <boot_aps+0x1d7>
		if (c == cpus + cpunum())  // We've started already.
  80042002e4:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  80042002eb:	00 00 00 
  80042002ee:	ff d0                	callq  *%rax
  80042002f0:	48 98                	cltq   
  80042002f2:	48 c1 e0 03          	shl    $0x3,%rax
  80042002f6:	48 89 c2             	mov    %rax,%rdx
  80042002f9:	48 c1 e2 04          	shl    $0x4,%rdx
  80042002fd:	48 01 c2             	add    %rax,%rdx
  8004200300:	48 b8 20 e0 6d 04 80 	movabs $0x80046de020,%rax
  8004200307:	00 00 00 
  800420030a:	48 01 d0             	add    %rdx,%rax
  800420030d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004200311:	0f 84 d7 00 00 00    	je     80042003ee <boot_aps+0x1ce>
			continue;

		// Tell mpentry.S what stack to use 
		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
  8004200317:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420031b:	48 b8 20 e0 6d 04 80 	movabs $0x80046de020,%rax
  8004200322:	00 00 00 
  8004200325:	48 29 c2             	sub    %rax,%rdx
  8004200328:	48 89 d0             	mov    %rdx,%rax
  800420032b:	48 c1 f8 03          	sar    $0x3,%rax
  800420032f:	48 89 c2             	mov    %rax,%rdx
  8004200332:	48 b8 f1 f0 f0 f0 f0 	movabs $0xf0f0f0f0f0f0f0f1,%rax
  8004200339:	f0 f0 f0 
  800420033c:	48 0f af c2          	imul   %rdx,%rax
  8004200340:	48 c1 e0 10          	shl    $0x10,%rax
  8004200344:	48 89 c2             	mov    %rax,%rdx
  8004200347:	48 b8 00 f0 6d 04 80 	movabs $0x80046df000,%rax
  800420034e:	00 00 00 
  8004200351:	48 01 d0             	add    %rdx,%rax
  8004200354:	48 8d 90 00 00 01 00 	lea    0x10000(%rax),%rdx
  800420035b:	48 b8 e0 c5 6d 04 80 	movabs $0x80046dc5e0,%rax
  8004200362:	00 00 00 
  8004200365:	48 89 10             	mov    %rdx,(%rax)
		// Start the CPU at mpentry_start
		lapic_startap(c->cpu_id, PADDR(code));
  8004200368:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420036c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004200370:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004200377:	00 00 00 
  800420037a:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  800420037e:	77 32                	ja     80042003b2 <boot_aps+0x192>
  8004200380:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004200384:	48 89 c1             	mov    %rax,%rcx
  8004200387:	48 ba 30 ee 21 04 80 	movabs $0x800421ee30,%rdx
  800420038e:	00 00 00 
  8004200391:	be b6 00 00 00       	mov    $0xb6,%esi
  8004200396:	48 bf dc ed 21 04 80 	movabs $0x800421eddc,%rdi
  800420039d:	00 00 00 
  80042003a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042003a5:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042003ac:	00 00 00 
  80042003af:	41 ff d0             	callq  *%r8
  80042003b2:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042003b9:	ff ff ff 
  80042003bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042003c0:	48 01 d0             	add    %rdx,%rax
  80042003c3:	89 c2                	mov    %eax,%edx
  80042003c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042003c9:	0f b6 00             	movzbl (%rax),%eax
  80042003cc:	0f b6 c0             	movzbl %al,%eax
  80042003cf:	89 d6                	mov    %edx,%esi
  80042003d1:	89 c7                	mov    %eax,%edi
  80042003d3:	48 b8 3f 7f 21 04 80 	movabs $0x8004217f3f,%rax
  80042003da:	00 00 00 
  80042003dd:	ff d0                	callq  *%rax
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
  80042003df:	90                   	nop
  80042003e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042003e4:	8b 40 04             	mov    0x4(%rax),%eax
  80042003e7:	83 f8 01             	cmp    $0x1,%eax
  80042003ea:	75 f4                	jne    80042003e0 <boot_aps+0x1c0>
  80042003ec:	eb 01                	jmp    80042003ef <boot_aps+0x1cf>
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
		if (c == cpus + cpunum())  // We've started already.
			continue;
  80042003ee:	90                   	nop

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  80042003ef:	48 81 45 f8 88 00 00 	addq   $0x88,-0x8(%rbp)
  80042003f6:	00 
  80042003f7:	48 b8 48 e2 6d 04 80 	movabs $0x80046de248,%rax
  80042003fe:	00 00 00 
  8004200401:	8b 00                	mov    (%rax),%eax
  8004200403:	48 98                	cltq   
  8004200405:	48 c1 e0 03          	shl    $0x3,%rax
  8004200409:	48 89 c2             	mov    %rax,%rdx
  800420040c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200410:	48 01 c2             	add    %rax,%rdx
  8004200413:	48 b8 20 e0 6d 04 80 	movabs $0x80046de020,%rax
  800420041a:	00 00 00 
  800420041d:	48 01 d0             	add    %rdx,%rax
  8004200420:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004200424:	0f 87 ba fe ff ff    	ja     80042002e4 <boot_aps+0xc4>
		lapic_startap(c->cpu_id, PADDR(code));
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
			;
	}
}
  800420042a:	90                   	nop
  800420042b:	c9                   	leaveq 
  800420042c:	c3                   	retq   

000000800420042d <mp_main>:

// Setup code for APs
void
mp_main(void)
{
  800420042d:	55                   	push   %rbp
  800420042e:	48 89 e5             	mov    %rsp,%rbp
  8004200431:	48 83 ec 10          	sub    $0x10,%rsp
	// We are in high EIP now, safe to switch to kern_pgdir 
	lcr3(boot_cr3);
  8004200435:	48 b8 e8 c5 6d 04 80 	movabs $0x80046dc5e8,%rax
  800420043c:	00 00 00 
  800420043f:	48 8b 00             	mov    (%rax),%rax
  8004200442:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004200446:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420044a:	0f 22 d8             	mov    %rax,%cr3
	cprintf("SMP: CPU %d starting\n", cpunum());
  800420044d:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  8004200454:	00 00 00 
  8004200457:	ff d0                	callq  *%rax
  8004200459:	89 c6                	mov    %eax,%esi
  800420045b:	48 bf 54 ee 21 04 80 	movabs $0x800421ee54,%rdi
  8004200462:	00 00 00 
  8004200465:	b8 00 00 00 00       	mov    $0x0,%eax
  800420046a:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004200471:	00 00 00 
  8004200474:	ff d2                	callq  *%rdx

	lapic_init();
  8004200476:	48 b8 d1 7c 21 04 80 	movabs $0x8004217cd1,%rax
  800420047d:	00 00 00 
  8004200480:	ff d0                	callq  *%rax
	env_init_percpu();
  8004200482:	48 b8 ac 80 20 04 80 	movabs $0x80042080ac,%rax
  8004200489:	00 00 00 
  800420048c:	ff d0                	callq  *%rax
	trap_init_percpu();
  800420048e:	48 b8 98 c5 20 04 80 	movabs $0x800420c598,%rax
  8004200495:	00 00 00 
  8004200498:	ff d0                	callq  *%rax
	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
  800420049a:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  80042004a1:	00 00 00 
  80042004a4:	ff d0                	callq  *%rax
  80042004a6:	48 98                	cltq   
  80042004a8:	48 c1 e0 03          	shl    $0x3,%rax
  80042004ac:	48 89 c2             	mov    %rax,%rdx
  80042004af:	48 c1 e2 04          	shl    $0x4,%rdx
  80042004b3:	48 01 d0             	add    %rdx,%rax
  80042004b6:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  80042004bd:	00 00 00 
  80042004c0:	48 01 d0             	add    %rdx,%rax
  80042004c3:	48 83 c0 04          	add    $0x4,%rax
  80042004c7:	be 01 00 00 00       	mov    $0x1,%esi
  80042004cc:	48 89 c7             	mov    %rax,%rdi
  80042004cf:	48 b8 58 00 20 04 80 	movabs $0x8004200058,%rax
  80042004d6:	00 00 00 
  80042004d9:	ff d0                	callq  *%rax
	// to start running processes on this CPU.  But make sure that
	// only one CPU can enter the scheduler at a time!
	//
	// Your code here:

	lock_kernel();
  80042004db:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  80042004e2:	00 00 00 
  80042004e5:	ff d0                	callq  *%rax
	sched_yield();     // start running processes
  80042004e7:	48 b8 16 da 20 04 80 	movabs $0x800420da16,%rax
  80042004ee:	00 00 00 
  80042004f1:	ff d0                	callq  *%rax

00000080042004f3 <_panic>:
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  80042004f3:	55                   	push   %rbp
  80042004f4:	48 89 e5             	mov    %rsp,%rbp
  80042004f7:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  80042004fe:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  8004200505:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  800420050b:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
  8004200512:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004200519:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004200520:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004200527:	84 c0                	test   %al,%al
  8004200529:	74 20                	je     800420054b <_panic+0x58>
  800420052b:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420052f:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004200533:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004200537:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420053b:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420053f:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004200543:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004200547:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;

	if (panicstr)
  800420054b:	48 b8 d8 c5 6d 04 80 	movabs $0x80046dc5d8,%rax
  8004200552:	00 00 00 
  8004200555:	48 8b 00             	mov    (%rax),%rax
  8004200558:	48 85 c0             	test   %rax,%rax
  800420055b:	74 05                	je     8004200562 <_panic+0x6f>
		goto dead;
  800420055d:	e9 ba 00 00 00       	jmpq   800420061c <_panic+0x129>
	panicstr = fmt;
  8004200562:	48 b8 d8 c5 6d 04 80 	movabs $0x80046dc5d8,%rax
  8004200569:	00 00 00 
  800420056c:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  8004200573:	48 89 10             	mov    %rdx,(%rax)

	// Be extra sure that the machine is in as reasonable state
	__asm __volatile("cli; cld");
  8004200576:	fa                   	cli    
  8004200577:	fc                   	cld    

	va_start(ap, fmt);
  8004200578:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420057f:	00 00 00 
  8004200582:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  8004200589:	00 00 00 
  800420058c:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004200590:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004200597:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420059e:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)

	cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
  80042005a5:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  80042005ac:	00 00 00 
  80042005af:	ff d0                	callq  *%rax
  80042005b1:	89 c6                	mov    %eax,%esi
  80042005b3:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  80042005b9:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042005c0:	89 d1                	mov    %edx,%ecx
  80042005c2:	48 89 c2             	mov    %rax,%rdx
  80042005c5:	48 bf 70 ee 21 04 80 	movabs $0x800421ee70,%rdi
  80042005cc:	00 00 00 
  80042005cf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042005d4:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  80042005db:	00 00 00 
  80042005de:	41 ff d0             	callq  *%r8

	vcprintf(fmt, ap);
  80042005e1:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  80042005e8:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042005ef:	48 89 d6             	mov    %rdx,%rsi
  80042005f2:	48 89 c7             	mov    %rax,%rdi
  80042005f5:	48 b8 aa 9c 20 04 80 	movabs $0x8004209caa,%rax
  80042005fc:	00 00 00 
  80042005ff:	ff d0                	callq  *%rax
	cprintf("\n");
  8004200601:	48 bf 92 ee 21 04 80 	movabs $0x800421ee92,%rdi
  8004200608:	00 00 00 
  800420060b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200610:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004200617:	00 00 00 
  800420061a:	ff d2                	callq  *%rdx
	va_end(ap);

dead:
	/* break into the kernel monitor */
	while (1)
		monitor(NULL);
  800420061c:	bf 00 00 00 00       	mov    $0x0,%edi
  8004200621:	48 b8 c0 1a 20 04 80 	movabs $0x8004201ac0,%rax
  8004200628:	00 00 00 
  800420062b:	ff d0                	callq  *%rax
  800420062d:	eb ed                	jmp    800420061c <_panic+0x129>

000000800420062f <_warn>:
}

/* like panic, but don't */
void
_warn(const char *file, int line, const char *fmt,...)
{
  800420062f:	55                   	push   %rbp
  8004200630:	48 89 e5             	mov    %rsp,%rbp
  8004200633:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420063a:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  8004200641:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  8004200647:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
  800420064e:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004200655:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420065c:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004200663:	84 c0                	test   %al,%al
  8004200665:	74 20                	je     8004200687 <_warn+0x58>
  8004200667:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420066b:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420066f:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004200673:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004200677:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420067b:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420067f:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004200683:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;

	va_start(ap, fmt);
  8004200687:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420068e:	00 00 00 
  8004200691:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  8004200698:	00 00 00 
  800420069b:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420069f:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042006a6:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042006ad:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel warning at %s:%d: ", file, line);
  80042006b4:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  80042006ba:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042006c1:	48 89 c6             	mov    %rax,%rsi
  80042006c4:	48 bf 94 ee 21 04 80 	movabs $0x800421ee94,%rdi
  80042006cb:	00 00 00 
  80042006ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80042006d3:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  80042006da:	00 00 00 
  80042006dd:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  80042006df:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  80042006e6:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042006ed:	48 89 d6             	mov    %rdx,%rsi
  80042006f0:	48 89 c7             	mov    %rax,%rdi
  80042006f3:	48 b8 aa 9c 20 04 80 	movabs $0x8004209caa,%rax
  80042006fa:	00 00 00 
  80042006fd:	ff d0                	callq  *%rax
	cprintf("\n");
  80042006ff:	48 bf 92 ee 21 04 80 	movabs $0x800421ee92,%rdi
  8004200706:	00 00 00 
  8004200709:	b8 00 00 00 00       	mov    $0x0,%eax
  800420070e:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004200715:	00 00 00 
  8004200718:	ff d2                	callq  *%rdx
	va_end(ap);
}
  800420071a:	90                   	nop
  800420071b:	c9                   	leaveq 
  800420071c:	c3                   	retq   

000000800420071d <delay>:
static void cons_putc(int c);

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
  800420071d:	55                   	push   %rbp
  800420071e:	48 89 e5             	mov    %rsp,%rbp
  8004200721:	48 83 ec 20          	sub    $0x20,%rsp
  8004200725:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420072c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420072f:	89 c2                	mov    %eax,%edx
  8004200731:	ec                   	in     (%dx),%al
  8004200732:	88 45 ec             	mov    %al,-0x14(%rbp)
  8004200735:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%rbp)
  800420073c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420073f:	89 c2                	mov    %eax,%edx
  8004200741:	ec                   	in     (%dx),%al
  8004200742:	88 45 ed             	mov    %al,-0x13(%rbp)
  8004200745:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%rbp)
  800420074c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420074f:	89 c2                	mov    %eax,%edx
  8004200751:	ec                   	in     (%dx),%al
  8004200752:	88 45 ee             	mov    %al,-0x12(%rbp)
  8004200755:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%rbp)
  800420075c:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800420075f:	89 c2                	mov    %eax,%edx
  8004200761:	ec                   	in     (%dx),%al
  8004200762:	88 45 ef             	mov    %al,-0x11(%rbp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
  8004200765:	90                   	nop
  8004200766:	c9                   	leaveq 
  8004200767:	c3                   	retq   

0000008004200768 <serial_proc_data>:

static bool serial_exists;

static int
serial_proc_data(void)
{
  8004200768:	55                   	push   %rbp
  8004200769:	48 89 e5             	mov    %rsp,%rbp
  800420076c:	48 83 ec 10          	sub    $0x10,%rsp
  8004200770:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%rbp)
  8004200777:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420077a:	89 c2                	mov    %eax,%edx
  800420077c:	ec                   	in     (%dx),%al
  800420077d:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  8004200780:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
  8004200784:	0f b6 c0             	movzbl %al,%eax
  8004200787:	83 e0 01             	and    $0x1,%eax
  800420078a:	85 c0                	test   %eax,%eax
  800420078c:	75 07                	jne    8004200795 <serial_proc_data+0x2d>
		return -1;
  800420078e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200793:	eb 17                	jmp    80042007ac <serial_proc_data+0x44>
  8004200795:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420079c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420079f:	89 c2                	mov    %eax,%edx
  80042007a1:	ec                   	in     (%dx),%al
  80042007a2:	88 45 f6             	mov    %al,-0xa(%rbp)
	return data;
  80042007a5:	0f b6 45 f6          	movzbl -0xa(%rbp),%eax
	return inb(COM1+COM_RX);
  80042007a9:	0f b6 c0             	movzbl %al,%eax
}
  80042007ac:	c9                   	leaveq 
  80042007ad:	c3                   	retq   

00000080042007ae <serial_intr>:

void
serial_intr(void)
{
  80042007ae:	55                   	push   %rbp
  80042007af:	48 89 e5             	mov    %rsp,%rbp
	if (serial_exists)
  80042007b2:	48 b8 00 d0 4d 04 80 	movabs $0x80044dd000,%rax
  80042007b9:	00 00 00 
  80042007bc:	0f b6 00             	movzbl (%rax),%eax
  80042007bf:	84 c0                	test   %al,%al
  80042007c1:	74 16                	je     80042007d9 <serial_intr+0x2b>
		cons_intr(serial_proc_data);
  80042007c3:	48 bf 68 07 20 04 80 	movabs $0x8004200768,%rdi
  80042007ca:	00 00 00 
  80042007cd:	48 b8 82 10 20 04 80 	movabs $0x8004201082,%rax
  80042007d4:	00 00 00 
  80042007d7:	ff d0                	callq  *%rax
}
  80042007d9:	90                   	nop
  80042007da:	5d                   	pop    %rbp
  80042007db:	c3                   	retq   

00000080042007dc <serial_putc>:

static void
serial_putc(int c)
{
  80042007dc:	55                   	push   %rbp
  80042007dd:	48 89 e5             	mov    %rsp,%rbp
  80042007e0:	48 83 ec 18          	sub    $0x18,%rsp
  80042007e4:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int i;

	for (i = 0;
  80042007e7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042007ee:	eb 10                	jmp    8004200800 <serial_putc+0x24>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
		delay();
  80042007f0:	48 b8 1d 07 20 04 80 	movabs $0x800420071d,%rax
  80042007f7:	00 00 00 
  80042007fa:	ff d0                	callq  *%rax
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
  80042007fc:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200800:	c7 45 f4 fd 03 00 00 	movl   $0x3fd,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200807:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420080a:	89 c2                	mov    %eax,%edx
  800420080c:	ec                   	in     (%dx),%al
  800420080d:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  8004200810:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
serial_putc(int c)
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  8004200814:	0f b6 c0             	movzbl %al,%eax
  8004200817:	83 e0 20             	and    $0x20,%eax
static void
serial_putc(int c)
{
	int i;

	for (i = 0;
  800420081a:	85 c0                	test   %eax,%eax
  800420081c:	75 09                	jne    8004200827 <serial_putc+0x4b>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  800420081e:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  8004200825:	7e c9                	jle    80042007f0 <serial_putc+0x14>
	     i++)
		delay();

	outb(COM1 + COM_TX, c);
  8004200827:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420082a:	0f b6 c0             	movzbl %al,%eax
  800420082d:	c7 45 f8 f8 03 00 00 	movl   $0x3f8,-0x8(%rbp)
  8004200834:	88 45 f2             	mov    %al,-0xe(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200837:	0f b6 45 f2          	movzbl -0xe(%rbp),%eax
  800420083b:	8b 55 f8             	mov    -0x8(%rbp),%edx
  800420083e:	ee                   	out    %al,(%dx)
}
  800420083f:	90                   	nop
  8004200840:	c9                   	leaveq 
  8004200841:	c3                   	retq   

0000008004200842 <serial_init>:

static void
serial_init(void)
{
  8004200842:	55                   	push   %rbp
  8004200843:	48 89 e5             	mov    %rsp,%rbp
  8004200846:	48 83 ec 40          	sub    $0x40,%rsp
  800420084a:	c7 45 fc fa 03 00 00 	movl   $0x3fa,-0x4(%rbp)
  8004200851:	c6 45 ce 00          	movb   $0x0,-0x32(%rbp)
  8004200855:	0f b6 45 ce          	movzbl -0x32(%rbp),%eax
  8004200859:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420085c:	ee                   	out    %al,(%dx)
  800420085d:	c7 45 f8 fb 03 00 00 	movl   $0x3fb,-0x8(%rbp)
  8004200864:	c6 45 cf 80          	movb   $0x80,-0x31(%rbp)
  8004200868:	0f b6 45 cf          	movzbl -0x31(%rbp),%eax
  800420086c:	8b 55 f8             	mov    -0x8(%rbp),%edx
  800420086f:	ee                   	out    %al,(%dx)
  8004200870:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%rbp)
  8004200877:	c6 45 d0 0c          	movb   $0xc,-0x30(%rbp)
  800420087b:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
  800420087f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004200882:	ee                   	out    %al,(%dx)
  8004200883:	c7 45 f0 f9 03 00 00 	movl   $0x3f9,-0x10(%rbp)
  800420088a:	c6 45 d1 00          	movb   $0x0,-0x2f(%rbp)
  800420088e:	0f b6 45 d1          	movzbl -0x2f(%rbp),%eax
  8004200892:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200895:	ee                   	out    %al,(%dx)
  8004200896:	c7 45 ec fb 03 00 00 	movl   $0x3fb,-0x14(%rbp)
  800420089d:	c6 45 d2 03          	movb   $0x3,-0x2e(%rbp)
  80042008a1:	0f b6 45 d2          	movzbl -0x2e(%rbp),%eax
  80042008a5:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042008a8:	ee                   	out    %al,(%dx)
  80042008a9:	c7 45 e8 fc 03 00 00 	movl   $0x3fc,-0x18(%rbp)
  80042008b0:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
  80042008b4:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  80042008b8:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042008bb:	ee                   	out    %al,(%dx)
  80042008bc:	c7 45 e4 f9 03 00 00 	movl   $0x3f9,-0x1c(%rbp)
  80042008c3:	c6 45 d4 01          	movb   $0x1,-0x2c(%rbp)
  80042008c7:	0f b6 45 d4          	movzbl -0x2c(%rbp),%eax
  80042008cb:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042008ce:	ee                   	out    %al,(%dx)
  80042008cf:	c7 45 e0 fd 03 00 00 	movl   $0x3fd,-0x20(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042008d6:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042008d9:	89 c2                	mov    %eax,%edx
  80042008db:	ec                   	in     (%dx),%al
  80042008dc:	88 45 d5             	mov    %al,-0x2b(%rbp)
	return data;
  80042008df:	0f b6 45 d5          	movzbl -0x2b(%rbp),%eax
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
  80042008e3:	3c ff                	cmp    $0xff,%al
  80042008e5:	0f 95 c2             	setne  %dl
  80042008e8:	48 b8 00 d0 4d 04 80 	movabs $0x80044dd000,%rax
  80042008ef:	00 00 00 
  80042008f2:	88 10                	mov    %dl,(%rax)
  80042008f4:	c7 45 dc fa 03 00 00 	movl   $0x3fa,-0x24(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042008fb:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042008fe:	89 c2                	mov    %eax,%edx
  8004200900:	ec                   	in     (%dx),%al
  8004200901:	88 45 d6             	mov    %al,-0x2a(%rbp)
  8004200904:	c7 45 d8 f8 03 00 00 	movl   $0x3f8,-0x28(%rbp)
  800420090b:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420090e:	89 c2                	mov    %eax,%edx
  8004200910:	ec                   	in     (%dx),%al
  8004200911:	88 45 d7             	mov    %al,-0x29(%rbp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);


	// Enable serial interrupts
	if (serial_exists)
  8004200914:	48 b8 00 d0 4d 04 80 	movabs $0x80044dd000,%rax
  800420091b:	00 00 00 
  800420091e:	0f b6 00             	movzbl (%rax),%eax
  8004200921:	84 c0                	test   %al,%al
  8004200923:	74 23                	je     8004200948 <serial_init+0x106>
		irq_setmask_8259A(irq_mask_8259A & ~(1<<4));
  8004200925:	48 b8 72 36 23 04 80 	movabs $0x8004233672,%rax
  800420092c:	00 00 00 
  800420092f:	0f b7 00             	movzwl (%rax),%eax
  8004200932:	0f b7 c0             	movzwl %ax,%eax
  8004200935:	25 ef ff 00 00       	and    $0xffef,%eax
  800420093a:	89 c7                	mov    %eax,%edi
  800420093c:	48 b8 57 9b 20 04 80 	movabs $0x8004209b57,%rax
  8004200943:	00 00 00 
  8004200946:	ff d0                	callq  *%rax

}
  8004200948:	90                   	nop
  8004200949:	c9                   	leaveq 
  800420094a:	c3                   	retq   

000000800420094b <lpt_putc>:
// For information on PC parallel port programming, see the class References
// page.

static void
lpt_putc(int c)
{
  800420094b:	55                   	push   %rbp
  800420094c:	48 89 e5             	mov    %rsp,%rbp
  800420094f:	48 83 ec 28          	sub    $0x28,%rsp
  8004200953:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200956:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420095d:	eb 10                	jmp    800420096f <lpt_putc+0x24>
		delay();
  800420095f:	48 b8 1d 07 20 04 80 	movabs $0x800420071d,%rax
  8004200966:	00 00 00 
  8004200969:	ff d0                	callq  *%rax
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  800420096b:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420096f:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%rbp)
  8004200976:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200979:	89 c2                	mov    %eax,%edx
  800420097b:	ec                   	in     (%dx),%al
  800420097c:	88 45 eb             	mov    %al,-0x15(%rbp)
	return data;
  800420097f:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200983:	84 c0                	test   %al,%al
  8004200985:	78 09                	js     8004200990 <lpt_putc+0x45>
  8004200987:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  800420098e:	7e cf                	jle    800420095f <lpt_putc+0x14>
		delay();
	outb(0x378+0, c);
  8004200990:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200993:	0f b6 c0             	movzbl %al,%eax
  8004200996:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%rbp)
  800420099d:	88 45 e8             	mov    %al,-0x18(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042009a0:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  80042009a4:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042009a7:	ee                   	out    %al,(%dx)
  80042009a8:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%rbp)
  80042009af:	c6 45 e9 0d          	movb   $0xd,-0x17(%rbp)
  80042009b3:	0f b6 45 e9          	movzbl -0x17(%rbp),%eax
  80042009b7:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042009ba:	ee                   	out    %al,(%dx)
  80042009bb:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%rbp)
  80042009c2:	c6 45 ea 08          	movb   $0x8,-0x16(%rbp)
  80042009c6:	0f b6 45 ea          	movzbl -0x16(%rbp),%eax
  80042009ca:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80042009cd:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
  80042009ce:	90                   	nop
  80042009cf:	c9                   	leaveq 
  80042009d0:	c3                   	retq   

00000080042009d1 <cga_init>:
static uint16_t crt_pos;


static void
cga_init(void)
{
  80042009d1:	55                   	push   %rbp
  80042009d2:	48 89 e5             	mov    %rsp,%rbp
  80042009d5:	48 83 ec 30          	sub    $0x30,%rsp
	volatile uint16_t *cp;
	uint16_t was;
	unsigned pos;

	cp = (uint16_t*) (KERNBASE + CGA_BUF);
  80042009d9:	48 b8 00 80 0b 04 80 	movabs $0x80040b8000,%rax
  80042009e0:	00 00 00 
  80042009e3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	was = *cp;
  80042009e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042009eb:	0f b7 00             	movzwl (%rax),%eax
  80042009ee:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	*cp = (uint16_t) 0xA55A;
  80042009f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042009f6:	66 c7 00 5a a5       	movw   $0xa55a,(%rax)
	if (*cp != 0xA55A) {
  80042009fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042009ff:	0f b7 00             	movzwl (%rax),%eax
  8004200a02:	66 3d 5a a5          	cmp    $0xa55a,%ax
  8004200a06:	74 20                	je     8004200a28 <cga_init+0x57>
		cp = (uint16_t*) (KERNBASE + MONO_BUF);
  8004200a08:	48 b8 00 00 0b 04 80 	movabs $0x80040b0000,%rax
  8004200a0f:	00 00 00 
  8004200a12:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		addr_6845 = MONO_BASE;
  8004200a16:	48 b8 04 d0 4d 04 80 	movabs $0x80044dd004,%rax
  8004200a1d:	00 00 00 
  8004200a20:	c7 00 b4 03 00 00    	movl   $0x3b4,(%rax)
  8004200a26:	eb 1b                	jmp    8004200a43 <cga_init+0x72>
	} else {
		*cp = was;
  8004200a28:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a2c:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004200a30:	66 89 10             	mov    %dx,(%rax)
		addr_6845 = CGA_BASE;
  8004200a33:	48 b8 04 d0 4d 04 80 	movabs $0x80044dd004,%rax
  8004200a3a:	00 00 00 
  8004200a3d:	c7 00 d4 03 00 00    	movl   $0x3d4,(%rax)
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
  8004200a43:	48 b8 04 d0 4d 04 80 	movabs $0x80044dd004,%rax
  8004200a4a:	00 00 00 
  8004200a4d:	8b 00                	mov    (%rax),%eax
  8004200a4f:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004200a52:	c6 45 dc 0e          	movb   $0xe,-0x24(%rbp)
  8004200a56:	0f b6 45 dc          	movzbl -0x24(%rbp),%eax
  8004200a5a:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200a5d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
  8004200a5e:	48 b8 04 d0 4d 04 80 	movabs $0x80044dd004,%rax
  8004200a65:	00 00 00 
  8004200a68:	8b 00                	mov    (%rax),%eax
  8004200a6a:	83 c0 01             	add    $0x1,%eax
  8004200a6d:	89 45 e8             	mov    %eax,-0x18(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a70:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004200a73:	89 c2                	mov    %eax,%edx
  8004200a75:	ec                   	in     (%dx),%al
  8004200a76:	88 45 dd             	mov    %al,-0x23(%rbp)
	return data;
  8004200a79:	0f b6 45 dd          	movzbl -0x23(%rbp),%eax
  8004200a7d:	0f b6 c0             	movzbl %al,%eax
  8004200a80:	c1 e0 08             	shl    $0x8,%eax
  8004200a83:	89 45 ec             	mov    %eax,-0x14(%rbp)
	outb(addr_6845, 15);
  8004200a86:	48 b8 04 d0 4d 04 80 	movabs $0x80044dd004,%rax
  8004200a8d:	00 00 00 
  8004200a90:	8b 00                	mov    (%rax),%eax
  8004200a92:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004200a95:	c6 45 de 0f          	movb   $0xf,-0x22(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200a99:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  8004200a9d:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200aa0:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
  8004200aa1:	48 b8 04 d0 4d 04 80 	movabs $0x80044dd004,%rax
  8004200aa8:	00 00 00 
  8004200aab:	8b 00                	mov    (%rax),%eax
  8004200aad:	83 c0 01             	add    $0x1,%eax
  8004200ab0:	89 45 e0             	mov    %eax,-0x20(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200ab3:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004200ab6:	89 c2                	mov    %eax,%edx
  8004200ab8:	ec                   	in     (%dx),%al
  8004200ab9:	88 45 df             	mov    %al,-0x21(%rbp)
	return data;
  8004200abc:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200ac0:	0f b6 c0             	movzbl %al,%eax
  8004200ac3:	09 45 ec             	or     %eax,-0x14(%rbp)

	crt_buf = (uint16_t*) cp;
  8004200ac6:	48 b8 08 d0 4d 04 80 	movabs $0x80044dd008,%rax
  8004200acd:	00 00 00 
  8004200ad0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200ad4:	48 89 10             	mov    %rdx,(%rax)
	crt_pos = pos;
  8004200ad7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200ada:	89 c2                	mov    %eax,%edx
  8004200adc:	48 b8 10 d0 4d 04 80 	movabs $0x80044dd010,%rax
  8004200ae3:	00 00 00 
  8004200ae6:	66 89 10             	mov    %dx,(%rax)
}
  8004200ae9:	90                   	nop
  8004200aea:	c9                   	leaveq 
  8004200aeb:	c3                   	retq   

0000008004200aec <cga_putc>:



static void
cga_putc(int c)
{
  8004200aec:	55                   	push   %rbp
  8004200aed:	48 89 e5             	mov    %rsp,%rbp
  8004200af0:	48 83 ec 30          	sub    $0x30,%rsp
  8004200af4:	89 7d dc             	mov    %edi,-0x24(%rbp)

	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
  8004200af7:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200afa:	b0 00                	mov    $0x0,%al
  8004200afc:	85 c0                	test   %eax,%eax
  8004200afe:	75 07                	jne    8004200b07 <cga_putc+0x1b>
		c |= 0x0700;
  8004200b00:	81 4d dc 00 07 00 00 	orl    $0x700,-0x24(%rbp)

	switch (c & 0xff) {
  8004200b07:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200b0a:	0f b6 c0             	movzbl %al,%eax
  8004200b0d:	83 f8 09             	cmp    $0x9,%eax
  8004200b10:	0f 84 f5 00 00 00    	je     8004200c0b <cga_putc+0x11f>
  8004200b16:	83 f8 09             	cmp    $0x9,%eax
  8004200b19:	7f 0a                	jg     8004200b25 <cga_putc+0x39>
  8004200b1b:	83 f8 08             	cmp    $0x8,%eax
  8004200b1e:	74 18                	je     8004200b38 <cga_putc+0x4c>
  8004200b20:	e9 3d 01 00 00       	jmpq   8004200c62 <cga_putc+0x176>
  8004200b25:	83 f8 0a             	cmp    $0xa,%eax
  8004200b28:	74 74                	je     8004200b9e <cga_putc+0xb2>
  8004200b2a:	83 f8 0d             	cmp    $0xd,%eax
  8004200b2d:	0f 84 88 00 00 00    	je     8004200bbb <cga_putc+0xcf>
  8004200b33:	e9 2a 01 00 00       	jmpq   8004200c62 <cga_putc+0x176>
	case '\b':
		if (crt_pos > 0) {
  8004200b38:	48 b8 10 d0 4d 04 80 	movabs $0x80044dd010,%rax
  8004200b3f:	00 00 00 
  8004200b42:	0f b7 00             	movzwl (%rax),%eax
  8004200b45:	66 85 c0             	test   %ax,%ax
  8004200b48:	0f 84 4f 01 00 00    	je     8004200c9d <cga_putc+0x1b1>
			crt_pos--;
  8004200b4e:	48 b8 10 d0 4d 04 80 	movabs $0x80044dd010,%rax
  8004200b55:	00 00 00 
  8004200b58:	0f b7 00             	movzwl (%rax),%eax
  8004200b5b:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004200b5e:	48 b8 10 d0 4d 04 80 	movabs $0x80044dd010,%rax
  8004200b65:	00 00 00 
  8004200b68:	66 89 10             	mov    %dx,(%rax)
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
  8004200b6b:	48 b8 08 d0 4d 04 80 	movabs $0x80044dd008,%rax
  8004200b72:	00 00 00 
  8004200b75:	48 8b 10             	mov    (%rax),%rdx
  8004200b78:	48 b8 10 d0 4d 04 80 	movabs $0x80044dd010,%rax
  8004200b7f:	00 00 00 
  8004200b82:	0f b7 00             	movzwl (%rax),%eax
  8004200b85:	0f b7 c0             	movzwl %ax,%eax
  8004200b88:	48 01 c0             	add    %rax,%rax
  8004200b8b:	48 01 d0             	add    %rdx,%rax
  8004200b8e:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200b91:	b2 00                	mov    $0x0,%dl
  8004200b93:	83 ca 20             	or     $0x20,%edx
  8004200b96:	66 89 10             	mov    %dx,(%rax)
		}
		break;
  8004200b99:	e9 ff 00 00 00       	jmpq   8004200c9d <cga_putc+0x1b1>
	case '\n':
		crt_pos += CRT_COLS;
  8004200b9e:	48 b8 10 d0 4d 04 80 	movabs $0x80044dd010,%rax
  8004200ba5:	00 00 00 
  8004200ba8:	0f b7 00             	movzwl (%rax),%eax
  8004200bab:	8d 50 50             	lea    0x50(%rax),%edx
  8004200bae:	48 b8 10 d0 4d 04 80 	movabs $0x80044dd010,%rax
  8004200bb5:	00 00 00 
  8004200bb8:	66 89 10             	mov    %dx,(%rax)
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
  8004200bbb:	48 b8 10 d0 4d 04 80 	movabs $0x80044dd010,%rax
  8004200bc2:	00 00 00 
  8004200bc5:	0f b7 30             	movzwl (%rax),%esi
  8004200bc8:	48 b8 10 d0 4d 04 80 	movabs $0x80044dd010,%rax
  8004200bcf:	00 00 00 
  8004200bd2:	0f b7 08             	movzwl (%rax),%ecx
  8004200bd5:	0f b7 c1             	movzwl %cx,%eax
  8004200bd8:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  8004200bde:	c1 e8 10             	shr    $0x10,%eax
  8004200be1:	89 c2                	mov    %eax,%edx
  8004200be3:	66 c1 ea 06          	shr    $0x6,%dx
  8004200be7:	89 d0                	mov    %edx,%eax
  8004200be9:	c1 e0 02             	shl    $0x2,%eax
  8004200bec:	01 d0                	add    %edx,%eax
  8004200bee:	c1 e0 04             	shl    $0x4,%eax
  8004200bf1:	29 c1                	sub    %eax,%ecx
  8004200bf3:	89 ca                	mov    %ecx,%edx
  8004200bf5:	29 d6                	sub    %edx,%esi
  8004200bf7:	89 f2                	mov    %esi,%edx
  8004200bf9:	48 b8 10 d0 4d 04 80 	movabs $0x80044dd010,%rax
  8004200c00:	00 00 00 
  8004200c03:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200c06:	e9 93 00 00 00       	jmpq   8004200c9e <cga_putc+0x1b2>
	case '\t':
		cons_putc(' ');
  8004200c0b:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c10:	48 b8 c0 11 20 04 80 	movabs $0x80042011c0,%rax
  8004200c17:	00 00 00 
  8004200c1a:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c1c:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c21:	48 b8 c0 11 20 04 80 	movabs $0x80042011c0,%rax
  8004200c28:	00 00 00 
  8004200c2b:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c2d:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c32:	48 b8 c0 11 20 04 80 	movabs $0x80042011c0,%rax
  8004200c39:	00 00 00 
  8004200c3c:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c3e:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c43:	48 b8 c0 11 20 04 80 	movabs $0x80042011c0,%rax
  8004200c4a:	00 00 00 
  8004200c4d:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c4f:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c54:	48 b8 c0 11 20 04 80 	movabs $0x80042011c0,%rax
  8004200c5b:	00 00 00 
  8004200c5e:	ff d0                	callq  *%rax
		break;
  8004200c60:	eb 3c                	jmp    8004200c9e <cga_putc+0x1b2>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
  8004200c62:	48 b8 08 d0 4d 04 80 	movabs $0x80044dd008,%rax
  8004200c69:	00 00 00 
  8004200c6c:	48 8b 30             	mov    (%rax),%rsi
  8004200c6f:	48 b8 10 d0 4d 04 80 	movabs $0x80044dd010,%rax
  8004200c76:	00 00 00 
  8004200c79:	0f b7 00             	movzwl (%rax),%eax
  8004200c7c:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200c7f:	48 ba 10 d0 4d 04 80 	movabs $0x80044dd010,%rdx
  8004200c86:	00 00 00 
  8004200c89:	66 89 0a             	mov    %cx,(%rdx)
  8004200c8c:	0f b7 c0             	movzwl %ax,%eax
  8004200c8f:	48 01 c0             	add    %rax,%rax
  8004200c92:	48 01 f0             	add    %rsi,%rax
  8004200c95:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200c98:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200c9b:	eb 01                	jmp    8004200c9e <cga_putc+0x1b2>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
  8004200c9d:	90                   	nop
	}


	/* scroll if necessary */

	if (crt_pos >= CRT_SIZE) {
  8004200c9e:	48 b8 10 d0 4d 04 80 	movabs $0x80044dd010,%rax
  8004200ca5:	00 00 00 
  8004200ca8:	0f b7 00             	movzwl (%rax),%eax
  8004200cab:	66 3d cf 07          	cmp    $0x7cf,%ax
  8004200caf:	0f 86 89 00 00 00    	jbe    8004200d3e <cga_putc+0x252>
		int i;


		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  8004200cb5:	48 b8 08 d0 4d 04 80 	movabs $0x80044dd008,%rax
  8004200cbc:	00 00 00 
  8004200cbf:	48 8b 00             	mov    (%rax),%rax
  8004200cc2:	48 8d 88 a0 00 00 00 	lea    0xa0(%rax),%rcx
  8004200cc9:	48 b8 08 d0 4d 04 80 	movabs $0x80044dd008,%rax
  8004200cd0:	00 00 00 
  8004200cd3:	48 8b 00             	mov    (%rax),%rax
  8004200cd6:	ba 00 0f 00 00       	mov    $0xf00,%edx
  8004200cdb:	48 89 ce             	mov    %rcx,%rsi
  8004200cde:	48 89 c7             	mov    %rax,%rdi
  8004200ce1:	48 b8 16 10 21 04 80 	movabs $0x8004211016,%rax
  8004200ce8:	00 00 00 
  8004200ceb:	ff d0                	callq  *%rax
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200ced:	c7 45 fc 80 07 00 00 	movl   $0x780,-0x4(%rbp)
  8004200cf4:	eb 22                	jmp    8004200d18 <cga_putc+0x22c>
			crt_buf[i] = 0x0700 | ' ';
  8004200cf6:	48 b8 08 d0 4d 04 80 	movabs $0x80044dd008,%rax
  8004200cfd:	00 00 00 
  8004200d00:	48 8b 00             	mov    (%rax),%rax
  8004200d03:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200d06:	48 63 d2             	movslq %edx,%rdx
  8004200d09:	48 01 d2             	add    %rdx,%rdx
  8004200d0c:	48 01 d0             	add    %rdx,%rax
  8004200d0f:	66 c7 00 20 07       	movw   $0x720,(%rax)
	if (crt_pos >= CRT_SIZE) {
		int i;


		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200d14:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200d18:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%rbp)
  8004200d1f:	7e d5                	jle    8004200cf6 <cga_putc+0x20a>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
  8004200d21:	48 b8 10 d0 4d 04 80 	movabs $0x80044dd010,%rax
  8004200d28:	00 00 00 
  8004200d2b:	0f b7 00             	movzwl (%rax),%eax
  8004200d2e:	8d 50 b0             	lea    -0x50(%rax),%edx
  8004200d31:	48 b8 10 d0 4d 04 80 	movabs $0x80044dd010,%rax
  8004200d38:	00 00 00 
  8004200d3b:	66 89 10             	mov    %dx,(%rax)
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
  8004200d3e:	48 b8 04 d0 4d 04 80 	movabs $0x80044dd004,%rax
  8004200d45:	00 00 00 
  8004200d48:	8b 00                	mov    (%rax),%eax
  8004200d4a:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004200d4d:	c6 45 e8 0e          	movb   $0xe,-0x18(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200d51:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  8004200d55:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200d58:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
  8004200d59:	48 b8 10 d0 4d 04 80 	movabs $0x80044dd010,%rax
  8004200d60:	00 00 00 
  8004200d63:	0f b7 00             	movzwl (%rax),%eax
  8004200d66:	66 c1 e8 08          	shr    $0x8,%ax
  8004200d6a:	0f b6 c0             	movzbl %al,%eax
  8004200d6d:	48 ba 04 d0 4d 04 80 	movabs $0x80044dd004,%rdx
  8004200d74:	00 00 00 
  8004200d77:	8b 12                	mov    (%rdx),%edx
  8004200d79:	83 c2 01             	add    $0x1,%edx
  8004200d7c:	89 55 f4             	mov    %edx,-0xc(%rbp)
  8004200d7f:	88 45 e9             	mov    %al,-0x17(%rbp)
  8004200d82:	0f b6 45 e9          	movzbl -0x17(%rbp),%eax
  8004200d86:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004200d89:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
  8004200d8a:	48 b8 04 d0 4d 04 80 	movabs $0x80044dd004,%rax
  8004200d91:	00 00 00 
  8004200d94:	8b 00                	mov    (%rax),%eax
  8004200d96:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004200d99:	c6 45 ea 0f          	movb   $0xf,-0x16(%rbp)
  8004200d9d:	0f b6 45 ea          	movzbl -0x16(%rbp),%eax
  8004200da1:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200da4:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
  8004200da5:	48 b8 10 d0 4d 04 80 	movabs $0x80044dd010,%rax
  8004200dac:	00 00 00 
  8004200daf:	0f b7 00             	movzwl (%rax),%eax
  8004200db2:	0f b6 c0             	movzbl %al,%eax
  8004200db5:	48 ba 04 d0 4d 04 80 	movabs $0x80044dd004,%rdx
  8004200dbc:	00 00 00 
  8004200dbf:	8b 12                	mov    (%rdx),%edx
  8004200dc1:	83 c2 01             	add    $0x1,%edx
  8004200dc4:	89 55 ec             	mov    %edx,-0x14(%rbp)
  8004200dc7:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004200dca:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200dce:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200dd1:	ee                   	out    %al,(%dx)
}
  8004200dd2:	90                   	nop
  8004200dd3:	c9                   	leaveq 
  8004200dd4:	c3                   	retq   

0000008004200dd5 <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
  8004200dd5:	55                   	push   %rbp
  8004200dd6:	48 89 e5             	mov    %rsp,%rbp
  8004200dd9:	48 83 ec 20          	sub    $0x20,%rsp
  8004200ddd:	c7 45 e8 64 00 00 00 	movl   $0x64,-0x18(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200de4:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004200de7:	89 c2                	mov    %eax,%edx
  8004200de9:	ec                   	in     (%dx),%al
  8004200dea:	88 45 e7             	mov    %al,-0x19(%rbp)
	return data;
  8004200ded:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
	int c;
	uint8_t data;
	static uint32_t shift;
	int r;
	if ((inb(KBSTATP) & KBS_DIB) == 0)
  8004200df1:	0f b6 c0             	movzbl %al,%eax
  8004200df4:	83 e0 01             	and    $0x1,%eax
  8004200df7:	85 c0                	test   %eax,%eax
  8004200df9:	75 0a                	jne    8004200e05 <kbd_proc_data+0x30>
		return -1;
  8004200dfb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200e00:	e9 28 02 00 00       	jmpq   800420102d <kbd_proc_data+0x258>
  8004200e05:	c7 45 f4 60 00 00 00 	movl   $0x60,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200e0c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200e0f:	89 c2                	mov    %eax,%edx
  8004200e11:	ec                   	in     (%dx),%al
  8004200e12:	88 45 e6             	mov    %al,-0x1a(%rbp)
	return data;
  8004200e15:	0f b6 45 e6          	movzbl -0x1a(%rbp),%eax

	data = inb(KBDATAP);
  8004200e19:	88 45 fb             	mov    %al,-0x5(%rbp)

	if (data == 0xE0) {
  8004200e1c:	80 7d fb e0          	cmpb   $0xe0,-0x5(%rbp)
  8004200e20:	75 27                	jne    8004200e49 <kbd_proc_data+0x74>
		// E0 escape character
		shift |= E0ESC;
  8004200e22:	48 b8 28 d2 4d 04 80 	movabs $0x80044dd228,%rax
  8004200e29:	00 00 00 
  8004200e2c:	8b 00                	mov    (%rax),%eax
  8004200e2e:	83 c8 40             	or     $0x40,%eax
  8004200e31:	89 c2                	mov    %eax,%edx
  8004200e33:	48 b8 28 d2 4d 04 80 	movabs $0x80044dd228,%rax
  8004200e3a:	00 00 00 
  8004200e3d:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200e3f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200e44:	e9 e4 01 00 00       	jmpq   800420102d <kbd_proc_data+0x258>
	} else if (data & 0x80) {
  8004200e49:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e4d:	84 c0                	test   %al,%al
  8004200e4f:	79 65                	jns    8004200eb6 <kbd_proc_data+0xe1>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
  8004200e51:	48 b8 28 d2 4d 04 80 	movabs $0x80044dd228,%rax
  8004200e58:	00 00 00 
  8004200e5b:	8b 00                	mov    (%rax),%eax
  8004200e5d:	83 e0 40             	and    $0x40,%eax
  8004200e60:	85 c0                	test   %eax,%eax
  8004200e62:	75 09                	jne    8004200e6d <kbd_proc_data+0x98>
  8004200e64:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e68:	83 e0 7f             	and    $0x7f,%eax
  8004200e6b:	eb 04                	jmp    8004200e71 <kbd_proc_data+0x9c>
  8004200e6d:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e71:	88 45 fb             	mov    %al,-0x5(%rbp)
		shift &= ~(shiftcode[data] | E0ESC);
  8004200e74:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e78:	48 ba 60 30 23 04 80 	movabs $0x8004233060,%rdx
  8004200e7f:	00 00 00 
  8004200e82:	48 98                	cltq   
  8004200e84:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200e88:	83 c8 40             	or     $0x40,%eax
  8004200e8b:	0f b6 c0             	movzbl %al,%eax
  8004200e8e:	f7 d0                	not    %eax
  8004200e90:	89 c2                	mov    %eax,%edx
  8004200e92:	48 b8 28 d2 4d 04 80 	movabs $0x80044dd228,%rax
  8004200e99:	00 00 00 
  8004200e9c:	8b 00                	mov    (%rax),%eax
  8004200e9e:	21 c2                	and    %eax,%edx
  8004200ea0:	48 b8 28 d2 4d 04 80 	movabs $0x80044dd228,%rax
  8004200ea7:	00 00 00 
  8004200eaa:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200eac:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200eb1:	e9 77 01 00 00       	jmpq   800420102d <kbd_proc_data+0x258>
	} else if (shift & E0ESC) {
  8004200eb6:	48 b8 28 d2 4d 04 80 	movabs $0x80044dd228,%rax
  8004200ebd:	00 00 00 
  8004200ec0:	8b 00                	mov    (%rax),%eax
  8004200ec2:	83 e0 40             	and    $0x40,%eax
  8004200ec5:	85 c0                	test   %eax,%eax
  8004200ec7:	74 21                	je     8004200eea <kbd_proc_data+0x115>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
  8004200ec9:	80 4d fb 80          	orb    $0x80,-0x5(%rbp)
		shift &= ~E0ESC;
  8004200ecd:	48 b8 28 d2 4d 04 80 	movabs $0x80044dd228,%rax
  8004200ed4:	00 00 00 
  8004200ed7:	8b 00                	mov    (%rax),%eax
  8004200ed9:	83 e0 bf             	and    $0xffffffbf,%eax
  8004200edc:	89 c2                	mov    %eax,%edx
  8004200ede:	48 b8 28 d2 4d 04 80 	movabs $0x80044dd228,%rax
  8004200ee5:	00 00 00 
  8004200ee8:	89 10                	mov    %edx,(%rax)
	}

	shift |= shiftcode[data];
  8004200eea:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200eee:	48 ba 60 30 23 04 80 	movabs $0x8004233060,%rdx
  8004200ef5:	00 00 00 
  8004200ef8:	48 98                	cltq   
  8004200efa:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200efe:	0f b6 d0             	movzbl %al,%edx
  8004200f01:	48 b8 28 d2 4d 04 80 	movabs $0x80044dd228,%rax
  8004200f08:	00 00 00 
  8004200f0b:	8b 00                	mov    (%rax),%eax
  8004200f0d:	09 c2                	or     %eax,%edx
  8004200f0f:	48 b8 28 d2 4d 04 80 	movabs $0x80044dd228,%rax
  8004200f16:	00 00 00 
  8004200f19:	89 10                	mov    %edx,(%rax)
	shift ^= togglecode[data];
  8004200f1b:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f1f:	48 ba 60 31 23 04 80 	movabs $0x8004233160,%rdx
  8004200f26:	00 00 00 
  8004200f29:	48 98                	cltq   
  8004200f2b:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200f2f:	0f b6 d0             	movzbl %al,%edx
  8004200f32:	48 b8 28 d2 4d 04 80 	movabs $0x80044dd228,%rax
  8004200f39:	00 00 00 
  8004200f3c:	8b 00                	mov    (%rax),%eax
  8004200f3e:	31 c2                	xor    %eax,%edx
  8004200f40:	48 b8 28 d2 4d 04 80 	movabs $0x80044dd228,%rax
  8004200f47:	00 00 00 
  8004200f4a:	89 10                	mov    %edx,(%rax)

	c = charcode[shift & (CTL | SHIFT)][data];
  8004200f4c:	48 b8 28 d2 4d 04 80 	movabs $0x80044dd228,%rax
  8004200f53:	00 00 00 
  8004200f56:	8b 00                	mov    (%rax),%eax
  8004200f58:	83 e0 03             	and    $0x3,%eax
  8004200f5b:	89 c2                	mov    %eax,%edx
  8004200f5d:	48 b8 60 35 23 04 80 	movabs $0x8004233560,%rax
  8004200f64:	00 00 00 
  8004200f67:	89 d2                	mov    %edx,%edx
  8004200f69:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8004200f6d:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f71:	48 01 d0             	add    %rdx,%rax
  8004200f74:	0f b6 00             	movzbl (%rax),%eax
  8004200f77:	0f b6 c0             	movzbl %al,%eax
  8004200f7a:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (shift & CAPSLOCK) {
  8004200f7d:	48 b8 28 d2 4d 04 80 	movabs $0x80044dd228,%rax
  8004200f84:	00 00 00 
  8004200f87:	8b 00                	mov    (%rax),%eax
  8004200f89:	83 e0 08             	and    $0x8,%eax
  8004200f8c:	85 c0                	test   %eax,%eax
  8004200f8e:	74 22                	je     8004200fb2 <kbd_proc_data+0x1dd>
		if ('a' <= c && c <= 'z')
  8004200f90:	83 7d fc 60          	cmpl   $0x60,-0x4(%rbp)
  8004200f94:	7e 0c                	jle    8004200fa2 <kbd_proc_data+0x1cd>
  8004200f96:	83 7d fc 7a          	cmpl   $0x7a,-0x4(%rbp)
  8004200f9a:	7f 06                	jg     8004200fa2 <kbd_proc_data+0x1cd>
			c += 'A' - 'a';
  8004200f9c:	83 6d fc 20          	subl   $0x20,-0x4(%rbp)
  8004200fa0:	eb 10                	jmp    8004200fb2 <kbd_proc_data+0x1dd>
		else if ('A' <= c && c <= 'Z')
  8004200fa2:	83 7d fc 40          	cmpl   $0x40,-0x4(%rbp)
  8004200fa6:	7e 0a                	jle    8004200fb2 <kbd_proc_data+0x1dd>
  8004200fa8:	83 7d fc 5a          	cmpl   $0x5a,-0x4(%rbp)
  8004200fac:	7f 04                	jg     8004200fb2 <kbd_proc_data+0x1dd>
			c += 'a' - 'A';
  8004200fae:	83 45 fc 20          	addl   $0x20,-0x4(%rbp)
	}

	// Process special keys

	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  8004200fb2:	48 b8 28 d2 4d 04 80 	movabs $0x80044dd228,%rax
  8004200fb9:	00 00 00 
  8004200fbc:	8b 00                	mov    (%rax),%eax
  8004200fbe:	f7 d0                	not    %eax
  8004200fc0:	83 e0 06             	and    $0x6,%eax
  8004200fc3:	85 c0                	test   %eax,%eax
  8004200fc5:	75 37                	jne    8004200ffe <kbd_proc_data+0x229>
  8004200fc7:	81 7d fc e9 00 00 00 	cmpl   $0xe9,-0x4(%rbp)
  8004200fce:	75 2e                	jne    8004200ffe <kbd_proc_data+0x229>
		cprintf("Rebooting!\n");
  8004200fd0:	48 bf ae ee 21 04 80 	movabs $0x800421eeae,%rdi
  8004200fd7:	00 00 00 
  8004200fda:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200fdf:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004200fe6:	00 00 00 
  8004200fe9:	ff d2                	callq  *%rdx
  8004200feb:	c7 45 f0 92 00 00 00 	movl   $0x92,-0x10(%rbp)
  8004200ff2:	c6 45 e5 03          	movb   $0x3,-0x1b(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200ff6:	0f b6 45 e5          	movzbl -0x1b(%rbp),%eax
  8004200ffa:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200ffd:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

#ifdef VMM_GUEST
	if (c == 0x1b) {
  8004200ffe:	83 7d fc 1b          	cmpl   $0x1b,-0x4(%rbp)
  8004201002:	75 26                	jne    800420102a <kbd_proc_data+0x255>
		cprintf("ESC pressed\n");
  8004201004:	48 bf ba ee 21 04 80 	movabs $0x800421eeba,%rdi
  800420100b:	00 00 00 
  800420100e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201013:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420101a:	00 00 00 
  800420101d:	ff d2                	callq  *%rdx
		asm("vmcall":"=a"(r): "0"(VMX_VMCALL_BACKTOHOST));
  800420101f:	b8 05 00 00 00       	mov    $0x5,%eax
  8004201024:	0f 01 c1             	vmcall 
  8004201027:	89 45 ec             	mov    %eax,-0x14(%rbp)
	}
#endif

	return c;
  800420102a:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420102d:	c9                   	leaveq 
  800420102e:	c3                   	retq   

000000800420102f <kbd_intr>:

void
kbd_intr(void)
{
  800420102f:	55                   	push   %rbp
  8004201030:	48 89 e5             	mov    %rsp,%rbp
	cons_intr(kbd_proc_data);
  8004201033:	48 bf d5 0d 20 04 80 	movabs $0x8004200dd5,%rdi
  800420103a:	00 00 00 
  800420103d:	48 b8 82 10 20 04 80 	movabs $0x8004201082,%rax
  8004201044:	00 00 00 
  8004201047:	ff d0                	callq  *%rax
}
  8004201049:	90                   	nop
  800420104a:	5d                   	pop    %rbp
  800420104b:	c3                   	retq   

000000800420104c <kbd_init>:

static void
kbd_init(void)
{
  800420104c:	55                   	push   %rbp
  800420104d:	48 89 e5             	mov    %rsp,%rbp

	// Drain the kbd buffer so that Bochs generates interrupts.
	kbd_intr();
  8004201050:	48 b8 2f 10 20 04 80 	movabs $0x800420102f,%rax
  8004201057:	00 00 00 
  800420105a:	ff d0                	callq  *%rax
	irq_setmask_8259A(irq_mask_8259A & ~(1<<1));
  800420105c:	48 b8 72 36 23 04 80 	movabs $0x8004233672,%rax
  8004201063:	00 00 00 
  8004201066:	0f b7 00             	movzwl (%rax),%eax
  8004201069:	0f b7 c0             	movzwl %ax,%eax
  800420106c:	25 fd ff 00 00       	and    $0xfffd,%eax
  8004201071:	89 c7                	mov    %eax,%edi
  8004201073:	48 b8 57 9b 20 04 80 	movabs $0x8004209b57,%rax
  800420107a:	00 00 00 
  800420107d:	ff d0                	callq  *%rax

}
  800420107f:	90                   	nop
  8004201080:	5d                   	pop    %rbp
  8004201081:	c3                   	retq   

0000008004201082 <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
static void
cons_intr(int (*proc)(void))
{
  8004201082:	55                   	push   %rbp
  8004201083:	48 89 e5             	mov    %rsp,%rbp
  8004201086:	48 83 ec 20          	sub    $0x20,%rsp
  800420108a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int c;

	while ((c = (*proc)()) != -1) {
  800420108e:	eb 6a                	jmp    80042010fa <cons_intr+0x78>
		if (c == 0)
  8004201090:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201094:	75 02                	jne    8004201098 <cons_intr+0x16>
			continue;
  8004201096:	eb 62                	jmp    80042010fa <cons_intr+0x78>
		cons.buf[cons.wpos++] = c;
  8004201098:	48 b8 20 d0 4d 04 80 	movabs $0x80044dd020,%rax
  800420109f:	00 00 00 
  80042010a2:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042010a8:	8d 48 01             	lea    0x1(%rax),%ecx
  80042010ab:	48 ba 20 d0 4d 04 80 	movabs $0x80044dd020,%rdx
  80042010b2:	00 00 00 
  80042010b5:	89 8a 04 02 00 00    	mov    %ecx,0x204(%rdx)
  80042010bb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042010be:	89 d1                	mov    %edx,%ecx
  80042010c0:	48 ba 20 d0 4d 04 80 	movabs $0x80044dd020,%rdx
  80042010c7:	00 00 00 
  80042010ca:	89 c0                	mov    %eax,%eax
  80042010cc:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
		if (cons.wpos == CONSBUFSIZE)
  80042010cf:	48 b8 20 d0 4d 04 80 	movabs $0x80044dd020,%rax
  80042010d6:	00 00 00 
  80042010d9:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042010df:	3d 00 02 00 00       	cmp    $0x200,%eax
  80042010e4:	75 14                	jne    80042010fa <cons_intr+0x78>
			cons.wpos = 0;
  80042010e6:	48 b8 20 d0 4d 04 80 	movabs $0x80044dd020,%rax
  80042010ed:	00 00 00 
  80042010f0:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%rax)
  80042010f7:	00 00 00 
static void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
  80042010fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042010fe:	ff d0                	callq  *%rax
  8004201100:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004201103:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  8004201107:	75 87                	jne    8004201090 <cons_intr+0xe>
			continue;
		cons.buf[cons.wpos++] = c;
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;
	}
}
  8004201109:	90                   	nop
  800420110a:	c9                   	leaveq 
  800420110b:	c3                   	retq   

000000800420110c <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
  800420110c:	55                   	push   %rbp
  800420110d:	48 89 e5             	mov    %rsp,%rbp
  8004201110:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
  8004201114:	48 b8 ae 07 20 04 80 	movabs $0x80042007ae,%rax
  800420111b:	00 00 00 
  800420111e:	ff d0                	callq  *%rax
	kbd_intr();
  8004201120:	48 b8 2f 10 20 04 80 	movabs $0x800420102f,%rax
  8004201127:	00 00 00 
  800420112a:	ff d0                	callq  *%rax

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
  800420112c:	48 b8 20 d0 4d 04 80 	movabs $0x80044dd020,%rax
  8004201133:	00 00 00 
  8004201136:	8b 90 00 02 00 00    	mov    0x200(%rax),%edx
  800420113c:	48 b8 20 d0 4d 04 80 	movabs $0x80044dd020,%rax
  8004201143:	00 00 00 
  8004201146:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  800420114c:	39 c2                	cmp    %eax,%edx
  800420114e:	74 69                	je     80042011b9 <cons_getc+0xad>
		c = cons.buf[cons.rpos++];
  8004201150:	48 b8 20 d0 4d 04 80 	movabs $0x80044dd020,%rax
  8004201157:	00 00 00 
  800420115a:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004201160:	8d 48 01             	lea    0x1(%rax),%ecx
  8004201163:	48 ba 20 d0 4d 04 80 	movabs $0x80044dd020,%rdx
  800420116a:	00 00 00 
  800420116d:	89 8a 00 02 00 00    	mov    %ecx,0x200(%rdx)
  8004201173:	48 ba 20 d0 4d 04 80 	movabs $0x80044dd020,%rdx
  800420117a:	00 00 00 
  800420117d:	89 c0                	mov    %eax,%eax
  800420117f:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004201183:	0f b6 c0             	movzbl %al,%eax
  8004201186:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (cons.rpos == CONSBUFSIZE)
  8004201189:	48 b8 20 d0 4d 04 80 	movabs $0x80044dd020,%rax
  8004201190:	00 00 00 
  8004201193:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004201199:	3d 00 02 00 00       	cmp    $0x200,%eax
  800420119e:	75 14                	jne    80042011b4 <cons_getc+0xa8>
			cons.rpos = 0;
  80042011a0:	48 b8 20 d0 4d 04 80 	movabs $0x80044dd020,%rax
  80042011a7:	00 00 00 
  80042011aa:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%rax)
  80042011b1:	00 00 00 
		return c;
  80042011b4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011b7:	eb 05                	jmp    80042011be <cons_getc+0xb2>
	}
	return 0;
  80042011b9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042011be:	c9                   	leaveq 
  80042011bf:	c3                   	retq   

00000080042011c0 <cons_putc>:

// output a character to the console
static void
cons_putc(int c)
{
  80042011c0:	55                   	push   %rbp
  80042011c1:	48 89 e5             	mov    %rsp,%rbp
  80042011c4:	48 83 ec 10          	sub    $0x10,%rsp
  80042011c8:	89 7d fc             	mov    %edi,-0x4(%rbp)
	serial_putc(c);
  80042011cb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011ce:	89 c7                	mov    %eax,%edi
  80042011d0:	48 b8 dc 07 20 04 80 	movabs $0x80042007dc,%rax
  80042011d7:	00 00 00 
  80042011da:	ff d0                	callq  *%rax
	lpt_putc(c);
  80042011dc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011df:	89 c7                	mov    %eax,%edi
  80042011e1:	48 b8 4b 09 20 04 80 	movabs $0x800420094b,%rax
  80042011e8:	00 00 00 
  80042011eb:	ff d0                	callq  *%rax
	cga_putc(c);
  80042011ed:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011f0:	89 c7                	mov    %eax,%edi
  80042011f2:	48 b8 ec 0a 20 04 80 	movabs $0x8004200aec,%rax
  80042011f9:	00 00 00 
  80042011fc:	ff d0                	callq  *%rax
}
  80042011fe:	90                   	nop
  80042011ff:	c9                   	leaveq 
  8004201200:	c3                   	retq   

0000008004201201 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
  8004201201:	55                   	push   %rbp
  8004201202:	48 89 e5             	mov    %rsp,%rbp
	cga_init();
  8004201205:	48 b8 d1 09 20 04 80 	movabs $0x80042009d1,%rax
  800420120c:	00 00 00 
  800420120f:	ff d0                	callq  *%rax
	kbd_init();
  8004201211:	48 b8 4c 10 20 04 80 	movabs $0x800420104c,%rax
  8004201218:	00 00 00 
  800420121b:	ff d0                	callq  *%rax
	serial_init();
  800420121d:	48 b8 42 08 20 04 80 	movabs $0x8004200842,%rax
  8004201224:	00 00 00 
  8004201227:	ff d0                	callq  *%rax

	if (!serial_exists)
  8004201229:	48 b8 00 d0 4d 04 80 	movabs $0x80044dd000,%rax
  8004201230:	00 00 00 
  8004201233:	0f b6 00             	movzbl (%rax),%eax
  8004201236:	83 f0 01             	xor    $0x1,%eax
  8004201239:	84 c0                	test   %al,%al
  800420123b:	74 1b                	je     8004201258 <cons_init+0x57>
		cprintf("Serial port does not exist!\n");
  800420123d:	48 bf c7 ee 21 04 80 	movabs $0x800421eec7,%rdi
  8004201244:	00 00 00 
  8004201247:	b8 00 00 00 00       	mov    $0x0,%eax
  800420124c:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004201253:	00 00 00 
  8004201256:	ff d2                	callq  *%rdx
}
  8004201258:	90                   	nop
  8004201259:	5d                   	pop    %rbp
  800420125a:	c3                   	retq   

000000800420125b <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
  800420125b:	55                   	push   %rbp
  800420125c:	48 89 e5             	mov    %rsp,%rbp
  800420125f:	48 83 ec 10          	sub    $0x10,%rsp
  8004201263:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cons_putc(c);
  8004201266:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201269:	89 c7                	mov    %eax,%edi
  800420126b:	48 b8 c0 11 20 04 80 	movabs $0x80042011c0,%rax
  8004201272:	00 00 00 
  8004201275:	ff d0                	callq  *%rax
}
  8004201277:	90                   	nop
  8004201278:	c9                   	leaveq 
  8004201279:	c3                   	retq   

000000800420127a <getchar>:

int
getchar(void)
{
  800420127a:	55                   	push   %rbp
  800420127b:	48 89 e5             	mov    %rsp,%rbp
  800420127e:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	while ((c = cons_getc()) == 0)
  8004201282:	48 b8 0c 11 20 04 80 	movabs $0x800420110c,%rax
  8004201289:	00 00 00 
  800420128c:	ff d0                	callq  *%rax
  800420128e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004201291:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201295:	74 eb                	je     8004201282 <getchar+0x8>
		/* do nothing */;
	return c;
  8004201297:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420129a:	c9                   	leaveq 
  800420129b:	c3                   	retq   

000000800420129c <iscons>:

int
iscons(int fdnum)
{
  800420129c:	55                   	push   %rbp
  800420129d:	48 89 e5             	mov    %rsp,%rbp
  80042012a0:	48 83 ec 08          	sub    $0x8,%rsp
  80042012a4:	89 7d fc             	mov    %edi,-0x4(%rbp)
	// used by readline
	return 1;
  80042012a7:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80042012ac:	c9                   	leaveq 
  80042012ad:	c3                   	retq   

00000080042012ae <mon_help>:

/***** Implementations of basic kernel monitor commands *****/

int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
  80042012ae:	55                   	push   %rbp
  80042012af:	48 89 e5             	mov    %rsp,%rbp
  80042012b2:	48 83 ec 30          	sub    $0x30,%rsp
  80042012b6:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042012b9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042012bd:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  80042012c1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042012c8:	eb 6f                	jmp    8004201339 <mon_help+0x8b>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  80042012ca:	48 b9 80 35 23 04 80 	movabs $0x8004233580,%rcx
  80042012d1:	00 00 00 
  80042012d4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012d7:	48 63 d0             	movslq %eax,%rdx
  80042012da:	48 89 d0             	mov    %rdx,%rax
  80042012dd:	48 01 c0             	add    %rax,%rax
  80042012e0:	48 01 d0             	add    %rdx,%rax
  80042012e3:	48 c1 e0 03          	shl    $0x3,%rax
  80042012e7:	48 01 c8             	add    %rcx,%rax
  80042012ea:	48 83 c0 08          	add    $0x8,%rax
  80042012ee:	48 8b 08             	mov    (%rax),%rcx
  80042012f1:	48 be 80 35 23 04 80 	movabs $0x8004233580,%rsi
  80042012f8:	00 00 00 
  80042012fb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012fe:	48 63 d0             	movslq %eax,%rdx
  8004201301:	48 89 d0             	mov    %rdx,%rax
  8004201304:	48 01 c0             	add    %rax,%rax
  8004201307:	48 01 d0             	add    %rdx,%rax
  800420130a:	48 c1 e0 03          	shl    $0x3,%rax
  800420130e:	48 01 f0             	add    %rsi,%rax
  8004201311:	48 8b 00             	mov    (%rax),%rax
  8004201314:	48 89 ca             	mov    %rcx,%rdx
  8004201317:	48 89 c6             	mov    %rax,%rsi
  800420131a:	48 bf 75 ef 21 04 80 	movabs $0x800421ef75,%rdi
  8004201321:	00 00 00 
  8004201324:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201329:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  8004201330:	00 00 00 
  8004201333:	ff d1                	callq  *%rcx
int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  8004201335:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004201339:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420133c:	83 f8 03             	cmp    $0x3,%eax
  800420133f:	76 89                	jbe    80042012ca <mon_help+0x1c>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
	return 0;
  8004201341:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201346:	c9                   	leaveq 
  8004201347:	c3                   	retq   

0000008004201348 <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  8004201348:	55                   	push   %rbp
  8004201349:	48 89 e5             	mov    %rsp,%rbp
  800420134c:	48 83 ec 30          	sub    $0x30,%rsp
  8004201350:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004201353:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004201357:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	extern char _start[], entry[], etext[], edata[], end[];

	cprintf("Special kernel symbols:\n");
  800420135b:	48 bf 7e ef 21 04 80 	movabs $0x800421ef7e,%rdi
  8004201362:	00 00 00 
  8004201365:	b8 00 00 00 00       	mov    $0x0,%eax
  800420136a:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004201371:	00 00 00 
  8004201374:	ff d2                	callq  *%rdx
	cprintf("  _start                  %08x (phys)\n", _start);
  8004201376:	48 be 0c 00 20 00 00 	movabs $0x20000c,%rsi
  800420137d:	00 00 00 
  8004201380:	48 bf 98 ef 21 04 80 	movabs $0x800421ef98,%rdi
  8004201387:	00 00 00 
  800420138a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420138f:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004201396:	00 00 00 
  8004201399:	ff d2                	callq  *%rdx
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
  800420139b:	48 b8 0c 00 20 00 00 	movabs $0x20000c,%rax
  80042013a2:	00 00 00 
  80042013a5:	48 89 c2             	mov    %rax,%rdx
  80042013a8:	48 be 0c 00 20 04 80 	movabs $0x800420000c,%rsi
  80042013af:	00 00 00 
  80042013b2:	48 bf c0 ef 21 04 80 	movabs $0x800421efc0,%rdi
  80042013b9:	00 00 00 
  80042013bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013c1:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  80042013c8:	00 00 00 
  80042013cb:	ff d1                	callq  *%rcx
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
  80042013cd:	48 b8 a2 ed 21 00 00 	movabs $0x21eda2,%rax
  80042013d4:	00 00 00 
  80042013d7:	48 89 c2             	mov    %rax,%rdx
  80042013da:	48 be a2 ed 21 04 80 	movabs $0x800421eda2,%rsi
  80042013e1:	00 00 00 
  80042013e4:	48 bf e8 ef 21 04 80 	movabs $0x800421efe8,%rdi
  80042013eb:	00 00 00 
  80042013ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013f3:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  80042013fa:	00 00 00 
  80042013fd:	ff d1                	callq  *%rcx
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
  80042013ff:	48 b8 b8 c0 4d 00 00 	movabs $0x4dc0b8,%rax
  8004201406:	00 00 00 
  8004201409:	48 89 c2             	mov    %rax,%rdx
  800420140c:	48 be b8 c0 4d 04 80 	movabs $0x80044dc0b8,%rsi
  8004201413:	00 00 00 
  8004201416:	48 bf 10 f0 21 04 80 	movabs $0x800421f010,%rdi
  800420141d:	00 00 00 
  8004201420:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201425:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800420142c:	00 00 00 
  800420142f:	ff d1                	callq  *%rcx
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
  8004201431:	48 b8 10 f0 71 00 00 	movabs $0x71f010,%rax
  8004201438:	00 00 00 
  800420143b:	48 89 c2             	mov    %rax,%rdx
  800420143e:	48 be 10 f0 71 04 80 	movabs $0x800471f010,%rsi
  8004201445:	00 00 00 
  8004201448:	48 bf 38 f0 21 04 80 	movabs $0x800421f038,%rdi
  800420144f:	00 00 00 
  8004201452:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201457:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800420145e:	00 00 00 
  8004201461:	ff d1                	callq  *%rcx
	cprintf("Kernel executable memory footprint: %dKB\n",
		ROUNDUP(end - entry, 1024) / 1024);
  8004201463:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  800420146a:	00 
  800420146b:	48 b8 0c 00 20 04 80 	movabs $0x800420000c,%rax
  8004201472:	00 00 00 
  8004201475:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201479:	48 29 c2             	sub    %rax,%rdx
  800420147c:	48 b8 10 f0 71 04 80 	movabs $0x800471f010,%rax
  8004201483:	00 00 00 
  8004201486:	48 83 e8 01          	sub    $0x1,%rax
  800420148a:	48 01 d0             	add    %rdx,%rax
  800420148d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004201491:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201495:	ba 00 00 00 00       	mov    $0x0,%edx
  800420149a:	48 f7 75 f8          	divq   -0x8(%rbp)
  800420149e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042014a2:	48 29 d0             	sub    %rdx,%rax
	cprintf("  _start                  %08x (phys)\n", _start);
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
	cprintf("Kernel executable memory footprint: %dKB\n",
  80042014a5:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  80042014ac:	48 85 c0             	test   %rax,%rax
  80042014af:	48 0f 48 c2          	cmovs  %rdx,%rax
  80042014b3:	48 c1 f8 0a          	sar    $0xa,%rax
  80042014b7:	48 89 c6             	mov    %rax,%rsi
  80042014ba:	48 bf 60 f0 21 04 80 	movabs $0x800421f060,%rdi
  80042014c1:	00 00 00 
  80042014c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014c9:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  80042014d0:	00 00 00 
  80042014d3:	ff d2                	callq  *%rdx
		ROUNDUP(end - entry, 1024) / 1024);
	return 0;
  80042014d5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042014da:	c9                   	leaveq 
  80042014db:	c3                   	retq   

00000080042014dc <mon_backtrace>:

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
  80042014dc:	55                   	push   %rbp
  80042014dd:	48 89 e5             	mov    %rsp,%rbp
  80042014e0:	48 81 ec 50 05 00 00 	sub    $0x550,%rsp
  80042014e7:	89 bd cc fa ff ff    	mov    %edi,-0x534(%rbp)
  80042014ed:	48 89 b5 c0 fa ff ff 	mov    %rsi,-0x540(%rbp)
  80042014f4:	48 89 95 b8 fa ff ff 	mov    %rdx,-0x548(%rbp)

static __inline uint64_t
read_rbp(void)
{
	uint64_t rbp;
	__asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  80042014fb:	48 89 e8             	mov    %rbp,%rax
  80042014fe:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	return rbp;
  8004201502:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
	uint64_t rip;
	uint64_t rsp;
	uint64_t offset;
	struct Ripdebuginfo info;

	rbp = (const uint64_t*)read_rbp();
  8004201506:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

static __inline uint64_t
read_rsp(void)
{
	uint64_t esp;
	__asm __volatile("movq %%rsp,%0" : "=r" (esp));
  800420150a:	48 89 e0             	mov    %rsp,%rax
  800420150d:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	return esp;
  8004201511:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
	rsp = read_rsp();
  8004201515:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	if (tf) {
  8004201519:	48 83 bd b8 fa ff ff 	cmpq   $0x0,-0x548(%rbp)
  8004201520:	00 
  8004201521:	74 21                	je     8004201544 <mon_backtrace+0x68>
		rbp = (const uint64_t*)tf->tf_regs.reg_rbp;
  8004201523:	48 8b 85 b8 fa ff ff 	mov    -0x548(%rbp),%rax
  800420152a:	48 8b 40 50          	mov    0x50(%rax),%rax
  800420152e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		rsp = tf->tf_rsp;
  8004201532:	48 8b 85 b8 fa ff ff 	mov    -0x548(%rbp),%rax
  8004201539:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  8004201540:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	read_rip(rip);
  8004201544:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 800420154b <mon_backtrace+0x6f>
  800420154b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cprintf("Stack backtrace:\n");
  800420154f:	48 bf 8a f0 21 04 80 	movabs $0x800421f08a,%rdi
  8004201556:	00 00 00 
  8004201559:	b8 00 00 00 00       	mov    $0x0,%eax
  800420155e:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004201565:	00 00 00 
  8004201568:	ff d2                	callq  *%rdx
	while (rbp) {
  800420156a:	e9 15 03 00 00       	jmpq   8004201884 <mon_backtrace+0x3a8>
		// print this stack frame
		cprintf("  rbp %016llx  rip %016llx\n", rbp, rip);
  800420156f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201573:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201577:	48 89 c6             	mov    %rax,%rsi
  800420157a:	48 bf 9c f0 21 04 80 	movabs $0x800421f09c,%rdi
  8004201581:	00 00 00 
  8004201584:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201589:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  8004201590:	00 00 00 
  8004201593:	ff d1                	callq  *%rcx
		if (debuginfo_rip(rip, &info) >= 0){
  8004201595:	48 8d 95 d0 fa ff ff 	lea    -0x530(%rbp),%rdx
  800420159c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042015a0:	48 89 d6             	mov    %rdx,%rsi
  80042015a3:	48 89 c7             	mov    %rax,%rdi
  80042015a6:	48 b8 26 fc 20 04 80 	movabs $0x800420fc26,%rax
  80042015ad:	00 00 00 
  80042015b0:	ff d0                	callq  *%rax
  80042015b2:	85 c0                	test   %eax,%eax
  80042015b4:	0f 88 98 02 00 00    	js     8004201852 <mon_backtrace+0x376>
			Dwarf_Regtable_Entry *cfa_rule = &info.reg_table.cfa_rule;
  80042015ba:	48 8d 85 d0 fa ff ff 	lea    -0x530(%rbp),%rax
  80042015c1:	48 05 a8 00 00 00    	add    $0xa8,%rax
  80042015c7:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
			uint64_t cfa;

			cprintf("       %s:%d: %.*s+%016llx", info.rip_file, info.rip_line, 
				info.rip_fn_namelen, info.rip_fn_name, rip - info.rip_fn_addr);
  80042015cb:	48 8b 85 f0 fa ff ff 	mov    -0x510(%rbp),%rax
		cprintf("  rbp %016llx  rip %016llx\n", rbp, rip);
		if (debuginfo_rip(rip, &info) >= 0){
			Dwarf_Regtable_Entry *cfa_rule = &info.reg_table.cfa_rule;
			uint64_t cfa;

			cprintf("       %s:%d: %.*s+%016llx", info.rip_file, info.rip_line, 
  80042015d2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042015d6:	48 89 d7             	mov    %rdx,%rdi
  80042015d9:	48 29 c7             	sub    %rax,%rdi
  80042015dc:	48 8b b5 e0 fa ff ff 	mov    -0x520(%rbp),%rsi
  80042015e3:	8b 8d e8 fa ff ff    	mov    -0x518(%rbp),%ecx
  80042015e9:	8b 95 d8 fa ff ff    	mov    -0x528(%rbp),%edx
  80042015ef:	48 8b 85 d0 fa ff ff 	mov    -0x530(%rbp),%rax
  80042015f6:	49 89 f9             	mov    %rdi,%r9
  80042015f9:	49 89 f0             	mov    %rsi,%r8
  80042015fc:	48 89 c6             	mov    %rax,%rsi
  80042015ff:	48 bf b8 f0 21 04 80 	movabs $0x800421f0b8,%rdi
  8004201606:	00 00 00 
  8004201609:	b8 00 00 00 00       	mov    $0x0,%eax
  800420160e:	49 ba 09 9d 20 04 80 	movabs $0x8004209d09,%r10
  8004201615:	00 00 00 
  8004201618:	41 ff d2             	callq  *%r10
				info.rip_fn_namelen, info.rip_fn_name, rip - info.rip_fn_addr);

			if (cfa_rule->dw_regnum == 6) { /* 6: rbp */
  800420161b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420161f:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004201623:	66 83 f8 06          	cmp    $0x6,%ax
  8004201627:	75 15                	jne    800420163e <mon_backtrace+0x162>
				cfa = (uint64_t)rbp + cfa_rule->dw_offset;
  8004201629:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420162d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004201631:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201635:	48 01 d0             	add    %rdx,%rax
  8004201638:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420163c:	eb 25                	jmp    8004201663 <mon_backtrace+0x187>
			} else if (cfa_rule->dw_regnum == 7) { /* 7: rsp */
  800420163e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201642:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004201646:	66 83 f8 07          	cmp    $0x7,%ax
  800420164a:	0f 85 01 02 00 00    	jne    8004201851 <mon_backtrace+0x375>
				cfa = rsp + cfa_rule->dw_offset;
  8004201650:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201654:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004201658:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420165c:	48 01 d0             	add    %rdx,%rax
  800420165f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
			} else {
				goto unknown_cfa;
			}

			cprintf("  args:%d ", info.rip_fn_narg);
  8004201663:	8b 85 f8 fa ff ff    	mov    -0x508(%rbp),%eax
  8004201669:	89 c6                	mov    %eax,%esi
  800420166b:	48 bf d3 f0 21 04 80 	movabs $0x800421f0d3,%rdi
  8004201672:	00 00 00 
  8004201675:	b8 00 00 00 00       	mov    $0x0,%eax
  800420167a:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004201681:	00 00 00 
  8004201684:	ff d2                	callq  *%rdx
			for (i = 0; i < info.rip_fn_narg ; i++)
  8004201686:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420168d:	e9 f2 00 00 00       	jmpq   8004201784 <mon_backtrace+0x2a8>
			{
				uint64_t val;
				assert(info.offset_fn_arg[i]);
  8004201692:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201695:	48 98                	cltq   
  8004201697:	48 83 c0 0a          	add    $0xa,%rax
  800420169b:	48 8b 84 c5 d8 fa ff 	mov    -0x528(%rbp,%rax,8),%rax
  80042016a2:	ff 
  80042016a3:	48 85 c0             	test   %rax,%rax
  80042016a6:	75 35                	jne    80042016dd <mon_backtrace+0x201>
  80042016a8:	48 b9 de f0 21 04 80 	movabs $0x800421f0de,%rcx
  80042016af:	00 00 00 
  80042016b2:	48 ba f4 f0 21 04 80 	movabs $0x800421f0f4,%rdx
  80042016b9:	00 00 00 
  80042016bc:	be 77 00 00 00       	mov    $0x77,%esi
  80042016c1:	48 bf 09 f1 21 04 80 	movabs $0x800421f109,%rdi
  80042016c8:	00 00 00 
  80042016cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042016d0:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042016d7:	00 00 00 
  80042016da:	41 ff d0             	callq  *%r8
				offset = cfa + info.offset_fn_arg[i];
  80042016dd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042016e0:	48 98                	cltq   
  80042016e2:	48 83 c0 0a          	add    $0xa,%rax
  80042016e6:	48 8b 94 c5 d8 fa ff 	mov    -0x528(%rbp,%rax,8),%rdx
  80042016ed:	ff 
  80042016ee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042016f2:	48 01 d0             	add    %rdx,%rax
  80042016f5:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
				switch(info.size_fn_arg[i]) {
  80042016f9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042016fc:	48 98                	cltq   
  80042016fe:	48 83 c0 08          	add    $0x8,%rax
  8004201702:	8b 84 85 dc fa ff ff 	mov    -0x524(%rbp,%rax,4),%eax
  8004201709:	83 f8 02             	cmp    $0x2,%eax
  800420170c:	74 31                	je     800420173f <mon_backtrace+0x263>
  800420170e:	83 f8 02             	cmp    $0x2,%eax
  8004201711:	7f 07                	jg     800420171a <mon_backtrace+0x23e>
  8004201713:	83 f8 01             	cmp    $0x1,%eax
  8004201716:	74 37                	je     800420174f <mon_backtrace+0x273>
  8004201718:	eb 44                	jmp    800420175e <mon_backtrace+0x282>
  800420171a:	83 f8 04             	cmp    $0x4,%eax
  800420171d:	74 12                	je     8004201731 <mon_backtrace+0x255>
  800420171f:	83 f8 08             	cmp    $0x8,%eax
  8004201722:	75 3a                	jne    800420175e <mon_backtrace+0x282>
					case 8:
						val = *(uint64_t *) offset;
  8004201724:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004201728:	48 8b 00             	mov    (%rax),%rax
  800420172b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
						break;
  800420172f:	eb 2d                	jmp    800420175e <mon_backtrace+0x282>
					case 4:
						val = *(uint32_t *) offset;
  8004201731:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004201735:	8b 00                	mov    (%rax),%eax
  8004201737:	89 c0                	mov    %eax,%eax
  8004201739:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
						break;
  800420173d:	eb 1f                	jmp    800420175e <mon_backtrace+0x282>
					case 2:
						val = *(uint16_t *) offset;
  800420173f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004201743:	0f b7 00             	movzwl (%rax),%eax
  8004201746:	0f b7 c0             	movzwl %ax,%eax
  8004201749:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
						break;
  800420174d:	eb 0f                	jmp    800420175e <mon_backtrace+0x282>
					case 1:
						val = *(uint8_t *) offset;
  800420174f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004201753:	0f b6 00             	movzbl (%rax),%eax
  8004201756:	0f b6 c0             	movzbl %al,%eax
  8004201759:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
						break;
  800420175d:	90                   	nop
				}
				cprintf(" %016x", val);
  800420175e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201762:	48 89 c6             	mov    %rax,%rsi
  8004201765:	48 bf 18 f1 21 04 80 	movabs $0x800421f118,%rdi
  800420176c:	00 00 00 
  800420176f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201774:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420177b:	00 00 00 
  800420177e:	ff d2                	callq  *%rdx
			} else {
				goto unknown_cfa;
			}

			cprintf("  args:%d ", info.rip_fn_narg);
			for (i = 0; i < info.rip_fn_narg ; i++)
  8004201780:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004201784:	8b 85 f8 fa ff ff    	mov    -0x508(%rbp),%eax
  800420178a:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800420178d:	0f 8f ff fe ff ff    	jg     8004201692 <mon_backtrace+0x1b6>
						break;
				}
				cprintf(" %016x", val);
			}

			switch(info.reg_table.rules[6].dw_regnum) { /* 6: rbp */
  8004201793:	0f b7 85 ea fb ff ff 	movzwl -0x416(%rbp),%eax
  800420179a:	0f b7 c0             	movzwl %ax,%eax
  800420179d:	3d 0b 04 00 00       	cmp    $0x40b,%eax
  80042017a2:	74 48                	je     80042017ec <mon_backtrace+0x310>
  80042017a4:	3d 9c 05 00 00       	cmp    $0x59c,%eax
  80042017a9:	75 17                	jne    80042017c2 <mon_backtrace+0x2e6>
				case DW_FRAME_SAME_VAL:
					break;
				case DW_FRAME_CFA_COL3:
					rbp = (const uint64_t *)*(uint64_t *)(cfa + info.reg_table.rules[6].dw_offset);
  80042017ab:	48 8b 95 f0 fb ff ff 	mov    -0x410(%rbp),%rdx
  80042017b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042017b6:	48 01 d0             	add    %rdx,%rax
  80042017b9:	48 8b 00             	mov    (%rax),%rax
  80042017bc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
					break;
  80042017c0:	eb 2b                	jmp    80042017ed <mon_backtrace+0x311>
				default:
					panic("unknown reg rule");
  80042017c2:	48 ba 1f f1 21 04 80 	movabs $0x800421f11f,%rdx
  80042017c9:	00 00 00 
  80042017cc:	be 91 00 00 00       	mov    $0x91,%esi
  80042017d1:	48 bf 09 f1 21 04 80 	movabs $0x800421f109,%rdi
  80042017d8:	00 00 00 
  80042017db:	b8 00 00 00 00       	mov    $0x0,%eax
  80042017e0:	48 b9 f3 04 20 04 80 	movabs $0x80042004f3,%rcx
  80042017e7:	00 00 00 
  80042017ea:	ff d1                	callq  *%rcx
				cprintf(" %016x", val);
			}

			switch(info.reg_table.rules[6].dw_regnum) { /* 6: rbp */
				case DW_FRAME_SAME_VAL:
					break;
  80042017ec:	90                   	nop
				default:
					panic("unknown reg rule");
					break;
			}

			switch(info.reg_table.rules[16].dw_regnum) { /* 16: rip */
  80042017ed:	0f b7 85 8a fc ff ff 	movzwl -0x376(%rbp),%eax
  80042017f4:	0f b7 c0             	movzwl %ax,%eax
  80042017f7:	3d 0b 04 00 00       	cmp    $0x40b,%eax
  80042017fc:	74 48                	je     8004201846 <mon_backtrace+0x36a>
  80042017fe:	3d 9c 05 00 00       	cmp    $0x59c,%eax
  8004201803:	75 17                	jne    800420181c <mon_backtrace+0x340>
				case DW_FRAME_SAME_VAL:
					break;
				case DW_FRAME_CFA_COL3:
					rip = *(uint64_t *)(cfa + info.reg_table.rules[16].dw_offset);
  8004201805:	48 8b 95 90 fc ff ff 	mov    -0x370(%rbp),%rdx
  800420180c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201810:	48 01 d0             	add    %rdx,%rax
  8004201813:	48 8b 00             	mov    (%rax),%rax
  8004201816:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					break;
  800420181a:	eb 2b                	jmp    8004201847 <mon_backtrace+0x36b>
				default:
					panic("unknown reg rule");
  800420181c:	48 ba 1f f1 21 04 80 	movabs $0x800421f11f,%rdx
  8004201823:	00 00 00 
  8004201826:	be 9c 00 00 00       	mov    $0x9c,%esi
  800420182b:	48 bf 09 f1 21 04 80 	movabs $0x800421f109,%rdi
  8004201832:	00 00 00 
  8004201835:	b8 00 00 00 00       	mov    $0x0,%eax
  800420183a:	48 b9 f3 04 20 04 80 	movabs $0x80042004f3,%rcx
  8004201841:	00 00 00 
  8004201844:	ff d1                	callq  *%rcx
					break;
			}

			switch(info.reg_table.rules[16].dw_regnum) { /* 16: rip */
				case DW_FRAME_SAME_VAL:
					break;
  8004201846:	90                   	nop
				default:
					panic("unknown reg rule");
					break;
			}

			rsp = cfa;
  8004201847:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420184b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420184f:	eb 18                	jmp    8004201869 <mon_backtrace+0x38d>
			if (cfa_rule->dw_regnum == 6) { /* 6: rbp */
				cfa = (uint64_t)rbp + cfa_rule->dw_offset;
			} else if (cfa_rule->dw_regnum == 7) { /* 7: rsp */
				cfa = rsp + cfa_rule->dw_offset;
			} else {
				goto unknown_cfa;
  8004201851:	90                   	nop

			rsp = cfa;
		} else {
unknown_cfa:
			// move to next lower stack frame
			rip = rbp[1];
  8004201852:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201856:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420185a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			rbp = (const uint64_t*) rbp[0];
  800420185e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201862:	48 8b 00             	mov    (%rax),%rax
  8004201865:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		}
		cprintf("\n");
  8004201869:	48 bf 30 f1 21 04 80 	movabs $0x800421f130,%rdi
  8004201870:	00 00 00 
  8004201873:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201878:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420187f:	00 00 00 
  8004201882:	ff d2                	callq  *%rdx
	}

	read_rip(rip);

	cprintf("Stack backtrace:\n");
	while (rbp) {
  8004201884:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004201889:	0f 85 e0 fc ff ff    	jne    800420156f <mon_backtrace+0x93>
			rbp = (const uint64_t*) rbp[0];
		}
		cprintf("\n");
	}

	return 0;
  800420188f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201894:	c9                   	leaveq 
  8004201895:	c3                   	retq   

0000008004201896 <mon_exit>:


int
mon_exit(int argc, char** argv, struct Trapframe* tf)
{
  8004201896:	55                   	push   %rbp
  8004201897:	48 89 e5             	mov    %rsp,%rbp
  800420189a:	48 83 ec 18          	sub    $0x18,%rsp
  800420189e:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80042018a1:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80042018a5:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
#ifdef VMM_GUEST
	asm("hlt");
  80042018a9:	f4                   	hlt    
#endif
	return -1;
  80042018aa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80042018af:	c9                   	leaveq 
  80042018b0:	c3                   	retq   

00000080042018b1 <runcmd>:
#define WHITESPACE "\t\r\n "
#define MAXARGS 16

static int
runcmd(char *buf, struct Trapframe *tf)
{
  80042018b1:	55                   	push   %rbp
  80042018b2:	48 89 e5             	mov    %rsp,%rbp
  80042018b5:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  80042018bc:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  80042018c3:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
	int argc;
	char *argv[MAXARGS];
	int i;

	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
  80042018ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	argv[argc] = 0;
  80042018d1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042018d4:	48 98                	cltq   
  80042018d6:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  80042018dd:	ff 00 00 00 00 
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  80042018e2:	eb 15                	jmp    80042018f9 <runcmd+0x48>
			*buf++ = 0;
  80042018e4:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042018eb:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042018ef:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
  80042018f6:	c6 00 00             	movb   $0x0,(%rax)
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  80042018f9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201900:	0f b6 00             	movzbl (%rax),%eax
  8004201903:	84 c0                	test   %al,%al
  8004201905:	74 2a                	je     8004201931 <runcmd+0x80>
  8004201907:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420190e:	0f b6 00             	movzbl (%rax),%eax
  8004201911:	0f be c0             	movsbl %al,%eax
  8004201914:	89 c6                	mov    %eax,%esi
  8004201916:	48 bf 32 f1 21 04 80 	movabs $0x800421f132,%rdi
  800420191d:	00 00 00 
  8004201920:	48 b8 17 0f 21 04 80 	movabs $0x8004210f17,%rax
  8004201927:	00 00 00 
  800420192a:	ff d0                	callq  *%rax
  800420192c:	48 85 c0             	test   %rax,%rax
  800420192f:	75 b3                	jne    80042018e4 <runcmd+0x33>
			*buf++ = 0;
		if (*buf == 0)
  8004201931:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201938:	0f b6 00             	movzbl (%rax),%eax
  800420193b:	84 c0                	test   %al,%al
  800420193d:	0f 84 95 00 00 00    	je     80042019d8 <runcmd+0x127>
			break;

		// save and scan past next arg
		if (argc == MAXARGS-1) {
  8004201943:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  8004201947:	75 2a                	jne    8004201973 <runcmd+0xc2>
			cprintf("Too many arguments (max %d)\n", MAXARGS);
  8004201949:	be 10 00 00 00       	mov    $0x10,%esi
  800420194e:	48 bf 37 f1 21 04 80 	movabs $0x800421f137,%rdi
  8004201955:	00 00 00 
  8004201958:	b8 00 00 00 00       	mov    $0x0,%eax
  800420195d:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004201964:	00 00 00 
  8004201967:	ff d2                	callq  *%rdx
			return 0;
  8004201969:	b8 00 00 00 00       	mov    $0x0,%eax
  800420196e:	e9 4b 01 00 00       	jmpq   8004201abe <runcmd+0x20d>
		}
		argv[argc++] = buf;
  8004201973:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201976:	8d 50 01             	lea    0x1(%rax),%edx
  8004201979:	89 55 fc             	mov    %edx,-0x4(%rbp)
  800420197c:	48 98                	cltq   
  800420197e:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004201985:	48 89 94 c5 70 ff ff 	mov    %rdx,-0x90(%rbp,%rax,8)
  800420198c:	ff 
		while (*buf && !strchr(WHITESPACE, *buf))
  800420198d:	eb 08                	jmp    8004201997 <runcmd+0xe6>
			buf++;
  800420198f:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  8004201996:	01 
		if (argc == MAXARGS-1) {
			cprintf("Too many arguments (max %d)\n", MAXARGS);
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201997:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420199e:	0f b6 00             	movzbl (%rax),%eax
  80042019a1:	84 c0                	test   %al,%al
  80042019a3:	0f 84 39 ff ff ff    	je     80042018e2 <runcmd+0x31>
  80042019a9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042019b0:	0f b6 00             	movzbl (%rax),%eax
  80042019b3:	0f be c0             	movsbl %al,%eax
  80042019b6:	89 c6                	mov    %eax,%esi
  80042019b8:	48 bf 32 f1 21 04 80 	movabs $0x800421f132,%rdi
  80042019bf:	00 00 00 
  80042019c2:	48 b8 17 0f 21 04 80 	movabs $0x8004210f17,%rax
  80042019c9:	00 00 00 
  80042019cc:	ff d0                	callq  *%rax
  80042019ce:	48 85 c0             	test   %rax,%rax
  80042019d1:	74 bc                	je     800420198f <runcmd+0xde>
			buf++;
	}
  80042019d3:	e9 0a ff ff ff       	jmpq   80042018e2 <runcmd+0x31>
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
			*buf++ = 0;
		if (*buf == 0)
			break;
  80042019d8:	90                   	nop
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
	argv[argc] = 0;
  80042019d9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042019dc:	48 98                	cltq   
  80042019de:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  80042019e5:	ff 00 00 00 00 

	// Lookup and invoke the command
	if (argc == 0)
  80042019ea:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042019ee:	75 0a                	jne    80042019fa <runcmd+0x149>
		return 0;
  80042019f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042019f5:	e9 c4 00 00 00       	jmpq   8004201abe <runcmd+0x20d>
	for (i = 0; i < NCOMMANDS; i++) {
  80042019fa:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8004201a01:	e9 82 00 00 00       	jmpq   8004201a88 <runcmd+0x1d7>
		if (strcmp(argv[0], commands[i].name) == 0)
  8004201a06:	48 b9 80 35 23 04 80 	movabs $0x8004233580,%rcx
  8004201a0d:	00 00 00 
  8004201a10:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201a13:	48 63 d0             	movslq %eax,%rdx
  8004201a16:	48 89 d0             	mov    %rdx,%rax
  8004201a19:	48 01 c0             	add    %rax,%rax
  8004201a1c:	48 01 d0             	add    %rdx,%rax
  8004201a1f:	48 c1 e0 03          	shl    $0x3,%rax
  8004201a23:	48 01 c8             	add    %rcx,%rax
  8004201a26:	48 8b 10             	mov    (%rax),%rdx
  8004201a29:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201a30:	48 89 d6             	mov    %rdx,%rsi
  8004201a33:	48 89 c7             	mov    %rax,%rdi
  8004201a36:	48 b8 53 0e 21 04 80 	movabs $0x8004210e53,%rax
  8004201a3d:	00 00 00 
  8004201a40:	ff d0                	callq  *%rax
  8004201a42:	85 c0                	test   %eax,%eax
  8004201a44:	75 3e                	jne    8004201a84 <runcmd+0x1d3>
			return commands[i].func(argc, argv, tf);
  8004201a46:	48 b9 80 35 23 04 80 	movabs $0x8004233580,%rcx
  8004201a4d:	00 00 00 
  8004201a50:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201a53:	48 63 d0             	movslq %eax,%rdx
  8004201a56:	48 89 d0             	mov    %rdx,%rax
  8004201a59:	48 01 c0             	add    %rax,%rax
  8004201a5c:	48 01 d0             	add    %rdx,%rax
  8004201a5f:	48 c1 e0 03          	shl    $0x3,%rax
  8004201a63:	48 01 c8             	add    %rcx,%rax
  8004201a66:	48 83 c0 10          	add    $0x10,%rax
  8004201a6a:	48 8b 00             	mov    (%rax),%rax
  8004201a6d:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004201a74:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
  8004201a7b:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004201a7e:	89 cf                	mov    %ecx,%edi
  8004201a80:	ff d0                	callq  *%rax
  8004201a82:	eb 3a                	jmp    8004201abe <runcmd+0x20d>
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
	for (i = 0; i < NCOMMANDS; i++) {
  8004201a84:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004201a88:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201a8b:	83 f8 03             	cmp    $0x3,%eax
  8004201a8e:	0f 86 72 ff ff ff    	jbe    8004201a06 <runcmd+0x155>
		if (strcmp(argv[0], commands[i].name) == 0)
			return commands[i].func(argc, argv, tf);
	}
	cprintf("Unknown command '%s'\n", argv[0]);
  8004201a94:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201a9b:	48 89 c6             	mov    %rax,%rsi
  8004201a9e:	48 bf 54 f1 21 04 80 	movabs $0x800421f154,%rdi
  8004201aa5:	00 00 00 
  8004201aa8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201aad:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004201ab4:	00 00 00 
  8004201ab7:	ff d2                	callq  *%rdx
	return 0;
  8004201ab9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201abe:	c9                   	leaveq 
  8004201abf:	c3                   	retq   

0000008004201ac0 <monitor>:

void
monitor(struct Trapframe *tf)
{
  8004201ac0:	55                   	push   %rbp
  8004201ac1:	48 89 e5             	mov    %rsp,%rbp
  8004201ac4:	48 83 ec 20          	sub    $0x20,%rsp
  8004201ac8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char *buf;

	cprintf("Welcome to the JOS kernel monitor!\n");
  8004201acc:	48 bf 70 f1 21 04 80 	movabs $0x800421f170,%rdi
  8004201ad3:	00 00 00 
  8004201ad6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201adb:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004201ae2:	00 00 00 
  8004201ae5:	ff d2                	callq  *%rdx
	cprintf("Type 'help' for a list of commands.\n");
  8004201ae7:	48 bf 98 f1 21 04 80 	movabs $0x800421f198,%rdi
  8004201aee:	00 00 00 
  8004201af1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201af6:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004201afd:	00 00 00 
  8004201b00:	ff d2                	callq  *%rdx


	if (tf != NULL)
  8004201b02:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201b07:	74 13                	je     8004201b1c <monitor+0x5c>
		print_trapframe(tf);
  8004201b09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201b0d:	48 89 c7             	mov    %rax,%rdi
  8004201b10:	48 b8 15 ca 20 04 80 	movabs $0x800420ca15,%rax
  8004201b17:	00 00 00 
  8004201b1a:	ff d0                	callq  *%rax


	while (1) {
		buf = readline("K> ");
  8004201b1c:	48 bf bd f1 21 04 80 	movabs $0x800421f1bd,%rdi
  8004201b23:	00 00 00 
  8004201b26:	48 b8 2c 0b 21 04 80 	movabs $0x8004210b2c,%rax
  8004201b2d:	00 00 00 
  8004201b30:	ff d0                	callq  *%rax
  8004201b32:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (buf != NULL)
  8004201b36:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004201b3b:	74 df                	je     8004201b1c <monitor+0x5c>
			if (runcmd(buf, tf) < 0)
  8004201b3d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201b41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201b45:	48 89 d6             	mov    %rdx,%rsi
  8004201b48:	48 89 c7             	mov    %rax,%rdi
  8004201b4b:	48 b8 b1 18 20 04 80 	movabs $0x80042018b1,%rax
  8004201b52:	00 00 00 
  8004201b55:	ff d0                	callq  *%rax
  8004201b57:	85 c0                	test   %eax,%eax
  8004201b59:	78 02                	js     8004201b5d <monitor+0x9d>
				break;
	}
  8004201b5b:	eb bf                	jmp    8004201b1c <monitor+0x5c>

	while (1) {
		buf = readline("K> ");
		if (buf != NULL)
			if (runcmd(buf, tf) < 0)
				break;
  8004201b5d:	90                   	nop
	}
}
  8004201b5e:	90                   	nop
  8004201b5f:	c9                   	leaveq 
  8004201b60:	c3                   	retq   

0000008004201b61 <page2ppn>:
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);


static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004201b61:	55                   	push   %rbp
  8004201b62:	48 89 e5             	mov    %rsp,%rbp
  8004201b65:	48 83 ec 08          	sub    $0x8,%rsp
  8004201b69:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004201b6d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201b71:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  8004201b78:	00 00 00 
  8004201b7b:	48 8b 00             	mov    (%rax),%rax
  8004201b7e:	48 29 c2             	sub    %rax,%rdx
  8004201b81:	48 89 d0             	mov    %rdx,%rax
  8004201b84:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004201b88:	c9                   	leaveq 
  8004201b89:	c3                   	retq   

0000008004201b8a <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004201b8a:	55                   	push   %rbp
  8004201b8b:	48 89 e5             	mov    %rsp,%rbp
  8004201b8e:	48 83 ec 08          	sub    $0x8,%rsp
  8004201b92:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004201b96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201b9a:	48 89 c7             	mov    %rax,%rdi
  8004201b9d:	48 b8 61 1b 20 04 80 	movabs $0x8004201b61,%rax
  8004201ba4:	00 00 00 
  8004201ba7:	ff d0                	callq  *%rax
  8004201ba9:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004201bad:	c9                   	leaveq 
  8004201bae:	c3                   	retq   

0000008004201baf <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004201baf:	55                   	push   %rbp
  8004201bb0:	48 89 e5             	mov    %rsp,%rbp
  8004201bb3:	48 83 ec 10          	sub    $0x10,%rsp
  8004201bb7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004201bbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201bbf:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201bc3:	48 89 c2             	mov    %rax,%rdx
  8004201bc6:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004201bcd:	00 00 00 
  8004201bd0:	48 8b 00             	mov    (%rax),%rax
  8004201bd3:	48 39 c2             	cmp    %rax,%rdx
  8004201bd6:	72 2a                	jb     8004201c02 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004201bd8:	48 ba c8 f1 21 04 80 	movabs $0x800421f1c8,%rdx
  8004201bdf:	00 00 00 
  8004201be2:	be 5a 00 00 00       	mov    $0x5a,%esi
  8004201be7:	48 bf e7 f1 21 04 80 	movabs $0x800421f1e7,%rdi
  8004201bee:	00 00 00 
  8004201bf1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201bf6:	48 b9 f3 04 20 04 80 	movabs $0x80042004f3,%rcx
  8004201bfd:	00 00 00 
  8004201c00:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004201c02:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  8004201c09:	00 00 00 
  8004201c0c:	48 8b 00             	mov    (%rax),%rax
  8004201c0f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201c13:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004201c17:	48 c1 e2 04          	shl    $0x4,%rdx
  8004201c1b:	48 01 d0             	add    %rdx,%rax
}
  8004201c1e:	c9                   	leaveq 
  8004201c1f:	c3                   	retq   

0000008004201c20 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004201c20:	55                   	push   %rbp
  8004201c21:	48 89 e5             	mov    %rsp,%rbp
  8004201c24:	48 83 ec 20          	sub    $0x20,%rsp
  8004201c28:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004201c2c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201c30:	48 89 c7             	mov    %rax,%rdi
  8004201c33:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  8004201c3a:	00 00 00 
  8004201c3d:	ff d0                	callq  *%rax
  8004201c3f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004201c43:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c47:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201c4b:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004201c4e:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004201c51:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004201c58:	00 00 00 
  8004201c5b:	48 8b 00             	mov    (%rax),%rax
  8004201c5e:	48 39 c2             	cmp    %rax,%rdx
  8004201c61:	72 32                	jb     8004201c95 <page2kva+0x75>
  8004201c63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c67:	48 89 c1             	mov    %rax,%rcx
  8004201c6a:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  8004201c71:	00 00 00 
  8004201c74:	be 61 00 00 00       	mov    $0x61,%esi
  8004201c79:	48 bf e7 f1 21 04 80 	movabs $0x800421f1e7,%rdi
  8004201c80:	00 00 00 
  8004201c83:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c88:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004201c8f:	00 00 00 
  8004201c92:	41 ff d0             	callq  *%r8
  8004201c95:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004201c9c:	00 00 00 
  8004201c9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201ca3:	48 01 d0             	add    %rdx,%rax
}
  8004201ca6:	c9                   	leaveq 
  8004201ca7:	c3                   	retq   

0000008004201ca8 <restrictive_type>:
   uint32_t length_low;
   uint32_t length_high;
   uint32_t type;
 } memory_map_t;

static __inline uint32_t restrictive_type(uint32_t t1, uint32_t t2) {
  8004201ca8:	55                   	push   %rbp
  8004201ca9:	48 89 e5             	mov    %rsp,%rbp
  8004201cac:	48 83 ec 08          	sub    $0x8,%rsp
  8004201cb0:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004201cb3:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if(t1==MB_TYPE_BAD || t2==MB_TYPE_BAD)
  8004201cb6:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  8004201cba:	74 06                	je     8004201cc2 <restrictive_type+0x1a>
  8004201cbc:	83 7d f8 05          	cmpl   $0x5,-0x8(%rbp)
  8004201cc0:	75 07                	jne    8004201cc9 <restrictive_type+0x21>
    return MB_TYPE_BAD;
  8004201cc2:	b8 05 00 00 00       	mov    $0x5,%eax
  8004201cc7:	eb 3e                	jmp    8004201d07 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_NVS || t2==MB_TYPE_ACPI_NVS)
  8004201cc9:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004201ccd:	74 06                	je     8004201cd5 <restrictive_type+0x2d>
  8004201ccf:	83 7d f8 04          	cmpl   $0x4,-0x8(%rbp)
  8004201cd3:	75 07                	jne    8004201cdc <restrictive_type+0x34>
    return MB_TYPE_ACPI_NVS;
  8004201cd5:	b8 04 00 00 00       	mov    $0x4,%eax
  8004201cda:	eb 2b                	jmp    8004201d07 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_RESERVED || t2==MB_TYPE_RESERVED)
  8004201cdc:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  8004201ce0:	74 06                	je     8004201ce8 <restrictive_type+0x40>
  8004201ce2:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  8004201ce6:	75 07                	jne    8004201cef <restrictive_type+0x47>
    return MB_TYPE_RESERVED;
  8004201ce8:	b8 02 00 00 00       	mov    $0x2,%eax
  8004201ced:	eb 18                	jmp    8004201d07 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_RECLM || t2==MB_TYPE_ACPI_RECLM)
  8004201cef:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004201cf3:	74 06                	je     8004201cfb <restrictive_type+0x53>
  8004201cf5:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
  8004201cf9:	75 07                	jne    8004201d02 <restrictive_type+0x5a>
    return MB_TYPE_ACPI_RECLM;
  8004201cfb:	b8 03 00 00 00       	mov    $0x3,%eax
  8004201d00:	eb 05                	jmp    8004201d07 <restrictive_type+0x5f>

  return MB_TYPE_USABLE;
  8004201d02:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004201d07:	c9                   	leaveq 
  8004201d08:	c3                   	retq   

0000008004201d09 <nvram_read>:
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int
nvram_read(int r)
{
  8004201d09:	55                   	push   %rbp
  8004201d0a:	48 89 e5             	mov    %rsp,%rbp
  8004201d0d:	53                   	push   %rbx
  8004201d0e:	48 83 ec 18          	sub    $0x18,%rsp
  8004201d12:	89 7d ec             	mov    %edi,-0x14(%rbp)
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
  8004201d15:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201d18:	89 c7                	mov    %eax,%edi
  8004201d1a:	48 b8 87 99 20 04 80 	movabs $0x8004209987,%rax
  8004201d21:	00 00 00 
  8004201d24:	ff d0                	callq  *%rax
  8004201d26:	89 c3                	mov    %eax,%ebx
  8004201d28:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201d2b:	83 c0 01             	add    $0x1,%eax
  8004201d2e:	89 c7                	mov    %eax,%edi
  8004201d30:	48 b8 87 99 20 04 80 	movabs $0x8004209987,%rax
  8004201d37:	00 00 00 
  8004201d3a:	ff d0                	callq  *%rax
  8004201d3c:	c1 e0 08             	shl    $0x8,%eax
  8004201d3f:	09 d8                	or     %ebx,%eax
}
  8004201d41:	48 83 c4 18          	add    $0x18,%rsp
  8004201d45:	5b                   	pop    %rbx
  8004201d46:	5d                   	pop    %rbp
  8004201d47:	c3                   	retq   

0000008004201d48 <multiboot_read>:

static void
multiboot_read(multiboot_info_t* mbinfo, size_t* basemem, size_t* extmem) {
  8004201d48:	55                   	push   %rbp
  8004201d49:	48 89 e5             	mov    %rsp,%rbp
  8004201d4c:	53                   	push   %rbx
  8004201d4d:	48 81 ec b8 00 00 00 	sub    $0xb8,%rsp
  8004201d54:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
  8004201d5b:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  8004201d62:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  8004201d69:	48 89 e0             	mov    %rsp,%rax
  8004201d6c:	48 89 c3             	mov    %rax,%rbx
	int i;

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
  8004201d6f:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201d76:	8b 40 30             	mov    0x30(%rax),%eax
  8004201d79:	89 c0                	mov    %eax,%eax
  8004201d7b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];
  8004201d7f:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201d86:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201d89:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201d8e:	f7 e2                	mul    %edx
  8004201d90:	89 d0                	mov    %edx,%eax
  8004201d92:	c1 e8 04             	shr    $0x4,%eax
  8004201d95:	89 c0                	mov    %eax,%eax
  8004201d97:	48 89 c2             	mov    %rax,%rdx
  8004201d9a:	48 83 ea 01          	sub    $0x1,%rdx
  8004201d9e:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004201da2:	49 89 c2             	mov    %rax,%r10
  8004201da5:	41 bb 00 00 00 00    	mov    $0x0,%r11d
  8004201dab:	49 89 c0             	mov    %rax,%r8
  8004201dae:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004201db4:	48 c1 e0 03          	shl    $0x3,%rax
  8004201db8:	48 8d 50 07          	lea    0x7(%rax),%rdx
  8004201dbc:	b8 10 00 00 00       	mov    $0x10,%eax
  8004201dc1:	48 83 e8 01          	sub    $0x1,%rax
  8004201dc5:	48 01 d0             	add    %rdx,%rax
  8004201dc8:	be 10 00 00 00       	mov    $0x10,%esi
  8004201dcd:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201dd2:	48 f7 f6             	div    %rsi
  8004201dd5:	48 6b c0 10          	imul   $0x10,%rax,%rax
  8004201dd9:	48 29 c4             	sub    %rax,%rsp
  8004201ddc:	48 89 e0             	mov    %rsp,%rax
  8004201ddf:	48 83 c0 07          	add    $0x7,%rax
  8004201de3:	48 c1 e8 03          	shr    $0x3,%rax
  8004201de7:	48 c1 e0 03          	shl    $0x3,%rax
  8004201deb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	cprintf("\ne820 MEMORY MAP\n");
  8004201def:	48 bf 1b f2 21 04 80 	movabs $0x800421f21b,%rdi
  8004201df6:	00 00 00 
  8004201df9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201dfe:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004201e05:	00 00 00 
  8004201e08:	ff d2                	callq  *%rdx
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201e0a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201e11:	e9 6c 01 00 00       	jmpq   8004201f82 <multiboot_read+0x23a>
		memory_map_t* mmap = &mmap_base[i];
  8004201e16:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201e19:	48 63 d0             	movslq %eax,%rdx
  8004201e1c:	48 89 d0             	mov    %rdx,%rax
  8004201e1f:	48 01 c0             	add    %rax,%rax
  8004201e22:	48 01 d0             	add    %rdx,%rax
  8004201e25:	48 c1 e0 03          	shl    $0x3,%rax
  8004201e29:	48 89 c2             	mov    %rax,%rdx
  8004201e2c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201e30:	48 01 d0             	add    %rdx,%rax
  8004201e33:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
  8004201e37:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201e3b:	8b 40 08             	mov    0x8(%rax),%eax
  8004201e3e:	89 c0                	mov    %eax,%eax
  8004201e40:	48 c1 e0 20          	shl    $0x20,%rax
  8004201e44:	48 89 c2             	mov    %rax,%rdx
  8004201e47:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201e4b:	8b 40 04             	mov    0x4(%rax),%eax
  8004201e4e:	89 c0                	mov    %eax,%eax
  8004201e50:	48 01 d0             	add    %rdx,%rax
  8004201e53:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201e57:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201e5b:	8b 40 10             	mov    0x10(%rax),%eax
  8004201e5e:	89 c0                	mov    %eax,%eax
  8004201e60:	48 c1 e0 20          	shl    $0x20,%rax
  8004201e64:	48 89 c2             	mov    %rax,%rdx
  8004201e67:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201e6b:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201e6e:	89 c0                	mov    %eax,%eax
  8004201e70:	48 01 d0             	add    %rdx,%rax
  8004201e73:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        
		cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size, 
  8004201e77:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201e7b:	8b 70 14             	mov    0x14(%rax),%esi
  8004201e7e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201e82:	8b 00                	mov    (%rax),%eax
  8004201e84:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004201e88:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004201e8c:	41 89 f0             	mov    %esi,%r8d
  8004201e8f:	89 c6                	mov    %eax,%esi
  8004201e91:	48 bf 30 f2 21 04 80 	movabs $0x800421f230,%rdi
  8004201e98:	00 00 00 
  8004201e9b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201ea0:	49 b9 09 9d 20 04 80 	movabs $0x8004209d09,%r9
  8004201ea7:	00 00 00 
  8004201eaa:	41 ff d1             	callq  *%r9
			addr, len, mmap->type);

		if(mmap->type > 5 || mmap->type < 1)
  8004201ead:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201eb1:	8b 40 14             	mov    0x14(%rax),%eax
  8004201eb4:	83 f8 05             	cmp    $0x5,%eax
  8004201eb7:	77 0b                	ja     8004201ec4 <multiboot_read+0x17c>
  8004201eb9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ebd:	8b 40 14             	mov    0x14(%rax),%eax
  8004201ec0:	85 c0                	test   %eax,%eax
  8004201ec2:	75 0b                	jne    8004201ecf <multiboot_read+0x187>
			mmap->type = MB_TYPE_RESERVED;
  8004201ec4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ec8:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)
       
		//Insert into the sorted list
		int j = 0;
  8004201ecf:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
		for(;j<i;j++) {
  8004201ed6:	e9 85 00 00 00       	jmpq   8004201f60 <multiboot_read+0x218>
			memory_map_t* this = mmap_list[j];
  8004201edb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201edf:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201ee2:	48 63 d2             	movslq %edx,%rdx
  8004201ee5:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201ee9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201eed:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201ef1:	8b 40 08             	mov    0x8(%rax),%eax
  8004201ef4:	89 c0                	mov    %eax,%eax
  8004201ef6:	48 c1 e0 20          	shl    $0x20,%rax
  8004201efa:	48 89 c2             	mov    %rax,%rdx
  8004201efd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201f01:	8b 40 04             	mov    0x4(%rax),%eax
  8004201f04:	89 c0                	mov    %eax,%eax
  8004201f06:	48 01 d0             	add    %rdx,%rax
  8004201f09:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			if(this_addr > addr) {
  8004201f0d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201f11:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004201f15:	76 45                	jbe    8004201f5c <multiboot_read+0x214>
				int last = i+1;
  8004201f17:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201f1a:	83 c0 01             	add    $0x1,%eax
  8004201f1d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				while(last != j) {
  8004201f20:	eb 30                	jmp    8004201f52 <multiboot_read+0x20a>
					*(mmap_list + last) = *(mmap_list + last - 1);
  8004201f22:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201f26:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004201f29:	48 63 d2             	movslq %edx,%rdx
  8004201f2c:	48 c1 e2 03          	shl    $0x3,%rdx
  8004201f30:	48 01 c2             	add    %rax,%rdx
  8004201f33:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201f37:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004201f3a:	48 63 c9             	movslq %ecx,%rcx
  8004201f3d:	48 c1 e1 03          	shl    $0x3,%rcx
  8004201f41:	48 83 e9 08          	sub    $0x8,%rcx
  8004201f45:	48 01 c8             	add    %rcx,%rax
  8004201f48:	48 8b 00             	mov    (%rax),%rax
  8004201f4b:	48 89 02             	mov    %rax,(%rdx)
					last--;
  8004201f4e:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
		for(;j<i;j++) {
			memory_map_t* this = mmap_list[j];
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
			if(this_addr > addr) {
				int last = i+1;
				while(last != j) {
  8004201f52:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004201f55:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004201f58:	75 c8                	jne    8004201f22 <multiboot_read+0x1da>
					*(mmap_list + last) = *(mmap_list + last - 1);
					last--;
				}
				break; 
  8004201f5a:	eb 10                	jmp    8004201f6c <multiboot_read+0x224>
		if(mmap->type > 5 || mmap->type < 1)
			mmap->type = MB_TYPE_RESERVED;
       
		//Insert into the sorted list
		int j = 0;
		for(;j<i;j++) {
  8004201f5c:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  8004201f60:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004201f63:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004201f66:	0f 8c 6f ff ff ff    	jl     8004201edb <multiboot_read+0x193>
					last--;
				}
				break; 
			}
		}
		mmap_list[j] = mmap;  
  8004201f6c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201f70:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201f73:	48 63 d2             	movslq %edx,%rdx
  8004201f76:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004201f7a:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];

	cprintf("\ne820 MEMORY MAP\n");
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201f7e:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201f82:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201f85:	48 63 c8             	movslq %eax,%rcx
  8004201f88:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201f8f:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201f92:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201f97:	f7 e2                	mul    %edx
  8004201f99:	89 d0                	mov    %edx,%eax
  8004201f9b:	c1 e8 04             	shr    $0x4,%eax
  8004201f9e:	89 c0                	mov    %eax,%eax
  8004201fa0:	48 39 c1             	cmp    %rax,%rcx
  8004201fa3:	0f 82 6d fe ff ff    	jb     8004201e16 <multiboot_read+0xce>
				break; 
			}
		}
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
  8004201fa9:	48 bf 67 f2 21 04 80 	movabs $0x800421f267,%rdi
  8004201fb0:	00 00 00 
  8004201fb3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201fb8:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004201fbf:	00 00 00 
  8004201fc2:	ff d2                	callq  *%rdx
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201fc4:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  8004201fcb:	e9 93 01 00 00       	jmpq   8004202163 <multiboot_read+0x41b>
		memory_map_t* prev = mmap_list[i-1];
  8004201fd0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201fd3:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004201fd6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201fda:	48 63 d2             	movslq %edx,%rdx
  8004201fdd:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201fe1:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		memory_map_t* this = mmap_list[i];
  8004201fe5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201fe9:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004201fec:	48 63 d2             	movslq %edx,%rdx
  8004201fef:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201ff3:	48 89 45 90          	mov    %rax,-0x70(%rbp)

		uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201ff7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201ffb:	8b 40 08             	mov    0x8(%rax),%eax
  8004201ffe:	89 c0                	mov    %eax,%eax
  8004202000:	48 c1 e0 20          	shl    $0x20,%rax
  8004202004:	48 89 c2             	mov    %rax,%rdx
  8004202007:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420200b:	8b 40 04             	mov    0x4(%rax),%eax
  800420200e:	89 c0                	mov    %eax,%eax
  8004202010:	48 01 d0             	add    %rdx,%rax
  8004202013:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		uint64_t prev_addr = APPEND_HILO(prev->base_addr_high, prev->base_addr_low);
  8004202017:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420201b:	8b 40 08             	mov    0x8(%rax),%eax
  800420201e:	89 c0                	mov    %eax,%eax
  8004202020:	48 c1 e0 20          	shl    $0x20,%rax
  8004202024:	48 89 c2             	mov    %rax,%rdx
  8004202027:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420202b:	8b 40 04             	mov    0x4(%rax),%eax
  800420202e:	89 c0                	mov    %eax,%eax
  8004202030:	48 01 d0             	add    %rdx,%rax
  8004202033:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		uint64_t prev_length = APPEND_HILO(prev->length_high, prev->length_low);
  8004202037:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420203b:	8b 40 10             	mov    0x10(%rax),%eax
  800420203e:	89 c0                	mov    %eax,%eax
  8004202040:	48 c1 e0 20          	shl    $0x20,%rax
  8004202044:	48 89 c2             	mov    %rax,%rdx
  8004202047:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420204b:	8b 40 0c             	mov    0xc(%rax),%eax
  800420204e:	89 c0                	mov    %eax,%eax
  8004202050:	48 01 d0             	add    %rdx,%rax
  8004202053:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		uint64_t this_length = APPEND_HILO(this->length_high, this->length_low);
  800420205a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420205e:	8b 40 10             	mov    0x10(%rax),%eax
  8004202061:	89 c0                	mov    %eax,%eax
  8004202063:	48 c1 e0 20          	shl    $0x20,%rax
  8004202067:	48 89 c2             	mov    %rax,%rdx
  800420206a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420206e:	8b 40 0c             	mov    0xc(%rax),%eax
  8004202071:	89 c0                	mov    %eax,%eax
  8004202073:	48 01 d0             	add    %rdx,%rax
  8004202076:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)

		// Merge adjacent regions with same type
		if(prev_addr + prev_length == this_addr && prev->type == this->type) {
  800420207d:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004202081:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004202088:	48 01 d0             	add    %rdx,%rax
  800420208b:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  800420208f:	75 7c                	jne    800420210d <multiboot_read+0x3c5>
  8004202091:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202095:	8b 50 14             	mov    0x14(%rax),%edx
  8004202098:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420209c:	8b 40 14             	mov    0x14(%rax),%eax
  800420209f:	39 c2                	cmp    %eax,%edx
  80042020a1:	75 6a                	jne    800420210d <multiboot_read+0x3c5>
			this->length_low = (uint32_t)prev_length + this_length;
  80042020a3:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042020aa:	89 c2                	mov    %eax,%edx
  80042020ac:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042020b3:	01 c2                	add    %eax,%edx
  80042020b5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042020b9:	89 50 0c             	mov    %edx,0xc(%rax)
			this->length_high = (uint32_t)((prev_length + this_length)>>32);
  80042020bc:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  80042020c3:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042020ca:	48 01 d0             	add    %rdx,%rax
  80042020cd:	48 c1 e8 20          	shr    $0x20,%rax
  80042020d1:	89 c2                	mov    %eax,%edx
  80042020d3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042020d7:	89 50 10             	mov    %edx,0x10(%rax)
			this->base_addr_low = prev->base_addr_low;
  80042020da:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020de:	8b 50 04             	mov    0x4(%rax),%edx
  80042020e1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042020e5:	89 50 04             	mov    %edx,0x4(%rax)
			this->base_addr_high = prev->base_addr_high;
  80042020e8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020ec:	8b 50 08             	mov    0x8(%rax),%edx
  80042020ef:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042020f3:	89 50 08             	mov    %edx,0x8(%rax)
			mmap_list[i-1] = NULL;
  80042020f6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042020f9:	8d 50 ff             	lea    -0x1(%rax),%edx
  80042020fc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202100:	48 63 d2             	movslq %edx,%rdx
  8004202103:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  800420210a:	00 
  800420210b:	eb 52                	jmp    800420215f <multiboot_read+0x417>
		} else if(prev_addr + prev_length > this_addr) {
  800420210d:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004202111:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004202118:	48 01 d0             	add    %rdx,%rax
  800420211b:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  800420211f:	76 3e                	jbe    800420215f <multiboot_read+0x417>
			//Overlapping regions
			uint32_t type = restrictive_type(prev->type, this->type);
  8004202121:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202125:	8b 50 14             	mov    0x14(%rax),%edx
  8004202128:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420212c:	8b 40 14             	mov    0x14(%rax),%eax
  800420212f:	89 d6                	mov    %edx,%esi
  8004202131:	89 c7                	mov    %eax,%edi
  8004202133:	48 b8 a8 1c 20 04 80 	movabs $0x8004201ca8,%rax
  800420213a:	00 00 00 
  800420213d:	ff d0                	callq  *%rax
  800420213f:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
			prev->type = type;
  8004202145:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202149:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  800420214f:	89 50 14             	mov    %edx,0x14(%rax)
			this->type = type;
  8004202152:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202156:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  800420215c:	89 50 14             	mov    %edx,0x14(%rax)
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  800420215f:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004202163:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202166:	48 63 c8             	movslq %eax,%rcx
  8004202169:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004202170:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004202173:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202178:	f7 e2                	mul    %edx
  800420217a:	89 d0                	mov    %edx,%eax
  800420217c:	c1 e8 04             	shr    $0x4,%eax
  800420217f:	89 c0                	mov    %eax,%eax
  8004202181:	48 39 c1             	cmp    %rax,%rcx
  8004202184:	0f 82 46 fe ff ff    	jb     8004201fd0 <multiboot_read+0x288>
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  800420218a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004202191:	e9 dc 00 00 00       	jmpq   8004202272 <multiboot_read+0x52a>
		memory_map_t* mmap = mmap_list[i];
  8004202196:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420219a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420219d:	48 63 d2             	movslq %edx,%rdx
  80042021a0:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80042021a4:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
		if(mmap) {
  80042021ab:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  80042021b2:	00 
  80042021b3:	0f 84 b5 00 00 00    	je     800420226e <multiboot_read+0x526>
			if(mmap->type == MB_TYPE_USABLE || mmap->type == MB_TYPE_ACPI_RECLM) {
  80042021b9:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042021c0:	8b 40 14             	mov    0x14(%rax),%eax
  80042021c3:	83 f8 01             	cmp    $0x1,%eax
  80042021c6:	74 13                	je     80042021db <multiboot_read+0x493>
  80042021c8:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042021cf:	8b 40 14             	mov    0x14(%rax),%eax
  80042021d2:	83 f8 03             	cmp    $0x3,%eax
  80042021d5:	0f 85 93 00 00 00    	jne    800420226e <multiboot_read+0x526>
				if(mmap->base_addr_low < 0x100000 && mmap->base_addr_high == 0)
  80042021db:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042021e2:	8b 40 04             	mov    0x4(%rax),%eax
  80042021e5:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  80042021ea:	77 49                	ja     8004202235 <multiboot_read+0x4ed>
  80042021ec:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042021f3:	8b 40 08             	mov    0x8(%rax),%eax
  80042021f6:	85 c0                	test   %eax,%eax
  80042021f8:	75 3b                	jne    8004202235 <multiboot_read+0x4ed>
					*basemem += APPEND_HILO(mmap->length_high, mmap->length_low);
  80042021fa:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004202201:	48 8b 10             	mov    (%rax),%rdx
  8004202204:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420220b:	8b 40 10             	mov    0x10(%rax),%eax
  800420220e:	89 c0                	mov    %eax,%eax
  8004202210:	48 c1 e0 20          	shl    $0x20,%rax
  8004202214:	48 89 c1             	mov    %rax,%rcx
  8004202217:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420221e:	8b 40 0c             	mov    0xc(%rax),%eax
  8004202221:	89 c0                	mov    %eax,%eax
  8004202223:	48 01 c8             	add    %rcx,%rax
  8004202226:	48 01 c2             	add    %rax,%rdx
  8004202229:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004202230:	48 89 10             	mov    %rdx,(%rax)
  8004202233:	eb 39                	jmp    800420226e <multiboot_read+0x526>
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004202235:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420223c:	48 8b 10             	mov    (%rax),%rdx
  800420223f:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202246:	8b 40 10             	mov    0x10(%rax),%eax
  8004202249:	89 c0                	mov    %eax,%eax
  800420224b:	48 c1 e0 20          	shl    $0x20,%rax
  800420224f:	48 89 c1             	mov    %rax,%rcx
  8004202252:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202259:	8b 40 0c             	mov    0xc(%rax),%eax
  800420225c:	89 c0                	mov    %eax,%eax
  800420225e:	48 01 c8             	add    %rcx,%rax
  8004202261:	48 01 c2             	add    %rax,%rdx
  8004202264:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420226b:	48 89 10             	mov    %rdx,(%rax)
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  800420226e:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004202272:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202275:	48 63 c8             	movslq %eax,%rcx
  8004202278:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420227f:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004202282:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202287:	f7 e2                	mul    %edx
  8004202289:	89 d0                	mov    %edx,%eax
  800420228b:	c1 e8 04             	shr    $0x4,%eax
  800420228e:	89 c0                	mov    %eax,%eax
  8004202290:	48 39 c1             	cmp    %rax,%rcx
  8004202293:	0f 82 fd fe ff ff    	jb     8004202196 <multiboot_read+0x44e>
  8004202299:	48 89 dc             	mov    %rbx,%rsp
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
			}
		}
	}
}
  800420229c:	90                   	nop
  800420229d:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  80042022a1:	c9                   	leaveq 
  80042022a2:	c3                   	retq   

00000080042022a3 <i386_detect_memory>:

static void
i386_detect_memory(void)
{
  80042022a3:	55                   	push   %rbp
  80042022a4:	48 89 e5             	mov    %rsp,%rbp
  80042022a7:	48 83 ec 50          	sub    $0x50,%rsp
	size_t npages_extmem;
	size_t basemem = 0;
  80042022ab:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  80042022b2:	00 
	size_t extmem = 0;
  80042022b3:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  80042022ba:	00 

	// Check if the bootloader passed us a multiboot structure
	extern char multiboot_info[];
	uintptr_t* mbp = (uintptr_t*)multiboot_info;
  80042022bb:	48 b8 00 70 10 00 00 	movabs $0x107000,%rax
  80042022c2:	00 00 00 
  80042022c5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	multiboot_info_t * mbinfo = (multiboot_info_t*)*mbp;
  80042022c9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042022cd:	48 8b 00             	mov    (%rax),%rax
  80042022d0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if(mbinfo && (mbinfo->flags & MB_FLAG_MMAP)) {
  80042022d4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042022d9:	74 2d                	je     8004202308 <i386_detect_memory+0x65>
  80042022db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042022df:	8b 00                	mov    (%rax),%eax
  80042022e1:	83 e0 40             	and    $0x40,%eax
  80042022e4:	85 c0                	test   %eax,%eax
  80042022e6:	74 20                	je     8004202308 <i386_detect_memory+0x65>
		multiboot_read(mbinfo, &basemem, &extmem);
  80042022e8:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  80042022ec:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  80042022f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042022f4:	48 89 ce             	mov    %rcx,%rsi
  80042022f7:	48 89 c7             	mov    %rax,%rdi
  80042022fa:	48 b8 48 1d 20 04 80 	movabs $0x8004201d48,%rax
  8004202301:	00 00 00 
  8004202304:	ff d0                	callq  *%rax
  8004202306:	eb 34                	jmp    800420233c <i386_detect_memory+0x99>
	} else {
		basemem = (nvram_read(NVRAM_BASELO) * 1024);
  8004202308:	bf 15 00 00 00       	mov    $0x15,%edi
  800420230d:	48 b8 09 1d 20 04 80 	movabs $0x8004201d09,%rax
  8004202314:	00 00 00 
  8004202317:	ff d0                	callq  *%rax
  8004202319:	c1 e0 0a             	shl    $0xa,%eax
  800420231c:	48 98                	cltq   
  800420231e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		extmem = (nvram_read(NVRAM_EXTLO) * 1024);
  8004202322:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202327:	48 b8 09 1d 20 04 80 	movabs $0x8004201d09,%rax
  800420232e:	00 00 00 
  8004202331:	ff d0                	callq  *%rax
  8004202333:	c1 e0 0a             	shl    $0xa,%eax
  8004202336:	48 98                	cltq   
  8004202338:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	}

	assert(basemem);
  800420233c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202340:	48 85 c0             	test   %rax,%rax
  8004202343:	75 35                	jne    800420237a <i386_detect_memory+0xd7>
  8004202345:	48 b9 69 f2 21 04 80 	movabs $0x800421f269,%rcx
  800420234c:	00 00 00 
  800420234f:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004202356:	00 00 00 
  8004202359:	be 89 00 00 00       	mov    $0x89,%esi
  800420235e:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004202365:	00 00 00 
  8004202368:	b8 00 00 00 00       	mov    $0x0,%eax
  800420236d:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004202374:	00 00 00 
  8004202377:	41 ff d0             	callq  *%r8

	npages_basemem = basemem / PGSIZE;
  800420237a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420237e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202382:	48 89 c2             	mov    %rax,%rdx
  8004202385:	48 b8 30 d2 4d 04 80 	movabs $0x80044dd230,%rax
  800420238c:	00 00 00 
  800420238f:	48 89 10             	mov    %rdx,(%rax)
	npages_extmem = extmem / PGSIZE;
  8004202392:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202396:	48 c1 e8 0c          	shr    $0xc,%rax
  800420239a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	
	if(nvram_read(NVRAM_EXTLO) == 0xffff) {
  800420239e:	bf 17 00 00 00       	mov    $0x17,%edi
  80042023a3:	48 b8 09 1d 20 04 80 	movabs $0x8004201d09,%rax
  80042023aa:	00 00 00 
  80042023ad:	ff d0                	callq  *%rax
  80042023af:	3d ff ff 00 00       	cmp    $0xffff,%eax
  80042023b4:	75 2c                	jne    80042023e2 <i386_detect_memory+0x13f>
		// EXTMEM > 16M in blocks of 64k
		size_t pextmem = nvram_read(NVRAM_EXTGT16LO) * (64 * 1024);
  80042023b6:	bf 34 00 00 00       	mov    $0x34,%edi
  80042023bb:	48 b8 09 1d 20 04 80 	movabs $0x8004201d09,%rax
  80042023c2:	00 00 00 
  80042023c5:	ff d0                	callq  *%rax
  80042023c7:	c1 e0 10             	shl    $0x10,%eax
  80042023ca:	48 98                	cltq   
  80042023cc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		npages_extmem = ((16 * 1024 * 1024) + pextmem - (1 * 1024 * 1024)) / PGSIZE;
  80042023d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042023d4:	48 05 00 00 f0 00    	add    $0xf00000,%rax
  80042023da:	48 c1 e8 0c          	shr    $0xc,%rax
  80042023de:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}
	
	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  80042023e2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042023e7:	74 1a                	je     8004202403 <i386_detect_memory+0x160>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  80042023e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042023ed:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  80042023f4:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  80042023fb:	00 00 00 
  80042023fe:	48 89 10             	mov    %rdx,(%rax)
  8004202401:	eb 1a                	jmp    800420241d <i386_detect_memory+0x17a>
	else
		npages = npages_basemem;
  8004202403:	48 b8 30 d2 4d 04 80 	movabs $0x80044dd230,%rax
  800420240a:	00 00 00 
  800420240d:	48 8b 10             	mov    (%rax),%rdx
  8004202410:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004202417:	00 00 00 
  800420241a:	48 89 10             	mov    %rdx,(%rax)

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  800420241d:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004202424:	00 00 00 
  8004202427:	48 8b 30             	mov    (%rax),%rsi
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
  800420242a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420242e:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202432:	48 c1 e8 0a          	shr    $0xa,%rax
  8004202436:	48 89 c1             	mov    %rax,%rcx
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
  8004202439:	48 b8 30 d2 4d 04 80 	movabs $0x80044dd230,%rax
  8004202440:	00 00 00 
  8004202443:	48 8b 00             	mov    (%rax),%rax
  8004202446:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  800420244a:	48 c1 e8 0a          	shr    $0xa,%rax
  800420244e:	48 89 c2             	mov    %rax,%rdx
		npages * PGSIZE / (1024 * 1024),
  8004202451:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004202458:	00 00 00 
  800420245b:	48 8b 00             	mov    (%rax),%rax
  800420245e:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202462:	48 c1 e8 14          	shr    $0x14,%rax
  8004202466:	49 89 f0             	mov    %rsi,%r8
  8004202469:	48 89 c6             	mov    %rax,%rsi
  800420246c:	48 bf 98 f2 21 04 80 	movabs $0x800421f298,%rdi
  8004202473:	00 00 00 
  8004202476:	b8 00 00 00 00       	mov    $0x0,%eax
  800420247b:	49 b9 09 9d 20 04 80 	movabs $0x8004209d09,%r9
  8004202482:	00 00 00 
  8004202485:	41 ff d1             	callq  *%r9
	//JOS 64 pages are limited by the size of both the UPAGES
	//  virtual address space, and the range from KERNBASE to UVPT.
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
  8004202488:	48 c7 45 d8 00 00 32 	movq   $0x320000,-0x28(%rbp)
  800420248f:	00 
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
  8004202490:	48 c7 45 d0 00 c0 ff 	movq   $0x7ffc000,-0x30(%rbp)
  8004202497:	07 
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
  8004202498:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420249c:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  80042024a0:	48 c1 e8 14          	shr    $0x14,%rax
  80042024a4:	48 89 c1             	mov    %rax,%rcx
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
  80042024a7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042024ab:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  80042024af:	48 c1 e8 14          	shr    $0x14,%rax
  80042024b3:	48 89 c6             	mov    %rax,%rsi
  80042024b6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042024ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042024be:	49 89 c8             	mov    %rcx,%r8
  80042024c1:	48 89 d1             	mov    %rdx,%rcx
  80042024c4:	48 89 f2             	mov    %rsi,%rdx
  80042024c7:	48 89 c6             	mov    %rax,%rsi
  80042024ca:	48 bf e8 f2 21 04 80 	movabs $0x800421f2e8,%rdi
  80042024d1:	00 00 00 
  80042024d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042024d9:	49 b9 09 9d 20 04 80 	movabs $0x8004209d09,%r9
  80042024e0:	00 00 00 
  80042024e3:	41 ff d1             	callq  *%r9
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
	uint64_t max_npages = upages_max < kern_mem_max ? upages_max : kern_mem_max;
  80042024e6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042024ea:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  80042024ee:	48 0f 46 45 d0       	cmovbe -0x30(%rbp),%rax
  80042024f3:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if(npages > max_npages) {
  80042024f7:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  80042024fe:	00 00 00 
  8004202501:	48 8b 00             	mov    (%rax),%rax
  8004202504:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004202508:	76 3a                	jbe    8004202544 <i386_detect_memory+0x2a1>
		npages = max_npages - 1024;
  800420250a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420250e:	48 8d 90 00 fc ff ff 	lea    -0x400(%rax),%rdx
  8004202515:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  800420251c:	00 00 00 
  800420251f:	48 89 10             	mov    %rdx,(%rax)
		cprintf("Using only %uK of the available memory.\n", max_npages);
  8004202522:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202526:	48 89 c6             	mov    %rax,%rsi
  8004202529:	48 bf 50 f3 21 04 80 	movabs $0x800421f350,%rdi
  8004202530:	00 00 00 
  8004202533:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202538:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420253f:	00 00 00 
  8004202542:	ff d2                	callq  *%rdx
	}
}
  8004202544:	90                   	nop
  8004202545:	c9                   	leaveq 
  8004202546:	c3                   	retq   

0000008004202547 <boot_alloc>:
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
  8004202547:	55                   	push   %rbp
  8004202548:	48 89 e5             	mov    %rsp,%rbp
  800420254b:	48 83 ec 40          	sub    $0x40,%rsp
  800420254f:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
  8004202552:	48 b8 48 d2 4d 04 80 	movabs $0x80044dd248,%rax
  8004202559:	00 00 00 
  800420255c:	48 8b 00             	mov    (%rax),%rax
  800420255f:	48 85 c0             	test   %rax,%rax
  8004202562:	75 45                	jne    80042025a9 <boot_alloc+0x62>

#ifdef VMM_GUEST
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
  8004202564:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  800420256b:	00 
  800420256c:	48 b8 10 f0 71 04 80 	movabs $0x800471f010,%rax
  8004202573:	00 00 00 
  8004202576:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420257a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420257e:	48 01 d0             	add    %rdx,%rax
  8004202581:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202585:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202589:	ba 00 00 00 00       	mov    $0x0,%edx
  800420258e:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004202592:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202596:	48 29 d0             	sub    %rdx,%rax
  8004202599:	48 89 c2             	mov    %rax,%rdx
  800420259c:	48 b8 48 d2 4d 04 80 	movabs $0x80044dd248,%rax
  80042025a3:	00 00 00 
  80042025a6:	48 89 10             	mov    %rdx,(%rax)
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.


	if ((uintptr_t)nextfree + n < (uintptr_t)nextfree
  80042025a9:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042025ac:	48 b8 48 d2 4d 04 80 	movabs $0x80044dd248,%rax
  80042025b3:	00 00 00 
  80042025b6:	48 8b 00             	mov    (%rax),%rax
  80042025b9:	48 01 c2             	add    %rax,%rdx
  80042025bc:	48 b8 48 d2 4d 04 80 	movabs $0x80044dd248,%rax
  80042025c3:	00 00 00 
  80042025c6:	48 8b 00             	mov    (%rax),%rax
  80042025c9:	48 39 c2             	cmp    %rax,%rdx
  80042025cc:	72 2f                	jb     80042025fd <boot_alloc+0xb6>
            || nextfree + n > (char*) (npages * PGSIZE + KERNBASE))
  80042025ce:	48 b8 48 d2 4d 04 80 	movabs $0x80044dd248,%rax
  80042025d5:	00 00 00 
  80042025d8:	48 8b 10             	mov    (%rax),%rdx
  80042025db:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80042025de:	48 01 c2             	add    %rax,%rdx
  80042025e1:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  80042025e8:	00 00 00 
  80042025eb:	48 8b 00             	mov    (%rax),%rax
  80042025ee:	48 05 00 40 00 08    	add    $0x8004000,%rax
  80042025f4:	48 c1 e0 0c          	shl    $0xc,%rax
  80042025f8:	48 39 c2             	cmp    %rax,%rdx
  80042025fb:	76 2a                	jbe    8004202627 <boot_alloc+0xe0>
		panic("out of memory during x64_vm_init");
  80042025fd:	48 ba 80 f3 21 04 80 	movabs $0x800421f380,%rdx
  8004202604:	00 00 00 
  8004202607:	be ee 00 00 00       	mov    $0xee,%esi
  800420260c:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004202613:	00 00 00 
  8004202616:	b8 00 00 00 00       	mov    $0x0,%eax
  800420261b:	48 b9 f3 04 20 04 80 	movabs $0x80042004f3,%rcx
  8004202622:	00 00 00 
  8004202625:	ff d1                	callq  *%rcx
	result = nextfree;
  8004202627:	48 b8 48 d2 4d 04 80 	movabs $0x80044dd248,%rax
  800420262e:	00 00 00 
  8004202631:	48 8b 00             	mov    (%rax),%rax
  8004202634:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	nextfree = ROUNDUP(nextfree + n, PGSIZE);
  8004202638:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  800420263f:	00 
  8004202640:	48 b8 48 d2 4d 04 80 	movabs $0x80044dd248,%rax
  8004202647:	00 00 00 
  800420264a:	48 8b 10             	mov    (%rax),%rdx
  800420264d:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004202650:	48 01 d0             	add    %rdx,%rax
  8004202653:	48 89 c2             	mov    %rax,%rdx
  8004202656:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420265a:	48 01 d0             	add    %rdx,%rax
  800420265d:	48 83 e8 01          	sub    $0x1,%rax
  8004202661:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004202665:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202669:	ba 00 00 00 00       	mov    $0x0,%edx
  800420266e:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004202672:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202676:	48 29 d0             	sub    %rdx,%rax
  8004202679:	48 89 c2             	mov    %rax,%rdx
  800420267c:	48 b8 48 d2 4d 04 80 	movabs $0x80044dd248,%rax
  8004202683:	00 00 00 
  8004202686:	48 89 10             	mov    %rdx,(%rax)
	return result;
  8004202689:	48 8b 45 e8          	mov    -0x18(%rbp),%rax

}
  800420268d:	c9                   	leaveq 
  800420268e:	c3                   	retq   

000000800420268f <x64_vm_init>:
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
x64_vm_init(void)
{
  800420268f:	55                   	push   %rbp
  8004202690:	48 89 e5             	mov    %rsp,%rbp
  8004202693:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
	pml4e_t* pml4e;
	uint32_t cr0;
	uint64_t n;
	int r;
	struct Env *env;
	i386_detect_memory();
  8004202697:	48 b8 a3 22 20 04 80 	movabs $0x80042022a3,%rax
  800420269e:	00 00 00 
  80042026a1:	ff d0                	callq  *%rax
	//panic("i386_vm_init: This function is not finished\n");
	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	pml4e = boot_alloc(PGSIZE);
  80042026a3:	bf 00 10 00 00       	mov    $0x1000,%edi
  80042026a8:	48 b8 47 25 20 04 80 	movabs $0x8004202547,%rax
  80042026af:	00 00 00 
  80042026b2:	ff d0                	callq  *%rax
  80042026b4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(pml4e, 0, PGSIZE);
  80042026b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042026bc:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042026c1:	be 00 00 00 00       	mov    $0x0,%esi
  80042026c6:	48 89 c7             	mov    %rax,%rdi
  80042026c9:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  80042026d0:	00 00 00 
  80042026d3:	ff d0                	callq  *%rax
	boot_pml4e = pml4e;
  80042026d5:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  80042026dc:	00 00 00 
  80042026df:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042026e3:	48 89 10             	mov    %rdx,(%rax)
	boot_cr3 = PADDR(pml4e);
  80042026e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042026ea:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042026ee:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042026f5:	00 00 00 
  80042026f8:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  80042026fc:	77 32                	ja     8004202730 <x64_vm_init+0xa1>
  80042026fe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202702:	48 89 c1             	mov    %rax,%rcx
  8004202705:	48 ba a8 f3 21 04 80 	movabs $0x800421f3a8,%rdx
  800420270c:	00 00 00 
  800420270f:	be 0e 01 00 00       	mov    $0x10e,%esi
  8004202714:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  800420271b:	00 00 00 
  800420271e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202723:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420272a:	00 00 00 
  800420272d:	41 ff d0             	callq  *%r8
  8004202730:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202737:	ff ff ff 
  800420273a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420273e:	48 01 c2             	add    %rax,%rdx
  8004202741:	48 b8 e8 c5 6d 04 80 	movabs $0x80046dc5e8,%rax
  8004202748:	00 00 00 
  800420274b:	48 89 10             	mov    %rdx,(%rax)
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.
	// Your code goes here:

	n = npages * sizeof(struct PageInfo);
  800420274e:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004202755:	00 00 00 
  8004202758:	48 8b 00             	mov    (%rax),%rax
  800420275b:	48 c1 e0 04          	shl    $0x4,%rax
  800420275f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	pages = (struct PageInfo *) boot_alloc(n);
  8004202763:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202767:	89 c7                	mov    %eax,%edi
  8004202769:	48 b8 47 25 20 04 80 	movabs $0x8004202547,%rax
  8004202770:	00 00 00 
  8004202773:	ff d0                	callq  *%rax
  8004202775:	48 89 c2             	mov    %rax,%rdx
  8004202778:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  800420277f:	00 00 00 
  8004202782:	48 89 10             	mov    %rdx,(%rax)
	memset(pages, 0, n);
  8004202785:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  800420278c:	00 00 00 
  800420278f:	48 8b 00             	mov    (%rax),%rax
  8004202792:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202796:	be 00 00 00 00       	mov    $0x0,%esi
  800420279b:	48 89 c7             	mov    %rax,%rdi
  800420279e:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  80042027a5:	00 00 00 
  80042027a8:	ff d0                	callq  *%rax

	//////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.

	envs    = boot_alloc(sizeof(struct Env)*NENV);
  80042027aa:	bf 00 a0 05 00       	mov    $0x5a000,%edi
  80042027af:	48 b8 47 25 20 04 80 	movabs $0x8004202547,%rax
  80042027b6:	00 00 00 
  80042027b9:	ff d0                	callq  *%rax
  80042027bb:	48 89 c2             	mov    %rax,%rdx
  80042027be:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  80042027c5:	00 00 00 
  80042027c8:	48 89 10             	mov    %rdx,(%rax)
	memset(envs, 0, sizeof(struct Env)*NENV);
  80042027cb:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  80042027d2:	00 00 00 
  80042027d5:	48 8b 00             	mov    (%rax),%rax
  80042027d8:	ba 00 a0 05 00       	mov    $0x5a000,%edx
  80042027dd:	be 00 00 00 00       	mov    $0x0,%esi
  80042027e2:	48 89 c7             	mov    %rax,%rdi
  80042027e5:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  80042027ec:	00 00 00 
  80042027ef:	ff d0                	callq  *%rax
	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region or page_insert
	page_init();
  80042027f1:	48 b8 4b 2c 20 04 80 	movabs $0x8004202c4b,%rax
  80042027f8:	00 00 00 
  80042027fb:	ff d0                	callq  *%rax
	//    - the new image at UPAGES -- kernel R, us/er R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:

	n = npages*sizeof(struct PageInfo);
  80042027fd:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004202804:	00 00 00 
  8004202807:	48 8b 00             	mov    (%rax),%rax
  800420280a:	48 c1 e0 04          	shl    $0x4,%rax
  800420280e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	boot_map_region(boot_pml4e, UPAGES, n, PADDR(pages), PTE_U);
  8004202812:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  8004202819:	00 00 00 
  800420281c:	48 8b 00             	mov    (%rax),%rax
  800420281f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004202823:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420282a:	00 00 00 
  800420282d:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004202831:	77 32                	ja     8004202865 <x64_vm_init+0x1d6>
  8004202833:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202837:	48 89 c1             	mov    %rax,%rcx
  800420283a:	48 ba a8 f3 21 04 80 	movabs $0x800421f3a8,%rdx
  8004202841:	00 00 00 
  8004202844:	be 38 01 00 00       	mov    $0x138,%esi
  8004202849:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004202850:	00 00 00 
  8004202853:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202858:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420285f:	00 00 00 
  8004202862:	41 ff d0             	callq  *%r8
  8004202865:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420286c:	ff ff ff 
  800420286f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202873:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004202877:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  800420287e:	00 00 00 
  8004202881:	48 8b 00             	mov    (%rax),%rax
  8004202884:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202888:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  800420288e:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  8004202895:	00 00 00 
  8004202898:	48 89 c7             	mov    %rax,%rdi
  800420289b:	48 b8 99 37 20 04 80 	movabs $0x8004203799,%rax
  80042028a2:	00 00 00 
  80042028a5:	ff d0                	callq  *%rax
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.

	n   = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  80042028a7:	48 c7 45 d8 00 10 00 	movq   $0x1000,-0x28(%rbp)
  80042028ae:	00 
  80042028af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042028b3:	48 05 ff 9f 05 00    	add    $0x59fff,%rax
  80042028b9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042028bd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042028c1:	ba 00 00 00 00       	mov    $0x0,%edx
  80042028c6:	48 f7 75 d8          	divq   -0x28(%rbp)
  80042028ca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042028ce:	48 29 d0             	sub    %rdx,%rax
  80042028d1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	boot_map_region(boot_pml4e, UENVS, n, PADDR(envs), PTE_U|PTE_P);
  80042028d5:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  80042028dc:	00 00 00 
  80042028df:	48 8b 00             	mov    (%rax),%rax
  80042028e2:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042028e6:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042028ed:	00 00 00 
  80042028f0:	48 39 45 c8          	cmp    %rax,-0x38(%rbp)
  80042028f4:	77 32                	ja     8004202928 <x64_vm_init+0x299>
  80042028f6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042028fa:	48 89 c1             	mov    %rax,%rcx
  80042028fd:	48 ba a8 f3 21 04 80 	movabs $0x800421f3a8,%rdx
  8004202904:	00 00 00 
  8004202907:	be 45 01 00 00       	mov    $0x145,%esi
  800420290c:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004202913:	00 00 00 
  8004202916:	b8 00 00 00 00       	mov    $0x0,%eax
  800420291b:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004202922:	00 00 00 
  8004202925:	41 ff d0             	callq  *%r8
  8004202928:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420292f:	ff ff ff 
  8004202932:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202936:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  800420293a:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004202941:	00 00 00 
  8004202944:	48 8b 00             	mov    (%rax),%rax
  8004202947:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420294b:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  8004202951:	48 be 00 00 80 00 80 	movabs $0x8000800000,%rsi
  8004202958:	00 00 00 
  800420295b:	48 89 c7             	mov    %rax,%rdi
  800420295e:	48 b8 99 37 20 04 80 	movabs $0x8004203799,%rax
  8004202965:	00 00 00 
  8004202968:	ff d0                	callq  *%rax
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:

	boot_map_region(boot_pml4e, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W|PTE_P);
  800420296a:	48 b8 00 30 22 04 80 	movabs $0x8004223000,%rax
  8004202971:	00 00 00 
  8004202974:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004202978:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420297f:	00 00 00 
  8004202982:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  8004202986:	77 32                	ja     80042029ba <x64_vm_init+0x32b>
  8004202988:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420298c:	48 89 c1             	mov    %rax,%rcx
  800420298f:	48 ba a8 f3 21 04 80 	movabs $0x800421f3a8,%rdx
  8004202996:	00 00 00 
  8004202999:	be 55 01 00 00       	mov    $0x155,%esi
  800420299e:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042029a5:	00 00 00 
  80042029a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042029ad:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042029b4:	00 00 00 
  80042029b7:	41 ff d0             	callq  *%r8
  80042029ba:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042029c1:	ff ff ff 
  80042029c4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042029c8:	48 01 c2             	add    %rax,%rdx
  80042029cb:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  80042029d2:	00 00 00 
  80042029d5:	48 8b 00             	mov    (%rax),%rax
  80042029d8:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  80042029de:	48 89 d1             	mov    %rdx,%rcx
  80042029e1:	ba 00 00 01 00       	mov    $0x10000,%edx
  80042029e6:	48 be 00 00 ff 03 80 	movabs $0x8003ff0000,%rsi
  80042029ed:	00 00 00 
  80042029f0:	48 89 c7             	mov    %rax,%rdi
  80042029f3:	48 b8 99 37 20 04 80 	movabs $0x8004203799,%rax
  80042029fa:	00 00 00 
  80042029fd:	ff d0                	callq  *%rax
	// Ie.  the VA range [KERNBASE, npages*PGSIZE) should map to
	//      the PA range [0, npages*PGSIZE)
	// Permissions: kernel RW, user NONE
	// Your code goes here: 

	boot_map_region(boot_pml4e, KERNBASE, npages*PGSIZE, 0, PTE_W|PTE_P);
  80042029ff:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004202a06:	00 00 00 
  8004202a09:	48 8b 00             	mov    (%rax),%rax
  8004202a0c:	48 c1 e0 0c          	shl    $0xc,%rax
  8004202a10:	48 89 c2             	mov    %rax,%rdx
  8004202a13:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004202a1a:	00 00 00 
  8004202a1d:	48 8b 00             	mov    (%rax),%rax
  8004202a20:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202a26:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004202a2b:	48 be 00 00 00 04 80 	movabs $0x8004000000,%rsi
  8004202a32:	00 00 00 
  8004202a35:	48 89 c7             	mov    %rax,%rdi
  8004202a38:	48 b8 99 37 20 04 80 	movabs $0x8004203799,%rax
  8004202a3f:	00 00 00 
  8004202a42:	ff d0                	callq  *%rax

	// Check that the initial page directory has been set up correctly.

	// Initialize the SMP-related parts of the memory map
	mem_init_mp();
  8004202a44:	48 b8 5f 2b 20 04 80 	movabs $0x8004202b5f,%rax
  8004202a4b:	00 00 00 
  8004202a4e:	ff d0                	callq  *%rax



	//////////////////////////////////////////////////////////////////////
	// Permissions: kernel RW, user NONE
	pdpe_t *pdpe = KADDR(PTE_ADDR(pml4e[1]));
  8004202a50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202a54:	48 83 c0 08          	add    $0x8,%rax
  8004202a58:	48 8b 00             	mov    (%rax),%rax
  8004202a5b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202a61:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004202a65:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202a69:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202a6d:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  8004202a70:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004202a73:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004202a7a:	00 00 00 
  8004202a7d:	48 8b 00             	mov    (%rax),%rax
  8004202a80:	48 39 c2             	cmp    %rax,%rdx
  8004202a83:	72 32                	jb     8004202ab7 <x64_vm_init+0x428>
  8004202a85:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202a89:	48 89 c1             	mov    %rax,%rcx
  8004202a8c:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  8004202a93:	00 00 00 
  8004202a96:	be 6c 01 00 00       	mov    $0x16c,%esi
  8004202a9b:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004202aa2:	00 00 00 
  8004202aa5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202aaa:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004202ab1:	00 00 00 
  8004202ab4:	41 ff d0             	callq  *%r8
  8004202ab7:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202abe:	00 00 00 
  8004202ac1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202ac5:	48 01 d0             	add    %rdx,%rax
  8004202ac8:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	pde_t *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004202acc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202ad0:	48 8b 00             	mov    (%rax),%rax
  8004202ad3:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202ad9:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004202add:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202ae1:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202ae5:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004202ae8:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004202aeb:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004202af2:	00 00 00 
  8004202af5:	48 8b 00             	mov    (%rax),%rax
  8004202af8:	48 39 c2             	cmp    %rax,%rdx
  8004202afb:	72 32                	jb     8004202b2f <x64_vm_init+0x4a0>
  8004202afd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202b01:	48 89 c1             	mov    %rax,%rcx
  8004202b04:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  8004202b0b:	00 00 00 
  8004202b0e:	be 6d 01 00 00       	mov    $0x16d,%esi
  8004202b13:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004202b1a:	00 00 00 
  8004202b1d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202b22:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004202b29:	00 00 00 
  8004202b2c:	41 ff d0             	callq  *%r8
  8004202b2f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202b36:	00 00 00 
  8004202b39:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202b3d:	48 01 d0             	add    %rdx,%rax
  8004202b40:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	lcr3(boot_cr3);
  8004202b44:	48 b8 e8 c5 6d 04 80 	movabs $0x80046dc5e8,%rax
  8004202b4b:	00 00 00 
  8004202b4e:	48 8b 00             	mov    (%rax),%rax
  8004202b51:	48 89 45 88          	mov    %rax,-0x78(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004202b55:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004202b59:	0f 22 d8             	mov    %rax,%cr3
}
  8004202b5c:	90                   	nop
  8004202b5d:	c9                   	leaveq 
  8004202b5e:	c3                   	retq   

0000008004202b5f <mem_init_mp>:
// Modify mappings in boot_pml4e to support SMP
//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
//
static void
mem_init_mp(void)
{
  8004202b5f:	55                   	push   %rbp
  8004202b60:	48 89 e5             	mov    %rsp,%rbp
  8004202b63:	48 83 ec 20          	sub    $0x20,%rsp
	// LAB 4: Your code here:


	int i;
	uintptr_t kstacktop;
	for (i = 0; i < NCPU; i++) {
  8004202b67:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004202b6e:	e9 cb 00 00 00       	jmpq   8004202c3e <mem_init_mp+0xdf>
		kstacktop = KSTACKTOP - (KSTKSIZE + KSTKGAP) * i;
  8004202b73:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004202b76:	89 d0                	mov    %edx,%eax
  8004202b78:	01 c0                	add    %eax,%eax
  8004202b7a:	01 d0                	add    %edx,%eax
  8004202b7c:	c1 e0 0f             	shl    $0xf,%eax
  8004202b7f:	48 98                	cltq   
  8004202b81:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202b88:	00 00 00 
  8004202b8b:	48 29 c2             	sub    %rax,%rdx
  8004202b8e:	48 89 d0             	mov    %rdx,%rax
  8004202b91:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		boot_map_region(boot_pml4e, kstacktop - KSTKSIZE, KSTKSIZE,
				PADDR(percpu_kstacks[i]), PTE_P|PTE_W);
  8004202b95:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004202b98:	48 98                	cltq   
  8004202b9a:	48 c1 e0 10          	shl    $0x10,%rax
  8004202b9e:	48 89 c2             	mov    %rax,%rdx
  8004202ba1:	48 b8 00 f0 6d 04 80 	movabs $0x80046df000,%rax
  8004202ba8:	00 00 00 
  8004202bab:	48 01 d0             	add    %rdx,%rax
  8004202bae:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202bb2:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202bb9:	00 00 00 
  8004202bbc:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004202bc0:	77 32                	ja     8004202bf4 <mem_init_mp+0x95>
  8004202bc2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202bc6:	48 89 c1             	mov    %rax,%rcx
  8004202bc9:	48 ba a8 f3 21 04 80 	movabs $0x800421f3a8,%rdx
  8004202bd0:	00 00 00 
  8004202bd3:	be 90 01 00 00       	mov    $0x190,%esi
  8004202bd8:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004202bdf:	00 00 00 
  8004202be2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202be7:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004202bee:	00 00 00 
  8004202bf1:	41 ff d0             	callq  *%r8
  8004202bf4:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202bfb:	ff ff ff 
  8004202bfe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202c02:	48 01 c2             	add    %rax,%rdx

	int i;
	uintptr_t kstacktop;
	for (i = 0; i < NCPU; i++) {
		kstacktop = KSTACKTOP - (KSTKSIZE + KSTKGAP) * i;
		boot_map_region(boot_pml4e, kstacktop - KSTKSIZE, KSTKSIZE,
  8004202c05:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202c09:	48 8d b0 00 00 ff ff 	lea    -0x10000(%rax),%rsi
  8004202c10:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004202c17:	00 00 00 
  8004202c1a:	48 8b 00             	mov    (%rax),%rax
  8004202c1d:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202c23:	48 89 d1             	mov    %rdx,%rcx
  8004202c26:	ba 00 00 01 00       	mov    $0x10000,%edx
  8004202c2b:	48 89 c7             	mov    %rax,%rdi
  8004202c2e:	48 b8 99 37 20 04 80 	movabs $0x8004203799,%rax
  8004202c35:	00 00 00 
  8004202c38:	ff d0                	callq  *%rax
	// LAB 4: Your code here:


	int i;
	uintptr_t kstacktop;
	for (i = 0; i < NCPU; i++) {
  8004202c3a:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004202c3e:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004202c42:	0f 8e 2b ff ff ff    	jle    8004202b73 <mem_init_mp+0x14>
		kstacktop = KSTACKTOP - (KSTKSIZE + KSTKGAP) * i;
		boot_map_region(boot_pml4e, kstacktop - KSTKSIZE, KSTKSIZE,
				PADDR(percpu_kstacks[i]), PTE_P|PTE_W);
	}

}
  8004202c48:	90                   	nop
  8004202c49:	c9                   	leaveq 
  8004202c4a:	c3                   	retq   

0000008004202c4b <page_init>:
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
  8004202c4b:	55                   	push   %rbp
  8004202c4c:	48 89 e5             	mov    %rsp,%rbp
  8004202c4f:	48 83 ec 50          	sub    $0x50,%rsp
	// LAB 4:
	// Change your code to mark the physical page at MPENTRY_PADDR
	// as in use


	void *nextfree = boot_alloc(0);
  8004202c53:	bf 00 00 00 00       	mov    $0x0,%edi
  8004202c58:	48 b8 47 25 20 04 80 	movabs $0x8004202547,%rax
  8004202c5f:	00 00 00 
  8004202c62:	ff d0                	callq  *%rax
  8004202c64:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	size_t i;
	int inuse;
	struct PageInfo* last = NULL;
  8004202c68:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004202c6f:	00 
	for (i = 0; i < npages; i++) {
  8004202c70:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202c77:	00 
  8004202c78:	e9 65 02 00 00       	jmpq   8004202ee2 <page_init+0x297>
		// Off-limits until proven otherwise.
		inuse = 1;
  8004202c7d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)

		// The bottom basemem bytes are free except page 0.
		if (i != 0 && i < npages_basemem)
  8004202c84:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202c89:	74 1a                	je     8004202ca5 <page_init+0x5a>
  8004202c8b:	48 b8 30 d2 4d 04 80 	movabs $0x80044dd230,%rax
  8004202c92:	00 00 00 
  8004202c95:	48 8b 00             	mov    (%rax),%rax
  8004202c98:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004202c9c:	73 07                	jae    8004202ca5 <page_init+0x5a>
			inuse = 0;
  8004202c9e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

		// Mark physical page at MPENTRY_PADDR as in use
		if (i == MPENTRY_PADDR / PGSIZE)
  8004202ca5:	48 83 7d f8 07       	cmpq   $0x7,-0x8(%rbp)
  8004202caa:	75 07                	jne    8004202cb3 <page_init+0x68>
			inuse = 1;
  8004202cac:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)


		// The IO hole and the kernel are non empty but
		// The memory past the kernel is free.
		if (i >= PADDR(nextfree) / PGSIZE)
  8004202cb3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202cb7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004202cbb:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202cc2:	00 00 00 
  8004202cc5:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004202cc9:	77 32                	ja     8004202cfd <page_init+0xb2>
  8004202ccb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202ccf:	48 89 c1             	mov    %rax,%rcx
  8004202cd2:	48 ba a8 f3 21 04 80 	movabs $0x800421f3a8,%rdx
  8004202cd9:	00 00 00 
  8004202cdc:	be be 01 00 00       	mov    $0x1be,%esi
  8004202ce1:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004202ce8:	00 00 00 
  8004202ceb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202cf0:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004202cf7:	00 00 00 
  8004202cfa:	41 ff d0             	callq  *%r8
  8004202cfd:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202d04:	ff ff ff 
  8004202d07:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202d0b:	48 01 d0             	add    %rdx,%rax
  8004202d0e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202d12:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004202d16:	77 07                	ja     8004202d1f <page_init+0xd4>
			inuse = 0;
  8004202d18:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

		uint64_t va = KERNBASE + i*PGSIZE;
  8004202d1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202d23:	48 05 00 40 00 08    	add    $0x8004000,%rax
  8004202d29:	48 c1 e0 0c          	shl    $0xc,%rax
  8004202d2d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if (va>=BOOT_PAGE_TABLE_START && va<BOOT_PAGE_TABLE_END)
  8004202d31:	48 b8 00 20 10 00 00 	movabs $0x102000,%rax
  8004202d38:	00 00 00 
  8004202d3b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004202d3f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202d43:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202d47:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004202d4a:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004202d4d:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004202d54:	00 00 00 
  8004202d57:	48 8b 00             	mov    (%rax),%rax
  8004202d5a:	48 39 c2             	cmp    %rax,%rdx
  8004202d5d:	72 32                	jb     8004202d91 <page_init+0x146>
  8004202d5f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202d63:	48 89 c1             	mov    %rax,%rcx
  8004202d66:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  8004202d6d:	00 00 00 
  8004202d70:	be c2 01 00 00       	mov    $0x1c2,%esi
  8004202d75:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004202d7c:	00 00 00 
  8004202d7f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202d84:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004202d8b:	00 00 00 
  8004202d8e:	41 ff d0             	callq  *%r8
  8004202d91:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202d98:	00 00 00 
  8004202d9b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202d9f:	48 01 d0             	add    %rdx,%rax
  8004202da2:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004202da6:	0f 87 84 00 00 00    	ja     8004202e30 <page_init+0x1e5>
  8004202dac:	48 b8 00 20 10 00 00 	movabs $0x102000,%rax
  8004202db3:	00 00 00 
  8004202db6:	48 05 00 50 00 00    	add    $0x5000,%rax
  8004202dbc:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004202dc0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202dc4:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202dc8:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  8004202dcb:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004202dce:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004202dd5:	00 00 00 
  8004202dd8:	48 8b 00             	mov    (%rax),%rax
  8004202ddb:	48 39 c2             	cmp    %rax,%rdx
  8004202dde:	72 32                	jb     8004202e12 <page_init+0x1c7>
  8004202de0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202de4:	48 89 c1             	mov    %rax,%rcx
  8004202de7:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  8004202dee:	00 00 00 
  8004202df1:	be c2 01 00 00       	mov    $0x1c2,%esi
  8004202df6:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004202dfd:	00 00 00 
  8004202e00:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202e05:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004202e0c:	00 00 00 
  8004202e0f:	41 ff d0             	callq  *%r8
  8004202e12:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202e19:	00 00 00 
  8004202e1c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202e20:	48 01 d0             	add    %rdx,%rax
  8004202e23:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004202e27:	76 07                	jbe    8004202e30 <page_init+0x1e5>
			inuse = 1;
  8004202e29:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)

		pages[i].pp_ref = inuse;
  8004202e30:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  8004202e37:	00 00 00 
  8004202e3a:	48 8b 00             	mov    (%rax),%rax
  8004202e3d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202e41:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202e45:	48 01 d0             	add    %rdx,%rax
  8004202e48:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004202e4b:	66 89 50 08          	mov    %dx,0x8(%rax)
		pages[i].pp_link = NULL;
  8004202e4f:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  8004202e56:	00 00 00 
  8004202e59:	48 8b 00             	mov    (%rax),%rax
  8004202e5c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202e60:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202e64:	48 01 d0             	add    %rdx,%rax
  8004202e67:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (!inuse) {
  8004202e6e:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004202e72:	75 69                	jne    8004202edd <page_init+0x292>
			if (last)
  8004202e74:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202e79:	74 21                	je     8004202e9c <page_init+0x251>
				last->pp_link = &pages[i];
  8004202e7b:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  8004202e82:	00 00 00 
  8004202e85:	48 8b 00             	mov    (%rax),%rax
  8004202e88:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202e8c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202e90:	48 01 c2             	add    %rax,%rdx
  8004202e93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202e97:	48 89 10             	mov    %rdx,(%rax)
  8004202e9a:	eb 25                	jmp    8004202ec1 <page_init+0x276>
			else
				page_free_list = &pages[i];
  8004202e9c:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  8004202ea3:	00 00 00 
  8004202ea6:	48 8b 00             	mov    (%rax),%rax
  8004202ea9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202ead:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202eb1:	48 01 c2             	add    %rax,%rdx
  8004202eb4:	48 b8 38 d2 4d 04 80 	movabs $0x80044dd238,%rax
  8004202ebb:	00 00 00 
  8004202ebe:	48 89 10             	mov    %rdx,(%rax)
			last = &pages[i];
  8004202ec1:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  8004202ec8:	00 00 00 
  8004202ecb:	48 8b 00             	mov    (%rax),%rax
  8004202ece:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202ed2:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202ed6:	48 01 d0             	add    %rdx,%rax
  8004202ed9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	void *nextfree = boot_alloc(0);
	size_t i;
	int inuse;
	struct PageInfo* last = NULL;
	for (i = 0; i < npages; i++) {
  8004202edd:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004202ee2:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004202ee9:	00 00 00 
  8004202eec:	48 8b 00             	mov    (%rax),%rax
  8004202eef:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004202ef3:	0f 82 84 fd ff ff    	jb     8004202c7d <page_init+0x32>
		}

	}


}
  8004202ef9:	90                   	nop
  8004202efa:	c9                   	leaveq 
  8004202efb:	c3                   	retq   

0000008004202efc <page_alloc>:
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
  8004202efc:	55                   	push   %rbp
  8004202efd:	48 89 e5             	mov    %rsp,%rbp
  8004202f00:	48 83 ec 20          	sub    $0x20,%rsp
  8004202f04:	89 7d ec             	mov    %edi,-0x14(%rbp)
	// Fill this function in

	struct PageInfo *pp = page_free_list;
  8004202f07:	48 b8 38 d2 4d 04 80 	movabs $0x80044dd238,%rax
  8004202f0e:	00 00 00 
  8004202f11:	48 8b 00             	mov    (%rax),%rax
  8004202f14:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (pp) {
  8004202f18:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202f1d:	74 5e                	je     8004202f7d <page_alloc+0x81>
		//cprintf("alloc new page: struct page %x va %x pa %x \n", pp, page2kva(pp), page2pa(pp));
		page_free_list = page_free_list->pp_link;
  8004202f1f:	48 b8 38 d2 4d 04 80 	movabs $0x80044dd238,%rax
  8004202f26:	00 00 00 
  8004202f29:	48 8b 00             	mov    (%rax),%rax
  8004202f2c:	48 8b 10             	mov    (%rax),%rdx
  8004202f2f:	48 b8 38 d2 4d 04 80 	movabs $0x80044dd238,%rax
  8004202f36:	00 00 00 
  8004202f39:	48 89 10             	mov    %rdx,(%rax)
		pp->pp_link = NULL;
  8004202f3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202f40:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (alloc_flags & ALLOC_ZERO)
  8004202f47:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202f4a:	83 e0 01             	and    $0x1,%eax
  8004202f4d:	85 c0                	test   %eax,%eax
  8004202f4f:	74 2c                	je     8004202f7d <page_alloc+0x81>
			memset(page2kva(pp), 0, PGSIZE);
  8004202f51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202f55:	48 89 c7             	mov    %rax,%rdi
  8004202f58:	48 b8 20 1c 20 04 80 	movabs $0x8004201c20,%rax
  8004202f5f:	00 00 00 
  8004202f62:	ff d0                	callq  *%rax
  8004202f64:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202f69:	be 00 00 00 00       	mov    $0x0,%esi
  8004202f6e:	48 89 c7             	mov    %rax,%rdi
  8004202f71:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  8004202f78:	00 00 00 
  8004202f7b:	ff d0                	callq  *%rax
	}
	return pp;
  8004202f7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax

}
  8004202f81:	c9                   	leaveq 
  8004202f82:	c3                   	retq   

0000008004202f83 <page_initpp>:
// The result has null links and 0 refcount.
// Note that the corresponding physical page is NOT initialized!
//
static void
page_initpp(struct PageInfo *pp)
{
  8004202f83:	55                   	push   %rbp
  8004202f84:	48 89 e5             	mov    %rsp,%rbp
  8004202f87:	48 83 ec 10          	sub    $0x10,%rsp
  8004202f8b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	memset(pp, 0, sizeof(*pp));
  8004202f8f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202f93:	ba 10 00 00 00       	mov    $0x10,%edx
  8004202f98:	be 00 00 00 00       	mov    $0x0,%esi
  8004202f9d:	48 89 c7             	mov    %rax,%rdi
  8004202fa0:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  8004202fa7:	00 00 00 
  8004202faa:	ff d0                	callq  *%rax
}
  8004202fac:	90                   	nop
  8004202fad:	c9                   	leaveq 
  8004202fae:	c3                   	retq   

0000008004202faf <page_free>:
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
  8004202faf:	55                   	push   %rbp
  8004202fb0:	48 89 e5             	mov    %rsp,%rbp
  8004202fb3:	48 83 ec 10          	sub    $0x10,%rsp
  8004202fb7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

	if (pp->pp_ref || pp->pp_link) {
  8004202fbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202fbf:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202fc3:	66 85 c0             	test   %ax,%ax
  8004202fc6:	75 0c                	jne    8004202fd4 <page_free+0x25>
  8004202fc8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202fcc:	48 8b 00             	mov    (%rax),%rax
  8004202fcf:	48 85 c0             	test   %rax,%rax
  8004202fd2:	74 2c                	je     8004203000 <page_free+0x51>
		warn("page_free: attempt to free mapped page");
  8004202fd4:	48 ba d0 f3 21 04 80 	movabs $0x800421f3d0,%rdx
  8004202fdb:	00 00 00 
  8004202fde:	be 04 02 00 00       	mov    $0x204,%esi
  8004202fe3:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004202fea:	00 00 00 
  8004202fed:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202ff2:	48 b9 2f 06 20 04 80 	movabs $0x800420062f,%rcx
  8004202ff9:	00 00 00 
  8004202ffc:	ff d1                	callq  *%rcx
		return;		/* be conservative and assume page is still used */
  8004202ffe:	eb 2f                	jmp    800420302f <page_free+0x80>
	}
	pp->pp_link = page_free_list;
  8004203000:	48 b8 38 d2 4d 04 80 	movabs $0x80044dd238,%rax
  8004203007:	00 00 00 
  800420300a:	48 8b 10             	mov    (%rax),%rdx
  800420300d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203011:	48 89 10             	mov    %rdx,(%rax)
	page_free_list = pp;
  8004203014:	48 b8 38 d2 4d 04 80 	movabs $0x80044dd238,%rax
  800420301b:	00 00 00 
  800420301e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203022:	48 89 10             	mov    %rdx,(%rax)
	pp->pp_ref = 0;
  8004203025:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203029:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)

}
  800420302f:	c9                   	leaveq 
  8004203030:	c3                   	retq   

0000008004203031 <page_decref>:
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
  8004203031:	55                   	push   %rbp
  8004203032:	48 89 e5             	mov    %rsp,%rbp
  8004203035:	48 83 ec 10          	sub    $0x10,%rsp
  8004203039:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (--pp->pp_ref == 0)
  800420303d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203041:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203045:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004203048:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420304c:	66 89 50 08          	mov    %dx,0x8(%rax)
  8004203050:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203054:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203058:	66 85 c0             	test   %ax,%ax
  800420305b:	75 13                	jne    8004203070 <page_decref+0x3f>
		page_free(pp);
  800420305d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203061:	48 89 c7             	mov    %rax,%rdi
  8004203064:	48 b8 af 2f 20 04 80 	movabs $0x8004202faf,%rax
  800420306b:	00 00 00 
  800420306e:	ff d0                	callq  *%rax
}
  8004203070:	90                   	nop
  8004203071:	c9                   	leaveq 
  8004203072:	c3                   	retq   

0000008004203073 <pml4e_walk>:
// table, page directory,page directory pointer and pml4 entries.
//

pte_t *
pml4e_walk(pml4e_t *pml4e, const void *va, int create)
{
  8004203073:	55                   	push   %rbp
  8004203074:	48 89 e5             	mov    %rsp,%rbp
  8004203077:	53                   	push   %rbx
  8004203078:	48 83 ec 68          	sub    $0x68,%rsp
  800420307c:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004203080:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8004203084:	89 55 9c             	mov    %edx,-0x64(%rbp)

	if (pml4e) {
  8004203087:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  800420308c:	0f 84 54 02 00 00    	je     80042032e6 <pml4e_walk+0x273>
		pdpe_t *pdpe  = (pdpe_t *)pml4e [PML4(va)];
  8004203092:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203096:	48 c1 e8 27          	shr    $0x27,%rax
  800420309a:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420309f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042030a6:	00 
  80042030a7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042030ab:	48 01 d0             	add    %rdx,%rax
  80042030ae:	48 8b 00             	mov    (%rax),%rax
  80042030b1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if (!((physaddr_t)pdpe & PTE_P) && create) {
  80042030b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042030b9:	83 e0 01             	and    $0x1,%eax
  80042030bc:	48 85 c0             	test   %rax,%rax
  80042030bf:	0f 85 82 01 00 00    	jne    8004203247 <pml4e_walk+0x1d4>
  80042030c5:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  80042030c9:	0f 84 78 01 00 00    	je     8004203247 <pml4e_walk+0x1d4>
			struct PageInfo *page   = NULL;
  80042030cf:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042030d6:	00 
			if ((page = page_alloc(ALLOC_ZERO))) {
  80042030d7:	bf 01 00 00 00       	mov    $0x1,%edi
  80042030dc:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  80042030e3:	00 00 00 
  80042030e6:	ff d0                	callq  *%rax
  80042030e8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042030ec:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042030f1:	0f 84 46 01 00 00    	je     800420323d <pml4e_walk+0x1ca>
				page->pp_ref    += 1;
  80042030f7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042030fb:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042030ff:	8d 50 01             	lea    0x1(%rax),%edx
  8004203102:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203106:	66 89 50 08          	mov    %dx,0x8(%rax)
				pml4e [PML4(va)] = page2pa(page)|PTE_U|PTE_W|PTE_P;
  800420310a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420310e:	48 c1 e8 27          	shr    $0x27,%rax
  8004203112:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203117:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420311e:	00 
  800420311f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203123:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004203127:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420312b:	48 89 c7             	mov    %rax,%rdi
  800420312e:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  8004203135:	00 00 00 
  8004203138:	ff d0                	callq  *%rax
  800420313a:	48 83 c8 07          	or     $0x7,%rax
  800420313e:	48 89 03             	mov    %rax,(%rbx)
				pte_t *pte= pdpe_walk(KADDR((uintptr_t)((pdpe_t *)(PTE_ADDR(pml4e [PML4(va)])))),va,create);
  8004203141:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203145:	48 c1 e8 27          	shr    $0x27,%rax
  8004203149:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420314e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203155:	00 
  8004203156:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420315a:	48 01 d0             	add    %rdx,%rax
  800420315d:	48 8b 00             	mov    (%rax),%rax
  8004203160:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203166:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420316a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420316e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203172:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  8004203175:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203178:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  800420317f:	00 00 00 
  8004203182:	48 8b 00             	mov    (%rax),%rax
  8004203185:	48 39 c2             	cmp    %rax,%rdx
  8004203188:	72 32                	jb     80042031bc <pml4e_walk+0x149>
  800420318a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420318e:	48 89 c1             	mov    %rax,%rcx
  8004203191:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  8004203198:	00 00 00 
  800420319b:	be 3c 02 00 00       	mov    $0x23c,%esi
  80042031a0:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042031a7:	00 00 00 
  80042031aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042031af:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042031b6:	00 00 00 
  80042031b9:	41 ff d0             	callq  *%r8
  80042031bc:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042031c3:	00 00 00 
  80042031c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042031ca:	48 01 d0             	add    %rdx,%rax
  80042031cd:	48 89 c1             	mov    %rax,%rcx
  80042031d0:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042031d3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042031d7:	48 89 c6             	mov    %rax,%rsi
  80042031da:	48 89 cf             	mov    %rcx,%rdi
  80042031dd:	48 b8 f2 32 20 04 80 	movabs $0x80042032f2,%rax
  80042031e4:	00 00 00 
  80042031e7:	ff d0                	callq  *%rax
  80042031e9:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
				if (pte!=NULL) return pte;
  80042031ed:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042031f2:	74 09                	je     80042031fd <pml4e_walk+0x18a>
  80042031f4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042031f8:	e9 ee 00 00 00       	jmpq   80042032eb <pml4e_walk+0x278>
				else{
					pml4e[PML4(va)] = 0;
  80042031fd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203201:	48 c1 e8 27          	shr    $0x27,%rax
  8004203205:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420320a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203211:	00 
  8004203212:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203216:	48 01 d0             	add    %rdx,%rax
  8004203219:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
					page_decref(page);
  8004203220:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203224:	48 89 c7             	mov    %rax,%rdi
  8004203227:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  800420322e:	00 00 00 
  8004203231:	ff d0                	callq  *%rax
					return NULL;
  8004203233:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203238:	e9 ae 00 00 00       	jmpq   80042032eb <pml4e_walk+0x278>
				}
			}else 
				return NULL;
  800420323d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203242:	e9 a4 00 00 00       	jmpq   80042032eb <pml4e_walk+0x278>
		} else if ((uint64_t)pdpe & PTE_P) {
  8004203247:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420324b:	83 e0 01             	and    $0x1,%eax
  800420324e:	48 85 c0             	test   %rax,%rax
  8004203251:	0f 84 8f 00 00 00    	je     80042032e6 <pml4e_walk+0x273>
			return pdpe_walk(KADDR((uintptr_t)((pdpe_t *)PTE_ADDR(pdpe))),va,create);
  8004203257:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420325b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203261:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004203265:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203269:	48 c1 e8 0c          	shr    $0xc,%rax
  800420326d:	89 45 bc             	mov    %eax,-0x44(%rbp)
  8004203270:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004203273:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  800420327a:	00 00 00 
  800420327d:	48 8b 00             	mov    (%rax),%rax
  8004203280:	48 39 c2             	cmp    %rax,%rdx
  8004203283:	72 32                	jb     80042032b7 <pml4e_walk+0x244>
  8004203285:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203289:	48 89 c1             	mov    %rax,%rcx
  800420328c:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  8004203293:	00 00 00 
  8004203296:	be 46 02 00 00       	mov    $0x246,%esi
  800420329b:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042032a2:	00 00 00 
  80042032a5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042032aa:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042032b1:	00 00 00 
  80042032b4:	41 ff d0             	callq  *%r8
  80042032b7:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042032be:	00 00 00 
  80042032c1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042032c5:	48 01 d0             	add    %rdx,%rax
  80042032c8:	48 89 c1             	mov    %rax,%rcx
  80042032cb:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042032ce:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042032d2:	48 89 c6             	mov    %rax,%rsi
  80042032d5:	48 89 cf             	mov    %rcx,%rdi
  80042032d8:	48 b8 f2 32 20 04 80 	movabs $0x80042032f2,%rax
  80042032df:	00 00 00 
  80042032e2:	ff d0                	callq  *%rax
  80042032e4:	eb 05                	jmp    80042032eb <pml4e_walk+0x278>
		}
	}
	return NULL;
  80042032e6:	b8 00 00 00 00       	mov    $0x0,%eax

}
  80042032eb:	48 83 c4 68          	add    $0x68,%rsp
  80042032ef:	5b                   	pop    %rbx
  80042032f0:	5d                   	pop    %rbp
  80042032f1:	c3                   	retq   

00000080042032f2 <pdpe_walk>:
// Given a pdpe i.e page directory pointer pdpe_walk returns the pointer to page table entry
// The programming logic in this function is similar to pml4e_walk.
// It calls the pgdir_walk which returns the page_table entry pointer.
// Hints are the same as in pml4e_walk
pte_t *
pdpe_walk(pdpe_t *pdpe,const void *va,int create){
  80042032f2:	55                   	push   %rbp
  80042032f3:	48 89 e5             	mov    %rsp,%rbp
  80042032f6:	53                   	push   %rbx
  80042032f7:	48 83 ec 68          	sub    $0x68,%rsp
  80042032fb:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80042032ff:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8004203303:	89 55 9c             	mov    %edx,-0x64(%rbp)


	if (pdpe){
  8004203306:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  800420330b:	0f 84 54 02 00 00    	je     8004203565 <pdpe_walk+0x273>
		pde_t * pdp = (pde_t *)pdpe[PDPE(va)];
  8004203311:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203315:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203319:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420331e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203325:	00 
  8004203326:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420332a:	48 01 d0             	add    %rdx,%rax
  800420332d:	48 8b 00             	mov    (%rax),%rax
  8004203330:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if(!((physaddr_t)pdp & PTE_P) && create){
  8004203334:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203338:	83 e0 01             	and    $0x1,%eax
  800420333b:	48 85 c0             	test   %rax,%rax
  800420333e:	0f 85 82 01 00 00    	jne    80042034c6 <pdpe_walk+0x1d4>
  8004203344:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  8004203348:	0f 84 78 01 00 00    	je     80042034c6 <pdpe_walk+0x1d4>
			struct PageInfo *page   = NULL;
  800420334e:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004203355:	00 
			if ((page = page_alloc(ALLOC_ZERO))) {
  8004203356:	bf 01 00 00 00       	mov    $0x1,%edi
  800420335b:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004203362:	00 00 00 
  8004203365:	ff d0                	callq  *%rax
  8004203367:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420336b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004203370:	0f 84 46 01 00 00    	je     80042034bc <pdpe_walk+0x1ca>
				page->pp_ref    += 1;
  8004203376:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420337a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420337e:	8d 50 01             	lea    0x1(%rax),%edx
  8004203381:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203385:	66 89 50 08          	mov    %dx,0x8(%rax)
				pdpe [PDPE(va)] = page2pa(page)|PTE_U|PTE_W|PTE_P;
  8004203389:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420338d:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203391:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203396:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420339d:	00 
  800420339e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042033a2:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  80042033a6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042033aa:	48 89 c7             	mov    %rax,%rdi
  80042033ad:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  80042033b4:	00 00 00 
  80042033b7:	ff d0                	callq  *%rax
  80042033b9:	48 83 c8 07          	or     $0x7,%rax
  80042033bd:	48 89 03             	mov    %rax,(%rbx)
				pte_t *pte = pgdir_walk(KADDR((uintptr_t)((pde_t *)PTE_ADDR(pdpe[PDPE(va)]))),va,create);
  80042033c0:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042033c4:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042033c8:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042033cd:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042033d4:	00 
  80042033d5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042033d9:	48 01 d0             	add    %rdx,%rax
  80042033dc:	48 8b 00             	mov    (%rax),%rax
  80042033df:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042033e5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042033e9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042033ed:	48 c1 e8 0c          	shr    $0xc,%rax
  80042033f1:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  80042033f4:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042033f7:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  80042033fe:	00 00 00 
  8004203401:	48 8b 00             	mov    (%rax),%rax
  8004203404:	48 39 c2             	cmp    %rax,%rdx
  8004203407:	72 32                	jb     800420343b <pdpe_walk+0x149>
  8004203409:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420340d:	48 89 c1             	mov    %rax,%rcx
  8004203410:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  8004203417:	00 00 00 
  800420341a:	be 5d 02 00 00       	mov    $0x25d,%esi
  800420341f:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004203426:	00 00 00 
  8004203429:	b8 00 00 00 00       	mov    $0x0,%eax
  800420342e:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004203435:	00 00 00 
  8004203438:	41 ff d0             	callq  *%r8
  800420343b:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203442:	00 00 00 
  8004203445:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203449:	48 01 d0             	add    %rdx,%rax
  800420344c:	48 89 c1             	mov    %rax,%rcx
  800420344f:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004203452:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203456:	48 89 c6             	mov    %rax,%rsi
  8004203459:	48 89 cf             	mov    %rcx,%rdi
  800420345c:	48 b8 71 35 20 04 80 	movabs $0x8004203571,%rax
  8004203463:	00 00 00 
  8004203466:	ff d0                	callq  *%rax
  8004203468:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
				if (pte!=NULL) return pte;
  800420346c:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004203471:	74 09                	je     800420347c <pdpe_walk+0x18a>
  8004203473:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203477:	e9 ee 00 00 00       	jmpq   800420356a <pdpe_walk+0x278>
				else{
					pdpe[PDPE(va)] = 0;
  800420347c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203480:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203484:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203489:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203490:	00 
  8004203491:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203495:	48 01 d0             	add    %rdx,%rax
  8004203498:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
					page_decref(page);
  800420349f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042034a3:	48 89 c7             	mov    %rax,%rdi
  80042034a6:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  80042034ad:	00 00 00 
  80042034b0:	ff d0                	callq  *%rax
					return NULL;
  80042034b2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042034b7:	e9 ae 00 00 00       	jmpq   800420356a <pdpe_walk+0x278>
				}
			}else
				return NULL;
  80042034bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042034c1:	e9 a4 00 00 00       	jmpq   800420356a <pdpe_walk+0x278>
		}else if((uint64_t)pdp & PTE_P){
  80042034c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042034ca:	83 e0 01             	and    $0x1,%eax
  80042034cd:	48 85 c0             	test   %rax,%rax
  80042034d0:	0f 84 8f 00 00 00    	je     8004203565 <pdpe_walk+0x273>
			return pgdir_walk(KADDR((uintptr_t)((pde_t *)PTE_ADDR(pdp))),va,create);
  80042034d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042034da:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042034e0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042034e4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042034e8:	48 c1 e8 0c          	shr    $0xc,%rax
  80042034ec:	89 45 bc             	mov    %eax,-0x44(%rbp)
  80042034ef:	8b 55 bc             	mov    -0x44(%rbp),%edx
  80042034f2:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  80042034f9:	00 00 00 
  80042034fc:	48 8b 00             	mov    (%rax),%rax
  80042034ff:	48 39 c2             	cmp    %rax,%rdx
  8004203502:	72 32                	jb     8004203536 <pdpe_walk+0x244>
  8004203504:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203508:	48 89 c1             	mov    %rax,%rcx
  800420350b:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  8004203512:	00 00 00 
  8004203515:	be 67 02 00 00       	mov    $0x267,%esi
  800420351a:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004203521:	00 00 00 
  8004203524:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203529:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004203530:	00 00 00 
  8004203533:	41 ff d0             	callq  *%r8
  8004203536:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420353d:	00 00 00 
  8004203540:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203544:	48 01 d0             	add    %rdx,%rax
  8004203547:	48 89 c1             	mov    %rax,%rcx
  800420354a:	8b 55 9c             	mov    -0x64(%rbp),%edx
  800420354d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203551:	48 89 c6             	mov    %rax,%rsi
  8004203554:	48 89 cf             	mov    %rcx,%rdi
  8004203557:	48 b8 71 35 20 04 80 	movabs $0x8004203571,%rax
  800420355e:	00 00 00 
  8004203561:	ff d0                	callq  *%rax
  8004203563:	eb 05                	jmp    800420356a <pdpe_walk+0x278>
		}
	}
	return NULL;
  8004203565:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420356a:	48 83 c4 68          	add    $0x68,%rsp
  800420356e:	5b                   	pop    %rbx
  800420356f:	5d                   	pop    %rbp
  8004203570:	c3                   	retq   

0000008004203571 <pgdir_walk>:
// The programming logic and the hints are the same as pml4e_walk
// and pdpe_walk.

pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
  8004203571:	55                   	push   %rbp
  8004203572:	48 89 e5             	mov    %rsp,%rbp
  8004203575:	53                   	push   %rbx
  8004203576:	48 83 ec 58          	sub    $0x58,%rsp
  800420357a:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800420357e:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004203582:	89 55 ac             	mov    %edx,-0x54(%rbp)

	if (pgdir) {
  8004203585:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  800420358a:	0f 84 fd 01 00 00    	je     800420378d <pgdir_walk+0x21c>
		pte_t *pte  = (pte_t *)pgdir [PDX(va)];
  8004203590:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203594:	48 c1 e8 15          	shr    $0x15,%rax
  8004203598:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420359d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042035a4:	00 
  80042035a5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042035a9:	48 01 d0             	add    %rdx,%rax
  80042035ac:	48 8b 00             	mov    (%rax),%rax
  80042035af:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if (!((physaddr_t)pte & PTE_P) && create) {
  80042035b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042035b7:	83 e0 01             	and    $0x1,%eax
  80042035ba:	48 85 c0             	test   %rax,%rax
  80042035bd:	0f 85 2f 01 00 00    	jne    80042036f2 <pgdir_walk+0x181>
  80042035c3:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  80042035c7:	0f 84 25 01 00 00    	je     80042036f2 <pgdir_walk+0x181>
			struct PageInfo *page   = NULL;
  80042035cd:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042035d4:	00 
			if ((page = page_alloc(ALLOC_ZERO))) {
  80042035d5:	bf 01 00 00 00       	mov    $0x1,%edi
  80042035da:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  80042035e1:	00 00 00 
  80042035e4:	ff d0                	callq  *%rax
  80042035e6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042035ea:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042035ef:	0f 84 f3 00 00 00    	je     80042036e8 <pgdir_walk+0x177>
				page->pp_ref    += 1;
  80042035f5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042035f9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042035fd:	8d 50 01             	lea    0x1(%rax),%edx
  8004203600:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203604:	66 89 50 08          	mov    %dx,0x8(%rax)
				pgdir [PDX(va)] = page2pa(page)|PTE_U|PTE_W|PTE_P;
  8004203608:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420360c:	48 c1 e8 15          	shr    $0x15,%rax
  8004203610:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203615:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420361c:	00 
  800420361d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203621:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004203625:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203629:	48 89 c7             	mov    %rax,%rdi
  800420362c:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  8004203633:	00 00 00 
  8004203636:	ff d0                	callq  *%rax
  8004203638:	48 83 c8 07          	or     $0x7,%rax
  800420363c:	48 89 03             	mov    %rax,(%rbx)
				return KADDR((uintptr_t)((pte_t *)(PTE_ADDR(pgdir [PDX(va)])) + PTX(va)));
  800420363f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203643:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203647:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420364c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203653:	00 
  8004203654:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203658:	48 c1 e8 15          	shr    $0x15,%rax
  800420365c:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203661:	48 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%rcx
  8004203668:	00 
  8004203669:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420366d:	48 01 c8             	add    %rcx,%rax
  8004203670:	48 8b 00             	mov    (%rax),%rax
  8004203673:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203679:	48 01 d0             	add    %rdx,%rax
  800420367c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004203680:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203684:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203688:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  800420368b:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800420368e:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004203695:	00 00 00 
  8004203698:	48 8b 00             	mov    (%rax),%rax
  800420369b:	48 39 c2             	cmp    %rax,%rdx
  800420369e:	72 32                	jb     80042036d2 <pgdir_walk+0x161>
  80042036a0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042036a4:	48 89 c1             	mov    %rax,%rcx
  80042036a7:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  80042036ae:	00 00 00 
  80042036b1:	be 7d 02 00 00       	mov    $0x27d,%esi
  80042036b6:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042036bd:	00 00 00 
  80042036c0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042036c5:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042036cc:	00 00 00 
  80042036cf:	41 ff d0             	callq  *%r8
  80042036d2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042036d9:	00 00 00 
  80042036dc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042036e0:	48 01 d0             	add    %rdx,%rax
  80042036e3:	e9 aa 00 00 00       	jmpq   8004203792 <pgdir_walk+0x221>
			}else{
				return NULL;
  80042036e8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042036ed:	e9 a0 00 00 00       	jmpq   8004203792 <pgdir_walk+0x221>
			}
		} else if ((uint64_t)pte & PTE_P) {
  80042036f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042036f6:	83 e0 01             	and    $0x1,%eax
  80042036f9:	48 85 c0             	test   %rax,%rax
  80042036fc:	0f 84 8b 00 00 00    	je     800420378d <pgdir_walk+0x21c>
			return KADDR((uintptr_t)((pte_t *)PTE_ADDR(pte) + PTX(va)));
  8004203702:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203706:	48 c1 e8 0c          	shr    $0xc,%rax
  800420370a:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420370f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203716:	00 
  8004203717:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420371b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203721:	48 01 d0             	add    %rdx,%rax
  8004203724:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004203728:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420372c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203730:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004203733:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004203736:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  800420373d:	00 00 00 
  8004203740:	48 8b 00             	mov    (%rax),%rax
  8004203743:	48 39 c2             	cmp    %rax,%rdx
  8004203746:	72 32                	jb     800420377a <pgdir_walk+0x209>
  8004203748:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420374c:	48 89 c1             	mov    %rax,%rcx
  800420374f:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  8004203756:	00 00 00 
  8004203759:	be 82 02 00 00       	mov    $0x282,%esi
  800420375e:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004203765:	00 00 00 
  8004203768:	b8 00 00 00 00       	mov    $0x0,%eax
  800420376d:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004203774:	00 00 00 
  8004203777:	41 ff d0             	callq  *%r8
  800420377a:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203781:	00 00 00 
  8004203784:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203788:	48 01 d0             	add    %rdx,%rax
  800420378b:	eb 05                	jmp    8004203792 <pgdir_walk+0x221>
		}
	}
	return NULL;
  800420378d:	b8 00 00 00 00       	mov    $0x0,%eax

}
  8004203792:	48 83 c4 58          	add    $0x58,%rsp
  8004203796:	5b                   	pop    %rbx
  8004203797:	5d                   	pop    %rbp
  8004203798:	c3                   	retq   

0000008004203799 <boot_map_region>:
// mapped pages.
//
// Hint: the TA solution uses pml4e_walk
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
  8004203799:	55                   	push   %rbp
  800420379a:	48 89 e5             	mov    %rsp,%rbp
  800420379d:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  80042037a1:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80042037a5:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  80042037a9:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  80042037ad:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
  80042037b1:	44 89 45 8c          	mov    %r8d,-0x74(%rbp)

	uint64_t i,j;
	pdpe_t *pdpe;
	pde_t *pde;
	//cprintf("mapping %x at %x (size: %x)\n", la, pa, size);
	for (i = 0; i < size; i+=PGSIZE) {
  80042037b5:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042037bc:	00 
  80042037bd:	e9 aa 02 00 00       	jmpq   8004203a6c <boot_map_region+0x2d3>
		pte_t *pte      = pml4e_walk(pml4e, (void *)(la + i), 1);
  80042037c2:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042037c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042037ca:	48 01 d0             	add    %rdx,%rax
  80042037cd:	48 89 c1             	mov    %rax,%rcx
  80042037d0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042037d4:	ba 01 00 00 00       	mov    $0x1,%edx
  80042037d9:	48 89 ce             	mov    %rcx,%rsi
  80042037dc:	48 89 c7             	mov    %rax,%rdi
  80042037df:	48 b8 73 30 20 04 80 	movabs $0x8004203073,%rax
  80042037e6:	00 00 00 
  80042037e9:	ff d0                	callq  *%rax
  80042037eb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		physaddr_t addr = pa + i;
  80042037ef:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042037f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042037f7:	48 01 d0             	add    %rdx,%rax
  80042037fa:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if (pte != NULL) {
  80042037fe:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004203803:	74 23                	je     8004203828 <boot_map_region+0x8f>
			*pte    = PTE_ADDR(addr)|perm|PTE_P;
  8004203805:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203809:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420380f:	48 89 c2             	mov    %rax,%rdx
  8004203812:	8b 45 8c             	mov    -0x74(%rbp),%eax
  8004203815:	48 98                	cltq   
  8004203817:	48 09 d0             	or     %rdx,%rax
  800420381a:	48 83 c8 01          	or     $0x1,%rax
  800420381e:	48 89 c2             	mov    %rax,%rdx
  8004203821:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203825:	48 89 10             	mov    %rdx,(%rax)
		}
		pml4e [PML4(la+i)]   = pml4e [PML4(la+i)]|perm|PTE_P;
  8004203828:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420382c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203830:	48 01 d0             	add    %rdx,%rax
  8004203833:	48 c1 e8 27          	shr    $0x27,%rax
  8004203837:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420383c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203843:	00 
  8004203844:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203848:	48 01 d0             	add    %rdx,%rax
  800420384b:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420384f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203853:	48 01 ca             	add    %rcx,%rdx
  8004203856:	48 c1 ea 27          	shr    $0x27,%rdx
  800420385a:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203860:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004203867:	00 
  8004203868:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420386c:	48 01 ca             	add    %rcx,%rdx
  800420386f:	48 8b 0a             	mov    (%rdx),%rcx
  8004203872:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004203875:	48 63 d2             	movslq %edx,%rdx
  8004203878:	48 09 ca             	or     %rcx,%rdx
  800420387b:	48 83 ca 01          	or     $0x1,%rdx
  800420387f:	48 89 10             	mov    %rdx,(%rax)
		pdpe                 = (pdpe_t *)KADDR(PTE_ADDR(pml4e[PML4(la + i)]));
  8004203882:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004203886:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420388a:	48 01 d0             	add    %rdx,%rax
  800420388d:	48 c1 e8 27          	shr    $0x27,%rax
  8004203891:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203896:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420389d:	00 
  800420389e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042038a2:	48 01 d0             	add    %rdx,%rax
  80042038a5:	48 8b 00             	mov    (%rax),%rax
  80042038a8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042038ae:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042038b2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042038b6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042038ba:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042038bd:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042038c0:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  80042038c7:	00 00 00 
  80042038ca:	48 8b 00             	mov    (%rax),%rax
  80042038cd:	48 39 c2             	cmp    %rax,%rdx
  80042038d0:	72 32                	jb     8004203904 <boot_map_region+0x16b>
  80042038d2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042038d6:	48 89 c1             	mov    %rax,%rcx
  80042038d9:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  80042038e0:	00 00 00 
  80042038e3:	be a2 02 00 00       	mov    $0x2a2,%esi
  80042038e8:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042038ef:	00 00 00 
  80042038f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042038f7:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042038fe:	00 00 00 
  8004203901:	41 ff d0             	callq  *%r8
  8004203904:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420390b:	00 00 00 
  800420390e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203912:	48 01 d0             	add    %rdx,%rax
  8004203915:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		pdpe[PDPE(la+i)]     = pdpe[PDPE(la+i)]|perm|PTE_P;
  8004203919:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420391d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203921:	48 01 d0             	add    %rdx,%rax
  8004203924:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203928:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420392d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203934:	00 
  8004203935:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203939:	48 01 d0             	add    %rdx,%rax
  800420393c:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004203940:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203944:	48 01 ca             	add    %rcx,%rdx
  8004203947:	48 c1 ea 1e          	shr    $0x1e,%rdx
  800420394b:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203951:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004203958:	00 
  8004203959:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420395d:	48 01 ca             	add    %rcx,%rdx
  8004203960:	48 8b 0a             	mov    (%rdx),%rcx
  8004203963:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004203966:	48 63 d2             	movslq %edx,%rdx
  8004203969:	48 09 ca             	or     %rcx,%rdx
  800420396c:	48 83 ca 01          	or     $0x1,%rdx
  8004203970:	48 89 10             	mov    %rdx,(%rax)
		pde                  = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(la+i)]));
  8004203973:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004203977:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420397b:	48 01 d0             	add    %rdx,%rax
  800420397e:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203982:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203987:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420398e:	00 
  800420398f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203993:	48 01 d0             	add    %rdx,%rax
  8004203996:	48 8b 00             	mov    (%rax),%rax
  8004203999:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420399f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042039a3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042039a7:	48 c1 e8 0c          	shr    $0xc,%rax
  80042039ab:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  80042039ae:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042039b1:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  80042039b8:	00 00 00 
  80042039bb:	48 8b 00             	mov    (%rax),%rax
  80042039be:	48 39 c2             	cmp    %rax,%rdx
  80042039c1:	72 32                	jb     80042039f5 <boot_map_region+0x25c>
  80042039c3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042039c7:	48 89 c1             	mov    %rax,%rcx
  80042039ca:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  80042039d1:	00 00 00 
  80042039d4:	be a4 02 00 00       	mov    $0x2a4,%esi
  80042039d9:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042039e0:	00 00 00 
  80042039e3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042039e8:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042039ef:	00 00 00 
  80042039f2:	41 ff d0             	callq  *%r8
  80042039f5:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042039fc:	00 00 00 
  80042039ff:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203a03:	48 01 d0             	add    %rdx,%rax
  8004203a06:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		pde[PDX(la+i)]       = pde[PDX(la+i)]|perm|PTE_P;
  8004203a0a:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004203a0e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a12:	48 01 d0             	add    %rdx,%rax
  8004203a15:	48 c1 e8 15          	shr    $0x15,%rax
  8004203a19:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203a1e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203a25:	00 
  8004203a26:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203a2a:	48 01 d0             	add    %rdx,%rax
  8004203a2d:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004203a31:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203a35:	48 01 ca             	add    %rcx,%rdx
  8004203a38:	48 c1 ea 15          	shr    $0x15,%rdx
  8004203a3c:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203a42:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004203a49:	00 
  8004203a4a:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004203a4e:	48 01 ca             	add    %rcx,%rdx
  8004203a51:	48 8b 0a             	mov    (%rdx),%rcx
  8004203a54:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004203a57:	48 63 d2             	movslq %edx,%rdx
  8004203a5a:	48 09 ca             	or     %rcx,%rdx
  8004203a5d:	48 83 ca 01          	or     $0x1,%rdx
  8004203a61:	48 89 10             	mov    %rdx,(%rax)

	uint64_t i,j;
	pdpe_t *pdpe;
	pde_t *pde;
	//cprintf("mapping %x at %x (size: %x)\n", la, pa, size);
	for (i = 0; i < size; i+=PGSIZE) {
  8004203a64:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004203a6b:	00 
  8004203a6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a70:	48 3b 45 98          	cmp    -0x68(%rbp),%rax
  8004203a74:	0f 82 48 fd ff ff    	jb     80042037c2 <boot_map_region+0x29>
		pdpe[PDPE(la+i)]     = pdpe[PDPE(la+i)]|perm|PTE_P;
		pde                  = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(la+i)]));
		pde[PDX(la+i)]       = pde[PDX(la+i)]|perm|PTE_P;
	}

}
  8004203a7a:	90                   	nop
  8004203a7b:	c9                   	leaveq 
  8004203a7c:	c3                   	retq   

0000008004203a7d <page_insert>:
// Hint: The TA solution is implemented using pml4e_walk, page_remove,
// and page2pa.
//
int
page_insert(pml4e_t *pml4e, struct PageInfo *pp, void *va, int perm)
{
  8004203a7d:	55                   	push   %rbp
  8004203a7e:	48 89 e5             	mov    %rsp,%rbp
  8004203a81:	48 83 ec 60          	sub    $0x60,%rsp
  8004203a85:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004203a89:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004203a8d:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  8004203a91:	89 4d a4             	mov    %ecx,-0x5c(%rbp)

	pdpe_t *pdpe;
	pde_t *pde;
	if (pml4e && pp) {
  8004203a94:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004203a99:	0f 84 4b 03 00 00    	je     8004203dea <page_insert+0x36d>
  8004203a9f:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004203aa4:	0f 84 40 03 00 00    	je     8004203dea <page_insert+0x36d>
		pte_t *pte  = pml4e_walk(pml4e, va, 1);
  8004203aaa:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004203aae:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203ab2:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203ab7:	48 89 ce             	mov    %rcx,%rsi
  8004203aba:	48 89 c7             	mov    %rax,%rdi
  8004203abd:	48 b8 73 30 20 04 80 	movabs $0x8004203073,%rax
  8004203ac4:	00 00 00 
  8004203ac7:	ff d0                	callq  *%rax
  8004203ac9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (pte != NULL) {
  8004203acd:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203ad2:	0f 84 0b 03 00 00    	je     8004203de3 <page_insert+0x366>
			pml4e [PML4(va)] = pml4e [PML4(va)]|(perm&(~PTE_AVAIL));
  8004203ad8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203adc:	48 c1 e8 27          	shr    $0x27,%rax
  8004203ae0:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203ae5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203aec:	00 
  8004203aed:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203af1:	48 01 d0             	add    %rdx,%rax
  8004203af4:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203af8:	48 c1 ea 27          	shr    $0x27,%rdx
  8004203afc:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203b02:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004203b09:	00 
  8004203b0a:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004203b0e:	48 01 ca             	add    %rcx,%rdx
  8004203b11:	48 8b 0a             	mov    (%rdx),%rcx
  8004203b14:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004203b17:	80 e6 f1             	and    $0xf1,%dh
  8004203b1a:	48 63 d2             	movslq %edx,%rdx
  8004203b1d:	48 09 ca             	or     %rcx,%rdx
  8004203b20:	48 89 10             	mov    %rdx,(%rax)
			pdpe = (pdpe_t *)KADDR(PTE_ADDR(pml4e[PML4(va)]));
  8004203b23:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203b27:	48 c1 e8 27          	shr    $0x27,%rax
  8004203b2b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203b30:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203b37:	00 
  8004203b38:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203b3c:	48 01 d0             	add    %rdx,%rax
  8004203b3f:	48 8b 00             	mov    (%rax),%rax
  8004203b42:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203b48:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004203b4c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203b50:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203b54:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004203b57:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004203b5a:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004203b61:	00 00 00 
  8004203b64:	48 8b 00             	mov    (%rax),%rax
  8004203b67:	48 39 c2             	cmp    %rax,%rdx
  8004203b6a:	72 32                	jb     8004203b9e <page_insert+0x121>
  8004203b6c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203b70:	48 89 c1             	mov    %rax,%rcx
  8004203b73:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  8004203b7a:	00 00 00 
  8004203b7d:	be cd 02 00 00       	mov    $0x2cd,%esi
  8004203b82:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004203b89:	00 00 00 
  8004203b8c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203b91:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004203b98:	00 00 00 
  8004203b9b:	41 ff d0             	callq  *%r8
  8004203b9e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203ba5:	00 00 00 
  8004203ba8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203bac:	48 01 d0             	add    %rdx,%rax
  8004203baf:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
			pdpe[PDPE(va)] = pdpe[PDPE(va)]|(perm&(~PTE_AVAIL));
  8004203bb3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203bb7:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203bbb:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203bc0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203bc7:	00 
  8004203bc8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203bcc:	48 01 d0             	add    %rdx,%rax
  8004203bcf:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203bd3:	48 c1 ea 1e          	shr    $0x1e,%rdx
  8004203bd7:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203bdd:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004203be4:	00 
  8004203be5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203be9:	48 01 ca             	add    %rcx,%rdx
  8004203bec:	48 8b 0a             	mov    (%rdx),%rcx
  8004203bef:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004203bf2:	80 e6 f1             	and    $0xf1,%dh
  8004203bf5:	48 63 d2             	movslq %edx,%rdx
  8004203bf8:	48 09 ca             	or     %rcx,%rdx
  8004203bfb:	48 89 10             	mov    %rdx,(%rax)
			pde = (pde_t *)KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004203bfe:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203c02:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203c06:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203c0b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203c12:	00 
  8004203c13:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203c17:	48 01 d0             	add    %rdx,%rax
  8004203c1a:	48 8b 00             	mov    (%rax),%rax
  8004203c1d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203c23:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004203c27:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203c2b:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203c2f:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  8004203c32:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203c35:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004203c3c:	00 00 00 
  8004203c3f:	48 8b 00             	mov    (%rax),%rax
  8004203c42:	48 39 c2             	cmp    %rax,%rdx
  8004203c45:	72 32                	jb     8004203c79 <page_insert+0x1fc>
  8004203c47:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203c4b:	48 89 c1             	mov    %rax,%rcx
  8004203c4e:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  8004203c55:	00 00 00 
  8004203c58:	be cf 02 00 00       	mov    $0x2cf,%esi
  8004203c5d:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004203c64:	00 00 00 
  8004203c67:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203c6c:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004203c73:	00 00 00 
  8004203c76:	41 ff d0             	callq  *%r8
  8004203c79:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203c80:	00 00 00 
  8004203c83:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203c87:	48 01 d0             	add    %rdx,%rax
  8004203c8a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			pde[PDX(va)] = pde[PDX(va)]|(perm&(~PTE_AVAIL));
  8004203c8e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203c92:	48 c1 e8 15          	shr    $0x15,%rax
  8004203c96:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203c9b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203ca2:	00 
  8004203ca3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203ca7:	48 01 d0             	add    %rdx,%rax
  8004203caa:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203cae:	48 c1 ea 15          	shr    $0x15,%rdx
  8004203cb2:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203cb8:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004203cbf:	00 
  8004203cc0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004203cc4:	48 01 ca             	add    %rcx,%rdx
  8004203cc7:	48 8b 0a             	mov    (%rdx),%rcx
  8004203cca:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004203ccd:	80 e6 f1             	and    $0xf1,%dh
  8004203cd0:	48 63 d2             	movslq %edx,%rdx
  8004203cd3:	48 09 ca             	or     %rcx,%rdx
  8004203cd6:	48 89 10             	mov    %rdx,(%rax)
			if ((*pte & PTE_P) && (page2pa(pp) == PTE_ADDR(*pte))) {
  8004203cd9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203cdd:	48 8b 00             	mov    (%rax),%rax
  8004203ce0:	83 e0 01             	and    $0x1,%eax
  8004203ce3:	48 85 c0             	test   %rax,%rax
  8004203ce6:	74 72                	je     8004203d5a <page_insert+0x2dd>
  8004203ce8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203cec:	48 89 c7             	mov    %rax,%rdi
  8004203cef:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  8004203cf6:	00 00 00 
  8004203cf9:	ff d0                	callq  *%rax
  8004203cfb:	48 89 c2             	mov    %rax,%rdx
  8004203cfe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d02:	48 8b 00             	mov    (%rax),%rax
  8004203d05:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203d0b:	48 39 c2             	cmp    %rax,%rdx
  8004203d0e:	75 4a                	jne    8004203d5a <page_insert+0x2dd>
				*pte    = PTE_ADDR(*pte)|perm|PTE_P;
  8004203d10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d14:	48 8b 00             	mov    (%rax),%rax
  8004203d17:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203d1d:	48 89 c2             	mov    %rax,%rdx
  8004203d20:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004203d23:	48 98                	cltq   
  8004203d25:	48 09 d0             	or     %rdx,%rax
  8004203d28:	48 83 c8 01          	or     $0x1,%rax
  8004203d2c:	48 89 c2             	mov    %rax,%rdx
  8004203d2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d33:	48 89 10             	mov    %rdx,(%rax)
				tlb_invalidate(pml4e, va);
  8004203d36:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203d3a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203d3e:	48 89 d6             	mov    %rdx,%rsi
  8004203d41:	48 89 c7             	mov    %rax,%rdi
  8004203d44:	48 b8 f0 3e 20 04 80 	movabs $0x8004203ef0,%rax
  8004203d4b:	00 00 00 
  8004203d4e:	ff d0                	callq  *%rax
				return 0;
  8004203d50:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203d55:	e9 95 00 00 00       	jmpq   8004203def <page_insert+0x372>
			} else if (*pte & PTE_P) {
  8004203d5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d5e:	48 8b 00             	mov    (%rax),%rax
  8004203d61:	83 e0 01             	and    $0x1,%eax
  8004203d64:	48 85 c0             	test   %rax,%rax
  8004203d67:	74 1a                	je     8004203d83 <page_insert+0x306>
				page_remove(pml4e, va);
  8004203d69:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203d6d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203d71:	48 89 d6             	mov    %rdx,%rsi
  8004203d74:	48 89 c7             	mov    %rax,%rdi
  8004203d77:	48 b8 7c 3e 20 04 80 	movabs $0x8004203e7c,%rax
  8004203d7e:	00 00 00 
  8004203d81:	ff d0                	callq  *%rax
			}
			pp->pp_ref  += 1;
  8004203d83:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203d87:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203d8b:	8d 50 01             	lea    0x1(%rax),%edx
  8004203d8e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203d92:	66 89 50 08          	mov    %dx,0x8(%rax)
			*pte    = page2pa(pp)|perm|PTE_P;
  8004203d96:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203d9a:	48 89 c7             	mov    %rax,%rdi
  8004203d9d:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  8004203da4:	00 00 00 
  8004203da7:	ff d0                	callq  *%rax
  8004203da9:	48 89 c2             	mov    %rax,%rdx
  8004203dac:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004203daf:	48 98                	cltq   
  8004203db1:	48 09 d0             	or     %rdx,%rax
  8004203db4:	48 83 c8 01          	or     $0x1,%rax
  8004203db8:	48 89 c2             	mov    %rax,%rdx
  8004203dbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203dbf:	48 89 10             	mov    %rdx,(%rax)
			tlb_invalidate(pml4e, va);
  8004203dc2:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203dc6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203dca:	48 89 d6             	mov    %rdx,%rsi
  8004203dcd:	48 89 c7             	mov    %rax,%rdi
  8004203dd0:	48 b8 f0 3e 20 04 80 	movabs $0x8004203ef0,%rax
  8004203dd7:	00 00 00 
  8004203dda:	ff d0                	callq  *%rax
			return 0;
  8004203ddc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203de1:	eb 0c                	jmp    8004203def <page_insert+0x372>
		}else
			return -E_NO_MEM;
  8004203de3:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004203de8:	eb 05                	jmp    8004203def <page_insert+0x372>
	}
	return -E_NO_MEM;
  8004203dea:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax

}
  8004203def:	c9                   	leaveq 
  8004203df0:	c3                   	retq   

0000008004203df1 <page_lookup>:
//
// Hint: the TA solution uses pml4e_walk and pa2page.
//
struct PageInfo *
page_lookup(pml4e_t *pml4e, void *va, pte_t **pte_store)
{
  8004203df1:	55                   	push   %rbp
  8004203df2:	48 89 e5             	mov    %rsp,%rbp
  8004203df5:	48 83 ec 30          	sub    $0x30,%rsp
  8004203df9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203dfd:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004203e01:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	if (pml4e != NULL) {
  8004203e05:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203e0a:	74 69                	je     8004203e75 <page_lookup+0x84>
		pte_t *pte  = pml4e_walk(pml4e, va, 0);
  8004203e0c:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203e10:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203e14:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203e19:	48 89 ce             	mov    %rcx,%rsi
  8004203e1c:	48 89 c7             	mov    %rax,%rdi
  8004203e1f:	48 b8 73 30 20 04 80 	movabs $0x8004203073,%rax
  8004203e26:	00 00 00 
  8004203e29:	ff d0                	callq  *%rax
  8004203e2b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (pte != NULL && (*pte & PTE_P)) {
  8004203e2f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203e34:	74 3f                	je     8004203e75 <page_lookup+0x84>
  8004203e36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e3a:	48 8b 00             	mov    (%rax),%rax
  8004203e3d:	83 e0 01             	and    $0x1,%eax
  8004203e40:	48 85 c0             	test   %rax,%rax
  8004203e43:	74 30                	je     8004203e75 <page_lookup+0x84>
			if (pte_store)
  8004203e45:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004203e4a:	74 0b                	je     8004203e57 <page_lookup+0x66>
				*pte_store  = pte;
  8004203e4c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203e50:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203e54:	48 89 10             	mov    %rdx,(%rax)
			return pa2page(PTE_ADDR(*pte));
  8004203e57:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e5b:	48 8b 00             	mov    (%rax),%rax
  8004203e5e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203e64:	48 89 c7             	mov    %rax,%rdi
  8004203e67:	48 b8 af 1b 20 04 80 	movabs $0x8004201baf,%rax
  8004203e6e:	00 00 00 
  8004203e71:	ff d0                	callq  *%rax
  8004203e73:	eb 05                	jmp    8004203e7a <page_lookup+0x89>
		}
	}
	return NULL;
  8004203e75:	b8 00 00 00 00       	mov    $0x0,%eax

}
  8004203e7a:	c9                   	leaveq 
  8004203e7b:	c3                   	retq   

0000008004203e7c <page_remove>:
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pml4e_t *pml4e, void *va)
{
  8004203e7c:	55                   	push   %rbp
  8004203e7d:	48 89 e5             	mov    %rsp,%rbp
  8004203e80:	48 83 ec 20          	sub    $0x20,%rsp
  8004203e84:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203e88:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	pte_t *pte;
	struct PageInfo *page   = page_lookup(pml4e, va, &pte);
  8004203e8c:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8004203e90:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203e94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203e98:	48 89 ce             	mov    %rcx,%rsi
  8004203e9b:	48 89 c7             	mov    %rax,%rdi
  8004203e9e:	48 b8 f1 3d 20 04 80 	movabs $0x8004203df1,%rax
  8004203ea5:	00 00 00 
  8004203ea8:	ff d0                	callq  *%rax
  8004203eaa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (page != NULL) {
  8004203eae:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203eb3:	74 38                	je     8004203eed <page_remove+0x71>
		tlb_invalidate(pml4e, va);
  8004203eb5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203eb9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203ebd:	48 89 d6             	mov    %rdx,%rsi
  8004203ec0:	48 89 c7             	mov    %rax,%rdi
  8004203ec3:	48 b8 f0 3e 20 04 80 	movabs $0x8004203ef0,%rax
  8004203eca:	00 00 00 
  8004203ecd:	ff d0                	callq  *%rax
		page_decref(page);
  8004203ecf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ed3:	48 89 c7             	mov    %rax,%rdi
  8004203ed6:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  8004203edd:	00 00 00 
  8004203ee0:	ff d0                	callq  *%rax
		*pte    = 0;
  8004203ee2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203ee6:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	}

}
  8004203eed:	90                   	nop
  8004203eee:	c9                   	leaveq 
  8004203eef:	c3                   	retq   

0000008004203ef0 <tlb_invalidate>:
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
void
tlb_invalidate(pml4e_t *pml4e, void *va)
{
  8004203ef0:	55                   	push   %rbp
  8004203ef1:	48 89 e5             	mov    %rsp,%rbp
  8004203ef4:	48 83 ec 20          	sub    $0x20,%rsp
  8004203ef8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203efc:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Flush the entry only if we're modifying the current address space.

	assert(pml4e!=NULL);
  8004203f00:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203f05:	75 35                	jne    8004203f3c <tlb_invalidate+0x4c>
  8004203f07:	48 b9 f7 f3 21 04 80 	movabs $0x800421f3f7,%rcx
  8004203f0e:	00 00 00 
  8004203f11:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004203f18:	00 00 00 
  8004203f1b:	be 24 03 00 00       	mov    $0x324,%esi
  8004203f20:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004203f27:	00 00 00 
  8004203f2a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203f2f:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004203f36:	00 00 00 
  8004203f39:	41 ff d0             	callq  *%r8
	if (!curenv || curenv->env_pml4e == pml4e)
  8004203f3c:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  8004203f43:	00 00 00 
  8004203f46:	ff d0                	callq  *%rax
  8004203f48:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  8004203f4f:	00 00 00 
  8004203f52:	48 98                	cltq   
  8004203f54:	48 c1 e0 03          	shl    $0x3,%rax
  8004203f58:	48 89 c1             	mov    %rax,%rcx
  8004203f5b:	48 c1 e1 04          	shl    $0x4,%rcx
  8004203f5f:	48 01 c8             	add    %rcx,%rax
  8004203f62:	48 01 d0             	add    %rdx,%rax
  8004203f65:	48 83 c0 08          	add    $0x8,%rax
  8004203f69:	48 8b 00             	mov    (%rax),%rax
  8004203f6c:	48 85 c0             	test   %rax,%rax
  8004203f6f:	74 3d                	je     8004203fae <tlb_invalidate+0xbe>
  8004203f71:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  8004203f78:	00 00 00 
  8004203f7b:	ff d0                	callq  *%rax
  8004203f7d:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  8004203f84:	00 00 00 
  8004203f87:	48 98                	cltq   
  8004203f89:	48 c1 e0 03          	shl    $0x3,%rax
  8004203f8d:	48 89 c1             	mov    %rax,%rcx
  8004203f90:	48 c1 e1 04          	shl    $0x4,%rcx
  8004203f94:	48 01 c8             	add    %rcx,%rax
  8004203f97:	48 01 d0             	add    %rdx,%rax
  8004203f9a:	48 83 c0 08          	add    $0x8,%rax
  8004203f9e:	48 8b 00             	mov    (%rax),%rax
  8004203fa1:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004203fa8:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004203fac:	75 0f                	jne    8004203fbd <tlb_invalidate+0xcd>
  8004203fae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203fb2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void 
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
  8004203fb6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203fba:	0f 01 38             	invlpg (%rax)
		invlpg(va);

}
  8004203fbd:	90                   	nop
  8004203fbe:	c9                   	leaveq 
  8004203fbf:	c3                   	retq   

0000008004203fc0 <mmio_map_region>:
// location.  Return the base of the reserved region.  size does *not*
// have to be multiple of PGSIZE.
//
void *
mmio_map_region(physaddr_t pa, size_t size)
{
  8004203fc0:	55                   	push   %rbp
  8004203fc1:	48 89 e5             	mov    %rsp,%rbp
  8004203fc4:	48 83 ec 30          	sub    $0x30,%rsp
  8004203fc8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004203fcc:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	//
	// Hint: The staff solution uses boot_map_region.
	//
	// Your code here:

	uintptr_t va = base;
  8004203fd0:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  8004203fd7:	00 00 00 
  8004203fda:	48 8b 00             	mov    (%rax),%rax
  8004203fdd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	size = ROUNDUP(size, PGSIZE);
  8004203fe1:	48 c7 45 f0 00 10 00 	movq   $0x1000,-0x10(%rbp)
  8004203fe8:	00 
  8004203fe9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203fed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203ff1:	48 01 d0             	add    %rdx,%rax
  8004203ff4:	48 83 e8 01          	sub    $0x1,%rax
  8004203ff8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004203ffc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204000:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204005:	48 f7 75 f0          	divq   -0x10(%rbp)
  8004204009:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420400d:	48 29 d0             	sub    %rdx,%rax
  8004204010:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	base += size;
  8004204014:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  800420401b:	00 00 00 
  800420401e:	48 8b 10             	mov    (%rax),%rdx
  8004204021:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204025:	48 01 c2             	add    %rax,%rdx
  8004204028:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  800420402f:	00 00 00 
  8004204032:	48 89 10             	mov    %rdx,(%rax)
	if (base >= MMIOLIM)
  8004204035:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  800420403c:	00 00 00 
  800420403f:	48 8b 10             	mov    (%rax),%rdx
  8004204042:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004204049:	00 00 00 
  800420404c:	48 39 c2             	cmp    %rax,%rdx
  800420404f:	76 2a                	jbe    800420407b <mmio_map_region+0xbb>
		panic("MMIO mappings exceeded MMIOLIM");
  8004204051:	48 ba 08 f4 21 04 80 	movabs $0x800421f408,%rdx
  8004204058:	00 00 00 
  800420405b:	be 51 03 00 00       	mov    $0x351,%esi
  8004204060:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204067:	00 00 00 
  800420406a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420406f:	48 b9 f3 04 20 04 80 	movabs $0x80042004f3,%rcx
  8004204076:	00 00 00 
  8004204079:	ff d1                	callq  *%rcx
	boot_map_region(boot_pml4e, va, size, pa, PTE_P|PTE_W|PTE_PWT|PTE_PCD);
  800420407b:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004204082:	00 00 00 
  8004204085:	48 8b 00             	mov    (%rax),%rax
  8004204088:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420408c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204090:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8004204094:	41 b8 1b 00 00 00    	mov    $0x1b,%r8d
  800420409a:	48 89 c7             	mov    %rax,%rdi
  800420409d:	48 b8 99 37 20 04 80 	movabs $0x8004203799,%rax
  80042040a4:	00 00 00 
  80042040a7:	ff d0                	callq  *%rax
	return (void*) va;
  80042040a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax

}
  80042040ad:	c9                   	leaveq 
  80042040ae:	c3                   	retq   

00000080042040af <user_mem_check>:
// Returns 0 if the user program can access this range of addresses,
// and -E_FAULT otherwise.
//
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
  80042040af:	55                   	push   %rbp
  80042040b0:	48 89 e5             	mov    %rsp,%rbp
  80042040b3:	48 83 ec 40          	sub    $0x40,%rsp
  80042040b7:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042040bb:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042040bf:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80042040c3:	89 4d c4             	mov    %ecx,-0x3c(%rbp)

	const void *endva = (const void *) ((uintptr_t) va + len);
  80042040c6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042040ca:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042040ce:	48 01 d0             	add    %rdx,%rax
  80042040d1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	pte_t *ptep;
	if ((uintptr_t) endva >= ULIM || va > endva) {
  80042040d5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042040d9:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  80042040e0:	00 00 00 
  80042040e3:	48 39 c2             	cmp    %rax,%rdx
  80042040e6:	77 0e                	ja     80042040f6 <user_mem_check+0x47>
  80042040e8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042040ec:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042040f0:	0f 86 bd 00 00 00    	jbe    80042041b3 <user_mem_check+0x104>
		user_mem_check_addr = (uintptr_t) va;
  80042040f6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042040fa:	48 b8 40 d2 4d 04 80 	movabs $0x80044dd240,%rax
  8004204101:	00 00 00 
  8004204104:	48 89 10             	mov    %rdx,(%rax)
		return -E_FAULT;
  8004204107:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  800420410c:	e9 b5 00 00 00       	jmpq   80042041c6 <user_mem_check+0x117>
	}
	while(va<endva){
		ptep = pml4e_walk(env->env_pml4e,va,0);
  8004204111:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204115:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420411c:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8004204120:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204125:	48 89 ce             	mov    %rcx,%rsi
  8004204128:	48 89 c7             	mov    %rax,%rdi
  800420412b:	48 b8 73 30 20 04 80 	movabs $0x8004203073,%rax
  8004204132:	00 00 00 
  8004204135:	ff d0                	callq  *%rax
  8004204137:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if (!ptep || (*ptep & (perm | PTE_P)) != (perm | PTE_P)) {
  800420413b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004204140:	74 1f                	je     8004204161 <user_mem_check+0xb2>
  8004204142:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004204146:	48 8b 10             	mov    (%rax),%rdx
  8004204149:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420414c:	83 c8 01             	or     $0x1,%eax
  800420414f:	48 98                	cltq   
  8004204151:	48 21 c2             	and    %rax,%rdx
  8004204154:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004204157:	83 c8 01             	or     $0x1,%eax
  800420415a:	48 98                	cltq   
  800420415c:	48 39 c2             	cmp    %rax,%rdx
  800420415f:	74 18                	je     8004204179 <user_mem_check+0xca>
			user_mem_check_addr = (uintptr_t) va;
  8004204161:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204165:	48 b8 40 d2 4d 04 80 	movabs $0x80044dd240,%rax
  800420416c:	00 00 00 
  800420416f:	48 89 10             	mov    %rdx,(%rax)
			return -E_FAULT;
  8004204172:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8004204177:	eb 4d                	jmp    80042041c6 <user_mem_check+0x117>
		}
		va = ROUNDUP(va+1,PGSIZE);
  8004204179:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004204180:	00 
  8004204181:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204185:	48 83 c0 01          	add    $0x1,%rax
  8004204189:	48 89 c2             	mov    %rax,%rdx
  800420418c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204190:	48 01 d0             	add    %rdx,%rax
  8004204193:	48 83 e8 01          	sub    $0x1,%rax
  8004204197:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420419b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420419f:	ba 00 00 00 00       	mov    $0x0,%edx
  80042041a4:	48 f7 75 e8          	divq   -0x18(%rbp)
  80042041a8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042041ac:	48 29 d0             	sub    %rdx,%rax
  80042041af:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	pte_t *ptep;
	if ((uintptr_t) endva >= ULIM || va > endva) {
		user_mem_check_addr = (uintptr_t) va;
		return -E_FAULT;
	}
	while(va<endva){
  80042041b3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042041b7:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042041bb:	0f 82 50 ff ff ff    	jb     8004204111 <user_mem_check+0x62>
			return -E_FAULT;
		}
		va = ROUNDUP(va+1,PGSIZE);
	}

	return 0;
  80042041c1:	b8 00 00 00 00       	mov    $0x0,%eax

}
  80042041c6:	c9                   	leaveq 
  80042041c7:	c3                   	retq   

00000080042041c8 <user_mem_assert>:
// If it cannot, 'env' is destroyed and, if env is the current
// environment, this function will not return.
//
void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
  80042041c8:	55                   	push   %rbp
  80042041c9:	48 89 e5             	mov    %rsp,%rbp
  80042041cc:	48 83 ec 20          	sub    $0x20,%rsp
  80042041d0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80042041d4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80042041d8:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80042041dc:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
  80042041df:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042041e2:	83 c8 04             	or     $0x4,%eax
  80042041e5:	89 c1                	mov    %eax,%ecx
  80042041e7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042041eb:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042041ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042041f3:	48 89 c7             	mov    %rax,%rdi
  80042041f6:	48 b8 af 40 20 04 80 	movabs $0x80042040af,%rax
  80042041fd:	00 00 00 
  8004204200:	ff d0                	callq  *%rax
  8004204202:	85 c0                	test   %eax,%eax
  8004204204:	79 47                	jns    800420424d <user_mem_assert+0x85>
		cprintf("[%08x] user_mem_check assertion failure for "
  8004204206:	48 b8 40 d2 4d 04 80 	movabs $0x80044dd240,%rax
  800420420d:	00 00 00 
  8004204210:	48 8b 10             	mov    (%rax),%rdx
  8004204213:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204217:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420421d:	89 c6                	mov    %eax,%esi
  800420421f:	48 bf 28 f4 21 04 80 	movabs $0x800421f428,%rdi
  8004204226:	00 00 00 
  8004204229:	b8 00 00 00 00       	mov    $0x0,%eax
  800420422e:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  8004204235:	00 00 00 
  8004204238:	ff d1                	callq  *%rcx
			"va %08x\n", env->env_id, user_mem_check_addr);
		env_destroy(env);	// may not return
  800420423a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420423e:	48 89 c7             	mov    %rax,%rdi
  8004204241:	48 b8 9f 95 20 04 80 	movabs $0x800420959f,%rax
  8004204248:	00 00 00 
  800420424b:	ff d0                	callq  *%rax
	}
}
  800420424d:	90                   	nop
  800420424e:	c9                   	leaveq 
  800420424f:	c3                   	retq   

0000008004204250 <check_page_free_list>:
// Check that the pages on the page_free_list are reasonable.
//

static void
check_page_free_list(bool only_low_memory)
{
  8004204250:	55                   	push   %rbp
  8004204251:	48 89 e5             	mov    %rsp,%rbp
  8004204254:	48 83 ec 60          	sub    $0x60,%rsp
  8004204258:	89 f8                	mov    %edi,%eax
  800420425a:	88 45 ac             	mov    %al,-0x54(%rbp)
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
  800420425d:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004204261:	74 07                	je     800420426a <check_page_free_list+0x1a>
  8004204263:	b8 01 00 00 00       	mov    $0x1,%eax
  8004204268:	eb 05                	jmp    800420426f <check_page_free_list+0x1f>
  800420426a:	b8 00 02 00 00       	mov    $0x200,%eax
  800420426f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	uint64_t nfree_basemem = 0, nfree_extmem = 0;
  8004204272:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004204279:	00 
  800420427a:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204281:	00 
	char *first_free_page;

	if (!page_free_list)
  8004204282:	48 b8 38 d2 4d 04 80 	movabs $0x80044dd238,%rax
  8004204289:	00 00 00 
  800420428c:	48 8b 00             	mov    (%rax),%rax
  800420428f:	48 85 c0             	test   %rax,%rax
  8004204292:	75 2a                	jne    80042042be <check_page_free_list+0x6e>
		panic("'page_free_list' is a null pointer!");
  8004204294:	48 ba 60 f4 21 04 80 	movabs $0x800421f460,%rdx
  800420429b:	00 00 00 
  800420429e:	be a7 03 00 00       	mov    $0x3a7,%esi
  80042042a3:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042042aa:	00 00 00 
  80042042ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80042042b2:	48 b9 f3 04 20 04 80 	movabs $0x80042004f3,%rcx
  80042042b9:	00 00 00 
  80042042bc:	ff d1                	callq  *%rcx

	if (only_low_memory) {
  80042042be:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  80042042c2:	0f 84 a9 00 00 00    	je     8004204371 <check_page_free_list+0x121>
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
  80042042c8:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  80042042cc:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80042042d0:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  80042042d4:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042042d8:	48 b8 38 d2 4d 04 80 	movabs $0x80044dd238,%rax
  80042042df:	00 00 00 
  80042042e2:	48 8b 00             	mov    (%rax),%rax
  80042042e5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042042e9:	eb 58                	jmp    8004204343 <check_page_free_list+0xf3>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
  80042042eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042042ef:	48 89 c7             	mov    %rax,%rdi
  80042042f2:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  80042042f9:	00 00 00 
  80042042fc:	ff d0                	callq  *%rax
  80042042fe:	48 c1 e8 15          	shr    $0x15,%rax
  8004204302:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204307:	48 89 c2             	mov    %rax,%rdx
  800420430a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420430d:	48 39 c2             	cmp    %rax,%rdx
  8004204310:	0f 93 c0             	setae  %al
  8004204313:	0f b6 c0             	movzbl %al,%eax
  8004204316:	89 45 e0             	mov    %eax,-0x20(%rbp)
			*tp[pagetype] = pp;
  8004204319:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800420431c:	48 98                	cltq   
  800420431e:	48 8b 44 c5 b0       	mov    -0x50(%rbp,%rax,8),%rax
  8004204323:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204327:	48 89 10             	mov    %rdx,(%rax)
			tp[pagetype] = &pp->pp_link;
  800420432a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420432e:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004204331:	48 98                	cltq   
  8004204333:	48 89 54 c5 b0       	mov    %rdx,-0x50(%rbp,%rax,8)
	if (only_low_memory) {
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004204338:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420433c:	48 8b 00             	mov    (%rax),%rax
  800420433f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204343:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204348:	75 a1                	jne    80042042eb <check_page_free_list+0x9b>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
			*tp[pagetype] = pp;
			tp[pagetype] = &pp->pp_link;
		}
		*tp[1] = 0;
  800420434a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420434e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		*tp[0] = pp2;
  8004204355:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004204359:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420435d:	48 89 10             	mov    %rdx,(%rax)
		page_free_list = pp1;
  8004204360:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204364:	48 b8 38 d2 4d 04 80 	movabs $0x80044dd238,%rax
  800420436b:	00 00 00 
  800420436e:	48 89 10             	mov    %rdx,(%rax)
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004204371:	48 b8 38 d2 4d 04 80 	movabs $0x80044dd238,%rax
  8004204378:	00 00 00 
  800420437b:	48 8b 00             	mov    (%rax),%rax
  800420437e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204382:	eb 5e                	jmp    80042043e2 <check_page_free_list+0x192>
		if (PDX(page2pa(pp)) < pdx_limit)
  8004204384:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204388:	48 89 c7             	mov    %rax,%rdi
  800420438b:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  8004204392:	00 00 00 
  8004204395:	ff d0                	callq  *%rax
  8004204397:	48 c1 e8 15          	shr    $0x15,%rax
  800420439b:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042043a0:	48 89 c2             	mov    %rax,%rdx
  80042043a3:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042043a6:	48 39 c2             	cmp    %rax,%rdx
  80042043a9:	73 2c                	jae    80042043d7 <check_page_free_list+0x187>
			memset(page2kva(pp), 0x97, 128);
  80042043ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042043af:	48 89 c7             	mov    %rax,%rdi
  80042043b2:	48 b8 20 1c 20 04 80 	movabs $0x8004201c20,%rax
  80042043b9:	00 00 00 
  80042043bc:	ff d0                	callq  *%rax
  80042043be:	ba 80 00 00 00       	mov    $0x80,%edx
  80042043c3:	be 97 00 00 00       	mov    $0x97,%esi
  80042043c8:	48 89 c7             	mov    %rax,%rdi
  80042043cb:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  80042043d2:	00 00 00 
  80042043d5:	ff d0                	callq  *%rax
		page_free_list = pp1;
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  80042043d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042043db:	48 8b 00             	mov    (%rax),%rax
  80042043de:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042043e2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042043e7:	75 9b                	jne    8004204384 <check_page_free_list+0x134>
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
  80042043e9:	bf 00 00 00 00       	mov    $0x0,%edi
  80042043ee:	48 b8 47 25 20 04 80 	movabs $0x8004202547,%rax
  80042043f5:	00 00 00 
  80042043f8:	ff d0                	callq  *%rax
  80042043fa:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042043fe:	48 b8 38 d2 4d 04 80 	movabs $0x80044dd238,%rax
  8004204405:	00 00 00 
  8004204408:	48 8b 00             	mov    (%rax),%rax
  800420440b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420440f:	e9 20 03 00 00       	jmpq   8004204734 <check_page_free_list+0x4e4>
		// check that we didn't corrupt the free list itself
		assert(pp >= pages);
  8004204414:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  800420441b:	00 00 00 
  800420441e:	48 8b 00             	mov    (%rax),%rax
  8004204421:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004204425:	73 35                	jae    800420445c <check_page_free_list+0x20c>
  8004204427:	48 b9 84 f4 21 04 80 	movabs $0x800421f484,%rcx
  800420442e:	00 00 00 
  8004204431:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204438:	00 00 00 
  800420443b:	be c1 03 00 00       	mov    $0x3c1,%esi
  8004204440:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204447:	00 00 00 
  800420444a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420444f:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204456:	00 00 00 
  8004204459:	41 ff d0             	callq  *%r8
		assert(pp < pages + npages);
  800420445c:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  8004204463:	00 00 00 
  8004204466:	48 8b 10             	mov    (%rax),%rdx
  8004204469:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004204470:	00 00 00 
  8004204473:	48 8b 00             	mov    (%rax),%rax
  8004204476:	48 c1 e0 04          	shl    $0x4,%rax
  800420447a:	48 01 d0             	add    %rdx,%rax
  800420447d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204481:	77 35                	ja     80042044b8 <check_page_free_list+0x268>
  8004204483:	48 b9 90 f4 21 04 80 	movabs $0x800421f490,%rcx
  800420448a:	00 00 00 
  800420448d:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204494:	00 00 00 
  8004204497:	be c2 03 00 00       	mov    $0x3c2,%esi
  800420449c:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042044a3:	00 00 00 
  80042044a6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042044ab:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042044b2:	00 00 00 
  80042044b5:	41 ff d0             	callq  *%r8
		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
  80042044b8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042044bc:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  80042044c3:	00 00 00 
  80042044c6:	48 8b 00             	mov    (%rax),%rax
  80042044c9:	48 29 c2             	sub    %rax,%rdx
  80042044cc:	48 89 d0             	mov    %rdx,%rax
  80042044cf:	83 e0 0f             	and    $0xf,%eax
  80042044d2:	48 85 c0             	test   %rax,%rax
  80042044d5:	74 35                	je     800420450c <check_page_free_list+0x2bc>
  80042044d7:	48 b9 a8 f4 21 04 80 	movabs $0x800421f4a8,%rcx
  80042044de:	00 00 00 
  80042044e1:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042044e8:	00 00 00 
  80042044eb:	be c3 03 00 00       	mov    $0x3c3,%esi
  80042044f0:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042044f7:	00 00 00 
  80042044fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042044ff:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204506:	00 00 00 
  8004204509:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp) != 0);
  800420450c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204510:	48 89 c7             	mov    %rax,%rdi
  8004204513:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  800420451a:	00 00 00 
  800420451d:	ff d0                	callq  *%rax
  800420451f:	48 85 c0             	test   %rax,%rax
  8004204522:	75 35                	jne    8004204559 <check_page_free_list+0x309>
  8004204524:	48 b9 da f4 21 04 80 	movabs $0x800421f4da,%rcx
  800420452b:	00 00 00 
  800420452e:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204535:	00 00 00 
  8004204538:	be c6 03 00 00       	mov    $0x3c6,%esi
  800420453d:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204544:	00 00 00 
  8004204547:	b8 00 00 00 00       	mov    $0x0,%eax
  800420454c:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204553:	00 00 00 
  8004204556:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != IOPHYSMEM);
  8004204559:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420455d:	48 89 c7             	mov    %rax,%rdi
  8004204560:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  8004204567:	00 00 00 
  800420456a:	ff d0                	callq  *%rax
  800420456c:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004204572:	75 35                	jne    80042045a9 <check_page_free_list+0x359>
  8004204574:	48 b9 eb f4 21 04 80 	movabs $0x800421f4eb,%rcx
  800420457b:	00 00 00 
  800420457e:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204585:	00 00 00 
  8004204588:	be c7 03 00 00       	mov    $0x3c7,%esi
  800420458d:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204594:	00 00 00 
  8004204597:	b8 00 00 00 00       	mov    $0x0,%eax
  800420459c:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042045a3:	00 00 00 
  80042045a6:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
  80042045a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042045ad:	48 89 c7             	mov    %rax,%rdi
  80042045b0:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  80042045b7:	00 00 00 
  80042045ba:	ff d0                	callq  *%rax
  80042045bc:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  80042045c2:	75 35                	jne    80042045f9 <check_page_free_list+0x3a9>
  80042045c4:	48 b9 08 f5 21 04 80 	movabs $0x800421f508,%rcx
  80042045cb:	00 00 00 
  80042045ce:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042045d5:	00 00 00 
  80042045d8:	be c8 03 00 00       	mov    $0x3c8,%esi
  80042045dd:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042045e4:	00 00 00 
  80042045e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045ec:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042045f3:	00 00 00 
  80042045f6:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM);
  80042045f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042045fd:	48 89 c7             	mov    %rax,%rdi
  8004204600:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  8004204607:	00 00 00 
  800420460a:	ff d0                	callq  *%rax
  800420460c:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004204612:	75 35                	jne    8004204649 <check_page_free_list+0x3f9>
  8004204614:	48 b9 2b f5 21 04 80 	movabs $0x800421f52b,%rcx
  800420461b:	00 00 00 
  800420461e:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204625:	00 00 00 
  8004204628:	be c9 03 00 00       	mov    $0x3c9,%esi
  800420462d:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204634:	00 00 00 
  8004204637:	b8 00 00 00 00       	mov    $0x0,%eax
  800420463c:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204643:	00 00 00 
  8004204646:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
  8004204649:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420464d:	48 89 c7             	mov    %rax,%rdi
  8004204650:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  8004204657:	00 00 00 
  800420465a:	ff d0                	callq  *%rax
  800420465c:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004204662:	76 4e                	jbe    80042046b2 <check_page_free_list+0x462>
  8004204664:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204668:	48 89 c7             	mov    %rax,%rdi
  800420466b:	48 b8 20 1c 20 04 80 	movabs $0x8004201c20,%rax
  8004204672:	00 00 00 
  8004204675:	ff d0                	callq  *%rax
  8004204677:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420467b:	73 35                	jae    80042046b2 <check_page_free_list+0x462>
  800420467d:	48 b9 48 f5 21 04 80 	movabs $0x800421f548,%rcx
  8004204684:	00 00 00 
  8004204687:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  800420468e:	00 00 00 
  8004204691:	be ca 03 00 00       	mov    $0x3ca,%esi
  8004204696:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  800420469d:	00 00 00 
  80042046a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042046a5:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042046ac:	00 00 00 
  80042046af:	41 ff d0             	callq  *%r8

		// (new test for lab 4)
		assert(page2pa(pp) != MPENTRY_PADDR);
  80042046b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042046b6:	48 89 c7             	mov    %rax,%rdi
  80042046b9:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  80042046c0:	00 00 00 
  80042046c3:	ff d0                	callq  *%rax
  80042046c5:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  80042046cb:	75 35                	jne    8004204702 <check_page_free_list+0x4b2>
  80042046cd:	48 b9 8d f5 21 04 80 	movabs $0x800421f58d,%rcx
  80042046d4:	00 00 00 
  80042046d7:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042046de:	00 00 00 
  80042046e1:	be cd 03 00 00       	mov    $0x3cd,%esi
  80042046e6:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042046ed:	00 00 00 
  80042046f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042046f5:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042046fc:	00 00 00 
  80042046ff:	41 ff d0             	callq  *%r8


		if (page2pa(pp) < EXTPHYSMEM)
  8004204702:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204706:	48 89 c7             	mov    %rax,%rdi
  8004204709:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  8004204710:	00 00 00 
  8004204713:	ff d0                	callq  *%rax
  8004204715:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  800420471b:	77 07                	ja     8004204724 <check_page_free_list+0x4d4>
			++nfree_basemem;
  800420471d:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004204722:	eb 05                	jmp    8004204729 <check_page_free_list+0x4d9>
		else
			++nfree_extmem;
  8004204724:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link)
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004204729:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420472d:	48 8b 00             	mov    (%rax),%rax
  8004204730:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204734:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204739:	0f 85 d5 fc ff ff    	jne    8004204414 <check_page_free_list+0x1c4>
			++nfree_basemem;
		else
			++nfree_extmem;
	}

	assert(nfree_extmem > 0);
  800420473f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204744:	75 35                	jne    800420477b <check_page_free_list+0x52b>
  8004204746:	48 b9 aa f5 21 04 80 	movabs $0x800421f5aa,%rcx
  800420474d:	00 00 00 
  8004204750:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204757:	00 00 00 
  800420475a:	be d6 03 00 00       	mov    $0x3d6,%esi
  800420475f:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204766:	00 00 00 
  8004204769:	b8 00 00 00 00       	mov    $0x0,%eax
  800420476e:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204775:	00 00 00 
  8004204778:	41 ff d0             	callq  *%r8
}
  800420477b:	90                   	nop
  800420477c:	c9                   	leaveq 
  800420477d:	c3                   	retq   

000000800420477e <check_page_alloc>:
// Check the physical page allocator (page_alloc(), page_free(),
// and page_init()).
//
static void
check_page_alloc(void)
{
  800420477e:	55                   	push   %rbp
  800420477f:	48 89 e5             	mov    %rsp,%rbp
  8004204782:	48 83 ec 40          	sub    $0x40,%rsp
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204786:	48 b8 38 d2 4d 04 80 	movabs $0x80044dd238,%rax
  800420478d:	00 00 00 
  8004204790:	48 8b 00             	mov    (%rax),%rax
  8004204793:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204797:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  800420479e:	eb 37                	jmp    80042047d7 <check_page_alloc+0x59>
		memset(page2kva(pp0), 0x97, PGSIZE);
  80042047a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042047a4:	48 89 c7             	mov    %rax,%rdi
  80042047a7:	48 b8 20 1c 20 04 80 	movabs $0x8004201c20,%rax
  80042047ae:	00 00 00 
  80042047b1:	ff d0                	callq  *%rax
  80042047b3:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042047b8:	be 97 00 00 00       	mov    $0x97,%esi
  80042047bd:	48 89 c7             	mov    %rax,%rdi
  80042047c0:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  80042047c7:	00 00 00 
  80042047ca:	ff d0                	callq  *%rax
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  80042047cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042047d0:	48 8b 00             	mov    (%rax),%rax
  80042047d3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042047d7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042047dc:	75 c2                	jne    80042047a0 <check_page_alloc+0x22>
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  80042047de:	48 b8 38 d2 4d 04 80 	movabs $0x80044dd238,%rax
  80042047e5:	00 00 00 
  80042047e8:	48 8b 00             	mov    (%rax),%rax
  80042047eb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042047ef:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  80042047f6:	e9 ec 01 00 00       	jmpq   80042049e7 <check_page_alloc+0x269>
		// check that we didn't corrupt the free list itself
		assert(pp0 >= pages);
  80042047fb:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  8004204802:	00 00 00 
  8004204805:	48 8b 00             	mov    (%rax),%rax
  8004204808:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800420480c:	73 35                	jae    8004204843 <check_page_alloc+0xc5>
  800420480e:	48 b9 bb f5 21 04 80 	movabs $0x800421f5bb,%rcx
  8004204815:	00 00 00 
  8004204818:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  800420481f:	00 00 00 
  8004204822:	be f0 03 00 00       	mov    $0x3f0,%esi
  8004204827:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  800420482e:	00 00 00 
  8004204831:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204836:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420483d:	00 00 00 
  8004204840:	41 ff d0             	callq  *%r8
		assert(pp0 < pages + npages);
  8004204843:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  800420484a:	00 00 00 
  800420484d:	48 8b 10             	mov    (%rax),%rdx
  8004204850:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004204857:	00 00 00 
  800420485a:	48 8b 00             	mov    (%rax),%rax
  800420485d:	48 c1 e0 04          	shl    $0x4,%rax
  8004204861:	48 01 d0             	add    %rdx,%rax
  8004204864:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204868:	77 35                	ja     800420489f <check_page_alloc+0x121>
  800420486a:	48 b9 c8 f5 21 04 80 	movabs $0x800421f5c8,%rcx
  8004204871:	00 00 00 
  8004204874:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  800420487b:	00 00 00 
  800420487e:	be f1 03 00 00       	mov    $0x3f1,%esi
  8004204883:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  800420488a:	00 00 00 
  800420488d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204892:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204899:	00 00 00 
  800420489c:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp0) != 0);
  800420489f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042048a3:	48 89 c7             	mov    %rax,%rdi
  80042048a6:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  80042048ad:	00 00 00 
  80042048b0:	ff d0                	callq  *%rax
  80042048b2:	48 85 c0             	test   %rax,%rax
  80042048b5:	75 35                	jne    80042048ec <check_page_alloc+0x16e>
  80042048b7:	48 b9 dd f5 21 04 80 	movabs $0x800421f5dd,%rcx
  80042048be:	00 00 00 
  80042048c1:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042048c8:	00 00 00 
  80042048cb:	be f4 03 00 00       	mov    $0x3f4,%esi
  80042048d0:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042048d7:	00 00 00 
  80042048da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042048df:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042048e6:	00 00 00 
  80042048e9:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != IOPHYSMEM);
  80042048ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042048f0:	48 89 c7             	mov    %rax,%rdi
  80042048f3:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  80042048fa:	00 00 00 
  80042048fd:	ff d0                	callq  *%rax
  80042048ff:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004204905:	75 35                	jne    800420493c <check_page_alloc+0x1be>
  8004204907:	48 b9 ef f5 21 04 80 	movabs $0x800421f5ef,%rcx
  800420490e:	00 00 00 
  8004204911:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204918:	00 00 00 
  800420491b:	be f5 03 00 00       	mov    $0x3f5,%esi
  8004204920:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204927:	00 00 00 
  800420492a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420492f:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204936:	00 00 00 
  8004204939:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
  800420493c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204940:	48 89 c7             	mov    %rax,%rdi
  8004204943:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  800420494a:	00 00 00 
  800420494d:	ff d0                	callq  *%rax
  800420494f:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004204955:	75 35                	jne    800420498c <check_page_alloc+0x20e>
  8004204957:	48 b9 10 f6 21 04 80 	movabs $0x800421f610,%rcx
  800420495e:	00 00 00 
  8004204961:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204968:	00 00 00 
  800420496b:	be f6 03 00 00       	mov    $0x3f6,%esi
  8004204970:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204977:	00 00 00 
  800420497a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420497f:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204986:	00 00 00 
  8004204989:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM);
  800420498c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204990:	48 89 c7             	mov    %rax,%rdi
  8004204993:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  800420499a:	00 00 00 
  800420499d:	ff d0                	callq  *%rax
  800420499f:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  80042049a5:	75 35                	jne    80042049dc <check_page_alloc+0x25e>
  80042049a7:	48 b9 34 f6 21 04 80 	movabs $0x800421f634,%rcx
  80042049ae:	00 00 00 
  80042049b1:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042049b8:	00 00 00 
  80042049bb:	be f7 03 00 00       	mov    $0x3f7,%esi
  80042049c0:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042049c7:	00 00 00 
  80042049ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80042049cf:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042049d6:	00 00 00 
  80042049d9:	41 ff d0             	callq  *%r8
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  80042049dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042049e0:	48 8b 00             	mov    (%rax),%rax
  80042049e3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042049e7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042049ec:	0f 85 09 fe ff ff    	jne    80042047fb <check_page_alloc+0x7d>
		assert(page2pa(pp0) != IOPHYSMEM);
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
		assert(page2pa(pp0) != EXTPHYSMEM);
	}
	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
  80042049f2:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042049f9:	00 
  80042049fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042049fe:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204a02:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204a06:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004204a0a:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204a0f:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004204a16:	00 00 00 
  8004204a19:	ff d0                	callq  *%rax
  8004204a1b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204a1f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204a24:	75 35                	jne    8004204a5b <check_page_alloc+0x2dd>
  8004204a26:	48 b9 4f f6 21 04 80 	movabs $0x800421f64f,%rcx
  8004204a2d:	00 00 00 
  8004204a30:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204a37:	00 00 00 
  8004204a3a:	be fb 03 00 00       	mov    $0x3fb,%esi
  8004204a3f:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204a46:	00 00 00 
  8004204a49:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a4e:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204a55:	00 00 00 
  8004204a58:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004204a5b:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204a60:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004204a67:	00 00 00 
  8004204a6a:	ff d0                	callq  *%rax
  8004204a6c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204a70:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204a75:	75 35                	jne    8004204aac <check_page_alloc+0x32e>
  8004204a77:	48 b9 65 f6 21 04 80 	movabs $0x800421f665,%rcx
  8004204a7e:	00 00 00 
  8004204a81:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204a88:	00 00 00 
  8004204a8b:	be fc 03 00 00       	mov    $0x3fc,%esi
  8004204a90:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204a97:	00 00 00 
  8004204a9a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a9f:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204aa6:	00 00 00 
  8004204aa9:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004204aac:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204ab1:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004204ab8:	00 00 00 
  8004204abb:	ff d0                	callq  *%rax
  8004204abd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204ac1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204ac6:	75 35                	jne    8004204afd <check_page_alloc+0x37f>
  8004204ac8:	48 b9 7b f6 21 04 80 	movabs $0x800421f67b,%rcx
  8004204acf:	00 00 00 
  8004204ad2:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204ad9:	00 00 00 
  8004204adc:	be fd 03 00 00       	mov    $0x3fd,%esi
  8004204ae1:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204ae8:	00 00 00 
  8004204aeb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204af0:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204af7:	00 00 00 
  8004204afa:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204afd:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204b02:	75 35                	jne    8004204b39 <check_page_alloc+0x3bb>
  8004204b04:	48 b9 91 f6 21 04 80 	movabs $0x800421f691,%rcx
  8004204b0b:	00 00 00 
  8004204b0e:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204b15:	00 00 00 
  8004204b18:	be fe 03 00 00       	mov    $0x3fe,%esi
  8004204b1d:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204b24:	00 00 00 
  8004204b27:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b2c:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204b33:	00 00 00 
  8004204b36:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204b39:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204b3e:	74 0a                	je     8004204b4a <check_page_alloc+0x3cc>
  8004204b40:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204b44:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204b48:	75 35                	jne    8004204b7f <check_page_alloc+0x401>
  8004204b4a:	48 b9 95 f6 21 04 80 	movabs $0x800421f695,%rcx
  8004204b51:	00 00 00 
  8004204b54:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204b5b:	00 00 00 
  8004204b5e:	be ff 03 00 00       	mov    $0x3ff,%esi
  8004204b63:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204b6a:	00 00 00 
  8004204b6d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b72:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204b79:	00 00 00 
  8004204b7c:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204b7f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204b84:	74 14                	je     8004204b9a <check_page_alloc+0x41c>
  8004204b86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204b8a:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204b8e:	74 0a                	je     8004204b9a <check_page_alloc+0x41c>
  8004204b90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204b94:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204b98:	75 35                	jne    8004204bcf <check_page_alloc+0x451>
  8004204b9a:	48 b9 a8 f6 21 04 80 	movabs $0x800421f6a8,%rcx
  8004204ba1:	00 00 00 
  8004204ba4:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204bab:	00 00 00 
  8004204bae:	be 00 04 00 00       	mov    $0x400,%esi
  8004204bb3:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204bba:	00 00 00 
  8004204bbd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204bc2:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204bc9:	00 00 00 
  8004204bcc:	41 ff d0             	callq  *%r8
	assert(page2pa(pp0) < npages*PGSIZE);
  8004204bcf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204bd3:	48 89 c7             	mov    %rax,%rdi
  8004204bd6:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  8004204bdd:	00 00 00 
  8004204be0:	ff d0                	callq  *%rax
  8004204be2:	48 89 c2             	mov    %rax,%rdx
  8004204be5:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004204bec:	00 00 00 
  8004204bef:	48 8b 00             	mov    (%rax),%rax
  8004204bf2:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204bf6:	48 39 c2             	cmp    %rax,%rdx
  8004204bf9:	72 35                	jb     8004204c30 <check_page_alloc+0x4b2>
  8004204bfb:	48 b9 c8 f6 21 04 80 	movabs $0x800421f6c8,%rcx
  8004204c02:	00 00 00 
  8004204c05:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204c0c:	00 00 00 
  8004204c0f:	be 01 04 00 00       	mov    $0x401,%esi
  8004204c14:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204c1b:	00 00 00 
  8004204c1e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c23:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204c2a:	00 00 00 
  8004204c2d:	41 ff d0             	callq  *%r8
	assert(page2pa(pp1) < npages*PGSIZE);
  8004204c30:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204c34:	48 89 c7             	mov    %rax,%rdi
  8004204c37:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  8004204c3e:	00 00 00 
  8004204c41:	ff d0                	callq  *%rax
  8004204c43:	48 89 c2             	mov    %rax,%rdx
  8004204c46:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004204c4d:	00 00 00 
  8004204c50:	48 8b 00             	mov    (%rax),%rax
  8004204c53:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204c57:	48 39 c2             	cmp    %rax,%rdx
  8004204c5a:	72 35                	jb     8004204c91 <check_page_alloc+0x513>
  8004204c5c:	48 b9 e5 f6 21 04 80 	movabs $0x800421f6e5,%rcx
  8004204c63:	00 00 00 
  8004204c66:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204c6d:	00 00 00 
  8004204c70:	be 02 04 00 00       	mov    $0x402,%esi
  8004204c75:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204c7c:	00 00 00 
  8004204c7f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c84:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204c8b:	00 00 00 
  8004204c8e:	41 ff d0             	callq  *%r8
	assert(page2pa(pp2) < npages*PGSIZE);
  8004204c91:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204c95:	48 89 c7             	mov    %rax,%rdi
  8004204c98:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  8004204c9f:	00 00 00 
  8004204ca2:	ff d0                	callq  *%rax
  8004204ca4:	48 89 c2             	mov    %rax,%rdx
  8004204ca7:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004204cae:	00 00 00 
  8004204cb1:	48 8b 00             	mov    (%rax),%rax
  8004204cb4:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204cb8:	48 39 c2             	cmp    %rax,%rdx
  8004204cbb:	72 35                	jb     8004204cf2 <check_page_alloc+0x574>
  8004204cbd:	48 b9 02 f7 21 04 80 	movabs $0x800421f702,%rcx
  8004204cc4:	00 00 00 
  8004204cc7:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204cce:	00 00 00 
  8004204cd1:	be 03 04 00 00       	mov    $0x403,%esi
  8004204cd6:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204cdd:	00 00 00 
  8004204ce0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ce5:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204cec:	00 00 00 
  8004204cef:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004204cf2:	48 b8 38 d2 4d 04 80 	movabs $0x80044dd238,%rax
  8004204cf9:	00 00 00 
  8004204cfc:	48 8b 00             	mov    (%rax),%rax
  8004204cff:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	page_free_list = 0;
  8004204d03:	48 b8 38 d2 4d 04 80 	movabs $0x80044dd238,%rax
  8004204d0a:	00 00 00 
  8004204d0d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004204d14:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204d19:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004204d20:	00 00 00 
  8004204d23:	ff d0                	callq  *%rax
  8004204d25:	48 85 c0             	test   %rax,%rax
  8004204d28:	74 35                	je     8004204d5f <check_page_alloc+0x5e1>
  8004204d2a:	48 b9 1f f7 21 04 80 	movabs $0x800421f71f,%rcx
  8004204d31:	00 00 00 
  8004204d34:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204d3b:	00 00 00 
  8004204d3e:	be 0a 04 00 00       	mov    $0x40a,%esi
  8004204d43:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204d4a:	00 00 00 
  8004204d4d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d52:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204d59:	00 00 00 
  8004204d5c:	41 ff d0             	callq  *%r8

	// free and re-allocate?
	page_free(pp0);
  8004204d5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204d63:	48 89 c7             	mov    %rax,%rdi
  8004204d66:	48 b8 af 2f 20 04 80 	movabs $0x8004202faf,%rax
  8004204d6d:	00 00 00 
  8004204d70:	ff d0                	callq  *%rax
	page_free(pp1);
  8004204d72:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204d76:	48 89 c7             	mov    %rax,%rdi
  8004204d79:	48 b8 af 2f 20 04 80 	movabs $0x8004202faf,%rax
  8004204d80:	00 00 00 
  8004204d83:	ff d0                	callq  *%rax
	page_free(pp2);
  8004204d85:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204d89:	48 89 c7             	mov    %rax,%rdi
  8004204d8c:	48 b8 af 2f 20 04 80 	movabs $0x8004202faf,%rax
  8004204d93:	00 00 00 
  8004204d96:	ff d0                	callq  *%rax
	pp0 = pp1 = pp2 = 0;
  8004204d98:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204d9f:	00 
  8004204da0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204da4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204da8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204dac:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004204db0:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204db5:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004204dbc:	00 00 00 
  8004204dbf:	ff d0                	callq  *%rax
  8004204dc1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204dc5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204dca:	75 35                	jne    8004204e01 <check_page_alloc+0x683>
  8004204dcc:	48 b9 4f f6 21 04 80 	movabs $0x800421f64f,%rcx
  8004204dd3:	00 00 00 
  8004204dd6:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204ddd:	00 00 00 
  8004204de0:	be 11 04 00 00       	mov    $0x411,%esi
  8004204de5:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204dec:	00 00 00 
  8004204def:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204df4:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204dfb:	00 00 00 
  8004204dfe:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004204e01:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204e06:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004204e0d:	00 00 00 
  8004204e10:	ff d0                	callq  *%rax
  8004204e12:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204e16:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204e1b:	75 35                	jne    8004204e52 <check_page_alloc+0x6d4>
  8004204e1d:	48 b9 65 f6 21 04 80 	movabs $0x800421f665,%rcx
  8004204e24:	00 00 00 
  8004204e27:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204e2e:	00 00 00 
  8004204e31:	be 12 04 00 00       	mov    $0x412,%esi
  8004204e36:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204e3d:	00 00 00 
  8004204e40:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e45:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204e4c:	00 00 00 
  8004204e4f:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004204e52:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204e57:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004204e5e:	00 00 00 
  8004204e61:	ff d0                	callq  *%rax
  8004204e63:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204e67:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204e6c:	75 35                	jne    8004204ea3 <check_page_alloc+0x725>
  8004204e6e:	48 b9 7b f6 21 04 80 	movabs $0x800421f67b,%rcx
  8004204e75:	00 00 00 
  8004204e78:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204e7f:	00 00 00 
  8004204e82:	be 13 04 00 00       	mov    $0x413,%esi
  8004204e87:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204e8e:	00 00 00 
  8004204e91:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e96:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204e9d:	00 00 00 
  8004204ea0:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204ea3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204ea8:	75 35                	jne    8004204edf <check_page_alloc+0x761>
  8004204eaa:	48 b9 91 f6 21 04 80 	movabs $0x800421f691,%rcx
  8004204eb1:	00 00 00 
  8004204eb4:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204ebb:	00 00 00 
  8004204ebe:	be 14 04 00 00       	mov    $0x414,%esi
  8004204ec3:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204eca:	00 00 00 
  8004204ecd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ed2:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204ed9:	00 00 00 
  8004204edc:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204edf:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204ee4:	74 0a                	je     8004204ef0 <check_page_alloc+0x772>
  8004204ee6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204eea:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204eee:	75 35                	jne    8004204f25 <check_page_alloc+0x7a7>
  8004204ef0:	48 b9 95 f6 21 04 80 	movabs $0x800421f695,%rcx
  8004204ef7:	00 00 00 
  8004204efa:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204f01:	00 00 00 
  8004204f04:	be 15 04 00 00       	mov    $0x415,%esi
  8004204f09:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204f10:	00 00 00 
  8004204f13:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f18:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204f1f:	00 00 00 
  8004204f22:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204f25:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204f2a:	74 14                	je     8004204f40 <check_page_alloc+0x7c2>
  8004204f2c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204f30:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204f34:	74 0a                	je     8004204f40 <check_page_alloc+0x7c2>
  8004204f36:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204f3a:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204f3e:	75 35                	jne    8004204f75 <check_page_alloc+0x7f7>
  8004204f40:	48 b9 a8 f6 21 04 80 	movabs $0x800421f6a8,%rcx
  8004204f47:	00 00 00 
  8004204f4a:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204f51:	00 00 00 
  8004204f54:	be 16 04 00 00       	mov    $0x416,%esi
  8004204f59:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204f60:	00 00 00 
  8004204f63:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f68:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204f6f:	00 00 00 
  8004204f72:	41 ff d0             	callq  *%r8
	assert(!page_alloc(0));
  8004204f75:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204f7a:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004204f81:	00 00 00 
  8004204f84:	ff d0                	callq  *%rax
  8004204f86:	48 85 c0             	test   %rax,%rax
  8004204f89:	74 35                	je     8004204fc0 <check_page_alloc+0x842>
  8004204f8b:	48 b9 1f f7 21 04 80 	movabs $0x800421f71f,%rcx
  8004204f92:	00 00 00 
  8004204f95:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004204f9c:	00 00 00 
  8004204f9f:	be 17 04 00 00       	mov    $0x417,%esi
  8004204fa4:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004204fab:	00 00 00 
  8004204fae:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204fb3:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004204fba:	00 00 00 
  8004204fbd:	41 ff d0             	callq  *%r8

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
  8004204fc0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204fc4:	48 89 c7             	mov    %rax,%rdi
  8004204fc7:	48 b8 20 1c 20 04 80 	movabs $0x8004201c20,%rax
  8004204fce:	00 00 00 
  8004204fd1:	ff d0                	callq  *%rax
  8004204fd3:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204fd8:	be 01 00 00 00       	mov    $0x1,%esi
  8004204fdd:	48 89 c7             	mov    %rax,%rdi
  8004204fe0:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  8004204fe7:	00 00 00 
  8004204fea:	ff d0                	callq  *%rax
	page_free(pp0);
  8004204fec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204ff0:	48 89 c7             	mov    %rax,%rdi
  8004204ff3:	48 b8 af 2f 20 04 80 	movabs $0x8004202faf,%rax
  8004204ffa:	00 00 00 
  8004204ffd:	ff d0                	callq  *%rax
	assert((pp = page_alloc(ALLOC_ZERO)));
  8004204fff:	bf 01 00 00 00       	mov    $0x1,%edi
  8004205004:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  800420500b:	00 00 00 
  800420500e:	ff d0                	callq  *%rax
  8004205010:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004205014:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205019:	75 35                	jne    8004205050 <check_page_alloc+0x8d2>
  800420501b:	48 b9 2e f7 21 04 80 	movabs $0x800421f72e,%rcx
  8004205022:	00 00 00 
  8004205025:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  800420502c:	00 00 00 
  800420502f:	be 1c 04 00 00       	mov    $0x41c,%esi
  8004205034:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  800420503b:	00 00 00 
  800420503e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205043:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420504a:	00 00 00 
  800420504d:	41 ff d0             	callq  *%r8
	assert(pp && pp0 == pp);
  8004205050:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205055:	74 0a                	je     8004205061 <check_page_alloc+0x8e3>
  8004205057:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420505b:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420505f:	74 35                	je     8004205096 <check_page_alloc+0x918>
  8004205061:	48 b9 4c f7 21 04 80 	movabs $0x800421f74c,%rcx
  8004205068:	00 00 00 
  800420506b:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004205072:	00 00 00 
  8004205075:	be 1d 04 00 00       	mov    $0x41d,%esi
  800420507a:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205081:	00 00 00 
  8004205084:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205089:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205090:	00 00 00 
  8004205093:	41 ff d0             	callq  *%r8
	c = page2kva(pp);
  8004205096:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420509a:	48 89 c7             	mov    %rax,%rdi
  800420509d:	48 b8 20 1c 20 04 80 	movabs $0x8004201c20,%rax
  80042050a4:	00 00 00 
  80042050a7:	ff d0                	callq  *%rax
  80042050a9:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < PGSIZE; i++)
  80042050ad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042050b4:	eb 4d                	jmp    8004205103 <check_page_alloc+0x985>
		assert(c[i] == 0);
  80042050b6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042050b9:	48 63 d0             	movslq %eax,%rdx
  80042050bc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042050c0:	48 01 d0             	add    %rdx,%rax
  80042050c3:	0f b6 00             	movzbl (%rax),%eax
  80042050c6:	84 c0                	test   %al,%al
  80042050c8:	74 35                	je     80042050ff <check_page_alloc+0x981>
  80042050ca:	48 b9 5c f7 21 04 80 	movabs $0x800421f75c,%rcx
  80042050d1:	00 00 00 
  80042050d4:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042050db:	00 00 00 
  80042050de:	be 20 04 00 00       	mov    $0x420,%esi
  80042050e3:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042050ea:	00 00 00 
  80042050ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042050f2:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042050f9:	00 00 00 
  80042050fc:	41 ff d0             	callq  *%r8
	memset(page2kva(pp0), 1, PGSIZE);
	page_free(pp0);
	assert((pp = page_alloc(ALLOC_ZERO)));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	for (i = 0; i < PGSIZE; i++)
  80042050ff:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004205103:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%rbp)
  800420510a:	7e aa                	jle    80042050b6 <check_page_alloc+0x938>
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;
  800420510c:	48 b8 38 d2 4d 04 80 	movabs $0x80044dd238,%rax
  8004205113:	00 00 00 
  8004205116:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420511a:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_free(pp0);
  800420511d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205121:	48 89 c7             	mov    %rax,%rdi
  8004205124:	48 b8 af 2f 20 04 80 	movabs $0x8004202faf,%rax
  800420512b:	00 00 00 
  800420512e:	ff d0                	callq  *%rax
	page_free(pp1);
  8004205130:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205134:	48 89 c7             	mov    %rax,%rdi
  8004205137:	48 b8 af 2f 20 04 80 	movabs $0x8004202faf,%rax
  800420513e:	00 00 00 
  8004205141:	ff d0                	callq  *%rax
	page_free(pp2);
  8004205143:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205147:	48 89 c7             	mov    %rax,%rdi
  800420514a:	48 b8 af 2f 20 04 80 	movabs $0x8004202faf,%rax
  8004205151:	00 00 00 
  8004205154:	ff d0                	callq  *%rax

	cprintf("check_page_alloc() succeeded!\n");
  8004205156:	48 bf 68 f7 21 04 80 	movabs $0x800421f768,%rdi
  800420515d:	00 00 00 
  8004205160:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205165:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420516c:	00 00 00 
  800420516f:	ff d2                	callq  *%rdx
}
  8004205171:	90                   	nop
  8004205172:	c9                   	leaveq 
  8004205173:	c3                   	retq   

0000008004205174 <check_boot_pml4e>:
// but it is a pretty good sanity check.
//

static void
check_boot_pml4e(pml4e_t *pml4e)
{
  8004205174:	55                   	push   %rbp
  8004205175:	48 89 e5             	mov    %rsp,%rbp
  8004205178:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  800420517f:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
	uint64_t i, n;

	pml4e = boot_pml4e;
  8004205186:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  800420518d:	00 00 00 
  8004205190:	48 8b 00             	mov    (%rax),%rax
  8004205193:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
  800420519a:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  80042051a1:	00 
  80042051a2:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  80042051a9:	00 00 00 
  80042051ac:	48 8b 00             	mov    (%rax),%rax
  80042051af:	48 c1 e0 04          	shl    $0x4,%rax
  80042051b3:	48 89 c2             	mov    %rax,%rdx
  80042051b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042051ba:	48 01 d0             	add    %rdx,%rax
  80042051bd:	48 83 e8 01          	sub    $0x1,%rax
  80042051c1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042051c5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042051c9:	ba 00 00 00 00       	mov    $0x0,%edx
  80042051ce:	48 f7 75 e8          	divq   -0x18(%rbp)
  80042051d2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042051d6:	48 29 d0             	sub    %rdx,%rax
  80042051d9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE) {
  80042051dd:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042051e4:	00 
  80042051e5:	e9 da 00 00 00       	jmpq   80042052c4 <check_boot_pml4e+0x150>
		// cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
  80042051ea:	48 ba 00 00 a0 00 80 	movabs $0x8000a00000,%rdx
  80042051f1:	00 00 00 
  80042051f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042051f8:	48 01 c2             	add    %rax,%rdx
  80042051fb:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205202:	48 89 d6             	mov    %rdx,%rsi
  8004205205:	48 89 c7             	mov    %rax,%rdi
  8004205208:	48 b8 c5 58 20 04 80 	movabs $0x80042058c5,%rax
  800420520f:	00 00 00 
  8004205212:	ff d0                	callq  *%rax
  8004205214:	48 89 c1             	mov    %rax,%rcx
  8004205217:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  800420521e:	00 00 00 
  8004205221:	48 8b 00             	mov    (%rax),%rax
  8004205224:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205228:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420522f:	00 00 00 
  8004205232:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004205236:	77 32                	ja     800420526a <check_boot_pml4e+0xf6>
  8004205238:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420523c:	48 89 c1             	mov    %rax,%rcx
  800420523f:	48 ba a8 f3 21 04 80 	movabs $0x800421f3a8,%rdx
  8004205246:	00 00 00 
  8004205249:	be 40 04 00 00       	mov    $0x440,%esi
  800420524e:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205255:	00 00 00 
  8004205258:	b8 00 00 00 00       	mov    $0x0,%eax
  800420525d:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205264:	00 00 00 
  8004205267:	41 ff d0             	callq  *%r8
  800420526a:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004205271:	ff ff ff 
  8004205274:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205278:	48 01 c2             	add    %rax,%rdx
  800420527b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420527f:	48 01 d0             	add    %rdx,%rax
  8004205282:	48 39 c1             	cmp    %rax,%rcx
  8004205285:	74 35                	je     80042052bc <check_boot_pml4e+0x148>
  8004205287:	48 b9 88 f7 21 04 80 	movabs $0x800421f788,%rcx
  800420528e:	00 00 00 
  8004205291:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004205298:	00 00 00 
  800420529b:	be 40 04 00 00       	mov    $0x440,%esi
  80042052a0:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042052a7:	00 00 00 
  80042052aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042052af:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042052b6:	00 00 00 
  80042052b9:	41 ff d0             	callq  *%r8

	pml4e = boot_pml4e;

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
	for (i = 0; i < n; i += PGSIZE) {
  80042052bc:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042052c3:	00 
  80042052c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042052c8:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80042052cc:	0f 82 18 ff ff ff    	jb     80042051ea <check_boot_pml4e+0x76>
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}


	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  80042052d2:	48 c7 45 d0 00 10 00 	movq   $0x1000,-0x30(%rbp)
  80042052d9:	00 
  80042052da:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042052de:	48 05 ff 9f 05 00    	add    $0x59fff,%rax
  80042052e4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042052e8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042052ec:	ba 00 00 00 00       	mov    $0x0,%edx
  80042052f1:	48 f7 75 d0          	divq   -0x30(%rbp)
  80042052f5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042052f9:	48 29 d0             	sub    %rdx,%rax
  80042052fc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE)
  8004205300:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205307:	00 
  8004205308:	e9 da 00 00 00       	jmpq   80042053e7 <check_boot_pml4e+0x273>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);
  800420530d:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  8004205314:	00 00 00 
  8004205317:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420531b:	48 01 c2             	add    %rax,%rdx
  800420531e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205325:	48 89 d6             	mov    %rdx,%rsi
  8004205328:	48 89 c7             	mov    %rax,%rdi
  800420532b:	48 b8 c5 58 20 04 80 	movabs $0x80042058c5,%rax
  8004205332:	00 00 00 
  8004205335:	ff d0                	callq  *%rax
  8004205337:	48 89 c1             	mov    %rax,%rcx
  800420533a:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  8004205341:	00 00 00 
  8004205344:	48 8b 00             	mov    (%rax),%rax
  8004205347:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800420534b:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004205352:	00 00 00 
  8004205355:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  8004205359:	77 32                	ja     800420538d <check_boot_pml4e+0x219>
  800420535b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420535f:	48 89 c1             	mov    %rax,%rcx
  8004205362:	48 ba a8 f3 21 04 80 	movabs $0x800421f3a8,%rdx
  8004205369:	00 00 00 
  800420536c:	be 47 04 00 00       	mov    $0x447,%esi
  8004205371:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205378:	00 00 00 
  800420537b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205380:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205387:	00 00 00 
  800420538a:	41 ff d0             	callq  *%r8
  800420538d:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004205394:	ff ff ff 
  8004205397:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420539b:	48 01 c2             	add    %rax,%rdx
  800420539e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042053a2:	48 01 d0             	add    %rdx,%rax
  80042053a5:	48 39 c1             	cmp    %rax,%rcx
  80042053a8:	74 35                	je     80042053df <check_boot_pml4e+0x26b>
  80042053aa:	48 b9 c0 f7 21 04 80 	movabs $0x800421f7c0,%rcx
  80042053b1:	00 00 00 
  80042053b4:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042053bb:	00 00 00 
  80042053be:	be 47 04 00 00       	mov    $0x447,%esi
  80042053c3:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042053ca:	00 00 00 
  80042053cd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042053d2:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042053d9:	00 00 00 
  80042053dc:	41 ff d0             	callq  *%r8
	}


	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
  80042053df:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042053e6:	00 
  80042053e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042053eb:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80042053ef:	0f 82 18 ff ff ff    	jb     800420530d <check_boot_pml4e+0x199>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);


	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  80042053f5:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042053fc:	00 
  80042053fd:	eb 6d                	jmp    800420546c <check_boot_pml4e+0x2f8>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);
  80042053ff:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205406:	00 00 00 
  8004205409:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420540d:	48 01 c2             	add    %rax,%rdx
  8004205410:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205417:	48 89 d6             	mov    %rdx,%rsi
  800420541a:	48 89 c7             	mov    %rax,%rdi
  800420541d:	48 b8 c5 58 20 04 80 	movabs $0x80042058c5,%rax
  8004205424:	00 00 00 
  8004205427:	ff d0                	callq  *%rax
  8004205429:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420542d:	74 35                	je     8004205464 <check_boot_pml4e+0x2f0>
  800420542f:	48 b9 f8 f7 21 04 80 	movabs $0x800421f7f8,%rcx
  8004205436:	00 00 00 
  8004205439:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004205440:	00 00 00 
  8004205443:	be 4c 04 00 00       	mov    $0x44c,%esi
  8004205448:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  800420544f:	00 00 00 
  8004205452:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205457:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420545e:	00 00 00 
  8004205461:	41 ff d0             	callq  *%r8
	for (i = 0; i < n; i += PGSIZE)
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);


	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004205464:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  800420546b:	00 
  800420546c:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004205473:	00 00 00 
  8004205476:	48 8b 00             	mov    (%rax),%rax
  8004205479:	48 c1 e0 0c          	shl    $0xc,%rax
  800420547d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004205481:	0f 87 78 ff ff ff    	ja     80042053ff <check_boot_pml4e+0x28b>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);


	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004205487:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420548e:	00 
  800420548f:	e9 aa 01 00 00       	jmpq   800420563e <check_boot_pml4e+0x4ca>
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
  8004205494:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004205498:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420549c:	48 89 d0             	mov    %rdx,%rax
  800420549f:	48 01 c0             	add    %rax,%rax
  80042054a2:	48 01 d0             	add    %rdx,%rax
  80042054a5:	48 c1 e0 0f          	shl    $0xf,%rax
  80042054a9:	48 89 c2             	mov    %rax,%rdx
  80042054ac:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  80042054b3:	00 00 00 
  80042054b6:	48 29 d0             	sub    %rdx,%rax
  80042054b9:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  80042054bd:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042054c4:	00 
  80042054c5:	e9 e6 00 00 00       	jmpq   80042055b0 <check_boot_pml4e+0x43c>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
  80042054ca:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042054ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042054d2:	48 01 d0             	add    %rdx,%rax
  80042054d5:	48 8d 90 00 80 00 00 	lea    0x8000(%rax),%rdx
  80042054dc:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042054e3:	48 89 d6             	mov    %rdx,%rsi
  80042054e6:	48 89 c7             	mov    %rax,%rdi
  80042054e9:	48 b8 c5 58 20 04 80 	movabs $0x80042058c5,%rax
  80042054f0:	00 00 00 
  80042054f3:	ff d0                	callq  *%rax
  80042054f5:	48 89 c1             	mov    %rax,%rcx
  80042054f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042054fc:	48 c1 e0 10          	shl    $0x10,%rax
  8004205500:	48 89 c2             	mov    %rax,%rdx
  8004205503:	48 b8 00 f0 6d 04 80 	movabs $0x80046df000,%rax
  800420550a:	00 00 00 
  800420550d:	48 01 d0             	add    %rdx,%rax
  8004205510:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004205514:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420551b:	00 00 00 
  800420551e:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  8004205522:	77 32                	ja     8004205556 <check_boot_pml4e+0x3e2>
  8004205524:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004205528:	48 89 c1             	mov    %rax,%rcx
  800420552b:	48 ba a8 f3 21 04 80 	movabs $0x800421f3a8,%rdx
  8004205532:	00 00 00 
  8004205535:	be 55 04 00 00       	mov    $0x455,%esi
  800420553a:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205541:	00 00 00 
  8004205544:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205549:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205550:	00 00 00 
  8004205553:	41 ff d0             	callq  *%r8
  8004205556:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420555d:	ff ff ff 
  8004205560:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004205564:	48 01 c2             	add    %rax,%rdx
  8004205567:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420556b:	48 01 d0             	add    %rdx,%rax
  800420556e:	48 39 c1             	cmp    %rax,%rcx
  8004205571:	74 35                	je     80042055a8 <check_boot_pml4e+0x434>
  8004205573:	48 b9 20 f8 21 04 80 	movabs $0x800421f820,%rcx
  800420557a:	00 00 00 
  800420557d:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004205584:	00 00 00 
  8004205587:	be 55 04 00 00       	mov    $0x455,%esi
  800420558c:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205593:	00 00 00 
  8004205596:	b8 00 00 00 00       	mov    $0x0,%eax
  800420559b:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042055a2:	00 00 00 
  80042055a5:	41 ff d0             	callq  *%r8

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  80042055a8:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042055af:	00 
  80042055b0:	48 81 7d f8 ff ff 00 	cmpq   $0xffff,-0x8(%rbp)
  80042055b7:	00 
  80042055b8:	0f 86 0c ff ff ff    	jbe    80042054ca <check_boot_pml4e+0x356>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  80042055be:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042055c5:	00 
  80042055c6:	eb 67                	jmp    800420562f <check_boot_pml4e+0x4bb>
			assert(check_va2pa(pml4e, base + i) == ~0);
  80042055c8:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042055cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042055d0:	48 01 c2             	add    %rax,%rdx
  80042055d3:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042055da:	48 89 d6             	mov    %rdx,%rsi
  80042055dd:	48 89 c7             	mov    %rax,%rdi
  80042055e0:	48 b8 c5 58 20 04 80 	movabs $0x80042058c5,%rax
  80042055e7:	00 00 00 
  80042055ea:	ff d0                	callq  *%rax
  80042055ec:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  80042055f0:	74 35                	je     8004205627 <check_boot_pml4e+0x4b3>
  80042055f2:	48 b9 68 f8 21 04 80 	movabs $0x800421f868,%rcx
  80042055f9:	00 00 00 
  80042055fc:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004205603:	00 00 00 
  8004205606:	be 57 04 00 00       	mov    $0x457,%esi
  800420560b:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205612:	00 00 00 
  8004205615:	b8 00 00 00 00       	mov    $0x0,%eax
  800420561a:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205621:	00 00 00 
  8004205624:	41 ff d0             	callq  *%r8
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004205627:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  800420562e:	00 
  800420562f:	48 81 7d f8 ff 7f 00 	cmpq   $0x7fff,-0x8(%rbp)
  8004205636:	00 
  8004205637:	76 8f                	jbe    80042055c8 <check_boot_pml4e+0x454>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);


	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004205639:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  800420563e:	48 83 7d f0 03       	cmpq   $0x3,-0x10(%rbp)
  8004205643:	0f 86 4b fe ff ff    	jbe    8004205494 <check_boot_pml4e+0x320>
		for (i = 0; i < KSTKGAP; i += PGSIZE)
			assert(check_va2pa(pml4e, base + i) == ~0);
	}


	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
  8004205649:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004205650:	00 00 00 
  8004205653:	48 8b 00             	mov    (%rax),%rax
  8004205656:	48 83 c0 08          	add    $0x8,%rax
  800420565a:	48 8b 00             	mov    (%rax),%rax
  800420565d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205663:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  8004205667:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420566b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420566f:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  8004205672:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004205675:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  800420567c:	00 00 00 
  800420567f:	48 8b 00             	mov    (%rax),%rax
  8004205682:	48 39 c2             	cmp    %rax,%rdx
  8004205685:	72 32                	jb     80042056b9 <check_boot_pml4e+0x545>
  8004205687:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420568b:	48 89 c1             	mov    %rax,%rcx
  800420568e:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  8004205695:	00 00 00 
  8004205698:	be 5b 04 00 00       	mov    $0x45b,%esi
  800420569d:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042056a4:	00 00 00 
  80042056a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042056ac:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042056b3:	00 00 00 
  80042056b6:	41 ff d0             	callq  *%r8
  80042056b9:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042056c0:	00 00 00 
  80042056c3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042056c7:	48 01 d0             	add    %rdx,%rax
  80042056ca:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  80042056ce:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042056d2:	48 8b 00             	mov    (%rax),%rax
  80042056d5:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042056db:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  80042056df:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042056e3:	48 c1 e8 0c          	shr    $0xc,%rax
  80042056e7:	89 45 8c             	mov    %eax,-0x74(%rbp)
  80042056ea:	8b 55 8c             	mov    -0x74(%rbp),%edx
  80042056ed:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  80042056f4:	00 00 00 
  80042056f7:	48 8b 00             	mov    (%rax),%rax
  80042056fa:	48 39 c2             	cmp    %rax,%rdx
  80042056fd:	72 32                	jb     8004205731 <check_boot_pml4e+0x5bd>
  80042056ff:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205703:	48 89 c1             	mov    %rax,%rcx
  8004205706:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  800420570d:	00 00 00 
  8004205710:	be 5c 04 00 00       	mov    $0x45c,%esi
  8004205715:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  800420571c:	00 00 00 
  800420571f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205724:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420572b:	00 00 00 
  800420572e:	41 ff d0             	callq  *%r8
  8004205731:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205738:	00 00 00 
  800420573b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420573f:	48 01 d0             	add    %rdx,%rax
  8004205742:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  8004205746:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420574d:	00 
  800420574e:	e9 46 01 00 00       	jmpq   8004205899 <check_boot_pml4e+0x725>
		switch (i) {
  8004205753:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205757:	48 83 f8 04          	cmp    $0x4,%rax
  800420575b:	72 63                	jb     80042057c0 <check_boot_pml4e+0x64c>
  800420575d:	48 83 f8 05          	cmp    $0x5,%rax
  8004205761:	76 06                	jbe    8004205769 <check_boot_pml4e+0x5f5>
  8004205763:	48 83 f8 1f          	cmp    $0x1f,%rax
  8004205767:	75 57                	jne    80042057c0 <check_boot_pml4e+0x64c>
		case PDX(KSTACKTOP - 1):
		case PDX(UPAGES):

		case PDX(UENVS):

			assert(pgdir[i] & PTE_P);
  8004205769:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420576d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205774:	00 
  8004205775:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004205779:	48 01 d0             	add    %rdx,%rax
  800420577c:	48 8b 00             	mov    (%rax),%rax
  800420577f:	83 e0 01             	and    $0x1,%eax
  8004205782:	48 85 c0             	test   %rax,%rax
  8004205785:	0f 85 05 01 00 00    	jne    8004205890 <check_boot_pml4e+0x71c>
  800420578b:	48 b9 8b f8 21 04 80 	movabs $0x800421f88b,%rcx
  8004205792:	00 00 00 
  8004205795:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  800420579c:	00 00 00 
  800420579f:	be 66 04 00 00       	mov    $0x466,%esi
  80042057a4:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042057ab:	00 00 00 
  80042057ae:	b8 00 00 00 00       	mov    $0x0,%eax
  80042057b3:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042057ba:	00 00 00 
  80042057bd:	41 ff d0             	callq  *%r8
			break;
		default:
			if (i >= PDX(KERNBASE)) {
  80042057c0:	48 83 7d f8 1f       	cmpq   $0x1f,-0x8(%rbp)
  80042057c5:	0f 86 c8 00 00 00    	jbe    8004205893 <check_boot_pml4e+0x71f>
				if (pgdir[i] & PTE_P)
  80042057cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042057cf:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042057d6:	00 
  80042057d7:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042057db:	48 01 d0             	add    %rdx,%rax
  80042057de:	48 8b 00             	mov    (%rax),%rax
  80042057e1:	83 e0 01             	and    $0x1,%eax
  80042057e4:	48 85 c0             	test   %rax,%rax
  80042057e7:	74 57                	je     8004205840 <check_boot_pml4e+0x6cc>
					assert(pgdir[i] & PTE_W);
  80042057e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042057ed:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042057f4:	00 
  80042057f5:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042057f9:	48 01 d0             	add    %rdx,%rax
  80042057fc:	48 8b 00             	mov    (%rax),%rax
  80042057ff:	83 e0 02             	and    $0x2,%eax
  8004205802:	48 85 c0             	test   %rax,%rax
  8004205805:	0f 85 88 00 00 00    	jne    8004205893 <check_boot_pml4e+0x71f>
  800420580b:	48 b9 9c f8 21 04 80 	movabs $0x800421f89c,%rcx
  8004205812:	00 00 00 
  8004205815:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  800420581c:	00 00 00 
  800420581f:	be 6b 04 00 00       	mov    $0x46b,%esi
  8004205824:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  800420582b:	00 00 00 
  800420582e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205833:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420583a:	00 00 00 
  800420583d:	41 ff d0             	callq  *%r8
				else
					assert(pgdir[i] == 0);
  8004205840:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205844:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420584b:	00 
  800420584c:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004205850:	48 01 d0             	add    %rdx,%rax
  8004205853:	48 8b 00             	mov    (%rax),%rax
  8004205856:	48 85 c0             	test   %rax,%rax
  8004205859:	74 38                	je     8004205893 <check_boot_pml4e+0x71f>
  800420585b:	48 b9 ad f8 21 04 80 	movabs $0x800421f8ad,%rcx
  8004205862:	00 00 00 
  8004205865:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  800420586c:	00 00 00 
  800420586f:	be 6d 04 00 00       	mov    $0x46d,%esi
  8004205874:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  800420587b:	00 00 00 
  800420587e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205883:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420588a:	00 00 00 
  800420588d:	41 ff d0             	callq  *%r8
		case PDX(UPAGES):

		case PDX(UENVS):

			assert(pgdir[i] & PTE_P);
			break;
  8004205890:	90                   	nop
  8004205891:	eb 01                	jmp    8004205894 <check_boot_pml4e+0x720>
				if (pgdir[i] & PTE_P)
					assert(pgdir[i] & PTE_W);
				else
					assert(pgdir[i] == 0);
			} 
			break;
  8004205893:	90                   	nop


	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  8004205894:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004205899:	48 81 7d f8 ff 01 00 	cmpq   $0x1ff,-0x8(%rbp)
  80042058a0:	00 
  80042058a1:	0f 86 ac fe ff ff    	jbe    8004205753 <check_boot_pml4e+0x5df>
					assert(pgdir[i] == 0);
			} 
			break;
		}
	}
	cprintf("check_boot_pml4e() succeeded!\n");
  80042058a7:	48 bf c0 f8 21 04 80 	movabs $0x800421f8c0,%rdi
  80042058ae:	00 00 00 
  80042058b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042058b6:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  80042058bd:	00 00 00 
  80042058c0:	ff d2                	callq  *%rdx
}
  80042058c2:	90                   	nop
  80042058c3:	c9                   	leaveq 
  80042058c4:	c3                   	retq   

00000080042058c5 <check_va2pa>:
// this functionality for us!  We define our own version to help check
// the check_boot_pml4e() function; it shouldn't be used elsewhere.

static physaddr_t
check_va2pa(pml4e_t *pml4e, uintptr_t va)
{
  80042058c5:	55                   	push   %rbp
  80042058c6:	48 89 e5             	mov    %rsp,%rbp
  80042058c9:	48 83 ec 60          	sub    $0x60,%rsp
  80042058cd:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80042058d1:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	pte_t *pte;
	pdpe_t *pdpe;
	pde_t *pde;
	// cprintf("%x", va);
	pml4e = &pml4e[PML4(va)];
  80042058d5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042058d9:	48 c1 e8 27          	shr    $0x27,%rax
  80042058dd:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042058e2:	48 c1 e0 03          	shl    $0x3,%rax
  80042058e6:	48 01 45 a8          	add    %rax,-0x58(%rbp)
	// cprintf(" %x %x " , PML4(va), *pml4e);
	if(!(*pml4e & PTE_P))
  80042058ea:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042058ee:	48 8b 00             	mov    (%rax),%rax
  80042058f1:	83 e0 01             	and    $0x1,%eax
  80042058f4:	48 85 c0             	test   %rax,%rax
  80042058f7:	75 0c                	jne    8004205905 <check_va2pa+0x40>
		return ~0;
  80042058f9:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205900:	e9 38 02 00 00       	jmpq   8004205b3d <check_va2pa+0x278>
	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*pml4e));
  8004205905:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205909:	48 8b 00             	mov    (%rax),%rax
  800420590c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205912:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004205916:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420591a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420591e:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004205921:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004205924:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  800420592b:	00 00 00 
  800420592e:	48 8b 00             	mov    (%rax),%rax
  8004205931:	48 39 c2             	cmp    %rax,%rdx
  8004205934:	72 32                	jb     8004205968 <check_va2pa+0xa3>
  8004205936:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420593a:	48 89 c1             	mov    %rax,%rcx
  800420593d:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  8004205944:	00 00 00 
  8004205947:	be 85 04 00 00       	mov    $0x485,%esi
  800420594c:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205953:	00 00 00 
  8004205956:	b8 00 00 00 00       	mov    $0x0,%eax
  800420595b:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205962:	00 00 00 
  8004205965:	41 ff d0             	callq  *%r8
  8004205968:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420596f:	00 00 00 
  8004205972:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205976:	48 01 d0             	add    %rdx,%rax
  8004205979:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// cprintf(" %x %x " , pdpe, *pdpe);
	if (!(pdpe[PDPE(va)] & PTE_P))
  800420597d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205981:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205985:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420598a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205991:	00 
  8004205992:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205996:	48 01 d0             	add    %rdx,%rax
  8004205999:	48 8b 00             	mov    (%rax),%rax
  800420599c:	83 e0 01             	and    $0x1,%eax
  800420599f:	48 85 c0             	test   %rax,%rax
  80042059a2:	75 0c                	jne    80042059b0 <check_va2pa+0xeb>
		return ~0;
  80042059a4:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  80042059ab:	e9 8d 01 00 00       	jmpq   8004205b3d <check_va2pa+0x278>
	pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  80042059b0:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042059b4:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042059b8:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042059bd:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042059c4:	00 
  80042059c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042059c9:	48 01 d0             	add    %rdx,%rax
  80042059cc:	48 8b 00             	mov    (%rax),%rax
  80042059cf:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042059d5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042059d9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042059dd:	48 c1 e8 0c          	shr    $0xc,%rax
  80042059e1:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042059e4:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042059e7:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  80042059ee:	00 00 00 
  80042059f1:	48 8b 00             	mov    (%rax),%rax
  80042059f4:	48 39 c2             	cmp    %rax,%rdx
  80042059f7:	72 32                	jb     8004205a2b <check_va2pa+0x166>
  80042059f9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042059fd:	48 89 c1             	mov    %rax,%rcx
  8004205a00:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  8004205a07:	00 00 00 
  8004205a0a:	be 89 04 00 00       	mov    $0x489,%esi
  8004205a0f:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205a16:	00 00 00 
  8004205a19:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a1e:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205a25:	00 00 00 
  8004205a28:	41 ff d0             	callq  *%r8
  8004205a2b:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205a32:	00 00 00 
  8004205a35:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a39:	48 01 d0             	add    %rdx,%rax
  8004205a3c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	// cprintf(" %x %x " , pde, *pde);
	pde = &pde[PDX(va)];
  8004205a40:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205a44:	48 c1 e8 15          	shr    $0x15,%rax
  8004205a48:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205a4d:	48 c1 e0 03          	shl    $0x3,%rax
  8004205a51:	48 01 45 d0          	add    %rax,-0x30(%rbp)
	if (!(*pde & PTE_P))
  8004205a55:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205a59:	48 8b 00             	mov    (%rax),%rax
  8004205a5c:	83 e0 01             	and    $0x1,%eax
  8004205a5f:	48 85 c0             	test   %rax,%rax
  8004205a62:	75 0c                	jne    8004205a70 <check_va2pa+0x1ab>
		return ~0;
  8004205a64:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205a6b:	e9 cd 00 00 00       	jmpq   8004205b3d <check_va2pa+0x278>
	pte = (pte_t*) KADDR(PTE_ADDR(*pde));
  8004205a70:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205a74:	48 8b 00             	mov    (%rax),%rax
  8004205a77:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205a7d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205a81:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205a85:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205a89:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004205a8c:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004205a8f:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004205a96:	00 00 00 
  8004205a99:	48 8b 00             	mov    (%rax),%rax
  8004205a9c:	48 39 c2             	cmp    %rax,%rdx
  8004205a9f:	72 32                	jb     8004205ad3 <check_va2pa+0x20e>
  8004205aa1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205aa5:	48 89 c1             	mov    %rax,%rcx
  8004205aa8:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  8004205aaf:	00 00 00 
  8004205ab2:	be 8e 04 00 00       	mov    $0x48e,%esi
  8004205ab7:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205abe:	00 00 00 
  8004205ac1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ac6:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205acd:	00 00 00 
  8004205ad0:	41 ff d0             	callq  *%r8
  8004205ad3:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205ada:	00 00 00 
  8004205add:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205ae1:	48 01 d0             	add    %rdx,%rax
  8004205ae4:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	// cprintf(" %x %x " , pte, *pte);
	if (!(pte[PTX(va)] & PTE_P))
  8004205ae8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205aec:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205af0:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205af5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205afc:	00 
  8004205afd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205b01:	48 01 d0             	add    %rdx,%rax
  8004205b04:	48 8b 00             	mov    (%rax),%rax
  8004205b07:	83 e0 01             	and    $0x1,%eax
  8004205b0a:	48 85 c0             	test   %rax,%rax
  8004205b0d:	75 09                	jne    8004205b18 <check_va2pa+0x253>
		return ~0;
  8004205b0f:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205b16:	eb 25                	jmp    8004205b3d <check_va2pa+0x278>
	// cprintf(" %x %x\n" , PTX(va),  PTE_ADDR(pte[PTX(va)]));
	return PTE_ADDR(pte[PTX(va)]);
  8004205b18:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205b1c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205b20:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205b25:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205b2c:	00 
  8004205b2d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205b31:	48 01 d0             	add    %rdx,%rax
  8004205b34:	48 8b 00             	mov    (%rax),%rax
  8004205b37:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  8004205b3d:	c9                   	leaveq 
  8004205b3e:	c3                   	retq   

0000008004205b3f <page_check>:


// check page_insert, page_remove, &c
static void
page_check(void)
{
  8004205b3f:	55                   	push   %rbp
  8004205b40:	48 89 e5             	mov    %rsp,%rbp
  8004205b43:	53                   	push   %rbx
  8004205b44:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
	void *va;
	int i;

	uintptr_t mm1, mm2;

	pp0 = pp1 = pp2 = pp3 = pp4 = pp5 =0;
  8004205b4b:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004205b52:	00 
  8004205b53:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205b57:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205b5b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205b5f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004205b63:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205b67:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205b6b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205b6f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004205b73:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205b77:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	assert(pp0 = page_alloc(0));
  8004205b7b:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205b80:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004205b87:	00 00 00 
  8004205b8a:	ff d0                	callq  *%rax
  8004205b8c:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004205b90:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004205b95:	75 35                	jne    8004205bcc <page_check+0x8d>
  8004205b97:	48 b9 df f8 21 04 80 	movabs $0x800421f8df,%rcx
  8004205b9e:	00 00 00 
  8004205ba1:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004205ba8:	00 00 00 
  8004205bab:	be a6 04 00 00       	mov    $0x4a6,%esi
  8004205bb0:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205bb7:	00 00 00 
  8004205bba:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205bbf:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205bc6:	00 00 00 
  8004205bc9:	41 ff d0             	callq  *%r8
	assert(pp1 = page_alloc(0));
  8004205bcc:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205bd1:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004205bd8:	00 00 00 
  8004205bdb:	ff d0                	callq  *%rax
  8004205bdd:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004205be1:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205be6:	75 35                	jne    8004205c1d <page_check+0xde>
  8004205be8:	48 b9 f3 f8 21 04 80 	movabs $0x800421f8f3,%rcx
  8004205bef:	00 00 00 
  8004205bf2:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004205bf9:	00 00 00 
  8004205bfc:	be a7 04 00 00       	mov    $0x4a7,%esi
  8004205c01:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205c08:	00 00 00 
  8004205c0b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c10:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205c17:	00 00 00 
  8004205c1a:	41 ff d0             	callq  *%r8
	assert(pp2 = page_alloc(0));
  8004205c1d:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205c22:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004205c29:	00 00 00 
  8004205c2c:	ff d0                	callq  *%rax
  8004205c2e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205c32:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205c37:	75 35                	jne    8004205c6e <page_check+0x12f>
  8004205c39:	48 b9 07 f9 21 04 80 	movabs $0x800421f907,%rcx
  8004205c40:	00 00 00 
  8004205c43:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004205c4a:	00 00 00 
  8004205c4d:	be a8 04 00 00       	mov    $0x4a8,%esi
  8004205c52:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205c59:	00 00 00 
  8004205c5c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c61:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205c68:	00 00 00 
  8004205c6b:	41 ff d0             	callq  *%r8
	assert(pp3 = page_alloc(0));
  8004205c6e:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205c73:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004205c7a:	00 00 00 
  8004205c7d:	ff d0                	callq  *%rax
  8004205c7f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004205c83:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205c88:	75 35                	jne    8004205cbf <page_check+0x180>
  8004205c8a:	48 b9 1b f9 21 04 80 	movabs $0x800421f91b,%rcx
  8004205c91:	00 00 00 
  8004205c94:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004205c9b:	00 00 00 
  8004205c9e:	be a9 04 00 00       	mov    $0x4a9,%esi
  8004205ca3:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205caa:	00 00 00 
  8004205cad:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205cb2:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205cb9:	00 00 00 
  8004205cbc:	41 ff d0             	callq  *%r8
	assert(pp4 = page_alloc(0));
  8004205cbf:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205cc4:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004205ccb:	00 00 00 
  8004205cce:	ff d0                	callq  *%rax
  8004205cd0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205cd4:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205cd9:	75 35                	jne    8004205d10 <page_check+0x1d1>
  8004205cdb:	48 b9 2f f9 21 04 80 	movabs $0x800421f92f,%rcx
  8004205ce2:	00 00 00 
  8004205ce5:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004205cec:	00 00 00 
  8004205cef:	be aa 04 00 00       	mov    $0x4aa,%esi
  8004205cf4:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205cfb:	00 00 00 
  8004205cfe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d03:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205d0a:	00 00 00 
  8004205d0d:	41 ff d0             	callq  *%r8
	assert(pp5 = page_alloc(0));
  8004205d10:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205d15:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004205d1c:	00 00 00 
  8004205d1f:	ff d0                	callq  *%rax
  8004205d21:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004205d25:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205d2a:	75 35                	jne    8004205d61 <page_check+0x222>
  8004205d2c:	48 b9 43 f9 21 04 80 	movabs $0x800421f943,%rcx
  8004205d33:	00 00 00 
  8004205d36:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004205d3d:	00 00 00 
  8004205d40:	be ab 04 00 00       	mov    $0x4ab,%esi
  8004205d45:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205d4c:	00 00 00 
  8004205d4f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d54:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205d5b:	00 00 00 
  8004205d5e:	41 ff d0             	callq  *%r8

	assert(pp0);
  8004205d61:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004205d66:	75 35                	jne    8004205d9d <page_check+0x25e>
  8004205d68:	48 b9 91 f6 21 04 80 	movabs $0x800421f691,%rcx
  8004205d6f:	00 00 00 
  8004205d72:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004205d79:	00 00 00 
  8004205d7c:	be ad 04 00 00       	mov    $0x4ad,%esi
  8004205d81:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205d88:	00 00 00 
  8004205d8b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d90:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205d97:	00 00 00 
  8004205d9a:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004205d9d:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205da2:	74 0a                	je     8004205dae <page_check+0x26f>
  8004205da4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205da8:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205dac:	75 35                	jne    8004205de3 <page_check+0x2a4>
  8004205dae:	48 b9 95 f6 21 04 80 	movabs $0x800421f695,%rcx
  8004205db5:	00 00 00 
  8004205db8:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004205dbf:	00 00 00 
  8004205dc2:	be ae 04 00 00       	mov    $0x4ae,%esi
  8004205dc7:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205dce:	00 00 00 
  8004205dd1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205dd6:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205ddd:	00 00 00 
  8004205de0:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004205de3:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205de8:	74 14                	je     8004205dfe <page_check+0x2bf>
  8004205dea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205dee:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205df2:	74 0a                	je     8004205dfe <page_check+0x2bf>
  8004205df4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205df8:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205dfc:	75 35                	jne    8004205e33 <page_check+0x2f4>
  8004205dfe:	48 b9 a8 f6 21 04 80 	movabs $0x800421f6a8,%rcx
  8004205e05:	00 00 00 
  8004205e08:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004205e0f:	00 00 00 
  8004205e12:	be af 04 00 00       	mov    $0x4af,%esi
  8004205e17:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205e1e:	00 00 00 
  8004205e21:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e26:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205e2d:	00 00 00 
  8004205e30:	41 ff d0             	callq  *%r8
	assert(pp3 && pp3 != pp2 && pp3 != pp1 && pp3 != pp0);
  8004205e33:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205e38:	74 1e                	je     8004205e58 <page_check+0x319>
  8004205e3a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205e3e:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205e42:	74 14                	je     8004205e58 <page_check+0x319>
  8004205e44:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205e48:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205e4c:	74 0a                	je     8004205e58 <page_check+0x319>
  8004205e4e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205e52:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205e56:	75 35                	jne    8004205e8d <page_check+0x34e>
  8004205e58:	48 b9 58 f9 21 04 80 	movabs $0x800421f958,%rcx
  8004205e5f:	00 00 00 
  8004205e62:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004205e69:	00 00 00 
  8004205e6c:	be b0 04 00 00       	mov    $0x4b0,%esi
  8004205e71:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205e78:	00 00 00 
  8004205e7b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e80:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205e87:	00 00 00 
  8004205e8a:	41 ff d0             	callq  *%r8
	assert(pp4 && pp4 != pp3 && pp4 != pp2 && pp4 != pp1 && pp4 != pp0);
  8004205e8d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205e92:	74 28                	je     8004205ebc <page_check+0x37d>
  8004205e94:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205e98:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205e9c:	74 1e                	je     8004205ebc <page_check+0x37d>
  8004205e9e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205ea2:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205ea6:	74 14                	je     8004205ebc <page_check+0x37d>
  8004205ea8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205eac:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205eb0:	74 0a                	je     8004205ebc <page_check+0x37d>
  8004205eb2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205eb6:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205eba:	75 35                	jne    8004205ef1 <page_check+0x3b2>
  8004205ebc:	48 b9 88 f9 21 04 80 	movabs $0x800421f988,%rcx
  8004205ec3:	00 00 00 
  8004205ec6:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004205ecd:	00 00 00 
  8004205ed0:	be b1 04 00 00       	mov    $0x4b1,%esi
  8004205ed5:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205edc:	00 00 00 
  8004205edf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ee4:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205eeb:	00 00 00 
  8004205eee:	41 ff d0             	callq  *%r8
	assert(pp5 && pp5 != pp4 && pp5 != pp3 && pp5 != pp2 && pp5 != pp1 && pp5 != pp0);
  8004205ef1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205ef6:	74 32                	je     8004205f2a <page_check+0x3eb>
  8004205ef8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205efc:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004205f00:	74 28                	je     8004205f2a <page_check+0x3eb>
  8004205f02:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205f06:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205f0a:	74 1e                	je     8004205f2a <page_check+0x3eb>
  8004205f0c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205f10:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205f14:	74 14                	je     8004205f2a <page_check+0x3eb>
  8004205f16:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205f1a:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205f1e:	74 0a                	je     8004205f2a <page_check+0x3eb>
  8004205f20:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205f24:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205f28:	75 35                	jne    8004205f5f <page_check+0x420>
  8004205f2a:	48 b9 c8 f9 21 04 80 	movabs $0x800421f9c8,%rcx
  8004205f31:	00 00 00 
  8004205f34:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004205f3b:	00 00 00 
  8004205f3e:	be b2 04 00 00       	mov    $0x4b2,%esi
  8004205f43:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205f4a:	00 00 00 
  8004205f4d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f52:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205f59:	00 00 00 
  8004205f5c:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004205f5f:	48 b8 38 d2 4d 04 80 	movabs $0x80044dd238,%rax
  8004205f66:	00 00 00 
  8004205f69:	48 8b 00             	mov    (%rax),%rax
  8004205f6c:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	page_free_list = NULL;
  8004205f70:	48 b8 38 d2 4d 04 80 	movabs $0x80044dd238,%rax
  8004205f77:	00 00 00 
  8004205f7a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004205f81:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205f86:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004205f8d:	00 00 00 
  8004205f90:	ff d0                	callq  *%rax
  8004205f92:	48 85 c0             	test   %rax,%rax
  8004205f95:	74 35                	je     8004205fcc <page_check+0x48d>
  8004205f97:	48 b9 1f f7 21 04 80 	movabs $0x800421f71f,%rcx
  8004205f9e:	00 00 00 
  8004205fa1:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004205fa8:	00 00 00 
  8004205fab:	be b9 04 00 00       	mov    $0x4b9,%esi
  8004205fb0:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004205fb7:	00 00 00 
  8004205fba:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205fbf:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004205fc6:	00 00 00 
  8004205fc9:	41 ff d0             	callq  *%r8

	// there is no page allocated at address 0
	assert(page_lookup(boot_pml4e, (void *) 0x0, &ptep) == NULL);
  8004205fcc:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004205fd3:	00 00 00 
  8004205fd6:	48 8b 00             	mov    (%rax),%rax
  8004205fd9:	48 8d 95 e0 fe ff ff 	lea    -0x120(%rbp),%rdx
  8004205fe0:	be 00 00 00 00       	mov    $0x0,%esi
  8004205fe5:	48 89 c7             	mov    %rax,%rdi
  8004205fe8:	48 b8 f1 3d 20 04 80 	movabs $0x8004203df1,%rax
  8004205fef:	00 00 00 
  8004205ff2:	ff d0                	callq  *%rax
  8004205ff4:	48 85 c0             	test   %rax,%rax
  8004205ff7:	74 35                	je     800420602e <page_check+0x4ef>
  8004205ff9:	48 b9 18 fa 21 04 80 	movabs $0x800421fa18,%rcx
  8004206000:	00 00 00 
  8004206003:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  800420600a:	00 00 00 
  800420600d:	be bc 04 00 00       	mov    $0x4bc,%esi
  8004206012:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206019:	00 00 00 
  800420601c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206021:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206028:	00 00 00 
  800420602b:	41 ff d0             	callq  *%r8

	// there is no free memory, so we can't allocate a page table 
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  800420602e:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206035:	00 00 00 
  8004206038:	48 8b 00             	mov    (%rax),%rax
  800420603b:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420603f:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206044:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206049:	48 89 c7             	mov    %rax,%rdi
  800420604c:	48 b8 7d 3a 20 04 80 	movabs $0x8004203a7d,%rax
  8004206053:	00 00 00 
  8004206056:	ff d0                	callq  *%rax
  8004206058:	85 c0                	test   %eax,%eax
  800420605a:	78 35                	js     8004206091 <page_check+0x552>
  800420605c:	48 b9 50 fa 21 04 80 	movabs $0x800421fa50,%rcx
  8004206063:	00 00 00 
  8004206066:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  800420606d:	00 00 00 
  8004206070:	be bf 04 00 00       	mov    $0x4bf,%esi
  8004206075:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  800420607c:	00 00 00 
  800420607f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206084:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420608b:	00 00 00 
  800420608e:	41 ff d0             	callq  *%r8

	// free pp0 and try again: pp0 should be used for page table
	page_free(pp0);
  8004206091:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206095:	48 89 c7             	mov    %rax,%rdi
  8004206098:	48 b8 af 2f 20 04 80 	movabs $0x8004202faf,%rax
  800420609f:	00 00 00 
  80042060a2:	ff d0                	callq  *%rax
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  80042060a4:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  80042060ab:	00 00 00 
  80042060ae:	48 8b 00             	mov    (%rax),%rax
  80042060b1:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042060b5:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042060ba:	ba 00 00 00 00       	mov    $0x0,%edx
  80042060bf:	48 89 c7             	mov    %rax,%rdi
  80042060c2:	48 b8 7d 3a 20 04 80 	movabs $0x8004203a7d,%rax
  80042060c9:	00 00 00 
  80042060cc:	ff d0                	callq  *%rax
  80042060ce:	85 c0                	test   %eax,%eax
  80042060d0:	78 35                	js     8004206107 <page_check+0x5c8>
  80042060d2:	48 b9 50 fa 21 04 80 	movabs $0x800421fa50,%rcx
  80042060d9:	00 00 00 
  80042060dc:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042060e3:	00 00 00 
  80042060e6:	be c3 04 00 00       	mov    $0x4c3,%esi
  80042060eb:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042060f2:	00 00 00 
  80042060f5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042060fa:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206101:	00 00 00 
  8004206104:	41 ff d0             	callq  *%r8
	page_free(pp2);
  8004206107:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420610b:	48 89 c7             	mov    %rax,%rdi
  800420610e:	48 b8 af 2f 20 04 80 	movabs $0x8004202faf,%rax
  8004206115:	00 00 00 
  8004206118:	ff d0                	callq  *%rax
	page_free(pp3);
  800420611a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420611e:	48 89 c7             	mov    %rax,%rdi
  8004206121:	48 b8 af 2f 20 04 80 	movabs $0x8004202faf,%rax
  8004206128:	00 00 00 
  800420612b:	ff d0                	callq  *%rax
	//cprintf("pp1 ref count = %d\n",pp1->pp_ref);
	//cprintf("pp0 ref count = %d\n",pp0->pp_ref);
	//cprintf("pp2 ref count = %d\n",pp2->pp_ref);
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) == 0);
  800420612d:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206134:	00 00 00 
  8004206137:	48 8b 00             	mov    (%rax),%rax
  800420613a:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420613e:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206143:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206148:	48 89 c7             	mov    %rax,%rdi
  800420614b:	48 b8 7d 3a 20 04 80 	movabs $0x8004203a7d,%rax
  8004206152:	00 00 00 
  8004206155:	ff d0                	callq  *%rax
  8004206157:	85 c0                	test   %eax,%eax
  8004206159:	74 35                	je     8004206190 <page_check+0x651>
  800420615b:	48 b9 80 fa 21 04 80 	movabs $0x800421fa80,%rcx
  8004206162:	00 00 00 
  8004206165:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  800420616c:	00 00 00 
  800420616f:	be c9 04 00 00       	mov    $0x4c9,%esi
  8004206174:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  800420617b:	00 00 00 
  800420617e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206183:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420618a:	00 00 00 
  800420618d:	41 ff d0             	callq  *%r8
	assert((PTE_ADDR(boot_pml4e[0]) == page2pa(pp0) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp2) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp3) ));
  8004206190:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206197:	00 00 00 
  800420619a:	48 8b 00             	mov    (%rax),%rax
  800420619d:	48 8b 00             	mov    (%rax),%rax
  80042061a0:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042061a6:	48 89 c3             	mov    %rax,%rbx
  80042061a9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042061ad:	48 89 c7             	mov    %rax,%rdi
  80042061b0:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  80042061b7:	00 00 00 
  80042061ba:	ff d0                	callq  *%rax
  80042061bc:	48 39 c3             	cmp    %rax,%rbx
  80042061bf:	0f 84 97 00 00 00    	je     800420625c <page_check+0x71d>
  80042061c5:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  80042061cc:	00 00 00 
  80042061cf:	48 8b 00             	mov    (%rax),%rax
  80042061d2:	48 8b 00             	mov    (%rax),%rax
  80042061d5:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042061db:	48 89 c3             	mov    %rax,%rbx
  80042061de:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042061e2:	48 89 c7             	mov    %rax,%rdi
  80042061e5:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  80042061ec:	00 00 00 
  80042061ef:	ff d0                	callq  *%rax
  80042061f1:	48 39 c3             	cmp    %rax,%rbx
  80042061f4:	74 66                	je     800420625c <page_check+0x71d>
  80042061f6:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  80042061fd:	00 00 00 
  8004206200:	48 8b 00             	mov    (%rax),%rax
  8004206203:	48 8b 00             	mov    (%rax),%rax
  8004206206:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420620c:	48 89 c3             	mov    %rax,%rbx
  800420620f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206213:	48 89 c7             	mov    %rax,%rdi
  8004206216:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  800420621d:	00 00 00 
  8004206220:	ff d0                	callq  *%rax
  8004206222:	48 39 c3             	cmp    %rax,%rbx
  8004206225:	74 35                	je     800420625c <page_check+0x71d>
  8004206227:	48 b9 b0 fa 21 04 80 	movabs $0x800421fab0,%rcx
  800420622e:	00 00 00 
  8004206231:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206238:	00 00 00 
  800420623b:	be ca 04 00 00       	mov    $0x4ca,%esi
  8004206240:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206247:	00 00 00 
  800420624a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420624f:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206256:	00 00 00 
  8004206259:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, 0x0) == page2pa(pp1));
  800420625c:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206263:	00 00 00 
  8004206266:	48 8b 00             	mov    (%rax),%rax
  8004206269:	be 00 00 00 00       	mov    $0x0,%esi
  800420626e:	48 89 c7             	mov    %rax,%rdi
  8004206271:	48 b8 c5 58 20 04 80 	movabs $0x80042058c5,%rax
  8004206278:	00 00 00 
  800420627b:	ff d0                	callq  *%rax
  800420627d:	48 89 c3             	mov    %rax,%rbx
  8004206280:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206284:	48 89 c7             	mov    %rax,%rdi
  8004206287:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  800420628e:	00 00 00 
  8004206291:	ff d0                	callq  *%rax
  8004206293:	48 39 c3             	cmp    %rax,%rbx
  8004206296:	74 35                	je     80042062cd <page_check+0x78e>
  8004206298:	48 b9 38 fb 21 04 80 	movabs $0x800421fb38,%rcx
  800420629f:	00 00 00 
  80042062a2:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042062a9:	00 00 00 
  80042062ac:	be cb 04 00 00       	mov    $0x4cb,%esi
  80042062b1:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042062b8:	00 00 00 
  80042062bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042062c0:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042062c7:	00 00 00 
  80042062ca:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  80042062cd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042062d1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042062d5:	66 83 f8 01          	cmp    $0x1,%ax
  80042062d9:	74 35                	je     8004206310 <page_check+0x7d1>
  80042062db:	48 b9 65 fb 21 04 80 	movabs $0x800421fb65,%rcx
  80042062e2:	00 00 00 
  80042062e5:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042062ec:	00 00 00 
  80042062ef:	be cc 04 00 00       	mov    $0x4cc,%esi
  80042062f4:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042062fb:	00 00 00 
  80042062fe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206303:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420630a:	00 00 00 
  800420630d:	41 ff d0             	callq  *%r8
	assert(pp0->pp_ref == 1);
  8004206310:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206314:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206318:	66 83 f8 01          	cmp    $0x1,%ax
  800420631c:	74 35                	je     8004206353 <page_check+0x814>
  800420631e:	48 b9 76 fb 21 04 80 	movabs $0x800421fb76,%rcx
  8004206325:	00 00 00 
  8004206328:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  800420632f:	00 00 00 
  8004206332:	be cd 04 00 00       	mov    $0x4cd,%esi
  8004206337:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  800420633e:	00 00 00 
  8004206341:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206346:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420634d:	00 00 00 
  8004206350:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 1);
  8004206353:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206357:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420635b:	66 83 f8 01          	cmp    $0x1,%ax
  800420635f:	74 35                	je     8004206396 <page_check+0x857>
  8004206361:	48 b9 87 fb 21 04 80 	movabs $0x800421fb87,%rcx
  8004206368:	00 00 00 
  800420636b:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206372:	00 00 00 
  8004206375:	be ce 04 00 00       	mov    $0x4ce,%esi
  800420637a:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206381:	00 00 00 
  8004206384:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206389:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206390:	00 00 00 
  8004206393:	41 ff d0             	callq  *%r8
	//should be able to map pp3 at PGSIZE because pp0 is already allocated for page table
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004206396:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  800420639d:	00 00 00 
  80042063a0:	48 8b 00             	mov    (%rax),%rax
  80042063a3:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042063a7:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042063ac:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042063b1:	48 89 c7             	mov    %rax,%rdi
  80042063b4:	48 b8 7d 3a 20 04 80 	movabs $0x8004203a7d,%rax
  80042063bb:	00 00 00 
  80042063be:	ff d0                	callq  *%rax
  80042063c0:	85 c0                	test   %eax,%eax
  80042063c2:	74 35                	je     80042063f9 <page_check+0x8ba>
  80042063c4:	48 b9 98 fb 21 04 80 	movabs $0x800421fb98,%rcx
  80042063cb:	00 00 00 
  80042063ce:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042063d5:	00 00 00 
  80042063d8:	be d0 04 00 00       	mov    $0x4d0,%esi
  80042063dd:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042063e4:	00 00 00 
  80042063e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042063ec:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042063f3:	00 00 00 
  80042063f6:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  80042063f9:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206400:	00 00 00 
  8004206403:	48 8b 00             	mov    (%rax),%rax
  8004206406:	be 00 10 00 00       	mov    $0x1000,%esi
  800420640b:	48 89 c7             	mov    %rax,%rdi
  800420640e:	48 b8 c5 58 20 04 80 	movabs $0x80042058c5,%rax
  8004206415:	00 00 00 
  8004206418:	ff d0                	callq  *%rax
  800420641a:	48 89 c3             	mov    %rax,%rbx
  800420641d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206421:	48 89 c7             	mov    %rax,%rdi
  8004206424:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  800420642b:	00 00 00 
  800420642e:	ff d0                	callq  *%rax
  8004206430:	48 39 c3             	cmp    %rax,%rbx
  8004206433:	74 35                	je     800420646a <page_check+0x92b>
  8004206435:	48 b9 d0 fb 21 04 80 	movabs $0x800421fbd0,%rcx
  800420643c:	00 00 00 
  800420643f:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206446:	00 00 00 
  8004206449:	be d1 04 00 00       	mov    $0x4d1,%esi
  800420644e:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206455:	00 00 00 
  8004206458:	b8 00 00 00 00       	mov    $0x0,%eax
  800420645d:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206464:	00 00 00 
  8004206467:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  800420646a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420646e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206472:	66 83 f8 02          	cmp    $0x2,%ax
  8004206476:	74 35                	je     80042064ad <page_check+0x96e>
  8004206478:	48 b9 00 fc 21 04 80 	movabs $0x800421fc00,%rcx
  800420647f:	00 00 00 
  8004206482:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206489:	00 00 00 
  800420648c:	be d2 04 00 00       	mov    $0x4d2,%esi
  8004206491:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206498:	00 00 00 
  800420649b:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064a0:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042064a7:	00 00 00 
  80042064aa:	41 ff d0             	callq  *%r8

	// should be no free memory
	assert(!page_alloc(0));
  80042064ad:	bf 00 00 00 00       	mov    $0x0,%edi
  80042064b2:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  80042064b9:	00 00 00 
  80042064bc:	ff d0                	callq  *%rax
  80042064be:	48 85 c0             	test   %rax,%rax
  80042064c1:	74 35                	je     80042064f8 <page_check+0x9b9>
  80042064c3:	48 b9 1f f7 21 04 80 	movabs $0x800421f71f,%rcx
  80042064ca:	00 00 00 
  80042064cd:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042064d4:	00 00 00 
  80042064d7:	be d5 04 00 00       	mov    $0x4d5,%esi
  80042064dc:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042064e3:	00 00 00 
  80042064e6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064eb:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042064f2:	00 00 00 
  80042064f5:	41 ff d0             	callq  *%r8

	// should be able to map pp3 at PGSIZE because it's already there
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  80042064f8:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  80042064ff:	00 00 00 
  8004206502:	48 8b 00             	mov    (%rax),%rax
  8004206505:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004206509:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420650e:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206513:	48 89 c7             	mov    %rax,%rdi
  8004206516:	48 b8 7d 3a 20 04 80 	movabs $0x8004203a7d,%rax
  800420651d:	00 00 00 
  8004206520:	ff d0                	callq  *%rax
  8004206522:	85 c0                	test   %eax,%eax
  8004206524:	74 35                	je     800420655b <page_check+0xa1c>
  8004206526:	48 b9 98 fb 21 04 80 	movabs $0x800421fb98,%rcx
  800420652d:	00 00 00 
  8004206530:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206537:	00 00 00 
  800420653a:	be d8 04 00 00       	mov    $0x4d8,%esi
  800420653f:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206546:	00 00 00 
  8004206549:	b8 00 00 00 00       	mov    $0x0,%eax
  800420654e:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206555:	00 00 00 
  8004206558:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  800420655b:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206562:	00 00 00 
  8004206565:	48 8b 00             	mov    (%rax),%rax
  8004206568:	be 00 10 00 00       	mov    $0x1000,%esi
  800420656d:	48 89 c7             	mov    %rax,%rdi
  8004206570:	48 b8 c5 58 20 04 80 	movabs $0x80042058c5,%rax
  8004206577:	00 00 00 
  800420657a:	ff d0                	callq  *%rax
  800420657c:	48 89 c3             	mov    %rax,%rbx
  800420657f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206583:	48 89 c7             	mov    %rax,%rdi
  8004206586:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  800420658d:	00 00 00 
  8004206590:	ff d0                	callq  *%rax
  8004206592:	48 39 c3             	cmp    %rax,%rbx
  8004206595:	74 35                	je     80042065cc <page_check+0xa8d>
  8004206597:	48 b9 d0 fb 21 04 80 	movabs $0x800421fbd0,%rcx
  800420659e:	00 00 00 
  80042065a1:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042065a8:	00 00 00 
  80042065ab:	be d9 04 00 00       	mov    $0x4d9,%esi
  80042065b0:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042065b7:	00 00 00 
  80042065ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80042065bf:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042065c6:	00 00 00 
  80042065c9:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  80042065cc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042065d0:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042065d4:	66 83 f8 02          	cmp    $0x2,%ax
  80042065d8:	74 35                	je     800420660f <page_check+0xad0>
  80042065da:	48 b9 00 fc 21 04 80 	movabs $0x800421fc00,%rcx
  80042065e1:	00 00 00 
  80042065e4:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042065eb:	00 00 00 
  80042065ee:	be da 04 00 00       	mov    $0x4da,%esi
  80042065f3:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042065fa:	00 00 00 
  80042065fd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206602:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206609:	00 00 00 
  800420660c:	41 ff d0             	callq  *%r8

	// pp3 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
	assert(!page_alloc(0));
  800420660f:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206614:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  800420661b:	00 00 00 
  800420661e:	ff d0                	callq  *%rax
  8004206620:	48 85 c0             	test   %rax,%rax
  8004206623:	74 35                	je     800420665a <page_check+0xb1b>
  8004206625:	48 b9 1f f7 21 04 80 	movabs $0x800421f71f,%rcx
  800420662c:	00 00 00 
  800420662f:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206636:	00 00 00 
  8004206639:	be de 04 00 00       	mov    $0x4de,%esi
  800420663e:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206645:	00 00 00 
  8004206648:	b8 00 00 00 00       	mov    $0x0,%eax
  800420664d:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206654:	00 00 00 
  8004206657:	41 ff d0             	callq  *%r8
	// check that pgdir_walk returns a pointer to the pte
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(PGSIZE)]));
  800420665a:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206661:	00 00 00 
  8004206664:	48 8b 00             	mov    (%rax),%rax
  8004206667:	48 8b 00             	mov    (%rax),%rax
  800420666a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206670:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  8004206674:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004206678:	48 c1 e8 0c          	shr    $0xc,%rax
  800420667c:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  800420667f:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004206682:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004206689:	00 00 00 
  800420668c:	48 8b 00             	mov    (%rax),%rax
  800420668f:	48 39 c2             	cmp    %rax,%rdx
  8004206692:	72 32                	jb     80042066c6 <page_check+0xb87>
  8004206694:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004206698:	48 89 c1             	mov    %rax,%rcx
  800420669b:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  80042066a2:	00 00 00 
  80042066a5:	be e0 04 00 00       	mov    $0x4e0,%esi
  80042066aa:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042066b1:	00 00 00 
  80042066b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042066b9:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042066c0:	00 00 00 
  80042066c3:	41 ff d0             	callq  *%r8
  80042066c6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042066cd:	00 00 00 
  80042066d0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042066d4:	48 01 d0             	add    %rdx,%rax
  80042066d7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde = KADDR(PTE_ADDR(pdpe[PDPE(PGSIZE)]));
  80042066db:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042066df:	48 8b 00             	mov    (%rax),%rax
  80042066e2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042066e8:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  80042066ec:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042066f0:	48 c1 e8 0c          	shr    $0xc,%rax
  80042066f4:	89 45 8c             	mov    %eax,-0x74(%rbp)
  80042066f7:	8b 55 8c             	mov    -0x74(%rbp),%edx
  80042066fa:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004206701:	00 00 00 
  8004206704:	48 8b 00             	mov    (%rax),%rax
  8004206707:	48 39 c2             	cmp    %rax,%rdx
  800420670a:	72 32                	jb     800420673e <page_check+0xbff>
  800420670c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004206710:	48 89 c1             	mov    %rax,%rcx
  8004206713:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  800420671a:	00 00 00 
  800420671d:	be e1 04 00 00       	mov    $0x4e1,%esi
  8004206722:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206729:	00 00 00 
  800420672c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206731:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206738:	00 00 00 
  800420673b:	41 ff d0             	callq  *%r8
  800420673e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206745:	00 00 00 
  8004206748:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420674c:	48 01 d0             	add    %rdx,%rax
  800420674f:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep = KADDR(PTE_ADDR(pde[PDX(PGSIZE)]));
  8004206753:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004206757:	48 8b 00             	mov    (%rax),%rax
  800420675a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206760:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004206767:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420676e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206772:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  8004206778:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  800420677e:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004206785:	00 00 00 
  8004206788:	48 8b 00             	mov    (%rax),%rax
  800420678b:	48 39 c2             	cmp    %rax,%rdx
  800420678e:	72 35                	jb     80042067c5 <page_check+0xc86>
  8004206790:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206797:	48 89 c1             	mov    %rax,%rcx
  800420679a:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  80042067a1:	00 00 00 
  80042067a4:	be e2 04 00 00       	mov    $0x4e2,%esi
  80042067a9:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042067b0:	00 00 00 
  80042067b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042067b8:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042067bf:	00 00 00 
  80042067c2:	41 ff d0             	callq  *%r8
  80042067c5:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042067cc:	00 00 00 
  80042067cf:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042067d6:	48 01 d0             	add    %rdx,%rax
  80042067d9:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	assert(pml4e_walk(boot_pml4e, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
  80042067e0:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  80042067e7:	00 00 00 
  80042067ea:	48 8b 00             	mov    (%rax),%rax
  80042067ed:	ba 00 00 00 00       	mov    $0x0,%edx
  80042067f2:	be 00 10 00 00       	mov    $0x1000,%esi
  80042067f7:	48 89 c7             	mov    %rax,%rdi
  80042067fa:	48 b8 73 30 20 04 80 	movabs $0x8004203073,%rax
  8004206801:	00 00 00 
  8004206804:	ff d0                	callq  *%rax
  8004206806:	48 89 c2             	mov    %rax,%rdx
  8004206809:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  8004206810:	48 83 c0 08          	add    $0x8,%rax
  8004206814:	48 39 c2             	cmp    %rax,%rdx
  8004206817:	74 35                	je     800420684e <page_check+0xd0f>
  8004206819:	48 b9 18 fc 21 04 80 	movabs $0x800421fc18,%rcx
  8004206820:	00 00 00 
  8004206823:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  800420682a:	00 00 00 
  800420682d:	be e3 04 00 00       	mov    $0x4e3,%esi
  8004206832:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206839:	00 00 00 
  800420683c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206841:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206848:	00 00 00 
  800420684b:	41 ff d0             	callq  *%r8

	// should be able to change permissions too.
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, PTE_U) == 0);
  800420684e:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206855:	00 00 00 
  8004206858:	48 8b 00             	mov    (%rax),%rax
  800420685b:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420685f:	b9 04 00 00 00       	mov    $0x4,%ecx
  8004206864:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206869:	48 89 c7             	mov    %rax,%rdi
  800420686c:	48 b8 7d 3a 20 04 80 	movabs $0x8004203a7d,%rax
  8004206873:	00 00 00 
  8004206876:	ff d0                	callq  *%rax
  8004206878:	85 c0                	test   %eax,%eax
  800420687a:	74 35                	je     80042068b1 <page_check+0xd72>
  800420687c:	48 b9 58 fc 21 04 80 	movabs $0x800421fc58,%rcx
  8004206883:	00 00 00 
  8004206886:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  800420688d:	00 00 00 
  8004206890:	be e6 04 00 00       	mov    $0x4e6,%esi
  8004206895:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  800420689c:	00 00 00 
  800420689f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042068a4:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042068ab:	00 00 00 
  80042068ae:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  80042068b1:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  80042068b8:	00 00 00 
  80042068bb:	48 8b 00             	mov    (%rax),%rax
  80042068be:	be 00 10 00 00       	mov    $0x1000,%esi
  80042068c3:	48 89 c7             	mov    %rax,%rdi
  80042068c6:	48 b8 c5 58 20 04 80 	movabs $0x80042058c5,%rax
  80042068cd:	00 00 00 
  80042068d0:	ff d0                	callq  *%rax
  80042068d2:	48 89 c3             	mov    %rax,%rbx
  80042068d5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042068d9:	48 89 c7             	mov    %rax,%rdi
  80042068dc:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  80042068e3:	00 00 00 
  80042068e6:	ff d0                	callq  *%rax
  80042068e8:	48 39 c3             	cmp    %rax,%rbx
  80042068eb:	74 35                	je     8004206922 <page_check+0xde3>
  80042068ed:	48 b9 d0 fb 21 04 80 	movabs $0x800421fbd0,%rcx
  80042068f4:	00 00 00 
  80042068f7:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042068fe:	00 00 00 
  8004206901:	be e7 04 00 00       	mov    $0x4e7,%esi
  8004206906:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  800420690d:	00 00 00 
  8004206910:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206915:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420691c:	00 00 00 
  800420691f:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004206922:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206926:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420692a:	66 83 f8 02          	cmp    $0x2,%ax
  800420692e:	74 35                	je     8004206965 <page_check+0xe26>
  8004206930:	48 b9 00 fc 21 04 80 	movabs $0x800421fc00,%rcx
  8004206937:	00 00 00 
  800420693a:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206941:	00 00 00 
  8004206944:	be e8 04 00 00       	mov    $0x4e8,%esi
  8004206949:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206950:	00 00 00 
  8004206953:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206958:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420695f:	00 00 00 
  8004206962:	41 ff d0             	callq  *%r8
	assert(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U);
  8004206965:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  800420696c:	00 00 00 
  800420696f:	48 8b 00             	mov    (%rax),%rax
  8004206972:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206977:	be 00 10 00 00       	mov    $0x1000,%esi
  800420697c:	48 89 c7             	mov    %rax,%rdi
  800420697f:	48 b8 73 30 20 04 80 	movabs $0x8004203073,%rax
  8004206986:	00 00 00 
  8004206989:	ff d0                	callq  *%rax
  800420698b:	48 8b 00             	mov    (%rax),%rax
  800420698e:	83 e0 04             	and    $0x4,%eax
  8004206991:	48 85 c0             	test   %rax,%rax
  8004206994:	75 35                	jne    80042069cb <page_check+0xe8c>
  8004206996:	48 b9 98 fc 21 04 80 	movabs $0x800421fc98,%rcx
  800420699d:	00 00 00 
  80042069a0:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042069a7:	00 00 00 
  80042069aa:	be e9 04 00 00       	mov    $0x4e9,%esi
  80042069af:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042069b6:	00 00 00 
  80042069b9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042069be:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042069c5:	00 00 00 
  80042069c8:	41 ff d0             	callq  *%r8
	assert(boot_pml4e[0] & PTE_U);
  80042069cb:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  80042069d2:	00 00 00 
  80042069d5:	48 8b 00             	mov    (%rax),%rax
  80042069d8:	48 8b 00             	mov    (%rax),%rax
  80042069db:	83 e0 04             	and    $0x4,%eax
  80042069de:	48 85 c0             	test   %rax,%rax
  80042069e1:	75 35                	jne    8004206a18 <page_check+0xed9>
  80042069e3:	48 b9 cb fc 21 04 80 	movabs $0x800421fccb,%rcx
  80042069ea:	00 00 00 
  80042069ed:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042069f4:	00 00 00 
  80042069f7:	be ea 04 00 00       	mov    $0x4ea,%esi
  80042069fc:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206a03:	00 00 00 
  8004206a06:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a0b:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206a12:	00 00 00 
  8004206a15:	41 ff d0             	callq  *%r8


	// should not be able to map at PTSIZE because need free page for page table
	assert(page_insert(boot_pml4e, pp0, (void*) PTSIZE, 0) < 0);
  8004206a18:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206a1f:	00 00 00 
  8004206a22:	48 8b 00             	mov    (%rax),%rax
  8004206a25:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004206a29:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206a2e:	ba 00 00 20 00       	mov    $0x200000,%edx
  8004206a33:	48 89 c7             	mov    %rax,%rdi
  8004206a36:	48 b8 7d 3a 20 04 80 	movabs $0x8004203a7d,%rax
  8004206a3d:	00 00 00 
  8004206a40:	ff d0                	callq  *%rax
  8004206a42:	85 c0                	test   %eax,%eax
  8004206a44:	78 35                	js     8004206a7b <page_check+0xf3c>
  8004206a46:	48 b9 e8 fc 21 04 80 	movabs $0x800421fce8,%rcx
  8004206a4d:	00 00 00 
  8004206a50:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206a57:	00 00 00 
  8004206a5a:	be ee 04 00 00       	mov    $0x4ee,%esi
  8004206a5f:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206a66:	00 00 00 
  8004206a69:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a6e:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206a75:	00 00 00 
  8004206a78:	41 ff d0             	callq  *%r8

	// insert pp1 at PGSIZE (replacing pp3)
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004206a7b:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206a82:	00 00 00 
  8004206a85:	48 8b 00             	mov    (%rax),%rax
  8004206a88:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206a8c:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206a91:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206a96:	48 89 c7             	mov    %rax,%rdi
  8004206a99:	48 b8 7d 3a 20 04 80 	movabs $0x8004203a7d,%rax
  8004206aa0:	00 00 00 
  8004206aa3:	ff d0                	callq  *%rax
  8004206aa5:	85 c0                	test   %eax,%eax
  8004206aa7:	74 35                	je     8004206ade <page_check+0xf9f>
  8004206aa9:	48 b9 20 fd 21 04 80 	movabs $0x800421fd20,%rcx
  8004206ab0:	00 00 00 
  8004206ab3:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206aba:	00 00 00 
  8004206abd:	be f1 04 00 00       	mov    $0x4f1,%esi
  8004206ac2:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206ac9:	00 00 00 
  8004206acc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ad1:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206ad8:	00 00 00 
  8004206adb:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U));
  8004206ade:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206ae5:	00 00 00 
  8004206ae8:	48 8b 00             	mov    (%rax),%rax
  8004206aeb:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206af0:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206af5:	48 89 c7             	mov    %rax,%rdi
  8004206af8:	48 b8 73 30 20 04 80 	movabs $0x8004203073,%rax
  8004206aff:	00 00 00 
  8004206b02:	ff d0                	callq  *%rax
  8004206b04:	48 8b 00             	mov    (%rax),%rax
  8004206b07:	83 e0 04             	and    $0x4,%eax
  8004206b0a:	48 85 c0             	test   %rax,%rax
  8004206b0d:	74 35                	je     8004206b44 <page_check+0x1005>
  8004206b0f:	48 b9 58 fd 21 04 80 	movabs $0x800421fd58,%rcx
  8004206b16:	00 00 00 
  8004206b19:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206b20:	00 00 00 
  8004206b23:	be f2 04 00 00       	mov    $0x4f2,%esi
  8004206b28:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206b2f:	00 00 00 
  8004206b32:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b37:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206b3e:	00 00 00 
  8004206b41:	41 ff d0             	callq  *%r8

	// should have pp1 at both 0 and PGSIZE
	assert(check_va2pa(boot_pml4e, 0) == page2pa(pp1));
  8004206b44:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206b4b:	00 00 00 
  8004206b4e:	48 8b 00             	mov    (%rax),%rax
  8004206b51:	be 00 00 00 00       	mov    $0x0,%esi
  8004206b56:	48 89 c7             	mov    %rax,%rdi
  8004206b59:	48 b8 c5 58 20 04 80 	movabs $0x80042058c5,%rax
  8004206b60:	00 00 00 
  8004206b63:	ff d0                	callq  *%rax
  8004206b65:	48 89 c3             	mov    %rax,%rbx
  8004206b68:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206b6c:	48 89 c7             	mov    %rax,%rdi
  8004206b6f:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  8004206b76:	00 00 00 
  8004206b79:	ff d0                	callq  *%rax
  8004206b7b:	48 39 c3             	cmp    %rax,%rbx
  8004206b7e:	74 35                	je     8004206bb5 <page_check+0x1076>
  8004206b80:	48 b9 90 fd 21 04 80 	movabs $0x800421fd90,%rcx
  8004206b87:	00 00 00 
  8004206b8a:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206b91:	00 00 00 
  8004206b94:	be f5 04 00 00       	mov    $0x4f5,%esi
  8004206b99:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206ba0:	00 00 00 
  8004206ba3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ba8:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206baf:	00 00 00 
  8004206bb2:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206bb5:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206bbc:	00 00 00 
  8004206bbf:	48 8b 00             	mov    (%rax),%rax
  8004206bc2:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206bc7:	48 89 c7             	mov    %rax,%rdi
  8004206bca:	48 b8 c5 58 20 04 80 	movabs $0x80042058c5,%rax
  8004206bd1:	00 00 00 
  8004206bd4:	ff d0                	callq  *%rax
  8004206bd6:	48 89 c3             	mov    %rax,%rbx
  8004206bd9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206bdd:	48 89 c7             	mov    %rax,%rdi
  8004206be0:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  8004206be7:	00 00 00 
  8004206bea:	ff d0                	callq  *%rax
  8004206bec:	48 39 c3             	cmp    %rax,%rbx
  8004206bef:	74 35                	je     8004206c26 <page_check+0x10e7>
  8004206bf1:	48 b9 c0 fd 21 04 80 	movabs $0x800421fdc0,%rcx
  8004206bf8:	00 00 00 
  8004206bfb:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206c02:	00 00 00 
  8004206c05:	be f6 04 00 00       	mov    $0x4f6,%esi
  8004206c0a:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206c11:	00 00 00 
  8004206c14:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c19:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206c20:	00 00 00 
  8004206c23:	41 ff d0             	callq  *%r8
	// ... and ref counts should reflect this
	assert(pp1->pp_ref == 2);
  8004206c26:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206c2a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206c2e:	66 83 f8 02          	cmp    $0x2,%ax
  8004206c32:	74 35                	je     8004206c69 <page_check+0x112a>
  8004206c34:	48 b9 f0 fd 21 04 80 	movabs $0x800421fdf0,%rcx
  8004206c3b:	00 00 00 
  8004206c3e:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206c45:	00 00 00 
  8004206c48:	be f8 04 00 00       	mov    $0x4f8,%esi
  8004206c4d:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206c54:	00 00 00 
  8004206c57:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c5c:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206c63:	00 00 00 
  8004206c66:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206c69:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206c6d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206c71:	66 83 f8 01          	cmp    $0x1,%ax
  8004206c75:	74 35                	je     8004206cac <page_check+0x116d>
  8004206c77:	48 b9 01 fe 21 04 80 	movabs $0x800421fe01,%rcx
  8004206c7e:	00 00 00 
  8004206c81:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206c88:	00 00 00 
  8004206c8b:	be f9 04 00 00       	mov    $0x4f9,%esi
  8004206c90:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206c97:	00 00 00 
  8004206c9a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c9f:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206ca6:	00 00 00 
  8004206ca9:	41 ff d0             	callq  *%r8


	// unmapping pp1 at 0 should keep pp1 at PGSIZE
	page_remove(boot_pml4e, 0x0);
  8004206cac:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206cb3:	00 00 00 
  8004206cb6:	48 8b 00             	mov    (%rax),%rax
  8004206cb9:	be 00 00 00 00       	mov    $0x0,%esi
  8004206cbe:	48 89 c7             	mov    %rax,%rdi
  8004206cc1:	48 b8 7c 3e 20 04 80 	movabs $0x8004203e7c,%rax
  8004206cc8:	00 00 00 
  8004206ccb:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206ccd:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206cd4:	00 00 00 
  8004206cd7:	48 8b 00             	mov    (%rax),%rax
  8004206cda:	be 00 00 00 00       	mov    $0x0,%esi
  8004206cdf:	48 89 c7             	mov    %rax,%rdi
  8004206ce2:	48 b8 c5 58 20 04 80 	movabs $0x80042058c5,%rax
  8004206ce9:	00 00 00 
  8004206cec:	ff d0                	callq  *%rax
  8004206cee:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206cf2:	74 35                	je     8004206d29 <page_check+0x11ea>
  8004206cf4:	48 b9 18 fe 21 04 80 	movabs $0x800421fe18,%rcx
  8004206cfb:	00 00 00 
  8004206cfe:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206d05:	00 00 00 
  8004206d08:	be fe 04 00 00       	mov    $0x4fe,%esi
  8004206d0d:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206d14:	00 00 00 
  8004206d17:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d1c:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206d23:	00 00 00 
  8004206d26:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206d29:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206d30:	00 00 00 
  8004206d33:	48 8b 00             	mov    (%rax),%rax
  8004206d36:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206d3b:	48 89 c7             	mov    %rax,%rdi
  8004206d3e:	48 b8 c5 58 20 04 80 	movabs $0x80042058c5,%rax
  8004206d45:	00 00 00 
  8004206d48:	ff d0                	callq  *%rax
  8004206d4a:	48 89 c3             	mov    %rax,%rbx
  8004206d4d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206d51:	48 89 c7             	mov    %rax,%rdi
  8004206d54:	48 b8 8a 1b 20 04 80 	movabs $0x8004201b8a,%rax
  8004206d5b:	00 00 00 
  8004206d5e:	ff d0                	callq  *%rax
  8004206d60:	48 39 c3             	cmp    %rax,%rbx
  8004206d63:	74 35                	je     8004206d9a <page_check+0x125b>
  8004206d65:	48 b9 c0 fd 21 04 80 	movabs $0x800421fdc0,%rcx
  8004206d6c:	00 00 00 
  8004206d6f:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206d76:	00 00 00 
  8004206d79:	be ff 04 00 00       	mov    $0x4ff,%esi
  8004206d7e:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206d85:	00 00 00 
  8004206d88:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d8d:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206d94:	00 00 00 
  8004206d97:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004206d9a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206d9e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206da2:	66 83 f8 01          	cmp    $0x1,%ax
  8004206da6:	74 35                	je     8004206ddd <page_check+0x129e>
  8004206da8:	48 b9 65 fb 21 04 80 	movabs $0x800421fb65,%rcx
  8004206daf:	00 00 00 
  8004206db2:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206db9:	00 00 00 
  8004206dbc:	be 00 05 00 00       	mov    $0x500,%esi
  8004206dc1:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206dc8:	00 00 00 
  8004206dcb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206dd0:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206dd7:	00 00 00 
  8004206dda:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206ddd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206de1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206de5:	66 83 f8 01          	cmp    $0x1,%ax
  8004206de9:	74 35                	je     8004206e20 <page_check+0x12e1>
  8004206deb:	48 b9 01 fe 21 04 80 	movabs $0x800421fe01,%rcx
  8004206df2:	00 00 00 
  8004206df5:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206dfc:	00 00 00 
  8004206dff:	be 01 05 00 00       	mov    $0x501,%esi
  8004206e04:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206e0b:	00 00 00 
  8004206e0e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e13:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206e1a:	00 00 00 
  8004206e1d:	41 ff d0             	callq  *%r8

	// Test re-inserting pp1 at PGSIZE.
	// Thanks to Varun Agrawal for suggesting this test case.
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004206e20:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206e27:	00 00 00 
  8004206e2a:	48 8b 00             	mov    (%rax),%rax
  8004206e2d:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206e31:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206e36:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206e3b:	48 89 c7             	mov    %rax,%rdi
  8004206e3e:	48 b8 7d 3a 20 04 80 	movabs $0x8004203a7d,%rax
  8004206e45:	00 00 00 
  8004206e48:	ff d0                	callq  *%rax
  8004206e4a:	85 c0                	test   %eax,%eax
  8004206e4c:	74 35                	je     8004206e83 <page_check+0x1344>
  8004206e4e:	48 b9 20 fd 21 04 80 	movabs $0x800421fd20,%rcx
  8004206e55:	00 00 00 
  8004206e58:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206e5f:	00 00 00 
  8004206e62:	be 05 05 00 00       	mov    $0x505,%esi
  8004206e67:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206e6e:	00 00 00 
  8004206e71:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e76:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206e7d:	00 00 00 
  8004206e80:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref);
  8004206e83:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206e87:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206e8b:	66 85 c0             	test   %ax,%ax
  8004206e8e:	75 35                	jne    8004206ec5 <page_check+0x1386>
  8004206e90:	48 b9 3b fe 21 04 80 	movabs $0x800421fe3b,%rcx
  8004206e97:	00 00 00 
  8004206e9a:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206ea1:	00 00 00 
  8004206ea4:	be 06 05 00 00       	mov    $0x506,%esi
  8004206ea9:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206eb0:	00 00 00 
  8004206eb3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206eb8:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206ebf:	00 00 00 
  8004206ec2:	41 ff d0             	callq  *%r8
	assert(pp1->pp_link == NULL);
  8004206ec5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206ec9:	48 8b 00             	mov    (%rax),%rax
  8004206ecc:	48 85 c0             	test   %rax,%rax
  8004206ecf:	74 35                	je     8004206f06 <page_check+0x13c7>
  8004206ed1:	48 b9 47 fe 21 04 80 	movabs $0x800421fe47,%rcx
  8004206ed8:	00 00 00 
  8004206edb:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206ee2:	00 00 00 
  8004206ee5:	be 07 05 00 00       	mov    $0x507,%esi
  8004206eea:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206ef1:	00 00 00 
  8004206ef4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ef9:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206f00:	00 00 00 
  8004206f03:	41 ff d0             	callq  *%r8

	// unmapping pp1 at PGSIZE should free it
	page_remove(boot_pml4e, (void*) PGSIZE);
  8004206f06:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206f0d:	00 00 00 
  8004206f10:	48 8b 00             	mov    (%rax),%rax
  8004206f13:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206f18:	48 89 c7             	mov    %rax,%rdi
  8004206f1b:	48 b8 7c 3e 20 04 80 	movabs $0x8004203e7c,%rax
  8004206f22:	00 00 00 
  8004206f25:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206f27:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206f2e:	00 00 00 
  8004206f31:	48 8b 00             	mov    (%rax),%rax
  8004206f34:	be 00 00 00 00       	mov    $0x0,%esi
  8004206f39:	48 89 c7             	mov    %rax,%rdi
  8004206f3c:	48 b8 c5 58 20 04 80 	movabs $0x80042058c5,%rax
  8004206f43:	00 00 00 
  8004206f46:	ff d0                	callq  *%rax
  8004206f48:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206f4c:	74 35                	je     8004206f83 <page_check+0x1444>
  8004206f4e:	48 b9 18 fe 21 04 80 	movabs $0x800421fe18,%rcx
  8004206f55:	00 00 00 
  8004206f58:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206f5f:	00 00 00 
  8004206f62:	be 0b 05 00 00       	mov    $0x50b,%esi
  8004206f67:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206f6e:	00 00 00 
  8004206f71:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f76:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206f7d:	00 00 00 
  8004206f80:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == ~0);
  8004206f83:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004206f8a:	00 00 00 
  8004206f8d:	48 8b 00             	mov    (%rax),%rax
  8004206f90:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206f95:	48 89 c7             	mov    %rax,%rdi
  8004206f98:	48 b8 c5 58 20 04 80 	movabs $0x80042058c5,%rax
  8004206f9f:	00 00 00 
  8004206fa2:	ff d0                	callq  *%rax
  8004206fa4:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206fa8:	74 35                	je     8004206fdf <page_check+0x14a0>
  8004206faa:	48 b9 60 fe 21 04 80 	movabs $0x800421fe60,%rcx
  8004206fb1:	00 00 00 
  8004206fb4:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206fbb:	00 00 00 
  8004206fbe:	be 0c 05 00 00       	mov    $0x50c,%esi
  8004206fc3:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004206fca:	00 00 00 
  8004206fcd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206fd2:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004206fd9:	00 00 00 
  8004206fdc:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  8004206fdf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206fe3:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206fe7:	66 85 c0             	test   %ax,%ax
  8004206fea:	74 35                	je     8004207021 <page_check+0x14e2>
  8004206fec:	48 b9 86 fe 21 04 80 	movabs $0x800421fe86,%rcx
  8004206ff3:	00 00 00 
  8004206ff6:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004206ffd:	00 00 00 
  8004207000:	be 0d 05 00 00       	mov    $0x50d,%esi
  8004207005:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  800420700c:	00 00 00 
  800420700f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207014:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420701b:	00 00 00 
  800420701e:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004207021:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207025:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207029:	66 83 f8 01          	cmp    $0x1,%ax
  800420702d:	74 35                	je     8004207064 <page_check+0x1525>
  800420702f:	48 b9 01 fe 21 04 80 	movabs $0x800421fe01,%rcx
  8004207036:	00 00 00 
  8004207039:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004207040:	00 00 00 
  8004207043:	be 0e 05 00 00       	mov    $0x50e,%esi
  8004207048:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  800420704f:	00 00 00 
  8004207052:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207057:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420705e:	00 00 00 
  8004207061:	41 ff d0             	callq  *%r8
	page_remove(boot_pgdir, 0x0);
	assert(pp2->pp_ref == 0);
#endif

	// forcibly take pp3 back
	struct PageInfo *pp_l1 = pa2page(PTE_ADDR(boot_pml4e[0]));
  8004207064:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  800420706b:	00 00 00 
  800420706e:	48 8b 00             	mov    (%rax),%rax
  8004207071:	48 8b 00             	mov    (%rax),%rax
  8004207074:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420707a:	48 89 c7             	mov    %rax,%rdi
  800420707d:	48 b8 af 1b 20 04 80 	movabs $0x8004201baf,%rax
  8004207084:	00 00 00 
  8004207087:	ff d0                	callq  *%rax
  8004207089:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
	boot_pml4e[0] = 0;
  8004207090:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004207097:	00 00 00 
  800420709a:	48 8b 00             	mov    (%rax),%rax
  800420709d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	assert(pp3->pp_ref == 1);
  80042070a4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042070a8:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042070ac:	66 83 f8 01          	cmp    $0x1,%ax
  80042070b0:	74 35                	je     80042070e7 <page_check+0x15a8>
  80042070b2:	48 b9 01 fe 21 04 80 	movabs $0x800421fe01,%rcx
  80042070b9:	00 00 00 
  80042070bc:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042070c3:	00 00 00 
  80042070c6:	be 24 05 00 00       	mov    $0x524,%esi
  80042070cb:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042070d2:	00 00 00 
  80042070d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042070da:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042070e1:	00 00 00 
  80042070e4:	41 ff d0             	callq  *%r8
	page_decref(pp_l1);
  80042070e7:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042070ee:	48 89 c7             	mov    %rax,%rdi
  80042070f1:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  80042070f8:	00 00 00 
  80042070fb:	ff d0                	callq  *%rax
	// check pointer arithmetic in pml4e_walk
	if (pp_l1 != pp3) page_decref(pp3);
  80042070fd:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004207104:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004207108:	74 13                	je     800420711d <page_check+0x15de>
  800420710a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420710e:	48 89 c7             	mov    %rax,%rdi
  8004207111:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  8004207118:	00 00 00 
  800420711b:	ff d0                	callq  *%rax
	if (pp_l1 != pp2) page_decref(pp2);
  800420711d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004207124:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004207128:	74 13                	je     800420713d <page_check+0x15fe>
  800420712a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420712e:	48 89 c7             	mov    %rax,%rdi
  8004207131:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  8004207138:	00 00 00 
  800420713b:	ff d0                	callq  *%rax
	if (pp_l1 != pp0) page_decref(pp0);
  800420713d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004207144:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004207148:	74 13                	je     800420715d <page_check+0x161e>
  800420714a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420714e:	48 89 c7             	mov    %rax,%rdi
  8004207151:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  8004207158:	00 00 00 
  800420715b:	ff d0                	callq  *%rax
	va = (void*)(PGSIZE * 100);
  800420715d:	48 c7 85 60 ff ff ff 	movq   $0x64000,-0xa0(%rbp)
  8004207164:	00 40 06 00 
	ptep = pml4e_walk(boot_pml4e, va, 1);
  8004207168:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  800420716f:	00 00 00 
  8004207172:	48 8b 00             	mov    (%rax),%rax
  8004207175:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420717c:	ba 01 00 00 00       	mov    $0x1,%edx
  8004207181:	48 89 ce             	mov    %rcx,%rsi
  8004207184:	48 89 c7             	mov    %rax,%rdi
  8004207187:	48 b8 73 30 20 04 80 	movabs $0x8004203073,%rax
  800420718e:	00 00 00 
  8004207191:	ff d0                	callq  *%rax
  8004207193:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(va)]));
  800420719a:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  80042071a1:	00 00 00 
  80042071a4:	48 8b 00             	mov    (%rax),%rax
  80042071a7:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042071ae:	48 c1 ea 27          	shr    $0x27,%rdx
  80042071b2:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  80042071b8:	48 c1 e2 03          	shl    $0x3,%rdx
  80042071bc:	48 01 d0             	add    %rdx,%rax
  80042071bf:	48 8b 00             	mov    (%rax),%rax
  80042071c2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042071c8:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  80042071cf:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042071d6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042071da:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
  80042071e0:	8b 95 54 ff ff ff    	mov    -0xac(%rbp),%edx
  80042071e6:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  80042071ed:	00 00 00 
  80042071f0:	48 8b 00             	mov    (%rax),%rax
  80042071f3:	48 39 c2             	cmp    %rax,%rdx
  80042071f6:	72 35                	jb     800420722d <page_check+0x16ee>
  80042071f8:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042071ff:	48 89 c1             	mov    %rax,%rcx
  8004207202:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  8004207209:	00 00 00 
  800420720c:	be 2c 05 00 00       	mov    $0x52c,%esi
  8004207211:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004207218:	00 00 00 
  800420721b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207220:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004207227:	00 00 00 
  800420722a:	41 ff d0             	callq  *%r8
  800420722d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207234:	00 00 00 
  8004207237:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420723e:	48 01 d0             	add    %rdx,%rax
  8004207241:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004207245:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420724c:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004207250:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004207255:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420725c:	00 
  800420725d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004207261:	48 01 d0             	add    %rdx,%rax
  8004207264:	48 8b 00             	mov    (%rax),%rax
  8004207267:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420726d:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
  8004207274:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420727b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420727f:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
  8004207285:	8b 95 44 ff ff ff    	mov    -0xbc(%rbp),%edx
  800420728b:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004207292:	00 00 00 
  8004207295:	48 8b 00             	mov    (%rax),%rax
  8004207298:	48 39 c2             	cmp    %rax,%rdx
  800420729b:	72 35                	jb     80042072d2 <page_check+0x1793>
  800420729d:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042072a4:	48 89 c1             	mov    %rax,%rcx
  80042072a7:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  80042072ae:	00 00 00 
  80042072b1:	be 2d 05 00 00       	mov    $0x52d,%esi
  80042072b6:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042072bd:	00 00 00 
  80042072c0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042072c5:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042072cc:	00 00 00 
  80042072cf:	41 ff d0             	callq  *%r8
  80042072d2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042072d9:	00 00 00 
  80042072dc:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042072e3:	48 01 d0             	add    %rdx,%rax
  80042072e6:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep1 = KADDR(PTE_ADDR(pde[PDX(va)]));
  80042072ea:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042072f1:	48 c1 e8 15          	shr    $0x15,%rax
  80042072f5:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042072fa:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207301:	00 
  8004207302:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004207306:	48 01 d0             	add    %rdx,%rax
  8004207309:	48 8b 00             	mov    (%rax),%rax
  800420730c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207312:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004207319:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004207320:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207324:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%rbp)
  800420732a:	8b 95 34 ff ff ff    	mov    -0xcc(%rbp),%edx
  8004207330:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004207337:	00 00 00 
  800420733a:	48 8b 00             	mov    (%rax),%rax
  800420733d:	48 39 c2             	cmp    %rax,%rdx
  8004207340:	72 35                	jb     8004207377 <page_check+0x1838>
  8004207342:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004207349:	48 89 c1             	mov    %rax,%rcx
  800420734c:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  8004207353:	00 00 00 
  8004207356:	be 2e 05 00 00       	mov    $0x52e,%esi
  800420735b:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004207362:	00 00 00 
  8004207365:	b8 00 00 00 00       	mov    $0x0,%eax
  800420736a:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004207371:	00 00 00 
  8004207374:	41 ff d0             	callq  *%r8
  8004207377:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420737e:	00 00 00 
  8004207381:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004207388:	48 01 d0             	add    %rdx,%rax
  800420738b:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	assert(ptep == ptep1 + PTX(va));
  8004207392:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004207399:	48 c1 e8 0c          	shr    $0xc,%rax
  800420739d:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042073a2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042073a9:	00 
  80042073aa:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042073b1:	48 01 c2             	add    %rax,%rdx
  80042073b4:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  80042073bb:	48 39 c2             	cmp    %rax,%rdx
  80042073be:	74 35                	je     80042073f5 <page_check+0x18b6>
  80042073c0:	48 b9 97 fe 21 04 80 	movabs $0x800421fe97,%rcx
  80042073c7:	00 00 00 
  80042073ca:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042073d1:	00 00 00 
  80042073d4:	be 2f 05 00 00       	mov    $0x52f,%esi
  80042073d9:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042073e0:	00 00 00 
  80042073e3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042073e8:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042073ef:	00 00 00 
  80042073f2:	41 ff d0             	callq  *%r8

	// check that new page tables get cleared
	memset(page2kva(pp4), 0xFF, PGSIZE);
  80042073f5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042073f9:	48 89 c7             	mov    %rax,%rdi
  80042073fc:	48 b8 20 1c 20 04 80 	movabs $0x8004201c20,%rax
  8004207403:	00 00 00 
  8004207406:	ff d0                	callq  *%rax
  8004207408:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420740d:	be ff 00 00 00       	mov    $0xff,%esi
  8004207412:	48 89 c7             	mov    %rax,%rdi
  8004207415:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  800420741c:	00 00 00 
  800420741f:	ff d0                	callq  *%rax
	pml4e_walk(boot_pml4e, 0x0, 1);
  8004207421:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004207428:	00 00 00 
  800420742b:	48 8b 00             	mov    (%rax),%rax
  800420742e:	ba 01 00 00 00       	mov    $0x1,%edx
  8004207433:	be 00 00 00 00       	mov    $0x0,%esi
  8004207438:	48 89 c7             	mov    %rax,%rdi
  800420743b:	48 b8 73 30 20 04 80 	movabs $0x8004203073,%rax
  8004207442:	00 00 00 
  8004207445:	ff d0                	callq  *%rax
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
  8004207447:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  800420744e:	00 00 00 
  8004207451:	48 8b 00             	mov    (%rax),%rax
  8004207454:	48 8b 00             	mov    (%rax),%rax
  8004207457:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420745d:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  8004207464:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  800420746b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420746f:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
  8004207475:	8b 95 1c ff ff ff    	mov    -0xe4(%rbp),%edx
  800420747b:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004207482:	00 00 00 
  8004207485:	48 8b 00             	mov    (%rax),%rax
  8004207488:	48 39 c2             	cmp    %rax,%rdx
  800420748b:	72 35                	jb     80042074c2 <page_check+0x1983>
  800420748d:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  8004207494:	48 89 c1             	mov    %rax,%rcx
  8004207497:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  800420749e:	00 00 00 
  80042074a1:	be 34 05 00 00       	mov    $0x534,%esi
  80042074a6:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042074ad:	00 00 00 
  80042074b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042074b5:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042074bc:	00 00 00 
  80042074bf:	41 ff d0             	callq  *%r8
  80042074c2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042074c9:	00 00 00 
  80042074cc:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  80042074d3:	48 01 d0             	add    %rdx,%rax
  80042074d6:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[0]));
  80042074da:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042074de:	48 8b 00             	mov    (%rax),%rax
  80042074e1:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042074e7:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  80042074ee:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042074f5:	48 c1 e8 0c          	shr    $0xc,%rax
  80042074f9:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
  80042074ff:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  8004207505:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  800420750c:	00 00 00 
  800420750f:	48 8b 00             	mov    (%rax),%rax
  8004207512:	48 39 c2             	cmp    %rax,%rdx
  8004207515:	72 35                	jb     800420754c <page_check+0x1a0d>
  8004207517:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  800420751e:	48 89 c1             	mov    %rax,%rcx
  8004207521:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  8004207528:	00 00 00 
  800420752b:	be 35 05 00 00       	mov    $0x535,%esi
  8004207530:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004207537:	00 00 00 
  800420753a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420753f:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004207546:	00 00 00 
  8004207549:	41 ff d0             	callq  *%r8
  800420754c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207553:	00 00 00 
  8004207556:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  800420755d:	48 01 d0             	add    %rdx,%rax
  8004207560:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep  = KADDR(PTE_ADDR(pde[0]));
  8004207564:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004207568:	48 8b 00             	mov    (%rax),%rax
  800420756b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207571:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  8004207578:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  800420757f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207583:	89 85 fc fe ff ff    	mov    %eax,-0x104(%rbp)
  8004207589:	8b 95 fc fe ff ff    	mov    -0x104(%rbp),%edx
  800420758f:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004207596:	00 00 00 
  8004207599:	48 8b 00             	mov    (%rax),%rax
  800420759c:	48 39 c2             	cmp    %rax,%rdx
  800420759f:	72 35                	jb     80042075d6 <page_check+0x1a97>
  80042075a1:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  80042075a8:	48 89 c1             	mov    %rax,%rcx
  80042075ab:	48 ba f8 f1 21 04 80 	movabs $0x800421f1f8,%rdx
  80042075b2:	00 00 00 
  80042075b5:	be 36 05 00 00       	mov    $0x536,%esi
  80042075ba:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042075c1:	00 00 00 
  80042075c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042075c9:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042075d0:	00 00 00 
  80042075d3:	41 ff d0             	callq  *%r8
  80042075d6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042075dd:	00 00 00 
  80042075e0:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  80042075e7:	48 01 d0             	add    %rdx,%rax
  80042075ea:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	for(i=0; i<NPTENTRIES; i++)
  80042075f1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042075f8:	eb 58                	jmp    8004207652 <page_check+0x1b13>
		assert((ptep[i] & PTE_P) == 0);
  80042075fa:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  8004207601:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004207604:	48 63 d2             	movslq %edx,%rdx
  8004207607:	48 c1 e2 03          	shl    $0x3,%rdx
  800420760b:	48 01 d0             	add    %rdx,%rax
  800420760e:	48 8b 00             	mov    (%rax),%rax
  8004207611:	83 e0 01             	and    $0x1,%eax
  8004207614:	48 85 c0             	test   %rax,%rax
  8004207617:	74 35                	je     800420764e <page_check+0x1b0f>
  8004207619:	48 b9 af fe 21 04 80 	movabs $0x800421feaf,%rcx
  8004207620:	00 00 00 
  8004207623:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  800420762a:	00 00 00 
  800420762d:	be 38 05 00 00       	mov    $0x538,%esi
  8004207632:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004207639:	00 00 00 
  800420763c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207641:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004207648:	00 00 00 
  800420764b:	41 ff d0             	callq  *%r8
	memset(page2kva(pp4), 0xFF, PGSIZE);
	pml4e_walk(boot_pml4e, 0x0, 1);
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
	pde  = KADDR(PTE_ADDR(pdpe[0]));
	ptep  = KADDR(PTE_ADDR(pde[0]));
	for(i=0; i<NPTENTRIES; i++)
  800420764e:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004207652:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
  8004207659:	7e 9f                	jle    80042075fa <page_check+0x1abb>
		assert((ptep[i] & PTE_P) == 0);
	boot_pml4e[0] = 0;
  800420765b:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004207662:	00 00 00 
  8004207665:	48 8b 00             	mov    (%rax),%rax
  8004207668:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// give free list back
	page_free_list = fl;
  800420766f:	48 b8 38 d2 4d 04 80 	movabs $0x80044dd238,%rax
  8004207676:	00 00 00 
  8004207679:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420767d:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_decref(pp0);
  8004207680:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207684:	48 89 c7             	mov    %rax,%rdi
  8004207687:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  800420768e:	00 00 00 
  8004207691:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004207693:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207697:	48 89 c7             	mov    %rax,%rdi
  800420769a:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  80042076a1:	00 00 00 
  80042076a4:	ff d0                	callq  *%rax
	page_decref(pp3);
  80042076a6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042076aa:	48 89 c7             	mov    %rax,%rdi
  80042076ad:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  80042076b4:	00 00 00 
  80042076b7:	ff d0                	callq  *%rax

	// Triple check that we got the ref counts right
	assert(pp0->pp_ref == 0);
  80042076b9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042076bd:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042076c1:	66 85 c0             	test   %ax,%ax
  80042076c4:	74 35                	je     80042076fb <page_check+0x1bbc>
  80042076c6:	48 b9 c6 fe 21 04 80 	movabs $0x800421fec6,%rcx
  80042076cd:	00 00 00 
  80042076d0:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042076d7:	00 00 00 
  80042076da:	be 44 05 00 00       	mov    $0x544,%esi
  80042076df:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042076e6:	00 00 00 
  80042076e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042076ee:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042076f5:	00 00 00 
  80042076f8:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  80042076fb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042076ff:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207703:	66 85 c0             	test   %ax,%ax
  8004207706:	74 35                	je     800420773d <page_check+0x1bfe>
  8004207708:	48 b9 86 fe 21 04 80 	movabs $0x800421fe86,%rcx
  800420770f:	00 00 00 
  8004207712:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004207719:	00 00 00 
  800420771c:	be 45 05 00 00       	mov    $0x545,%esi
  8004207721:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004207728:	00 00 00 
  800420772b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207730:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004207737:	00 00 00 
  800420773a:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 0);
  800420773d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207741:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207745:	66 85 c0             	test   %ax,%ax
  8004207748:	74 35                	je     800420777f <page_check+0x1c40>
  800420774a:	48 b9 d7 fe 21 04 80 	movabs $0x800421fed7,%rcx
  8004207751:	00 00 00 
  8004207754:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  800420775b:	00 00 00 
  800420775e:	be 46 05 00 00       	mov    $0x546,%esi
  8004207763:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  800420776a:	00 00 00 
  800420776d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207772:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004207779:	00 00 00 
  800420777c:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 0);
  800420777f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207783:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207787:	66 85 c0             	test   %ax,%ax
  800420778a:	74 35                	je     80042077c1 <page_check+0x1c82>
  800420778c:	48 b9 e8 fe 21 04 80 	movabs $0x800421fee8,%rcx
  8004207793:	00 00 00 
  8004207796:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  800420779d:	00 00 00 
  80042077a0:	be 47 05 00 00       	mov    $0x547,%esi
  80042077a5:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042077ac:	00 00 00 
  80042077af:	b8 00 00 00 00       	mov    $0x0,%eax
  80042077b4:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042077bb:	00 00 00 
  80042077be:	41 ff d0             	callq  *%r8
	assert(pp4->pp_ref == 0);
  80042077c1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042077c5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042077c9:	66 85 c0             	test   %ax,%ax
  80042077cc:	74 35                	je     8004207803 <page_check+0x1cc4>
  80042077ce:	48 b9 f9 fe 21 04 80 	movabs $0x800421fef9,%rcx
  80042077d5:	00 00 00 
  80042077d8:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042077df:	00 00 00 
  80042077e2:	be 48 05 00 00       	mov    $0x548,%esi
  80042077e7:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042077ee:	00 00 00 
  80042077f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042077f6:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042077fd:	00 00 00 
  8004207800:	41 ff d0             	callq  *%r8
	assert(pp5->pp_ref == 0);
  8004207803:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207807:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420780b:	66 85 c0             	test   %ax,%ax
  800420780e:	74 35                	je     8004207845 <page_check+0x1d06>
  8004207810:	48 b9 0a ff 21 04 80 	movabs $0x800421ff0a,%rcx
  8004207817:	00 00 00 
  800420781a:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004207821:	00 00 00 
  8004207824:	be 49 05 00 00       	mov    $0x549,%esi
  8004207829:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004207830:	00 00 00 
  8004207833:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207838:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420783f:	00 00 00 
  8004207842:	41 ff d0             	callq  *%r8


	// test mmio_map_region
	mm1 = (uintptr_t) mmio_map_region(0, 4097);
  8004207845:	be 01 10 00 00       	mov    $0x1001,%esi
  800420784a:	bf 00 00 00 00       	mov    $0x0,%edi
  800420784f:	48 b8 c0 3f 20 04 80 	movabs $0x8004203fc0,%rax
  8004207856:	00 00 00 
  8004207859:	ff d0                	callq  *%rax
  800420785b:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	mm2 = (uintptr_t) mmio_map_region(0, 4096);
  8004207862:	be 00 10 00 00       	mov    $0x1000,%esi
  8004207867:	bf 00 00 00 00       	mov    $0x0,%edi
  800420786c:	48 b8 c0 3f 20 04 80 	movabs $0x8004203fc0,%rax
  8004207873:	00 00 00 
  8004207876:	ff d0                	callq  *%rax
  8004207878:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	// check that they're in the right region
	assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
  800420787f:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004207886:	00 00 00 
  8004207889:	48 39 85 f0 fe ff ff 	cmp    %rax,-0x110(%rbp)
  8004207890:	76 1d                	jbe    80042078af <page_check+0x1d70>
  8004207892:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207899:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  80042078a0:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  80042078a7:	00 00 00 
  80042078aa:	48 39 c2             	cmp    %rax,%rdx
  80042078ad:	76 35                	jbe    80042078e4 <page_check+0x1da5>
  80042078af:	48 b9 20 ff 21 04 80 	movabs $0x800421ff20,%rcx
  80042078b6:	00 00 00 
  80042078b9:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042078c0:	00 00 00 
  80042078c3:	be 50 05 00 00       	mov    $0x550,%esi
  80042078c8:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042078cf:	00 00 00 
  80042078d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042078d7:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042078de:	00 00 00 
  80042078e1:	41 ff d0             	callq  *%r8
	assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
  80042078e4:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  80042078eb:	00 00 00 
  80042078ee:	48 39 85 e8 fe ff ff 	cmp    %rax,-0x118(%rbp)
  80042078f5:	76 1d                	jbe    8004207914 <page_check+0x1dd5>
  80042078f7:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  80042078fe:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004207905:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  800420790c:	00 00 00 
  800420790f:	48 39 c2             	cmp    %rax,%rdx
  8004207912:	76 35                	jbe    8004207949 <page_check+0x1e0a>
  8004207914:	48 b9 48 ff 21 04 80 	movabs $0x800421ff48,%rcx
  800420791b:	00 00 00 
  800420791e:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004207925:	00 00 00 
  8004207928:	be 51 05 00 00       	mov    $0x551,%esi
  800420792d:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004207934:	00 00 00 
  8004207937:	b8 00 00 00 00       	mov    $0x0,%eax
  800420793c:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004207943:	00 00 00 
  8004207946:	41 ff d0             	callq  *%r8
	// check that they're page-aligned
	assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
  8004207949:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207950:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004207955:	48 85 c0             	test   %rax,%rax
  8004207958:	75 11                	jne    800420796b <page_check+0x1e2c>
  800420795a:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004207961:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004207966:	48 85 c0             	test   %rax,%rax
  8004207969:	74 35                	je     80042079a0 <page_check+0x1e61>
  800420796b:	48 b9 70 ff 21 04 80 	movabs $0x800421ff70,%rcx
  8004207972:	00 00 00 
  8004207975:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  800420797c:	00 00 00 
  800420797f:	be 53 05 00 00       	mov    $0x553,%esi
  8004207984:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  800420798b:	00 00 00 
  800420798e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207993:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420799a:	00 00 00 
  800420799d:	41 ff d0             	callq  *%r8
	// check that they don't overlap
	assert(mm1 + 8096 <= mm2);
  80042079a0:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  80042079a7:	48 05 a0 1f 00 00    	add    $0x1fa0,%rax
  80042079ad:	48 3b 85 e8 fe ff ff 	cmp    -0x118(%rbp),%rax
  80042079b4:	76 35                	jbe    80042079eb <page_check+0x1eac>
  80042079b6:	48 b9 97 ff 21 04 80 	movabs $0x800421ff97,%rcx
  80042079bd:	00 00 00 
  80042079c0:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  80042079c7:	00 00 00 
  80042079ca:	be 55 05 00 00       	mov    $0x555,%esi
  80042079cf:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  80042079d6:	00 00 00 
  80042079d9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042079de:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042079e5:	00 00 00 
  80042079e8:	41 ff d0             	callq  *%r8
	// check page mappings

	assert(check_va2pa(boot_pml4e, mm1) == 0);
  80042079eb:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  80042079f2:	00 00 00 
  80042079f5:	48 8b 00             	mov    (%rax),%rax
  80042079f8:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  80042079ff:	48 89 d6             	mov    %rdx,%rsi
  8004207a02:	48 89 c7             	mov    %rax,%rdi
  8004207a05:	48 b8 c5 58 20 04 80 	movabs $0x80042058c5,%rax
  8004207a0c:	00 00 00 
  8004207a0f:	ff d0                	callq  *%rax
  8004207a11:	48 85 c0             	test   %rax,%rax
  8004207a14:	74 35                	je     8004207a4b <page_check+0x1f0c>
  8004207a16:	48 b9 b0 ff 21 04 80 	movabs $0x800421ffb0,%rcx
  8004207a1d:	00 00 00 
  8004207a20:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004207a27:	00 00 00 
  8004207a2a:	be 58 05 00 00       	mov    $0x558,%esi
  8004207a2f:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004207a36:	00 00 00 
  8004207a39:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207a3e:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004207a45:	00 00 00 
  8004207a48:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm1+PGSIZE) == PGSIZE);
  8004207a4b:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207a52:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207a59:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004207a60:	00 00 00 
  8004207a63:	48 8b 00             	mov    (%rax),%rax
  8004207a66:	48 89 d6             	mov    %rdx,%rsi
  8004207a69:	48 89 c7             	mov    %rax,%rdi
  8004207a6c:	48 b8 c5 58 20 04 80 	movabs $0x80042058c5,%rax
  8004207a73:	00 00 00 
  8004207a76:	ff d0                	callq  *%rax
  8004207a78:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  8004207a7e:	74 35                	je     8004207ab5 <page_check+0x1f76>
  8004207a80:	48 b9 d8 ff 21 04 80 	movabs $0x800421ffd8,%rcx
  8004207a87:	00 00 00 
  8004207a8a:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004207a91:	00 00 00 
  8004207a94:	be 59 05 00 00       	mov    $0x559,%esi
  8004207a99:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004207aa0:	00 00 00 
  8004207aa3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207aa8:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004207aaf:	00 00 00 
  8004207ab2:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2) == 0);
  8004207ab5:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004207abc:	00 00 00 
  8004207abf:	48 8b 00             	mov    (%rax),%rax
  8004207ac2:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
  8004207ac9:	48 89 d6             	mov    %rdx,%rsi
  8004207acc:	48 89 c7             	mov    %rax,%rdi
  8004207acf:	48 b8 c5 58 20 04 80 	movabs $0x80042058c5,%rax
  8004207ad6:	00 00 00 
  8004207ad9:	ff d0                	callq  *%rax
  8004207adb:	48 85 c0             	test   %rax,%rax
  8004207ade:	74 35                	je     8004207b15 <page_check+0x1fd6>
  8004207ae0:	48 b9 08 00 22 04 80 	movabs $0x8004220008,%rcx
  8004207ae7:	00 00 00 
  8004207aea:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004207af1:	00 00 00 
  8004207af4:	be 5a 05 00 00       	mov    $0x55a,%esi
  8004207af9:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004207b00:	00 00 00 
  8004207b03:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207b08:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004207b0f:	00 00 00 
  8004207b12:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2+PGSIZE) == ~0);
  8004207b15:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004207b1c:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207b23:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004207b2a:	00 00 00 
  8004207b2d:	48 8b 00             	mov    (%rax),%rax
  8004207b30:	48 89 d6             	mov    %rdx,%rsi
  8004207b33:	48 89 c7             	mov    %rax,%rdi
  8004207b36:	48 b8 c5 58 20 04 80 	movabs $0x80042058c5,%rax
  8004207b3d:	00 00 00 
  8004207b40:	ff d0                	callq  *%rax
  8004207b42:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004207b46:	74 35                	je     8004207b7d <page_check+0x203e>
  8004207b48:	48 b9 30 00 22 04 80 	movabs $0x8004220030,%rcx
  8004207b4f:	00 00 00 
  8004207b52:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004207b59:	00 00 00 
  8004207b5c:	be 5b 05 00 00       	mov    $0x55b,%esi
  8004207b61:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004207b68:	00 00 00 
  8004207b6b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207b70:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004207b77:	00 00 00 
  8004207b7a:	41 ff d0             	callq  *%r8
	// check permissions
	assert(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
  8004207b7d:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207b84:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004207b8b:	00 00 00 
  8004207b8e:	48 8b 00             	mov    (%rax),%rax
  8004207b91:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207b96:	48 89 ce             	mov    %rcx,%rsi
  8004207b99:	48 89 c7             	mov    %rax,%rdi
  8004207b9c:	48 b8 73 30 20 04 80 	movabs $0x8004203073,%rax
  8004207ba3:	00 00 00 
  8004207ba6:	ff d0                	callq  *%rax
  8004207ba8:	48 8b 00             	mov    (%rax),%rax
  8004207bab:	83 e0 1a             	and    $0x1a,%eax
  8004207bae:	48 85 c0             	test   %rax,%rax
  8004207bb1:	75 35                	jne    8004207be8 <page_check+0x20a9>
  8004207bb3:	48 b9 60 00 22 04 80 	movabs $0x8004220060,%rcx
  8004207bba:	00 00 00 
  8004207bbd:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004207bc4:	00 00 00 
  8004207bc7:	be 5d 05 00 00       	mov    $0x55d,%esi
  8004207bcc:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004207bd3:	00 00 00 
  8004207bd6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207bdb:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004207be2:	00 00 00 
  8004207be5:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & PTE_U));
  8004207be8:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207bef:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004207bf6:	00 00 00 
  8004207bf9:	48 8b 00             	mov    (%rax),%rax
  8004207bfc:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207c01:	48 89 ce             	mov    %rcx,%rsi
  8004207c04:	48 89 c7             	mov    %rax,%rdi
  8004207c07:	48 b8 73 30 20 04 80 	movabs $0x8004203073,%rax
  8004207c0e:	00 00 00 
  8004207c11:	ff d0                	callq  *%rax
  8004207c13:	48 8b 00             	mov    (%rax),%rax
  8004207c16:	83 e0 04             	and    $0x4,%eax
  8004207c19:	48 85 c0             	test   %rax,%rax
  8004207c1c:	74 35                	je     8004207c53 <page_check+0x2114>
  8004207c1e:	48 b9 a8 00 22 04 80 	movabs $0x80042200a8,%rcx
  8004207c25:	00 00 00 
  8004207c28:	48 ba 71 f2 21 04 80 	movabs $0x800421f271,%rdx
  8004207c2f:	00 00 00 
  8004207c32:	be 5e 05 00 00       	mov    $0x55e,%esi
  8004207c37:	48 bf 86 f2 21 04 80 	movabs $0x800421f286,%rdi
  8004207c3e:	00 00 00 
  8004207c41:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207c46:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004207c4d:	00 00 00 
  8004207c50:	41 ff d0             	callq  *%r8
	// clear the mappings
	*pml4e_walk(boot_pml4e, (void*) mm1, 0) = 0;
  8004207c53:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207c5a:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004207c61:	00 00 00 
  8004207c64:	48 8b 00             	mov    (%rax),%rax
  8004207c67:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207c6c:	48 89 ce             	mov    %rcx,%rsi
  8004207c6f:	48 89 c7             	mov    %rax,%rdi
  8004207c72:	48 b8 73 30 20 04 80 	movabs $0x8004203073,%rax
  8004207c79:	00 00 00 
  8004207c7c:	ff d0                	callq  *%rax
  8004207c7e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm1 + PGSIZE, 0) = 0;
  8004207c85:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207c8c:	48 05 00 10 00 00    	add    $0x1000,%rax
  8004207c92:	48 89 c1             	mov    %rax,%rcx
  8004207c95:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004207c9c:	00 00 00 
  8004207c9f:	48 8b 00             	mov    (%rax),%rax
  8004207ca2:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207ca7:	48 89 ce             	mov    %rcx,%rsi
  8004207caa:	48 89 c7             	mov    %rax,%rdi
  8004207cad:	48 b8 73 30 20 04 80 	movabs $0x8004203073,%rax
  8004207cb4:	00 00 00 
  8004207cb7:	ff d0                	callq  *%rax
  8004207cb9:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm2, 0) = 0;
  8004207cc0:	48 8b 8d e8 fe ff ff 	mov    -0x118(%rbp),%rcx
  8004207cc7:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  8004207cce:	00 00 00 
  8004207cd1:	48 8b 00             	mov    (%rax),%rax
  8004207cd4:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207cd9:	48 89 ce             	mov    %rcx,%rsi
  8004207cdc:	48 89 c7             	mov    %rax,%rdi
  8004207cdf:	48 b8 73 30 20 04 80 	movabs $0x8004203073,%rax
  8004207ce6:	00 00 00 
  8004207ce9:	ff d0                	callq  *%rax
  8004207ceb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)


	cprintf("check_page() succeeded!\n");
  8004207cf2:	48 bf db 00 22 04 80 	movabs $0x80042200db,%rdi
  8004207cf9:	00 00 00 
  8004207cfc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207d01:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004207d08:	00 00 00 
  8004207d0b:	ff d2                	callq  *%rdx
}
  8004207d0d:	90                   	nop
  8004207d0e:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
  8004207d15:	5b                   	pop    %rbx
  8004207d16:	5d                   	pop    %rbp
  8004207d17:	c3                   	retq   

0000008004207d18 <page2ppn>:
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);


static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004207d18:	55                   	push   %rbp
  8004207d19:	48 89 e5             	mov    %rsp,%rbp
  8004207d1c:	48 83 ec 08          	sub    $0x8,%rsp
  8004207d20:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004207d24:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207d28:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  8004207d2f:	00 00 00 
  8004207d32:	48 8b 00             	mov    (%rax),%rax
  8004207d35:	48 29 c2             	sub    %rax,%rdx
  8004207d38:	48 89 d0             	mov    %rdx,%rax
  8004207d3b:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004207d3f:	c9                   	leaveq 
  8004207d40:	c3                   	retq   

0000008004207d41 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004207d41:	55                   	push   %rbp
  8004207d42:	48 89 e5             	mov    %rsp,%rbp
  8004207d45:	48 83 ec 08          	sub    $0x8,%rsp
  8004207d49:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004207d4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d51:	48 89 c7             	mov    %rax,%rdi
  8004207d54:	48 b8 18 7d 20 04 80 	movabs $0x8004207d18,%rax
  8004207d5b:	00 00 00 
  8004207d5e:	ff d0                	callq  *%rax
  8004207d60:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004207d64:	c9                   	leaveq 
  8004207d65:	c3                   	retq   

0000008004207d66 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004207d66:	55                   	push   %rbp
  8004207d67:	48 89 e5             	mov    %rsp,%rbp
  8004207d6a:	48 83 ec 10          	sub    $0x10,%rsp
  8004207d6e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004207d72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d76:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207d7a:	48 89 c2             	mov    %rax,%rdx
  8004207d7d:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004207d84:	00 00 00 
  8004207d87:	48 8b 00             	mov    (%rax),%rax
  8004207d8a:	48 39 c2             	cmp    %rax,%rdx
  8004207d8d:	72 2a                	jb     8004207db9 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004207d8f:	48 ba f8 00 22 04 80 	movabs $0x80042200f8,%rdx
  8004207d96:	00 00 00 
  8004207d99:	be 5a 00 00 00       	mov    $0x5a,%esi
  8004207d9e:	48 bf 17 01 22 04 80 	movabs $0x8004220117,%rdi
  8004207da5:	00 00 00 
  8004207da8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207dad:	48 b9 f3 04 20 04 80 	movabs $0x80042004f3,%rcx
  8004207db4:	00 00 00 
  8004207db7:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004207db9:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  8004207dc0:	00 00 00 
  8004207dc3:	48 8b 00             	mov    (%rax),%rax
  8004207dc6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207dca:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004207dce:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207dd2:	48 01 d0             	add    %rdx,%rax
}
  8004207dd5:	c9                   	leaveq 
  8004207dd6:	c3                   	retq   

0000008004207dd7 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004207dd7:	55                   	push   %rbp
  8004207dd8:	48 89 e5             	mov    %rsp,%rbp
  8004207ddb:	48 83 ec 20          	sub    $0x20,%rsp
  8004207ddf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004207de3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207de7:	48 89 c7             	mov    %rax,%rdi
  8004207dea:	48 b8 41 7d 20 04 80 	movabs $0x8004207d41,%rax
  8004207df1:	00 00 00 
  8004207df4:	ff d0                	callq  *%rax
  8004207df6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207dfa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207dfe:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207e02:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004207e05:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004207e08:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004207e0f:	00 00 00 
  8004207e12:	48 8b 00             	mov    (%rax),%rax
  8004207e15:	48 39 c2             	cmp    %rax,%rdx
  8004207e18:	72 32                	jb     8004207e4c <page2kva+0x75>
  8004207e1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207e1e:	48 89 c1             	mov    %rax,%rcx
  8004207e21:	48 ba 28 01 22 04 80 	movabs $0x8004220128,%rdx
  8004207e28:	00 00 00 
  8004207e2b:	be 61 00 00 00       	mov    $0x61,%esi
  8004207e30:	48 bf 17 01 22 04 80 	movabs $0x8004220117,%rdi
  8004207e37:	00 00 00 
  8004207e3a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207e3f:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004207e46:	00 00 00 
  8004207e49:	41 ff d0             	callq  *%r8
  8004207e4c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207e53:	00 00 00 
  8004207e56:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207e5a:	48 01 d0             	add    %rdx,%rax
}
  8004207e5d:	c9                   	leaveq 
  8004207e5e:	c3                   	retq   

0000008004207e5f <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  8004207e5f:	55                   	push   %rbp
  8004207e60:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  8004207e63:	48 bf 60 37 23 04 80 	movabs $0x8004233760,%rdi
  8004207e6a:	00 00 00 
  8004207e6d:	48 b8 34 83 21 04 80 	movabs $0x8004218334,%rax
  8004207e74:	00 00 00 
  8004207e77:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  8004207e79:	f3 90                	pause  
}
  8004207e7b:	90                   	nop
  8004207e7c:	5d                   	pop    %rbp
  8004207e7d:	c3                   	retq   

0000008004207e7e <envid2env>:
//   On success, sets *env_store to the environment.
//   On error, sets *env_store to NULL.
//
int
envid2env(envid_t envid, struct Env **env_store, bool checkperm)
{
  8004207e7e:	55                   	push   %rbp
  8004207e7f:	48 89 e5             	mov    %rsp,%rbp
  8004207e82:	53                   	push   %rbx
  8004207e83:	48 83 ec 28          	sub    $0x28,%rsp
  8004207e87:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8004207e8a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004207e8e:	89 d0                	mov    %edx,%eax
  8004207e90:	88 45 d8             	mov    %al,-0x28(%rbp)
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
  8004207e93:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004207e97:	75 41                	jne    8004207eda <envid2env+0x5c>
		*env_store = curenv;
  8004207e99:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  8004207ea0:	00 00 00 
  8004207ea3:	ff d0                	callq  *%rax
  8004207ea5:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  8004207eac:	00 00 00 
  8004207eaf:	48 98                	cltq   
  8004207eb1:	48 c1 e0 03          	shl    $0x3,%rax
  8004207eb5:	48 89 c1             	mov    %rax,%rcx
  8004207eb8:	48 c1 e1 04          	shl    $0x4,%rcx
  8004207ebc:	48 01 c8             	add    %rcx,%rax
  8004207ebf:	48 01 d0             	add    %rdx,%rax
  8004207ec2:	48 83 c0 08          	add    $0x8,%rax
  8004207ec6:	48 8b 10             	mov    (%rax),%rdx
  8004207ec9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207ecd:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  8004207ed0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207ed5:	e9 fd 00 00 00       	jmpq   8004207fd7 <envid2env+0x159>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
  8004207eda:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  8004207ee1:	00 00 00 
  8004207ee4:	48 8b 10             	mov    (%rax),%rdx
  8004207ee7:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004207eea:	48 98                	cltq   
  8004207eec:	25 ff 03 00 00       	and    $0x3ff,%eax
  8004207ef1:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004207ef8:	48 01 d0             	add    %rdx,%rax
  8004207efb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
  8004207eff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207f03:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004207f09:	85 c0                	test   %eax,%eax
  8004207f0b:	74 0f                	je     8004207f1c <envid2env+0x9e>
  8004207f0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207f11:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207f17:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  8004207f1a:	74 15                	je     8004207f31 <envid2env+0xb3>
		*env_store = 0;
  8004207f1c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207f20:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207f27:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207f2c:	e9 a6 00 00 00       	jmpq   8004207fd7 <envid2env+0x159>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
  8004207f31:	80 7d d8 00          	cmpb   $0x0,-0x28(%rbp)
  8004207f35:	0f 84 8c 00 00 00    	je     8004207fc7 <envid2env+0x149>
  8004207f3b:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  8004207f42:	00 00 00 
  8004207f45:	ff d0                	callq  *%rax
  8004207f47:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  8004207f4e:	00 00 00 
  8004207f51:	48 98                	cltq   
  8004207f53:	48 c1 e0 03          	shl    $0x3,%rax
  8004207f57:	48 89 c1             	mov    %rax,%rcx
  8004207f5a:	48 c1 e1 04          	shl    $0x4,%rcx
  8004207f5e:	48 01 c8             	add    %rcx,%rax
  8004207f61:	48 01 d0             	add    %rdx,%rax
  8004207f64:	48 83 c0 08          	add    $0x8,%rax
  8004207f68:	48 8b 00             	mov    (%rax),%rax
  8004207f6b:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004207f6f:	74 56                	je     8004207fc7 <envid2env+0x149>
  8004207f71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207f75:	8b 98 cc 00 00 00    	mov    0xcc(%rax),%ebx
  8004207f7b:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  8004207f82:	00 00 00 
  8004207f85:	ff d0                	callq  *%rax
  8004207f87:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  8004207f8e:	00 00 00 
  8004207f91:	48 98                	cltq   
  8004207f93:	48 c1 e0 03          	shl    $0x3,%rax
  8004207f97:	48 89 c1             	mov    %rax,%rcx
  8004207f9a:	48 c1 e1 04          	shl    $0x4,%rcx
  8004207f9e:	48 01 c8             	add    %rcx,%rax
  8004207fa1:	48 01 d0             	add    %rdx,%rax
  8004207fa4:	48 83 c0 08          	add    $0x8,%rax
  8004207fa8:	48 8b 00             	mov    (%rax),%rax
  8004207fab:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207fb1:	39 c3                	cmp    %eax,%ebx
  8004207fb3:	74 12                	je     8004207fc7 <envid2env+0x149>
		*env_store = 0;
  8004207fb5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207fb9:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207fc0:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207fc5:	eb 10                	jmp    8004207fd7 <envid2env+0x159>
	}

	*env_store = e;
  8004207fc7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207fcb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207fcf:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  8004207fd2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207fd7:	48 83 c4 28          	add    $0x28,%rsp
  8004207fdb:	5b                   	pop    %rbx
  8004207fdc:	5d                   	pop    %rbp
  8004207fdd:	c3                   	retq   

0000008004207fde <env_init>:
// they are in the envs array (i.e., so that the first call to
// env_alloc() returns envs[0]).
//
void
env_init(void)
{
  8004207fde:	55                   	push   %rbp
  8004207fdf:	48 89 e5             	mov    %rsp,%rbp
  8004207fe2:	48 83 ec 10          	sub    $0x10,%rsp
	// Set up envs array
	// LAB 3: Your code here.

	int i;
	for (i = 0; i < NENV; i++) {
  8004207fe6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004207fed:	eb 6d                	jmp    800420805c <env_init+0x7e>
		envs[i].env_status = ENV_FREE;
  8004207fef:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  8004207ff6:	00 00 00 
  8004207ff9:	48 8b 10             	mov    (%rax),%rdx
  8004207ffc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004207fff:	48 98                	cltq   
  8004208001:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004208008:	48 01 d0             	add    %rdx,%rax
  800420800b:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8004208012:	00 00 00 
		envs[i].env_link = &envs[i+1];
  8004208015:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  800420801c:	00 00 00 
  800420801f:	48 8b 10             	mov    (%rax),%rdx
  8004208022:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208025:	48 98                	cltq   
  8004208027:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420802e:	48 01 c2             	add    %rax,%rdx
  8004208031:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  8004208038:	00 00 00 
  800420803b:	48 8b 08             	mov    (%rax),%rcx
  800420803e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208041:	48 98                	cltq   
  8004208043:	48 83 c0 01          	add    $0x1,%rax
  8004208047:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420804e:	48 01 c8             	add    %rcx,%rax
  8004208051:	48 89 82 c0 00 00 00 	mov    %rax,0xc0(%rdx)
{
	// Set up envs array
	// LAB 3: Your code here.

	int i;
	for (i = 0; i < NENV; i++) {
  8004208058:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420805c:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  8004208063:	7e 8a                	jle    8004207fef <env_init+0x11>
		envs[i].env_status = ENV_FREE;
		envs[i].env_link = &envs[i+1];
	}
	envs[NENV-1].env_link = NULL;
  8004208065:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  800420806c:	00 00 00 
  800420806f:	48 8b 00             	mov    (%rax),%rax
  8004208072:	48 05 98 9e 05 00    	add    $0x59e98,%rax
  8004208078:	48 c7 80 c0 00 00 00 	movq   $0x0,0xc0(%rax)
  800420807f:	00 00 00 00 
	env_free_list = &envs[0];
  8004208083:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  800420808a:	00 00 00 
  800420808d:	48 8b 10             	mov    (%rax),%rdx
  8004208090:	48 b8 60 d2 4d 04 80 	movabs $0x80044dd260,%rax
  8004208097:	00 00 00 
  800420809a:	48 89 10             	mov    %rdx,(%rax)


	// Per-CPU part of the initialization
	env_init_percpu();
  800420809d:	48 b8 ac 80 20 04 80 	movabs $0x80042080ac,%rax
  80042080a4:	00 00 00 
  80042080a7:	ff d0                	callq  *%rax
}
  80042080a9:	90                   	nop
  80042080aa:	c9                   	leaveq 
  80042080ab:	c3                   	retq   

00000080042080ac <env_init_percpu>:

// Load GDT and segment descriptors.
void
env_init_percpu(void)
{
  80042080ac:	55                   	push   %rbp
  80042080ad:	48 89 e5             	mov    %rsp,%rbp
  80042080b0:	53                   	push   %rbx
  80042080b1:	48 83 ec 10          	sub    $0x10,%rsp
  80042080b5:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  80042080bc:	00 00 00 
  80042080bf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}

static __inline void
lgdt(void *p)
{
	__asm __volatile("lgdt (%0)" : : "r" (p));
  80042080c3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042080c7:	0f 01 10             	lgdt   (%rax)
	lgdt(&gdt_pd);

	// The kernel never uses GS or FS, so we leave those set to
	// the user data segment.
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
  80042080ca:	b8 23 00 00 00       	mov    $0x23,%eax
  80042080cf:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
  80042080d1:	b8 23 00 00 00       	mov    $0x23,%eax
  80042080d6:	8e e0                	mov    %eax,%fs
	// The kernel does use ES, DS, and SS.  We'll change between
	// the kernel and user data segments as needed.
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
  80042080d8:	b8 10 00 00 00       	mov    $0x10,%eax
  80042080dd:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
  80042080df:	b8 10 00 00 00       	mov    $0x10,%eax
  80042080e4:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
  80042080e6:	b8 10 00 00 00       	mov    $0x10,%eax
  80042080eb:	8e d0                	mov    %eax,%ss
	// Load the kernel text segment into CS.
	asm volatile("pushq %%rbx \n \t movabs $1f,%%rax \n \t pushq %%rax \n\t lretq \n 1:\n" :: "b" (GD_KT):"cc","memory");
  80042080ed:	b8 08 00 00 00       	mov    $0x8,%eax
  80042080f2:	89 c3                	mov    %eax,%ebx
  80042080f4:	53                   	push   %rbx
  80042080f5:	48 b8 02 81 20 04 80 	movabs $0x8004208102,%rax
  80042080fc:	00 00 00 
  80042080ff:	50                   	push   %rax
  8004208100:	48 cb                	lretq  
  8004208102:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
}

static __inline void
lldt(uint16_t sel)
{
	__asm __volatile("lldt %0" : : "r" (sel));
  8004208108:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  800420810c:	0f 00 d0             	lldt   %ax
	// For good measure, clear the local descriptor table (LDT),
	// since we don't use it.
	lldt(0);
}
  800420810f:	90                   	nop
  8004208110:	48 83 c4 10          	add    $0x10,%rsp
  8004208114:	5b                   	pop    %rbx
  8004208115:	5d                   	pop    %rbp
  8004208116:	c3                   	retq   

0000008004208117 <env_setup_vm>:
// Returns 0 on success, < 0 on error.  Errors include:
//	-E_NO_MEM if page directory or table could not be allocated.
//
static int
env_setup_vm(struct Env *e)
{
  8004208117:	55                   	push   %rbp
  8004208118:	48 89 e5             	mov    %rsp,%rbp
  800420811b:	48 83 ec 20          	sub    $0x20,%rsp
  800420811f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;
	int i;
	struct PageInfo *p = NULL;
  8004208123:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420812a:	00 

	// Allocate a page for the page directory
	if (!(p = page_alloc(ALLOC_ZERO)))
  800420812b:	bf 01 00 00 00       	mov    $0x1,%edi
  8004208130:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004208137:	00 00 00 
  800420813a:	ff d0                	callq  *%rax
  800420813c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004208140:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004208145:	75 0a                	jne    8004208151 <env_setup_vm+0x3a>
		return -E_NO_MEM;
  8004208147:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420814c:	e9 c2 00 00 00       	jmpq   8004208213 <env_setup_vm+0xfc>
	//	pp_ref for env_free to work correctly.
	//    - The functions in kern/pmap.h are handy.

	// LAB 3: Your code here.

	p->pp_ref       += 1;
  8004208151:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208155:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004208159:	8d 50 01             	lea    0x1(%rax),%edx
  800420815c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208160:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_pml4e    = page2kva(p);
  8004208164:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208168:	48 89 c7             	mov    %rax,%rdi
  800420816b:	48 b8 d7 7d 20 04 80 	movabs $0x8004207dd7,%rax
  8004208172:	00 00 00 
  8004208175:	ff d0                	callq  *%rax
  8004208177:	48 89 c2             	mov    %rax,%rdx
  800420817a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420817e:	48 89 90 e0 00 00 00 	mov    %rdx,0xe0(%rax)
	e->env_cr3      = page2pa(p);
  8004208185:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208189:	48 89 c7             	mov    %rax,%rdi
  800420818c:	48 b8 41 7d 20 04 80 	movabs $0x8004207d41,%rax
  8004208193:	00 00 00 
  8004208196:	ff d0                	callq  *%rax
  8004208198:	48 89 c2             	mov    %rax,%rdx
  800420819b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420819f:	48 89 90 e8 00 00 00 	mov    %rdx,0xe8(%rax)

	memset(e->env_pml4e, 0, PGSIZE);
  80042081a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042081aa:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042081b1:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042081b6:	be 00 00 00 00       	mov    $0x0,%esi
  80042081bb:	48 89 c7             	mov    %rax,%rdi
  80042081be:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  80042081c5:	00 00 00 
  80042081c8:	ff d0                	callq  *%rax
	e->env_pml4e[1] = boot_pml4e[1];
  80042081ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042081ce:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042081d5:	48 8d 50 08          	lea    0x8(%rax),%rdx
  80042081d9:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  80042081e0:	00 00 00 
  80042081e3:	48 8b 00             	mov    (%rax),%rax
  80042081e6:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042081ea:	48 89 02             	mov    %rax,(%rdx)


	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	e->env_pml4e[PML4(UVPT)] = e->env_cr3 | PTE_P | PTE_U;
  80042081ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042081f1:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042081f8:	48 8d 50 10          	lea    0x10(%rax),%rdx
  80042081fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208200:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208207:	48 83 c8 05          	or     $0x5,%rax
  800420820b:	48 89 02             	mov    %rax,(%rdx)

	return 0;
  800420820e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004208213:	c9                   	leaveq 
  8004208214:	c3                   	retq   

0000008004208215 <env_guest_alloc>:


// #ifndef VMM_GUEST
int
env_guest_alloc(struct Env **newenv_store, envid_t parent_id)
{
  8004208215:	55                   	push   %rbp
  8004208216:	48 89 e5             	mov    %rsp,%rbp
  8004208219:	48 83 ec 50          	sub    $0x50,%rsp
  800420821d:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004208221:	89 75 b4             	mov    %esi,-0x4c(%rbp)
	int32_t generation;
	struct Env *e;

	if (!(e = env_free_list))
  8004208224:	48 b8 60 d2 4d 04 80 	movabs $0x80044dd260,%rax
  800420822b:	00 00 00 
  800420822e:	48 8b 00             	mov    (%rax),%rax
  8004208231:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004208235:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420823a:	75 0a                	jne    8004208246 <env_guest_alloc+0x31>
		return -E_NO_FREE_ENV;
  800420823c:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  8004208241:	e9 67 04 00 00       	jmpq   80042086ad <env_guest_alloc+0x498>

	memset(&e->env_vmxinfo, 0, sizeof(struct VmxGuestInfo));
  8004208246:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420824a:	48 05 20 01 00 00    	add    $0x120,%rax
  8004208250:	ba 48 00 00 00       	mov    $0x48,%edx
  8004208255:	be 00 00 00 00       	mov    $0x0,%esi
  800420825a:	48 89 c7             	mov    %rax,%rdi
  800420825d:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  8004208264:	00 00 00 
  8004208267:	ff d0                	callq  *%rax

	// allocate a page for the EPT PML4..
	struct PageInfo *p = NULL;
  8004208269:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004208270:	00 

	if (!(p = page_alloc(ALLOC_ZERO)))
  8004208271:	bf 01 00 00 00       	mov    $0x1,%edi
  8004208276:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  800420827d:	00 00 00 
  8004208280:	ff d0                	callq  *%rax
  8004208282:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004208286:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420828b:	75 0a                	jne    8004208297 <env_guest_alloc+0x82>
		return -E_NO_MEM;
  800420828d:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004208292:	e9 16 04 00 00       	jmpq   80042086ad <env_guest_alloc+0x498>

	memset(p, 0, sizeof(struct PageInfo));
  8004208297:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420829b:	ba 10 00 00 00       	mov    $0x10,%edx
  80042082a0:	be 00 00 00 00       	mov    $0x0,%esi
  80042082a5:	48 89 c7             	mov    %rax,%rdi
  80042082a8:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  80042082af:	00 00 00 
  80042082b2:	ff d0                	callq  *%rax
	p->pp_ref       += 1;
  80042082b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042082b8:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042082bc:	8d 50 01             	lea    0x1(%rax),%edx
  80042082bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042082c3:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_pml4e    = page2kva(p);
  80042082c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042082cb:	48 89 c7             	mov    %rax,%rdi
  80042082ce:	48 b8 d7 7d 20 04 80 	movabs $0x8004207dd7,%rax
  80042082d5:	00 00 00 
  80042082d8:	ff d0                	callq  *%rax
  80042082da:	48 89 c2             	mov    %rax,%rdx
  80042082dd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042082e1:	48 89 90 e0 00 00 00 	mov    %rdx,0xe0(%rax)
	e->env_cr3      = page2pa(p);
  80042082e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042082ec:	48 89 c7             	mov    %rax,%rdi
  80042082ef:	48 b8 41 7d 20 04 80 	movabs $0x8004207d41,%rax
  80042082f6:	00 00 00 
  80042082f9:	ff d0                	callq  *%rax
  80042082fb:	48 89 c2             	mov    %rax,%rdx
  80042082fe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208302:	48 89 90 e8 00 00 00 	mov    %rdx,0xe8(%rax)

	// Allocate a VMCS.
	struct PageInfo *q = vmx_init_vmcs();
  8004208309:	b8 00 00 00 00       	mov    $0x0,%eax
  800420830e:	48 ba 94 a4 21 04 80 	movabs $0x800421a494,%rdx
  8004208315:	00 00 00 
  8004208318:	ff d2                	callq  *%rdx
  800420831a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (!q) {
  800420831e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004208323:	75 1d                	jne    8004208342 <env_guest_alloc+0x12d>
		page_decref(p);
  8004208325:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208329:	48 89 c7             	mov    %rax,%rdi
  800420832c:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  8004208333:	00 00 00 
  8004208336:	ff d0                	callq  *%rax
		return -E_NO_MEM;
  8004208338:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420833d:	e9 6b 03 00 00       	jmpq   80042086ad <env_guest_alloc+0x498>
	}
	q->pp_ref += 1;
  8004208342:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208346:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420834a:	8d 50 01             	lea    0x1(%rax),%edx
  800420834d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208351:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_vmxinfo.vmcs = page2kva(q);
  8004208355:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208359:	48 89 c7             	mov    %rax,%rdi
  800420835c:	48 b8 d7 7d 20 04 80 	movabs $0x8004207dd7,%rax
  8004208363:	00 00 00 
  8004208366:	ff d0                	callq  *%rax
  8004208368:	48 89 c2             	mov    %rax,%rdx
  800420836b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420836f:	48 89 90 28 01 00 00 	mov    %rdx,0x128(%rax)

	// Allocate a page for msr load/store area.
	struct PageInfo *r = NULL;
  8004208376:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  800420837d:	00 
	if (!(r = page_alloc(ALLOC_ZERO))) {
  800420837e:	bf 01 00 00 00       	mov    $0x1,%edi
  8004208383:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  800420838a:	00 00 00 
  800420838d:	ff d0                	callq  *%rax
  800420838f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004208393:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004208398:	75 30                	jne    80042083ca <env_guest_alloc+0x1b5>
		page_decref(p);
  800420839a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420839e:	48 89 c7             	mov    %rax,%rdi
  80042083a1:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  80042083a8:	00 00 00 
  80042083ab:	ff d0                	callq  *%rax
		page_decref(q);
  80042083ad:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042083b1:	48 89 c7             	mov    %rax,%rdi
  80042083b4:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  80042083bb:	00 00 00 
  80042083be:	ff d0                	callq  *%rax
		return -E_NO_MEM;
  80042083c0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80042083c5:	e9 e3 02 00 00       	jmpq   80042086ad <env_guest_alloc+0x498>
	}
	r->pp_ref += 1;
  80042083ca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042083ce:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042083d2:	8d 50 01             	lea    0x1(%rax),%edx
  80042083d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042083d9:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_vmxinfo.msr_host_area = page2kva(r);
  80042083dd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042083e1:	48 89 c7             	mov    %rax,%rdi
  80042083e4:	48 b8 d7 7d 20 04 80 	movabs $0x8004207dd7,%rax
  80042083eb:	00 00 00 
  80042083ee:	ff d0                	callq  *%rax
  80042083f0:	48 89 c2             	mov    %rax,%rdx
  80042083f3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083f7:	48 89 90 50 01 00 00 	mov    %rdx,0x150(%rax)
	e->env_vmxinfo.msr_guest_area = page2kva(r) + PGSIZE / 2;
  80042083fe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208402:	48 89 c7             	mov    %rax,%rdi
  8004208405:	48 b8 d7 7d 20 04 80 	movabs $0x8004207dd7,%rax
  800420840c:	00 00 00 
  800420840f:	ff d0                	callq  *%rax
  8004208411:	48 8d 90 00 08 00 00 	lea    0x800(%rax),%rdx
  8004208418:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420841c:	48 89 90 58 01 00 00 	mov    %rdx,0x158(%rax)

	// Allocate pages for IO bitmaps.
	struct PageInfo *s = NULL;
  8004208423:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  800420842a:	00 
	if (!(s = page_alloc(ALLOC_ZERO))) {
  800420842b:	bf 01 00 00 00       	mov    $0x1,%edi
  8004208430:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004208437:	00 00 00 
  800420843a:	ff d0                	callq  *%rax
  800420843c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004208440:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004208445:	75 43                	jne    800420848a <env_guest_alloc+0x275>
		page_decref(p);
  8004208447:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420844b:	48 89 c7             	mov    %rax,%rdi
  800420844e:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  8004208455:	00 00 00 
  8004208458:	ff d0                	callq  *%rax
		page_decref(q);
  800420845a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420845e:	48 89 c7             	mov    %rax,%rdi
  8004208461:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  8004208468:	00 00 00 
  800420846b:	ff d0                	callq  *%rax
		page_decref(r);
  800420846d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208471:	48 89 c7             	mov    %rax,%rdi
  8004208474:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  800420847b:	00 00 00 
  800420847e:	ff d0                	callq  *%rax
		return -E_NO_MEM;
  8004208480:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004208485:	e9 23 02 00 00       	jmpq   80042086ad <env_guest_alloc+0x498>
	}
	s->pp_ref += 1;
  800420848a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420848e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004208492:	8d 50 01             	lea    0x1(%rax),%edx
  8004208495:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208499:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_vmxinfo.io_bmap_a = page2kva(s);
  800420849d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042084a1:	48 89 c7             	mov    %rax,%rdi
  80042084a4:	48 b8 d7 7d 20 04 80 	movabs $0x8004207dd7,%rax
  80042084ab:	00 00 00 
  80042084ae:	ff d0                	callq  *%rax
  80042084b0:	48 89 c2             	mov    %rax,%rdx
  80042084b3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042084b7:	48 89 90 38 01 00 00 	mov    %rdx,0x138(%rax)

	struct PageInfo *t = NULL;
  80042084be:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  80042084c5:	00 
	if (!(t = page_alloc(ALLOC_ZERO))) {
  80042084c6:	bf 01 00 00 00       	mov    $0x1,%edi
  80042084cb:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  80042084d2:	00 00 00 
  80042084d5:	ff d0                	callq  *%rax
  80042084d7:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042084db:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042084e0:	75 56                	jne    8004208538 <env_guest_alloc+0x323>
		page_decref(p);
  80042084e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042084e6:	48 89 c7             	mov    %rax,%rdi
  80042084e9:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  80042084f0:	00 00 00 
  80042084f3:	ff d0                	callq  *%rax
		page_decref(q);
  80042084f5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042084f9:	48 89 c7             	mov    %rax,%rdi
  80042084fc:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  8004208503:	00 00 00 
  8004208506:	ff d0                	callq  *%rax
		page_decref(r);
  8004208508:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420850c:	48 89 c7             	mov    %rax,%rdi
  800420850f:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  8004208516:	00 00 00 
  8004208519:	ff d0                	callq  *%rax
		page_decref(s);
  800420851b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420851f:	48 89 c7             	mov    %rax,%rdi
  8004208522:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  8004208529:	00 00 00 
  800420852c:	ff d0                	callq  *%rax
		return -E_NO_MEM;
  800420852e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004208533:	e9 75 01 00 00       	jmpq   80042086ad <env_guest_alloc+0x498>
	}
	t->pp_ref += 1;
  8004208538:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420853c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004208540:	8d 50 01             	lea    0x1(%rax),%edx
  8004208543:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208547:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_vmxinfo.io_bmap_b = page2kva(t);
  800420854b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420854f:	48 89 c7             	mov    %rax,%rdi
  8004208552:	48 b8 d7 7d 20 04 80 	movabs $0x8004207dd7,%rax
  8004208559:	00 00 00 
  800420855c:	ff d0                	callq  *%rax
  800420855e:	48 89 c2             	mov    %rax,%rdx
  8004208561:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208565:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  800420856c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208570:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004208576:	05 00 10 00 00       	add    $0x1000,%eax
  800420857b:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  8004208580:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  8004208583:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004208587:	7f 07                	jg     8004208590 <env_guest_alloc+0x37b>
		generation = 1 << ENVGENSHIFT;
  8004208589:	c7 45 fc 00 10 00 00 	movl   $0x1000,-0x4(%rbp)
	e->env_id = generation | (e - envs);
  8004208590:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004208594:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  800420859b:	00 00 00 
  800420859e:	48 8b 00             	mov    (%rax),%rax
  80042085a1:	48 29 c2             	sub    %rax,%rdx
  80042085a4:	48 89 d0             	mov    %rdx,%rax
  80042085a7:	48 c1 f8 03          	sar    $0x3,%rax
  80042085ab:	48 89 c2             	mov    %rax,%rdx
  80042085ae:	48 b8 a5 4f fa a4 4f 	movabs $0x4fa4fa4fa4fa4fa5,%rax
  80042085b5:	fa a4 4f 
  80042085b8:	48 0f af c2          	imul   %rdx,%rax
  80042085bc:	0b 45 fc             	or     -0x4(%rbp),%eax
  80042085bf:	89 c2                	mov    %eax,%edx
  80042085c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042085c5:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  80042085cb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042085cf:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  80042085d2:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_GUEST;
  80042085d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042085dc:	c7 80 d0 00 00 00 03 	movl   $0x3,0xd0(%rax)
  80042085e3:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  80042085e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042085ea:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  80042085f1:	00 00 00 
	e->env_runs = 0;
  80042085f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042085f8:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  80042085ff:	00 00 00 
	e->env_vmxinfo.vcpunum = vcpu_count++;
  8004208602:	48 b8 50 d2 4d 04 80 	movabs $0x80044dd250,%rax
  8004208609:	00 00 00 
  800420860c:	8b 00                	mov    (%rax),%eax
  800420860e:	8d 48 01             	lea    0x1(%rax),%ecx
  8004208611:	48 ba 50 d2 4d 04 80 	movabs $0x80044dd250,%rdx
  8004208618:	00 00 00 
  800420861b:	89 0a                	mov    %ecx,(%rdx)
  800420861d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004208621:	89 82 60 01 00 00    	mov    %eax,0x160(%rdx)
    	cprintf("VCPUNUM allocated: %d\n", e->env_vmxinfo.vcpunum);
  8004208627:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420862b:	8b 80 60 01 00 00    	mov    0x160(%rax),%eax
  8004208631:	89 c6                	mov    %eax,%esi
  8004208633:	48 bf 4b 01 22 04 80 	movabs $0x800422014b,%rdi
  800420863a:	00 00 00 
  800420863d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208642:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004208649:	00 00 00 
  800420864c:	ff d2                	callq  *%rdx

	memset(&e->env_tf, 0, sizeof(e->env_tf));
  800420864e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208652:	ba c0 00 00 00       	mov    $0xc0,%edx
  8004208657:	be 00 00 00 00       	mov    $0x0,%esi
  800420865c:	48 89 c7             	mov    %rax,%rdi
  800420865f:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  8004208666:	00 00 00 
  8004208669:	ff d0                	callq  *%rax

	e->env_pgfault_upcall = 0;
  800420866b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420866f:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  8004208676:	00 00 00 00 
	e->env_ipc_recving = 0;
  800420867a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420867e:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)

	// commit the allocation
	env_free_list = e->env_link;
  8004208685:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208689:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  8004208690:	48 b8 60 d2 4d 04 80 	movabs $0x80044dd260,%rax
  8004208697:	00 00 00 
  800420869a:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  800420869d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042086a1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042086a5:	48 89 10             	mov    %rdx,(%rax)

	return 0;
  80042086a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042086ad:	c9                   	leaveq 
  80042086ae:	c3                   	retq   

00000080042086af <env_guest_free>:

void env_guest_free(struct Env *e) {
  80042086af:	55                   	push   %rbp
  80042086b0:	48 89 e5             	mov    %rsp,%rbp
  80042086b3:	53                   	push   %rbx
  80042086b4:	48 83 ec 38          	sub    $0x38,%rsp
  80042086b8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	// Free the VMCS.
	page_decref(pa2page(PADDR(e->env_vmxinfo.vmcs)));
  80042086bc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042086c0:	48 8b 80 28 01 00 00 	mov    0x128(%rax),%rax
  80042086c7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042086cb:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042086d2:	00 00 00 
  80042086d5:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80042086d9:	77 32                	ja     800420870d <env_guest_free+0x5e>
  80042086db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042086df:	48 89 c1             	mov    %rax,%rcx
  80042086e2:	48 ba 68 01 22 04 80 	movabs $0x8004220168,%rdx
  80042086e9:	00 00 00 
  80042086ec:	be 45 01 00 00       	mov    $0x145,%esi
  80042086f1:	48 bf 8c 01 22 04 80 	movabs $0x800422018c,%rdi
  80042086f8:	00 00 00 
  80042086fb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208700:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004208707:	00 00 00 
  800420870a:	41 ff d0             	callq  *%r8
  800420870d:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004208714:	ff ff ff 
  8004208717:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420871b:	48 01 d0             	add    %rdx,%rax
  800420871e:	48 89 c7             	mov    %rax,%rdi
  8004208721:	48 b8 66 7d 20 04 80 	movabs $0x8004207d66,%rax
  8004208728:	00 00 00 
  800420872b:	ff d0                	callq  *%rax
  800420872d:	48 89 c7             	mov    %rax,%rdi
  8004208730:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  8004208737:	00 00 00 
  800420873a:	ff d0                	callq  *%rax
	// Free msr load/store area.
	page_decref(pa2page(PADDR(e->env_vmxinfo.msr_host_area)));
  800420873c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208740:	48 8b 80 50 01 00 00 	mov    0x150(%rax),%rax
  8004208747:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420874b:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004208752:	00 00 00 
  8004208755:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004208759:	77 32                	ja     800420878d <env_guest_free+0xde>
  800420875b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420875f:	48 89 c1             	mov    %rax,%rcx
  8004208762:	48 ba 68 01 22 04 80 	movabs $0x8004220168,%rdx
  8004208769:	00 00 00 
  800420876c:	be 47 01 00 00       	mov    $0x147,%esi
  8004208771:	48 bf 8c 01 22 04 80 	movabs $0x800422018c,%rdi
  8004208778:	00 00 00 
  800420877b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208780:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004208787:	00 00 00 
  800420878a:	41 ff d0             	callq  *%r8
  800420878d:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004208794:	ff ff ff 
  8004208797:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420879b:	48 01 d0             	add    %rdx,%rax
  800420879e:	48 89 c7             	mov    %rax,%rdi
  80042087a1:	48 b8 66 7d 20 04 80 	movabs $0x8004207d66,%rax
  80042087a8:	00 00 00 
  80042087ab:	ff d0                	callq  *%rax
  80042087ad:	48 89 c7             	mov    %rax,%rdi
  80042087b0:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  80042087b7:	00 00 00 
  80042087ba:	ff d0                	callq  *%rax
	// Free IO bitmaps page.
	page_decref(pa2page(PADDR(e->env_vmxinfo.io_bmap_a)));
  80042087bc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042087c0:	48 8b 80 38 01 00 00 	mov    0x138(%rax),%rax
  80042087c7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042087cb:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042087d2:	00 00 00 
  80042087d5:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80042087d9:	77 32                	ja     800420880d <env_guest_free+0x15e>
  80042087db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042087df:	48 89 c1             	mov    %rax,%rcx
  80042087e2:	48 ba 68 01 22 04 80 	movabs $0x8004220168,%rdx
  80042087e9:	00 00 00 
  80042087ec:	be 49 01 00 00       	mov    $0x149,%esi
  80042087f1:	48 bf 8c 01 22 04 80 	movabs $0x800422018c,%rdi
  80042087f8:	00 00 00 
  80042087fb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208800:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004208807:	00 00 00 
  800420880a:	41 ff d0             	callq  *%r8
  800420880d:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004208814:	ff ff ff 
  8004208817:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420881b:	48 01 d0             	add    %rdx,%rax
  800420881e:	48 89 c7             	mov    %rax,%rdi
  8004208821:	48 b8 66 7d 20 04 80 	movabs $0x8004207d66,%rax
  8004208828:	00 00 00 
  800420882b:	ff d0                	callq  *%rax
  800420882d:	48 89 c7             	mov    %rax,%rdi
  8004208830:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  8004208837:	00 00 00 
  800420883a:	ff d0                	callq  *%rax
	page_decref(pa2page(PADDR(e->env_vmxinfo.io_bmap_b)));
  800420883c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208840:	48 8b 80 40 01 00 00 	mov    0x140(%rax),%rax
  8004208847:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420884b:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004208852:	00 00 00 
  8004208855:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  8004208859:	77 32                	ja     800420888d <env_guest_free+0x1de>
  800420885b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420885f:	48 89 c1             	mov    %rax,%rcx
  8004208862:	48 ba 68 01 22 04 80 	movabs $0x8004220168,%rdx
  8004208869:	00 00 00 
  800420886c:	be 4a 01 00 00       	mov    $0x14a,%esi
  8004208871:	48 bf 8c 01 22 04 80 	movabs $0x800422018c,%rdi
  8004208878:	00 00 00 
  800420887b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208880:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004208887:	00 00 00 
  800420888a:	41 ff d0             	callq  *%r8
  800420888d:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004208894:	ff ff ff 
  8004208897:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420889b:	48 01 d0             	add    %rdx,%rax
  800420889e:	48 89 c7             	mov    %rax,%rdi
  80042088a1:	48 b8 66 7d 20 04 80 	movabs $0x8004207d66,%rax
  80042088a8:	00 00 00 
  80042088ab:	ff d0                	callq  *%rax
  80042088ad:	48 89 c7             	mov    %rax,%rdi
  80042088b0:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  80042088b7:	00 00 00 
  80042088ba:	ff d0                	callq  *%rax
    
	// Free the host pages that were allocated for the guest and 
	// the EPT tables itself.
	free_guest_mem(e->env_pml4e);
  80042088bc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042088c0:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042088c7:	48 89 c7             	mov    %rax,%rdi
  80042088ca:	48 b8 85 9c 21 04 80 	movabs $0x8004219c85,%rax
  80042088d1:	00 00 00 
  80042088d4:	ff d0                	callq  *%rax

	// Free the EPT PML4 page.
	page_decref(pa2page(e->env_cr3));
  80042088d6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042088da:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042088e1:	48 89 c7             	mov    %rax,%rdi
  80042088e4:	48 b8 66 7d 20 04 80 	movabs $0x8004207d66,%rax
  80042088eb:	00 00 00 
  80042088ee:	ff d0                	callq  *%rax
  80042088f0:	48 89 c7             	mov    %rax,%rdi
  80042088f3:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  80042088fa:	00 00 00 
  80042088fd:	ff d0                	callq  *%rax
	e->env_pml4e = 0;
  80042088ff:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208903:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  800420890a:	00 00 00 00 
	e->env_cr3 = 0;
  800420890e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208912:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8004208919:	00 00 00 00 

	// return the environment to the free list
	e->env_status = ENV_FREE;
  800420891d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208921:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8004208928:	00 00 00 
	e->env_link = env_free_list;
  800420892b:	48 b8 60 d2 4d 04 80 	movabs $0x80044dd260,%rax
  8004208932:	00 00 00 
  8004208935:	48 8b 10             	mov    (%rax),%rdx
  8004208938:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420893c:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  8004208943:	48 b8 60 d2 4d 04 80 	movabs $0x80044dd260,%rax
  800420894a:	00 00 00 
  800420894d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004208951:	48 89 10             	mov    %rdx,(%rax)

	cprintf("[%08x] free vmx guest env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
  8004208954:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208958:	8b 98 c8 00 00 00    	mov    0xc8(%rax),%ebx
  800420895e:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  8004208965:	00 00 00 
  8004208968:	ff d0                	callq  *%rax
  800420896a:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  8004208971:	00 00 00 
  8004208974:	48 98                	cltq   
  8004208976:	48 c1 e0 03          	shl    $0x3,%rax
  800420897a:	48 89 c1             	mov    %rax,%rcx
  800420897d:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208981:	48 01 c8             	add    %rcx,%rax
  8004208984:	48 01 d0             	add    %rdx,%rax
  8004208987:	48 83 c0 08          	add    $0x8,%rax
  800420898b:	48 8b 00             	mov    (%rax),%rax
  800420898e:	48 85 c0             	test   %rax,%rax
  8004208991:	74 38                	je     80042089cb <env_guest_free+0x31c>
  8004208993:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420899a:	00 00 00 
  800420899d:	ff d0                	callq  *%rax
  800420899f:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  80042089a6:	00 00 00 
  80042089a9:	48 98                	cltq   
  80042089ab:	48 c1 e0 03          	shl    $0x3,%rax
  80042089af:	48 89 c1             	mov    %rax,%rcx
  80042089b2:	48 c1 e1 04          	shl    $0x4,%rcx
  80042089b6:	48 01 c8             	add    %rcx,%rax
  80042089b9:	48 01 d0             	add    %rdx,%rax
  80042089bc:	48 83 c0 08          	add    $0x8,%rax
  80042089c0:	48 8b 00             	mov    (%rax),%rax
  80042089c3:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042089c9:	eb 05                	jmp    80042089d0 <env_guest_free+0x321>
  80042089cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042089d0:	89 da                	mov    %ebx,%edx
  80042089d2:	89 c6                	mov    %eax,%esi
  80042089d4:	48 bf 98 01 22 04 80 	movabs $0x8004220198,%rdi
  80042089db:	00 00 00 
  80042089de:	b8 00 00 00 00       	mov    $0x0,%eax
  80042089e3:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  80042089ea:	00 00 00 
  80042089ed:	ff d1                	callq  *%rcx
}
  80042089ef:	90                   	nop
  80042089f0:	48 83 c4 38          	add    $0x38,%rsp
  80042089f4:	5b                   	pop    %rbx
  80042089f5:	5d                   	pop    %rbp
  80042089f6:	c3                   	retq   

00000080042089f7 <env_alloc>:
//	-E_NO_FREE_ENV if all NENVS environments are allocated
//	-E_NO_MEM on memory exhaustion
//
int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
  80042089f7:	55                   	push   %rbp
  80042089f8:	48 89 e5             	mov    %rsp,%rbp
  80042089fb:	48 83 ec 30          	sub    $0x30,%rsp
  80042089ff:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004208a03:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	int32_t generation;
	int r;
	struct Env *e;

	if (!(e = env_free_list))
  8004208a06:	48 b8 60 d2 4d 04 80 	movabs $0x80044dd260,%rax
  8004208a0d:	00 00 00 
  8004208a10:	48 8b 00             	mov    (%rax),%rax
  8004208a13:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004208a17:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004208a1c:	75 0a                	jne    8004208a28 <env_alloc+0x31>
		return -E_NO_FREE_ENV;
  8004208a1e:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  8004208a23:	e9 69 01 00 00       	jmpq   8004208b91 <env_alloc+0x19a>

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
  8004208a28:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208a2c:	48 89 c7             	mov    %rax,%rdi
  8004208a2f:	48 b8 17 81 20 04 80 	movabs $0x8004208117,%rax
  8004208a36:	00 00 00 
  8004208a39:	ff d0                	callq  *%rax
  8004208a3b:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004208a3e:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8004208a42:	79 08                	jns    8004208a4c <env_alloc+0x55>
		return r;
  8004208a44:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208a47:	e9 45 01 00 00       	jmpq   8004208b91 <env_alloc+0x19a>

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  8004208a4c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208a50:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004208a56:	05 00 10 00 00       	add    $0x1000,%eax
  8004208a5b:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  8004208a60:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  8004208a63:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004208a67:	7f 07                	jg     8004208a70 <env_alloc+0x79>
		generation = 1 << ENVGENSHIFT;
  8004208a69:	c7 45 fc 00 10 00 00 	movl   $0x1000,-0x4(%rbp)
	e->env_id = generation | (e - envs);
  8004208a70:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004208a74:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  8004208a7b:	00 00 00 
  8004208a7e:	48 8b 00             	mov    (%rax),%rax
  8004208a81:	48 29 c2             	sub    %rax,%rdx
  8004208a84:	48 89 d0             	mov    %rdx,%rax
  8004208a87:	48 c1 f8 03          	sar    $0x3,%rax
  8004208a8b:	48 89 c2             	mov    %rax,%rdx
  8004208a8e:	48 b8 a5 4f fa a4 4f 	movabs $0x4fa4fa4fa4fa4fa5,%rax
  8004208a95:	fa a4 4f 
  8004208a98:	48 0f af c2          	imul   %rdx,%rax
  8004208a9c:	0b 45 fc             	or     -0x4(%rbp),%eax
  8004208a9f:	89 c2                	mov    %eax,%edx
  8004208aa1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208aa5:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  8004208aab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208aaf:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004208ab2:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_USER;
  8004208ab8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208abc:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  8004208ac3:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  8004208ac6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208aca:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004208ad1:	00 00 00 
	e->env_runs = 0;
  8004208ad4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208ad8:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  8004208adf:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
  8004208ae2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208ae6:	ba c0 00 00 00       	mov    $0xc0,%edx
  8004208aeb:	be 00 00 00 00       	mov    $0x0,%esi
  8004208af0:	48 89 c7             	mov    %rax,%rdi
  8004208af3:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  8004208afa:	00 00 00 
  8004208afd:	ff d0                	callq  *%rax
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.  When
	// we switch privilege levels, the hardware does various
	// checks involving the RPL and the Descriptor Privilege Level
	// (DPL) stored in the descriptors themselves.
	e->env_tf.tf_ds = GD_UD | 3;
  8004208aff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208b03:	66 c7 80 80 00 00 00 	movw   $0x23,0x80(%rax)
  8004208b0a:	23 00 
	e->env_tf.tf_es = GD_UD | 3;
  8004208b0c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208b10:	66 c7 40 78 23 00    	movw   $0x23,0x78(%rax)
	e->env_tf.tf_ss = GD_UD | 3;
  8004208b16:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208b1a:	66 c7 80 b8 00 00 00 	movw   $0x23,0xb8(%rax)
  8004208b21:	23 00 
	e->env_tf.tf_rsp = USTACKTOP;
  8004208b23:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208b27:	b9 00 e0 7f ef       	mov    $0xef7fe000,%ecx
  8004208b2c:	48 89 88 b0 00 00 00 	mov    %rcx,0xb0(%rax)
	e->env_tf.tf_cs = GD_UT | 3;
  8004208b33:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208b37:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  8004208b3e:	1b 00 


	// Enable interrupts while in user mode.
	// LAB 4: Your code here.

	e->env_tf.tf_eflags = FL_IF; // interrupts enabled
  8004208b40:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208b44:	48 c7 80 a8 00 00 00 	movq   $0x200,0xa8(%rax)
  8004208b4b:	00 02 00 00 


	// Clear the page fault handler until user installs one.
	e->env_pgfault_upcall = 0;
  8004208b4f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208b53:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  8004208b5a:	00 00 00 00 

	// Also clear the IPC receiving flag.
	e->env_ipc_recving = 0;
  8004208b5e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208b62:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)


	// commit the allocation
	env_free_list = e->env_link;
  8004208b69:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208b6d:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  8004208b74:	48 b8 60 d2 4d 04 80 	movabs $0x80044dd260,%rax
  8004208b7b:	00 00 00 
  8004208b7e:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  8004208b81:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208b85:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004208b89:	48 89 10             	mov    %rdx,(%rax)


	// cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);

	return 0;
  8004208b8c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004208b91:	c9                   	leaveq 
  8004208b92:	c3                   	retq   

0000008004208b93 <region_alloc>:
// Pages should be writable by user and kernel.
// Panic if any allocation attempt fails.
//
static void
region_alloc(struct Env *e, void *va, size_t len)
{
  8004208b93:	55                   	push   %rbp
  8004208b94:	48 89 e5             	mov    %rsp,%rbp
  8004208b97:	48 83 ec 40          	sub    $0x40,%rsp
  8004208b9b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004208b9f:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004208ba3:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)

	int r;
	struct PageInfo *pp;
	void *endva = (uint8_t*) va + len;
  8004208ba7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004208bab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208baf:	48 01 d0             	add    %rdx,%rax
  8004208bb2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	while (va < endva) {
  8004208bb6:	e9 c8 00 00 00       	jmpq   8004208c83 <region_alloc+0xf0>
		// Allocate and map a page covering virtual address va.
		if (!(pp = page_alloc(0)))
  8004208bbb:	bf 00 00 00 00       	mov    $0x0,%edi
  8004208bc0:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004208bc7:	00 00 00 
  8004208bca:	ff d0                	callq  *%rax
  8004208bcc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004208bd0:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004208bd5:	75 30                	jne    8004208c07 <region_alloc+0x74>
			panic("map_segment: could not alloc page: %e\n", -E_NO_MEM);
  8004208bd7:	b9 fc ff ff ff       	mov    $0xfffffffc,%ecx
  8004208bdc:	48 ba b8 01 22 04 80 	movabs $0x80042201b8,%rdx
  8004208be3:	00 00 00 
  8004208be6:	be c0 01 00 00       	mov    $0x1c0,%esi
  8004208beb:	48 bf 8c 01 22 04 80 	movabs $0x800422018c,%rdi
  8004208bf2:	00 00 00 
  8004208bf5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208bfa:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004208c01:	00 00 00 
  8004208c04:	41 ff d0             	callq  *%r8

		// Insert the page into the env's address space
		if ((r = page_insert(e->env_pml4e, pp, va, PTE_P|PTE_W|PTE_U)) < 0)
  8004208c07:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208c0b:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208c12:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004208c16:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004208c1a:	b9 07 00 00 00       	mov    $0x7,%ecx
  8004208c1f:	48 89 c7             	mov    %rax,%rdi
  8004208c22:	48 b8 7d 3a 20 04 80 	movabs $0x8004203a7d,%rax
  8004208c29:	00 00 00 
  8004208c2c:	ff d0                	callq  *%rax
  8004208c2e:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004208c31:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8004208c35:	79 30                	jns    8004208c67 <region_alloc+0xd4>
			panic("map_segment: could not insert page: %e\n", r);
  8004208c37:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208c3a:	89 c1                	mov    %eax,%ecx
  8004208c3c:	48 ba e0 01 22 04 80 	movabs $0x80042201e0,%rdx
  8004208c43:	00 00 00 
  8004208c46:	be c4 01 00 00       	mov    $0x1c4,%esi
  8004208c4b:	48 bf 8c 01 22 04 80 	movabs $0x800422018c,%rdi
  8004208c52:	00 00 00 
  8004208c55:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208c5a:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004208c61:	00 00 00 
  8004208c64:	41 ff d0             	callq  *%r8

		va = ROUNDDOWN((uint8_t*) va + PGSIZE, PGSIZE);
  8004208c67:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208c6b:	48 05 00 10 00 00    	add    $0x1000,%rax
  8004208c71:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004208c75:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208c79:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208c7f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	int r;
	struct PageInfo *pp;
	void *endva = (uint8_t*) va + len;

	while (va < endva) {
  8004208c83:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208c87:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208c8b:	0f 82 2a ff ff ff    	jb     8004208bbb <region_alloc+0x28>
	//
	// Hint: It is easier to use region_alloc if the caller can pass
	//   'va' and 'len' values that are not page-aligned.
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
}
  8004208c91:	90                   	nop
  8004208c92:	c9                   	leaveq 
  8004208c93:	c3                   	retq   

0000008004208c94 <load_icode>:
// load_icode panics if it encounters problems.
//  - How might load_icode fail?  What might be wrong with the given input?
//
void
load_icode(struct Env *e, uint8_t *binary)
{
  8004208c94:	55                   	push   %rbp
  8004208c95:	48 89 e5             	mov    %rsp,%rbp
  8004208c98:	48 83 ec 70          	sub    $0x70,%rsp
  8004208c9c:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  8004208ca0:	48 89 75 90          	mov    %rsi,-0x70(%rbp)

	struct Elf *elf = (struct Elf *)binary;
  8004208ca4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004208ca8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	struct Proghdr *ph, *eph;

	if (elf && elf->e_magic == ELF_MAGIC) {
  8004208cac:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004208cb1:	0f 84 72 03 00 00    	je     8004209029 <load_icode+0x395>
  8004208cb7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208cbb:	8b 00                	mov    (%rax),%eax
  8004208cbd:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  8004208cc2:	0f 85 61 03 00 00    	jne    8004209029 <load_icode+0x395>
		lcr3(PADDR((uint64_t)e->env_pml4e));
  8004208cc8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208ccc:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208cd3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004208cd7:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004208cde:	00 00 00 
  8004208ce1:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004208ce5:	77 32                	ja     8004208d19 <load_icode+0x85>
  8004208ce7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208ceb:	48 89 c1             	mov    %rax,%rcx
  8004208cee:	48 ba 68 01 22 04 80 	movabs $0x8004220168,%rdx
  8004208cf5:	00 00 00 
  8004208cf8:	be f0 01 00 00       	mov    $0x1f0,%esi
  8004208cfd:	48 bf 8c 01 22 04 80 	movabs $0x800422018c,%rdi
  8004208d04:	00 00 00 
  8004208d07:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208d0c:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004208d13:	00 00 00 
  8004208d16:	41 ff d0             	callq  *%r8
  8004208d19:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004208d20:	ff ff ff 
  8004208d23:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208d27:	48 01 d0             	add    %rdx,%rax
  8004208d2a:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004208d2e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208d32:	0f 22 d8             	mov    %rax,%cr3
		ph  = (struct Proghdr *)((uint8_t *)elf + elf->e_phoff);
  8004208d35:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208d39:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004208d3d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208d41:	48 01 d0             	add    %rdx,%rax
  8004208d44:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		eph = ph + elf->e_phnum;
  8004208d48:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208d4c:	0f b7 40 38          	movzwl 0x38(%rax),%eax
  8004208d50:	0f b7 c0             	movzwl %ax,%eax
  8004208d53:	48 c1 e0 03          	shl    $0x3,%rax
  8004208d57:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208d5e:	00 
  8004208d5f:	48 29 c2             	sub    %rax,%rdx
  8004208d62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208d66:	48 01 d0             	add    %rdx,%rax
  8004208d69:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		for(;ph < eph; ph++) {
  8004208d6d:	e9 c0 00 00 00       	jmpq   8004208e32 <load_icode+0x19e>
			if (ph->p_type == ELF_PROG_LOAD) {
  8004208d72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208d76:	8b 00                	mov    (%rax),%eax
  8004208d78:	83 f8 01             	cmp    $0x1,%eax
  8004208d7b:	0f 85 ac 00 00 00    	jne    8004208e2d <load_icode+0x199>
				region_alloc(e, (void *)ph->p_va, ph->p_memsz);
  8004208d81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208d85:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004208d89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208d8d:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004208d91:	48 89 c1             	mov    %rax,%rcx
  8004208d94:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208d98:	48 89 ce             	mov    %rcx,%rsi
  8004208d9b:	48 89 c7             	mov    %rax,%rdi
  8004208d9e:	48 b8 93 8b 20 04 80 	movabs $0x8004208b93,%rax
  8004208da5:	00 00 00 
  8004208da8:	ff d0                	callq  *%rax
				memcpy((void *)ph->p_va, (void *)((uint8_t *)elf + ph->p_offset), ph->p_filesz);
  8004208daa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208dae:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004208db2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004208db6:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004208dba:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004208dbe:	48 01 d1             	add    %rdx,%rcx
  8004208dc1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004208dc5:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004208dc9:	48 89 d7             	mov    %rdx,%rdi
  8004208dcc:	48 89 c2             	mov    %rax,%rdx
  8004208dcf:	48 89 ce             	mov    %rcx,%rsi
  8004208dd2:	48 b8 2d 11 21 04 80 	movabs $0x800421112d,%rax
  8004208dd9:	00 00 00 
  8004208ddc:	ff d0                	callq  *%rax
				if (ph->p_filesz < ph->p_memsz) {
  8004208dde:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208de2:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004208de6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208dea:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004208dee:	48 39 c2             	cmp    %rax,%rdx
  8004208df1:	73 3a                	jae    8004208e2d <load_icode+0x199>
					memset((void *)(ph->p_va + ph->p_filesz), 0, ph->p_memsz-ph->p_filesz);
  8004208df3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208df7:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004208dfb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208dff:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004208e03:	48 29 c2             	sub    %rax,%rdx
  8004208e06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208e0a:	48 8b 48 10          	mov    0x10(%rax),%rcx
  8004208e0e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208e12:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004208e16:	48 01 c8             	add    %rcx,%rax
  8004208e19:	be 00 00 00 00       	mov    $0x0,%esi
  8004208e1e:	48 89 c7             	mov    %rax,%rdi
  8004208e21:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  8004208e28:	00 00 00 
  8004208e2b:	ff d0                	callq  *%rax

	if (elf && elf->e_magic == ELF_MAGIC) {
		lcr3(PADDR((uint64_t)e->env_pml4e));
		ph  = (struct Proghdr *)((uint8_t *)elf + elf->e_phoff);
		eph = ph + elf->e_phnum;
		for(;ph < eph; ph++) {
  8004208e2d:	48 83 45 f8 38       	addq   $0x38,-0x8(%rbp)
  8004208e32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208e36:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004208e3a:	0f 82 32 ff ff ff    	jb     8004208d72 <load_icode+0xde>
				if (ph->p_filesz < ph->p_memsz) {
					memset((void *)(ph->p_va + ph->p_filesz), 0, ph->p_memsz-ph->p_filesz);
				}
			}
		}
		region_alloc(e, (void*) (USTACKTOP - PGSIZE), PGSIZE);
  8004208e40:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208e44:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004208e49:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  8004208e4e:	48 89 c7             	mov    %rax,%rdi
  8004208e51:	48 b8 93 8b 20 04 80 	movabs $0x8004208b93,%rax
  8004208e58:	00 00 00 
  8004208e5b:	ff d0                	callq  *%rax
		e->env_tf.tf_rip    = elf->e_entry;
  8004208e5d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208e61:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004208e65:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208e69:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		e->env_tf.tf_rsp    = USTACKTOP; //keeping stack 8 byte aligned
  8004208e70:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208e74:	be 00 e0 7f ef       	mov    $0xef7fe000,%esi
  8004208e79:	48 89 b0 b0 00 00 00 	mov    %rsi,0xb0(%rax)

		uintptr_t debug_address = USTABDATA;
  8004208e80:	48 c7 45 f0 00 00 20 	movq   $0x200000,-0x10(%rbp)
  8004208e87:	00 
		struct Secthdr *sh = (struct Secthdr *)(((uint8_t *)elf + elf->e_shoff));
  8004208e88:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208e8c:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004208e90:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208e94:	48 01 d0             	add    %rdx,%rax
  8004208e97:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		struct Secthdr *shstr_tab = sh + elf->e_shstrndx;
  8004208e9b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208e9f:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004208ea3:	0f b7 c0             	movzwl %ax,%eax
  8004208ea6:	48 c1 e0 06          	shl    $0x6,%rax
  8004208eaa:	48 89 c2             	mov    %rax,%rdx
  8004208ead:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208eb1:	48 01 d0             	add    %rdx,%rax
  8004208eb4:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		struct Secthdr* esh = sh + elf->e_shnum;
  8004208eb8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208ebc:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004208ec0:	0f b7 c0             	movzwl %ax,%eax
  8004208ec3:	48 c1 e0 06          	shl    $0x6,%rax
  8004208ec7:	48 89 c2             	mov    %rax,%rdx
  8004208eca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208ece:	48 01 d0             	add    %rdx,%rax
  8004208ed1:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for(;sh < esh; sh++) {
  8004208ed5:	e9 27 01 00 00       	jmpq   8004209001 <load_icode+0x36d>
			char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  8004208eda:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004208ede:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004208ee2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208ee6:	8b 00                	mov    (%rax),%eax
  8004208ee8:	89 c0                	mov    %eax,%eax
  8004208eea:	48 01 c2             	add    %rax,%rdx
  8004208eed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208ef1:	48 01 d0             	add    %rdx,%rax
  8004208ef4:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
			if(!strcmp(name, ".debug_info") || !strcmp(name, ".debug_abbrev")
  8004208ef8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004208efc:	48 be 08 02 22 04 80 	movabs $0x8004220208,%rsi
  8004208f03:	00 00 00 
  8004208f06:	48 89 c7             	mov    %rax,%rdi
  8004208f09:	48 b8 53 0e 21 04 80 	movabs $0x8004210e53,%rax
  8004208f10:	00 00 00 
  8004208f13:	ff d0                	callq  *%rax
  8004208f15:	85 c0                	test   %eax,%eax
  8004208f17:	0f 84 84 00 00 00    	je     8004208fa1 <load_icode+0x30d>
  8004208f1d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004208f21:	48 be 14 02 22 04 80 	movabs $0x8004220214,%rsi
  8004208f28:	00 00 00 
  8004208f2b:	48 89 c7             	mov    %rax,%rdi
  8004208f2e:	48 b8 53 0e 21 04 80 	movabs $0x8004210e53,%rax
  8004208f35:	00 00 00 
  8004208f38:	ff d0                	callq  *%rax
  8004208f3a:	85 c0                	test   %eax,%eax
  8004208f3c:	74 63                	je     8004208fa1 <load_icode+0x30d>
			   || !strcmp(name, ".debug_line") || !strcmp(name, ".eh_frame")
  8004208f3e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004208f42:	48 be 22 02 22 04 80 	movabs $0x8004220222,%rsi
  8004208f49:	00 00 00 
  8004208f4c:	48 89 c7             	mov    %rax,%rdi
  8004208f4f:	48 b8 53 0e 21 04 80 	movabs $0x8004210e53,%rax
  8004208f56:	00 00 00 
  8004208f59:	ff d0                	callq  *%rax
  8004208f5b:	85 c0                	test   %eax,%eax
  8004208f5d:	74 42                	je     8004208fa1 <load_icode+0x30d>
  8004208f5f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004208f63:	48 be 2e 02 22 04 80 	movabs $0x800422022e,%rsi
  8004208f6a:	00 00 00 
  8004208f6d:	48 89 c7             	mov    %rax,%rdi
  8004208f70:	48 b8 53 0e 21 04 80 	movabs $0x8004210e53,%rax
  8004208f77:	00 00 00 
  8004208f7a:	ff d0                	callq  *%rax
  8004208f7c:	85 c0                	test   %eax,%eax
  8004208f7e:	74 21                	je     8004208fa1 <load_icode+0x30d>
			   || !strcmp(name, ".debug_str")) {
  8004208f80:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004208f84:	48 be 38 02 22 04 80 	movabs $0x8004220238,%rsi
  8004208f8b:	00 00 00 
  8004208f8e:	48 89 c7             	mov    %rax,%rdi
  8004208f91:	48 b8 53 0e 21 04 80 	movabs $0x8004210e53,%rax
  8004208f98:	00 00 00 
  8004208f9b:	ff d0                	callq  *%rax
  8004208f9d:	85 c0                	test   %eax,%eax
  8004208f9f:	75 5b                	jne    8004208ffc <load_icode+0x368>
				region_alloc(e ,(void*)debug_address, sh->sh_size);
  8004208fa1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208fa5:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004208fa9:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8004208fad:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208fb1:	48 89 ce             	mov    %rcx,%rsi
  8004208fb4:	48 89 c7             	mov    %rax,%rdi
  8004208fb7:	48 b8 93 8b 20 04 80 	movabs $0x8004208b93,%rax
  8004208fbe:	00 00 00 
  8004208fc1:	ff d0                	callq  *%rax
				memcpy((void *)debug_address, (void *)((uint8_t *)elf + sh->sh_offset), 
  8004208fc3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208fc7:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004208fcb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208fcf:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004208fd3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208fd7:	48 01 c1             	add    %rax,%rcx
  8004208fda:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208fde:	48 89 ce             	mov    %rcx,%rsi
  8004208fe1:	48 89 c7             	mov    %rax,%rdi
  8004208fe4:	48 b8 2d 11 21 04 80 	movabs $0x800421112d,%rax
  8004208feb:	00 00 00 
  8004208fee:	ff d0                	callq  *%rax
				       sh->sh_size);
				debug_address += sh->sh_size;
  8004208ff0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208ff4:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004208ff8:	48 01 45 f0          	add    %rax,-0x10(%rbp)

		uintptr_t debug_address = USTABDATA;
		struct Secthdr *sh = (struct Secthdr *)(((uint8_t *)elf + elf->e_shoff));
		struct Secthdr *shstr_tab = sh + elf->e_shstrndx;
		struct Secthdr* esh = sh + elf->e_shnum;
		for(;sh < esh; sh++) {
  8004208ffc:	48 83 45 e8 40       	addq   $0x40,-0x18(%rbp)
  8004209001:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209005:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004209009:	0f 82 cb fe ff ff    	jb     8004208eda <load_icode+0x246>
				memcpy((void *)debug_address, (void *)((uint8_t *)elf + sh->sh_offset), 
				       sh->sh_size);
				debug_address += sh->sh_size;
			}
		}
		lcr3(boot_cr3);
  800420900f:	48 b8 e8 c5 6d 04 80 	movabs $0x80046dc5e8,%rax
  8004209016:	00 00 00 
  8004209019:	48 8b 00             	mov    (%rax),%rax
  800420901c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004209020:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004209024:	0f 22 d8             	mov    %rax,%cr3
{

	struct Elf *elf = (struct Elf *)binary;
	struct Proghdr *ph, *eph;

	if (elf && elf->e_magic == ELF_MAGIC) {
  8004209027:	eb 2a                	jmp    8004209053 <load_icode+0x3bf>
				debug_address += sh->sh_size;
			}
		}
		lcr3(boot_cr3);
	} else {
		panic("Invalid Binary");
  8004209029:	48 ba 43 02 22 04 80 	movabs $0x8004220243,%rdx
  8004209030:	00 00 00 
  8004209033:	be 11 02 00 00       	mov    $0x211,%esi
  8004209038:	48 bf 8c 01 22 04 80 	movabs $0x800422018c,%rdi
  800420903f:	00 00 00 
  8004209042:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209047:	48 b9 f3 04 20 04 80 	movabs $0x80042004f3,%rcx
  800420904e:	00 00 00 
  8004209051:	ff d1                	callq  *%rcx
	}
	// Give environment a stack

	e->elf = binary;
  8004209053:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004209057:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420905b:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)

}
  8004209062:	90                   	nop
  8004209063:	c9                   	leaveq 
  8004209064:	c3                   	retq   

0000008004209065 <env_create>:
// before running the first user-mode environment.
// The new env's parent ID is set to 0.
//
void
env_create(uint8_t *binary, enum EnvType type)
{
  8004209065:	55                   	push   %rbp
  8004209066:	48 89 e5             	mov    %rsp,%rbp
  8004209069:	48 83 ec 20          	sub    $0x20,%rsp
  800420906d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004209071:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// LAB 3: Your code here.

	int r;
	struct Env *e;
	if ((r = env_alloc(&e, 0)) < 0)
  8004209074:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8004209078:	be 00 00 00 00       	mov    $0x0,%esi
  800420907d:	48 89 c7             	mov    %rax,%rdi
  8004209080:	48 b8 f7 89 20 04 80 	movabs $0x80042089f7,%rax
  8004209087:	00 00 00 
  800420908a:	ff d0                	callq  *%rax
  800420908c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420908f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004209093:	79 30                	jns    80042090c5 <env_create+0x60>
		panic("env_create: could not allocate env: %e\n", r);
  8004209095:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209098:	89 c1                	mov    %eax,%ecx
  800420909a:	48 ba 58 02 22 04 80 	movabs $0x8004220258,%rdx
  80042090a1:	00 00 00 
  80042090a4:	be 28 02 00 00       	mov    $0x228,%esi
  80042090a9:	48 bf 8c 01 22 04 80 	movabs $0x800422018c,%rdi
  80042090b0:	00 00 00 
  80042090b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042090b8:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042090bf:	00 00 00 
  80042090c2:	41 ff d0             	callq  *%r8
	load_icode(e, binary);
  80042090c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042090c9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042090cd:	48 89 d6             	mov    %rdx,%rsi
  80042090d0:	48 89 c7             	mov    %rax,%rdi
  80042090d3:	48 b8 94 8c 20 04 80 	movabs $0x8004208c94,%rax
  80042090da:	00 00 00 
  80042090dd:	ff d0                	callq  *%rax
	e->env_type = type;
  80042090df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042090e3:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042090e6:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)


	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
	// LAB 5: Your code here.

	if (type == ENV_TYPE_FS)
  80042090ec:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  80042090f0:	75 19                	jne    800420910b <env_create+0xa6>
		e->env_tf.tf_eflags |= FL_IOPL_3;
  80042090f2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042090f6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042090fa:	48 8b 92 a8 00 00 00 	mov    0xa8(%rdx),%rdx
  8004209101:	80 ce 30             	or     $0x30,%dh
  8004209104:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)

}
  800420910b:	90                   	nop
  800420910c:	c9                   	leaveq 
  800420910d:	c3                   	retq   

000000800420910e <env_free>:
//
// Frees env e and all memory it uses.
//
void
env_free(struct Env *e)
{
  800420910e:	55                   	push   %rbp
  800420910f:	48 89 e5             	mov    %rsp,%rbp
  8004209112:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  8004209119:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)


	// If freeing the current environment, switch to kern_pgdir
	// before freeing the page directory, just in case the page
	// gets reused.
	if (e == curenv)
  8004209120:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  8004209127:	00 00 00 
  800420912a:	ff d0                	callq  *%rax
  800420912c:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  8004209133:	00 00 00 
  8004209136:	48 98                	cltq   
  8004209138:	48 c1 e0 03          	shl    $0x3,%rax
  800420913c:	48 89 c1             	mov    %rax,%rcx
  800420913f:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209143:	48 01 c8             	add    %rcx,%rax
  8004209146:	48 01 d0             	add    %rdx,%rax
  8004209149:	48 83 c0 08          	add    $0x8,%rax
  800420914d:	48 8b 00             	mov    (%rax),%rax
  8004209150:	48 3b 85 78 ff ff ff 	cmp    -0x88(%rbp),%rax
  8004209157:	75 18                	jne    8004209171 <env_free+0x63>
		lcr3(boot_cr3);
  8004209159:	48 b8 e8 c5 6d 04 80 	movabs $0x80046dc5e8,%rax
  8004209160:	00 00 00 
  8004209163:	48 8b 00             	mov    (%rax),%rax
  8004209166:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  800420916a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800420916e:	0f 22 d8             	mov    %rax,%cr3

	// cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);


	// Flush all mapped pages in the user portion of the address space
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
  8004209171:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004209178:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420917f:	48 8b 00             	mov    (%rax),%rax
  8004209182:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004209188:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420918c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004209190:	48 c1 e8 0c          	shr    $0xc,%rax
  8004209194:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004209197:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420919a:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  80042091a1:	00 00 00 
  80042091a4:	48 8b 00             	mov    (%rax),%rax
  80042091a7:	48 39 c2             	cmp    %rax,%rdx
  80042091aa:	72 32                	jb     80042091de <env_free+0xd0>
  80042091ac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042091b0:	48 89 c1             	mov    %rax,%rcx
  80042091b3:	48 ba 28 01 22 04 80 	movabs $0x8004220128,%rdx
  80042091ba:	00 00 00 
  80042091bd:	be 54 02 00 00       	mov    $0x254,%esi
  80042091c2:	48 bf 8c 01 22 04 80 	movabs $0x800422018c,%rdi
  80042091c9:	00 00 00 
  80042091cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042091d1:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042091d8:	00 00 00 
  80042091db:	41 ff d0             	callq  *%r8
  80042091de:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042091e5:	00 00 00 
  80042091e8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042091ec:	48 01 d0             	add    %rdx,%rax
  80042091ef:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  80042091f3:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042091fa:	00 
  80042091fb:	e9 af 02 00 00       	jmpq   80042094af <env_free+0x3a1>
		if(!(env_pdpe[pdpe_index] & PTE_P))
  8004209200:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209204:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420920b:	00 
  800420920c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004209210:	48 01 d0             	add    %rdx,%rax
  8004209213:	48 8b 00             	mov    (%rax),%rax
  8004209216:	83 e0 01             	and    $0x1,%eax
  8004209219:	48 85 c0             	test   %rax,%rax
  800420921c:	0f 84 87 02 00 00    	je     80042094a9 <env_free+0x39b>
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
  8004209222:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209226:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420922d:	00 
  800420922e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004209232:	48 01 d0             	add    %rdx,%rax
  8004209235:	48 8b 00             	mov    (%rax),%rax
  8004209238:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420923e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004209242:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004209246:	48 c1 e8 0c          	shr    $0xc,%rax
  800420924a:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  800420924d:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004209250:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004209257:	00 00 00 
  800420925a:	48 8b 00             	mov    (%rax),%rax
  800420925d:	48 39 c2             	cmp    %rax,%rdx
  8004209260:	72 32                	jb     8004209294 <env_free+0x186>
  8004209262:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004209266:	48 89 c1             	mov    %rax,%rcx
  8004209269:	48 ba 28 01 22 04 80 	movabs $0x8004220128,%rdx
  8004209270:	00 00 00 
  8004209273:	be 5c 02 00 00       	mov    $0x25c,%esi
  8004209278:	48 bf 8c 01 22 04 80 	movabs $0x800422018c,%rdi
  800420927f:	00 00 00 
  8004209282:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209287:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420928e:	00 00 00 
  8004209291:	41 ff d0             	callq  *%r8
  8004209294:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420929b:	00 00 00 
  800420929e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042092a2:	48 01 d0             	add    %rdx,%rax
  80042092a5:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
  80042092a9:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  80042092ae:	75 07                	jne    80042092b7 <env_free+0x1a9>
  80042092b0:	b8 04 00 00 00       	mov    $0x4,%eax
  80042092b5:	eb 05                	jmp    80042092bc <env_free+0x1ae>
  80042092b7:	b8 ff 01 00 00       	mov    $0x1ff,%eax
  80042092bc:	89 45 b4             	mov    %eax,-0x4c(%rbp)
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  80042092bf:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042092c6:	00 
  80042092c7:	e9 70 01 00 00       	jmpq   800420943c <env_free+0x32e>

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
  80042092cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042092d0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042092d7:	00 
  80042092d8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042092dc:	48 01 d0             	add    %rdx,%rax
  80042092df:	48 8b 00             	mov    (%rax),%rax
  80042092e2:	83 e0 01             	and    $0x1,%eax
  80042092e5:	48 85 c0             	test   %rax,%rax
  80042092e8:	0f 84 48 01 00 00    	je     8004209436 <env_free+0x328>
				continue;
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
  80042092ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042092f2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042092f9:	00 
  80042092fa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042092fe:	48 01 d0             	add    %rdx,%rax
  8004209301:	48 8b 00             	mov    (%rax),%rax
  8004209304:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420930a:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			pt = (pte_t*) KADDR(pa);
  800420930e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004209312:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004209316:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420931a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420931e:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004209321:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004209324:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  800420932b:	00 00 00 
  800420932e:	48 8b 00             	mov    (%rax),%rax
  8004209331:	48 39 c2             	cmp    %rax,%rdx
  8004209334:	72 32                	jb     8004209368 <env_free+0x25a>
  8004209336:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420933a:	48 89 c1             	mov    %rax,%rcx
  800420933d:	48 ba 28 01 22 04 80 	movabs $0x8004220128,%rdx
  8004209344:	00 00 00 
  8004209347:	be 66 02 00 00       	mov    $0x266,%esi
  800420934c:	48 bf 8c 01 22 04 80 	movabs $0x800422018c,%rdi
  8004209353:	00 00 00 
  8004209356:	b8 00 00 00 00       	mov    $0x0,%eax
  800420935b:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004209362:	00 00 00 
  8004209365:	41 ff d0             	callq  *%r8
  8004209368:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420936f:	00 00 00 
  8004209372:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004209376:	48 01 d0             	add    %rdx,%rax
  8004209379:	48 89 45 90          	mov    %rax,-0x70(%rbp)

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  800420937d:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004209384:	00 
  8004209385:	eb 67                	jmp    80042093ee <env_free+0x2e0>
				if (pt[pteno] & PTE_P){
  8004209387:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420938b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209392:	00 
  8004209393:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004209397:	48 01 d0             	add    %rdx,%rax
  800420939a:	48 8b 00             	mov    (%rax),%rax
  800420939d:	83 e0 01             	and    $0x1,%eax
  80042093a0:	48 85 c0             	test   %rax,%rax
  80042093a3:	74 44                	je     80042093e9 <env_free+0x2db>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
  80042093a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042093a9:	48 c1 e0 1e          	shl    $0x1e,%rax
  80042093ad:	48 89 c2             	mov    %rax,%rdx
  80042093b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042093b4:	48 c1 e0 15          	shl    $0x15,%rax
  80042093b8:	48 09 c2             	or     %rax,%rdx
  80042093bb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042093bf:	48 c1 e0 0c          	shl    $0xc,%rax
  80042093c3:	48 09 d0             	or     %rdx,%rax
  80042093c6:	48 89 c2             	mov    %rax,%rdx
  80042093c9:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042093d0:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042093d7:	48 89 d6             	mov    %rdx,%rsi
  80042093da:	48 89 c7             	mov    %rax,%rdi
  80042093dd:	48 b8 7c 3e 20 04 80 	movabs $0x8004203e7c,%rax
  80042093e4:	00 00 00 
  80042093e7:	ff d0                	callq  *%rax
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
			pt = (pte_t*) KADDR(pa);

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  80042093e9:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  80042093ee:	48 81 7d f0 fe 01 00 	cmpq   $0x1fe,-0x10(%rbp)
  80042093f5:	00 
  80042093f6:	76 8f                	jbe    8004209387 <env_free+0x279>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
				}
			}

			// free the page table itself
			env_pgdir[pdeno] = 0;
  80042093f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042093fc:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209403:	00 
  8004209404:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004209408:	48 01 d0             	add    %rdx,%rax
  800420940b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(pa2page(pa));
  8004209412:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004209416:	48 89 c7             	mov    %rax,%rdi
  8004209419:	48 b8 66 7d 20 04 80 	movabs $0x8004207d66,%rax
  8004209420:	00 00 00 
  8004209423:	ff d0                	callq  *%rax
  8004209425:	48 89 c7             	mov    %rax,%rdi
  8004209428:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  800420942f:	00 00 00 
  8004209432:	ff d0                	callq  *%rax
  8004209434:	eb 01                	jmp    8004209437 <env_free+0x329>
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
				continue;
  8004209436:	90                   	nop
		if(!(env_pdpe[pdpe_index] & PTE_P))
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004209437:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420943c:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420943f:	48 98                	cltq   
  8004209441:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004209445:	0f 87 81 fe ff ff    	ja     80042092cc <env_free+0x1be>
			// free the page table itself
			env_pgdir[pdeno] = 0;
			page_decref(pa2page(pa));
		}
		// free the page directory
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
  800420944b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420944f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209456:	00 
  8004209457:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420945b:	48 01 d0             	add    %rdx,%rax
  800420945e:	48 8b 00             	mov    (%rax),%rax
  8004209461:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004209467:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
		env_pdpe[pdpe_index] = 0;
  800420946b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420946f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209476:	00 
  8004209477:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420947b:	48 01 d0             	add    %rdx,%rax
  800420947e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		page_decref(pa2page(pa));
  8004209485:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004209489:	48 89 c7             	mov    %rax,%rdi
  800420948c:	48 b8 66 7d 20 04 80 	movabs $0x8004207d66,%rax
  8004209493:	00 00 00 
  8004209496:	ff d0                	callq  *%rax
  8004209498:	48 89 c7             	mov    %rax,%rdi
  800420949b:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  80042094a2:	00 00 00 
  80042094a5:	ff d0                	callq  *%rax
  80042094a7:	eb 01                	jmp    80042094aa <env_free+0x39c>
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
		if(!(env_pdpe[pdpe_index] & PTE_P))
			continue;
  80042094a9:	90                   	nop
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  80042094aa:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  80042094af:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  80042094b4:	0f 86 46 fd ff ff    	jbe    8004209200 <env_free+0xf2>
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
		env_pdpe[pdpe_index] = 0;
		page_decref(pa2page(pa));
	}
	// free the page directory pointer
	page_decref(pa2page(PTE_ADDR(e->env_pml4e[0])));
  80042094ba:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042094c1:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042094c8:	48 8b 00             	mov    (%rax),%rax
  80042094cb:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042094d1:	48 89 c7             	mov    %rax,%rdi
  80042094d4:	48 b8 66 7d 20 04 80 	movabs $0x8004207d66,%rax
  80042094db:	00 00 00 
  80042094de:	ff d0                	callq  *%rax
  80042094e0:	48 89 c7             	mov    %rax,%rdi
  80042094e3:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  80042094ea:	00 00 00 
  80042094ed:	ff d0                	callq  *%rax
	// free the page map level 4 (PML4)
	e->env_pml4e[0] = 0;
  80042094ef:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042094f6:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042094fd:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	pa = e->env_cr3;
  8004209504:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420950b:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004209512:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	e->env_pml4e = 0;
  8004209516:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420951d:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  8004209524:	00 00 00 00 
	e->env_cr3 = 0;
  8004209528:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420952f:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8004209536:	00 00 00 00 
	page_decref(pa2page(pa));
  800420953a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420953e:	48 89 c7             	mov    %rax,%rdi
  8004209541:	48 b8 66 7d 20 04 80 	movabs $0x8004207d66,%rax
  8004209548:	00 00 00 
  800420954b:	ff d0                	callq  *%rax
  800420954d:	48 89 c7             	mov    %rax,%rdi
  8004209550:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  8004209557:	00 00 00 
  800420955a:	ff d0                	callq  *%rax

	// return the environment to the free list
	e->env_status = ENV_FREE;
  800420955c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004209563:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  800420956a:	00 00 00 
	e->env_link = env_free_list;
  800420956d:	48 b8 60 d2 4d 04 80 	movabs $0x80044dd260,%rax
  8004209574:	00 00 00 
  8004209577:	48 8b 10             	mov    (%rax),%rdx
  800420957a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004209581:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  8004209588:	48 b8 60 d2 4d 04 80 	movabs $0x80044dd260,%rax
  800420958f:	00 00 00 
  8004209592:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004209599:	48 89 10             	mov    %rdx,(%rax)
}
  800420959c:	90                   	nop
  800420959d:	c9                   	leaveq 
  800420959e:	c3                   	retq   

000000800420959f <env_destroy>:
// to the caller).

//
void
env_destroy(struct Env *e)
{
  800420959f:	55                   	push   %rbp
  80042095a0:	48 89 e5             	mov    %rsp,%rbp
  80042095a3:	48 83 ec 10          	sub    $0x10,%rsp
  80042095a7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

	// If e is currently running on other CPUs, we change its state to
	// ENV_DYING. A zombie environment will be freed the next time
	// it traps to the kernel.
	if (e->env_status == ENV_RUNNING && curenv != e) {
  80042095ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042095af:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042095b5:	83 f8 03             	cmp    $0x3,%eax
  80042095b8:	75 49                	jne    8004209603 <env_destroy+0x64>
  80042095ba:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  80042095c1:	00 00 00 
  80042095c4:	ff d0                	callq  *%rax
  80042095c6:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  80042095cd:	00 00 00 
  80042095d0:	48 98                	cltq   
  80042095d2:	48 c1 e0 03          	shl    $0x3,%rax
  80042095d6:	48 89 c1             	mov    %rax,%rcx
  80042095d9:	48 c1 e1 04          	shl    $0x4,%rcx
  80042095dd:	48 01 c8             	add    %rcx,%rax
  80042095e0:	48 01 d0             	add    %rdx,%rax
  80042095e3:	48 83 c0 08          	add    $0x8,%rax
  80042095e7:	48 8b 00             	mov    (%rax),%rax
  80042095ea:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042095ee:	74 13                	je     8004209603 <env_destroy+0x64>
		e->env_status = ENV_DYING;
  80042095f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042095f4:	c7 80 d4 00 00 00 01 	movl   $0x1,0xd4(%rax)
  80042095fb:	00 00 00 
		return;
  80042095fe:	e9 89 00 00 00       	jmpq   800420968c <env_destroy+0xed>
	}

	env_free(e);
  8004209603:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209607:	48 89 c7             	mov    %rax,%rdi
  800420960a:	48 b8 0e 91 20 04 80 	movabs $0x800420910e,%rax
  8004209611:	00 00 00 
  8004209614:	ff d0                	callq  *%rax
	if (curenv == e) {
  8004209616:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420961d:	00 00 00 
  8004209620:	ff d0                	callq  *%rax
  8004209622:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  8004209629:	00 00 00 
  800420962c:	48 98                	cltq   
  800420962e:	48 c1 e0 03          	shl    $0x3,%rax
  8004209632:	48 89 c1             	mov    %rax,%rcx
  8004209635:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209639:	48 01 c8             	add    %rcx,%rax
  800420963c:	48 01 d0             	add    %rdx,%rax
  800420963f:	48 83 c0 08          	add    $0x8,%rax
  8004209643:	48 8b 00             	mov    (%rax),%rax
  8004209646:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420964a:	75 40                	jne    800420968c <env_destroy+0xed>
		curenv = NULL;
  800420964c:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  8004209653:	00 00 00 
  8004209656:	ff d0                	callq  *%rax
  8004209658:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420965f:	00 00 00 
  8004209662:	48 98                	cltq   
  8004209664:	48 c1 e0 03          	shl    $0x3,%rax
  8004209668:	48 89 c1             	mov    %rax,%rcx
  800420966b:	48 c1 e1 04          	shl    $0x4,%rcx
  800420966f:	48 01 c8             	add    %rcx,%rax
  8004209672:	48 01 d0             	add    %rdx,%rax
  8004209675:	48 83 c0 08          	add    $0x8,%rax
  8004209679:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		sched_yield();
  8004209680:	48 b8 16 da 20 04 80 	movabs $0x800420da16,%rax
  8004209687:	00 00 00 
  800420968a:	ff d0                	callq  *%rax
	}

}
  800420968c:	c9                   	leaveq 
  800420968d:	c3                   	retq   

000000800420968e <env_pop_tf>:
//
// This function does not return.
//
void
env_pop_tf(struct Trapframe *tf)
{
  800420968e:	55                   	push   %rbp
  800420968f:	48 89 e5             	mov    %rsp,%rbp
  8004209692:	53                   	push   %rbx
  8004209693:	48 83 ec 18          	sub    $0x18,%rsp
  8004209697:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	// Record the CPU we are running on for user-space debugging
	curenv->env_cpunum = cpunum();
  800420969b:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  80042096a2:	00 00 00 
  80042096a5:	ff d0                	callq  *%rax
  80042096a7:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  80042096ae:	00 00 00 
  80042096b1:	48 98                	cltq   
  80042096b3:	48 c1 e0 03          	shl    $0x3,%rax
  80042096b7:	48 89 c1             	mov    %rax,%rcx
  80042096ba:	48 c1 e1 04          	shl    $0x4,%rcx
  80042096be:	48 01 c8             	add    %rcx,%rax
  80042096c1:	48 01 d0             	add    %rdx,%rax
  80042096c4:	48 83 c0 08          	add    $0x8,%rax
  80042096c8:	48 8b 18             	mov    (%rax),%rbx
  80042096cb:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  80042096d2:	00 00 00 
  80042096d5:	ff d0                	callq  *%rax
  80042096d7:	89 83 dc 00 00 00    	mov    %eax,0xdc(%rbx)

	__asm __volatile("movq %0,%%rsp\n"
  80042096dd:	48 8b 65 e8          	mov    -0x18(%rbp),%rsp
  80042096e1:	4c 8b 3c 24          	mov    (%rsp),%r15
  80042096e5:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  80042096ea:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  80042096ef:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  80042096f4:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  80042096f9:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  80042096fe:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  8004209703:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  8004209708:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  800420970d:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  8004209712:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  8004209717:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  800420971c:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  8004209721:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  8004209726:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800420972b:	48 83 c4 78          	add    $0x78,%rsp
  800420972f:	8e 04 24             	mov    (%rsp),%es
  8004209732:	8e 5c 24 08          	mov    0x8(%rsp),%ds
  8004209736:	48 83 c4 10          	add    $0x10,%rsp
  800420973a:	48 83 c4 10          	add    $0x10,%rsp
  800420973e:	48 cf                	iretq  
			 "movw 8(%%rsp),%%ds\n"
			 "addq $16,%%rsp\n"
			 "\taddq $16,%%rsp\n" /* skip tf_trapno and tf_errcode */
			 "\tiretq"
			 : : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
  8004209740:	48 ba 80 02 22 04 80 	movabs $0x8004220280,%rdx
  8004209747:	00 00 00 
  800420974a:	be b8 02 00 00       	mov    $0x2b8,%esi
  800420974f:	48 bf 8c 01 22 04 80 	movabs $0x800422018c,%rdi
  8004209756:	00 00 00 
  8004209759:	b8 00 00 00 00       	mov    $0x0,%eax
  800420975e:	48 b9 f3 04 20 04 80 	movabs $0x80042004f3,%rcx
  8004209765:	00 00 00 
  8004209768:	ff d1                	callq  *%rcx

000000800420976a <env_run>:
//
// This function does not return.
//
void
env_run(struct Env *e)
{
  800420976a:	55                   	push   %rbp
  800420976b:	48 89 e5             	mov    %rsp,%rbp
  800420976e:	48 83 ec 20          	sub    $0x20,%rsp
  8004209772:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	// Is this a context switch or just a return?
	if (curenv != e) {
  8004209776:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420977d:	00 00 00 
  8004209780:	ff d0                	callq  *%rax
  8004209782:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  8004209789:	00 00 00 
  800420978c:	48 98                	cltq   
  800420978e:	48 c1 e0 03          	shl    $0x3,%rax
  8004209792:	48 89 c1             	mov    %rax,%rcx
  8004209795:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209799:	48 01 c8             	add    %rcx,%rax
  800420979c:	48 01 d0             	add    %rdx,%rax
  800420979f:	48 83 c0 08          	add    $0x8,%rax
  80042097a3:	48 8b 00             	mov    (%rax),%rax
  80042097a6:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042097aa:	0f 84 28 01 00 00    	je     80042098d8 <env_run+0x16e>
		if (curenv && curenv->env_status == ENV_RUNNING)
  80042097b0:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  80042097b7:	00 00 00 
  80042097ba:	ff d0                	callq  *%rax
  80042097bc:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  80042097c3:	00 00 00 
  80042097c6:	48 98                	cltq   
  80042097c8:	48 c1 e0 03          	shl    $0x3,%rax
  80042097cc:	48 89 c1             	mov    %rax,%rcx
  80042097cf:	48 c1 e1 04          	shl    $0x4,%rcx
  80042097d3:	48 01 c8             	add    %rcx,%rax
  80042097d6:	48 01 d0             	add    %rdx,%rax
  80042097d9:	48 83 c0 08          	add    $0x8,%rax
  80042097dd:	48 8b 00             	mov    (%rax),%rax
  80042097e0:	48 85 c0             	test   %rax,%rax
  80042097e3:	74 75                	je     800420985a <env_run+0xf0>
  80042097e5:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  80042097ec:	00 00 00 
  80042097ef:	ff d0                	callq  *%rax
  80042097f1:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  80042097f8:	00 00 00 
  80042097fb:	48 98                	cltq   
  80042097fd:	48 c1 e0 03          	shl    $0x3,%rax
  8004209801:	48 89 c1             	mov    %rax,%rcx
  8004209804:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209808:	48 01 c8             	add    %rcx,%rax
  800420980b:	48 01 d0             	add    %rdx,%rax
  800420980e:	48 83 c0 08          	add    $0x8,%rax
  8004209812:	48 8b 00             	mov    (%rax),%rax
  8004209815:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420981b:	83 f8 03             	cmp    $0x3,%eax
  800420981e:	75 3a                	jne    800420985a <env_run+0xf0>
			curenv->env_status = ENV_RUNNABLE;
  8004209820:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  8004209827:	00 00 00 
  800420982a:	ff d0                	callq  *%rax
  800420982c:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  8004209833:	00 00 00 
  8004209836:	48 98                	cltq   
  8004209838:	48 c1 e0 03          	shl    $0x3,%rax
  800420983c:	48 89 c1             	mov    %rax,%rcx
  800420983f:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209843:	48 01 c8             	add    %rcx,%rax
  8004209846:	48 01 d0             	add    %rdx,%rax
  8004209849:	48 83 c0 08          	add    $0x8,%rax
  800420984d:	48 8b 00             	mov    (%rax),%rax
  8004209850:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004209857:	00 00 00 
		//cprintf("cpu %d switch from env %d to env %d\n",
		//	cpunum(), curenv ? curenv - envs : -1, e - envs);

		// keep track of which environment we're currently
		// running
		curenv = e;
  800420985a:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  8004209861:	00 00 00 
  8004209864:	ff d0                	callq  *%rax
  8004209866:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420986d:	00 00 00 
  8004209870:	48 98                	cltq   
  8004209872:	48 c1 e0 03          	shl    $0x3,%rax
  8004209876:	48 89 c1             	mov    %rax,%rcx
  8004209879:	48 c1 e1 04          	shl    $0x4,%rcx
  800420987d:	48 01 c8             	add    %rcx,%rax
  8004209880:	48 01 d0             	add    %rdx,%rax
  8004209883:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004209887:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420988b:	48 89 02             	mov    %rax,(%rdx)
		e->env_status = ENV_RUNNING;
  800420988e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209892:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  8004209899:	00 00 00 
		e->env_runs++;
  800420989c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042098a0:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  80042098a6:	8d 50 01             	lea    0x1(%rax),%edx
  80042098a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042098ad:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)

		// restore e's address space

		if(e->env_type != ENV_TYPE_GUEST)
  80042098b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042098b7:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80042098bd:	83 f8 03             	cmp    $0x3,%eax
  80042098c0:	74 16                	je     80042098d8 <env_run+0x16e>
			lcr3(e->env_cr3);
  80042098c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042098c6:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042098cd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042098d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042098d5:	0f 22 d8             	mov    %rax,%cr3

	}

	assert(e->env_status == ENV_RUNNING);
  80042098d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042098dc:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042098e2:	83 f8 03             	cmp    $0x3,%eax
  80042098e5:	74 35                	je     800420991c <env_run+0x1b2>
  80042098e7:	48 b9 8c 02 22 04 80 	movabs $0x800422028c,%rcx
  80042098ee:	00 00 00 
  80042098f1:	48 ba a9 02 22 04 80 	movabs $0x80042202a9,%rdx
  80042098f8:	00 00 00 
  80042098fb:	be da 02 00 00       	mov    $0x2da,%esi
  8004209900:	48 bf 8c 01 22 04 80 	movabs $0x800422018c,%rdi
  8004209907:	00 00 00 
  800420990a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420990f:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004209916:	00 00 00 
  8004209919:	41 ff d0             	callq  *%r8
    
	if(e->env_type == ENV_TYPE_GUEST) {
  800420991c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209920:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  8004209926:	83 f8 03             	cmp    $0x3,%eax
  8004209929:	75 3d                	jne    8004209968 <env_run+0x1fe>
		vmx_vmrun(e);
  800420992b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420992f:	48 89 c7             	mov    %rax,%rdi
  8004209932:	48 b8 5d dc 21 04 80 	movabs $0x800421dc5d,%rax
  8004209939:	00 00 00 
  800420993c:	ff d0                	callq  *%rax
		panic ("vmx_run never returns\n");
  800420993e:	48 ba be 02 22 04 80 	movabs $0x80042202be,%rdx
  8004209945:	00 00 00 
  8004209948:	be de 02 00 00       	mov    $0x2de,%esi
  800420994d:	48 bf 8c 01 22 04 80 	movabs $0x800422018c,%rdi
  8004209954:	00 00 00 
  8004209957:	b8 00 00 00 00       	mov    $0x0,%eax
  800420995c:	48 b9 f3 04 20 04 80 	movabs $0x80042004f3,%rcx
  8004209963:	00 00 00 
  8004209966:	ff d1                	callq  *%rcx
	}
	else {
		unlock_kernel();
  8004209968:	48 b8 5f 7e 20 04 80 	movabs $0x8004207e5f,%rax
  800420996f:	00 00 00 
  8004209972:	ff d0                	callq  *%rax
		env_pop_tf(&e->env_tf);
  8004209974:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209978:	48 89 c7             	mov    %rax,%rdi
  800420997b:	48 b8 8e 96 20 04 80 	movabs $0x800420968e,%rax
  8004209982:	00 00 00 
  8004209985:	ff d0                	callq  *%rax

0000008004209987 <mc146818_read>:
#include <kern/kclock.h>


unsigned
mc146818_read(unsigned reg)
{
  8004209987:	55                   	push   %rbp
  8004209988:	48 89 e5             	mov    %rsp,%rbp
  800420998b:	48 83 ec 18          	sub    $0x18,%rsp
  800420998f:	89 7d ec             	mov    %edi,-0x14(%rbp)
	outb(IO_RTC, reg);
  8004209992:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209995:	0f b6 c0             	movzbl %al,%eax
  8004209998:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  800420999f:	88 45 f6             	mov    %al,-0xa(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042099a2:	0f b6 45 f6          	movzbl -0xa(%rbp),%eax
  80042099a6:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042099a9:	ee                   	out    %al,(%dx)
  80042099aa:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042099b1:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042099b4:	89 c2                	mov    %eax,%edx
  80042099b6:	ec                   	in     (%dx),%al
  80042099b7:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  80042099ba:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
	return inb(IO_RTC+1);
  80042099be:	0f b6 c0             	movzbl %al,%eax
}
  80042099c1:	c9                   	leaveq 
  80042099c2:	c3                   	retq   

00000080042099c3 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
  80042099c3:	55                   	push   %rbp
  80042099c4:	48 89 e5             	mov    %rsp,%rbp
  80042099c7:	48 83 ec 18          	sub    $0x18,%rsp
  80042099cb:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042099ce:	89 75 e8             	mov    %esi,-0x18(%rbp)
	outb(IO_RTC, reg);
  80042099d1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042099d4:	0f b6 c0             	movzbl %al,%eax
  80042099d7:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  80042099de:	88 45 f6             	mov    %al,-0xa(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042099e1:	0f b6 45 f6          	movzbl -0xa(%rbp),%eax
  80042099e5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042099e8:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
  80042099e9:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042099ec:	0f b6 c0             	movzbl %al,%eax
  80042099ef:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%rbp)
  80042099f6:	88 45 f7             	mov    %al,-0x9(%rbp)
  80042099f9:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  80042099fd:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004209a00:	ee                   	out    %al,(%dx)
}
  8004209a01:	90                   	nop
  8004209a02:	c9                   	leaveq 
  8004209a03:	c3                   	retq   

0000008004209a04 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
  8004209a04:	55                   	push   %rbp
  8004209a05:	48 89 e5             	mov    %rsp,%rbp
  8004209a08:	48 83 ec 50          	sub    $0x50,%rsp
	didinit = 1;
  8004209a0c:	48 b8 68 d2 4d 04 80 	movabs $0x80044dd268,%rax
  8004209a13:	00 00 00 
  8004209a16:	c6 00 01             	movb   $0x1,(%rax)
  8004209a19:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%rbp)
  8004209a20:	c6 45 ba ff          	movb   $0xff,-0x46(%rbp)
  8004209a24:	0f b6 45 ba          	movzbl -0x46(%rbp),%eax
  8004209a28:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209a2b:	ee                   	out    %al,(%dx)
  8004209a2c:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%rbp)
  8004209a33:	c6 45 bb ff          	movb   $0xff,-0x45(%rbp)
  8004209a37:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004209a3b:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004209a3e:	ee                   	out    %al,(%dx)
  8004209a3f:	c7 45 f4 20 00 00 00 	movl   $0x20,-0xc(%rbp)
  8004209a46:	c6 45 bc 11          	movb   $0x11,-0x44(%rbp)
  8004209a4a:	0f b6 45 bc          	movzbl -0x44(%rbp),%eax
  8004209a4e:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004209a51:	ee                   	out    %al,(%dx)
  8004209a52:	c7 45 f0 21 00 00 00 	movl   $0x21,-0x10(%rbp)
  8004209a59:	c6 45 bd 20          	movb   $0x20,-0x43(%rbp)
  8004209a5d:	0f b6 45 bd          	movzbl -0x43(%rbp),%eax
  8004209a61:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004209a64:	ee                   	out    %al,(%dx)
  8004209a65:	c7 45 ec 21 00 00 00 	movl   $0x21,-0x14(%rbp)
  8004209a6c:	c6 45 be 04          	movb   $0x4,-0x42(%rbp)
  8004209a70:	0f b6 45 be          	movzbl -0x42(%rbp),%eax
  8004209a74:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004209a77:	ee                   	out    %al,(%dx)
  8004209a78:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%rbp)
  8004209a7f:	c6 45 bf 03          	movb   $0x3,-0x41(%rbp)
  8004209a83:	0f b6 45 bf          	movzbl -0x41(%rbp),%eax
  8004209a87:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004209a8a:	ee                   	out    %al,(%dx)
  8004209a8b:	c7 45 e4 a0 00 00 00 	movl   $0xa0,-0x1c(%rbp)
  8004209a92:	c6 45 c0 11          	movb   $0x11,-0x40(%rbp)
  8004209a96:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
  8004209a9a:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004209a9d:	ee                   	out    %al,(%dx)
  8004209a9e:	c7 45 e0 a1 00 00 00 	movl   $0xa1,-0x20(%rbp)
  8004209aa5:	c6 45 c1 28          	movb   $0x28,-0x3f(%rbp)
  8004209aa9:	0f b6 45 c1          	movzbl -0x3f(%rbp),%eax
  8004209aad:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004209ab0:	ee                   	out    %al,(%dx)
  8004209ab1:	c7 45 dc a1 00 00 00 	movl   $0xa1,-0x24(%rbp)
  8004209ab8:	c6 45 c2 02          	movb   $0x2,-0x3e(%rbp)
  8004209abc:	0f b6 45 c2          	movzbl -0x3e(%rbp),%eax
  8004209ac0:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004209ac3:	ee                   	out    %al,(%dx)
  8004209ac4:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%rbp)
  8004209acb:	c6 45 c3 01          	movb   $0x1,-0x3d(%rbp)
  8004209acf:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  8004209ad3:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8004209ad6:	ee                   	out    %al,(%dx)
  8004209ad7:	c7 45 d4 20 00 00 00 	movl   $0x20,-0x2c(%rbp)
  8004209ade:	c6 45 c4 68          	movb   $0x68,-0x3c(%rbp)
  8004209ae2:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  8004209ae6:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004209ae9:	ee                   	out    %al,(%dx)
  8004209aea:	c7 45 d0 20 00 00 00 	movl   $0x20,-0x30(%rbp)
  8004209af1:	c6 45 c5 0a          	movb   $0xa,-0x3b(%rbp)
  8004209af5:	0f b6 45 c5          	movzbl -0x3b(%rbp),%eax
  8004209af9:	8b 55 d0             	mov    -0x30(%rbp),%edx
  8004209afc:	ee                   	out    %al,(%dx)
  8004209afd:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%rbp)
  8004209b04:	c6 45 c6 68          	movb   $0x68,-0x3a(%rbp)
  8004209b08:	0f b6 45 c6          	movzbl -0x3a(%rbp),%eax
  8004209b0c:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004209b0f:	ee                   	out    %al,(%dx)
  8004209b10:	c7 45 c8 a0 00 00 00 	movl   $0xa0,-0x38(%rbp)
  8004209b17:	c6 45 c7 0a          	movb   $0xa,-0x39(%rbp)
  8004209b1b:	0f b6 45 c7          	movzbl -0x39(%rbp),%eax
  8004209b1f:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004209b22:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);               /* OCW3 */
	outb(IO_PIC2, 0x0a);               /* OCW3 */

	if (irq_mask_8259A != 0xFFFF)
  8004209b23:	48 b8 72 36 23 04 80 	movabs $0x8004233672,%rax
  8004209b2a:	00 00 00 
  8004209b2d:	0f b7 00             	movzwl (%rax),%eax
  8004209b30:	66 83 f8 ff          	cmp    $0xffff,%ax
  8004209b34:	74 1e                	je     8004209b54 <pic_init+0x150>
		irq_setmask_8259A(irq_mask_8259A);
  8004209b36:	48 b8 72 36 23 04 80 	movabs $0x8004233672,%rax
  8004209b3d:	00 00 00 
  8004209b40:	0f b7 00             	movzwl (%rax),%eax
  8004209b43:	0f b7 c0             	movzwl %ax,%eax
  8004209b46:	89 c7                	mov    %eax,%edi
  8004209b48:	48 b8 57 9b 20 04 80 	movabs $0x8004209b57,%rax
  8004209b4f:	00 00 00 
  8004209b52:	ff d0                	callq  *%rax
}
  8004209b54:	90                   	nop
  8004209b55:	c9                   	leaveq 
  8004209b56:	c3                   	retq   

0000008004209b57 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16_t mask)
{
  8004209b57:	55                   	push   %rbp
  8004209b58:	48 89 e5             	mov    %rsp,%rbp
  8004209b5b:	48 83 ec 20          	sub    $0x20,%rsp
  8004209b5f:	89 f8                	mov    %edi,%eax
  8004209b61:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
	int i;
	irq_mask_8259A = mask;
  8004209b65:	48 b8 72 36 23 04 80 	movabs $0x8004233672,%rax
  8004209b6c:	00 00 00 
  8004209b6f:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  8004209b73:	66 89 10             	mov    %dx,(%rax)
	if (!didinit)
  8004209b76:	48 b8 68 d2 4d 04 80 	movabs $0x80044dd268,%rax
  8004209b7d:	00 00 00 
  8004209b80:	0f b6 00             	movzbl (%rax),%eax
  8004209b83:	83 f0 01             	xor    $0x1,%eax
  8004209b86:	84 c0                	test   %al,%al
  8004209b88:	0f 85 b9 00 00 00    	jne    8004209c47 <irq_setmask_8259A+0xf0>
		return;
	outb(IO_PIC1+1, (char)mask);
  8004209b8e:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  8004209b92:	0f b6 c0             	movzbl %al,%eax
  8004209b95:	c7 45 f8 21 00 00 00 	movl   $0x21,-0x8(%rbp)
  8004209b9c:	88 45 f2             	mov    %al,-0xe(%rbp)
  8004209b9f:	0f b6 45 f2          	movzbl -0xe(%rbp),%eax
  8004209ba3:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004209ba6:	ee                   	out    %al,(%dx)
	outb(IO_PIC2+1, (char)(mask >> 8));
  8004209ba7:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  8004209bab:	66 c1 e8 08          	shr    $0x8,%ax
  8004209baf:	0f b6 c0             	movzbl %al,%eax
  8004209bb2:	c7 45 f4 a1 00 00 00 	movl   $0xa1,-0xc(%rbp)
  8004209bb9:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004209bbc:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004209bc0:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004209bc3:	ee                   	out    %al,(%dx)
	cprintf("enabled interrupts:");
  8004209bc4:	48 bf d5 02 22 04 80 	movabs $0x80042202d5,%rdi
  8004209bcb:	00 00 00 
  8004209bce:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209bd3:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004209bda:	00 00 00 
  8004209bdd:	ff d2                	callq  *%rdx
	for (i = 0; i < 16; i++)
  8004209bdf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004209be6:	eb 3c                	jmp    8004209c24 <irq_setmask_8259A+0xcd>
		if (~mask & (1<<i))
  8004209be8:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  8004209bec:	f7 d0                	not    %eax
  8004209bee:	89 c2                	mov    %eax,%edx
  8004209bf0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209bf3:	89 c1                	mov    %eax,%ecx
  8004209bf5:	d3 fa                	sar    %cl,%edx
  8004209bf7:	89 d0                	mov    %edx,%eax
  8004209bf9:	83 e0 01             	and    $0x1,%eax
  8004209bfc:	85 c0                	test   %eax,%eax
  8004209bfe:	74 20                	je     8004209c20 <irq_setmask_8259A+0xc9>
			cprintf(" %d", i);
  8004209c00:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209c03:	89 c6                	mov    %eax,%esi
  8004209c05:	48 bf e9 02 22 04 80 	movabs $0x80042202e9,%rdi
  8004209c0c:	00 00 00 
  8004209c0f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209c14:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004209c1b:	00 00 00 
  8004209c1e:	ff d2                	callq  *%rdx
	if (!didinit)
		return;
	outb(IO_PIC1+1, (char)mask);
	outb(IO_PIC2+1, (char)(mask >> 8));
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
  8004209c20:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004209c24:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  8004209c28:	7e be                	jle    8004209be8 <irq_setmask_8259A+0x91>
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
  8004209c2a:	48 bf ed 02 22 04 80 	movabs $0x80042202ed,%rdi
  8004209c31:	00 00 00 
  8004209c34:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209c39:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004209c40:	00 00 00 
  8004209c43:	ff d2                	callq  *%rdx
  8004209c45:	eb 01                	jmp    8004209c48 <irq_setmask_8259A+0xf1>
irq_setmask_8259A(uint16_t mask)
{
	int i;
	irq_mask_8259A = mask;
	if (!didinit)
		return;
  8004209c47:	90                   	nop
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
}
  8004209c48:	c9                   	leaveq 
  8004209c49:	c3                   	retq   

0000008004209c4a <irq_eoi>:


void
irq_eoi(void)
{
  8004209c4a:	55                   	push   %rbp
  8004209c4b:	48 89 e5             	mov    %rsp,%rbp
  8004209c4e:	48 83 ec 10          	sub    $0x10,%rsp
  8004209c52:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%rbp)
  8004209c59:	c6 45 f6 20          	movb   $0x20,-0xa(%rbp)
  8004209c5d:	0f b6 45 f6          	movzbl -0xa(%rbp),%eax
  8004209c61:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209c64:	ee                   	out    %al,(%dx)
  8004209c65:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%rbp)
  8004209c6c:	c6 45 f7 20          	movb   $0x20,-0x9(%rbp)
  8004209c70:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004209c74:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004209c77:	ee                   	out    %al,(%dx)
	//   s: specific
	//   e: end-of-interrupt
	// xxx: specific interrupt line
	outb(IO_PIC1, 0x20);
	outb(IO_PIC2, 0x20);
}
  8004209c78:	90                   	nop
  8004209c79:	c9                   	leaveq 
  8004209c7a:	c3                   	retq   

0000008004209c7b <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
  8004209c7b:	55                   	push   %rbp
  8004209c7c:	48 89 e5             	mov    %rsp,%rbp
  8004209c7f:	48 83 ec 10          	sub    $0x10,%rsp
  8004209c83:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004209c86:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	cputchar(ch);
  8004209c8a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209c8d:	89 c7                	mov    %eax,%edi
  8004209c8f:	48 b8 5b 12 20 04 80 	movabs $0x800420125b,%rax
  8004209c96:	00 00 00 
  8004209c99:	ff d0                	callq  *%rax
	*cnt++;
  8004209c9b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004209c9f:	48 83 c0 04          	add    $0x4,%rax
  8004209ca3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  8004209ca7:	90                   	nop
  8004209ca8:	c9                   	leaveq 
  8004209ca9:	c3                   	retq   

0000008004209caa <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  8004209caa:	55                   	push   %rbp
  8004209cab:	48 89 e5             	mov    %rsp,%rbp
  8004209cae:	48 83 ec 30          	sub    $0x30,%rsp
  8004209cb2:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004209cb6:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int cnt = 0;
  8004209cba:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004209cc1:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004209cc5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004209cc9:	48 8b 0a             	mov    (%rdx),%rcx
  8004209ccc:	48 89 08             	mov    %rcx,(%rax)
  8004209ccf:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004209cd3:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004209cd7:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004209cdb:	48 89 50 10          	mov    %rdx,0x10(%rax)
	vprintfmt((void*)putch, &cnt, fmt, aq);
  8004209cdf:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  8004209ce3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004209ce7:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8004209ceb:	48 89 c6             	mov    %rax,%rsi
  8004209cee:	48 bf 7b 9c 20 04 80 	movabs $0x8004209c7b,%rdi
  8004209cf5:	00 00 00 
  8004209cf8:	48 b8 a6 03 21 04 80 	movabs $0x80042103a6,%rax
  8004209cff:	00 00 00 
  8004209d02:	ff d0                	callq  *%rax
	va_end(aq);
	return cnt;
  8004209d04:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  8004209d07:	c9                   	leaveq 
  8004209d08:	c3                   	retq   

0000008004209d09 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  8004209d09:	55                   	push   %rbp
  8004209d0a:	48 89 e5             	mov    %rsp,%rbp
  8004209d0d:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  8004209d14:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  8004209d1b:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  8004209d22:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  8004209d29:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004209d30:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004209d37:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004209d3e:	84 c0                	test   %al,%al
  8004209d40:	74 20                	je     8004209d62 <cprintf+0x59>
  8004209d42:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004209d46:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004209d4a:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004209d4e:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004209d52:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004209d56:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004209d5a:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004209d5e:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;
	int cnt;
	va_start(ap, fmt);
  8004209d62:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  8004209d69:	00 00 00 
  8004209d6c:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  8004209d73:	00 00 00 
  8004209d76:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004209d7a:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004209d81:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004209d88:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004209d8f:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  8004209d96:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8004209d9d:	48 8b 0a             	mov    (%rdx),%rcx
  8004209da0:	48 89 08             	mov    %rcx,(%rax)
  8004209da3:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004209da7:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004209dab:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004209daf:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  8004209db3:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  8004209dba:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004209dc1:	48 89 d6             	mov    %rdx,%rsi
  8004209dc4:	48 89 c7             	mov    %rax,%rdi
  8004209dc7:	48 b8 aa 9c 20 04 80 	movabs $0x8004209caa,%rax
  8004209dce:	00 00 00 
  8004209dd1:	ff d0                	callq  *%rax
  8004209dd3:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  8004209dd9:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8004209ddf:	c9                   	leaveq 
  8004209de0:	c3                   	retq   

0000008004209de1 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004209de1:	55                   	push   %rbp
  8004209de2:	48 89 e5             	mov    %rsp,%rbp
  8004209de5:	48 83 ec 20          	sub    $0x20,%rsp
  8004209de9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004209ded:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004209df0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004209df4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004209df7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004209dfb:	f0 87 02             	lock xchg %eax,(%rdx)
  8004209dfe:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004209e01:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004209e04:	c9                   	leaveq 
  8004209e05:	c3                   	retq   

0000008004209e06 <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  8004209e06:	55                   	push   %rbp
  8004209e07:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004209e0a:	48 bf 60 37 23 04 80 	movabs $0x8004233760,%rdi
  8004209e11:	00 00 00 
  8004209e14:	48 b8 5e 82 21 04 80 	movabs $0x800421825e,%rax
  8004209e1b:	00 00 00 
  8004209e1e:	ff d0                	callq  *%rax
}
  8004209e20:	90                   	nop
  8004209e21:	5d                   	pop    %rbp
  8004209e22:	c3                   	retq   

0000008004209e23 <trapname>:
struct Gatedesc idt[256] = { { 0 } };
struct Pseudodesc idt_pd = {0,0};


static const char *trapname(int trapno)
{
  8004209e23:	55                   	push   %rbp
  8004209e24:	48 89 e5             	mov    %rsp,%rbp
  8004209e27:	48 83 ec 08          	sub    $0x8,%rsp
  8004209e2b:	89 7d fc             	mov    %edi,-0x4(%rbp)
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
  8004209e2e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209e31:	83 f8 13             	cmp    $0x13,%eax
  8004209e34:	77 16                	ja     8004209e4c <trapname+0x29>
		return excnames[trapno];
  8004209e36:	48 b8 00 07 22 04 80 	movabs $0x8004220700,%rax
  8004209e3d:	00 00 00 
  8004209e40:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209e43:	48 63 d2             	movslq %edx,%rdx
  8004209e46:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004209e4a:	eb 34                	jmp    8004209e80 <trapname+0x5d>
	if (trapno == T_SYSCALL)
  8004209e4c:	83 7d fc 30          	cmpl   $0x30,-0x4(%rbp)
  8004209e50:	75 0c                	jne    8004209e5e <trapname+0x3b>
		return "System call";
  8004209e52:	48 b8 00 03 22 04 80 	movabs $0x8004220300,%rax
  8004209e59:	00 00 00 
  8004209e5c:	eb 22                	jmp    8004209e80 <trapname+0x5d>

	if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
  8004209e5e:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  8004209e62:	7e 12                	jle    8004209e76 <trapname+0x53>
  8004209e64:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  8004209e68:	7f 0c                	jg     8004209e76 <trapname+0x53>
		return "Hardware Interrupt";
  8004209e6a:	48 b8 0c 03 22 04 80 	movabs $0x800422030c,%rax
  8004209e71:	00 00 00 
  8004209e74:	eb 0a                	jmp    8004209e80 <trapname+0x5d>

	return "(unknown trap)";
  8004209e76:	48 b8 1f 03 22 04 80 	movabs $0x800422031f,%rax
  8004209e7d:	00 00 00 
}
  8004209e80:	c9                   	leaveq 
  8004209e81:	c3                   	retq   

0000008004209e82 <trap_init>:


void
trap_init(void)
{
  8004209e82:	55                   	push   %rbp
  8004209e83:	48 89 e5             	mov    %rsp,%rbp
  8004209e86:	48 83 ec 10          	sub    $0x10,%rsp
	// check that IRQ_OFFSET is a multiple of 8
	static_assert((IRQ_OFFSET & 7) == 0);


	// install a default handler
	for (i = 0; i < sizeof(idt)/sizeof(idt[0]); i++)
  8004209e8a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004209e91:	e9 8f 01 00 00       	jmpq   800420a025 <trap_init+0x1a3>
		SETGATE(idt[i], 0, GD_KT, &Xdefault, 0);
  8004209e96:	48 b8 56 d9 20 04 80 	movabs $0x800420d956,%rax
  8004209e9d:	00 00 00 
  8004209ea0:	89 c1                	mov    %eax,%ecx
  8004209ea2:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  8004209ea9:	00 00 00 
  8004209eac:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209eaf:	48 63 d2             	movslq %edx,%rdx
  8004209eb2:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209eb6:	48 01 d0             	add    %rdx,%rax
  8004209eb9:	66 89 08             	mov    %cx,(%rax)
  8004209ebc:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  8004209ec3:	00 00 00 
  8004209ec6:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209ec9:	48 63 d2             	movslq %edx,%rdx
  8004209ecc:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209ed0:	48 01 d0             	add    %rdx,%rax
  8004209ed3:	48 83 c0 02          	add    $0x2,%rax
  8004209ed7:	66 c7 00 08 00       	movw   $0x8,(%rax)
  8004209edc:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  8004209ee3:	00 00 00 
  8004209ee6:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209ee9:	48 63 d2             	movslq %edx,%rdx
  8004209eec:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209ef0:	48 01 d0             	add    %rdx,%rax
  8004209ef3:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004209ef7:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209efa:	88 50 04             	mov    %dl,0x4(%rax)
  8004209efd:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  8004209f04:	00 00 00 
  8004209f07:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209f0a:	48 63 d2             	movslq %edx,%rdx
  8004209f0d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209f11:	48 01 d0             	add    %rdx,%rax
  8004209f14:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004209f18:	83 e2 07             	and    $0x7,%edx
  8004209f1b:	88 50 04             	mov    %dl,0x4(%rax)
  8004209f1e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  8004209f25:	00 00 00 
  8004209f28:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209f2b:	48 63 d2             	movslq %edx,%rdx
  8004209f2e:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209f32:	48 01 d0             	add    %rdx,%rax
  8004209f35:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209f39:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209f3c:	83 ca 0e             	or     $0xe,%edx
  8004209f3f:	88 50 05             	mov    %dl,0x5(%rax)
  8004209f42:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  8004209f49:	00 00 00 
  8004209f4c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209f4f:	48 63 d2             	movslq %edx,%rdx
  8004209f52:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209f56:	48 01 d0             	add    %rdx,%rax
  8004209f59:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209f5d:	83 e2 ef             	and    $0xffffffef,%edx
  8004209f60:	88 50 05             	mov    %dl,0x5(%rax)
  8004209f63:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  8004209f6a:	00 00 00 
  8004209f6d:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209f70:	48 63 d2             	movslq %edx,%rdx
  8004209f73:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209f77:	48 01 d0             	add    %rdx,%rax
  8004209f7a:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209f7e:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209f81:	88 50 05             	mov    %dl,0x5(%rax)
  8004209f84:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  8004209f8b:	00 00 00 
  8004209f8e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209f91:	48 63 d2             	movslq %edx,%rdx
  8004209f94:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209f98:	48 01 d0             	add    %rdx,%rax
  8004209f9b:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209f9f:	83 ca 80             	or     $0xffffff80,%edx
  8004209fa2:	88 50 05             	mov    %dl,0x5(%rax)
  8004209fa5:	48 b8 56 d9 20 04 80 	movabs $0x800420d956,%rax
  8004209fac:	00 00 00 
  8004209faf:	48 c1 e8 10          	shr    $0x10,%rax
  8004209fb3:	89 c1                	mov    %eax,%ecx
  8004209fb5:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  8004209fbc:	00 00 00 
  8004209fbf:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209fc2:	48 63 d2             	movslq %edx,%rdx
  8004209fc5:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209fc9:	48 01 d0             	add    %rdx,%rax
  8004209fcc:	48 83 c0 06          	add    $0x6,%rax
  8004209fd0:	66 89 08             	mov    %cx,(%rax)
  8004209fd3:	48 b8 56 d9 20 04 80 	movabs $0x800420d956,%rax
  8004209fda:	00 00 00 
  8004209fdd:	48 c1 e8 20          	shr    $0x20,%rax
  8004209fe1:	89 c1                	mov    %eax,%ecx
  8004209fe3:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  8004209fea:	00 00 00 
  8004209fed:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209ff0:	48 63 d2             	movslq %edx,%rdx
  8004209ff3:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209ff7:	48 01 d0             	add    %rdx,%rax
  8004209ffa:	48 83 c0 08          	add    $0x8,%rax
  8004209ffe:	89 08                	mov    %ecx,(%rax)
  800420a000:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a007:	00 00 00 
  800420a00a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420a00d:	48 63 d2             	movslq %edx,%rdx
  800420a010:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a014:	48 01 d0             	add    %rdx,%rax
  800420a017:	48 83 c0 0c          	add    $0xc,%rax
  800420a01b:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	// check that IRQ_OFFSET is a multiple of 8
	static_assert((IRQ_OFFSET & 7) == 0);


	// install a default handler
	for (i = 0; i < sizeof(idt)/sizeof(idt[0]); i++)
  800420a021:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420a025:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420a028:	3d ff 00 00 00       	cmp    $0xff,%eax
  800420a02d:	0f 86 63 fe ff ff    	jbe    8004209e96 <trap_init+0x14>
		SETGATE(idt[i], 0, GD_KT, &Xdefault, 0);

	SETGATE(idt[T_DIVIDE], 0, GD_KT, &Xdivide, 0);
  800420a033:	48 b8 60 d8 20 04 80 	movabs $0x800420d860,%rax
  800420a03a:	00 00 00 
  800420a03d:	89 c2                	mov    %eax,%edx
  800420a03f:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a046:	00 00 00 
  800420a049:	66 89 10             	mov    %dx,(%rax)
  800420a04c:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a053:	00 00 00 
  800420a056:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  800420a05c:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a063:	00 00 00 
  800420a066:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  800420a06a:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a06d:	88 50 04             	mov    %dl,0x4(%rax)
  800420a070:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a077:	00 00 00 
  800420a07a:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  800420a07e:	83 e2 07             	and    $0x7,%edx
  800420a081:	88 50 04             	mov    %dl,0x4(%rax)
  800420a084:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a08b:	00 00 00 
  800420a08e:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420a092:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a095:	83 ca 0e             	or     $0xe,%edx
  800420a098:	88 50 05             	mov    %dl,0x5(%rax)
  800420a09b:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a0a2:	00 00 00 
  800420a0a5:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420a0a9:	83 e2 ef             	and    $0xffffffef,%edx
  800420a0ac:	88 50 05             	mov    %dl,0x5(%rax)
  800420a0af:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a0b6:	00 00 00 
  800420a0b9:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420a0bd:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a0c0:	88 50 05             	mov    %dl,0x5(%rax)
  800420a0c3:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a0ca:	00 00 00 
  800420a0cd:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420a0d1:	83 ca 80             	or     $0xffffff80,%edx
  800420a0d4:	88 50 05             	mov    %dl,0x5(%rax)
  800420a0d7:	48 b8 60 d8 20 04 80 	movabs $0x800420d860,%rax
  800420a0de:	00 00 00 
  800420a0e1:	48 c1 e8 10          	shr    $0x10,%rax
  800420a0e5:	89 c2                	mov    %eax,%edx
  800420a0e7:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a0ee:	00 00 00 
  800420a0f1:	66 89 50 06          	mov    %dx,0x6(%rax)
  800420a0f5:	48 b8 60 d8 20 04 80 	movabs $0x800420d860,%rax
  800420a0fc:	00 00 00 
  800420a0ff:	48 c1 e8 20          	shr    $0x20,%rax
  800420a103:	89 c2                	mov    %eax,%edx
  800420a105:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a10c:	00 00 00 
  800420a10f:	89 50 08             	mov    %edx,0x8(%rax)
  800420a112:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a119:	00 00 00 
  800420a11c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
	SETGATE(idt[T_DEBUG],  0, GD_KT, &Xdebug,  0);
  800420a123:	48 b8 6a d8 20 04 80 	movabs $0x800420d86a,%rax
  800420a12a:	00 00 00 
  800420a12d:	89 c2                	mov    %eax,%edx
  800420a12f:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a136:	00 00 00 
  800420a139:	66 89 50 10          	mov    %dx,0x10(%rax)
  800420a13d:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a144:	00 00 00 
  800420a147:	66 c7 40 12 08 00    	movw   $0x8,0x12(%rax)
  800420a14d:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a154:	00 00 00 
  800420a157:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  800420a15b:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a15e:	88 50 14             	mov    %dl,0x14(%rax)
  800420a161:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a168:	00 00 00 
  800420a16b:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  800420a16f:	83 e2 07             	and    $0x7,%edx
  800420a172:	88 50 14             	mov    %dl,0x14(%rax)
  800420a175:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a17c:	00 00 00 
  800420a17f:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  800420a183:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a186:	83 ca 0e             	or     $0xe,%edx
  800420a189:	88 50 15             	mov    %dl,0x15(%rax)
  800420a18c:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a193:	00 00 00 
  800420a196:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  800420a19a:	83 e2 ef             	and    $0xffffffef,%edx
  800420a19d:	88 50 15             	mov    %dl,0x15(%rax)
  800420a1a0:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a1a7:	00 00 00 
  800420a1aa:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  800420a1ae:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a1b1:	88 50 15             	mov    %dl,0x15(%rax)
  800420a1b4:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a1bb:	00 00 00 
  800420a1be:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  800420a1c2:	83 ca 80             	or     $0xffffff80,%edx
  800420a1c5:	88 50 15             	mov    %dl,0x15(%rax)
  800420a1c8:	48 b8 6a d8 20 04 80 	movabs $0x800420d86a,%rax
  800420a1cf:	00 00 00 
  800420a1d2:	48 c1 e8 10          	shr    $0x10,%rax
  800420a1d6:	89 c2                	mov    %eax,%edx
  800420a1d8:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a1df:	00 00 00 
  800420a1e2:	66 89 50 16          	mov    %dx,0x16(%rax)
  800420a1e6:	48 b8 6a d8 20 04 80 	movabs $0x800420d86a,%rax
  800420a1ed:	00 00 00 
  800420a1f0:	48 c1 e8 20          	shr    $0x20,%rax
  800420a1f4:	89 c2                	mov    %eax,%edx
  800420a1f6:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a1fd:	00 00 00 
  800420a200:	89 50 18             	mov    %edx,0x18(%rax)
  800420a203:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a20a:	00 00 00 
  800420a20d:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%rax)
	SETGATE(idt[T_NMI],    0, GD_KT, &Xnmi,    0);
  800420a214:	48 b8 74 d8 20 04 80 	movabs $0x800420d874,%rax
  800420a21b:	00 00 00 
  800420a21e:	89 c2                	mov    %eax,%edx
  800420a220:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a227:	00 00 00 
  800420a22a:	66 89 50 20          	mov    %dx,0x20(%rax)
  800420a22e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a235:	00 00 00 
  800420a238:	66 c7 40 22 08 00    	movw   $0x8,0x22(%rax)
  800420a23e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a245:	00 00 00 
  800420a248:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  800420a24c:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a24f:	88 50 24             	mov    %dl,0x24(%rax)
  800420a252:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a259:	00 00 00 
  800420a25c:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  800420a260:	83 e2 07             	and    $0x7,%edx
  800420a263:	88 50 24             	mov    %dl,0x24(%rax)
  800420a266:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a26d:	00 00 00 
  800420a270:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  800420a274:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a277:	83 ca 0e             	or     $0xe,%edx
  800420a27a:	88 50 25             	mov    %dl,0x25(%rax)
  800420a27d:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a284:	00 00 00 
  800420a287:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  800420a28b:	83 e2 ef             	and    $0xffffffef,%edx
  800420a28e:	88 50 25             	mov    %dl,0x25(%rax)
  800420a291:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a298:	00 00 00 
  800420a29b:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  800420a29f:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a2a2:	88 50 25             	mov    %dl,0x25(%rax)
  800420a2a5:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a2ac:	00 00 00 
  800420a2af:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  800420a2b3:	83 ca 80             	or     $0xffffff80,%edx
  800420a2b6:	88 50 25             	mov    %dl,0x25(%rax)
  800420a2b9:	48 b8 74 d8 20 04 80 	movabs $0x800420d874,%rax
  800420a2c0:	00 00 00 
  800420a2c3:	48 c1 e8 10          	shr    $0x10,%rax
  800420a2c7:	89 c2                	mov    %eax,%edx
  800420a2c9:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a2d0:	00 00 00 
  800420a2d3:	66 89 50 26          	mov    %dx,0x26(%rax)
  800420a2d7:	48 b8 74 d8 20 04 80 	movabs $0x800420d874,%rax
  800420a2de:	00 00 00 
  800420a2e1:	48 c1 e8 20          	shr    $0x20,%rax
  800420a2e5:	89 c2                	mov    %eax,%edx
  800420a2e7:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a2ee:	00 00 00 
  800420a2f1:	89 50 28             	mov    %edx,0x28(%rax)
  800420a2f4:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a2fb:	00 00 00 
  800420a2fe:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%rax)
	SETGATE(idt[T_BRKPT],  0, GD_KT, &Xbrkpt,  3);
  800420a305:	48 b8 7e d8 20 04 80 	movabs $0x800420d87e,%rax
  800420a30c:	00 00 00 
  800420a30f:	89 c2                	mov    %eax,%edx
  800420a311:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a318:	00 00 00 
  800420a31b:	66 89 50 30          	mov    %dx,0x30(%rax)
  800420a31f:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a326:	00 00 00 
  800420a329:	66 c7 40 32 08 00    	movw   $0x8,0x32(%rax)
  800420a32f:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a336:	00 00 00 
  800420a339:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  800420a33d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a340:	88 50 34             	mov    %dl,0x34(%rax)
  800420a343:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a34a:	00 00 00 
  800420a34d:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  800420a351:	83 e2 07             	and    $0x7,%edx
  800420a354:	88 50 34             	mov    %dl,0x34(%rax)
  800420a357:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a35e:	00 00 00 
  800420a361:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  800420a365:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a368:	83 ca 0e             	or     $0xe,%edx
  800420a36b:	88 50 35             	mov    %dl,0x35(%rax)
  800420a36e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a375:	00 00 00 
  800420a378:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  800420a37c:	83 e2 ef             	and    $0xffffffef,%edx
  800420a37f:	88 50 35             	mov    %dl,0x35(%rax)
  800420a382:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a389:	00 00 00 
  800420a38c:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  800420a390:	83 ca 60             	or     $0x60,%edx
  800420a393:	88 50 35             	mov    %dl,0x35(%rax)
  800420a396:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a39d:	00 00 00 
  800420a3a0:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  800420a3a4:	83 ca 80             	or     $0xffffff80,%edx
  800420a3a7:	88 50 35             	mov    %dl,0x35(%rax)
  800420a3aa:	48 b8 7e d8 20 04 80 	movabs $0x800420d87e,%rax
  800420a3b1:	00 00 00 
  800420a3b4:	48 c1 e8 10          	shr    $0x10,%rax
  800420a3b8:	89 c2                	mov    %eax,%edx
  800420a3ba:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a3c1:	00 00 00 
  800420a3c4:	66 89 50 36          	mov    %dx,0x36(%rax)
  800420a3c8:	48 b8 7e d8 20 04 80 	movabs $0x800420d87e,%rax
  800420a3cf:	00 00 00 
  800420a3d2:	48 c1 e8 20          	shr    $0x20,%rax
  800420a3d6:	89 c2                	mov    %eax,%edx
  800420a3d8:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a3df:	00 00 00 
  800420a3e2:	89 50 38             	mov    %edx,0x38(%rax)
  800420a3e5:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a3ec:	00 00 00 
  800420a3ef:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
	SETGATE(idt[T_OFLOW],  0, GD_KT, &Xoflow,  0);
  800420a3f6:	48 b8 88 d8 20 04 80 	movabs $0x800420d888,%rax
  800420a3fd:	00 00 00 
  800420a400:	89 c2                	mov    %eax,%edx
  800420a402:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a409:	00 00 00 
  800420a40c:	66 89 50 40          	mov    %dx,0x40(%rax)
  800420a410:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a417:	00 00 00 
  800420a41a:	66 c7 40 42 08 00    	movw   $0x8,0x42(%rax)
  800420a420:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a427:	00 00 00 
  800420a42a:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  800420a42e:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a431:	88 50 44             	mov    %dl,0x44(%rax)
  800420a434:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a43b:	00 00 00 
  800420a43e:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  800420a442:	83 e2 07             	and    $0x7,%edx
  800420a445:	88 50 44             	mov    %dl,0x44(%rax)
  800420a448:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a44f:	00 00 00 
  800420a452:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  800420a456:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a459:	83 ca 0e             	or     $0xe,%edx
  800420a45c:	88 50 45             	mov    %dl,0x45(%rax)
  800420a45f:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a466:	00 00 00 
  800420a469:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  800420a46d:	83 e2 ef             	and    $0xffffffef,%edx
  800420a470:	88 50 45             	mov    %dl,0x45(%rax)
  800420a473:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a47a:	00 00 00 
  800420a47d:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  800420a481:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a484:	88 50 45             	mov    %dl,0x45(%rax)
  800420a487:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a48e:	00 00 00 
  800420a491:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  800420a495:	83 ca 80             	or     $0xffffff80,%edx
  800420a498:	88 50 45             	mov    %dl,0x45(%rax)
  800420a49b:	48 b8 88 d8 20 04 80 	movabs $0x800420d888,%rax
  800420a4a2:	00 00 00 
  800420a4a5:	48 c1 e8 10          	shr    $0x10,%rax
  800420a4a9:	89 c2                	mov    %eax,%edx
  800420a4ab:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a4b2:	00 00 00 
  800420a4b5:	66 89 50 46          	mov    %dx,0x46(%rax)
  800420a4b9:	48 b8 88 d8 20 04 80 	movabs $0x800420d888,%rax
  800420a4c0:	00 00 00 
  800420a4c3:	48 c1 e8 20          	shr    $0x20,%rax
  800420a4c7:	89 c2                	mov    %eax,%edx
  800420a4c9:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a4d0:	00 00 00 
  800420a4d3:	89 50 48             	mov    %edx,0x48(%rax)
  800420a4d6:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a4dd:	00 00 00 
  800420a4e0:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
	SETGATE(idt[T_BOUND],  0, GD_KT, &Xbound,  0);
  800420a4e7:	48 b8 92 d8 20 04 80 	movabs $0x800420d892,%rax
  800420a4ee:	00 00 00 
  800420a4f1:	89 c2                	mov    %eax,%edx
  800420a4f3:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a4fa:	00 00 00 
  800420a4fd:	66 89 50 50          	mov    %dx,0x50(%rax)
  800420a501:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a508:	00 00 00 
  800420a50b:	66 c7 40 52 08 00    	movw   $0x8,0x52(%rax)
  800420a511:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a518:	00 00 00 
  800420a51b:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  800420a51f:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a522:	88 50 54             	mov    %dl,0x54(%rax)
  800420a525:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a52c:	00 00 00 
  800420a52f:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  800420a533:	83 e2 07             	and    $0x7,%edx
  800420a536:	88 50 54             	mov    %dl,0x54(%rax)
  800420a539:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a540:	00 00 00 
  800420a543:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  800420a547:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a54a:	83 ca 0e             	or     $0xe,%edx
  800420a54d:	88 50 55             	mov    %dl,0x55(%rax)
  800420a550:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a557:	00 00 00 
  800420a55a:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  800420a55e:	83 e2 ef             	and    $0xffffffef,%edx
  800420a561:	88 50 55             	mov    %dl,0x55(%rax)
  800420a564:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a56b:	00 00 00 
  800420a56e:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  800420a572:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a575:	88 50 55             	mov    %dl,0x55(%rax)
  800420a578:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a57f:	00 00 00 
  800420a582:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  800420a586:	83 ca 80             	or     $0xffffff80,%edx
  800420a589:	88 50 55             	mov    %dl,0x55(%rax)
  800420a58c:	48 b8 92 d8 20 04 80 	movabs $0x800420d892,%rax
  800420a593:	00 00 00 
  800420a596:	48 c1 e8 10          	shr    $0x10,%rax
  800420a59a:	89 c2                	mov    %eax,%edx
  800420a59c:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a5a3:	00 00 00 
  800420a5a6:	66 89 50 56          	mov    %dx,0x56(%rax)
  800420a5aa:	48 b8 92 d8 20 04 80 	movabs $0x800420d892,%rax
  800420a5b1:	00 00 00 
  800420a5b4:	48 c1 e8 20          	shr    $0x20,%rax
  800420a5b8:	89 c2                	mov    %eax,%edx
  800420a5ba:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a5c1:	00 00 00 
  800420a5c4:	89 50 58             	mov    %edx,0x58(%rax)
  800420a5c7:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a5ce:	00 00 00 
  800420a5d1:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
	SETGATE(idt[T_ILLOP],  0, GD_KT, &Xillop,  0);
  800420a5d8:	48 b8 9c d8 20 04 80 	movabs $0x800420d89c,%rax
  800420a5df:	00 00 00 
  800420a5e2:	89 c2                	mov    %eax,%edx
  800420a5e4:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a5eb:	00 00 00 
  800420a5ee:	66 89 50 60          	mov    %dx,0x60(%rax)
  800420a5f2:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a5f9:	00 00 00 
  800420a5fc:	66 c7 40 62 08 00    	movw   $0x8,0x62(%rax)
  800420a602:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a609:	00 00 00 
  800420a60c:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  800420a610:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a613:	88 50 64             	mov    %dl,0x64(%rax)
  800420a616:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a61d:	00 00 00 
  800420a620:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  800420a624:	83 e2 07             	and    $0x7,%edx
  800420a627:	88 50 64             	mov    %dl,0x64(%rax)
  800420a62a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a631:	00 00 00 
  800420a634:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420a638:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a63b:	83 ca 0e             	or     $0xe,%edx
  800420a63e:	88 50 65             	mov    %dl,0x65(%rax)
  800420a641:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a648:	00 00 00 
  800420a64b:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420a64f:	83 e2 ef             	and    $0xffffffef,%edx
  800420a652:	88 50 65             	mov    %dl,0x65(%rax)
  800420a655:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a65c:	00 00 00 
  800420a65f:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420a663:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a666:	88 50 65             	mov    %dl,0x65(%rax)
  800420a669:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a670:	00 00 00 
  800420a673:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420a677:	83 ca 80             	or     $0xffffff80,%edx
  800420a67a:	88 50 65             	mov    %dl,0x65(%rax)
  800420a67d:	48 b8 9c d8 20 04 80 	movabs $0x800420d89c,%rax
  800420a684:	00 00 00 
  800420a687:	48 c1 e8 10          	shr    $0x10,%rax
  800420a68b:	89 c2                	mov    %eax,%edx
  800420a68d:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a694:	00 00 00 
  800420a697:	66 89 50 66          	mov    %dx,0x66(%rax)
  800420a69b:	48 b8 9c d8 20 04 80 	movabs $0x800420d89c,%rax
  800420a6a2:	00 00 00 
  800420a6a5:	48 c1 e8 20          	shr    $0x20,%rax
  800420a6a9:	89 c2                	mov    %eax,%edx
  800420a6ab:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a6b2:	00 00 00 
  800420a6b5:	89 50 68             	mov    %edx,0x68(%rax)
  800420a6b8:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a6bf:	00 00 00 
  800420a6c2:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%rax)
	SETGATE(idt[T_DEVICE], 0, GD_KT, &Xdevice, 0);
  800420a6c9:	48 b8 a6 d8 20 04 80 	movabs $0x800420d8a6,%rax
  800420a6d0:	00 00 00 
  800420a6d3:	89 c2                	mov    %eax,%edx
  800420a6d5:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a6dc:	00 00 00 
  800420a6df:	66 89 50 70          	mov    %dx,0x70(%rax)
  800420a6e3:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a6ea:	00 00 00 
  800420a6ed:	66 c7 40 72 08 00    	movw   $0x8,0x72(%rax)
  800420a6f3:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a6fa:	00 00 00 
  800420a6fd:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  800420a701:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a704:	88 50 74             	mov    %dl,0x74(%rax)
  800420a707:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a70e:	00 00 00 
  800420a711:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  800420a715:	83 e2 07             	and    $0x7,%edx
  800420a718:	88 50 74             	mov    %dl,0x74(%rax)
  800420a71b:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a722:	00 00 00 
  800420a725:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420a729:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a72c:	83 ca 0e             	or     $0xe,%edx
  800420a72f:	88 50 75             	mov    %dl,0x75(%rax)
  800420a732:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a739:	00 00 00 
  800420a73c:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420a740:	83 e2 ef             	and    $0xffffffef,%edx
  800420a743:	88 50 75             	mov    %dl,0x75(%rax)
  800420a746:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a74d:	00 00 00 
  800420a750:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420a754:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a757:	88 50 75             	mov    %dl,0x75(%rax)
  800420a75a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a761:	00 00 00 
  800420a764:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420a768:	83 ca 80             	or     $0xffffff80,%edx
  800420a76b:	88 50 75             	mov    %dl,0x75(%rax)
  800420a76e:	48 b8 a6 d8 20 04 80 	movabs $0x800420d8a6,%rax
  800420a775:	00 00 00 
  800420a778:	48 c1 e8 10          	shr    $0x10,%rax
  800420a77c:	89 c2                	mov    %eax,%edx
  800420a77e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a785:	00 00 00 
  800420a788:	66 89 50 76          	mov    %dx,0x76(%rax)
  800420a78c:	48 b8 a6 d8 20 04 80 	movabs $0x800420d8a6,%rax
  800420a793:	00 00 00 
  800420a796:	48 c1 e8 20          	shr    $0x20,%rax
  800420a79a:	89 c2                	mov    %eax,%edx
  800420a79c:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a7a3:	00 00 00 
  800420a7a6:	89 50 78             	mov    %edx,0x78(%rax)
  800420a7a9:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a7b0:	00 00 00 
  800420a7b3:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
	SETGATE(idt[T_DBLFLT], 0, GD_KT, &Xdblflt, 0);
  800420a7ba:	48 b8 b0 d8 20 04 80 	movabs $0x800420d8b0,%rax
  800420a7c1:	00 00 00 
  800420a7c4:	89 c2                	mov    %eax,%edx
  800420a7c6:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a7cd:	00 00 00 
  800420a7d0:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
  800420a7d7:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a7de:	00 00 00 
  800420a7e1:	66 c7 80 82 00 00 00 	movw   $0x8,0x82(%rax)
  800420a7e8:	08 00 
  800420a7ea:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a7f1:	00 00 00 
  800420a7f4:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  800420a7fb:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a7fe:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  800420a804:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a80b:	00 00 00 
  800420a80e:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  800420a815:	83 e2 07             	and    $0x7,%edx
  800420a818:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  800420a81e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a825:	00 00 00 
  800420a828:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420a82f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a832:	83 ca 0e             	or     $0xe,%edx
  800420a835:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420a83b:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a842:	00 00 00 
  800420a845:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420a84c:	83 e2 ef             	and    $0xffffffef,%edx
  800420a84f:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420a855:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a85c:	00 00 00 
  800420a85f:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420a866:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a869:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420a86f:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a876:	00 00 00 
  800420a879:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420a880:	83 ca 80             	or     $0xffffff80,%edx
  800420a883:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420a889:	48 b8 b0 d8 20 04 80 	movabs $0x800420d8b0,%rax
  800420a890:	00 00 00 
  800420a893:	48 c1 e8 10          	shr    $0x10,%rax
  800420a897:	89 c2                	mov    %eax,%edx
  800420a899:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a8a0:	00 00 00 
  800420a8a3:	66 89 90 86 00 00 00 	mov    %dx,0x86(%rax)
  800420a8aa:	48 b8 b0 d8 20 04 80 	movabs $0x800420d8b0,%rax
  800420a8b1:	00 00 00 
  800420a8b4:	48 c1 e8 20          	shr    $0x20,%rax
  800420a8b8:	89 c2                	mov    %eax,%edx
  800420a8ba:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a8c1:	00 00 00 
  800420a8c4:	89 90 88 00 00 00    	mov    %edx,0x88(%rax)
  800420a8ca:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a8d1:	00 00 00 
  800420a8d4:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%rax)
  800420a8db:	00 00 00 
	SETGATE(idt[T_TSS],    0, GD_KT, &Xtss,    0);
  800420a8de:	48 b8 b8 d8 20 04 80 	movabs $0x800420d8b8,%rax
  800420a8e5:	00 00 00 
  800420a8e8:	89 c2                	mov    %eax,%edx
  800420a8ea:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a8f1:	00 00 00 
  800420a8f4:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
  800420a8fb:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a902:	00 00 00 
  800420a905:	66 c7 80 a2 00 00 00 	movw   $0x8,0xa2(%rax)
  800420a90c:	08 00 
  800420a90e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a915:	00 00 00 
  800420a918:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  800420a91f:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a922:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  800420a928:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a92f:	00 00 00 
  800420a932:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  800420a939:	83 e2 07             	and    $0x7,%edx
  800420a93c:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  800420a942:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a949:	00 00 00 
  800420a94c:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a953:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a956:	83 ca 0e             	or     $0xe,%edx
  800420a959:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a95f:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a966:	00 00 00 
  800420a969:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a970:	83 e2 ef             	and    $0xffffffef,%edx
  800420a973:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a979:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a980:	00 00 00 
  800420a983:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a98a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a98d:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a993:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a99a:	00 00 00 
  800420a99d:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a9a4:	83 ca 80             	or     $0xffffff80,%edx
  800420a9a7:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a9ad:	48 b8 b8 d8 20 04 80 	movabs $0x800420d8b8,%rax
  800420a9b4:	00 00 00 
  800420a9b7:	48 c1 e8 10          	shr    $0x10,%rax
  800420a9bb:	89 c2                	mov    %eax,%edx
  800420a9bd:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a9c4:	00 00 00 
  800420a9c7:	66 89 90 a6 00 00 00 	mov    %dx,0xa6(%rax)
  800420a9ce:	48 b8 b8 d8 20 04 80 	movabs $0x800420d8b8,%rax
  800420a9d5:	00 00 00 
  800420a9d8:	48 c1 e8 20          	shr    $0x20,%rax
  800420a9dc:	89 c2                	mov    %eax,%edx
  800420a9de:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a9e5:	00 00 00 
  800420a9e8:	89 90 a8 00 00 00    	mov    %edx,0xa8(%rax)
  800420a9ee:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420a9f5:	00 00 00 
  800420a9f8:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%rax)
  800420a9ff:	00 00 00 
	SETGATE(idt[T_SEGNP],  0, GD_KT, &Xsegnp,  0);
  800420aa02:	48 b8 c0 d8 20 04 80 	movabs $0x800420d8c0,%rax
  800420aa09:	00 00 00 
  800420aa0c:	89 c2                	mov    %eax,%edx
  800420aa0e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420aa15:	00 00 00 
  800420aa18:	66 89 90 b0 00 00 00 	mov    %dx,0xb0(%rax)
  800420aa1f:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420aa26:	00 00 00 
  800420aa29:	66 c7 80 b2 00 00 00 	movw   $0x8,0xb2(%rax)
  800420aa30:	08 00 
  800420aa32:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420aa39:	00 00 00 
  800420aa3c:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  800420aa43:	83 e2 f8             	and    $0xfffffff8,%edx
  800420aa46:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  800420aa4c:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420aa53:	00 00 00 
  800420aa56:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  800420aa5d:	83 e2 07             	and    $0x7,%edx
  800420aa60:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  800420aa66:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420aa6d:	00 00 00 
  800420aa70:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420aa77:	83 e2 f0             	and    $0xfffffff0,%edx
  800420aa7a:	83 ca 0e             	or     $0xe,%edx
  800420aa7d:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420aa83:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420aa8a:	00 00 00 
  800420aa8d:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420aa94:	83 e2 ef             	and    $0xffffffef,%edx
  800420aa97:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420aa9d:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420aaa4:	00 00 00 
  800420aaa7:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420aaae:	83 e2 9f             	and    $0xffffff9f,%edx
  800420aab1:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420aab7:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420aabe:	00 00 00 
  800420aac1:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420aac8:	83 ca 80             	or     $0xffffff80,%edx
  800420aacb:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420aad1:	48 b8 c0 d8 20 04 80 	movabs $0x800420d8c0,%rax
  800420aad8:	00 00 00 
  800420aadb:	48 c1 e8 10          	shr    $0x10,%rax
  800420aadf:	89 c2                	mov    %eax,%edx
  800420aae1:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420aae8:	00 00 00 
  800420aaeb:	66 89 90 b6 00 00 00 	mov    %dx,0xb6(%rax)
  800420aaf2:	48 b8 c0 d8 20 04 80 	movabs $0x800420d8c0,%rax
  800420aaf9:	00 00 00 
  800420aafc:	48 c1 e8 20          	shr    $0x20,%rax
  800420ab00:	89 c2                	mov    %eax,%edx
  800420ab02:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ab09:	00 00 00 
  800420ab0c:	89 90 b8 00 00 00    	mov    %edx,0xb8(%rax)
  800420ab12:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ab19:	00 00 00 
  800420ab1c:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%rax)
  800420ab23:	00 00 00 
	SETGATE(idt[T_STACK],  0, GD_KT, &Xstack,  0);
  800420ab26:	48 b8 c8 d8 20 04 80 	movabs $0x800420d8c8,%rax
  800420ab2d:	00 00 00 
  800420ab30:	89 c2                	mov    %eax,%edx
  800420ab32:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ab39:	00 00 00 
  800420ab3c:	66 89 90 c0 00 00 00 	mov    %dx,0xc0(%rax)
  800420ab43:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ab4a:	00 00 00 
  800420ab4d:	66 c7 80 c2 00 00 00 	movw   $0x8,0xc2(%rax)
  800420ab54:	08 00 
  800420ab56:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ab5d:	00 00 00 
  800420ab60:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  800420ab67:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ab6a:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  800420ab70:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ab77:	00 00 00 
  800420ab7a:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  800420ab81:	83 e2 07             	and    $0x7,%edx
  800420ab84:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  800420ab8a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ab91:	00 00 00 
  800420ab94:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420ab9b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ab9e:	83 ca 0e             	or     $0xe,%edx
  800420aba1:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420aba7:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420abae:	00 00 00 
  800420abb1:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420abb8:	83 e2 ef             	and    $0xffffffef,%edx
  800420abbb:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420abc1:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420abc8:	00 00 00 
  800420abcb:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420abd2:	83 e2 9f             	and    $0xffffff9f,%edx
  800420abd5:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420abdb:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420abe2:	00 00 00 
  800420abe5:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420abec:	83 ca 80             	or     $0xffffff80,%edx
  800420abef:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420abf5:	48 b8 c8 d8 20 04 80 	movabs $0x800420d8c8,%rax
  800420abfc:	00 00 00 
  800420abff:	48 c1 e8 10          	shr    $0x10,%rax
  800420ac03:	89 c2                	mov    %eax,%edx
  800420ac05:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ac0c:	00 00 00 
  800420ac0f:	66 89 90 c6 00 00 00 	mov    %dx,0xc6(%rax)
  800420ac16:	48 b8 c8 d8 20 04 80 	movabs $0x800420d8c8,%rax
  800420ac1d:	00 00 00 
  800420ac20:	48 c1 e8 20          	shr    $0x20,%rax
  800420ac24:	89 c2                	mov    %eax,%edx
  800420ac26:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ac2d:	00 00 00 
  800420ac30:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)
  800420ac36:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ac3d:	00 00 00 
  800420ac40:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  800420ac47:	00 00 00 
	SETGATE(idt[T_GPFLT],  0, GD_KT, &Xgpflt,  0);
  800420ac4a:	48 b8 d0 d8 20 04 80 	movabs $0x800420d8d0,%rax
  800420ac51:	00 00 00 
  800420ac54:	89 c2                	mov    %eax,%edx
  800420ac56:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ac5d:	00 00 00 
  800420ac60:	66 89 90 d0 00 00 00 	mov    %dx,0xd0(%rax)
  800420ac67:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ac6e:	00 00 00 
  800420ac71:	66 c7 80 d2 00 00 00 	movw   $0x8,0xd2(%rax)
  800420ac78:	08 00 
  800420ac7a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ac81:	00 00 00 
  800420ac84:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  800420ac8b:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ac8e:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  800420ac94:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ac9b:	00 00 00 
  800420ac9e:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  800420aca5:	83 e2 07             	and    $0x7,%edx
  800420aca8:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  800420acae:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420acb5:	00 00 00 
  800420acb8:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420acbf:	83 e2 f0             	and    $0xfffffff0,%edx
  800420acc2:	83 ca 0e             	or     $0xe,%edx
  800420acc5:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420accb:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420acd2:	00 00 00 
  800420acd5:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420acdc:	83 e2 ef             	and    $0xffffffef,%edx
  800420acdf:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420ace5:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420acec:	00 00 00 
  800420acef:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420acf6:	83 e2 9f             	and    $0xffffff9f,%edx
  800420acf9:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420acff:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ad06:	00 00 00 
  800420ad09:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420ad10:	83 ca 80             	or     $0xffffff80,%edx
  800420ad13:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420ad19:	48 b8 d0 d8 20 04 80 	movabs $0x800420d8d0,%rax
  800420ad20:	00 00 00 
  800420ad23:	48 c1 e8 10          	shr    $0x10,%rax
  800420ad27:	89 c2                	mov    %eax,%edx
  800420ad29:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ad30:	00 00 00 
  800420ad33:	66 89 90 d6 00 00 00 	mov    %dx,0xd6(%rax)
  800420ad3a:	48 b8 d0 d8 20 04 80 	movabs $0x800420d8d0,%rax
  800420ad41:	00 00 00 
  800420ad44:	48 c1 e8 20          	shr    $0x20,%rax
  800420ad48:	89 c2                	mov    %eax,%edx
  800420ad4a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ad51:	00 00 00 
  800420ad54:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
  800420ad5a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ad61:	00 00 00 
  800420ad64:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%rax)
  800420ad6b:	00 00 00 
	SETGATE(idt[T_PGFLT],  0, GD_KT, &Xpgflt,  0);
  800420ad6e:	48 b8 d8 d8 20 04 80 	movabs $0x800420d8d8,%rax
  800420ad75:	00 00 00 
  800420ad78:	89 c2                	mov    %eax,%edx
  800420ad7a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ad81:	00 00 00 
  800420ad84:	66 89 90 e0 00 00 00 	mov    %dx,0xe0(%rax)
  800420ad8b:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ad92:	00 00 00 
  800420ad95:	66 c7 80 e2 00 00 00 	movw   $0x8,0xe2(%rax)
  800420ad9c:	08 00 
  800420ad9e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ada5:	00 00 00 
  800420ada8:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  800420adaf:	83 e2 f8             	and    $0xfffffff8,%edx
  800420adb2:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  800420adb8:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420adbf:	00 00 00 
  800420adc2:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  800420adc9:	83 e2 07             	and    $0x7,%edx
  800420adcc:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  800420add2:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420add9:	00 00 00 
  800420addc:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420ade3:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ade6:	83 ca 0e             	or     $0xe,%edx
  800420ade9:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420adef:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420adf6:	00 00 00 
  800420adf9:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420ae00:	83 e2 ef             	and    $0xffffffef,%edx
  800420ae03:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420ae09:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ae10:	00 00 00 
  800420ae13:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420ae1a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ae1d:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420ae23:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ae2a:	00 00 00 
  800420ae2d:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420ae34:	83 ca 80             	or     $0xffffff80,%edx
  800420ae37:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420ae3d:	48 b8 d8 d8 20 04 80 	movabs $0x800420d8d8,%rax
  800420ae44:	00 00 00 
  800420ae47:	48 c1 e8 10          	shr    $0x10,%rax
  800420ae4b:	89 c2                	mov    %eax,%edx
  800420ae4d:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ae54:	00 00 00 
  800420ae57:	66 89 90 e6 00 00 00 	mov    %dx,0xe6(%rax)
  800420ae5e:	48 b8 d8 d8 20 04 80 	movabs $0x800420d8d8,%rax
  800420ae65:	00 00 00 
  800420ae68:	48 c1 e8 20          	shr    $0x20,%rax
  800420ae6c:	89 c2                	mov    %eax,%edx
  800420ae6e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ae75:	00 00 00 
  800420ae78:	89 90 e8 00 00 00    	mov    %edx,0xe8(%rax)
  800420ae7e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ae85:	00 00 00 
  800420ae88:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%rax)
  800420ae8f:	00 00 00 
	SETGATE(idt[T_FPERR],  0, GD_KT, &Xfperr,  0);
  800420ae92:	48 b8 e0 d8 20 04 80 	movabs $0x800420d8e0,%rax
  800420ae99:	00 00 00 
  800420ae9c:	89 c2                	mov    %eax,%edx
  800420ae9e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420aea5:	00 00 00 
  800420aea8:	66 89 90 00 01 00 00 	mov    %dx,0x100(%rax)
  800420aeaf:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420aeb6:	00 00 00 
  800420aeb9:	66 c7 80 02 01 00 00 	movw   $0x8,0x102(%rax)
  800420aec0:	08 00 
  800420aec2:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420aec9:	00 00 00 
  800420aecc:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  800420aed3:	83 e2 f8             	and    $0xfffffff8,%edx
  800420aed6:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  800420aedc:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420aee3:	00 00 00 
  800420aee6:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  800420aeed:	83 e2 07             	and    $0x7,%edx
  800420aef0:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  800420aef6:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420aefd:	00 00 00 
  800420af00:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420af07:	83 e2 f0             	and    $0xfffffff0,%edx
  800420af0a:	83 ca 0e             	or     $0xe,%edx
  800420af0d:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420af13:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420af1a:	00 00 00 
  800420af1d:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420af24:	83 e2 ef             	and    $0xffffffef,%edx
  800420af27:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420af2d:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420af34:	00 00 00 
  800420af37:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420af3e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420af41:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420af47:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420af4e:	00 00 00 
  800420af51:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420af58:	83 ca 80             	or     $0xffffff80,%edx
  800420af5b:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420af61:	48 b8 e0 d8 20 04 80 	movabs $0x800420d8e0,%rax
  800420af68:	00 00 00 
  800420af6b:	48 c1 e8 10          	shr    $0x10,%rax
  800420af6f:	89 c2                	mov    %eax,%edx
  800420af71:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420af78:	00 00 00 
  800420af7b:	66 89 90 06 01 00 00 	mov    %dx,0x106(%rax)
  800420af82:	48 b8 e0 d8 20 04 80 	movabs $0x800420d8e0,%rax
  800420af89:	00 00 00 
  800420af8c:	48 c1 e8 20          	shr    $0x20,%rax
  800420af90:	89 c2                	mov    %eax,%edx
  800420af92:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420af99:	00 00 00 
  800420af9c:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
  800420afa2:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420afa9:	00 00 00 
  800420afac:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%rax)
  800420afb3:	00 00 00 
	SETGATE(idt[T_ALIGN],  0, GD_KT, &Xalign,  0);
  800420afb6:	48 b8 e6 d8 20 04 80 	movabs $0x800420d8e6,%rax
  800420afbd:	00 00 00 
  800420afc0:	89 c2                	mov    %eax,%edx
  800420afc2:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420afc9:	00 00 00 
  800420afcc:	66 89 90 10 01 00 00 	mov    %dx,0x110(%rax)
  800420afd3:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420afda:	00 00 00 
  800420afdd:	66 c7 80 12 01 00 00 	movw   $0x8,0x112(%rax)
  800420afe4:	08 00 
  800420afe6:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420afed:	00 00 00 
  800420aff0:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  800420aff7:	83 e2 f8             	and    $0xfffffff8,%edx
  800420affa:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  800420b000:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b007:	00 00 00 
  800420b00a:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  800420b011:	83 e2 07             	and    $0x7,%edx
  800420b014:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  800420b01a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b021:	00 00 00 
  800420b024:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420b02b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b02e:	83 ca 0e             	or     $0xe,%edx
  800420b031:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420b037:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b03e:	00 00 00 
  800420b041:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420b048:	83 e2 ef             	and    $0xffffffef,%edx
  800420b04b:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420b051:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b058:	00 00 00 
  800420b05b:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420b062:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b065:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420b06b:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b072:	00 00 00 
  800420b075:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420b07c:	83 ca 80             	or     $0xffffff80,%edx
  800420b07f:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420b085:	48 b8 e6 d8 20 04 80 	movabs $0x800420d8e6,%rax
  800420b08c:	00 00 00 
  800420b08f:	48 c1 e8 10          	shr    $0x10,%rax
  800420b093:	89 c2                	mov    %eax,%edx
  800420b095:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b09c:	00 00 00 
  800420b09f:	66 89 90 16 01 00 00 	mov    %dx,0x116(%rax)
  800420b0a6:	48 b8 e6 d8 20 04 80 	movabs $0x800420d8e6,%rax
  800420b0ad:	00 00 00 
  800420b0b0:	48 c1 e8 20          	shr    $0x20,%rax
  800420b0b4:	89 c2                	mov    %eax,%edx
  800420b0b6:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b0bd:	00 00 00 
  800420b0c0:	89 90 18 01 00 00    	mov    %edx,0x118(%rax)
  800420b0c6:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b0cd:	00 00 00 
  800420b0d0:	c7 80 1c 01 00 00 00 	movl   $0x0,0x11c(%rax)
  800420b0d7:	00 00 00 
	SETGATE(idt[T_MCHK],   0, GD_KT, &Xmchk,   0);
  800420b0da:	48 b8 ea d8 20 04 80 	movabs $0x800420d8ea,%rax
  800420b0e1:	00 00 00 
  800420b0e4:	89 c2                	mov    %eax,%edx
  800420b0e6:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b0ed:	00 00 00 
  800420b0f0:	66 89 90 20 01 00 00 	mov    %dx,0x120(%rax)
  800420b0f7:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b0fe:	00 00 00 
  800420b101:	66 c7 80 22 01 00 00 	movw   $0x8,0x122(%rax)
  800420b108:	08 00 
  800420b10a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b111:	00 00 00 
  800420b114:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420b11b:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b11e:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420b124:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b12b:	00 00 00 
  800420b12e:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420b135:	83 e2 07             	and    $0x7,%edx
  800420b138:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420b13e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b145:	00 00 00 
  800420b148:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420b14f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b152:	83 ca 0e             	or     $0xe,%edx
  800420b155:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420b15b:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b162:	00 00 00 
  800420b165:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420b16c:	83 e2 ef             	and    $0xffffffef,%edx
  800420b16f:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420b175:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b17c:	00 00 00 
  800420b17f:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420b186:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b189:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420b18f:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b196:	00 00 00 
  800420b199:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420b1a0:	83 ca 80             	or     $0xffffff80,%edx
  800420b1a3:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420b1a9:	48 b8 ea d8 20 04 80 	movabs $0x800420d8ea,%rax
  800420b1b0:	00 00 00 
  800420b1b3:	48 c1 e8 10          	shr    $0x10,%rax
  800420b1b7:	89 c2                	mov    %eax,%edx
  800420b1b9:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b1c0:	00 00 00 
  800420b1c3:	66 89 90 26 01 00 00 	mov    %dx,0x126(%rax)
  800420b1ca:	48 b8 ea d8 20 04 80 	movabs $0x800420d8ea,%rax
  800420b1d1:	00 00 00 
  800420b1d4:	48 c1 e8 20          	shr    $0x20,%rax
  800420b1d8:	89 c2                	mov    %eax,%edx
  800420b1da:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b1e1:	00 00 00 
  800420b1e4:	89 90 28 01 00 00    	mov    %edx,0x128(%rax)
  800420b1ea:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b1f1:	00 00 00 
  800420b1f4:	c7 80 2c 01 00 00 00 	movl   $0x0,0x12c(%rax)
  800420b1fb:	00 00 00 


	SETGATE(idt[IRQ_OFFSET + 0], 0, GD_KT, &Xirq0, 0);
  800420b1fe:	48 b8 f0 d8 20 04 80 	movabs $0x800420d8f0,%rax
  800420b205:	00 00 00 
  800420b208:	89 c2                	mov    %eax,%edx
  800420b20a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b211:	00 00 00 
  800420b214:	66 89 90 00 02 00 00 	mov    %dx,0x200(%rax)
  800420b21b:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b222:	00 00 00 
  800420b225:	66 c7 80 02 02 00 00 	movw   $0x8,0x202(%rax)
  800420b22c:	08 00 
  800420b22e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b235:	00 00 00 
  800420b238:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420b23f:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b242:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420b248:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b24f:	00 00 00 
  800420b252:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420b259:	83 e2 07             	and    $0x7,%edx
  800420b25c:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420b262:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b269:	00 00 00 
  800420b26c:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420b273:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b276:	83 ca 0e             	or     $0xe,%edx
  800420b279:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420b27f:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b286:	00 00 00 
  800420b289:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420b290:	83 e2 ef             	and    $0xffffffef,%edx
  800420b293:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420b299:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b2a0:	00 00 00 
  800420b2a3:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420b2aa:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b2ad:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420b2b3:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b2ba:	00 00 00 
  800420b2bd:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420b2c4:	83 ca 80             	or     $0xffffff80,%edx
  800420b2c7:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420b2cd:	48 b8 f0 d8 20 04 80 	movabs $0x800420d8f0,%rax
  800420b2d4:	00 00 00 
  800420b2d7:	48 c1 e8 10          	shr    $0x10,%rax
  800420b2db:	89 c2                	mov    %eax,%edx
  800420b2dd:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b2e4:	00 00 00 
  800420b2e7:	66 89 90 06 02 00 00 	mov    %dx,0x206(%rax)
  800420b2ee:	48 b8 f0 d8 20 04 80 	movabs $0x800420d8f0,%rax
  800420b2f5:	00 00 00 
  800420b2f8:	48 c1 e8 20          	shr    $0x20,%rax
  800420b2fc:	89 c2                	mov    %eax,%edx
  800420b2fe:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b305:	00 00 00 
  800420b308:	89 90 08 02 00 00    	mov    %edx,0x208(%rax)
  800420b30e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b315:	00 00 00 
  800420b318:	c7 80 0c 02 00 00 00 	movl   $0x0,0x20c(%rax)
  800420b31f:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 1], 0, GD_KT, &Xirq1, 0);
  800420b322:	48 b8 f6 d8 20 04 80 	movabs $0x800420d8f6,%rax
  800420b329:	00 00 00 
  800420b32c:	89 c2                	mov    %eax,%edx
  800420b32e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b335:	00 00 00 
  800420b338:	66 89 90 10 02 00 00 	mov    %dx,0x210(%rax)
  800420b33f:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b346:	00 00 00 
  800420b349:	66 c7 80 12 02 00 00 	movw   $0x8,0x212(%rax)
  800420b350:	08 00 
  800420b352:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b359:	00 00 00 
  800420b35c:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420b363:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b366:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420b36c:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b373:	00 00 00 
  800420b376:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420b37d:	83 e2 07             	and    $0x7,%edx
  800420b380:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420b386:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b38d:	00 00 00 
  800420b390:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420b397:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b39a:	83 ca 0e             	or     $0xe,%edx
  800420b39d:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420b3a3:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b3aa:	00 00 00 
  800420b3ad:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420b3b4:	83 e2 ef             	and    $0xffffffef,%edx
  800420b3b7:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420b3bd:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b3c4:	00 00 00 
  800420b3c7:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420b3ce:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b3d1:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420b3d7:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b3de:	00 00 00 
  800420b3e1:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420b3e8:	83 ca 80             	or     $0xffffff80,%edx
  800420b3eb:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420b3f1:	48 b8 f6 d8 20 04 80 	movabs $0x800420d8f6,%rax
  800420b3f8:	00 00 00 
  800420b3fb:	48 c1 e8 10          	shr    $0x10,%rax
  800420b3ff:	89 c2                	mov    %eax,%edx
  800420b401:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b408:	00 00 00 
  800420b40b:	66 89 90 16 02 00 00 	mov    %dx,0x216(%rax)
  800420b412:	48 b8 f6 d8 20 04 80 	movabs $0x800420d8f6,%rax
  800420b419:	00 00 00 
  800420b41c:	48 c1 e8 20          	shr    $0x20,%rax
  800420b420:	89 c2                	mov    %eax,%edx
  800420b422:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b429:	00 00 00 
  800420b42c:	89 90 18 02 00 00    	mov    %edx,0x218(%rax)
  800420b432:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b439:	00 00 00 
  800420b43c:	c7 80 1c 02 00 00 00 	movl   $0x0,0x21c(%rax)
  800420b443:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 2], 0, GD_KT, &Xirq2, 0);
  800420b446:	48 b8 fc d8 20 04 80 	movabs $0x800420d8fc,%rax
  800420b44d:	00 00 00 
  800420b450:	89 c2                	mov    %eax,%edx
  800420b452:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b459:	00 00 00 
  800420b45c:	66 89 90 20 02 00 00 	mov    %dx,0x220(%rax)
  800420b463:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b46a:	00 00 00 
  800420b46d:	66 c7 80 22 02 00 00 	movw   $0x8,0x222(%rax)
  800420b474:	08 00 
  800420b476:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b47d:	00 00 00 
  800420b480:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420b487:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b48a:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420b490:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b497:	00 00 00 
  800420b49a:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420b4a1:	83 e2 07             	and    $0x7,%edx
  800420b4a4:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420b4aa:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b4b1:	00 00 00 
  800420b4b4:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420b4bb:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b4be:	83 ca 0e             	or     $0xe,%edx
  800420b4c1:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420b4c7:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b4ce:	00 00 00 
  800420b4d1:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420b4d8:	83 e2 ef             	and    $0xffffffef,%edx
  800420b4db:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420b4e1:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b4e8:	00 00 00 
  800420b4eb:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420b4f2:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b4f5:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420b4fb:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b502:	00 00 00 
  800420b505:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420b50c:	83 ca 80             	or     $0xffffff80,%edx
  800420b50f:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420b515:	48 b8 fc d8 20 04 80 	movabs $0x800420d8fc,%rax
  800420b51c:	00 00 00 
  800420b51f:	48 c1 e8 10          	shr    $0x10,%rax
  800420b523:	89 c2                	mov    %eax,%edx
  800420b525:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b52c:	00 00 00 
  800420b52f:	66 89 90 26 02 00 00 	mov    %dx,0x226(%rax)
  800420b536:	48 b8 fc d8 20 04 80 	movabs $0x800420d8fc,%rax
  800420b53d:	00 00 00 
  800420b540:	48 c1 e8 20          	shr    $0x20,%rax
  800420b544:	89 c2                	mov    %eax,%edx
  800420b546:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b54d:	00 00 00 
  800420b550:	89 90 28 02 00 00    	mov    %edx,0x228(%rax)
  800420b556:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b55d:	00 00 00 
  800420b560:	c7 80 2c 02 00 00 00 	movl   $0x0,0x22c(%rax)
  800420b567:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 3], 0, GD_KT, &Xirq3, 0);
  800420b56a:	48 b8 02 d9 20 04 80 	movabs $0x800420d902,%rax
  800420b571:	00 00 00 
  800420b574:	89 c2                	mov    %eax,%edx
  800420b576:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b57d:	00 00 00 
  800420b580:	66 89 90 30 02 00 00 	mov    %dx,0x230(%rax)
  800420b587:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b58e:	00 00 00 
  800420b591:	66 c7 80 32 02 00 00 	movw   $0x8,0x232(%rax)
  800420b598:	08 00 
  800420b59a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b5a1:	00 00 00 
  800420b5a4:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420b5ab:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b5ae:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420b5b4:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b5bb:	00 00 00 
  800420b5be:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420b5c5:	83 e2 07             	and    $0x7,%edx
  800420b5c8:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420b5ce:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b5d5:	00 00 00 
  800420b5d8:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420b5df:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b5e2:	83 ca 0e             	or     $0xe,%edx
  800420b5e5:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420b5eb:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b5f2:	00 00 00 
  800420b5f5:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420b5fc:	83 e2 ef             	and    $0xffffffef,%edx
  800420b5ff:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420b605:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b60c:	00 00 00 
  800420b60f:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420b616:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b619:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420b61f:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b626:	00 00 00 
  800420b629:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420b630:	83 ca 80             	or     $0xffffff80,%edx
  800420b633:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420b639:	48 b8 02 d9 20 04 80 	movabs $0x800420d902,%rax
  800420b640:	00 00 00 
  800420b643:	48 c1 e8 10          	shr    $0x10,%rax
  800420b647:	89 c2                	mov    %eax,%edx
  800420b649:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b650:	00 00 00 
  800420b653:	66 89 90 36 02 00 00 	mov    %dx,0x236(%rax)
  800420b65a:	48 b8 02 d9 20 04 80 	movabs $0x800420d902,%rax
  800420b661:	00 00 00 
  800420b664:	48 c1 e8 20          	shr    $0x20,%rax
  800420b668:	89 c2                	mov    %eax,%edx
  800420b66a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b671:	00 00 00 
  800420b674:	89 90 38 02 00 00    	mov    %edx,0x238(%rax)
  800420b67a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b681:	00 00 00 
  800420b684:	c7 80 3c 02 00 00 00 	movl   $0x0,0x23c(%rax)
  800420b68b:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 4], 0, GD_KT, &Xirq4, 0);
  800420b68e:	48 b8 08 d9 20 04 80 	movabs $0x800420d908,%rax
  800420b695:	00 00 00 
  800420b698:	89 c2                	mov    %eax,%edx
  800420b69a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b6a1:	00 00 00 
  800420b6a4:	66 89 90 40 02 00 00 	mov    %dx,0x240(%rax)
  800420b6ab:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b6b2:	00 00 00 
  800420b6b5:	66 c7 80 42 02 00 00 	movw   $0x8,0x242(%rax)
  800420b6bc:	08 00 
  800420b6be:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b6c5:	00 00 00 
  800420b6c8:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420b6cf:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b6d2:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420b6d8:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b6df:	00 00 00 
  800420b6e2:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420b6e9:	83 e2 07             	and    $0x7,%edx
  800420b6ec:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420b6f2:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b6f9:	00 00 00 
  800420b6fc:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420b703:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b706:	83 ca 0e             	or     $0xe,%edx
  800420b709:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420b70f:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b716:	00 00 00 
  800420b719:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420b720:	83 e2 ef             	and    $0xffffffef,%edx
  800420b723:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420b729:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b730:	00 00 00 
  800420b733:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420b73a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b73d:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420b743:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b74a:	00 00 00 
  800420b74d:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420b754:	83 ca 80             	or     $0xffffff80,%edx
  800420b757:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420b75d:	48 b8 08 d9 20 04 80 	movabs $0x800420d908,%rax
  800420b764:	00 00 00 
  800420b767:	48 c1 e8 10          	shr    $0x10,%rax
  800420b76b:	89 c2                	mov    %eax,%edx
  800420b76d:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b774:	00 00 00 
  800420b777:	66 89 90 46 02 00 00 	mov    %dx,0x246(%rax)
  800420b77e:	48 b8 08 d9 20 04 80 	movabs $0x800420d908,%rax
  800420b785:	00 00 00 
  800420b788:	48 c1 e8 20          	shr    $0x20,%rax
  800420b78c:	89 c2                	mov    %eax,%edx
  800420b78e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b795:	00 00 00 
  800420b798:	89 90 48 02 00 00    	mov    %edx,0x248(%rax)
  800420b79e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b7a5:	00 00 00 
  800420b7a8:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%rax)
  800420b7af:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 5], 0, GD_KT, &Xirq5, 0);
  800420b7b2:	48 b8 0e d9 20 04 80 	movabs $0x800420d90e,%rax
  800420b7b9:	00 00 00 
  800420b7bc:	89 c2                	mov    %eax,%edx
  800420b7be:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b7c5:	00 00 00 
  800420b7c8:	66 89 90 50 02 00 00 	mov    %dx,0x250(%rax)
  800420b7cf:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b7d6:	00 00 00 
  800420b7d9:	66 c7 80 52 02 00 00 	movw   $0x8,0x252(%rax)
  800420b7e0:	08 00 
  800420b7e2:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b7e9:	00 00 00 
  800420b7ec:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420b7f3:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b7f6:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420b7fc:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b803:	00 00 00 
  800420b806:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420b80d:	83 e2 07             	and    $0x7,%edx
  800420b810:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420b816:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b81d:	00 00 00 
  800420b820:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b827:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b82a:	83 ca 0e             	or     $0xe,%edx
  800420b82d:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b833:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b83a:	00 00 00 
  800420b83d:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b844:	83 e2 ef             	and    $0xffffffef,%edx
  800420b847:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b84d:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b854:	00 00 00 
  800420b857:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b85e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b861:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b867:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b86e:	00 00 00 
  800420b871:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b878:	83 ca 80             	or     $0xffffff80,%edx
  800420b87b:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b881:	48 b8 0e d9 20 04 80 	movabs $0x800420d90e,%rax
  800420b888:	00 00 00 
  800420b88b:	48 c1 e8 10          	shr    $0x10,%rax
  800420b88f:	89 c2                	mov    %eax,%edx
  800420b891:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b898:	00 00 00 
  800420b89b:	66 89 90 56 02 00 00 	mov    %dx,0x256(%rax)
  800420b8a2:	48 b8 0e d9 20 04 80 	movabs $0x800420d90e,%rax
  800420b8a9:	00 00 00 
  800420b8ac:	48 c1 e8 20          	shr    $0x20,%rax
  800420b8b0:	89 c2                	mov    %eax,%edx
  800420b8b2:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b8b9:	00 00 00 
  800420b8bc:	89 90 58 02 00 00    	mov    %edx,0x258(%rax)
  800420b8c2:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b8c9:	00 00 00 
  800420b8cc:	c7 80 5c 02 00 00 00 	movl   $0x0,0x25c(%rax)
  800420b8d3:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 6], 0, GD_KT, &Xirq6, 0);
  800420b8d6:	48 b8 14 d9 20 04 80 	movabs $0x800420d914,%rax
  800420b8dd:	00 00 00 
  800420b8e0:	89 c2                	mov    %eax,%edx
  800420b8e2:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b8e9:	00 00 00 
  800420b8ec:	66 89 90 60 02 00 00 	mov    %dx,0x260(%rax)
  800420b8f3:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b8fa:	00 00 00 
  800420b8fd:	66 c7 80 62 02 00 00 	movw   $0x8,0x262(%rax)
  800420b904:	08 00 
  800420b906:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b90d:	00 00 00 
  800420b910:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420b917:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b91a:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420b920:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b927:	00 00 00 
  800420b92a:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420b931:	83 e2 07             	and    $0x7,%edx
  800420b934:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420b93a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b941:	00 00 00 
  800420b944:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b94b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b94e:	83 ca 0e             	or     $0xe,%edx
  800420b951:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b957:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b95e:	00 00 00 
  800420b961:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b968:	83 e2 ef             	and    $0xffffffef,%edx
  800420b96b:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b971:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b978:	00 00 00 
  800420b97b:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b982:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b985:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b98b:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b992:	00 00 00 
  800420b995:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b99c:	83 ca 80             	or     $0xffffff80,%edx
  800420b99f:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b9a5:	48 b8 14 d9 20 04 80 	movabs $0x800420d914,%rax
  800420b9ac:	00 00 00 
  800420b9af:	48 c1 e8 10          	shr    $0x10,%rax
  800420b9b3:	89 c2                	mov    %eax,%edx
  800420b9b5:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b9bc:	00 00 00 
  800420b9bf:	66 89 90 66 02 00 00 	mov    %dx,0x266(%rax)
  800420b9c6:	48 b8 14 d9 20 04 80 	movabs $0x800420d914,%rax
  800420b9cd:	00 00 00 
  800420b9d0:	48 c1 e8 20          	shr    $0x20,%rax
  800420b9d4:	89 c2                	mov    %eax,%edx
  800420b9d6:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b9dd:	00 00 00 
  800420b9e0:	89 90 68 02 00 00    	mov    %edx,0x268(%rax)
  800420b9e6:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420b9ed:	00 00 00 
  800420b9f0:	c7 80 6c 02 00 00 00 	movl   $0x0,0x26c(%rax)
  800420b9f7:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 7], 0, GD_KT, &Xirq7, 0);
  800420b9fa:	48 b8 1a d9 20 04 80 	movabs $0x800420d91a,%rax
  800420ba01:	00 00 00 
  800420ba04:	89 c2                	mov    %eax,%edx
  800420ba06:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ba0d:	00 00 00 
  800420ba10:	66 89 90 70 02 00 00 	mov    %dx,0x270(%rax)
  800420ba17:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ba1e:	00 00 00 
  800420ba21:	66 c7 80 72 02 00 00 	movw   $0x8,0x272(%rax)
  800420ba28:	08 00 
  800420ba2a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ba31:	00 00 00 
  800420ba34:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420ba3b:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ba3e:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420ba44:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ba4b:	00 00 00 
  800420ba4e:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420ba55:	83 e2 07             	and    $0x7,%edx
  800420ba58:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420ba5e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ba65:	00 00 00 
  800420ba68:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420ba6f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ba72:	83 ca 0e             	or     $0xe,%edx
  800420ba75:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420ba7b:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ba82:	00 00 00 
  800420ba85:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420ba8c:	83 e2 ef             	and    $0xffffffef,%edx
  800420ba8f:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420ba95:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420ba9c:	00 00 00 
  800420ba9f:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420baa6:	83 e2 9f             	and    $0xffffff9f,%edx
  800420baa9:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420baaf:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bab6:	00 00 00 
  800420bab9:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420bac0:	83 ca 80             	or     $0xffffff80,%edx
  800420bac3:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420bac9:	48 b8 1a d9 20 04 80 	movabs $0x800420d91a,%rax
  800420bad0:	00 00 00 
  800420bad3:	48 c1 e8 10          	shr    $0x10,%rax
  800420bad7:	89 c2                	mov    %eax,%edx
  800420bad9:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bae0:	00 00 00 
  800420bae3:	66 89 90 76 02 00 00 	mov    %dx,0x276(%rax)
  800420baea:	48 b8 1a d9 20 04 80 	movabs $0x800420d91a,%rax
  800420baf1:	00 00 00 
  800420baf4:	48 c1 e8 20          	shr    $0x20,%rax
  800420baf8:	89 c2                	mov    %eax,%edx
  800420bafa:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bb01:	00 00 00 
  800420bb04:	89 90 78 02 00 00    	mov    %edx,0x278(%rax)
  800420bb0a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bb11:	00 00 00 
  800420bb14:	c7 80 7c 02 00 00 00 	movl   $0x0,0x27c(%rax)
  800420bb1b:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 8], 0, GD_KT, &Xirq8, 0);
  800420bb1e:	48 b8 20 d9 20 04 80 	movabs $0x800420d920,%rax
  800420bb25:	00 00 00 
  800420bb28:	89 c2                	mov    %eax,%edx
  800420bb2a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bb31:	00 00 00 
  800420bb34:	66 89 90 80 02 00 00 	mov    %dx,0x280(%rax)
  800420bb3b:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bb42:	00 00 00 
  800420bb45:	66 c7 80 82 02 00 00 	movw   $0x8,0x282(%rax)
  800420bb4c:	08 00 
  800420bb4e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bb55:	00 00 00 
  800420bb58:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420bb5f:	83 e2 f8             	and    $0xfffffff8,%edx
  800420bb62:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420bb68:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bb6f:	00 00 00 
  800420bb72:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420bb79:	83 e2 07             	and    $0x7,%edx
  800420bb7c:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420bb82:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bb89:	00 00 00 
  800420bb8c:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420bb93:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bb96:	83 ca 0e             	or     $0xe,%edx
  800420bb99:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420bb9f:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bba6:	00 00 00 
  800420bba9:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420bbb0:	83 e2 ef             	and    $0xffffffef,%edx
  800420bbb3:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420bbb9:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bbc0:	00 00 00 
  800420bbc3:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420bbca:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bbcd:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420bbd3:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bbda:	00 00 00 
  800420bbdd:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420bbe4:	83 ca 80             	or     $0xffffff80,%edx
  800420bbe7:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420bbed:	48 b8 20 d9 20 04 80 	movabs $0x800420d920,%rax
  800420bbf4:	00 00 00 
  800420bbf7:	48 c1 e8 10          	shr    $0x10,%rax
  800420bbfb:	89 c2                	mov    %eax,%edx
  800420bbfd:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bc04:	00 00 00 
  800420bc07:	66 89 90 86 02 00 00 	mov    %dx,0x286(%rax)
  800420bc0e:	48 b8 20 d9 20 04 80 	movabs $0x800420d920,%rax
  800420bc15:	00 00 00 
  800420bc18:	48 c1 e8 20          	shr    $0x20,%rax
  800420bc1c:	89 c2                	mov    %eax,%edx
  800420bc1e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bc25:	00 00 00 
  800420bc28:	89 90 88 02 00 00    	mov    %edx,0x288(%rax)
  800420bc2e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bc35:	00 00 00 
  800420bc38:	c7 80 8c 02 00 00 00 	movl   $0x0,0x28c(%rax)
  800420bc3f:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 9], 0, GD_KT, &Xirq9, 0);
  800420bc42:	48 b8 26 d9 20 04 80 	movabs $0x800420d926,%rax
  800420bc49:	00 00 00 
  800420bc4c:	89 c2                	mov    %eax,%edx
  800420bc4e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bc55:	00 00 00 
  800420bc58:	66 89 90 90 02 00 00 	mov    %dx,0x290(%rax)
  800420bc5f:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bc66:	00 00 00 
  800420bc69:	66 c7 80 92 02 00 00 	movw   $0x8,0x292(%rax)
  800420bc70:	08 00 
  800420bc72:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bc79:	00 00 00 
  800420bc7c:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420bc83:	83 e2 f8             	and    $0xfffffff8,%edx
  800420bc86:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420bc8c:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bc93:	00 00 00 
  800420bc96:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420bc9d:	83 e2 07             	and    $0x7,%edx
  800420bca0:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420bca6:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bcad:	00 00 00 
  800420bcb0:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420bcb7:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bcba:	83 ca 0e             	or     $0xe,%edx
  800420bcbd:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420bcc3:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bcca:	00 00 00 
  800420bccd:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420bcd4:	83 e2 ef             	and    $0xffffffef,%edx
  800420bcd7:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420bcdd:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bce4:	00 00 00 
  800420bce7:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420bcee:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bcf1:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420bcf7:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bcfe:	00 00 00 
  800420bd01:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420bd08:	83 ca 80             	or     $0xffffff80,%edx
  800420bd0b:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420bd11:	48 b8 26 d9 20 04 80 	movabs $0x800420d926,%rax
  800420bd18:	00 00 00 
  800420bd1b:	48 c1 e8 10          	shr    $0x10,%rax
  800420bd1f:	89 c2                	mov    %eax,%edx
  800420bd21:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bd28:	00 00 00 
  800420bd2b:	66 89 90 96 02 00 00 	mov    %dx,0x296(%rax)
  800420bd32:	48 b8 26 d9 20 04 80 	movabs $0x800420d926,%rax
  800420bd39:	00 00 00 
  800420bd3c:	48 c1 e8 20          	shr    $0x20,%rax
  800420bd40:	89 c2                	mov    %eax,%edx
  800420bd42:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bd49:	00 00 00 
  800420bd4c:	89 90 98 02 00 00    	mov    %edx,0x298(%rax)
  800420bd52:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bd59:	00 00 00 
  800420bd5c:	c7 80 9c 02 00 00 00 	movl   $0x0,0x29c(%rax)
  800420bd63:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 10], 0, GD_KT, &Xirq10, 0);
  800420bd66:	48 b8 2c d9 20 04 80 	movabs $0x800420d92c,%rax
  800420bd6d:	00 00 00 
  800420bd70:	89 c2                	mov    %eax,%edx
  800420bd72:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bd79:	00 00 00 
  800420bd7c:	66 89 90 a0 02 00 00 	mov    %dx,0x2a0(%rax)
  800420bd83:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bd8a:	00 00 00 
  800420bd8d:	66 c7 80 a2 02 00 00 	movw   $0x8,0x2a2(%rax)
  800420bd94:	08 00 
  800420bd96:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bd9d:	00 00 00 
  800420bda0:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420bda7:	83 e2 f8             	and    $0xfffffff8,%edx
  800420bdaa:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420bdb0:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bdb7:	00 00 00 
  800420bdba:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420bdc1:	83 e2 07             	and    $0x7,%edx
  800420bdc4:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420bdca:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bdd1:	00 00 00 
  800420bdd4:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420bddb:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bdde:	83 ca 0e             	or     $0xe,%edx
  800420bde1:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420bde7:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bdee:	00 00 00 
  800420bdf1:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420bdf8:	83 e2 ef             	and    $0xffffffef,%edx
  800420bdfb:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420be01:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420be08:	00 00 00 
  800420be0b:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420be12:	83 e2 9f             	and    $0xffffff9f,%edx
  800420be15:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420be1b:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420be22:	00 00 00 
  800420be25:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420be2c:	83 ca 80             	or     $0xffffff80,%edx
  800420be2f:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420be35:	48 b8 2c d9 20 04 80 	movabs $0x800420d92c,%rax
  800420be3c:	00 00 00 
  800420be3f:	48 c1 e8 10          	shr    $0x10,%rax
  800420be43:	89 c2                	mov    %eax,%edx
  800420be45:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420be4c:	00 00 00 
  800420be4f:	66 89 90 a6 02 00 00 	mov    %dx,0x2a6(%rax)
  800420be56:	48 b8 2c d9 20 04 80 	movabs $0x800420d92c,%rax
  800420be5d:	00 00 00 
  800420be60:	48 c1 e8 20          	shr    $0x20,%rax
  800420be64:	89 c2                	mov    %eax,%edx
  800420be66:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420be6d:	00 00 00 
  800420be70:	89 90 a8 02 00 00    	mov    %edx,0x2a8(%rax)
  800420be76:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420be7d:	00 00 00 
  800420be80:	c7 80 ac 02 00 00 00 	movl   $0x0,0x2ac(%rax)
  800420be87:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 11], 0, GD_KT, &Xirq11, 0);
  800420be8a:	48 b8 32 d9 20 04 80 	movabs $0x800420d932,%rax
  800420be91:	00 00 00 
  800420be94:	89 c2                	mov    %eax,%edx
  800420be96:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420be9d:	00 00 00 
  800420bea0:	66 89 90 b0 02 00 00 	mov    %dx,0x2b0(%rax)
  800420bea7:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420beae:	00 00 00 
  800420beb1:	66 c7 80 b2 02 00 00 	movw   $0x8,0x2b2(%rax)
  800420beb8:	08 00 
  800420beba:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bec1:	00 00 00 
  800420bec4:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420becb:	83 e2 f8             	and    $0xfffffff8,%edx
  800420bece:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420bed4:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bedb:	00 00 00 
  800420bede:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420bee5:	83 e2 07             	and    $0x7,%edx
  800420bee8:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420beee:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bef5:	00 00 00 
  800420bef8:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420beff:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bf02:	83 ca 0e             	or     $0xe,%edx
  800420bf05:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420bf0b:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bf12:	00 00 00 
  800420bf15:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420bf1c:	83 e2 ef             	and    $0xffffffef,%edx
  800420bf1f:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420bf25:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bf2c:	00 00 00 
  800420bf2f:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420bf36:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bf39:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420bf3f:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bf46:	00 00 00 
  800420bf49:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420bf50:	83 ca 80             	or     $0xffffff80,%edx
  800420bf53:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420bf59:	48 b8 32 d9 20 04 80 	movabs $0x800420d932,%rax
  800420bf60:	00 00 00 
  800420bf63:	48 c1 e8 10          	shr    $0x10,%rax
  800420bf67:	89 c2                	mov    %eax,%edx
  800420bf69:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bf70:	00 00 00 
  800420bf73:	66 89 90 b6 02 00 00 	mov    %dx,0x2b6(%rax)
  800420bf7a:	48 b8 32 d9 20 04 80 	movabs $0x800420d932,%rax
  800420bf81:	00 00 00 
  800420bf84:	48 c1 e8 20          	shr    $0x20,%rax
  800420bf88:	89 c2                	mov    %eax,%edx
  800420bf8a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bf91:	00 00 00 
  800420bf94:	89 90 b8 02 00 00    	mov    %edx,0x2b8(%rax)
  800420bf9a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bfa1:	00 00 00 
  800420bfa4:	c7 80 bc 02 00 00 00 	movl   $0x0,0x2bc(%rax)
  800420bfab:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 12], 0, GD_KT, &Xirq12, 0);
  800420bfae:	48 b8 38 d9 20 04 80 	movabs $0x800420d938,%rax
  800420bfb5:	00 00 00 
  800420bfb8:	89 c2                	mov    %eax,%edx
  800420bfba:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bfc1:	00 00 00 
  800420bfc4:	66 89 90 c0 02 00 00 	mov    %dx,0x2c0(%rax)
  800420bfcb:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bfd2:	00 00 00 
  800420bfd5:	66 c7 80 c2 02 00 00 	movw   $0x8,0x2c2(%rax)
  800420bfdc:	08 00 
  800420bfde:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bfe5:	00 00 00 
  800420bfe8:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420bfef:	83 e2 f8             	and    $0xfffffff8,%edx
  800420bff2:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420bff8:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420bfff:	00 00 00 
  800420c002:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420c009:	83 e2 07             	and    $0x7,%edx
  800420c00c:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420c012:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c019:	00 00 00 
  800420c01c:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420c023:	83 e2 f0             	and    $0xfffffff0,%edx
  800420c026:	83 ca 0e             	or     $0xe,%edx
  800420c029:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420c02f:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c036:	00 00 00 
  800420c039:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420c040:	83 e2 ef             	and    $0xffffffef,%edx
  800420c043:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420c049:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c050:	00 00 00 
  800420c053:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420c05a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420c05d:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420c063:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c06a:	00 00 00 
  800420c06d:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420c074:	83 ca 80             	or     $0xffffff80,%edx
  800420c077:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420c07d:	48 b8 38 d9 20 04 80 	movabs $0x800420d938,%rax
  800420c084:	00 00 00 
  800420c087:	48 c1 e8 10          	shr    $0x10,%rax
  800420c08b:	89 c2                	mov    %eax,%edx
  800420c08d:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c094:	00 00 00 
  800420c097:	66 89 90 c6 02 00 00 	mov    %dx,0x2c6(%rax)
  800420c09e:	48 b8 38 d9 20 04 80 	movabs $0x800420d938,%rax
  800420c0a5:	00 00 00 
  800420c0a8:	48 c1 e8 20          	shr    $0x20,%rax
  800420c0ac:	89 c2                	mov    %eax,%edx
  800420c0ae:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c0b5:	00 00 00 
  800420c0b8:	89 90 c8 02 00 00    	mov    %edx,0x2c8(%rax)
  800420c0be:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c0c5:	00 00 00 
  800420c0c8:	c7 80 cc 02 00 00 00 	movl   $0x0,0x2cc(%rax)
  800420c0cf:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 13], 0, GD_KT, &Xirq13, 0);
  800420c0d2:	48 b8 3e d9 20 04 80 	movabs $0x800420d93e,%rax
  800420c0d9:	00 00 00 
  800420c0dc:	89 c2                	mov    %eax,%edx
  800420c0de:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c0e5:	00 00 00 
  800420c0e8:	66 89 90 d0 02 00 00 	mov    %dx,0x2d0(%rax)
  800420c0ef:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c0f6:	00 00 00 
  800420c0f9:	66 c7 80 d2 02 00 00 	movw   $0x8,0x2d2(%rax)
  800420c100:	08 00 
  800420c102:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c109:	00 00 00 
  800420c10c:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420c113:	83 e2 f8             	and    $0xfffffff8,%edx
  800420c116:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420c11c:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c123:	00 00 00 
  800420c126:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420c12d:	83 e2 07             	and    $0x7,%edx
  800420c130:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420c136:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c13d:	00 00 00 
  800420c140:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420c147:	83 e2 f0             	and    $0xfffffff0,%edx
  800420c14a:	83 ca 0e             	or     $0xe,%edx
  800420c14d:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420c153:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c15a:	00 00 00 
  800420c15d:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420c164:	83 e2 ef             	and    $0xffffffef,%edx
  800420c167:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420c16d:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c174:	00 00 00 
  800420c177:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420c17e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420c181:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420c187:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c18e:	00 00 00 
  800420c191:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420c198:	83 ca 80             	or     $0xffffff80,%edx
  800420c19b:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420c1a1:	48 b8 3e d9 20 04 80 	movabs $0x800420d93e,%rax
  800420c1a8:	00 00 00 
  800420c1ab:	48 c1 e8 10          	shr    $0x10,%rax
  800420c1af:	89 c2                	mov    %eax,%edx
  800420c1b1:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c1b8:	00 00 00 
  800420c1bb:	66 89 90 d6 02 00 00 	mov    %dx,0x2d6(%rax)
  800420c1c2:	48 b8 3e d9 20 04 80 	movabs $0x800420d93e,%rax
  800420c1c9:	00 00 00 
  800420c1cc:	48 c1 e8 20          	shr    $0x20,%rax
  800420c1d0:	89 c2                	mov    %eax,%edx
  800420c1d2:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c1d9:	00 00 00 
  800420c1dc:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%rax)
  800420c1e2:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c1e9:	00 00 00 
  800420c1ec:	c7 80 dc 02 00 00 00 	movl   $0x0,0x2dc(%rax)
  800420c1f3:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 14], 0, GD_KT, &Xirq14, 0);
  800420c1f6:	48 b8 44 d9 20 04 80 	movabs $0x800420d944,%rax
  800420c1fd:	00 00 00 
  800420c200:	89 c2                	mov    %eax,%edx
  800420c202:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c209:	00 00 00 
  800420c20c:	66 89 90 e0 02 00 00 	mov    %dx,0x2e0(%rax)
  800420c213:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c21a:	00 00 00 
  800420c21d:	66 c7 80 e2 02 00 00 	movw   $0x8,0x2e2(%rax)
  800420c224:	08 00 
  800420c226:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c22d:	00 00 00 
  800420c230:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420c237:	83 e2 f8             	and    $0xfffffff8,%edx
  800420c23a:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420c240:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c247:	00 00 00 
  800420c24a:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420c251:	83 e2 07             	and    $0x7,%edx
  800420c254:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420c25a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c261:	00 00 00 
  800420c264:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420c26b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420c26e:	83 ca 0e             	or     $0xe,%edx
  800420c271:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420c277:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c27e:	00 00 00 
  800420c281:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420c288:	83 e2 ef             	and    $0xffffffef,%edx
  800420c28b:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420c291:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c298:	00 00 00 
  800420c29b:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420c2a2:	83 e2 9f             	and    $0xffffff9f,%edx
  800420c2a5:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420c2ab:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c2b2:	00 00 00 
  800420c2b5:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420c2bc:	83 ca 80             	or     $0xffffff80,%edx
  800420c2bf:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420c2c5:	48 b8 44 d9 20 04 80 	movabs $0x800420d944,%rax
  800420c2cc:	00 00 00 
  800420c2cf:	48 c1 e8 10          	shr    $0x10,%rax
  800420c2d3:	89 c2                	mov    %eax,%edx
  800420c2d5:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c2dc:	00 00 00 
  800420c2df:	66 89 90 e6 02 00 00 	mov    %dx,0x2e6(%rax)
  800420c2e6:	48 b8 44 d9 20 04 80 	movabs $0x800420d944,%rax
  800420c2ed:	00 00 00 
  800420c2f0:	48 c1 e8 20          	shr    $0x20,%rax
  800420c2f4:	89 c2                	mov    %eax,%edx
  800420c2f6:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c2fd:	00 00 00 
  800420c300:	89 90 e8 02 00 00    	mov    %edx,0x2e8(%rax)
  800420c306:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c30d:	00 00 00 
  800420c310:	c7 80 ec 02 00 00 00 	movl   $0x0,0x2ec(%rax)
  800420c317:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 15], 0, GD_KT, &Xirq15, 0);
  800420c31a:	48 b8 4a d9 20 04 80 	movabs $0x800420d94a,%rax
  800420c321:	00 00 00 
  800420c324:	89 c2                	mov    %eax,%edx
  800420c326:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c32d:	00 00 00 
  800420c330:	66 89 90 f0 02 00 00 	mov    %dx,0x2f0(%rax)
  800420c337:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c33e:	00 00 00 
  800420c341:	66 c7 80 f2 02 00 00 	movw   $0x8,0x2f2(%rax)
  800420c348:	08 00 
  800420c34a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c351:	00 00 00 
  800420c354:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420c35b:	83 e2 f8             	and    $0xfffffff8,%edx
  800420c35e:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420c364:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c36b:	00 00 00 
  800420c36e:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420c375:	83 e2 07             	and    $0x7,%edx
  800420c378:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420c37e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c385:	00 00 00 
  800420c388:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420c38f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420c392:	83 ca 0e             	or     $0xe,%edx
  800420c395:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420c39b:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c3a2:	00 00 00 
  800420c3a5:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420c3ac:	83 e2 ef             	and    $0xffffffef,%edx
  800420c3af:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420c3b5:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c3bc:	00 00 00 
  800420c3bf:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420c3c6:	83 e2 9f             	and    $0xffffff9f,%edx
  800420c3c9:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420c3cf:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c3d6:	00 00 00 
  800420c3d9:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420c3e0:	83 ca 80             	or     $0xffffff80,%edx
  800420c3e3:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420c3e9:	48 b8 4a d9 20 04 80 	movabs $0x800420d94a,%rax
  800420c3f0:	00 00 00 
  800420c3f3:	48 c1 e8 10          	shr    $0x10,%rax
  800420c3f7:	89 c2                	mov    %eax,%edx
  800420c3f9:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c400:	00 00 00 
  800420c403:	66 89 90 f6 02 00 00 	mov    %dx,0x2f6(%rax)
  800420c40a:	48 b8 4a d9 20 04 80 	movabs $0x800420d94a,%rax
  800420c411:	00 00 00 
  800420c414:	48 c1 e8 20          	shr    $0x20,%rax
  800420c418:	89 c2                	mov    %eax,%edx
  800420c41a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c421:	00 00 00 
  800420c424:	89 90 f8 02 00 00    	mov    %edx,0x2f8(%rax)
  800420c42a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c431:	00 00 00 
  800420c434:	c7 80 fc 02 00 00 00 	movl   $0x0,0x2fc(%rax)
  800420c43b:	00 00 00 


	// Use DPL=3 here because system calls are explicitly invoked
	// by the user process (with "int $T_SYSCALL").
	SETGATE(idt[T_SYSCALL], 0, GD_KT, &Xsyscall, 3);
  800420c43e:	48 b8 50 d9 20 04 80 	movabs $0x800420d950,%rax
  800420c445:	00 00 00 
  800420c448:	89 c2                	mov    %eax,%edx
  800420c44a:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c451:	00 00 00 
  800420c454:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  800420c45b:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c462:	00 00 00 
  800420c465:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  800420c46c:	08 00 
  800420c46e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c475:	00 00 00 
  800420c478:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420c47f:	83 e2 f8             	and    $0xfffffff8,%edx
  800420c482:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420c488:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c48f:	00 00 00 
  800420c492:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420c499:	83 e2 07             	and    $0x7,%edx
  800420c49c:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420c4a2:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c4a9:	00 00 00 
  800420c4ac:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420c4b3:	83 e2 f0             	and    $0xfffffff0,%edx
  800420c4b6:	83 ca 0e             	or     $0xe,%edx
  800420c4b9:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420c4bf:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c4c6:	00 00 00 
  800420c4c9:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420c4d0:	83 e2 ef             	and    $0xffffffef,%edx
  800420c4d3:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420c4d9:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c4e0:	00 00 00 
  800420c4e3:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420c4ea:	83 ca 60             	or     $0x60,%edx
  800420c4ed:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420c4f3:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c4fa:	00 00 00 
  800420c4fd:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420c504:	83 ca 80             	or     $0xffffff80,%edx
  800420c507:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420c50d:	48 b8 50 d9 20 04 80 	movabs $0x800420d950,%rax
  800420c514:	00 00 00 
  800420c517:	48 c1 e8 10          	shr    $0x10,%rax
  800420c51b:	89 c2                	mov    %eax,%edx
  800420c51d:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c524:	00 00 00 
  800420c527:	66 89 90 06 03 00 00 	mov    %dx,0x306(%rax)
  800420c52e:	48 b8 50 d9 20 04 80 	movabs $0x800420d950,%rax
  800420c535:	00 00 00 
  800420c538:	48 c1 e8 20          	shr    $0x20,%rax
  800420c53c:	89 c2                	mov    %eax,%edx
  800420c53e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c545:	00 00 00 
  800420c548:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  800420c54e:	48 b8 80 d2 4d 04 80 	movabs $0x80044dd280,%rax
  800420c555:	00 00 00 
  800420c558:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  800420c55f:	00 00 00 

	idt_pd.pd_lim = sizeof(idt)-1;
  800420c562:	48 b8 80 e2 4d 04 80 	movabs $0x80044de280,%rax
  800420c569:	00 00 00 
  800420c56c:	66 c7 00 ff 0f       	movw   $0xfff,(%rax)
	idt_pd.pd_base = (uint64_t)idt;
  800420c571:	48 ba 80 d2 4d 04 80 	movabs $0x80044dd280,%rdx
  800420c578:	00 00 00 
  800420c57b:	48 b8 80 e2 4d 04 80 	movabs $0x80044de280,%rax
  800420c582:	00 00 00 
  800420c585:	48 89 50 02          	mov    %rdx,0x2(%rax)
	// Per-CPU setup
	trap_init_percpu();
  800420c589:	48 b8 98 c5 20 04 80 	movabs $0x800420c598,%rax
  800420c590:	00 00 00 
  800420c593:	ff d0                	callq  *%rax
}
  800420c595:	90                   	nop
  800420c596:	c9                   	leaveq 
  800420c597:	c3                   	retq   

000000800420c598 <trap_init_percpu>:

// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
  800420c598:	55                   	push   %rbp
  800420c599:	48 89 e5             	mov    %rsp,%rbp
  800420c59c:	53                   	push   %rbx
  800420c59d:	48 83 ec 18          	sub    $0x18,%rsp
	// wrong, you may not get a fault until you try to return from
	// user space on that CPU.
	//
	// LAB 4: Your code here:

	int gd_tss = (GD_TSS0 >> 3) + cpunum()*2;
  800420c5a1:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c5a8:	00 00 00 
  800420c5ab:	ff d0                	callq  *%rax
  800420c5ad:	01 c0                	add    %eax,%eax
  800420c5af:	83 c0 05             	add    $0x5,%eax
  800420c5b2:	89 45 ec             	mov    %eax,-0x14(%rbp)

	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP 
  800420c5b5:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c5bc:	00 00 00 
  800420c5bf:	ff d0                	callq  *%rax
  800420c5c1:	89 c3                	mov    %eax,%ebx
		- (KSTKSIZE + KSTKGAP) * cpunum();
  800420c5c3:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c5ca:	00 00 00 
  800420c5cd:	ff d0                	callq  *%rax
  800420c5cf:	89 c2                	mov    %eax,%edx
  800420c5d1:	89 d0                	mov    %edx,%eax
  800420c5d3:	01 c0                	add    %eax,%eax
  800420c5d5:	01 d0                	add    %edx,%eax
  800420c5d7:	c1 e0 0f             	shl    $0xf,%eax
  800420c5da:	48 98                	cltq   
  800420c5dc:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420c5e3:	00 00 00 
  800420c5e6:	48 29 c2             	sub    %rax,%rdx
  800420c5e9:	48 89 d0             	mov    %rdx,%rax
	//
	// LAB 4: Your code here:

	int gd_tss = (GD_TSS0 >> 3) + cpunum()*2;

	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP 
  800420c5ec:	48 89 c6             	mov    %rax,%rsi
  800420c5ef:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420c5f6:	00 00 00 
  800420c5f9:	48 63 c3             	movslq %ebx,%rax
  800420c5fc:	48 c1 e0 03          	shl    $0x3,%rax
  800420c600:	48 89 c1             	mov    %rax,%rcx
  800420c603:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c607:	48 01 c8             	add    %rcx,%rax
  800420c60a:	48 01 d0             	add    %rdx,%rax
  800420c60d:	48 83 c0 10          	add    $0x10,%rax
  800420c611:	48 89 70 04          	mov    %rsi,0x4(%rax)
		- (KSTKSIZE + KSTKGAP) * cpunum();

	SETTSS((struct SystemSegdesc64 *)((gdt_pd>>16)+40+cpunum()*16),STS_T64A, (uint64_t) (&thiscpu->cpu_ts),sizeof(struct Taskstate), 0);
  800420c615:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420c61c:	00 00 00 
  800420c61f:	48 8b 00             	mov    (%rax),%rax
  800420c622:	48 c1 f8 10          	sar    $0x10,%rax
  800420c626:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c62a:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c631:	00 00 00 
  800420c634:	ff d0                	callq  *%rax
  800420c636:	c1 e0 04             	shl    $0x4,%eax
  800420c639:	48 98                	cltq   
  800420c63b:	48 01 d8             	add    %rbx,%rax
  800420c63e:	66 c7 00 68 00       	movw   $0x68,(%rax)
  800420c643:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420c64a:	00 00 00 
  800420c64d:	48 8b 00             	mov    (%rax),%rax
  800420c650:	48 c1 f8 10          	sar    $0x10,%rax
  800420c654:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c658:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c65f:	00 00 00 
  800420c662:	ff d0                	callq  *%rax
  800420c664:	c1 e0 04             	shl    $0x4,%eax
  800420c667:	48 98                	cltq   
  800420c669:	48 01 d8             	add    %rbx,%rax
  800420c66c:	48 89 c3             	mov    %rax,%rbx
  800420c66f:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c676:	00 00 00 
  800420c679:	ff d0                	callq  *%rax
  800420c67b:	48 98                	cltq   
  800420c67d:	48 c1 e0 03          	shl    $0x3,%rax
  800420c681:	48 89 c2             	mov    %rax,%rdx
  800420c684:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c688:	48 01 d0             	add    %rdx,%rax
  800420c68b:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420c68f:	48 b8 20 e0 6d 04 80 	movabs $0x80046de020,%rax
  800420c696:	00 00 00 
  800420c699:	48 01 d0             	add    %rdx,%rax
  800420c69c:	66 89 43 02          	mov    %ax,0x2(%rbx)
  800420c6a0:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420c6a7:	00 00 00 
  800420c6aa:	48 8b 00             	mov    (%rax),%rax
  800420c6ad:	48 c1 f8 10          	sar    $0x10,%rax
  800420c6b1:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c6b5:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c6bc:	00 00 00 
  800420c6bf:	ff d0                	callq  *%rax
  800420c6c1:	c1 e0 04             	shl    $0x4,%eax
  800420c6c4:	48 98                	cltq   
  800420c6c6:	48 01 d8             	add    %rbx,%rax
  800420c6c9:	48 89 c3             	mov    %rax,%rbx
  800420c6cc:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c6d3:	00 00 00 
  800420c6d6:	ff d0                	callq  *%rax
  800420c6d8:	48 98                	cltq   
  800420c6da:	48 c1 e0 03          	shl    $0x3,%rax
  800420c6de:	48 89 c2             	mov    %rax,%rdx
  800420c6e1:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c6e5:	48 01 d0             	add    %rdx,%rax
  800420c6e8:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420c6ec:	48 b8 20 e0 6d 04 80 	movabs $0x80046de020,%rax
  800420c6f3:	00 00 00 
  800420c6f6:	48 01 d0             	add    %rdx,%rax
  800420c6f9:	48 c1 e8 10          	shr    $0x10,%rax
  800420c6fd:	88 43 04             	mov    %al,0x4(%rbx)
  800420c700:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420c707:	00 00 00 
  800420c70a:	48 8b 00             	mov    (%rax),%rax
  800420c70d:	48 c1 f8 10          	sar    $0x10,%rax
  800420c711:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c715:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c71c:	00 00 00 
  800420c71f:	ff d0                	callq  *%rax
  800420c721:	c1 e0 04             	shl    $0x4,%eax
  800420c724:	48 98                	cltq   
  800420c726:	48 01 d8             	add    %rbx,%rax
  800420c729:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420c72d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420c730:	83 ca 09             	or     $0x9,%edx
  800420c733:	88 50 05             	mov    %dl,0x5(%rax)
  800420c736:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420c73d:	00 00 00 
  800420c740:	48 8b 00             	mov    (%rax),%rax
  800420c743:	48 c1 f8 10          	sar    $0x10,%rax
  800420c747:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c74b:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c752:	00 00 00 
  800420c755:	ff d0                	callq  *%rax
  800420c757:	c1 e0 04             	shl    $0x4,%eax
  800420c75a:	48 98                	cltq   
  800420c75c:	48 01 d8             	add    %rbx,%rax
  800420c75f:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420c763:	83 e2 ef             	and    $0xffffffef,%edx
  800420c766:	88 50 05             	mov    %dl,0x5(%rax)
  800420c769:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420c770:	00 00 00 
  800420c773:	48 8b 00             	mov    (%rax),%rax
  800420c776:	48 c1 f8 10          	sar    $0x10,%rax
  800420c77a:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c77e:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c785:	00 00 00 
  800420c788:	ff d0                	callq  *%rax
  800420c78a:	c1 e0 04             	shl    $0x4,%eax
  800420c78d:	48 98                	cltq   
  800420c78f:	48 01 d8             	add    %rbx,%rax
  800420c792:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420c796:	83 e2 9f             	and    $0xffffff9f,%edx
  800420c799:	88 50 05             	mov    %dl,0x5(%rax)
  800420c79c:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420c7a3:	00 00 00 
  800420c7a6:	48 8b 00             	mov    (%rax),%rax
  800420c7a9:	48 c1 f8 10          	sar    $0x10,%rax
  800420c7ad:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c7b1:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c7b8:	00 00 00 
  800420c7bb:	ff d0                	callq  *%rax
  800420c7bd:	c1 e0 04             	shl    $0x4,%eax
  800420c7c0:	48 98                	cltq   
  800420c7c2:	48 01 d8             	add    %rbx,%rax
  800420c7c5:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420c7c9:	83 ca 80             	or     $0xffffff80,%edx
  800420c7cc:	88 50 05             	mov    %dl,0x5(%rax)
  800420c7cf:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420c7d6:	00 00 00 
  800420c7d9:	48 8b 00             	mov    (%rax),%rax
  800420c7dc:	48 c1 f8 10          	sar    $0x10,%rax
  800420c7e0:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c7e4:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c7eb:	00 00 00 
  800420c7ee:	ff d0                	callq  *%rax
  800420c7f0:	c1 e0 04             	shl    $0x4,%eax
  800420c7f3:	48 98                	cltq   
  800420c7f5:	48 01 d8             	add    %rbx,%rax
  800420c7f8:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c7fc:	83 e2 f0             	and    $0xfffffff0,%edx
  800420c7ff:	88 50 06             	mov    %dl,0x6(%rax)
  800420c802:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420c809:	00 00 00 
  800420c80c:	48 8b 00             	mov    (%rax),%rax
  800420c80f:	48 c1 f8 10          	sar    $0x10,%rax
  800420c813:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c817:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c81e:	00 00 00 
  800420c821:	ff d0                	callq  *%rax
  800420c823:	c1 e0 04             	shl    $0x4,%eax
  800420c826:	48 98                	cltq   
  800420c828:	48 01 d8             	add    %rbx,%rax
  800420c82b:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c82f:	83 e2 ef             	and    $0xffffffef,%edx
  800420c832:	88 50 06             	mov    %dl,0x6(%rax)
  800420c835:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420c83c:	00 00 00 
  800420c83f:	48 8b 00             	mov    (%rax),%rax
  800420c842:	48 c1 f8 10          	sar    $0x10,%rax
  800420c846:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c84a:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c851:	00 00 00 
  800420c854:	ff d0                	callq  *%rax
  800420c856:	c1 e0 04             	shl    $0x4,%eax
  800420c859:	48 98                	cltq   
  800420c85b:	48 01 d8             	add    %rbx,%rax
  800420c85e:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c862:	83 e2 9f             	and    $0xffffff9f,%edx
  800420c865:	88 50 06             	mov    %dl,0x6(%rax)
  800420c868:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420c86f:	00 00 00 
  800420c872:	48 8b 00             	mov    (%rax),%rax
  800420c875:	48 c1 f8 10          	sar    $0x10,%rax
  800420c879:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c87d:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c884:	00 00 00 
  800420c887:	ff d0                	callq  *%rax
  800420c889:	c1 e0 04             	shl    $0x4,%eax
  800420c88c:	48 98                	cltq   
  800420c88e:	48 01 d8             	add    %rbx,%rax
  800420c891:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c895:	83 e2 7f             	and    $0x7f,%edx
  800420c898:	88 50 06             	mov    %dl,0x6(%rax)
  800420c89b:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420c8a2:	00 00 00 
  800420c8a5:	48 8b 00             	mov    (%rax),%rax
  800420c8a8:	48 c1 f8 10          	sar    $0x10,%rax
  800420c8ac:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c8b0:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c8b7:	00 00 00 
  800420c8ba:	ff d0                	callq  *%rax
  800420c8bc:	c1 e0 04             	shl    $0x4,%eax
  800420c8bf:	48 98                	cltq   
  800420c8c1:	48 01 d8             	add    %rbx,%rax
  800420c8c4:	48 89 c3             	mov    %rax,%rbx
  800420c8c7:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c8ce:	00 00 00 
  800420c8d1:	ff d0                	callq  *%rax
  800420c8d3:	48 98                	cltq   
  800420c8d5:	48 c1 e0 03          	shl    $0x3,%rax
  800420c8d9:	48 89 c2             	mov    %rax,%rdx
  800420c8dc:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c8e0:	48 01 d0             	add    %rdx,%rax
  800420c8e3:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420c8e7:	48 b8 20 e0 6d 04 80 	movabs $0x80046de020,%rax
  800420c8ee:	00 00 00 
  800420c8f1:	48 01 d0             	add    %rdx,%rax
  800420c8f4:	48 c1 e8 18          	shr    $0x18,%rax
  800420c8f8:	88 43 07             	mov    %al,0x7(%rbx)
  800420c8fb:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420c902:	00 00 00 
  800420c905:	48 8b 00             	mov    (%rax),%rax
  800420c908:	48 c1 f8 10          	sar    $0x10,%rax
  800420c90c:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c910:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c917:	00 00 00 
  800420c91a:	ff d0                	callq  *%rax
  800420c91c:	c1 e0 04             	shl    $0x4,%eax
  800420c91f:	48 98                	cltq   
  800420c921:	48 01 d8             	add    %rbx,%rax
  800420c924:	48 89 c3             	mov    %rax,%rbx
  800420c927:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c92e:	00 00 00 
  800420c931:	ff d0                	callq  *%rax
  800420c933:	48 98                	cltq   
  800420c935:	48 c1 e0 03          	shl    $0x3,%rax
  800420c939:	48 89 c2             	mov    %rax,%rdx
  800420c93c:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c940:	48 01 d0             	add    %rdx,%rax
  800420c943:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420c947:	48 b8 20 e0 6d 04 80 	movabs $0x80046de020,%rax
  800420c94e:	00 00 00 
  800420c951:	48 01 d0             	add    %rdx,%rax
  800420c954:	48 c1 e8 20          	shr    $0x20,%rax
  800420c958:	89 43 08             	mov    %eax,0x8(%rbx)
  800420c95b:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420c962:	00 00 00 
  800420c965:	48 8b 00             	mov    (%rax),%rax
  800420c968:	48 c1 f8 10          	sar    $0x10,%rax
  800420c96c:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c970:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c977:	00 00 00 
  800420c97a:	ff d0                	callq  *%rax
  800420c97c:	c1 e0 04             	shl    $0x4,%eax
  800420c97f:	48 98                	cltq   
  800420c981:	48 01 d8             	add    %rbx,%rax
  800420c984:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
  800420c988:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420c98f:	00 00 00 
  800420c992:	48 8b 00             	mov    (%rax),%rax
  800420c995:	48 c1 f8 10          	sar    $0x10,%rax
  800420c999:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c99d:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c9a4:	00 00 00 
  800420c9a7:	ff d0                	callq  *%rax
  800420c9a9:	c1 e0 04             	shl    $0x4,%eax
  800420c9ac:	48 98                	cltq   
  800420c9ae:	48 01 d8             	add    %rbx,%rax
  800420c9b1:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
  800420c9b5:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420c9bc:	00 00 00 
  800420c9bf:	48 8b 00             	mov    (%rax),%rax
  800420c9c2:	48 c1 f8 10          	sar    $0x10,%rax
  800420c9c6:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c9ca:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420c9d1:	00 00 00 
  800420c9d4:	ff d0                	callq  *%rax
  800420c9d6:	c1 e0 04             	shl    $0x4,%eax
  800420c9d9:	48 98                	cltq   
  800420c9db:	48 01 d8             	add    %rbx,%rax
  800420c9de:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)

	// Load the TSS
	ltr(gd_tss << 3);
  800420c9e4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c9e7:	c1 e0 03             	shl    $0x3,%eax
  800420c9ea:	0f b7 c0             	movzwl %ax,%eax
  800420c9ed:	66 89 45 ea          	mov    %ax,-0x16(%rbp)
	__asm __volatile("lgdt (%0)" : : "r" (p));
}
static __inline void
ltr(uint16_t sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
  800420c9f1:	0f b7 45 ea          	movzwl -0x16(%rbp),%eax
  800420c9f5:	0f 00 d8             	ltr    %ax
  800420c9f8:	48 b8 80 e2 4d 04 80 	movabs $0x80044de280,%rax
  800420c9ff:	00 00 00 
  800420ca02:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}  

static __inline void
lidt(void *p)
{
	__asm __volatile("lidt (%0)" : : "r" (p));
  800420ca06:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ca0a:	0f 01 18             	lidt   (%rax)


	// Load the IDT
	lidt(&idt_pd);
}
  800420ca0d:	90                   	nop
  800420ca0e:	48 83 c4 18          	add    $0x18,%rsp
  800420ca12:	5b                   	pop    %rbx
  800420ca13:	5d                   	pop    %rbp
  800420ca14:	c3                   	retq   

000000800420ca15 <print_trapframe>:

void
print_trapframe(struct Trapframe *tf)
{
  800420ca15:	55                   	push   %rbp
  800420ca16:	48 89 e5             	mov    %rsp,%rbp
  800420ca19:	48 83 ec 20          	sub    $0x20,%rsp
  800420ca1d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
  800420ca21:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420ca28:	00 00 00 
  800420ca2b:	ff d0                	callq  *%rax
  800420ca2d:	89 c2                	mov    %eax,%edx
  800420ca2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca33:	48 89 c6             	mov    %rax,%rsi
  800420ca36:	48 bf 2e 03 22 04 80 	movabs $0x800422032e,%rdi
  800420ca3d:	00 00 00 
  800420ca40:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ca45:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800420ca4c:	00 00 00 
  800420ca4f:	ff d1                	callq  *%rcx

	print_regs(&tf->tf_regs);
  800420ca51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca55:	48 89 c7             	mov    %rax,%rdi
  800420ca58:	48 b8 27 cd 20 04 80 	movabs $0x800420cd27,%rax
  800420ca5f:	00 00 00 
  800420ca62:	ff d0                	callq  *%rax
	cprintf("  es   0x----%04x\n", tf->tf_es);
  800420ca64:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca68:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800420ca6c:	0f b7 c0             	movzwl %ax,%eax
  800420ca6f:	89 c6                	mov    %eax,%esi
  800420ca71:	48 bf 4c 03 22 04 80 	movabs $0x800422034c,%rdi
  800420ca78:	00 00 00 
  800420ca7b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ca80:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420ca87:	00 00 00 
  800420ca8a:	ff d2                	callq  *%rdx
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
  800420ca8c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca90:	0f b7 80 80 00 00 00 	movzwl 0x80(%rax),%eax
  800420ca97:	0f b7 c0             	movzwl %ax,%eax
  800420ca9a:	89 c6                	mov    %eax,%esi
  800420ca9c:	48 bf 5f 03 22 04 80 	movabs $0x800422035f,%rdi
  800420caa3:	00 00 00 
  800420caa6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420caab:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420cab2:	00 00 00 
  800420cab5:	ff d2                	callq  *%rdx
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
  800420cab7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cabb:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420cac2:	89 c7                	mov    %eax,%edi
  800420cac4:	48 b8 23 9e 20 04 80 	movabs $0x8004209e23,%rax
  800420cacb:	00 00 00 
  800420cace:	ff d0                	callq  *%rax
  800420cad0:	48 89 c2             	mov    %rax,%rdx
  800420cad3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cad7:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420cade:	48 89 c6             	mov    %rax,%rsi
  800420cae1:	48 bf 72 03 22 04 80 	movabs $0x8004220372,%rdi
  800420cae8:	00 00 00 
  800420caeb:	b8 00 00 00 00       	mov    $0x0,%eax
  800420caf0:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800420caf7:	00 00 00 
  800420cafa:	ff d1                	callq  *%rcx
	// If this trap was a page fault that just happened
	// (so %cr2 is meaningful), print the faulting linear address.
	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  800420cafc:	48 b8 90 e2 4d 04 80 	movabs $0x80044de290,%rax
  800420cb03:	00 00 00 
  800420cb06:	48 8b 00             	mov    (%rax),%rax
  800420cb09:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420cb0d:	75 3a                	jne    800420cb49 <print_trapframe+0x134>
  800420cb0f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cb13:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420cb1a:	48 83 f8 0e          	cmp    $0xe,%rax
  800420cb1e:	75 29                	jne    800420cb49 <print_trapframe+0x134>

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420cb20:	0f 20 d0             	mov    %cr2,%rax
  800420cb23:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return val;
  800420cb27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
		cprintf("  cr2  0x%08x\n", rcr2());
  800420cb2b:	48 89 c6             	mov    %rax,%rsi
  800420cb2e:	48 bf 84 03 22 04 80 	movabs $0x8004220384,%rdi
  800420cb35:	00 00 00 
  800420cb38:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cb3d:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420cb44:	00 00 00 
  800420cb47:	ff d2                	callq  *%rdx
	cprintf("  err  0x%08x", tf->tf_err);
  800420cb49:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cb4d:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420cb54:	48 89 c6             	mov    %rax,%rsi
  800420cb57:	48 bf 93 03 22 04 80 	movabs $0x8004220393,%rdi
  800420cb5e:	00 00 00 
  800420cb61:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cb66:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420cb6d:	00 00 00 
  800420cb70:	ff d2                	callq  *%rdx
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
  800420cb72:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cb76:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420cb7d:	48 83 f8 0e          	cmp    $0xe,%rax
  800420cb81:	0f 85 9c 00 00 00    	jne    800420cc23 <print_trapframe+0x20e>
		cprintf(" [%s, %s, %s]\n",
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
  800420cb87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cb8b:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420cb92:	83 e0 01             	and    $0x1,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420cb95:	48 85 c0             	test   %rax,%rax
  800420cb98:	74 0c                	je     800420cba6 <print_trapframe+0x191>
  800420cb9a:	48 b9 a1 03 22 04 80 	movabs $0x80042203a1,%rcx
  800420cba1:	00 00 00 
  800420cba4:	eb 0a                	jmp    800420cbb0 <print_trapframe+0x19b>
  800420cba6:	48 b9 ac 03 22 04 80 	movabs $0x80042203ac,%rcx
  800420cbad:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
  800420cbb0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cbb4:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420cbbb:	83 e0 02             	and    $0x2,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420cbbe:	48 85 c0             	test   %rax,%rax
  800420cbc1:	74 0c                	je     800420cbcf <print_trapframe+0x1ba>
  800420cbc3:	48 ba b8 03 22 04 80 	movabs $0x80042203b8,%rdx
  800420cbca:	00 00 00 
  800420cbcd:	eb 0a                	jmp    800420cbd9 <print_trapframe+0x1c4>
  800420cbcf:	48 ba be 03 22 04 80 	movabs $0x80042203be,%rdx
  800420cbd6:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
  800420cbd9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cbdd:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420cbe4:	83 e0 04             	and    $0x4,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420cbe7:	48 85 c0             	test   %rax,%rax
  800420cbea:	74 0c                	je     800420cbf8 <print_trapframe+0x1e3>
  800420cbec:	48 b8 c3 03 22 04 80 	movabs $0x80042203c3,%rax
  800420cbf3:	00 00 00 
  800420cbf6:	eb 0a                	jmp    800420cc02 <print_trapframe+0x1ed>
  800420cbf8:	48 b8 c8 03 22 04 80 	movabs $0x80042203c8,%rax
  800420cbff:	00 00 00 
  800420cc02:	48 89 c6             	mov    %rax,%rsi
  800420cc05:	48 bf cf 03 22 04 80 	movabs $0x80042203cf,%rdi
  800420cc0c:	00 00 00 
  800420cc0f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cc14:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800420cc1b:	00 00 00 
  800420cc1e:	41 ff d0             	callq  *%r8
  800420cc21:	eb 1b                	jmp    800420cc3e <print_trapframe+0x229>
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
	else
		cprintf("\n");
  800420cc23:	48 bf de 03 22 04 80 	movabs $0x80042203de,%rdi
  800420cc2a:	00 00 00 
  800420cc2d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cc32:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420cc39:	00 00 00 
  800420cc3c:	ff d2                	callq  *%rdx
	cprintf("  rip  0x%08x\n", tf->tf_rip);
  800420cc3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cc42:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800420cc49:	48 89 c6             	mov    %rax,%rsi
  800420cc4c:	48 bf e0 03 22 04 80 	movabs $0x80042203e0,%rdi
  800420cc53:	00 00 00 
  800420cc56:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cc5b:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420cc62:	00 00 00 
  800420cc65:	ff d2                	callq  *%rdx
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
  800420cc67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cc6b:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420cc72:	0f b7 c0             	movzwl %ax,%eax
  800420cc75:	89 c6                	mov    %eax,%esi
  800420cc77:	48 bf ef 03 22 04 80 	movabs $0x80042203ef,%rdi
  800420cc7e:	00 00 00 
  800420cc81:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cc86:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420cc8d:	00 00 00 
  800420cc90:	ff d2                	callq  *%rdx
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
  800420cc92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cc96:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420cc9d:	48 89 c6             	mov    %rax,%rsi
  800420cca0:	48 bf 02 04 22 04 80 	movabs $0x8004220402,%rdi
  800420cca7:	00 00 00 
  800420ccaa:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ccaf:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420ccb6:	00 00 00 
  800420ccb9:	ff d2                	callq  *%rdx
	if ((tf->tf_cs & 3) != 0) {
  800420ccbb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ccbf:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420ccc6:	0f b7 c0             	movzwl %ax,%eax
  800420ccc9:	83 e0 03             	and    $0x3,%eax
  800420cccc:	85 c0                	test   %eax,%eax
  800420ccce:	74 54                	je     800420cd24 <print_trapframe+0x30f>
		cprintf("  rsp  0x%08x\n", tf->tf_rsp);
  800420ccd0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ccd4:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420ccdb:	48 89 c6             	mov    %rax,%rsi
  800420ccde:	48 bf 11 04 22 04 80 	movabs $0x8004220411,%rdi
  800420cce5:	00 00 00 
  800420cce8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cced:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420ccf4:	00 00 00 
  800420ccf7:	ff d2                	callq  *%rdx
		cprintf("  ss   0x----%04x\n", tf->tf_ss);
  800420ccf9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ccfd:	0f b7 80 b8 00 00 00 	movzwl 0xb8(%rax),%eax
  800420cd04:	0f b7 c0             	movzwl %ax,%eax
  800420cd07:	89 c6                	mov    %eax,%esi
  800420cd09:	48 bf 20 04 22 04 80 	movabs $0x8004220420,%rdi
  800420cd10:	00 00 00 
  800420cd13:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cd18:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420cd1f:	00 00 00 
  800420cd22:	ff d2                	callq  *%rdx
	}
	//vmcs_dump_cpu();
}
  800420cd24:	90                   	nop
  800420cd25:	c9                   	leaveq 
  800420cd26:	c3                   	retq   

000000800420cd27 <print_regs>:

void
print_regs(struct PushRegs *regs)
{
  800420cd27:	55                   	push   %rbp
  800420cd28:	48 89 e5             	mov    %rsp,%rbp
  800420cd2b:	48 83 ec 10          	sub    $0x10,%rsp
  800420cd2f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	cprintf("  r15  0x%08x\n", regs->reg_r15);
  800420cd33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cd37:	48 8b 00             	mov    (%rax),%rax
  800420cd3a:	48 89 c6             	mov    %rax,%rsi
  800420cd3d:	48 bf 33 04 22 04 80 	movabs $0x8004220433,%rdi
  800420cd44:	00 00 00 
  800420cd47:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cd4c:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420cd53:	00 00 00 
  800420cd56:	ff d2                	callq  *%rdx
	cprintf("  r14  0x%08x\n", regs->reg_r14);
  800420cd58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cd5c:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420cd60:	48 89 c6             	mov    %rax,%rsi
  800420cd63:	48 bf 42 04 22 04 80 	movabs $0x8004220442,%rdi
  800420cd6a:	00 00 00 
  800420cd6d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cd72:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420cd79:	00 00 00 
  800420cd7c:	ff d2                	callq  *%rdx
	cprintf("  r13  0x%08x\n", regs->reg_r13);
  800420cd7e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cd82:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420cd86:	48 89 c6             	mov    %rax,%rsi
  800420cd89:	48 bf 51 04 22 04 80 	movabs $0x8004220451,%rdi
  800420cd90:	00 00 00 
  800420cd93:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cd98:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420cd9f:	00 00 00 
  800420cda2:	ff d2                	callq  *%rdx
	cprintf("  r12  0x%08x\n", regs->reg_r12);
  800420cda4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cda8:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420cdac:	48 89 c6             	mov    %rax,%rsi
  800420cdaf:	48 bf 60 04 22 04 80 	movabs $0x8004220460,%rdi
  800420cdb6:	00 00 00 
  800420cdb9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cdbe:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420cdc5:	00 00 00 
  800420cdc8:	ff d2                	callq  *%rdx
	cprintf("  r11  0x%08x\n", regs->reg_r11);
  800420cdca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cdce:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420cdd2:	48 89 c6             	mov    %rax,%rsi
  800420cdd5:	48 bf 6f 04 22 04 80 	movabs $0x800422046f,%rdi
  800420cddc:	00 00 00 
  800420cddf:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cde4:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420cdeb:	00 00 00 
  800420cdee:	ff d2                	callq  *%rdx
	cprintf("  r10  0x%08x\n", regs->reg_r10);
  800420cdf0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cdf4:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420cdf8:	48 89 c6             	mov    %rax,%rsi
  800420cdfb:	48 bf 7e 04 22 04 80 	movabs $0x800422047e,%rdi
  800420ce02:	00 00 00 
  800420ce05:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ce0a:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420ce11:	00 00 00 
  800420ce14:	ff d2                	callq  *%rdx
	cprintf("  r9  0x%08x\n", regs->reg_r9);
  800420ce16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ce1a:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420ce1e:	48 89 c6             	mov    %rax,%rsi
  800420ce21:	48 bf 8d 04 22 04 80 	movabs $0x800422048d,%rdi
  800420ce28:	00 00 00 
  800420ce2b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ce30:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420ce37:	00 00 00 
  800420ce3a:	ff d2                	callq  *%rdx
	cprintf("  r8  0x%08x\n", regs->reg_r8);
  800420ce3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ce40:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420ce44:	48 89 c6             	mov    %rax,%rsi
  800420ce47:	48 bf 9b 04 22 04 80 	movabs $0x800422049b,%rdi
  800420ce4e:	00 00 00 
  800420ce51:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ce56:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420ce5d:	00 00 00 
  800420ce60:	ff d2                	callq  *%rdx
	cprintf("  rdi  0x%08x\n", regs->reg_rdi);
  800420ce62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ce66:	48 8b 40 48          	mov    0x48(%rax),%rax
  800420ce6a:	48 89 c6             	mov    %rax,%rsi
  800420ce6d:	48 bf a9 04 22 04 80 	movabs $0x80042204a9,%rdi
  800420ce74:	00 00 00 
  800420ce77:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ce7c:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420ce83:	00 00 00 
  800420ce86:	ff d2                	callq  *%rdx
	cprintf("  rsi  0x%08x\n", regs->reg_rsi);
  800420ce88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ce8c:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420ce90:	48 89 c6             	mov    %rax,%rsi
  800420ce93:	48 bf b8 04 22 04 80 	movabs $0x80042204b8,%rdi
  800420ce9a:	00 00 00 
  800420ce9d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cea2:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420cea9:	00 00 00 
  800420ceac:	ff d2                	callq  *%rdx
	cprintf("  rbp  0x%08x\n", regs->reg_rbp);
  800420ceae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ceb2:	48 8b 40 50          	mov    0x50(%rax),%rax
  800420ceb6:	48 89 c6             	mov    %rax,%rsi
  800420ceb9:	48 bf c7 04 22 04 80 	movabs $0x80042204c7,%rdi
  800420cec0:	00 00 00 
  800420cec3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cec8:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420cecf:	00 00 00 
  800420ced2:	ff d2                	callq  *%rdx
	cprintf("  rbx  0x%08x\n", regs->reg_rbx);
  800420ced4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ced8:	48 8b 40 68          	mov    0x68(%rax),%rax
  800420cedc:	48 89 c6             	mov    %rax,%rsi
  800420cedf:	48 bf d6 04 22 04 80 	movabs $0x80042204d6,%rdi
  800420cee6:	00 00 00 
  800420cee9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ceee:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420cef5:	00 00 00 
  800420cef8:	ff d2                	callq  *%rdx
	cprintf("  rdx  0x%08x\n", regs->reg_rdx);
  800420cefa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cefe:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420cf02:	48 89 c6             	mov    %rax,%rsi
  800420cf05:	48 bf e5 04 22 04 80 	movabs $0x80042204e5,%rdi
  800420cf0c:	00 00 00 
  800420cf0f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cf14:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420cf1b:	00 00 00 
  800420cf1e:	ff d2                	callq  *%rdx
	cprintf("  rcx  0x%08x\n", regs->reg_rcx);
  800420cf20:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cf24:	48 8b 40 60          	mov    0x60(%rax),%rax
  800420cf28:	48 89 c6             	mov    %rax,%rsi
  800420cf2b:	48 bf f4 04 22 04 80 	movabs $0x80042204f4,%rdi
  800420cf32:	00 00 00 
  800420cf35:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cf3a:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420cf41:	00 00 00 
  800420cf44:	ff d2                	callq  *%rdx
	cprintf("  rax  0x%08x\n", regs->reg_rax);
  800420cf46:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cf4a:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420cf4e:	48 89 c6             	mov    %rax,%rsi
  800420cf51:	48 bf 03 05 22 04 80 	movabs $0x8004220503,%rdi
  800420cf58:	00 00 00 
  800420cf5b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cf60:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420cf67:	00 00 00 
  800420cf6a:	ff d2                	callq  *%rdx
}
  800420cf6c:	90                   	nop
  800420cf6d:	c9                   	leaveq 
  800420cf6e:	c3                   	retq   

000000800420cf6f <trap_dispatch>:

static void
trap_dispatch(struct Trapframe *tf)
{
  800420cf6f:	55                   	push   %rbp
  800420cf70:	48 89 e5             	mov    %rsp,%rbp
  800420cf73:	48 83 ec 10          	sub    $0x10,%rsp
  800420cf77:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

	// Handle processor exceptions.
	// LAB 3: Your code here.

	if (tf->tf_trapno == T_PGFLT) {
  800420cf7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cf7f:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420cf86:	48 83 f8 0e          	cmp    $0xe,%rax
  800420cf8a:	75 18                	jne    800420cfa4 <trap_dispatch+0x35>
		page_fault_handler(tf);
  800420cf8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cf90:	48 89 c7             	mov    %rax,%rdi
  800420cf93:	48 b8 ed d4 20 04 80 	movabs $0x800420d4ed,%rax
  800420cf9a:	00 00 00 
  800420cf9d:	ff d0                	callq  *%rax
		return;
  800420cf9f:	e9 ea 01 00 00       	jmpq   800420d18e <trap_dispatch+0x21f>
	}
	if (tf->tf_trapno == T_SYSCALL) {
  800420cfa4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cfa8:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420cfaf:	48 83 f8 30          	cmp    $0x30,%rax
  800420cfb3:	75 55                	jne    800420d00a <trap_dispatch+0x9b>
		// handle system call
		tf->tf_regs.reg_rax =
			syscall(tf->tf_regs.reg_rax,
  800420cfb5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cfb9:	4c 8b 40 40          	mov    0x40(%rax),%r8
  800420cfbd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cfc1:	48 8b 78 48          	mov    0x48(%rax),%rdi
  800420cfc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cfc9:	48 8b 48 68          	mov    0x68(%rax),%rcx
  800420cfcd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cfd1:	48 8b 50 60          	mov    0x60(%rax),%rdx
  800420cfd5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cfd9:	48 8b 70 58          	mov    0x58(%rax),%rsi
  800420cfdd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cfe1:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420cfe5:	4d 89 c1             	mov    %r8,%r9
  800420cfe8:	49 89 f8             	mov    %rdi,%r8
  800420cfeb:	48 89 c7             	mov    %rax,%rdi
  800420cfee:	48 b8 f3 f1 20 04 80 	movabs $0x800420f1f3,%rax
  800420cff5:	00 00 00 
  800420cff8:	ff d0                	callq  *%rax
		page_fault_handler(tf);
		return;
	}
	if (tf->tf_trapno == T_SYSCALL) {
		// handle system call
		tf->tf_regs.reg_rax =
  800420cffa:	48 89 c2             	mov    %rax,%rdx
  800420cffd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d001:	48 89 50 70          	mov    %rdx,0x70(%rax)
				tf->tf_regs.reg_rdx,
				tf->tf_regs.reg_rcx,
				tf->tf_regs.reg_rbx,
				tf->tf_regs.reg_rdi,
				tf->tf_regs.reg_rsi);
		return;
  800420d005:	e9 84 01 00 00       	jmpq   800420d18e <trap_dispatch+0x21f>
	}
	if (tf->tf_trapno == T_BRKPT) {
  800420d00a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d00e:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420d015:	48 83 f8 03          	cmp    $0x3,%rax
  800420d019:	75 18                	jne    800420d033 <trap_dispatch+0xc4>
		// Invoke the kernel monitor.
		monitor(tf);
  800420d01b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d01f:	48 89 c7             	mov    %rax,%rdi
  800420d022:	48 b8 c0 1a 20 04 80 	movabs $0x8004201ac0,%rax
  800420d029:	00 00 00 
  800420d02c:	ff d0                	callq  *%rax
		return;
  800420d02e:	e9 5b 01 00 00       	jmpq   800420d18e <trap_dispatch+0x21f>


	// Handle spurious interrupts
	// The hardware sometimes raises these because of noise on the
	// IRQ line or other reasons. We don't care.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
  800420d033:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d037:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420d03e:	48 83 f8 27          	cmp    $0x27,%rax
  800420d042:	75 33                	jne    800420d077 <trap_dispatch+0x108>
		cprintf("Spurious interrupt on irq 7\n");
  800420d044:	48 bf 12 05 22 04 80 	movabs $0x8004220512,%rdi
  800420d04b:	00 00 00 
  800420d04e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d053:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420d05a:	00 00 00 
  800420d05d:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420d05f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d063:	48 89 c7             	mov    %rax,%rdi
  800420d066:	48 b8 15 ca 20 04 80 	movabs $0x800420ca15,%rax
  800420d06d:	00 00 00 
  800420d070:	ff d0                	callq  *%rax
		return;
  800420d072:	e9 17 01 00 00       	jmpq   800420d18e <trap_dispatch+0x21f>
	// Add time tick increment to clock interrupts.
	// Be careful! In multiprocessors, clock interrupts are
	// triggered on every CPU.
	// LAB 6: Your code here.

	if (tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER) {
  800420d077:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d07b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420d082:	48 83 f8 20          	cmp    $0x20,%rax
  800420d086:	75 34                	jne    800420d0bc <trap_dispatch+0x14d>
		// irq 0 -- clock interrupt

		if (cpunum() == 0)
  800420d088:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420d08f:	00 00 00 
  800420d092:	ff d0                	callq  *%rax
  800420d094:	85 c0                	test   %eax,%eax
  800420d096:	75 0c                	jne    800420d0a4 <trap_dispatch+0x135>
			time_tick();
  800420d098:	48 b8 3a 97 21 04 80 	movabs $0x800421973a,%rax
  800420d09f:	00 00 00 
  800420d0a2:	ff d0                	callq  *%rax

		lapic_eoi();
  800420d0a4:	48 b8 02 7f 21 04 80 	movabs $0x8004217f02,%rax
  800420d0ab:	00 00 00 
  800420d0ae:	ff d0                	callq  *%rax

		sched_yield();
  800420d0b0:	48 b8 16 da 20 04 80 	movabs $0x800420da16,%rax
  800420d0b7:	00 00 00 
  800420d0ba:	ff d0                	callq  *%rax
	}

	// Handle keyboard and serial interrupts.
	// LAB 5: Your code here.

	if (tf->tf_trapno == IRQ_OFFSET + IRQ_KBD) {
  800420d0bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d0c0:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420d0c7:	48 83 f8 21          	cmp    $0x21,%rax
  800420d0cb:	75 11                	jne    800420d0de <trap_dispatch+0x16f>
		kbd_intr();
  800420d0cd:	48 b8 2f 10 20 04 80 	movabs $0x800420102f,%rax
  800420d0d4:	00 00 00 
  800420d0d7:	ff d0                	callq  *%rax
		return;
  800420d0d9:	e9 b0 00 00 00       	jmpq   800420d18e <trap_dispatch+0x21f>
	}
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SERIAL) {
  800420d0de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d0e2:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420d0e9:	48 83 f8 24          	cmp    $0x24,%rax
  800420d0ed:	75 11                	jne    800420d100 <trap_dispatch+0x191>
		serial_intr();
  800420d0ef:	48 b8 ae 07 20 04 80 	movabs $0x80042007ae,%rax
  800420d0f6:	00 00 00 
  800420d0f9:	ff d0                	callq  *%rax
		return;
  800420d0fb:	e9 8e 00 00 00       	jmpq   800420d18e <trap_dispatch+0x21f>
	}


	// Unexpected trap: The user process or the kernel has a bug.
	print_trapframe(tf);
  800420d100:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d104:	48 89 c7             	mov    %rax,%rdi
  800420d107:	48 b8 15 ca 20 04 80 	movabs $0x800420ca15,%rax
  800420d10e:	00 00 00 
  800420d111:	ff d0                	callq  *%rax
	if (tf->tf_cs == GD_KT)
  800420d113:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d117:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420d11e:	66 83 f8 08          	cmp    $0x8,%ax
  800420d122:	75 2a                	jne    800420d14e <trap_dispatch+0x1df>
		panic("unhandled trap in kernel");
  800420d124:	48 ba 2f 05 22 04 80 	movabs $0x800422052f,%rdx
  800420d12b:	00 00 00 
  800420d12e:	be 48 01 00 00       	mov    $0x148,%esi
  800420d133:	48 bf 48 05 22 04 80 	movabs $0x8004220548,%rdi
  800420d13a:	00 00 00 
  800420d13d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d142:	48 b9 f3 04 20 04 80 	movabs $0x80042004f3,%rcx
  800420d149:	00 00 00 
  800420d14c:	ff d1                	callq  *%rcx
	else {
		env_destroy(curenv);
  800420d14e:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420d155:	00 00 00 
  800420d158:	ff d0                	callq  *%rax
  800420d15a:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420d161:	00 00 00 
  800420d164:	48 98                	cltq   
  800420d166:	48 c1 e0 03          	shl    $0x3,%rax
  800420d16a:	48 89 c1             	mov    %rax,%rcx
  800420d16d:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d171:	48 01 c8             	add    %rcx,%rax
  800420d174:	48 01 d0             	add    %rdx,%rax
  800420d177:	48 83 c0 08          	add    $0x8,%rax
  800420d17b:	48 8b 00             	mov    (%rax),%rax
  800420d17e:	48 89 c7             	mov    %rax,%rdi
  800420d181:	48 b8 9f 95 20 04 80 	movabs $0x800420959f,%rax
  800420d188:	00 00 00 
  800420d18b:	ff d0                	callq  *%rax
		return;
  800420d18d:	90                   	nop
	}
}
  800420d18e:	c9                   	leaveq 
  800420d18f:	c3                   	retq   

000000800420d190 <trap>:

void
trap(struct Trapframe *tf)
{
  800420d190:	55                   	push   %rbp
  800420d191:	48 89 e5             	mov    %rsp,%rbp
  800420d194:	48 83 ec 20          	sub    $0x20,%rsp
  800420d198:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//struct Trapframe *tf = &tf_;
	// The environment may have set DF and some versions
	// of GCC rely on DF being clear
	asm volatile("cld" ::: "cc");
  800420d19c:	fc                   	cld    


	// Halt the CPU if some other CPU has called panic()
	extern char *panicstr;
	if (panicstr)
  800420d19d:	48 b8 d8 c5 6d 04 80 	movabs $0x80046dc5d8,%rax
  800420d1a4:	00 00 00 
  800420d1a7:	48 8b 00             	mov    (%rax),%rax
  800420d1aa:	48 85 c0             	test   %rax,%rax
  800420d1ad:	74 01                	je     800420d1b0 <trap+0x20>
		asm volatile("hlt");
  800420d1af:	f4                   	hlt    

	// Re-acqurie the big kernel lock if we were halted in
	// sched_yield()
	if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
  800420d1b0:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420d1b7:	00 00 00 
  800420d1ba:	ff d0                	callq  *%rax
  800420d1bc:	48 98                	cltq   
  800420d1be:	48 c1 e0 03          	shl    $0x3,%rax
  800420d1c2:	48 89 c2             	mov    %rax,%rdx
  800420d1c5:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d1c9:	48 01 d0             	add    %rdx,%rax
  800420d1cc:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420d1d3:	00 00 00 
  800420d1d6:	48 01 d0             	add    %rdx,%rax
  800420d1d9:	48 83 c0 04          	add    $0x4,%rax
  800420d1dd:	be 01 00 00 00       	mov    $0x1,%esi
  800420d1e2:	48 89 c7             	mov    %rax,%rdi
  800420d1e5:	48 b8 e1 9d 20 04 80 	movabs $0x8004209de1,%rax
  800420d1ec:	00 00 00 
  800420d1ef:	ff d0                	callq  *%rax
  800420d1f1:	83 f8 02             	cmp    $0x2,%eax
  800420d1f4:	75 0c                	jne    800420d202 <trap+0x72>
		lock_kernel();
  800420d1f6:	48 b8 06 9e 20 04 80 	movabs $0x8004209e06,%rax
  800420d1fd:	00 00 00 
  800420d200:	ff d0                	callq  *%rax

static __inline uint64_t
read_eflags(void)
{
	uint64_t rflags;
	__asm __volatile("pushfq; popq %0" : "=r" (rflags));
  800420d202:	9c                   	pushfq 
  800420d203:	58                   	pop    %rax
  800420d204:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return rflags;
  800420d208:	48 8b 45 f8          	mov    -0x8(%rbp),%rax

	// Check that interrupts are disabled.  If this assertion
	// fails, DO NOT be tempted to fix it by inserting a "cli" in
	// the interrupt path.
	assert(!(read_eflags() & FL_IF));
  800420d20c:	25 00 02 00 00       	and    $0x200,%eax
  800420d211:	48 85 c0             	test   %rax,%rax
  800420d214:	74 35                	je     800420d24b <trap+0xbb>
  800420d216:	48 b9 54 05 22 04 80 	movabs $0x8004220554,%rcx
  800420d21d:	00 00 00 
  800420d220:	48 ba 6d 05 22 04 80 	movabs $0x800422056d,%rdx
  800420d227:	00 00 00 
  800420d22a:	be 65 01 00 00       	mov    $0x165,%esi
  800420d22f:	48 bf 48 05 22 04 80 	movabs $0x8004220548,%rdi
  800420d236:	00 00 00 
  800420d239:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d23e:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420d245:	00 00 00 
  800420d248:	41 ff d0             	callq  *%r8


	if ((tf->tf_cs & 3) == 3) {
  800420d24b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d24f:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420d256:	0f b7 c0             	movzwl %ax,%eax
  800420d259:	83 e0 03             	and    $0x3,%eax
  800420d25c:	83 f8 03             	cmp    $0x3,%eax
  800420d25f:	0f 85 a9 01 00 00    	jne    800420d40e <trap+0x27e>

		// Acquire the big kernel lock before doing any
		// serious kernel work.
		// LAB 4: Your code here.

		lock_kernel();
  800420d265:	48 b8 06 9e 20 04 80 	movabs $0x8004209e06,%rax
  800420d26c:	00 00 00 
  800420d26f:	ff d0                	callq  *%rax

		assert(curenv);
  800420d271:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420d278:	00 00 00 
  800420d27b:	ff d0                	callq  *%rax
  800420d27d:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420d284:	00 00 00 
  800420d287:	48 98                	cltq   
  800420d289:	48 c1 e0 03          	shl    $0x3,%rax
  800420d28d:	48 89 c1             	mov    %rax,%rcx
  800420d290:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d294:	48 01 c8             	add    %rcx,%rax
  800420d297:	48 01 d0             	add    %rdx,%rax
  800420d29a:	48 83 c0 08          	add    $0x8,%rax
  800420d29e:	48 8b 00             	mov    (%rax),%rax
  800420d2a1:	48 85 c0             	test   %rax,%rax
  800420d2a4:	75 35                	jne    800420d2db <trap+0x14b>
  800420d2a6:	48 b9 82 05 22 04 80 	movabs $0x8004220582,%rcx
  800420d2ad:	00 00 00 
  800420d2b0:	48 ba 6d 05 22 04 80 	movabs $0x800422056d,%rdx
  800420d2b7:	00 00 00 
  800420d2ba:	be 71 01 00 00       	mov    $0x171,%esi
  800420d2bf:	48 bf 48 05 22 04 80 	movabs $0x8004220548,%rdi
  800420d2c6:	00 00 00 
  800420d2c9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d2ce:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420d2d5:	00 00 00 
  800420d2d8:	41 ff d0             	callq  *%r8


		// Garbage collect if current enviroment is a zombie
		if (curenv->env_status == ENV_DYING) {
  800420d2db:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420d2e2:	00 00 00 
  800420d2e5:	ff d0                	callq  *%rax
  800420d2e7:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420d2ee:	00 00 00 
  800420d2f1:	48 98                	cltq   
  800420d2f3:	48 c1 e0 03          	shl    $0x3,%rax
  800420d2f7:	48 89 c1             	mov    %rax,%rcx
  800420d2fa:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d2fe:	48 01 c8             	add    %rcx,%rax
  800420d301:	48 01 d0             	add    %rdx,%rax
  800420d304:	48 83 c0 08          	add    $0x8,%rax
  800420d308:	48 8b 00             	mov    (%rax),%rax
  800420d30b:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d311:	83 f8 01             	cmp    $0x1,%eax
  800420d314:	75 7f                	jne    800420d395 <trap+0x205>
			env_free(curenv);
  800420d316:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420d31d:	00 00 00 
  800420d320:	ff d0                	callq  *%rax
  800420d322:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420d329:	00 00 00 
  800420d32c:	48 98                	cltq   
  800420d32e:	48 c1 e0 03          	shl    $0x3,%rax
  800420d332:	48 89 c1             	mov    %rax,%rcx
  800420d335:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d339:	48 01 c8             	add    %rcx,%rax
  800420d33c:	48 01 d0             	add    %rdx,%rax
  800420d33f:	48 83 c0 08          	add    $0x8,%rax
  800420d343:	48 8b 00             	mov    (%rax),%rax
  800420d346:	48 89 c7             	mov    %rax,%rdi
  800420d349:	48 b8 0e 91 20 04 80 	movabs $0x800420910e,%rax
  800420d350:	00 00 00 
  800420d353:	ff d0                	callq  *%rax
			curenv = NULL;
  800420d355:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420d35c:	00 00 00 
  800420d35f:	ff d0                	callq  *%rax
  800420d361:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420d368:	00 00 00 
  800420d36b:	48 98                	cltq   
  800420d36d:	48 c1 e0 03          	shl    $0x3,%rax
  800420d371:	48 89 c1             	mov    %rax,%rcx
  800420d374:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d378:	48 01 c8             	add    %rcx,%rax
  800420d37b:	48 01 d0             	add    %rdx,%rax
  800420d37e:	48 83 c0 08          	add    $0x8,%rax
  800420d382:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			sched_yield();
  800420d389:	48 b8 16 da 20 04 80 	movabs $0x800420da16,%rax
  800420d390:	00 00 00 
  800420d393:	ff d0                	callq  *%rax


		// Copy trap frame (which is currently on the stack)
		// into 'curenv->env_tf', so that running the environment
		// will restart at the trap point.
		curenv->env_tf = *tf;
  800420d395:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420d39c:	00 00 00 
  800420d39f:	ff d0                	callq  *%rax
  800420d3a1:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420d3a8:	00 00 00 
  800420d3ab:	48 98                	cltq   
  800420d3ad:	48 c1 e0 03          	shl    $0x3,%rax
  800420d3b1:	48 89 c1             	mov    %rax,%rcx
  800420d3b4:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d3b8:	48 01 c8             	add    %rcx,%rax
  800420d3bb:	48 01 d0             	add    %rdx,%rax
  800420d3be:	48 83 c0 08          	add    $0x8,%rax
  800420d3c2:	48 8b 10             	mov    (%rax),%rdx
  800420d3c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d3c9:	48 89 c6             	mov    %rax,%rsi
  800420d3cc:	b8 18 00 00 00       	mov    $0x18,%eax
  800420d3d1:	48 89 d7             	mov    %rdx,%rdi
  800420d3d4:	48 89 c1             	mov    %rax,%rcx
  800420d3d7:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		// The trapframe on the stack should be ignored from here on.
		tf = &curenv->env_tf;
  800420d3da:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420d3e1:	00 00 00 
  800420d3e4:	ff d0                	callq  *%rax
  800420d3e6:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420d3ed:	00 00 00 
  800420d3f0:	48 98                	cltq   
  800420d3f2:	48 c1 e0 03          	shl    $0x3,%rax
  800420d3f6:	48 89 c1             	mov    %rax,%rcx
  800420d3f9:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d3fd:	48 01 c8             	add    %rcx,%rax
  800420d400:	48 01 d0             	add    %rdx,%rax
  800420d403:	48 83 c0 08          	add    $0x8,%rax
  800420d407:	48 8b 00             	mov    (%rax),%rax
  800420d40a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}


	// Record that tf is the last real trapframe so
	// print_trapframe can print some additional information.
	last_tf = tf;
  800420d40e:	48 b8 90 e2 4d 04 80 	movabs $0x80044de290,%rax
  800420d415:	00 00 00 
  800420d418:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d41c:	48 89 10             	mov    %rdx,(%rax)

	// Dispatch based on what type of trap occurred
	trap_dispatch(tf);
  800420d41f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d423:	48 89 c7             	mov    %rax,%rdi
  800420d426:	48 b8 6f cf 20 04 80 	movabs $0x800420cf6f,%rax
  800420d42d:	00 00 00 
  800420d430:	ff d0                	callq  *%rax


	// If we made it to this point, then no other environment was
	// scheduled, so we should return to the current environment
	// if doing so makes sense.
	if (curenv && curenv->env_status == ENV_RUNNING)
  800420d432:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420d439:	00 00 00 
  800420d43c:	ff d0                	callq  *%rax
  800420d43e:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420d445:	00 00 00 
  800420d448:	48 98                	cltq   
  800420d44a:	48 c1 e0 03          	shl    $0x3,%rax
  800420d44e:	48 89 c1             	mov    %rax,%rcx
  800420d451:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d455:	48 01 c8             	add    %rcx,%rax
  800420d458:	48 01 d0             	add    %rdx,%rax
  800420d45b:	48 83 c0 08          	add    $0x8,%rax
  800420d45f:	48 8b 00             	mov    (%rax),%rax
  800420d462:	48 85 c0             	test   %rax,%rax
  800420d465:	74 7a                	je     800420d4e1 <trap+0x351>
  800420d467:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420d46e:	00 00 00 
  800420d471:	ff d0                	callq  *%rax
  800420d473:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420d47a:	00 00 00 
  800420d47d:	48 98                	cltq   
  800420d47f:	48 c1 e0 03          	shl    $0x3,%rax
  800420d483:	48 89 c1             	mov    %rax,%rcx
  800420d486:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d48a:	48 01 c8             	add    %rcx,%rax
  800420d48d:	48 01 d0             	add    %rdx,%rax
  800420d490:	48 83 c0 08          	add    $0x8,%rax
  800420d494:	48 8b 00             	mov    (%rax),%rax
  800420d497:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d49d:	83 f8 03             	cmp    $0x3,%eax
  800420d4a0:	75 3f                	jne    800420d4e1 <trap+0x351>
		env_run(curenv);
  800420d4a2:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420d4a9:	00 00 00 
  800420d4ac:	ff d0                	callq  *%rax
  800420d4ae:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420d4b5:	00 00 00 
  800420d4b8:	48 98                	cltq   
  800420d4ba:	48 c1 e0 03          	shl    $0x3,%rax
  800420d4be:	48 89 c1             	mov    %rax,%rcx
  800420d4c1:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d4c5:	48 01 c8             	add    %rcx,%rax
  800420d4c8:	48 01 d0             	add    %rdx,%rax
  800420d4cb:	48 83 c0 08          	add    $0x8,%rax
  800420d4cf:	48 8b 00             	mov    (%rax),%rax
  800420d4d2:	48 89 c7             	mov    %rax,%rdi
  800420d4d5:	48 b8 6a 97 20 04 80 	movabs $0x800420976a,%rax
  800420d4dc:	00 00 00 
  800420d4df:	ff d0                	callq  *%rax
	else
		sched_yield();
  800420d4e1:	48 b8 16 da 20 04 80 	movabs $0x800420da16,%rax
  800420d4e8:	00 00 00 
  800420d4eb:	ff d0                	callq  *%rax

000000800420d4ed <page_fault_handler>:
}


void
page_fault_handler(struct Trapframe *tf)
{
  800420d4ed:	55                   	push   %rbp
  800420d4ee:	48 89 e5             	mov    %rsp,%rbp
  800420d4f1:	53                   	push   %rbx
  800420d4f2:	48 83 ec 38          	sub    $0x38,%rsp
  800420d4f6:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420d4fa:	0f 20 d0             	mov    %cr2,%rax
  800420d4fd:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	return val;
  800420d501:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
	uint64_t fault_va;

	struct UTrapframe *utf;
	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
  800420d505:	48 89 45 e0          	mov    %rax,-0x20(%rbp)


	if ((tf->tf_cs & 3) == 0) {
  800420d509:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d50d:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420d514:	0f b7 c0             	movzwl %ax,%eax
  800420d517:	83 e0 03             	and    $0x3,%eax
  800420d51a:	85 c0                	test   %eax,%eax
  800420d51c:	75 3d                	jne    800420d55b <page_fault_handler+0x6e>
		print_trapframe(tf);
  800420d51e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d522:	48 89 c7             	mov    %rax,%rdi
  800420d525:	48 b8 15 ca 20 04 80 	movabs $0x800420ca15,%rax
  800420d52c:	00 00 00 
  800420d52f:	ff d0                	callq  *%rax
		panic("page fault");
  800420d531:	48 ba 89 05 22 04 80 	movabs $0x8004220589,%rdx
  800420d538:	00 00 00 
  800420d53b:	be a4 01 00 00       	mov    $0x1a4,%esi
  800420d540:	48 bf 48 05 22 04 80 	movabs $0x8004220548,%rdi
  800420d547:	00 00 00 
  800420d54a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d54f:	48 b9 f3 04 20 04 80 	movabs $0x80042004f3,%rcx
  800420d556:	00 00 00 
  800420d559:	ff d1                	callq  *%rcx
	}



	// See if the environment has installed a user page fault handler.
	if (curenv->env_pgfault_upcall == 0) {
  800420d55b:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420d562:	00 00 00 
  800420d565:	ff d0                	callq  *%rax
  800420d567:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420d56e:	00 00 00 
  800420d571:	48 98                	cltq   
  800420d573:	48 c1 e0 03          	shl    $0x3,%rax
  800420d577:	48 89 c1             	mov    %rax,%rcx
  800420d57a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d57e:	48 01 c8             	add    %rcx,%rax
  800420d581:	48 01 d0             	add    %rdx,%rax
  800420d584:	48 83 c0 08          	add    $0x8,%rax
  800420d588:	48 8b 00             	mov    (%rax),%rax
  800420d58b:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420d592:	48 85 c0             	test   %rax,%rax
  800420d595:	0f 85 b8 00 00 00    	jne    800420d653 <page_fault_handler+0x166>
		cprintf("[%08x] user fault va %08x ip %08x\n",
  800420d59b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d59f:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
			curenv->env_id, fault_va, tf->tf_rip);
  800420d5a6:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420d5ad:	00 00 00 
  800420d5b0:	ff d0                	callq  *%rax
  800420d5b2:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420d5b9:	00 00 00 
  800420d5bc:	48 98                	cltq   
  800420d5be:	48 c1 e0 03          	shl    $0x3,%rax
  800420d5c2:	48 89 c1             	mov    %rax,%rcx
  800420d5c5:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d5c9:	48 01 c8             	add    %rcx,%rax
  800420d5cc:	48 01 d0             	add    %rdx,%rax
  800420d5cf:	48 83 c0 08          	add    $0x8,%rax
  800420d5d3:	48 8b 00             	mov    (%rax),%rax



	// See if the environment has installed a user page fault handler.
	if (curenv->env_pgfault_upcall == 0) {
		cprintf("[%08x] user fault va %08x ip %08x\n",
  800420d5d6:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420d5dc:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d5e0:	48 89 d9             	mov    %rbx,%rcx
  800420d5e3:	89 c6                	mov    %eax,%esi
  800420d5e5:	48 bf 98 05 22 04 80 	movabs $0x8004220598,%rdi
  800420d5ec:	00 00 00 
  800420d5ef:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d5f4:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800420d5fb:	00 00 00 
  800420d5fe:	41 ff d0             	callq  *%r8
			curenv->env_id, fault_va, tf->tf_rip);
		print_trapframe(tf);
  800420d601:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d605:	48 89 c7             	mov    %rax,%rdi
  800420d608:	48 b8 15 ca 20 04 80 	movabs $0x800420ca15,%rax
  800420d60f:	00 00 00 
  800420d612:	ff d0                	callq  *%rax
		env_destroy(curenv);
  800420d614:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420d61b:	00 00 00 
  800420d61e:	ff d0                	callq  *%rax
  800420d620:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420d627:	00 00 00 
  800420d62a:	48 98                	cltq   
  800420d62c:	48 c1 e0 03          	shl    $0x3,%rax
  800420d630:	48 89 c1             	mov    %rax,%rcx
  800420d633:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d637:	48 01 c8             	add    %rcx,%rax
  800420d63a:	48 01 d0             	add    %rdx,%rax
  800420d63d:	48 83 c0 08          	add    $0x8,%rax
  800420d641:	48 8b 00             	mov    (%rax),%rax
  800420d644:	48 89 c7             	mov    %rax,%rdi
  800420d647:	48 b8 9f 95 20 04 80 	movabs $0x800420959f,%rax
  800420d64e:	00 00 00 
  800420d651:	ff d0                	callq  *%rax
	}

	// Decide where to push our exception stack frame.
	if (tf->tf_rsp >= UXSTACKTOP - PGSIZE && tf->tf_rsp < UXSTACKTOP) {
  800420d653:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d657:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420d65e:	b8 ff ef 7f ef       	mov    $0xef7fefff,%eax
  800420d663:	48 39 c2             	cmp    %rax,%rdx
  800420d666:	76 2c                	jbe    800420d694 <page_fault_handler+0x1a7>
  800420d668:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d66c:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420d673:	b8 ff ff 7f ef       	mov    $0xef7fffff,%eax
  800420d678:	48 39 c2             	cmp    %rax,%rdx
  800420d67b:	77 17                	ja     800420d694 <page_fault_handler+0x1a7>
		// The user's ESP is ALREADY in the user exception stack area,
		// so push the new frame on the exception stack,
		// preserving the existing exception stack contents.
		utf = (struct UTrapframe*)(tf->tf_rsp
  800420d67d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d681:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
					   - sizeof(struct UTrapframe)
					   // Save a spare word for return
					   - 8);
  800420d688:	48 2d a8 00 00 00    	sub    $0xa8,%rax
	// Decide where to push our exception stack frame.
	if (tf->tf_rsp >= UXSTACKTOP - PGSIZE && tf->tf_rsp < UXSTACKTOP) {
		// The user's ESP is ALREADY in the user exception stack area,
		// so push the new frame on the exception stack,
		// preserving the existing exception stack contents.
		utf = (struct UTrapframe*)(tf->tf_rsp
  800420d68e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420d692:	eb 09                	jmp    800420d69d <page_fault_handler+0x1b0>
		// The user's ESP is NOT in the user exception stack area,
		// so it's presumably pointing to a normal user stack
		// and the user exception stack is not in use.
		// Therefore, switch the user's ESP onto the exception stack
		// and push the new frame at the top of the exception stack.
		utf = (struct UTrapframe*)(UXSTACKTOP
  800420d694:	b8 60 ff 7f ef       	mov    $0xef7fff60,%eax
  800420d699:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}

	// If we can't write to the exception stack,
	// it means the user environment is seriously screwed up,
	// so just terminate it.
	user_mem_assert(curenv, utf, sizeof(struct UTrapframe), PTE_U | PTE_W);
  800420d69d:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420d6a4:	00 00 00 
  800420d6a7:	ff d0                	callq  *%rax
  800420d6a9:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420d6b0:	00 00 00 
  800420d6b3:	48 98                	cltq   
  800420d6b5:	48 c1 e0 03          	shl    $0x3,%rax
  800420d6b9:	48 89 c1             	mov    %rax,%rcx
  800420d6bc:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d6c0:	48 01 c8             	add    %rcx,%rax
  800420d6c3:	48 01 d0             	add    %rdx,%rax
  800420d6c6:	48 83 c0 08          	add    $0x8,%rax
  800420d6ca:	48 8b 00             	mov    (%rax),%rax
  800420d6cd:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420d6d1:	b9 06 00 00 00       	mov    $0x6,%ecx
  800420d6d6:	ba a0 00 00 00       	mov    $0xa0,%edx
  800420d6db:	48 89 c7             	mov    %rax,%rdi
  800420d6de:	48 b8 c8 41 20 04 80 	movabs $0x80042041c8,%rax
  800420d6e5:	00 00 00 
  800420d6e8:	ff d0                	callq  *%rax

	// fill utf
	utf->utf_fault_va = fault_va;
  800420d6ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d6ee:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d6f2:	48 89 10             	mov    %rdx,(%rax)
	utf->utf_err = tf->tf_err;
  800420d6f5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d6f9:	48 8b 90 90 00 00 00 	mov    0x90(%rax),%rdx
  800420d700:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d704:	48 89 50 08          	mov    %rdx,0x8(%rax)
	utf->utf_regs = tf->tf_regs;
  800420d708:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d70c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420d710:	48 8b 0a             	mov    (%rdx),%rcx
  800420d713:	48 89 48 10          	mov    %rcx,0x10(%rax)
  800420d717:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420d71b:	48 89 48 18          	mov    %rcx,0x18(%rax)
  800420d71f:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  800420d723:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800420d727:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  800420d72b:	48 89 48 28          	mov    %rcx,0x28(%rax)
  800420d72f:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  800420d733:	48 89 48 30          	mov    %rcx,0x30(%rax)
  800420d737:	48 8b 4a 28          	mov    0x28(%rdx),%rcx
  800420d73b:	48 89 48 38          	mov    %rcx,0x38(%rax)
  800420d73f:	48 8b 4a 30          	mov    0x30(%rdx),%rcx
  800420d743:	48 89 48 40          	mov    %rcx,0x40(%rax)
  800420d747:	48 8b 4a 38          	mov    0x38(%rdx),%rcx
  800420d74b:	48 89 48 48          	mov    %rcx,0x48(%rax)
  800420d74f:	48 8b 4a 40          	mov    0x40(%rdx),%rcx
  800420d753:	48 89 48 50          	mov    %rcx,0x50(%rax)
  800420d757:	48 8b 4a 48          	mov    0x48(%rdx),%rcx
  800420d75b:	48 89 48 58          	mov    %rcx,0x58(%rax)
  800420d75f:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
  800420d763:	48 89 48 60          	mov    %rcx,0x60(%rax)
  800420d767:	48 8b 4a 58          	mov    0x58(%rdx),%rcx
  800420d76b:	48 89 48 68          	mov    %rcx,0x68(%rax)
  800420d76f:	48 8b 4a 60          	mov    0x60(%rdx),%rcx
  800420d773:	48 89 48 70          	mov    %rcx,0x70(%rax)
  800420d777:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
  800420d77b:	48 89 48 78          	mov    %rcx,0x78(%rax)
  800420d77f:	48 8b 52 70          	mov    0x70(%rdx),%rdx
  800420d783:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
	utf->utf_rip = tf->tf_rip;
  800420d78a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d78e:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  800420d795:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d799:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
	utf->utf_eflags = tf->tf_eflags;
  800420d7a0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d7a4:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  800420d7ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d7af:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
	utf->utf_rsp = tf->tf_rsp;
  800420d7b6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d7ba:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420d7c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d7c5:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)

 	// set user registers so that env_run switches to fault handler
	tf->tf_rsp = (uintptr_t) utf;
  800420d7cc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d7d0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d7d4:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
 	tf->tf_rip = (uintptr_t) curenv->env_pgfault_upcall;
  800420d7db:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420d7e2:	00 00 00 
  800420d7e5:	ff d0                	callq  *%rax
  800420d7e7:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420d7ee:	00 00 00 
  800420d7f1:	48 98                	cltq   
  800420d7f3:	48 c1 e0 03          	shl    $0x3,%rax
  800420d7f7:	48 89 c1             	mov    %rax,%rcx
  800420d7fa:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d7fe:	48 01 c8             	add    %rcx,%rax
  800420d801:	48 01 d0             	add    %rdx,%rax
  800420d804:	48 83 c0 08          	add    $0x8,%rax
  800420d808:	48 8b 00             	mov    (%rax),%rax
  800420d80b:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420d812:	48 89 c2             	mov    %rax,%rdx
  800420d815:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d819:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)

	env_run(curenv);
  800420d820:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420d827:	00 00 00 
  800420d82a:	ff d0                	callq  *%rax
  800420d82c:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420d833:	00 00 00 
  800420d836:	48 98                	cltq   
  800420d838:	48 c1 e0 03          	shl    $0x3,%rax
  800420d83c:	48 89 c1             	mov    %rax,%rcx
  800420d83f:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d843:	48 01 c8             	add    %rcx,%rax
  800420d846:	48 01 d0             	add    %rdx,%rax
  800420d849:	48 83 c0 08          	add    $0x8,%rax
  800420d84d:	48 8b 00             	mov    (%rax),%rax
  800420d850:	48 89 c7             	mov    %rax,%rdi
  800420d853:	48 b8 6a 97 20 04 80 	movabs $0x800420976a,%rax
  800420d85a:	00 00 00 
  800420d85d:	ff d0                	callq  *%rax
  800420d85f:	90                   	nop

000000800420d860 <Xdivide>:

.text


/* CPU traps */
TRAPHANDLER_NOEC(Xdivide, T_DIVIDE)
  800420d860:	6a 00                	pushq  $0x0
  800420d862:	6a 00                	pushq  $0x0
  800420d864:	e9 f7 00 00 00       	jmpq   800420d960 <_alltraps>
  800420d869:	90                   	nop

000000800420d86a <Xdebug>:
TRAPHANDLER_NOEC(Xdebug,  T_DEBUG)
  800420d86a:	6a 00                	pushq  $0x0
  800420d86c:	6a 01                	pushq  $0x1
  800420d86e:	e9 ed 00 00 00       	jmpq   800420d960 <_alltraps>
  800420d873:	90                   	nop

000000800420d874 <Xnmi>:
TRAPHANDLER_NOEC(Xnmi,    T_NMI)
  800420d874:	6a 00                	pushq  $0x0
  800420d876:	6a 02                	pushq  $0x2
  800420d878:	e9 e3 00 00 00       	jmpq   800420d960 <_alltraps>
  800420d87d:	90                   	nop

000000800420d87e <Xbrkpt>:
TRAPHANDLER_NOEC(Xbrkpt,  T_BRKPT)
  800420d87e:	6a 00                	pushq  $0x0
  800420d880:	6a 03                	pushq  $0x3
  800420d882:	e9 d9 00 00 00       	jmpq   800420d960 <_alltraps>
  800420d887:	90                   	nop

000000800420d888 <Xoflow>:
TRAPHANDLER_NOEC(Xoflow,  T_OFLOW)
  800420d888:	6a 00                	pushq  $0x0
  800420d88a:	6a 04                	pushq  $0x4
  800420d88c:	e9 cf 00 00 00       	jmpq   800420d960 <_alltraps>
  800420d891:	90                   	nop

000000800420d892 <Xbound>:
TRAPHANDLER_NOEC(Xbound,  T_BOUND)
  800420d892:	6a 00                	pushq  $0x0
  800420d894:	6a 05                	pushq  $0x5
  800420d896:	e9 c5 00 00 00       	jmpq   800420d960 <_alltraps>
  800420d89b:	90                   	nop

000000800420d89c <Xillop>:
TRAPHANDLER_NOEC(Xillop,  T_ILLOP)
  800420d89c:	6a 00                	pushq  $0x0
  800420d89e:	6a 06                	pushq  $0x6
  800420d8a0:	e9 bb 00 00 00       	jmpq   800420d960 <_alltraps>
  800420d8a5:	90                   	nop

000000800420d8a6 <Xdevice>:
TRAPHANDLER_NOEC(Xdevice, T_DEVICE)
  800420d8a6:	6a 00                	pushq  $0x0
  800420d8a8:	6a 07                	pushq  $0x7
  800420d8aa:	e9 b1 00 00 00       	jmpq   800420d960 <_alltraps>
  800420d8af:	90                   	nop

000000800420d8b0 <Xdblflt>:
TRAPHANDLER     (Xdblflt, T_DBLFLT)
  800420d8b0:	6a 08                	pushq  $0x8
  800420d8b2:	e9 a9 00 00 00       	jmpq   800420d960 <_alltraps>
  800420d8b7:	90                   	nop

000000800420d8b8 <Xtss>:
TRAPHANDLER     (Xtss,    T_TSS)
  800420d8b8:	6a 0a                	pushq  $0xa
  800420d8ba:	e9 a1 00 00 00       	jmpq   800420d960 <_alltraps>
  800420d8bf:	90                   	nop

000000800420d8c0 <Xsegnp>:
TRAPHANDLER     (Xsegnp,  T_SEGNP)
  800420d8c0:	6a 0b                	pushq  $0xb
  800420d8c2:	e9 99 00 00 00       	jmpq   800420d960 <_alltraps>
  800420d8c7:	90                   	nop

000000800420d8c8 <Xstack>:
TRAPHANDLER     (Xstack,  T_STACK)
  800420d8c8:	6a 0c                	pushq  $0xc
  800420d8ca:	e9 91 00 00 00       	jmpq   800420d960 <_alltraps>
  800420d8cf:	90                   	nop

000000800420d8d0 <Xgpflt>:
TRAPHANDLER     (Xgpflt,  T_GPFLT)
  800420d8d0:	6a 0d                	pushq  $0xd
  800420d8d2:	e9 89 00 00 00       	jmpq   800420d960 <_alltraps>
  800420d8d7:	90                   	nop

000000800420d8d8 <Xpgflt>:
TRAPHANDLER     (Xpgflt,  T_PGFLT)
  800420d8d8:	6a 0e                	pushq  $0xe
  800420d8da:	e9 81 00 00 00       	jmpq   800420d960 <_alltraps>
  800420d8df:	90                   	nop

000000800420d8e0 <Xfperr>:
TRAPHANDLER_NOEC(Xfperr,  T_FPERR)
  800420d8e0:	6a 00                	pushq  $0x0
  800420d8e2:	6a 10                	pushq  $0x10
  800420d8e4:	eb 7a                	jmp    800420d960 <_alltraps>

000000800420d8e6 <Xalign>:
TRAPHANDLER     (Xalign,  T_ALIGN)
  800420d8e6:	6a 11                	pushq  $0x11
  800420d8e8:	eb 76                	jmp    800420d960 <_alltraps>

000000800420d8ea <Xmchk>:
TRAPHANDLER_NOEC(Xmchk,   T_MCHK)
  800420d8ea:	6a 00                	pushq  $0x0
  800420d8ec:	6a 12                	pushq  $0x12
  800420d8ee:	eb 70                	jmp    800420d960 <_alltraps>

000000800420d8f0 <Xirq0>:

/* the external device interrupts */
TRAPHANDLER_NOEC(Xirq0,   IRQ_OFFSET+0)
  800420d8f0:	6a 00                	pushq  $0x0
  800420d8f2:	6a 20                	pushq  $0x20
  800420d8f4:	eb 6a                	jmp    800420d960 <_alltraps>

000000800420d8f6 <Xirq1>:
TRAPHANDLER_NOEC(Xirq1,   IRQ_OFFSET+1)
  800420d8f6:	6a 00                	pushq  $0x0
  800420d8f8:	6a 21                	pushq  $0x21
  800420d8fa:	eb 64                	jmp    800420d960 <_alltraps>

000000800420d8fc <Xirq2>:
TRAPHANDLER_NOEC(Xirq2,   IRQ_OFFSET+2)
  800420d8fc:	6a 00                	pushq  $0x0
  800420d8fe:	6a 22                	pushq  $0x22
  800420d900:	eb 5e                	jmp    800420d960 <_alltraps>

000000800420d902 <Xirq3>:
TRAPHANDLER_NOEC(Xirq3,   IRQ_OFFSET+3)
  800420d902:	6a 00                	pushq  $0x0
  800420d904:	6a 23                	pushq  $0x23
  800420d906:	eb 58                	jmp    800420d960 <_alltraps>

000000800420d908 <Xirq4>:
TRAPHANDLER_NOEC(Xirq4,   IRQ_OFFSET+4)
  800420d908:	6a 00                	pushq  $0x0
  800420d90a:	6a 24                	pushq  $0x24
  800420d90c:	eb 52                	jmp    800420d960 <_alltraps>

000000800420d90e <Xirq5>:
TRAPHANDLER_NOEC(Xirq5,   IRQ_OFFSET+5)
  800420d90e:	6a 00                	pushq  $0x0
  800420d910:	6a 25                	pushq  $0x25
  800420d912:	eb 4c                	jmp    800420d960 <_alltraps>

000000800420d914 <Xirq6>:
TRAPHANDLER_NOEC(Xirq6,   IRQ_OFFSET+6)
  800420d914:	6a 00                	pushq  $0x0
  800420d916:	6a 26                	pushq  $0x26
  800420d918:	eb 46                	jmp    800420d960 <_alltraps>

000000800420d91a <Xirq7>:
TRAPHANDLER_NOEC(Xirq7,   IRQ_OFFSET+7)
  800420d91a:	6a 00                	pushq  $0x0
  800420d91c:	6a 27                	pushq  $0x27
  800420d91e:	eb 40                	jmp    800420d960 <_alltraps>

000000800420d920 <Xirq8>:
TRAPHANDLER_NOEC(Xirq8,   IRQ_OFFSET+8)
  800420d920:	6a 00                	pushq  $0x0
  800420d922:	6a 28                	pushq  $0x28
  800420d924:	eb 3a                	jmp    800420d960 <_alltraps>

000000800420d926 <Xirq9>:
TRAPHANDLER_NOEC(Xirq9,   IRQ_OFFSET+9)
  800420d926:	6a 00                	pushq  $0x0
  800420d928:	6a 29                	pushq  $0x29
  800420d92a:	eb 34                	jmp    800420d960 <_alltraps>

000000800420d92c <Xirq10>:
TRAPHANDLER_NOEC(Xirq10,  IRQ_OFFSET+10)
  800420d92c:	6a 00                	pushq  $0x0
  800420d92e:	6a 2a                	pushq  $0x2a
  800420d930:	eb 2e                	jmp    800420d960 <_alltraps>

000000800420d932 <Xirq11>:
TRAPHANDLER_NOEC(Xirq11,  IRQ_OFFSET+11)
  800420d932:	6a 00                	pushq  $0x0
  800420d934:	6a 2b                	pushq  $0x2b
  800420d936:	eb 28                	jmp    800420d960 <_alltraps>

000000800420d938 <Xirq12>:
TRAPHANDLER_NOEC(Xirq12,  IRQ_OFFSET+12)
  800420d938:	6a 00                	pushq  $0x0
  800420d93a:	6a 2c                	pushq  $0x2c
  800420d93c:	eb 22                	jmp    800420d960 <_alltraps>

000000800420d93e <Xirq13>:
TRAPHANDLER_NOEC(Xirq13,  IRQ_OFFSET+13)
  800420d93e:	6a 00                	pushq  $0x0
  800420d940:	6a 2d                	pushq  $0x2d
  800420d942:	eb 1c                	jmp    800420d960 <_alltraps>

000000800420d944 <Xirq14>:
TRAPHANDLER_NOEC(Xirq14,  IRQ_OFFSET+14)
  800420d944:	6a 00                	pushq  $0x0
  800420d946:	6a 2e                	pushq  $0x2e
  800420d948:	eb 16                	jmp    800420d960 <_alltraps>

000000800420d94a <Xirq15>:
TRAPHANDLER_NOEC(Xirq15,  IRQ_OFFSET+15)
  800420d94a:	6a 00                	pushq  $0x0
  800420d94c:	6a 2f                	pushq  $0x2f
  800420d94e:	eb 10                	jmp    800420d960 <_alltraps>

000000800420d950 <Xsyscall>:

/* system call entry point */
TRAPHANDLER_NOEC(Xsyscall, T_SYSCALL)
  800420d950:	6a 00                	pushq  $0x0
  800420d952:	6a 30                	pushq  $0x30
  800420d954:	eb 0a                	jmp    800420d960 <_alltraps>

000000800420d956 <Xdefault>:

/* default handler -- not for any specific trap */
TRAPHANDLER     (Xdefault, T_DEFAULT)
  800420d956:	68 f4 01 00 00       	pushq  $0x1f4
  800420d95b:	eb 03                	jmp    800420d960 <_alltraps>
  800420d95d:	0f 1f 00             	nopl   (%rax)

000000800420d960 <_alltraps>:

.globl	_alltraps
.type	_alltraps,@function
.p2align 4, 0x90		/* 16-byte alignment, nop filled */
_alltraps:
    subq $16,%rsp
  800420d960:	48 83 ec 10          	sub    $0x10,%rsp
    movw %ds,8(%rsp)
  800420d964:	8c 5c 24 08          	mov    %ds,0x8(%rsp)
    movw %es,0(%rsp)
  800420d968:	8c 04 24             	mov    %es,(%rsp)
    PUSHA
  800420d96b:	48 83 ec 78          	sub    $0x78,%rsp
  800420d96f:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  800420d974:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  800420d979:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
  800420d97e:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  800420d983:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
  800420d988:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  800420d98d:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  800420d992:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
  800420d997:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
  800420d99c:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)
  800420d9a1:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  800420d9a6:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
  800420d9ab:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  800420d9b0:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  800420d9b5:	4c 89 3c 24          	mov    %r15,(%rsp)
    movl $GD_KD, %eax
  800420d9b9:	b8 10 00 00 00       	mov    $0x10,%eax
    movw %ax, %ds
  800420d9be:	8e d8                	mov    %eax,%ds
    movw %ax, %es
  800420d9c0:	8e c0                	mov    %eax,%es
    movw %ax, %ss
  800420d9c2:	8e d0                	mov    %eax,%ss
    movw %ax, %fs
  800420d9c4:	8e e0                	mov    %eax,%fs
    movw %ax, %gs
  800420d9c6:	8e e8                	mov    %eax,%gs
    movq %rsp,%rdi
  800420d9c8:	48 89 e7             	mov    %rsp,%rdi
    call trap   # never returns 
  800420d9cb:	e8 c0 f7 ff ff       	callq  800420d190 <trap>

000000800420d9d0 <spin>:
spin:	jmp spin
  800420d9d0:	eb fe                	jmp    800420d9d0 <spin>

000000800420d9d2 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800420d9d2:	55                   	push   %rbp
  800420d9d3:	48 89 e5             	mov    %rsp,%rbp
  800420d9d6:	48 83 ec 20          	sub    $0x20,%rsp
  800420d9da:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d9de:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420d9e1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d9e5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420d9e8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d9ec:	f0 87 02             	lock xchg %eax,(%rdx)
  800420d9ef:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800420d9f2:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420d9f5:	c9                   	leaveq 
  800420d9f6:	c3                   	retq   

000000800420d9f7 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420d9f7:	55                   	push   %rbp
  800420d9f8:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420d9fb:	48 bf 60 37 23 04 80 	movabs $0x8004233760,%rdi
  800420da02:	00 00 00 
  800420da05:	48 b8 34 83 21 04 80 	movabs $0x8004218334,%rax
  800420da0c:	00 00 00 
  800420da0f:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420da11:	f3 90                	pause  
}
  800420da13:	90                   	nop
  800420da14:	5d                   	pop    %rbp
  800420da15:	c3                   	retq   

000000800420da16 <sched_yield>:


// Choose a user environment to run and run it.
void
sched_yield(void)
{
  800420da16:	55                   	push   %rbp
  800420da17:	48 89 e5             	mov    %rsp,%rbp
  800420da1a:	48 83 ec 10          	sub    $0x10,%rsp
	struct Env *idle;

	int i, j, k;

	// Determine the starting point for the search.
	if (curenv)
  800420da1e:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420da25:	00 00 00 
  800420da28:	ff d0                	callq  *%rax
  800420da2a:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420da31:	00 00 00 
  800420da34:	48 98                	cltq   
  800420da36:	48 c1 e0 03          	shl    $0x3,%rax
  800420da3a:	48 89 c1             	mov    %rax,%rcx
  800420da3d:	48 c1 e1 04          	shl    $0x4,%rcx
  800420da41:	48 01 c8             	add    %rcx,%rax
  800420da44:	48 01 d0             	add    %rdx,%rax
  800420da47:	48 83 c0 08          	add    $0x8,%rax
  800420da4b:	48 8b 00             	mov    (%rax),%rax
  800420da4e:	48 85 c0             	test   %rax,%rax
  800420da51:	74 60                	je     800420dab3 <sched_yield+0x9d>
		i = curenv-envs;
  800420da53:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420da5a:	00 00 00 
  800420da5d:	ff d0                	callq  *%rax
  800420da5f:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420da66:	00 00 00 
  800420da69:	48 98                	cltq   
  800420da6b:	48 c1 e0 03          	shl    $0x3,%rax
  800420da6f:	48 89 c1             	mov    %rax,%rcx
  800420da72:	48 c1 e1 04          	shl    $0x4,%rcx
  800420da76:	48 01 c8             	add    %rcx,%rax
  800420da79:	48 01 d0             	add    %rdx,%rax
  800420da7c:	48 83 c0 08          	add    $0x8,%rax
  800420da80:	48 8b 00             	mov    (%rax),%rax
  800420da83:	48 89 c2             	mov    %rax,%rdx
  800420da86:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  800420da8d:	00 00 00 
  800420da90:	48 8b 00             	mov    (%rax),%rax
  800420da93:	48 29 c2             	sub    %rax,%rdx
  800420da96:	48 89 d0             	mov    %rdx,%rax
  800420da99:	48 c1 f8 03          	sar    $0x3,%rax
  800420da9d:	48 89 c2             	mov    %rax,%rdx
  800420daa0:	48 b8 a5 4f fa a4 4f 	movabs $0x4fa4fa4fa4fa4fa5,%rax
  800420daa7:	fa a4 4f 
  800420daaa:	48 0f af c2          	imul   %rdx,%rax
  800420daae:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420dab1:	eb 07                	jmp    800420daba <sched_yield+0xa4>
	else
		i = NENV-1;
  800420dab3:	c7 45 fc ff 03 00 00 	movl   $0x3ff,-0x4(%rbp)
	//cprintf("sched_yield searching from %d\n", i);

	// Loop through all the environments at most once.
	for (j = 1; j <= NENV; j++) {
  800420daba:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%rbp)
  800420dac1:	eb 75                	jmp    800420db38 <sched_yield+0x122>
		k = (j + i) % NENV;
  800420dac3:	8b 55 f8             	mov    -0x8(%rbp),%edx
  800420dac6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dac9:	01 c2                	add    %eax,%edx
  800420dacb:	89 d0                	mov    %edx,%eax
  800420dacd:	c1 f8 1f             	sar    $0x1f,%eax
  800420dad0:	c1 e8 16             	shr    $0x16,%eax
  800420dad3:	01 c2                	add    %eax,%edx
  800420dad5:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  800420dadb:	29 c2                	sub    %eax,%edx
  800420dadd:	89 d0                	mov    %edx,%eax
  800420dadf:	89 45 f4             	mov    %eax,-0xc(%rbp)
		// If this environment is runnable, run it.
		if (envs[k].env_status == ENV_RUNNABLE) {
  800420dae2:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  800420dae9:	00 00 00 
  800420daec:	48 8b 10             	mov    (%rax),%rdx
  800420daef:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420daf2:	48 98                	cltq   
  800420daf4:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420dafb:	48 01 d0             	add    %rdx,%rax
  800420dafe:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420db04:	83 f8 02             	cmp    $0x2,%eax
  800420db07:	75 2b                	jne    800420db34 <sched_yield+0x11e>
					env_destroy(&envs[k]);
					continue;
				}
			}
#endif
			env_run(&envs[k]);
  800420db09:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  800420db10:	00 00 00 
  800420db13:	48 8b 10             	mov    (%rax),%rdx
  800420db16:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420db19:	48 98                	cltq   
  800420db1b:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420db22:	48 01 d0             	add    %rdx,%rax
  800420db25:	48 89 c7             	mov    %rax,%rdi
  800420db28:	48 b8 6a 97 20 04 80 	movabs $0x800420976a,%rax
  800420db2f:	00 00 00 
  800420db32:	ff d0                	callq  *%rax
	else
		i = NENV-1;
	//cprintf("sched_yield searching from %d\n", i);

	// Loop through all the environments at most once.
	for (j = 1; j <= NENV; j++) {
  800420db34:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  800420db38:	81 7d f8 00 04 00 00 	cmpl   $0x400,-0x8(%rbp)
  800420db3f:	7e 82                	jle    800420dac3 <sched_yield+0xad>
#endif
			env_run(&envs[k]);
		}
	}

	if (curenv && curenv->env_status == ENV_RUNNING) {
  800420db41:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420db48:	00 00 00 
  800420db4b:	ff d0                	callq  *%rax
  800420db4d:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420db54:	00 00 00 
  800420db57:	48 98                	cltq   
  800420db59:	48 c1 e0 03          	shl    $0x3,%rax
  800420db5d:	48 89 c1             	mov    %rax,%rcx
  800420db60:	48 c1 e1 04          	shl    $0x4,%rcx
  800420db64:	48 01 c8             	add    %rcx,%rax
  800420db67:	48 01 d0             	add    %rdx,%rax
  800420db6a:	48 83 c0 08          	add    $0x8,%rax
  800420db6e:	48 8b 00             	mov    (%rax),%rax
  800420db71:	48 85 c0             	test   %rax,%rax
  800420db74:	74 7a                	je     800420dbf0 <sched_yield+0x1da>
  800420db76:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420db7d:	00 00 00 
  800420db80:	ff d0                	callq  *%rax
  800420db82:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420db89:	00 00 00 
  800420db8c:	48 98                	cltq   
  800420db8e:	48 c1 e0 03          	shl    $0x3,%rax
  800420db92:	48 89 c1             	mov    %rax,%rcx
  800420db95:	48 c1 e1 04          	shl    $0x4,%rcx
  800420db99:	48 01 c8             	add    %rcx,%rax
  800420db9c:	48 01 d0             	add    %rdx,%rax
  800420db9f:	48 83 c0 08          	add    $0x8,%rax
  800420dba3:	48 8b 00             	mov    (%rax),%rax
  800420dba6:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420dbac:	83 f8 03             	cmp    $0x3,%eax
  800420dbaf:	75 3f                	jne    800420dbf0 <sched_yield+0x1da>
			}
		}
		env_run(curenv);
#endif // !VMM_GUEST

		env_run(curenv);
  800420dbb1:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420dbb8:	00 00 00 
  800420dbbb:	ff d0                	callq  *%rax
  800420dbbd:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420dbc4:	00 00 00 
  800420dbc7:	48 98                	cltq   
  800420dbc9:	48 c1 e0 03          	shl    $0x3,%rax
  800420dbcd:	48 89 c1             	mov    %rax,%rcx
  800420dbd0:	48 c1 e1 04          	shl    $0x4,%rcx
  800420dbd4:	48 01 c8             	add    %rcx,%rax
  800420dbd7:	48 01 d0             	add    %rdx,%rax
  800420dbda:	48 83 c0 08          	add    $0x8,%rax
  800420dbde:	48 8b 00             	mov    (%rax),%rax
  800420dbe1:	48 89 c7             	mov    %rax,%rdi
  800420dbe4:	48 b8 6a 97 20 04 80 	movabs $0x800420976a,%rax
  800420dbeb:	00 00 00 
  800420dbee:	ff d0                	callq  *%rax
	}


	// sched_halt never returns
	sched_halt();
  800420dbf0:	48 b8 ff db 20 04 80 	movabs $0x800420dbff,%rax
  800420dbf7:	00 00 00 
  800420dbfa:	ff d0                	callq  *%rax
}
  800420dbfc:	90                   	nop
  800420dbfd:	c9                   	leaveq 
  800420dbfe:	c3                   	retq   

000000800420dbff <sched_halt>:
// Halt this CPU when there is nothing to do. Wait until the
// timer interrupt wakes it up. This function never returns.
//
void
sched_halt(void)
{
  800420dbff:	55                   	push   %rbp
  800420dc00:	48 89 e5             	mov    %rsp,%rbp
  800420dc03:	48 83 ec 20          	sub    $0x20,%rsp
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420dc07:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420dc0e:	eb 79                	jmp    800420dc89 <sched_halt+0x8a>
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420dc10:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  800420dc17:	00 00 00 
  800420dc1a:	48 8b 10             	mov    (%rax),%rdx
  800420dc1d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dc20:	48 98                	cltq   
  800420dc22:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420dc29:	48 01 d0             	add    %rdx,%rax
  800420dc2c:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420dc32:	83 f8 02             	cmp    $0x2,%eax
  800420dc35:	74 5f                	je     800420dc96 <sched_halt+0x97>
		     envs[i].env_status == ENV_RUNNING ||
  800420dc37:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  800420dc3e:	00 00 00 
  800420dc41:	48 8b 10             	mov    (%rax),%rdx
  800420dc44:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dc47:	48 98                	cltq   
  800420dc49:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420dc50:	48 01 d0             	add    %rdx,%rax
  800420dc53:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420dc59:	83 f8 03             	cmp    $0x3,%eax
  800420dc5c:	74 38                	je     800420dc96 <sched_halt+0x97>
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
  800420dc5e:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  800420dc65:	00 00 00 
  800420dc68:	48 8b 10             	mov    (%rax),%rdx
  800420dc6b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dc6e:	48 98                	cltq   
  800420dc70:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420dc77:	48 01 d0             	add    %rdx,%rax
  800420dc7a:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
  800420dc80:	83 f8 01             	cmp    $0x1,%eax
  800420dc83:	74 11                	je     800420dc96 <sched_halt+0x97>
{
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420dc85:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420dc89:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420dc90:	0f 8e 7a ff ff ff    	jle    800420dc10 <sched_halt+0x11>
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
			break;
	}
	if (i == NENV) {
  800420dc96:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420dc9d:	75 2e                	jne    800420dccd <sched_halt+0xce>
		cprintf("No runnable environments in the system!\n");
  800420dc9f:	48 bf a0 07 22 04 80 	movabs $0x80042207a0,%rdi
  800420dca6:	00 00 00 
  800420dca9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dcae:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420dcb5:	00 00 00 
  800420dcb8:	ff d2                	callq  *%rdx
		while (1)
			monitor(NULL);
  800420dcba:	bf 00 00 00 00       	mov    $0x0,%edi
  800420dcbf:	48 b8 c0 1a 20 04 80 	movabs $0x8004201ac0,%rax
  800420dcc6:	00 00 00 
  800420dcc9:	ff d0                	callq  *%rax
  800420dccb:	eb ed                	jmp    800420dcba <sched_halt+0xbb>
	}

	// Mark that no environment is running on this CPU
	curenv = NULL;
  800420dccd:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420dcd4:	00 00 00 
  800420dcd7:	ff d0                	callq  *%rax
  800420dcd9:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420dce0:	00 00 00 
  800420dce3:	48 98                	cltq   
  800420dce5:	48 c1 e0 03          	shl    $0x3,%rax
  800420dce9:	48 89 c1             	mov    %rax,%rcx
  800420dcec:	48 c1 e1 04          	shl    $0x4,%rcx
  800420dcf0:	48 01 c8             	add    %rcx,%rax
  800420dcf3:	48 01 d0             	add    %rdx,%rax
  800420dcf6:	48 83 c0 08          	add    $0x8,%rax
  800420dcfa:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	lcr3(PADDR(boot_pml4e));
  800420dd01:	48 b8 f0 c5 6d 04 80 	movabs $0x80046dc5f0,%rax
  800420dd08:	00 00 00 
  800420dd0b:	48 8b 00             	mov    (%rax),%rax
  800420dd0e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420dd12:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420dd19:	00 00 00 
  800420dd1c:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420dd20:	77 32                	ja     800420dd54 <sched_halt+0x155>
  800420dd22:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dd26:	48 89 c1             	mov    %rax,%rcx
  800420dd29:	48 ba d0 07 22 04 80 	movabs $0x80042207d0,%rdx
  800420dd30:	00 00 00 
  800420dd33:	be 75 00 00 00       	mov    $0x75,%esi
  800420dd38:	48 bf f4 07 22 04 80 	movabs $0x80042207f4,%rdi
  800420dd3f:	00 00 00 
  800420dd42:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dd47:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420dd4e:	00 00 00 
  800420dd51:	41 ff d0             	callq  *%r8
  800420dd54:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420dd5b:	ff ff ff 
  800420dd5e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dd62:	48 01 d0             	add    %rdx,%rax
  800420dd65:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420dd69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dd6d:	0f 22 d8             	mov    %rax,%cr3

	// Mark that this CPU is in the HALT state, so that when
	// timer interupts come in, we know we should re-acquire the
	// big kernel lock
	xchg(&thiscpu->cpu_status, CPU_HALTED);
  800420dd70:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420dd77:	00 00 00 
  800420dd7a:	ff d0                	callq  *%rax
  800420dd7c:	48 98                	cltq   
  800420dd7e:	48 c1 e0 03          	shl    $0x3,%rax
  800420dd82:	48 89 c2             	mov    %rax,%rdx
  800420dd85:	48 c1 e2 04          	shl    $0x4,%rdx
  800420dd89:	48 01 d0             	add    %rdx,%rax
  800420dd8c:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420dd93:	00 00 00 
  800420dd96:	48 01 d0             	add    %rdx,%rax
  800420dd99:	48 83 c0 04          	add    $0x4,%rax
  800420dd9d:	be 02 00 00 00       	mov    $0x2,%esi
  800420dda2:	48 89 c7             	mov    %rax,%rdi
  800420dda5:	48 b8 d2 d9 20 04 80 	movabs $0x800420d9d2,%rax
  800420ddac:	00 00 00 
  800420ddaf:	ff d0                	callq  *%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();
  800420ddb1:	48 b8 f7 d9 20 04 80 	movabs $0x800420d9f7,%rax
  800420ddb8:	00 00 00 
  800420ddbb:	ff d0                	callq  *%rax
		"movq %0, %%rsp\n"
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
  800420ddbd:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420ddc4:	00 00 00 
  800420ddc7:	ff d0                	callq  *%rax
  800420ddc9:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420ddd0:	00 00 00 
  800420ddd3:	48 98                	cltq   
  800420ddd5:	48 c1 e0 03          	shl    $0x3,%rax
  800420ddd9:	48 89 c1             	mov    %rax,%rcx
  800420dddc:	48 c1 e1 04          	shl    $0x4,%rcx
  800420dde0:	48 01 c8             	add    %rcx,%rax
  800420dde3:	48 01 d0             	add    %rdx,%rax
  800420dde6:	48 83 c0 10          	add    $0x10,%rax
  800420ddea:	48 8b 40 04          	mov    0x4(%rax),%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();

	// Reset stack pointer, enable interrupts and then halt.
	asm volatile (
  800420ddee:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  800420ddf5:	48 89 c4             	mov    %rax,%rsp
  800420ddf8:	6a 00                	pushq  $0x0
  800420ddfa:	6a 00                	pushq  $0x0
  800420ddfc:	fb                   	sti    
  800420ddfd:	f4                   	hlt    
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
}
  800420ddfe:	90                   	nop
  800420ddff:	c9                   	leaveq 
  800420de00:	c3                   	retq   

000000800420de01 <page2ppn>:
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);


static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  800420de01:	55                   	push   %rbp
  800420de02:	48 89 e5             	mov    %rsp,%rbp
  800420de05:	48 83 ec 08          	sub    $0x8,%rsp
  800420de09:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  800420de0d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420de11:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  800420de18:	00 00 00 
  800420de1b:	48 8b 00             	mov    (%rax),%rax
  800420de1e:	48 29 c2             	sub    %rax,%rdx
  800420de21:	48 89 d0             	mov    %rdx,%rax
  800420de24:	48 c1 f8 04          	sar    $0x4,%rax
}
  800420de28:	c9                   	leaveq 
  800420de29:	c3                   	retq   

000000800420de2a <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  800420de2a:	55                   	push   %rbp
  800420de2b:	48 89 e5             	mov    %rsp,%rbp
  800420de2e:	48 83 ec 08          	sub    $0x8,%rsp
  800420de32:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  800420de36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420de3a:	48 89 c7             	mov    %rax,%rdi
  800420de3d:	48 b8 01 de 20 04 80 	movabs $0x800420de01,%rax
  800420de44:	00 00 00 
  800420de47:	ff d0                	callq  *%rax
  800420de49:	48 c1 e0 0c          	shl    $0xc,%rax
}
  800420de4d:	c9                   	leaveq 
  800420de4e:	c3                   	retq   

000000800420de4f <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  800420de4f:	55                   	push   %rbp
  800420de50:	48 89 e5             	mov    %rsp,%rbp
  800420de53:	48 83 ec 10          	sub    $0x10,%rsp
  800420de57:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  800420de5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420de5f:	48 c1 e8 0c          	shr    $0xc,%rax
  800420de63:	48 89 c2             	mov    %rax,%rdx
  800420de66:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  800420de6d:	00 00 00 
  800420de70:	48 8b 00             	mov    (%rax),%rax
  800420de73:	48 39 c2             	cmp    %rax,%rdx
  800420de76:	72 2a                	jb     800420dea2 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  800420de78:	48 ba 08 08 22 04 80 	movabs $0x8004220808,%rdx
  800420de7f:	00 00 00 
  800420de82:	be 5a 00 00 00       	mov    $0x5a,%esi
  800420de87:	48 bf 27 08 22 04 80 	movabs $0x8004220827,%rdi
  800420de8e:	00 00 00 
  800420de91:	b8 00 00 00 00       	mov    $0x0,%eax
  800420de96:	48 b9 f3 04 20 04 80 	movabs $0x80042004f3,%rcx
  800420de9d:	00 00 00 
  800420dea0:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  800420dea2:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  800420dea9:	00 00 00 
  800420deac:	48 8b 00             	mov    (%rax),%rax
  800420deaf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420deb3:	48 c1 ea 0c          	shr    $0xc,%rdx
  800420deb7:	48 c1 e2 04          	shl    $0x4,%rdx
  800420debb:	48 01 d0             	add    %rdx,%rax
}
  800420debe:	c9                   	leaveq 
  800420debf:	c3                   	retq   

000000800420dec0 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  800420dec0:	55                   	push   %rbp
  800420dec1:	48 89 e5             	mov    %rsp,%rbp
  800420dec4:	48 83 ec 20          	sub    $0x20,%rsp
  800420dec8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  800420decc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ded0:	48 89 c7             	mov    %rax,%rdi
  800420ded3:	48 b8 2a de 20 04 80 	movabs $0x800420de2a,%rax
  800420deda:	00 00 00 
  800420dedd:	ff d0                	callq  *%rax
  800420dedf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420dee3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dee7:	48 c1 e8 0c          	shr    $0xc,%rax
  800420deeb:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800420deee:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420def1:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  800420def8:	00 00 00 
  800420defb:	48 8b 00             	mov    (%rax),%rax
  800420defe:	48 39 c2             	cmp    %rax,%rdx
  800420df01:	72 32                	jb     800420df35 <page2kva+0x75>
  800420df03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420df07:	48 89 c1             	mov    %rax,%rcx
  800420df0a:	48 ba 38 08 22 04 80 	movabs $0x8004220838,%rdx
  800420df11:	00 00 00 
  800420df14:	be 61 00 00 00       	mov    $0x61,%esi
  800420df19:	48 bf 27 08 22 04 80 	movabs $0x8004220827,%rdi
  800420df20:	00 00 00 
  800420df23:	b8 00 00 00 00       	mov    $0x0,%eax
  800420df28:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420df2f:	00 00 00 
  800420df32:	41 ff d0             	callq  *%r8
  800420df35:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420df3c:	00 00 00 
  800420df3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420df43:	48 01 d0             	add    %rdx,%rax
}
  800420df46:	c9                   	leaveq 
  800420df47:	c3                   	retq   

000000800420df48 <sys_cputs>:
// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void
sys_cputs(const char *s, size_t len)
{
  800420df48:	55                   	push   %rbp
  800420df49:	48 89 e5             	mov    %rsp,%rbp
  800420df4c:	48 83 ec 10          	sub    $0x10,%rsp
  800420df50:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420df54:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Check that the user has permission to read memory [s, s+len).
	// Destroy the environment if not.

	// LAB 3: Your code here.

	user_mem_assert(curenv, s, len, PTE_U);
  800420df58:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420df5f:	00 00 00 
  800420df62:	ff d0                	callq  *%rax
  800420df64:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420df6b:	00 00 00 
  800420df6e:	48 98                	cltq   
  800420df70:	48 c1 e0 03          	shl    $0x3,%rax
  800420df74:	48 89 c1             	mov    %rax,%rcx
  800420df77:	48 c1 e1 04          	shl    $0x4,%rcx
  800420df7b:	48 01 c8             	add    %rcx,%rax
  800420df7e:	48 01 d0             	add    %rdx,%rax
  800420df81:	48 83 c0 08          	add    $0x8,%rax
  800420df85:	48 8b 00             	mov    (%rax),%rax
  800420df88:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420df8c:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420df90:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420df95:	48 89 c7             	mov    %rax,%rdi
  800420df98:	48 b8 c8 41 20 04 80 	movabs $0x80042041c8,%rax
  800420df9f:	00 00 00 
  800420dfa2:	ff d0                	callq  *%rax


	// Print the string supplied by the user.
	cprintf("%.*s", len, s);
  800420dfa4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420dfa8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dfac:	48 89 c6             	mov    %rax,%rsi
  800420dfaf:	48 bf 5b 08 22 04 80 	movabs $0x800422085b,%rdi
  800420dfb6:	00 00 00 
  800420dfb9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dfbe:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800420dfc5:	00 00 00 
  800420dfc8:	ff d1                	callq  *%rcx
}
  800420dfca:	90                   	nop
  800420dfcb:	c9                   	leaveq 
  800420dfcc:	c3                   	retq   

000000800420dfcd <sys_cgetc>:

// Read a character from the system console without blocking.
// Returns the character, or 0 if there is no input waiting.
static int
sys_cgetc(void)
{
  800420dfcd:	55                   	push   %rbp
  800420dfce:	48 89 e5             	mov    %rsp,%rbp
	return cons_getc();
  800420dfd1:	48 b8 0c 11 20 04 80 	movabs $0x800420110c,%rax
  800420dfd8:	00 00 00 
  800420dfdb:	ff d0                	callq  *%rax
}
  800420dfdd:	5d                   	pop    %rbp
  800420dfde:	c3                   	retq   

000000800420dfdf <sys_getenvid>:

// Returns the current environment's envid.
static envid_t
sys_getenvid(void)
{
  800420dfdf:	55                   	push   %rbp
  800420dfe0:	48 89 e5             	mov    %rsp,%rbp
	return curenv->env_id;
  800420dfe3:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420dfea:	00 00 00 
  800420dfed:	ff d0                	callq  *%rax
  800420dfef:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420dff6:	00 00 00 
  800420dff9:	48 98                	cltq   
  800420dffb:	48 c1 e0 03          	shl    $0x3,%rax
  800420dfff:	48 89 c1             	mov    %rax,%rcx
  800420e002:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e006:	48 01 c8             	add    %rcx,%rax
  800420e009:	48 01 d0             	add    %rdx,%rax
  800420e00c:	48 83 c0 08          	add    $0x8,%rax
  800420e010:	48 8b 00             	mov    (%rax),%rax
  800420e013:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420e019:	5d                   	pop    %rbp
  800420e01a:	c3                   	retq   

000000800420e01b <sys_env_destroy>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_destroy(envid_t envid)
{
  800420e01b:	55                   	push   %rbp
  800420e01c:	48 89 e5             	mov    %rsp,%rbp
  800420e01f:	48 83 ec 20          	sub    $0x20,%rsp
  800420e023:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420e026:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420e02a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e02d:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e032:	48 89 ce             	mov    %rcx,%rsi
  800420e035:	89 c7                	mov    %eax,%edi
  800420e037:	48 b8 7e 7e 20 04 80 	movabs $0x8004207e7e,%rax
  800420e03e:	00 00 00 
  800420e041:	ff d0                	callq  *%rax
  800420e043:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e046:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e04a:	79 05                	jns    800420e051 <sys_env_destroy+0x36>
		return r;
  800420e04c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e04f:	eb 18                	jmp    800420e069 <sys_env_destroy+0x4e>

	env_destroy(e);
  800420e051:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e055:	48 89 c7             	mov    %rax,%rdi
  800420e058:	48 b8 9f 95 20 04 80 	movabs $0x800420959f,%rax
  800420e05f:	00 00 00 
  800420e062:	ff d0                	callq  *%rax
	return 0;
  800420e064:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420e069:	c9                   	leaveq 
  800420e06a:	c3                   	retq   

000000800420e06b <sys_yield>:


// Deschedule current environment and pick a different one to run.
static void
sys_yield(void)
{
  800420e06b:	55                   	push   %rbp
  800420e06c:	48 89 e5             	mov    %rsp,%rbp
	sched_yield();
  800420e06f:	48 b8 16 da 20 04 80 	movabs $0x800420da16,%rax
  800420e076:	00 00 00 
  800420e079:	ff d0                	callq  *%rax

000000800420e07b <sys_exofork>:
// Returns envid of new environment, or < 0 on error.  Errors are:
//	-E_NO_FREE_ENV if no free environment is available.
//	-E_NO_MEM on memory exhaustion.
static envid_t
sys_exofork(void)
{
  800420e07b:	55                   	push   %rbp
  800420e07c:	48 89 e5             	mov    %rsp,%rbp
  800420e07f:	53                   	push   %rbx
  800420e080:	48 83 ec 18          	sub    $0x18,%rsp

	int r;
	struct Env *e;

	if ((r = env_alloc(&e, curenv->env_id)) < 0)
  800420e084:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420e08b:	00 00 00 
  800420e08e:	ff d0                	callq  *%rax
  800420e090:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420e097:	00 00 00 
  800420e09a:	48 98                	cltq   
  800420e09c:	48 c1 e0 03          	shl    $0x3,%rax
  800420e0a0:	48 89 c1             	mov    %rax,%rcx
  800420e0a3:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e0a7:	48 01 c8             	add    %rcx,%rax
  800420e0aa:	48 01 d0             	add    %rdx,%rax
  800420e0ad:	48 83 c0 08          	add    $0x8,%rax
  800420e0b1:	48 8b 00             	mov    (%rax),%rax
  800420e0b4:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420e0ba:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420e0be:	89 d6                	mov    %edx,%esi
  800420e0c0:	48 89 c7             	mov    %rax,%rdi
  800420e0c3:	48 b8 f7 89 20 04 80 	movabs $0x80042089f7,%rax
  800420e0ca:	00 00 00 
  800420e0cd:	ff d0                	callq  *%rax
  800420e0cf:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420e0d2:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420e0d6:	79 05                	jns    800420e0dd <sys_exofork+0x62>
		return r;
  800420e0d8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e0db:	eb 6c                	jmp    800420e149 <sys_exofork+0xce>
	e->env_status = ENV_NOT_RUNNABLE;
  800420e0dd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e0e1:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420e0e8:	00 00 00 
	e->env_tf = curenv->env_tf;
  800420e0eb:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420e0ef:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420e0f6:	00 00 00 
  800420e0f9:	ff d0                	callq  *%rax
  800420e0fb:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420e102:	00 00 00 
  800420e105:	48 98                	cltq   
  800420e107:	48 c1 e0 03          	shl    $0x3,%rax
  800420e10b:	48 89 c1             	mov    %rax,%rcx
  800420e10e:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e112:	48 01 c8             	add    %rcx,%rax
  800420e115:	48 01 d0             	add    %rdx,%rax
  800420e118:	48 83 c0 08          	add    $0x8,%rax
  800420e11c:	48 8b 00             	mov    (%rax),%rax
  800420e11f:	48 89 da             	mov    %rbx,%rdx
  800420e122:	48 89 c6             	mov    %rax,%rsi
  800420e125:	b8 18 00 00 00       	mov    $0x18,%eax
  800420e12a:	48 89 d7             	mov    %rdx,%rdi
  800420e12d:	48 89 c1             	mov    %rax,%rcx
  800420e130:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	e->env_tf.tf_regs.reg_rax = 0;
  800420e133:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e137:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420e13e:	00 
	return e->env_id;
  800420e13f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e143:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax

}
  800420e149:	48 83 c4 18          	add    $0x18,%rsp
  800420e14d:	5b                   	pop    %rbx
  800420e14e:	5d                   	pop    %rbp
  800420e14f:	c3                   	retq   

000000800420e150 <sys_env_set_status>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if status is not a valid status for an environment.
static int
sys_env_set_status(envid_t envid, int status)
{
  800420e150:	55                   	push   %rbp
  800420e151:	48 89 e5             	mov    %rsp,%rbp
  800420e154:	48 83 ec 20          	sub    $0x20,%rsp
  800420e158:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420e15b:	89 75 e8             	mov    %esi,-0x18(%rbp)

	struct Env *e;
	int r;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420e15e:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420e162:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e165:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e16a:	48 89 ce             	mov    %rcx,%rsi
  800420e16d:	89 c7                	mov    %eax,%edi
  800420e16f:	48 b8 7e 7e 20 04 80 	movabs $0x8004207e7e,%rax
  800420e176:	00 00 00 
  800420e179:	ff d0                	callq  *%rax
  800420e17b:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e17e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e182:	79 05                	jns    800420e189 <sys_env_set_status+0x39>
		return r;
  800420e184:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e187:	eb 25                	jmp    800420e1ae <sys_env_set_status+0x5e>
	if (status != ENV_RUNNABLE && status != ENV_NOT_RUNNABLE)
  800420e189:	83 7d e8 02          	cmpl   $0x2,-0x18(%rbp)
  800420e18d:	74 0d                	je     800420e19c <sys_env_set_status+0x4c>
  800420e18f:	83 7d e8 04          	cmpl   $0x4,-0x18(%rbp)
  800420e193:	74 07                	je     800420e19c <sys_env_set_status+0x4c>
		return -E_INVAL;
  800420e195:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e19a:	eb 12                	jmp    800420e1ae <sys_env_set_status+0x5e>
	e->env_status = status;
  800420e19c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e1a0:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420e1a3:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
	return 0;
  800420e1a9:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420e1ae:	c9                   	leaveq 
  800420e1af:	c3                   	retq   

000000800420e1b0 <sys_env_set_trapframe>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  800420e1b0:	55                   	push   %rbp
  800420e1b1:	48 89 e5             	mov    %rsp,%rbp
  800420e1b4:	48 81 ec e0 00 00 00 	sub    $0xe0,%rsp
  800420e1bb:	89 bd 2c ff ff ff    	mov    %edi,-0xd4(%rbp)
  800420e1c1:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)

	int r;
	struct Env *e;
	struct Trapframe ltf;

	user_mem_assert(curenv, tf, sizeof(struct Trapframe), PTE_U);
  800420e1c8:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420e1cf:	00 00 00 
  800420e1d2:	ff d0                	callq  *%rax
  800420e1d4:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420e1db:	00 00 00 
  800420e1de:	48 98                	cltq   
  800420e1e0:	48 c1 e0 03          	shl    $0x3,%rax
  800420e1e4:	48 89 c1             	mov    %rax,%rcx
  800420e1e7:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e1eb:	48 01 c8             	add    %rcx,%rax
  800420e1ee:	48 01 d0             	add    %rdx,%rax
  800420e1f1:	48 83 c0 08          	add    $0x8,%rax
  800420e1f5:	48 8b 00             	mov    (%rax),%rax
  800420e1f8:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800420e1ff:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420e204:	ba c0 00 00 00       	mov    $0xc0,%edx
  800420e209:	48 89 c7             	mov    %rax,%rdi
  800420e20c:	48 b8 c8 41 20 04 80 	movabs $0x80042041c8,%rax
  800420e213:	00 00 00 
  800420e216:	ff d0                	callq  *%rax
	ltf = *tf;
  800420e218:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
  800420e21f:	48 8d 85 30 ff ff ff 	lea    -0xd0(%rbp),%rax
  800420e226:	48 89 d6             	mov    %rdx,%rsi
  800420e229:	ba 18 00 00 00       	mov    $0x18,%edx
  800420e22e:	48 89 c7             	mov    %rax,%rdi
  800420e231:	48 89 d1             	mov    %rdx,%rcx
  800420e234:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	ltf.tf_eflags |= FL_IF;
  800420e237:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e23b:	80 cc 02             	or     $0x2,%ah
  800420e23e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	ltf.tf_cs |= 3;
  800420e242:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  800420e246:	83 c8 03             	or     $0x3,%eax
  800420e249:	66 89 45 d0          	mov    %ax,-0x30(%rbp)

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420e24d:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420e251:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
  800420e257:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e25c:	48 89 ce             	mov    %rcx,%rsi
  800420e25f:	89 c7                	mov    %eax,%edi
  800420e261:	48 b8 7e 7e 20 04 80 	movabs $0x8004207e7e,%rax
  800420e268:	00 00 00 
  800420e26b:	ff d0                	callq  *%rax
  800420e26d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e270:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e274:	79 05                	jns    800420e27b <sys_env_set_trapframe+0xcb>
		return r;
  800420e276:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e279:	eb 21                	jmp    800420e29c <sys_env_set_trapframe+0xec>
	e->env_tf = ltf;
  800420e27b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e27f:	48 89 c7             	mov    %rax,%rdi
  800420e282:	48 8d 85 30 ff ff ff 	lea    -0xd0(%rbp),%rax
  800420e289:	ba 18 00 00 00       	mov    $0x18,%edx
  800420e28e:	48 89 c6             	mov    %rax,%rsi
  800420e291:	48 89 d1             	mov    %rdx,%rcx
  800420e294:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	return 0;
  800420e297:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420e29c:	c9                   	leaveq 
  800420e29d:	c3                   	retq   

000000800420e29e <sys_env_set_pgfault_upcall>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
  800420e29e:	55                   	push   %rbp
  800420e29f:	48 89 e5             	mov    %rsp,%rbp
  800420e2a2:	48 83 ec 20          	sub    $0x20,%rsp
  800420e2a6:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420e2a9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420e2ad:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420e2b1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e2b4:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e2b9:	48 89 ce             	mov    %rcx,%rsi
  800420e2bc:	89 c7                	mov    %eax,%edi
  800420e2be:	48 b8 7e 7e 20 04 80 	movabs $0x8004207e7e,%rax
  800420e2c5:	00 00 00 
  800420e2c8:	ff d0                	callq  *%rax
  800420e2ca:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e2cd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e2d1:	79 05                	jns    800420e2d8 <sys_env_set_pgfault_upcall+0x3a>
		return r;
  800420e2d3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e2d6:	eb 14                	jmp    800420e2ec <sys_env_set_pgfault_upcall+0x4e>
	e->env_pgfault_upcall = func;
  800420e2d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e2dc:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420e2e0:	48 89 90 f0 00 00 00 	mov    %rdx,0xf0(%rax)
	return 0;
  800420e2e7:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420e2ec:	c9                   	leaveq 
  800420e2ed:	c3                   	retq   

000000800420e2ee <sys_page_alloc>:
//	-E_INVAL if perm is inappropriate (see above).
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  800420e2ee:	55                   	push   %rbp
  800420e2ef:	48 89 e5             	mov    %rsp,%rbp
  800420e2f2:	48 83 ec 30          	sub    $0x30,%rsp
  800420e2f6:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420e2f9:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420e2fd:	89 55 d8             	mov    %edx,-0x28(%rbp)

	int r;
	struct Env *e;
	struct PageInfo *pp;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420e300:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420e304:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420e307:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e30c:	48 89 ce             	mov    %rcx,%rsi
  800420e30f:	89 c7                	mov    %eax,%edi
  800420e311:	48 b8 7e 7e 20 04 80 	movabs $0x8004207e7e,%rax
  800420e318:	00 00 00 
  800420e31b:	ff d0                	callq  *%rax
  800420e31d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e320:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e324:	79 08                	jns    800420e32e <sys_page_alloc+0x40>
		return r;
  800420e326:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e329:	e9 a7 00 00 00       	jmpq   800420e3d5 <sys_page_alloc+0xe7>
	if ((~perm & (PTE_U|PTE_P)) || (perm & ~PTE_SYSCALL))
  800420e32e:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420e331:	f7 d0                	not    %eax
  800420e333:	83 e0 05             	and    $0x5,%eax
  800420e336:	85 c0                	test   %eax,%eax
  800420e338:	75 0c                	jne    800420e346 <sys_page_alloc+0x58>
  800420e33a:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420e33d:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420e342:	85 c0                	test   %eax,%eax
  800420e344:	74 0a                	je     800420e350 <sys_page_alloc+0x62>
		return -E_INVAL;
  800420e346:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e34b:	e9 85 00 00 00       	jmpq   800420e3d5 <sys_page_alloc+0xe7>
	if (va >= (void*) UTOP)
  800420e350:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e357:	00 00 00 
  800420e35a:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420e35e:	76 07                	jbe    800420e367 <sys_page_alloc+0x79>
		return -E_INVAL;
  800420e360:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e365:	eb 6e                	jmp    800420e3d5 <sys_page_alloc+0xe7>
	if (!(pp = page_alloc(ALLOC_ZERO)))
  800420e367:	bf 01 00 00 00       	mov    $0x1,%edi
  800420e36c:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  800420e373:	00 00 00 
  800420e376:	ff d0                	callq  *%rax
  800420e378:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420e37c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420e381:	75 07                	jne    800420e38a <sys_page_alloc+0x9c>
		return -E_NO_MEM;
  800420e383:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420e388:	eb 4b                	jmp    800420e3d5 <sys_page_alloc+0xe7>
	if ((r = page_insert(e->env_pml4e, pp, va, perm)) < 0) {
  800420e38a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e38e:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e395:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  800420e398:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e39c:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420e3a0:	48 89 c7             	mov    %rax,%rdi
  800420e3a3:	48 b8 7d 3a 20 04 80 	movabs $0x8004203a7d,%rax
  800420e3aa:	00 00 00 
  800420e3ad:	ff d0                	callq  *%rax
  800420e3af:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e3b2:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e3b6:	79 18                	jns    800420e3d0 <sys_page_alloc+0xe2>
		page_free(pp);
  800420e3b8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e3bc:	48 89 c7             	mov    %rax,%rdi
  800420e3bf:	48 b8 af 2f 20 04 80 	movabs $0x8004202faf,%rax
  800420e3c6:	00 00 00 
  800420e3c9:	ff d0                	callq  *%rax
		return r;
  800420e3cb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e3ce:	eb 05                	jmp    800420e3d5 <sys_page_alloc+0xe7>
	}
	return 0;
  800420e3d0:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420e3d5:	c9                   	leaveq 
  800420e3d6:	c3                   	retq   

000000800420e3d7 <sys_page_map>:
//		address space.
//	-E_NO_MEM if there's no memory to allocate any necessary page tables.
static int
sys_page_map(envid_t srcenvid, void *srcva,
	     envid_t dstenvid, void *dstva, int perm)
{
  800420e3d7:	55                   	push   %rbp
  800420e3d8:	48 89 e5             	mov    %rsp,%rbp
  800420e3db:	48 83 ec 60          	sub    $0x60,%rsp
  800420e3df:	89 7d bc             	mov    %edi,-0x44(%rbp)
  800420e3e2:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800420e3e6:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420e3e9:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  800420e3ed:	44 89 45 a4          	mov    %r8d,-0x5c(%rbp)
	int r;
	struct Env *es, *ed;
	struct PageInfo *pp;
	pte_t *ppte;

	if (srcva >= (void*) UTOP || dstva >= (void*) UTOP)
  800420e3f1:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e3f8:	00 00 00 
  800420e3fb:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  800420e3ff:	77 10                	ja     800420e411 <sys_page_map+0x3a>
  800420e401:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e408:	00 00 00 
  800420e40b:	48 39 45 a8          	cmp    %rax,-0x58(%rbp)
  800420e40f:	76 0a                	jbe    800420e41b <sys_page_map+0x44>
		return -E_INVAL;
  800420e411:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e416:	e9 3f 01 00 00       	jmpq   800420e55a <sys_page_map+0x183>
	if (srcva != ROUNDDOWN(srcva, PGSIZE) || dstva != ROUNDDOWN(dstva, PGSIZE))
  800420e41b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420e41f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420e423:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e427:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420e42d:	48 3b 45 b0          	cmp    -0x50(%rbp),%rax
  800420e431:	75 18                	jne    800420e44b <sys_page_map+0x74>
  800420e433:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e437:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420e43b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e43f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420e445:	48 3b 45 a8          	cmp    -0x58(%rbp),%rax
  800420e449:	74 0a                	je     800420e455 <sys_page_map+0x7e>
		return -E_INVAL;
  800420e44b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e450:	e9 05 01 00 00       	jmpq   800420e55a <sys_page_map+0x183>

	if ((r = envid2env(srcenvid, &es, 1)) < 0
  800420e455:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800420e459:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420e45c:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e461:	48 89 ce             	mov    %rcx,%rsi
  800420e464:	89 c7                	mov    %eax,%edi
  800420e466:	48 b8 7e 7e 20 04 80 	movabs $0x8004207e7e,%rax
  800420e46d:	00 00 00 
  800420e470:	ff d0                	callq  *%rax
  800420e472:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e475:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e479:	78 26                	js     800420e4a1 <sys_page_map+0xca>
            || (r = envid2env(dstenvid, &ed, 1)) < 0)
  800420e47b:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800420e47f:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e482:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e487:	48 89 ce             	mov    %rcx,%rsi
  800420e48a:	89 c7                	mov    %eax,%edi
  800420e48c:	48 b8 7e 7e 20 04 80 	movabs $0x8004207e7e,%rax
  800420e493:	00 00 00 
  800420e496:	ff d0                	callq  *%rax
  800420e498:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e49b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e49f:	79 08                	jns    800420e4a9 <sys_page_map+0xd2>
		return r;
  800420e4a1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e4a4:	e9 b1 00 00 00       	jmpq   800420e55a <sys_page_map+0x183>
	if ((~perm & (PTE_U|PTE_P)) || (perm & ~PTE_SYSCALL))
  800420e4a9:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800420e4ac:	f7 d0                	not    %eax
  800420e4ae:	83 e0 05             	and    $0x5,%eax
  800420e4b1:	85 c0                	test   %eax,%eax
  800420e4b3:	75 0c                	jne    800420e4c1 <sys_page_map+0xea>
  800420e4b5:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800420e4b8:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420e4bd:	85 c0                	test   %eax,%eax
  800420e4bf:	74 0a                	je     800420e4cb <sys_page_map+0xf4>
		return -E_INVAL;
  800420e4c1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e4c6:	e9 8f 00 00 00       	jmpq   800420e55a <sys_page_map+0x183>
	if ((pp = page_lookup(es->env_pml4e, srcva, &ppte)) == 0)
  800420e4cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e4cf:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e4d6:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  800420e4da:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800420e4de:	48 89 ce             	mov    %rcx,%rsi
  800420e4e1:	48 89 c7             	mov    %rax,%rdi
  800420e4e4:	48 b8 f1 3d 20 04 80 	movabs $0x8004203df1,%rax
  800420e4eb:	00 00 00 
  800420e4ee:	ff d0                	callq  *%rax
  800420e4f0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420e4f4:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420e4f9:	75 07                	jne    800420e502 <sys_page_map+0x12b>
		return -E_INVAL;
  800420e4fb:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e500:	eb 58                	jmp    800420e55a <sys_page_map+0x183>
	if ((perm & PTE_W) && !(*ppte & PTE_W))
  800420e502:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800420e505:	83 e0 02             	and    $0x2,%eax
  800420e508:	85 c0                	test   %eax,%eax
  800420e50a:	74 16                	je     800420e522 <sys_page_map+0x14b>
  800420e50c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e510:	48 8b 00             	mov    (%rax),%rax
  800420e513:	83 e0 02             	and    $0x2,%eax
  800420e516:	48 85 c0             	test   %rax,%rax
  800420e519:	75 07                	jne    800420e522 <sys_page_map+0x14b>
		return -E_INVAL;
  800420e51b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e520:	eb 38                	jmp    800420e55a <sys_page_map+0x183>
	if ((r = page_insert(ed->env_pml4e, pp, dstva, perm)) < 0)
  800420e522:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e526:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e52d:	8b 4d a4             	mov    -0x5c(%rbp),%ecx
  800420e530:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420e534:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420e538:	48 89 c7             	mov    %rax,%rdi
  800420e53b:	48 b8 7d 3a 20 04 80 	movabs $0x8004203a7d,%rax
  800420e542:	00 00 00 
  800420e545:	ff d0                	callq  *%rax
  800420e547:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e54a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e54e:	79 05                	jns    800420e555 <sys_page_map+0x17e>
		return r;
  800420e550:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e553:	eb 05                	jmp    800420e55a <sys_page_map+0x183>
	return 0;
  800420e555:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420e55a:	c9                   	leaveq 
  800420e55b:	c3                   	retq   

000000800420e55c <sys_page_unmap>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int
sys_page_unmap(envid_t envid, void *va)
{
  800420e55c:	55                   	push   %rbp
  800420e55d:	48 89 e5             	mov    %rsp,%rbp
  800420e560:	48 83 ec 20          	sub    $0x20,%rsp
  800420e564:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420e567:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420e56b:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420e56f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e572:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e577:	48 89 ce             	mov    %rcx,%rsi
  800420e57a:	89 c7                	mov    %eax,%edi
  800420e57c:	48 b8 7e 7e 20 04 80 	movabs $0x8004207e7e,%rax
  800420e583:	00 00 00 
  800420e586:	ff d0                	callq  *%rax
  800420e588:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e58b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e58f:	79 05                	jns    800420e596 <sys_page_unmap+0x3a>
		return r;
  800420e591:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e594:	eb 4b                	jmp    800420e5e1 <sys_page_unmap+0x85>
	if (va >= (void*) UTOP || PGOFF(va))
  800420e596:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e59d:	00 00 00 
  800420e5a0:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  800420e5a4:	77 0e                	ja     800420e5b4 <sys_page_unmap+0x58>
  800420e5a6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e5aa:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420e5af:	48 85 c0             	test   %rax,%rax
  800420e5b2:	74 07                	je     800420e5bb <sys_page_unmap+0x5f>
		return -E_INVAL;
  800420e5b4:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e5b9:	eb 26                	jmp    800420e5e1 <sys_page_unmap+0x85>
	page_remove(e->env_pml4e, va);
  800420e5bb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e5bf:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e5c6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420e5ca:	48 89 d6             	mov    %rdx,%rsi
  800420e5cd:	48 89 c7             	mov    %rax,%rdi
  800420e5d0:	48 b8 7c 3e 20 04 80 	movabs $0x8004203e7c,%rax
  800420e5d7:	00 00 00 
  800420e5da:	ff d0                	callq  *%rax
	return 0;
  800420e5dc:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420e5e1:	c9                   	leaveq 
  800420e5e2:	c3                   	retq   

000000800420e5e3 <sys_ipc_try_send>:
//		current environment's address space.
//	-E_NO_MEM if there's not enough memory to map srcva in envid's
//		address space.
static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
  800420e5e3:	55                   	push   %rbp
  800420e5e4:	48 89 e5             	mov    %rsp,%rbp
  800420e5e7:	53                   	push   %rbx
  800420e5e8:	48 83 ec 58          	sub    $0x58,%rsp
  800420e5ec:	89 7d bc             	mov    %edi,-0x44(%rbp)
  800420e5ef:	89 75 b8             	mov    %esi,-0x48(%rbp)
  800420e5f2:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420e5f6:	89 4d ac             	mov    %ecx,-0x54(%rbp)

	int r;
	struct Env *e;
	struct PageInfo *pp;
	pte_t *ppte;    
	if ((r = envid2env(envid, &e, 0)) < 0)
  800420e5f9:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800420e5fd:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420e600:	ba 00 00 00 00       	mov    $0x0,%edx
  800420e605:	48 89 ce             	mov    %rcx,%rsi
  800420e608:	89 c7                	mov    %eax,%edi
  800420e60a:	48 b8 7e 7e 20 04 80 	movabs $0x8004207e7e,%rax
  800420e611:	00 00 00 
  800420e614:	ff d0                	callq  *%rax
  800420e616:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420e619:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420e61d:	79 08                	jns    800420e627 <sys_ipc_try_send+0x44>
		return r;
  800420e61f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e622:	e9 89 06 00 00       	jmpq   800420ecb0 <sys_ipc_try_send+0x6cd>
	if (!e->env_ipc_recving) {
  800420e627:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e62b:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420e632:	83 f0 01             	xor    $0x1,%eax
  800420e635:	84 c0                	test   %al,%al
  800420e637:	74 0a                	je     800420e643 <sys_ipc_try_send+0x60>
		/* cprintf("[%08x] not recieving!\n", e->env_id); */
		return -E_IPC_NOT_RECV;
  800420e639:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  800420e63e:	e9 6d 06 00 00       	jmpq   800420ecb0 <sys_ipc_try_send+0x6cd>
	}
    

	if(curenv->env_type == ENV_TYPE_GUEST && e->env_ipc_dstva < (void*) UTOP) {
  800420e643:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420e64a:	00 00 00 
  800420e64d:	ff d0                	callq  *%rax
  800420e64f:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420e656:	00 00 00 
  800420e659:	48 98                	cltq   
  800420e65b:	48 c1 e0 03          	shl    $0x3,%rax
  800420e65f:	48 89 c1             	mov    %rax,%rcx
  800420e662:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e666:	48 01 c8             	add    %rcx,%rax
  800420e669:	48 01 d0             	add    %rdx,%rax
  800420e66c:	48 83 c0 08          	add    $0x8,%rax
  800420e670:	48 8b 00             	mov    (%rax),%rax
  800420e673:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800420e679:	83 f8 03             	cmp    $0x3,%eax
  800420e67c:	0f 85 7b 01 00 00    	jne    800420e7fd <sys_ipc_try_send+0x21a>
  800420e682:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e686:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420e68d:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e694:	00 00 00 
  800420e697:	48 39 c2             	cmp    %rax,%rdx
  800420e69a:	0f 87 5d 01 00 00    	ja     800420e7fd <sys_ipc_try_send+0x21a>
		// Guest sending a message. srcva is a kernel page.
		/* cprintf("Sending message from a guest\n"); */
		assert(srcva >= (void*)KERNBASE);
  800420e6a0:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420e6a7:	00 00 00 
  800420e6aa:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  800420e6ae:	77 35                	ja     800420e6e5 <sys_ipc_try_send+0x102>
  800420e6b0:	48 b9 60 08 22 04 80 	movabs $0x8004220860,%rcx
  800420e6b7:	00 00 00 
  800420e6ba:	48 ba 79 08 22 04 80 	movabs $0x8004220879,%rdx
  800420e6c1:	00 00 00 
  800420e6c4:	be 63 01 00 00       	mov    $0x163,%esi
  800420e6c9:	48 bf 8e 08 22 04 80 	movabs $0x800422088e,%rdi
  800420e6d0:	00 00 00 
  800420e6d3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e6d8:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420e6df:	00 00 00 
  800420e6e2:	41 ff d0             	callq  *%r8
		pp = pa2page(PADDR(srcva));
  800420e6e5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420e6e9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420e6ed:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420e6f4:	00 00 00 
  800420e6f7:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  800420e6fb:	77 32                	ja     800420e72f <sys_ipc_try_send+0x14c>
  800420e6fd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e701:	48 89 c1             	mov    %rax,%rcx
  800420e704:	48 ba a0 08 22 04 80 	movabs $0x80042208a0,%rdx
  800420e70b:	00 00 00 
  800420e70e:	be 64 01 00 00       	mov    $0x164,%esi
  800420e713:	48 bf 8e 08 22 04 80 	movabs $0x800422088e,%rdi
  800420e71a:	00 00 00 
  800420e71d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e722:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420e729:	00 00 00 
  800420e72c:	41 ff d0             	callq  *%r8
  800420e72f:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420e736:	ff ff ff 
  800420e739:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e73d:	48 01 d0             	add    %rdx,%rax
  800420e740:	48 89 c7             	mov    %rax,%rdi
  800420e743:	48 b8 4f de 20 04 80 	movabs $0x800420de4f,%rax
  800420e74a:	00 00 00 
  800420e74d:	ff d0                	callq  *%rax
  800420e74f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

		r = page_insert(e->env_pml4e, pp, e->env_ipc_dstva, perm);
  800420e753:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  800420e756:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e75a:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420e761:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e765:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e76c:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  800420e770:	48 89 c7             	mov    %rax,%rdi
  800420e773:	48 b8 7d 3a 20 04 80 	movabs $0x8004203a7d,%rax
  800420e77a:	00 00 00 
  800420e77d:	ff d0                	callq  *%rax
  800420e77f:	89 45 ec             	mov    %eax,-0x14(%rbp)
		if (r < 0) {
  800420e782:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420e786:	79 63                	jns    800420e7eb <sys_ipc_try_send+0x208>
			cprintf("[%08x] page_insert %08x failed in sys_ipc_try_send (%e)\n", curenv->env_id, srcva, r);
  800420e788:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420e78f:	00 00 00 
  800420e792:	ff d0                	callq  *%rax
  800420e794:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420e79b:	00 00 00 
  800420e79e:	48 98                	cltq   
  800420e7a0:	48 c1 e0 03          	shl    $0x3,%rax
  800420e7a4:	48 89 c1             	mov    %rax,%rcx
  800420e7a7:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e7ab:	48 01 c8             	add    %rcx,%rax
  800420e7ae:	48 01 d0             	add    %rdx,%rax
  800420e7b1:	48 83 c0 08          	add    $0x8,%rax
  800420e7b5:	48 8b 00             	mov    (%rax),%rax
  800420e7b8:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420e7be:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  800420e7c1:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420e7c5:	89 c6                	mov    %eax,%esi
  800420e7c7:	48 bf c8 08 22 04 80 	movabs $0x80042208c8,%rdi
  800420e7ce:	00 00 00 
  800420e7d1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e7d6:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800420e7dd:	00 00 00 
  800420e7e0:	41 ff d0             	callq  *%r8
			return r;
  800420e7e3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e7e6:	e9 c5 04 00 00       	jmpq   800420ecb0 <sys_ipc_try_send+0x6cd>
		}

		e->env_ipc_perm = perm;
  800420e7eb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e7ef:	8b 55 ac             	mov    -0x54(%rbp),%edx
  800420e7f2:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
  800420e7f8:	e9 22 04 00 00       	jmpq   800420ec1f <sys_ipc_try_send+0x63c>
	} else if(e->env_type == ENV_TYPE_GUEST && srcva < (void*) UTOP) {
  800420e7fd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e801:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800420e807:	83 f8 03             	cmp    $0x3,%eax
  800420e80a:	0f 85 7d 01 00 00    	jne    800420e98d <sys_ipc_try_send+0x3aa>
  800420e810:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e817:	00 00 00 
  800420e81a:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  800420e81e:	0f 87 69 01 00 00    	ja     800420e98d <sys_ipc_try_send+0x3aa>
		// Sending a message to a VMX guest.
		/* cprintf("Sending message to guest\n"); */
		pp = page_lookup(curenv->env_pml4e, srcva, &ppte);
  800420e824:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420e82b:	00 00 00 
  800420e82e:	ff d0                	callq  *%rax
  800420e830:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420e837:	00 00 00 
  800420e83a:	48 98                	cltq   
  800420e83c:	48 c1 e0 03          	shl    $0x3,%rax
  800420e840:	48 89 c1             	mov    %rax,%rcx
  800420e843:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e847:	48 01 c8             	add    %rcx,%rax
  800420e84a:	48 01 d0             	add    %rdx,%rax
  800420e84d:	48 83 c0 08          	add    $0x8,%rax
  800420e851:	48 8b 00             	mov    (%rax),%rax
  800420e854:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e85b:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  800420e85f:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800420e863:	48 89 ce             	mov    %rcx,%rsi
  800420e866:	48 89 c7             	mov    %rax,%rdi
  800420e869:	48 b8 f1 3d 20 04 80 	movabs $0x8004203df1,%rax
  800420e870:	00 00 00 
  800420e873:	ff d0                	callq  *%rax
  800420e875:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		if(pp == 0) {
  800420e879:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420e87e:	75 61                	jne    800420e8e1 <sys_ipc_try_send+0x2fe>
			cprintf("[%08x] page_lookup %08x failed in sys_ipc_try_send\n", curenv->env_id, srcva);
  800420e880:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420e887:	00 00 00 
  800420e88a:	ff d0                	callq  *%rax
  800420e88c:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420e893:	00 00 00 
  800420e896:	48 98                	cltq   
  800420e898:	48 c1 e0 03          	shl    $0x3,%rax
  800420e89c:	48 89 c1             	mov    %rax,%rcx
  800420e89f:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e8a3:	48 01 c8             	add    %rcx,%rax
  800420e8a6:	48 01 d0             	add    %rdx,%rax
  800420e8a9:	48 83 c0 08          	add    $0x8,%rax
  800420e8ad:	48 8b 00             	mov    (%rax),%rax
  800420e8b0:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420e8b6:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420e8ba:	89 c6                	mov    %eax,%esi
  800420e8bc:	48 bf 08 09 22 04 80 	movabs $0x8004220908,%rdi
  800420e8c3:	00 00 00 
  800420e8c6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e8cb:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800420e8d2:	00 00 00 
  800420e8d5:	ff d1                	callq  *%rcx
			return -E_INVAL;
  800420e8d7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e8dc:	e9 cf 03 00 00       	jmpq   800420ecb0 <sys_ipc_try_send+0x6cd>
		}

		if ((perm & PTE_W) && !(*ppte &PTE_W)) {
  800420e8e1:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800420e8e4:	83 e0 02             	and    $0x2,%eax
  800420e8e7:	85 c0                	test   %eax,%eax
  800420e8e9:	74 6c                	je     800420e957 <sys_ipc_try_send+0x374>
  800420e8eb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e8ef:	48 8b 00             	mov    (%rax),%rax
  800420e8f2:	83 e0 02             	and    $0x2,%eax
  800420e8f5:	48 85 c0             	test   %rax,%rax
  800420e8f8:	75 5d                	jne    800420e957 <sys_ipc_try_send+0x374>
			cprintf("[%08x] attempt to send read-only page read-write in sys_ipc_try_send\n", curenv->env_id);
  800420e8fa:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420e901:	00 00 00 
  800420e904:	ff d0                	callq  *%rax
  800420e906:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420e90d:	00 00 00 
  800420e910:	48 98                	cltq   
  800420e912:	48 c1 e0 03          	shl    $0x3,%rax
  800420e916:	48 89 c1             	mov    %rax,%rcx
  800420e919:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e91d:	48 01 c8             	add    %rcx,%rax
  800420e920:	48 01 d0             	add    %rdx,%rax
  800420e923:	48 83 c0 08          	add    $0x8,%rax
  800420e927:	48 8b 00             	mov    (%rax),%rax
  800420e92a:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420e930:	89 c6                	mov    %eax,%esi
  800420e932:	48 bf 40 09 22 04 80 	movabs $0x8004220940,%rdi
  800420e939:	00 00 00 
  800420e93c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e941:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420e948:	00 00 00 
  800420e94b:	ff d2                	callq  *%rdx
			return -E_INVAL;
  800420e94d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e952:	e9 59 03 00 00       	jmpq   800420ecb0 <sys_ipc_try_send+0x6cd>
		}

		// Map the page in guest physical memory.
		// TODO: Fix permissions.
//#ifndef VMM_GUEST
		r = ept_page_insert(e->env_pml4e, pp, e->env_ipc_dstva, __EPTE_FULL);
  800420e957:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e95b:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420e962:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e966:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e96d:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  800420e971:	b9 07 00 00 00       	mov    $0x7,%ecx
  800420e976:	48 89 c7             	mov    %rax,%rdi
  800420e979:	48 b8 ba 9c 21 04 80 	movabs $0x8004219cba,%rax
  800420e980:	00 00 00 
  800420e983:	ff d0                	callq  *%rax
  800420e985:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420e988:	e9 92 02 00 00       	jmpq   800420ec1f <sys_ipc_try_send+0x63c>
//#endif
    
	} else if (srcva < (void*) UTOP && e->env_ipc_dstva < (void*) UTOP) {
  800420e98d:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e994:	00 00 00 
  800420e997:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  800420e99b:	0f 87 70 02 00 00    	ja     800420ec11 <sys_ipc_try_send+0x62e>
  800420e9a1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e9a5:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420e9ac:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e9b3:	00 00 00 
  800420e9b6:	48 39 c2             	cmp    %rax,%rdx
  800420e9b9:	0f 87 52 02 00 00    	ja     800420ec11 <sys_ipc_try_send+0x62e>

			if ((~perm & (PTE_U|PTE_P)) || (perm & ~PTE_SYSCALL)) {
  800420e9bf:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800420e9c2:	f7 d0                	not    %eax
  800420e9c4:	83 e0 05             	and    $0x5,%eax
  800420e9c7:	85 c0                	test   %eax,%eax
  800420e9c9:	75 0c                	jne    800420e9d7 <sys_ipc_try_send+0x3f4>
  800420e9cb:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800420e9ce:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420e9d3:	85 c0                	test   %eax,%eax
  800420e9d5:	74 60                	je     800420ea37 <sys_ipc_try_send+0x454>
				cprintf("[%08x] bad perm %x in sys_ipc_try_send\n", curenv->env_id, perm);
  800420e9d7:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420e9de:	00 00 00 
  800420e9e1:	ff d0                	callq  *%rax
  800420e9e3:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420e9ea:	00 00 00 
  800420e9ed:	48 98                	cltq   
  800420e9ef:	48 c1 e0 03          	shl    $0x3,%rax
  800420e9f3:	48 89 c1             	mov    %rax,%rcx
  800420e9f6:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e9fa:	48 01 c8             	add    %rcx,%rax
  800420e9fd:	48 01 d0             	add    %rdx,%rax
  800420ea00:	48 83 c0 08          	add    $0x8,%rax
  800420ea04:	48 8b 00             	mov    (%rax),%rax
  800420ea07:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420ea0d:	8b 55 ac             	mov    -0x54(%rbp),%edx
  800420ea10:	89 c6                	mov    %eax,%esi
  800420ea12:	48 bf 88 09 22 04 80 	movabs $0x8004220988,%rdi
  800420ea19:	00 00 00 
  800420ea1c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ea21:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800420ea28:	00 00 00 
  800420ea2b:	ff d1                	callq  *%rcx
				return -E_INVAL;
  800420ea2d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ea32:	e9 79 02 00 00       	jmpq   800420ecb0 <sys_ipc_try_send+0x6cd>
			}

			pp = page_lookup(curenv->env_pml4e, srcva, &ppte);
  800420ea37:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420ea3e:	00 00 00 
  800420ea41:	ff d0                	callq  *%rax
  800420ea43:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420ea4a:	00 00 00 
  800420ea4d:	48 98                	cltq   
  800420ea4f:	48 c1 e0 03          	shl    $0x3,%rax
  800420ea53:	48 89 c1             	mov    %rax,%rcx
  800420ea56:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ea5a:	48 01 c8             	add    %rcx,%rax
  800420ea5d:	48 01 d0             	add    %rdx,%rax
  800420ea60:	48 83 c0 08          	add    $0x8,%rax
  800420ea64:	48 8b 00             	mov    (%rax),%rax
  800420ea67:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420ea6e:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  800420ea72:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800420ea76:	48 89 ce             	mov    %rcx,%rsi
  800420ea79:	48 89 c7             	mov    %rax,%rdi
  800420ea7c:	48 b8 f1 3d 20 04 80 	movabs $0x8004203df1,%rax
  800420ea83:	00 00 00 
  800420ea86:	ff d0                	callq  *%rax
  800420ea88:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
			if (pp == 0) {
  800420ea8c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420ea91:	75 61                	jne    800420eaf4 <sys_ipc_try_send+0x511>
				cprintf("[%08x] page_lookup %08x failed in sys_ipc_try_send\n", curenv->env_id, srcva);
  800420ea93:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420ea9a:	00 00 00 
  800420ea9d:	ff d0                	callq  *%rax
  800420ea9f:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420eaa6:	00 00 00 
  800420eaa9:	48 98                	cltq   
  800420eaab:	48 c1 e0 03          	shl    $0x3,%rax
  800420eaaf:	48 89 c1             	mov    %rax,%rcx
  800420eab2:	48 c1 e1 04          	shl    $0x4,%rcx
  800420eab6:	48 01 c8             	add    %rcx,%rax
  800420eab9:	48 01 d0             	add    %rdx,%rax
  800420eabc:	48 83 c0 08          	add    $0x8,%rax
  800420eac0:	48 8b 00             	mov    (%rax),%rax
  800420eac3:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420eac9:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420eacd:	89 c6                	mov    %eax,%esi
  800420eacf:	48 bf 08 09 22 04 80 	movabs $0x8004220908,%rdi
  800420ead6:	00 00 00 
  800420ead9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420eade:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800420eae5:	00 00 00 
  800420eae8:	ff d1                	callq  *%rcx
				return -E_INVAL;
  800420eaea:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420eaef:	e9 bc 01 00 00       	jmpq   800420ecb0 <sys_ipc_try_send+0x6cd>
			}

			if ((perm & PTE_W) && !(*ppte & PTE_W)) {
  800420eaf4:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800420eaf7:	83 e0 02             	and    $0x2,%eax
  800420eafa:	85 c0                	test   %eax,%eax
  800420eafc:	74 6c                	je     800420eb6a <sys_ipc_try_send+0x587>
  800420eafe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420eb02:	48 8b 00             	mov    (%rax),%rax
  800420eb05:	83 e0 02             	and    $0x2,%eax
  800420eb08:	48 85 c0             	test   %rax,%rax
  800420eb0b:	75 5d                	jne    800420eb6a <sys_ipc_try_send+0x587>
				cprintf("[%08x] attempt to send read-only page read-write in sys_ipc_try_send\n", curenv->env_id);
  800420eb0d:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420eb14:	00 00 00 
  800420eb17:	ff d0                	callq  *%rax
  800420eb19:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420eb20:	00 00 00 
  800420eb23:	48 98                	cltq   
  800420eb25:	48 c1 e0 03          	shl    $0x3,%rax
  800420eb29:	48 89 c1             	mov    %rax,%rcx
  800420eb2c:	48 c1 e1 04          	shl    $0x4,%rcx
  800420eb30:	48 01 c8             	add    %rcx,%rax
  800420eb33:	48 01 d0             	add    %rdx,%rax
  800420eb36:	48 83 c0 08          	add    $0x8,%rax
  800420eb3a:	48 8b 00             	mov    (%rax),%rax
  800420eb3d:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420eb43:	89 c6                	mov    %eax,%esi
  800420eb45:	48 bf 40 09 22 04 80 	movabs $0x8004220940,%rdi
  800420eb4c:	00 00 00 
  800420eb4f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420eb54:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800420eb5b:	00 00 00 
  800420eb5e:	ff d2                	callq  *%rdx
				return -E_INVAL;
  800420eb60:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420eb65:	e9 46 01 00 00       	jmpq   800420ecb0 <sys_ipc_try_send+0x6cd>
			}

			r = page_insert(e->env_pml4e, pp, e->env_ipc_dstva, perm);
  800420eb6a:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  800420eb6d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420eb71:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420eb78:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420eb7c:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420eb83:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  800420eb87:	48 89 c7             	mov    %rax,%rdi
  800420eb8a:	48 b8 7d 3a 20 04 80 	movabs $0x8004203a7d,%rax
  800420eb91:	00 00 00 
  800420eb94:	ff d0                	callq  *%rax
  800420eb96:	89 45 ec             	mov    %eax,-0x14(%rbp)
			if (r < 0) {
  800420eb99:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420eb9d:	79 63                	jns    800420ec02 <sys_ipc_try_send+0x61f>
				cprintf("[%08x] page_insert %08x failed in sys_ipc_try_send (%e)\n", curenv->env_id, srcva, r);
  800420eb9f:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420eba6:	00 00 00 
  800420eba9:	ff d0                	callq  *%rax
  800420ebab:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420ebb2:	00 00 00 
  800420ebb5:	48 98                	cltq   
  800420ebb7:	48 c1 e0 03          	shl    $0x3,%rax
  800420ebbb:	48 89 c1             	mov    %rax,%rcx
  800420ebbe:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ebc2:	48 01 c8             	add    %rcx,%rax
  800420ebc5:	48 01 d0             	add    %rdx,%rax
  800420ebc8:	48 83 c0 08          	add    $0x8,%rax
  800420ebcc:	48 8b 00             	mov    (%rax),%rax
  800420ebcf:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420ebd5:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  800420ebd8:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420ebdc:	89 c6                	mov    %eax,%esi
  800420ebde:	48 bf c8 08 22 04 80 	movabs $0x80042208c8,%rdi
  800420ebe5:	00 00 00 
  800420ebe8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ebed:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800420ebf4:	00 00 00 
  800420ebf7:	41 ff d0             	callq  *%r8
				return r;
  800420ebfa:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ebfd:	e9 ae 00 00 00       	jmpq   800420ecb0 <sys_ipc_try_send+0x6cd>
			}

			e->env_ipc_perm = perm;
  800420ec02:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ec06:	8b 55 ac             	mov    -0x54(%rbp),%edx
  800420ec09:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
  800420ec0f:	eb 0e                	jmp    800420ec1f <sys_ipc_try_send+0x63c>
		} else {
			e->env_ipc_perm = 0;
  800420ec11:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ec15:	c7 80 10 01 00 00 00 	movl   $0x0,0x110(%rax)
  800420ec1c:	00 00 00 
		}

		e->env_ipc_recving = 0;
  800420ec1f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ec23:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)
		e->env_ipc_from = curenv->env_id;
  800420ec2a:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
  800420ec2e:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420ec35:	00 00 00 
  800420ec38:	ff d0                	callq  *%rax
  800420ec3a:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420ec41:	00 00 00 
  800420ec44:	48 98                	cltq   
  800420ec46:	48 c1 e0 03          	shl    $0x3,%rax
  800420ec4a:	48 89 c1             	mov    %rax,%rcx
  800420ec4d:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ec51:	48 01 c8             	add    %rcx,%rax
  800420ec54:	48 01 d0             	add    %rdx,%rax
  800420ec57:	48 83 c0 08          	add    $0x8,%rax
  800420ec5b:	48 8b 00             	mov    (%rax),%rax
  800420ec5e:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420ec64:	89 83 0c 01 00 00    	mov    %eax,0x10c(%rbx)
		e->env_ipc_value = value;
  800420ec6a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ec6e:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420ec71:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
		e->env_tf.tf_regs.reg_rax = 0;
  800420ec77:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ec7b:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420ec82:	00 
		e->env_status = ENV_RUNNABLE;
  800420ec83:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ec87:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420ec8e:	00 00 00 

		if(e->env_type == ENV_TYPE_GUEST) {
  800420ec91:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ec95:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800420ec9b:	83 f8 03             	cmp    $0x3,%eax
  800420ec9e:	75 0b                	jne    800420ecab <sys_ipc_try_send+0x6c8>
			e->env_tf.tf_regs.reg_rsi = value;
  800420eca0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420eca4:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420eca7:	48 89 50 40          	mov    %rdx,0x40(%rax)
		}

		return 0;
  800420ecab:	b8 00 00 00 00       	mov    $0x0,%eax

	}
  800420ecb0:	48 83 c4 58          	add    $0x58,%rsp
  800420ecb4:	5b                   	pop    %rbx
  800420ecb5:	5d                   	pop    %rbp
  800420ecb6:	c3                   	retq   

000000800420ecb7 <sys_ipc_recv>:
// return 0 on success.
// Return < 0 on error.  Errors are:
//	-E_INVAL if dstva < UTOP but dstva is not page-aligned.
static int
sys_ipc_recv(void *dstva)
{
  800420ecb7:	55                   	push   %rbp
  800420ecb8:	48 89 e5             	mov    %rsp,%rbp
  800420ecbb:	48 83 ec 10          	sub    $0x10,%rsp
  800420ecbf:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

	if (curenv->env_ipc_recving)
  800420ecc3:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420ecca:	00 00 00 
  800420eccd:	ff d0                	callq  *%rax
  800420eccf:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420ecd6:	00 00 00 
  800420ecd9:	48 98                	cltq   
  800420ecdb:	48 c1 e0 03          	shl    $0x3,%rax
  800420ecdf:	48 89 c1             	mov    %rax,%rcx
  800420ece2:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ece6:	48 01 c8             	add    %rcx,%rax
  800420ece9:	48 01 d0             	add    %rdx,%rax
  800420ecec:	48 83 c0 08          	add    $0x8,%rax
  800420ecf0:	48 8b 00             	mov    (%rax),%rax
  800420ecf3:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420ecfa:	84 c0                	test   %al,%al
  800420ecfc:	74 2a                	je     800420ed28 <sys_ipc_recv+0x71>
		panic("already recving!");
  800420ecfe:	48 ba b0 09 22 04 80 	movabs $0x80042209b0,%rdx
  800420ed05:	00 00 00 
  800420ed08:	be bc 01 00 00       	mov    $0x1bc,%esi
  800420ed0d:	48 bf 8e 08 22 04 80 	movabs $0x800422088e,%rdi
  800420ed14:	00 00 00 
  800420ed17:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ed1c:	48 b9 f3 04 20 04 80 	movabs $0x80042004f3,%rcx
  800420ed23:	00 00 00 
  800420ed26:	ff d1                	callq  *%rcx
	
	curenv->env_ipc_recving = 1;
  800420ed28:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420ed2f:	00 00 00 
  800420ed32:	ff d0                	callq  *%rax
  800420ed34:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420ed3b:	00 00 00 
  800420ed3e:	48 98                	cltq   
  800420ed40:	48 c1 e0 03          	shl    $0x3,%rax
  800420ed44:	48 89 c1             	mov    %rax,%rcx
  800420ed47:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ed4b:	48 01 c8             	add    %rcx,%rax
  800420ed4e:	48 01 d0             	add    %rdx,%rax
  800420ed51:	48 83 c0 08          	add    $0x8,%rax
  800420ed55:	48 8b 00             	mov    (%rax),%rax
  800420ed58:	c6 80 f8 00 00 00 01 	movb   $0x1,0xf8(%rax)
	curenv->env_ipc_dstva = dstva;
  800420ed5f:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420ed66:	00 00 00 
  800420ed69:	ff d0                	callq  *%rax
  800420ed6b:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420ed72:	00 00 00 
  800420ed75:	48 98                	cltq   
  800420ed77:	48 c1 e0 03          	shl    $0x3,%rax
  800420ed7b:	48 89 c1             	mov    %rax,%rcx
  800420ed7e:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ed82:	48 01 c8             	add    %rcx,%rax
  800420ed85:	48 01 d0             	add    %rdx,%rax
  800420ed88:	48 83 c0 08          	add    $0x8,%rax
  800420ed8c:	48 8b 00             	mov    (%rax),%rax
  800420ed8f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ed93:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)
	curenv->env_status = ENV_NOT_RUNNABLE;
  800420ed9a:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420eda1:	00 00 00 
  800420eda4:	ff d0                	callq  *%rax
  800420eda6:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420edad:	00 00 00 
  800420edb0:	48 98                	cltq   
  800420edb2:	48 c1 e0 03          	shl    $0x3,%rax
  800420edb6:	48 89 c1             	mov    %rax,%rcx
  800420edb9:	48 c1 e1 04          	shl    $0x4,%rcx
  800420edbd:	48 01 c8             	add    %rcx,%rax
  800420edc0:	48 01 d0             	add    %rdx,%rax
  800420edc3:	48 83 c0 08          	add    $0x8,%rax
  800420edc7:	48 8b 00             	mov    (%rax),%rax
  800420edca:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420edd1:	00 00 00 
	sched_yield();
  800420edd4:	48 b8 16 da 20 04 80 	movabs $0x800420da16,%rax
  800420eddb:	00 00 00 
  800420edde:	ff d0                	callq  *%rax

000000800420ede0 <sys_time_msec>:


// Return the current time.
static int
sys_time_msec(void)
{
  800420ede0:	55                   	push   %rbp
  800420ede1:	48 89 e5             	mov    %rsp,%rbp

	return (int) time_msec();
  800420ede4:	48 b8 ad 97 21 04 80 	movabs $0x80042197ad,%rax
  800420edeb:	00 00 00 
  800420edee:	ff d0                	callq  *%rax

}
  800420edf0:	5d                   	pop    %rbp
  800420edf1:	c3                   	retq   

000000800420edf2 <sys_net_transmit>:



static int
sys_net_transmit(const void *data, size_t len)
{
  800420edf2:	55                   	push   %rbp
  800420edf3:	48 89 e5             	mov    %rsp,%rbp
  800420edf6:	48 83 ec 10          	sub    $0x10,%rsp
  800420edfa:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420edfe:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	user_mem_assert(curenv, data, len, 0);
  800420ee02:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420ee09:	00 00 00 
  800420ee0c:	ff d0                	callq  *%rax
  800420ee0e:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420ee15:	00 00 00 
  800420ee18:	48 98                	cltq   
  800420ee1a:	48 c1 e0 03          	shl    $0x3,%rax
  800420ee1e:	48 89 c1             	mov    %rax,%rcx
  800420ee21:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ee25:	48 01 c8             	add    %rcx,%rax
  800420ee28:	48 01 d0             	add    %rdx,%rax
  800420ee2b:	48 83 c0 08          	add    $0x8,%rax
  800420ee2f:	48 8b 00             	mov    (%rax),%rax
  800420ee32:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420ee36:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420ee3a:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420ee3f:	48 89 c7             	mov    %rax,%rdi
  800420ee42:	48 b8 c8 41 20 04 80 	movabs $0x80042041c8,%rax
  800420ee49:	00 00 00 
  800420ee4c:	ff d0                	callq  *%rax
	return e1000_transmit(data, len);
  800420ee4e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee52:	89 c2                	mov    %eax,%edx
  800420ee54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ee58:	89 d6                	mov    %edx,%esi
  800420ee5a:	48 89 c7             	mov    %rax,%rdi
  800420ee5d:	48 b8 13 89 21 04 80 	movabs $0x8004218913,%rax
  800420ee64:	00 00 00 
  800420ee67:	ff d0                	callq  *%rax
}
  800420ee69:	c9                   	leaveq 
  800420ee6a:	c3                   	retq   

000000800420ee6b <sys_net_receive>:

static int
sys_net_receive(void *buf, size_t len)
{
  800420ee6b:	55                   	push   %rbp
  800420ee6c:	48 89 e5             	mov    %rsp,%rbp
  800420ee6f:	48 83 ec 10          	sub    $0x10,%rsp
  800420ee73:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ee77:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	user_mem_assert(curenv, buf, len, PTE_W);
  800420ee7b:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420ee82:	00 00 00 
  800420ee85:	ff d0                	callq  *%rax
  800420ee87:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420ee8e:	00 00 00 
  800420ee91:	48 98                	cltq   
  800420ee93:	48 c1 e0 03          	shl    $0x3,%rax
  800420ee97:	48 89 c1             	mov    %rax,%rcx
  800420ee9a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ee9e:	48 01 c8             	add    %rcx,%rax
  800420eea1:	48 01 d0             	add    %rdx,%rax
  800420eea4:	48 83 c0 08          	add    $0x8,%rax
  800420eea8:	48 8b 00             	mov    (%rax),%rax
  800420eeab:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420eeaf:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420eeb3:	b9 02 00 00 00       	mov    $0x2,%ecx
  800420eeb8:	48 89 c7             	mov    %rax,%rdi
  800420eebb:	48 b8 c8 41 20 04 80 	movabs $0x80042041c8,%rax
  800420eec2:	00 00 00 
  800420eec5:	ff d0                	callq  *%rax
	return e1000_receive(buf, len);
  800420eec7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eecb:	89 c2                	mov    %eax,%edx
  800420eecd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420eed1:	89 d6                	mov    %edx,%esi
  800420eed3:	48 89 c7             	mov    %rax,%rdi
  800420eed6:	48 b8 93 8a 21 04 80 	movabs $0x8004218a93,%rax
  800420eedd:	00 00 00 
  800420eee0:	ff d0                	callq  *%rax
}
  800420eee2:	c9                   	leaveq 
  800420eee3:	c3                   	retq   

000000800420eee4 <sys_vmx_list_vms>:



//#ifndef VMM_GUEST
static void
sys_vmx_list_vms() {
  800420eee4:	55                   	push   %rbp
  800420eee5:	48 89 e5             	mov    %rsp,%rbp
	vmx_list_vms();
  800420eee8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420eeed:	48 ba 7b a1 21 04 80 	movabs $0x800421a17b,%rdx
  800420eef4:	00 00 00 
  800420eef7:	ff d2                	callq  *%rdx
}
  800420eef9:	90                   	nop
  800420eefa:	5d                   	pop    %rbp
  800420eefb:	c3                   	retq   

000000800420eefc <sys_vmx_sel_resume>:

static bool
sys_vmx_sel_resume(int i) {
  800420eefc:	55                   	push   %rbp
  800420eefd:	48 89 e5             	mov    %rsp,%rbp
  800420ef00:	48 83 ec 10          	sub    $0x10,%rsp
  800420ef04:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return vmx_sel_resume(i);
  800420ef07:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420ef0a:	89 c7                	mov    %eax,%edi
  800420ef0c:	48 b8 3c a2 21 04 80 	movabs $0x800421a23c,%rax
  800420ef13:	00 00 00 
  800420ef16:	ff d0                	callq  *%rax
}
  800420ef18:	c9                   	leaveq 
  800420ef19:	c3                   	retq   

000000800420ef1a <sys_vmx_get_vmdisk_number>:

static int
sys_vmx_get_vmdisk_number() {
  800420ef1a:	55                   	push   %rbp
  800420ef1b:	48 89 e5             	mov    %rsp,%rbp
	return vmx_get_vmdisk_number();
  800420ef1e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ef23:	48 ba ae e0 21 04 80 	movabs $0x800421e0ae,%rdx
  800420ef2a:	00 00 00 
  800420ef2d:	ff d2                	callq  *%rdx
}
  800420ef2f:	5d                   	pop    %rbp
  800420ef30:	c3                   	retq   

000000800420ef31 <sys_vmx_incr_vmdisk_number>:

static void
sys_vmx_incr_vmdisk_number() {
  800420ef31:	55                   	push   %rbp
  800420ef32:	48 89 e5             	mov    %rsp,%rbp
	vmx_incr_vmdisk_number();
  800420ef35:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ef3a:	48 ba c0 e0 21 04 80 	movabs $0x800421e0c0,%rdx
  800420ef41:	00 00 00 
  800420ef44:	ff d2                	callq  *%rdx
}
  800420ef46:	90                   	nop
  800420ef47:	5d                   	pop    %rbp
  800420ef48:	c3                   	retq   

000000800420ef49 <sys_ept_map>:
//       env_pml4e to store the root of the extended page tables.
// 
static int
sys_ept_map(envid_t srcenvid, void *srcva,
	    envid_t guest, void* guest_pa, int perm)
{
  800420ef49:	55                   	push   %rbp
  800420ef4a:	48 89 e5             	mov    %rsp,%rbp
  800420ef4d:	48 83 ec 50          	sub    $0x50,%rsp
  800420ef51:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420ef54:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420ef58:	89 55 c8             	mov    %edx,-0x38(%rbp)
  800420ef5b:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  800420ef5f:	44 89 45 b4          	mov    %r8d,-0x4c(%rbp)
	struct Env *src_env_store = NULL;
  800420ef63:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  800420ef6a:	00 
	struct Env *guest_env_store = NULL;
  800420ef6b:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  800420ef72:	00 
	pte_t **pte_store = NULL;
  800420ef73:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420ef7a:	00 
	struct PageInfo *pp = NULL;
  800420ef7b:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420ef82:	00 
	
	if (envid2env(srcenvid, &src_env_store, 1) < 0 || 
  800420ef83:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800420ef87:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420ef8a:	ba 01 00 00 00       	mov    $0x1,%edx
  800420ef8f:	48 89 ce             	mov    %rcx,%rsi
  800420ef92:	89 c7                	mov    %eax,%edi
  800420ef94:	48 b8 7e 7e 20 04 80 	movabs $0x8004207e7e,%rax
  800420ef9b:	00 00 00 
  800420ef9e:	ff d0                	callq  *%rax
  800420efa0:	85 c0                	test   %eax,%eax
  800420efa2:	78 21                	js     800420efc5 <sys_ept_map+0x7c>
			envid2env(guest, &guest_env_store, 1) < 0)
  800420efa4:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800420efa8:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420efab:	ba 01 00 00 00       	mov    $0x1,%edx
  800420efb0:	48 89 ce             	mov    %rcx,%rsi
  800420efb3:	89 c7                	mov    %eax,%edi
  800420efb5:	48 b8 7e 7e 20 04 80 	movabs $0x8004207e7e,%rax
  800420efbc:	00 00 00 
  800420efbf:	ff d0                	callq  *%rax
	struct Env *src_env_store = NULL;
	struct Env *guest_env_store = NULL;
	pte_t **pte_store = NULL;
	struct PageInfo *pp = NULL;
	
	if (envid2env(srcenvid, &src_env_store, 1) < 0 || 
  800420efc1:	85 c0                	test   %eax,%eax
  800420efc3:	79 0a                	jns    800420efcf <sys_ept_map+0x86>
			envid2env(guest, &guest_env_store, 1) < 0)
		return -E_BAD_ENV;
  800420efc5:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420efca:	e9 3d 01 00 00       	jmpq   800420f10c <sys_ept_map+0x1c3>

	if (srcva >= (void *)UTOP || (uint64_t)srcva % PGSIZE != 0)
  800420efcf:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420efd6:	00 00 00 
  800420efd9:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  800420efdd:	77 0e                	ja     800420efed <sys_ept_map+0xa4>
  800420efdf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420efe3:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420efe8:	48 85 c0             	test   %rax,%rax
  800420efeb:	74 0a                	je     800420eff7 <sys_ept_map+0xae>
		return -E_INVAL;
  800420efed:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420eff2:	e9 15 01 00 00       	jmpq   800420f10c <sys_ept_map+0x1c3>

	if (guest_env_store->env_vmxinfo.vmcs == 0)
  800420eff7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420effb:	48 8b 80 28 01 00 00 	mov    0x128(%rax),%rax
  800420f002:	48 85 c0             	test   %rax,%rax
  800420f005:	75 0a                	jne    800420f011 <sys_ept_map+0xc8>
		return -E_BAD_ENV;
  800420f007:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420f00c:	e9 fb 00 00 00       	jmpq   800420f10c <sys_ept_map+0x1c3>

	if (guest_pa >= (void *)(guest_env_store->env_vmxinfo).phys_sz|| ROUNDUP(guest_pa, PGSIZE) != guest_pa)
  800420f011:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f015:	48 8b 80 20 01 00 00 	mov    0x120(%rax),%rax
  800420f01c:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  800420f020:	76 35                	jbe    800420f057 <sys_ept_map+0x10e>
  800420f022:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  800420f029:	00 
  800420f02a:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420f02e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f032:	48 01 d0             	add    %rdx,%rax
  800420f035:	48 83 e8 01          	sub    $0x1,%rax
  800420f039:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420f03d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f041:	ba 00 00 00 00       	mov    $0x0,%edx
  800420f046:	48 f7 75 e8          	divq   -0x18(%rbp)
  800420f04a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f04e:	48 29 d0             	sub    %rdx,%rax
  800420f051:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  800420f055:	74 0a                	je     800420f061 <sys_ept_map+0x118>
		return -E_INVAL;
  800420f057:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420f05c:	e9 ab 00 00 00       	jmpq   800420f10c <sys_ept_map+0x1c3>
	
	if ((perm & __EPTE_READ) == 0)
  800420f061:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420f064:	83 e0 01             	and    $0x1,%eax
  800420f067:	85 c0                	test   %eax,%eax
  800420f069:	75 0a                	jne    800420f075 <sys_ept_map+0x12c>
		return -E_INVAL; 
  800420f06b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420f070:	e9 97 00 00 00       	jmpq   800420f10c <sys_ept_map+0x1c3>

	if ((pp = page_lookup(src_env_store->env_pml4e, srcva, pte_store)) == NULL)
  800420f075:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f079:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420f080:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420f084:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420f088:	48 89 ce             	mov    %rcx,%rsi
  800420f08b:	48 89 c7             	mov    %rax,%rdi
  800420f08e:	48 b8 f1 3d 20 04 80 	movabs $0x8004203df1,%rax
  800420f095:	00 00 00 
  800420f098:	ff d0                	callq  *%rax
  800420f09a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420f09e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420f0a3:	75 07                	jne    800420f0ac <sys_ept_map+0x163>
		return -E_INVAL;
  800420f0a5:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420f0aa:	eb 60                	jmp    800420f10c <sys_ept_map+0x1c3>

	/*if ((perm & PTE_W) && (((uint64_t)srcva & PTE_W == 0) && (uint64_t)srcva & PTE_R))
		return -E_INVAL;
*/
	if (ept_map_hva2gpa(guest_env_store->env_pml4e,(void *)page2kva(pp), guest_pa, perm, 0) < 0)
  800420f0ac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f0b0:	48 89 c7             	mov    %rax,%rdi
  800420f0b3:	48 b8 c0 de 20 04 80 	movabs $0x800420dec0,%rax
  800420f0ba:	00 00 00 
  800420f0bd:	ff d0                	callq  *%rax
  800420f0bf:	48 89 c6             	mov    %rax,%rsi
  800420f0c2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f0c6:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420f0cd:	8b 4d b4             	mov    -0x4c(%rbp),%ecx
  800420f0d0:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420f0d4:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420f0da:	48 89 c7             	mov    %rax,%rdi
  800420f0dd:	48 b8 9c 9d 21 04 80 	movabs $0x8004219d9c,%rax
  800420f0e4:	00 00 00 
  800420f0e7:	ff d0                	callq  *%rax
  800420f0e9:	85 c0                	test   %eax,%eax
  800420f0eb:	79 07                	jns    800420f0f4 <sys_ept_map+0x1ab>
		return -E_NO_MEM; 
  800420f0ed:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420f0f2:	eb 18                	jmp    800420f10c <sys_ept_map+0x1c3>
	
	pp->pp_ref += 1;
  800420f0f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f0f8:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420f0fc:	8d 50 01             	lea    0x1(%rax),%edx
  800420f0ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f103:	66 89 50 08          	mov    %dx,0x8(%rax)
	 
	return 0;
  800420f107:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420f10c:	c9                   	leaveq 
  800420f10d:	c3                   	retq   

000000800420f10e <sys_env_mkguest>:

static envid_t
sys_env_mkguest(uint64_t gphysz, uint64_t gRIP) {
  800420f10e:	55                   	push   %rbp
  800420f10f:	48 89 e5             	mov    %rsp,%rbp
  800420f112:	48 83 ec 20          	sub    $0x20,%rsp
  800420f116:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f11a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int r;
	struct Env *e;

	// Check if the processor has VMX support.
	if ( !vmx_check_support() ) {
  800420f11e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f123:	48 ba 12 a3 21 04 80 	movabs $0x800421a312,%rdx
  800420f12a:	00 00 00 
  800420f12d:	ff d2                	callq  *%rdx
  800420f12f:	83 f0 01             	xor    $0x1,%eax
  800420f132:	84 c0                	test   %al,%al
  800420f134:	74 0a                	je     800420f140 <sys_env_mkguest+0x32>
		return -E_NO_VMX;
  800420f136:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
  800420f13b:	e9 b1 00 00 00       	jmpq   800420f1f1 <sys_env_mkguest+0xe3>
	} else if ( !vmx_check_ept() ) {
  800420f140:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f145:	48 ba 48 a3 21 04 80 	movabs $0x800421a348,%rdx
  800420f14c:	00 00 00 
  800420f14f:	ff d2                	callq  *%rdx
  800420f151:	83 f0 01             	xor    $0x1,%eax
  800420f154:	84 c0                	test   %al,%al
  800420f156:	74 0a                	je     800420f162 <sys_env_mkguest+0x54>
		return -E_NO_EPT;
  800420f158:	b8 ee ff ff ff       	mov    $0xffffffee,%eax
  800420f15d:	e9 8f 00 00 00       	jmpq   800420f1f1 <sys_env_mkguest+0xe3>
	} 
	if ((r = env_guest_alloc(&e, curenv->env_id)) < 0)
  800420f162:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420f169:	00 00 00 
  800420f16c:	ff d0                	callq  *%rax
  800420f16e:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420f175:	00 00 00 
  800420f178:	48 98                	cltq   
  800420f17a:	48 c1 e0 03          	shl    $0x3,%rax
  800420f17e:	48 89 c1             	mov    %rax,%rcx
  800420f181:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f185:	48 01 c8             	add    %rcx,%rax
  800420f188:	48 01 d0             	add    %rdx,%rax
  800420f18b:	48 83 c0 08          	add    $0x8,%rax
  800420f18f:	48 8b 00             	mov    (%rax),%rax
  800420f192:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420f198:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  800420f19c:	89 d6                	mov    %edx,%esi
  800420f19e:	48 89 c7             	mov    %rax,%rdi
  800420f1a1:	48 b8 15 82 20 04 80 	movabs $0x8004208215,%rax
  800420f1a8:	00 00 00 
  800420f1ab:	ff d0                	callq  *%rax
  800420f1ad:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420f1b0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420f1b4:	79 05                	jns    800420f1bb <sys_env_mkguest+0xad>
		return r;
  800420f1b6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f1b9:	eb 36                	jmp    800420f1f1 <sys_env_mkguest+0xe3>
	e->env_status = ENV_NOT_RUNNABLE;
  800420f1bb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f1bf:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420f1c6:	00 00 00 
	e->env_vmxinfo.phys_sz = gphysz;
  800420f1c9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f1cd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f1d1:	48 89 90 20 01 00 00 	mov    %rdx,0x120(%rax)
	e->env_tf.tf_rip = gRIP;
  800420f1d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f1dc:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f1e0:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	return e->env_id;
  800420f1e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f1eb:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420f1f1:	c9                   	leaveq 
  800420f1f2:	c3                   	retq   

000000800420f1f3 <syscall>:


// Dispatches to the correct kernel function, passing the arguments.
int64_t
syscall(uint64_t syscallno, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420f1f3:	55                   	push   %rbp
  800420f1f4:	48 89 e5             	mov    %rsp,%rbp
  800420f1f7:	48 83 ec 30          	sub    $0x30,%rsp
  800420f1fb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f1ff:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420f203:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f207:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420f20b:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  800420f20f:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)

	switch (syscallno) {
  800420f213:	48 83 7d f8 16       	cmpq   $0x16,-0x8(%rbp)
  800420f218:	0f 87 d9 02 00 00    	ja     800420f4f7 <syscall+0x304>
  800420f21e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f222:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420f229:	00 
  800420f22a:	48 b8 c8 09 22 04 80 	movabs $0x80042209c8,%rax
  800420f231:	00 00 00 
  800420f234:	48 01 d0             	add    %rdx,%rax
  800420f237:	48 8b 00             	mov    (%rax),%rax
  800420f23a:	ff e0                	jmpq   *%rax

	case SYS_cputs:
		sys_cputs((const char*) a1, a2);
  800420f23c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f240:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f244:	48 89 d6             	mov    %rdx,%rsi
  800420f247:	48 89 c7             	mov    %rax,%rdi
  800420f24a:	48 b8 48 df 20 04 80 	movabs $0x800420df48,%rax
  800420f251:	00 00 00 
  800420f254:	ff d0                	callq  *%rax
		return 0;
  800420f256:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f25b:	e9 9e 02 00 00       	jmpq   800420f4fe <syscall+0x30b>
	case SYS_cgetc:
		return sys_cgetc();
  800420f260:	48 b8 cd df 20 04 80 	movabs $0x800420dfcd,%rax
  800420f267:	00 00 00 
  800420f26a:	ff d0                	callq  *%rax
  800420f26c:	48 98                	cltq   
  800420f26e:	e9 8b 02 00 00       	jmpq   800420f4fe <syscall+0x30b>
	case SYS_getenvid:
		return sys_getenvid();
  800420f273:	48 b8 df df 20 04 80 	movabs $0x800420dfdf,%rax
  800420f27a:	00 00 00 
  800420f27d:	ff d0                	callq  *%rax
  800420f27f:	48 98                	cltq   
  800420f281:	e9 78 02 00 00       	jmpq   800420f4fe <syscall+0x30b>
	case SYS_env_destroy:
		return sys_env_destroy(a1);
  800420f286:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f28a:	89 c7                	mov    %eax,%edi
  800420f28c:	48 b8 1b e0 20 04 80 	movabs $0x800420e01b,%rax
  800420f293:	00 00 00 
  800420f296:	ff d0                	callq  *%rax
  800420f298:	48 98                	cltq   
  800420f29a:	e9 5f 02 00 00       	jmpq   800420f4fe <syscall+0x30b>

	case SYS_page_alloc:
		return sys_page_alloc(a1, (void*) a2, a3);
  800420f29f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f2a3:	89 c6                	mov    %eax,%esi
  800420f2a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f2a9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f2ad:	89 d1                	mov    %edx,%ecx
  800420f2af:	89 f2                	mov    %esi,%edx
  800420f2b1:	48 89 c6             	mov    %rax,%rsi
  800420f2b4:	89 cf                	mov    %ecx,%edi
  800420f2b6:	48 b8 ee e2 20 04 80 	movabs $0x800420e2ee,%rax
  800420f2bd:	00 00 00 
  800420f2c0:	ff d0                	callq  *%rax
  800420f2c2:	48 98                	cltq   
  800420f2c4:	e9 35 02 00 00       	jmpq   800420f4fe <syscall+0x30b>
	case SYS_page_map:
		return sys_page_map(a1, (void*) a2, a3, (void*) a4, a5);
  800420f2c9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f2cd:	41 89 c0             	mov    %eax,%r8d
  800420f2d0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420f2d4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f2d8:	89 c6                	mov    %eax,%esi
  800420f2da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f2de:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420f2e2:	89 cf                	mov    %ecx,%edi
  800420f2e4:	48 89 d1             	mov    %rdx,%rcx
  800420f2e7:	89 f2                	mov    %esi,%edx
  800420f2e9:	48 89 c6             	mov    %rax,%rsi
  800420f2ec:	48 b8 d7 e3 20 04 80 	movabs $0x800420e3d7,%rax
  800420f2f3:	00 00 00 
  800420f2f6:	ff d0                	callq  *%rax
  800420f2f8:	48 98                	cltq   
  800420f2fa:	e9 ff 01 00 00       	jmpq   800420f4fe <syscall+0x30b>
	case SYS_page_unmap:
		return sys_page_unmap(a1, (void*) a2);
  800420f2ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f303:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f307:	48 89 c6             	mov    %rax,%rsi
  800420f30a:	89 d7                	mov    %edx,%edi
  800420f30c:	48 b8 5c e5 20 04 80 	movabs $0x800420e55c,%rax
  800420f313:	00 00 00 
  800420f316:	ff d0                	callq  *%rax
  800420f318:	48 98                	cltq   
  800420f31a:	e9 df 01 00 00       	jmpq   800420f4fe <syscall+0x30b>
	case SYS_exofork:
		return sys_exofork();
  800420f31f:	48 b8 7b e0 20 04 80 	movabs $0x800420e07b,%rax
  800420f326:	00 00 00 
  800420f329:	ff d0                	callq  *%rax
  800420f32b:	48 98                	cltq   
  800420f32d:	e9 cc 01 00 00       	jmpq   800420f4fe <syscall+0x30b>
	case SYS_env_set_status:
		return sys_env_set_status(a1, a2);
  800420f332:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f336:	89 c2                	mov    %eax,%edx
  800420f338:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f33c:	89 d6                	mov    %edx,%esi
  800420f33e:	89 c7                	mov    %eax,%edi
  800420f340:	48 b8 50 e1 20 04 80 	movabs $0x800420e150,%rax
  800420f347:	00 00 00 
  800420f34a:	ff d0                	callq  *%rax
  800420f34c:	48 98                	cltq   
  800420f34e:	e9 ab 01 00 00       	jmpq   800420f4fe <syscall+0x30b>

	case SYS_env_set_trapframe:
		return sys_env_set_trapframe(a1, (struct Trapframe*) a2);
  800420f353:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f357:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f35b:	48 89 c6             	mov    %rax,%rsi
  800420f35e:	89 d7                	mov    %edx,%edi
  800420f360:	48 b8 b0 e1 20 04 80 	movabs $0x800420e1b0,%rax
  800420f367:	00 00 00 
  800420f36a:	ff d0                	callq  *%rax
  800420f36c:	48 98                	cltq   
  800420f36e:	e9 8b 01 00 00       	jmpq   800420f4fe <syscall+0x30b>

	case SYS_env_set_pgfault_upcall:
		return sys_env_set_pgfault_upcall(a1, (void*) a2);
  800420f373:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f377:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f37b:	48 89 c6             	mov    %rax,%rsi
  800420f37e:	89 d7                	mov    %edx,%edi
  800420f380:	48 b8 9e e2 20 04 80 	movabs $0x800420e29e,%rax
  800420f387:	00 00 00 
  800420f38a:	ff d0                	callq  *%rax
  800420f38c:	48 98                	cltq   
  800420f38e:	e9 6b 01 00 00       	jmpq   800420f4fe <syscall+0x30b>
	case SYS_yield:
		sys_yield();
  800420f393:	48 b8 6b e0 20 04 80 	movabs $0x800420e06b,%rax
  800420f39a:	00 00 00 
  800420f39d:	ff d0                	callq  *%rax
		return 0;
  800420f39f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f3a4:	e9 55 01 00 00       	jmpq   800420f4fe <syscall+0x30b>
	case SYS_ipc_try_send:
		return sys_ipc_try_send(a1, a2, (void*) a3, a4);
  800420f3a9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f3ad:	89 c1                	mov    %eax,%ecx
  800420f3af:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f3b3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f3b7:	89 d6                	mov    %edx,%esi
  800420f3b9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f3bd:	89 d7                	mov    %edx,%edi
  800420f3bf:	48 89 c2             	mov    %rax,%rdx
  800420f3c2:	48 b8 e3 e5 20 04 80 	movabs $0x800420e5e3,%rax
  800420f3c9:	00 00 00 
  800420f3cc:	ff d0                	callq  *%rax
  800420f3ce:	48 98                	cltq   
  800420f3d0:	e9 29 01 00 00       	jmpq   800420f4fe <syscall+0x30b>
	case SYS_ipc_recv:
		sys_ipc_recv((void*) a1);
  800420f3d5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f3d9:	48 89 c7             	mov    %rax,%rdi
  800420f3dc:	48 b8 b7 ec 20 04 80 	movabs $0x800420ecb7,%rax
  800420f3e3:	00 00 00 
  800420f3e6:	ff d0                	callq  *%rax
		return 0;
  800420f3e8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f3ed:	e9 0c 01 00 00       	jmpq   800420f4fe <syscall+0x30b>

	case SYS_time_msec:
		return sys_time_msec();
  800420f3f2:	48 b8 e0 ed 20 04 80 	movabs $0x800420ede0,%rax
  800420f3f9:	00 00 00 
  800420f3fc:	ff d0                	callq  *%rax
  800420f3fe:	48 98                	cltq   
  800420f400:	e9 f9 00 00 00       	jmpq   800420f4fe <syscall+0x30b>
	case SYS_net_transmit:
		return sys_net_transmit((const void*)a1, a2);
  800420f405:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f409:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f40d:	48 89 d6             	mov    %rdx,%rsi
  800420f410:	48 89 c7             	mov    %rax,%rdi
  800420f413:	48 b8 f2 ed 20 04 80 	movabs $0x800420edf2,%rax
  800420f41a:	00 00 00 
  800420f41d:	ff d0                	callq  *%rax
  800420f41f:	48 98                	cltq   
  800420f421:	e9 d8 00 00 00       	jmpq   800420f4fe <syscall+0x30b>
	case SYS_net_receive:
		return sys_net_receive((void*)a1, a2);
  800420f426:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f42a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f42e:	48 89 d6             	mov    %rdx,%rsi
  800420f431:	48 89 c7             	mov    %rax,%rdi
  800420f434:	48 b8 6b ee 20 04 80 	movabs $0x800420ee6b,%rax
  800420f43b:	00 00 00 
  800420f43e:	ff d0                	callq  *%rax
  800420f440:	48 98                	cltq   
  800420f442:	e9 b7 00 00 00       	jmpq   800420f4fe <syscall+0x30b>

//#ifndef VMM_GUEST
	case SYS_ept_map:
		return sys_ept_map(a1, (void*) a2, a3, (void*) a4, a5);
  800420f447:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f44b:	41 89 c0             	mov    %eax,%r8d
  800420f44e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420f452:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f456:	89 c6                	mov    %eax,%esi
  800420f458:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f45c:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420f460:	89 cf                	mov    %ecx,%edi
  800420f462:	48 89 d1             	mov    %rdx,%rcx
  800420f465:	89 f2                	mov    %esi,%edx
  800420f467:	48 89 c6             	mov    %rax,%rsi
  800420f46a:	48 b8 49 ef 20 04 80 	movabs $0x800420ef49,%rax
  800420f471:	00 00 00 
  800420f474:	ff d0                	callq  *%rax
  800420f476:	48 98                	cltq   
  800420f478:	e9 81 00 00 00       	jmpq   800420f4fe <syscall+0x30b>
	case SYS_env_mkguest:
		return sys_env_mkguest(a1, a2);
  800420f47d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f481:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f485:	48 89 d6             	mov    %rdx,%rsi
  800420f488:	48 89 c7             	mov    %rax,%rdi
  800420f48b:	48 b8 0e f1 20 04 80 	movabs $0x800420f10e,%rax
  800420f492:	00 00 00 
  800420f495:	ff d0                	callq  *%rax
  800420f497:	48 98                	cltq   
  800420f499:	eb 63                	jmp    800420f4fe <syscall+0x30b>
	case SYS_vmx_list_vms:
		sys_vmx_list_vms();
  800420f49b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f4a0:	48 ba e4 ee 20 04 80 	movabs $0x800420eee4,%rdx
  800420f4a7:	00 00 00 
  800420f4aa:	ff d2                	callq  *%rdx
		return 0;
  800420f4ac:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f4b1:	eb 4b                	jmp    800420f4fe <syscall+0x30b>
	case SYS_vmx_sel_resume:
		return sys_vmx_sel_resume(a1);
  800420f4b3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f4b7:	89 c7                	mov    %eax,%edi
  800420f4b9:	48 b8 fc ee 20 04 80 	movabs $0x800420eefc,%rax
  800420f4c0:	00 00 00 
  800420f4c3:	ff d0                	callq  *%rax
  800420f4c5:	0f b6 c0             	movzbl %al,%eax
  800420f4c8:	eb 34                	jmp    800420f4fe <syscall+0x30b>
	case SYS_vmx_get_vmdisk_number:
		return sys_vmx_get_vmdisk_number();
  800420f4ca:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f4cf:	48 ba 1a ef 20 04 80 	movabs $0x800420ef1a,%rdx
  800420f4d6:	00 00 00 
  800420f4d9:	ff d2                	callq  *%rdx
  800420f4db:	48 98                	cltq   
  800420f4dd:	eb 1f                	jmp    800420f4fe <syscall+0x30b>
	case SYS_vmx_incr_vmdisk_number:
		sys_vmx_incr_vmdisk_number();
  800420f4df:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f4e4:	48 ba 31 ef 20 04 80 	movabs $0x800420ef31,%rdx
  800420f4eb:	00 00 00 
  800420f4ee:	ff d2                	callq  *%rdx
		return 0;
  800420f4f0:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f4f5:	eb 07                	jmp    800420f4fe <syscall+0x30b>
//#endif

		
	default:
		return -E_NO_SYS;
  800420f4f7:	48 c7 c0 f9 ff ff ff 	mov    $0xfffffffffffffff9,%rax
	}
}
  800420f4fe:	c9                   	leaveq 
  800420f4ff:	c3                   	retq   

000000800420f500 <list_func_die>:
	const char *stabstr_end;
};


int list_func_die(struct Ripdebuginfo *info, Dwarf_Die *die, uint64_t addr)
{
  800420f500:	55                   	push   %rbp
  800420f501:	48 89 e5             	mov    %rsp,%rbp
  800420f504:	48 81 ec c0 61 00 00 	sub    $0x61c0,%rsp
  800420f50b:	48 89 bd 58 9e ff ff 	mov    %rdi,-0x61a8(%rbp)
  800420f512:	48 89 b5 50 9e ff ff 	mov    %rsi,-0x61b0(%rbp)
  800420f519:	48 89 95 48 9e ff ff 	mov    %rdx,-0x61b8(%rbp)
	_Dwarf_Line ln;
	Dwarf_Attribute *low;
	Dwarf_Attribute *high;
	Dwarf_CU *cu = die->cu_header;
  800420f520:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f527:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800420f52e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Dwarf_Die *cudie = die->cu_die; 
  800420f532:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f539:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420f540:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	Dwarf_Die ret, sib=*die; 
  800420f544:	48 8b 95 50 9e ff ff 	mov    -0x61b0(%rbp),%rdx
  800420f54b:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420f552:	48 89 d1             	mov    %rdx,%rcx
  800420f555:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420f55a:	48 89 ce             	mov    %rcx,%rsi
  800420f55d:	48 89 c7             	mov    %rax,%rdi
  800420f560:	48 b8 2d 11 21 04 80 	movabs $0x800421112d,%rax
  800420f567:	00 00 00 
  800420f56a:	ff d0                	callq  *%rax
	Dwarf_Attribute *attr;
	uint64_t offset;
	uint64_t ret_val=8;
  800420f56c:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  800420f573:	00 
	uint64_t ret_offset=0;
  800420f574:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420f57b:	00 

	if(die->die_tag != DW_TAG_subprogram)
  800420f57c:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f583:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f587:	48 83 f8 2e          	cmp    $0x2e,%rax
  800420f58b:	74 0a                	je     800420f597 <list_func_die+0x97>
		return 0;
  800420f58d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f592:	e9 8d 06 00 00       	jmpq   800420fc24 <list_func_die+0x724>

	memset(&ln, 0, sizeof(_Dwarf_Line));
  800420f597:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420f59e:	ba 38 00 00 00       	mov    $0x38,%edx
  800420f5a3:	be 00 00 00 00       	mov    $0x0,%esi
  800420f5a8:	48 89 c7             	mov    %rax,%rdi
  800420f5ab:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  800420f5b2:	00 00 00 
  800420f5b5:	ff d0                	callq  *%rax

	low  = _dwarf_attr_find(die, DW_AT_low_pc);
  800420f5b7:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f5be:	be 11 00 00 00       	mov    $0x11,%esi
  800420f5c3:	48 89 c7             	mov    %rax,%rdi
  800420f5c6:	48 b8 69 2e 21 04 80 	movabs $0x8004212e69,%rax
  800420f5cd:	00 00 00 
  800420f5d0:	ff d0                	callq  *%rax
  800420f5d2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	high = _dwarf_attr_find(die, DW_AT_high_pc);
  800420f5d6:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f5dd:	be 12 00 00 00       	mov    $0x12,%esi
  800420f5e2:	48 89 c7             	mov    %rax,%rdi
  800420f5e5:	48 b8 69 2e 21 04 80 	movabs $0x8004212e69,%rax
  800420f5ec:	00 00 00 
  800420f5ef:	ff d0                	callq  *%rax
  800420f5f1:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if((low && (low->u[0].u64 < addr)) && (high && (high->u[0].u64 > addr)))
  800420f5f5:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420f5fa:	0f 84 1f 06 00 00    	je     800420fc1f <list_func_die+0x71f>
  800420f600:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f604:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420f608:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420f60f:	0f 83 0a 06 00 00    	jae    800420fc1f <list_func_die+0x71f>
  800420f615:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420f61a:	0f 84 ff 05 00 00    	je     800420fc1f <list_func_die+0x71f>
  800420f620:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f624:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420f628:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420f62f:	0f 86 ea 05 00 00    	jbe    800420fc1f <list_func_die+0x71f>
	{
		info->rip_file = die->cu_die->die_name;
  800420f635:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f63c:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420f643:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420f64a:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f651:	48 89 10             	mov    %rdx,(%rax)

		info->rip_fn_name = die->die_name;
  800420f654:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f65b:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420f662:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f669:	48 89 50 10          	mov    %rdx,0x10(%rax)
		info->rip_fn_namelen = strlen(die->die_name);
  800420f66d:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f674:	48 8b 80 50 03 00 00 	mov    0x350(%rax),%rax
  800420f67b:	48 89 c7             	mov    %rax,%rdi
  800420f67e:	48 b8 85 0c 21 04 80 	movabs $0x8004210c85,%rax
  800420f685:	00 00 00 
  800420f688:	ff d0                	callq  *%rax
  800420f68a:	89 c2                	mov    %eax,%edx
  800420f68c:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f693:	89 50 18             	mov    %edx,0x18(%rax)

		info->rip_fn_addr = (uintptr_t)low->u[0].u64;
  800420f696:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f69a:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420f69e:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f6a5:	48 89 50 20          	mov    %rdx,0x20(%rax)

		assert(die->cu_die);	
  800420f6a9:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f6b0:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420f6b7:	48 85 c0             	test   %rax,%rax
  800420f6ba:	75 35                	jne    800420f6f1 <list_func_die+0x1f1>
  800420f6bc:	48 b9 a0 0d 22 04 80 	movabs $0x8004220da0,%rcx
  800420f6c3:	00 00 00 
  800420f6c6:	48 ba ac 0d 22 04 80 	movabs $0x8004220dac,%rdx
  800420f6cd:	00 00 00 
  800420f6d0:	be 95 00 00 00       	mov    $0x95,%esi
  800420f6d5:	48 bf c1 0d 22 04 80 	movabs $0x8004220dc1,%rdi
  800420f6dc:	00 00 00 
  800420f6df:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f6e4:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420f6eb:	00 00 00 
  800420f6ee:	41 ff d0             	callq  *%r8
		dwarf_srclines(die->cu_die, &ln, addr, NULL); 
  800420f6f1:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f6f8:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420f6ff:	48 8b 95 48 9e ff ff 	mov    -0x61b8(%rbp),%rdx
  800420f706:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
  800420f70d:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420f712:	48 89 c7             	mov    %rax,%rdi
  800420f715:	48 b8 21 64 21 04 80 	movabs $0x8004216421,%rax
  800420f71c:	00 00 00 
  800420f71f:	ff d0                	callq  *%rax

		info->rip_line = ln.ln_lineno;
  800420f721:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420f728:	89 c2                	mov    %eax,%edx
  800420f72a:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f731:	89 50 08             	mov    %edx,0x8(%rax)
		info->rip_fn_narg = 0;
  800420f734:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f73b:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)

		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
  800420f742:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  800420f749:	00 00 00 
  800420f74c:	48 8b 00             	mov    (%rax),%rax
  800420f74f:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420f756:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420f75d:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420f761:	48 89 c7             	mov    %rax,%rdi
  800420f764:	48 b8 fe 30 21 04 80 	movabs $0x80042130fe,%rax
  800420f76b:	00 00 00 
  800420f76e:	ff d0                	callq  *%rax
  800420f770:	83 f8 04             	cmp    $0x4,%eax
  800420f773:	0f 84 9f 04 00 00    	je     800420fc18 <list_func_die+0x718>
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
  800420f779:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420f780:	48 83 f8 05          	cmp    $0x5,%rax
  800420f784:	0f 85 8a 04 00 00    	jne    800420fc14 <list_func_die+0x714>
				goto last;

			attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420f78a:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420f791:	be 49 00 00 00       	mov    $0x49,%esi
  800420f796:	48 89 c7             	mov    %rax,%rdi
  800420f799:	48 b8 69 2e 21 04 80 	movabs $0x8004212e69,%rax
  800420f7a0:	00 00 00 
  800420f7a3:	ff d0                	callq  *%rax
  800420f7a5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
		try_again:
			if(attr != NULL)
  800420f7a9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f7ae:	0f 84 b6 00 00 00    	je     800420f86a <list_func_die+0x36a>
			{
				offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420f7b4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f7b8:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420f7bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f7c0:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420f7c4:	48 01 d0             	add    %rdx,%rax
  800420f7c7:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				dwarf_offdie(dbg, offset, &sib, *cu);
  800420f7cb:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  800420f7d2:	00 00 00 
  800420f7d5:	48 8b 08             	mov    (%rax),%rcx
  800420f7d8:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420f7df:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420f7e3:	48 83 ec 08          	sub    $0x8,%rsp
  800420f7e7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f7eb:	ff 70 30             	pushq  0x30(%rax)
  800420f7ee:	ff 70 28             	pushq  0x28(%rax)
  800420f7f1:	ff 70 20             	pushq  0x20(%rax)
  800420f7f4:	ff 70 18             	pushq  0x18(%rax)
  800420f7f7:	ff 70 10             	pushq  0x10(%rax)
  800420f7fa:	ff 70 08             	pushq  0x8(%rax)
  800420f7fd:	ff 30                	pushq  (%rax)
  800420f7ff:	48 89 cf             	mov    %rcx,%rdi
  800420f802:	48 b8 87 2d 21 04 80 	movabs $0x8004212d87,%rax
  800420f809:	00 00 00 
  800420f80c:	ff d0                	callq  *%rax
  800420f80e:	48 83 c4 40          	add    $0x40,%rsp
				attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420f812:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420f819:	be 0b 00 00 00       	mov    $0xb,%esi
  800420f81e:	48 89 c7             	mov    %rax,%rdi
  800420f821:	48 b8 69 2e 21 04 80 	movabs $0x8004212e69,%rax
  800420f828:	00 00 00 
  800420f82b:	ff d0                	callq  *%rax
  800420f82d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		
				if(attr != NULL)
  800420f831:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f836:	74 0e                	je     800420f846 <list_func_die+0x346>
				{
					ret_val = attr->u[0].u64;
  800420f838:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f83c:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420f840:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420f844:	eb 24                	jmp    800420f86a <list_func_die+0x36a>
				}
				else
				{
					attr = _dwarf_attr_find(&sib, DW_AT_type);
  800420f846:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420f84d:	be 49 00 00 00       	mov    $0x49,%esi
  800420f852:	48 89 c7             	mov    %rax,%rdi
  800420f855:	48 b8 69 2e 21 04 80 	movabs $0x8004212e69,%rax
  800420f85c:	00 00 00 
  800420f85f:	ff d0                	callq  *%rax
  800420f861:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					goto try_again;
  800420f865:	e9 3f ff ff ff       	jmpq   800420f7a9 <list_func_die+0x2a9>
				}
			}

			ret_offset = 0;
  800420f86a:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420f871:	00 
			attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420f872:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420f879:	be 02 00 00 00       	mov    $0x2,%esi
  800420f87e:	48 89 c7             	mov    %rax,%rdi
  800420f881:	48 b8 69 2e 21 04 80 	movabs $0x8004212e69,%rax
  800420f888:	00 00 00 
  800420f88b:	ff d0                	callq  *%rax
  800420f88d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if (attr != NULL)
  800420f891:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f896:	0f 84 a0 00 00 00    	je     800420f93c <list_func_die+0x43c>
			{
				Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420f89c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8a0:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420f8a4:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
				Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420f8a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8ac:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420f8b0:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
				Dwarf_Small atom;
				Dwarf_Unsigned op1, op2;

				switch(attr->at_form) {
  800420f8b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8b8:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f8bc:	48 83 f8 03          	cmp    $0x3,%rax
  800420f8c0:	72 7a                	jb     800420f93c <list_func_die+0x43c>
  800420f8c2:	48 83 f8 04          	cmp    $0x4,%rax
  800420f8c6:	76 06                	jbe    800420f8ce <list_func_die+0x3ce>
  800420f8c8:	48 83 f8 0a          	cmp    $0xa,%rax
  800420f8cc:	75 6e                	jne    800420f93c <list_func_die+0x43c>
					case DW_FORM_block1:
					case DW_FORM_block2:
					case DW_FORM_block4:
						offset = 0;
  800420f8ce:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420f8d5:	00 
						atom = *(loc_ptr++);
  800420f8d6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420f8da:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f8de:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420f8e2:	0f b6 00             	movzbl (%rax),%eax
  800420f8e5:	88 45 af             	mov    %al,-0x51(%rbp)
						offset++;
  800420f8e8:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
						if (atom == DW_OP_fbreg) {
  800420f8ed:	80 7d af 91          	cmpb   $0x91,-0x51(%rbp)
  800420f8f1:	75 48                	jne    800420f93b <list_func_die+0x43b>
							uint8_t *p = loc_ptr;
  800420f8f3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420f8f7:	48 89 85 68 9e ff ff 	mov    %rax,-0x6198(%rbp)
							ret_offset = _dwarf_decode_sleb128(&p);
  800420f8fe:	48 8d 85 68 9e ff ff 	lea    -0x6198(%rbp),%rax
  800420f905:	48 89 c7             	mov    %rax,%rdi
  800420f908:	48 b8 22 1b 21 04 80 	movabs $0x8004211b22,%rax
  800420f90f:	00 00 00 
  800420f912:	ff d0                	callq  *%rax
  800420f914:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
							offset += p - loc_ptr;
  800420f918:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420f91f:	48 89 c2             	mov    %rax,%rdx
  800420f922:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420f926:	48 29 c2             	sub    %rax,%rdx
  800420f929:	48 89 d0             	mov    %rdx,%rax
  800420f92c:	48 01 45 c0          	add    %rax,-0x40(%rbp)
							loc_ptr = p;
  800420f930:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420f937:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
						}
						break;
  800420f93b:	90                   	nop
				}
			}

			info->size_fn_arg[info->rip_fn_narg] = ret_val;
  800420f93c:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f943:	8b 50 28             	mov    0x28(%rax),%edx
  800420f946:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f94a:	89 c1                	mov    %eax,%ecx
  800420f94c:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f953:	48 63 d2             	movslq %edx,%rdx
  800420f956:	48 83 c2 08          	add    $0x8,%rdx
  800420f95a:	89 4c 90 0c          	mov    %ecx,0xc(%rax,%rdx,4)
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
  800420f95e:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f965:	8b 50 28             	mov    0x28(%rax),%edx
  800420f968:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f96f:	48 63 d2             	movslq %edx,%rdx
  800420f972:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420f976:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f97a:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
			info->rip_fn_narg++;
  800420f97f:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f986:	8b 40 28             	mov    0x28(%rax),%eax
  800420f989:	8d 50 01             	lea    0x1(%rax),%edx
  800420f98c:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f993:	89 50 28             	mov    %edx,0x28(%rax)
			sib = ret; 
  800420f996:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420f99d:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420f9a4:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420f9a9:	48 89 ce             	mov    %rcx,%rsi
  800420f9ac:	48 89 c7             	mov    %rax,%rdi
  800420f9af:	48 b8 2d 11 21 04 80 	movabs $0x800421112d,%rax
  800420f9b6:	00 00 00 
  800420f9b9:	ff d0                	callq  *%rax

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420f9bb:	e9 1c 02 00 00       	jmpq   800420fbdc <list_func_die+0x6dc>
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
  800420f9c0:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420f9c7:	48 83 f8 05          	cmp    $0x5,%rax
  800420f9cb:	0f 85 46 02 00 00    	jne    800420fc17 <list_func_die+0x717>
					break;

				attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420f9d1:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420f9d8:	be 49 00 00 00       	mov    $0x49,%esi
  800420f9dd:	48 89 c7             	mov    %rax,%rdi
  800420f9e0:	48 b8 69 2e 21 04 80 	movabs $0x8004212e69,%rax
  800420f9e7:	00 00 00 
  800420f9ea:	ff d0                	callq  *%rax
  800420f9ec:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
				if(attr != NULL)
  800420f9f0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f9f5:	0f 84 90 00 00 00    	je     800420fa8b <list_func_die+0x58b>
				{	   
					offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420f9fb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f9ff:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420fa03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa07:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420fa0b:	48 01 d0             	add    %rdx,%rax
  800420fa0e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
					dwarf_offdie(dbg, offset, &sib, *cu);
  800420fa12:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  800420fa19:	00 00 00 
  800420fa1c:	48 8b 08             	mov    (%rax),%rcx
  800420fa1f:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420fa26:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420fa2a:	48 83 ec 08          	sub    $0x8,%rsp
  800420fa2e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fa32:	ff 70 30             	pushq  0x30(%rax)
  800420fa35:	ff 70 28             	pushq  0x28(%rax)
  800420fa38:	ff 70 20             	pushq  0x20(%rax)
  800420fa3b:	ff 70 18             	pushq  0x18(%rax)
  800420fa3e:	ff 70 10             	pushq  0x10(%rax)
  800420fa41:	ff 70 08             	pushq  0x8(%rax)
  800420fa44:	ff 30                	pushq  (%rax)
  800420fa46:	48 89 cf             	mov    %rcx,%rdi
  800420fa49:	48 b8 87 2d 21 04 80 	movabs $0x8004212d87,%rax
  800420fa50:	00 00 00 
  800420fa53:	ff d0                	callq  *%rax
  800420fa55:	48 83 c4 40          	add    $0x40,%rsp
					attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420fa59:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420fa60:	be 0b 00 00 00       	mov    $0xb,%esi
  800420fa65:	48 89 c7             	mov    %rax,%rdi
  800420fa68:	48 b8 69 2e 21 04 80 	movabs $0x8004212e69,%rax
  800420fa6f:	00 00 00 
  800420fa72:	ff d0                	callq  *%rax
  800420fa74:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
					if(attr != NULL)
  800420fa78:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420fa7d:	74 0c                	je     800420fa8b <list_func_die+0x58b>
					{
						ret_val = attr->u[0].u64;
  800420fa7f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa83:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420fa87:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
					}
				}
	
				ret_offset = 0;
  800420fa8b:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420fa92:	00 
				attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420fa93:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420fa9a:	be 02 00 00 00       	mov    $0x2,%esi
  800420fa9f:	48 89 c7             	mov    %rax,%rdi
  800420faa2:	48 b8 69 2e 21 04 80 	movabs $0x8004212e69,%rax
  800420faa9:	00 00 00 
  800420faac:	ff d0                	callq  *%rax
  800420faae:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				if (attr != NULL)
  800420fab2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420fab7:	0f 84 a0 00 00 00    	je     800420fb5d <list_func_die+0x65d>
				{
					Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420fabd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fac1:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420fac5:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
					Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420fac9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420facd:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420fad1:	48 89 45 98          	mov    %rax,-0x68(%rbp)
					Dwarf_Small atom;
					Dwarf_Unsigned op1, op2;

					switch(attr->at_form) {
  800420fad5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fad9:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fadd:	48 83 f8 03          	cmp    $0x3,%rax
  800420fae1:	72 7a                	jb     800420fb5d <list_func_die+0x65d>
  800420fae3:	48 83 f8 04          	cmp    $0x4,%rax
  800420fae7:	76 06                	jbe    800420faef <list_func_die+0x5ef>
  800420fae9:	48 83 f8 0a          	cmp    $0xa,%rax
  800420faed:	75 6e                	jne    800420fb5d <list_func_die+0x65d>
						case DW_FORM_block1:
						case DW_FORM_block2:
						case DW_FORM_block4:
							offset = 0;
  800420faef:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420faf6:	00 
							atom = *(loc_ptr++);
  800420faf7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420fafb:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420faff:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420fb03:	0f b6 00             	movzbl (%rax),%eax
  800420fb06:	88 45 97             	mov    %al,-0x69(%rbp)
							offset++;
  800420fb09:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
							if (atom == DW_OP_fbreg) {
  800420fb0e:	80 7d 97 91          	cmpb   $0x91,-0x69(%rbp)
  800420fb12:	75 48                	jne    800420fb5c <list_func_die+0x65c>
								uint8_t *p = loc_ptr;
  800420fb14:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420fb18:	48 89 85 60 9e ff ff 	mov    %rax,-0x61a0(%rbp)
								ret_offset = _dwarf_decode_sleb128(&p);
  800420fb1f:	48 8d 85 60 9e ff ff 	lea    -0x61a0(%rbp),%rax
  800420fb26:	48 89 c7             	mov    %rax,%rdi
  800420fb29:	48 b8 22 1b 21 04 80 	movabs $0x8004211b22,%rax
  800420fb30:	00 00 00 
  800420fb33:	ff d0                	callq  *%rax
  800420fb35:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
								offset += p - loc_ptr;
  800420fb39:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420fb40:	48 89 c2             	mov    %rax,%rdx
  800420fb43:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420fb47:	48 29 c2             	sub    %rax,%rdx
  800420fb4a:	48 89 d0             	mov    %rdx,%rax
  800420fb4d:	48 01 45 c0          	add    %rax,-0x40(%rbp)
								loc_ptr = p;
  800420fb51:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420fb58:	48 89 45 98          	mov    %rax,-0x68(%rbp)
							}
							break;
  800420fb5c:	90                   	nop
					}
				}

				info->size_fn_arg[info->rip_fn_narg]=ret_val;// _get_arg_size(ret);
  800420fb5d:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420fb64:	8b 50 28             	mov    0x28(%rax),%edx
  800420fb67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb6b:	89 c1                	mov    %eax,%ecx
  800420fb6d:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420fb74:	48 63 d2             	movslq %edx,%rdx
  800420fb77:	48 83 c2 08          	add    $0x8,%rdx
  800420fb7b:	89 4c 90 0c          	mov    %ecx,0xc(%rax,%rdx,4)
				info->offset_fn_arg[info->rip_fn_narg]=ret_offset;
  800420fb7f:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420fb86:	8b 50 28             	mov    0x28(%rax),%edx
  800420fb89:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420fb90:	48 63 d2             	movslq %edx,%rdx
  800420fb93:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420fb97:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420fb9b:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
				info->rip_fn_narg++;
  800420fba0:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420fba7:	8b 40 28             	mov    0x28(%rax),%eax
  800420fbaa:	8d 50 01             	lea    0x1(%rax),%edx
  800420fbad:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420fbb4:	89 50 28             	mov    %edx,0x28(%rax)
				sib = ret; 
  800420fbb7:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420fbbe:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420fbc5:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420fbca:	48 89 ce             	mov    %rcx,%rsi
  800420fbcd:	48 89 c7             	mov    %rax,%rdi
  800420fbd0:	48 b8 2d 11 21 04 80 	movabs $0x800421112d,%rax
  800420fbd7:	00 00 00 
  800420fbda:	ff d0                	callq  *%rax
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
			info->rip_fn_narg++;
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420fbdc:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  800420fbe3:	00 00 00 
  800420fbe6:	48 8b 00             	mov    (%rax),%rax
  800420fbe9:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420fbed:	48 8d 95 e0 ce ff ff 	lea    -0x3120(%rbp),%rdx
  800420fbf4:	48 8d b5 70 9e ff ff 	lea    -0x6190(%rbp),%rsi
  800420fbfb:	48 89 c7             	mov    %rax,%rdi
  800420fbfe:	48 b8 fc 2e 21 04 80 	movabs $0x8004212efc,%rax
  800420fc05:	00 00 00 
  800420fc08:	ff d0                	callq  *%rax
  800420fc0a:	85 c0                	test   %eax,%eax
  800420fc0c:	0f 84 ae fd ff ff    	je     800420f9c0 <list_func_die+0x4c0>
  800420fc12:	eb 04                	jmp    800420fc18 <list_func_die+0x718>
		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
				goto last;
  800420fc14:	90                   	nop
  800420fc15:	eb 01                	jmp    800420fc18 <list_func_die+0x718>
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
					break;
  800420fc17:	90                   	nop
				info->rip_fn_narg++;
				sib = ret; 
			}
		}
	last:	
		return 1;
  800420fc18:	b8 01 00 00 00       	mov    $0x1,%eax
  800420fc1d:	eb 05                	jmp    800420fc24 <list_func_die+0x724>
	}

	return 0;
  800420fc1f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fc24:	c9                   	leaveq 
  800420fc25:	c3                   	retq   

000000800420fc26 <debuginfo_rip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info)
{
  800420fc26:	55                   	push   %rbp
  800420fc27:	48 89 e5             	mov    %rsp,%rbp
  800420fc2a:	48 81 ec c0 91 00 00 	sub    $0x91c0,%rsp
  800420fc31:	48 89 bd 48 6e ff ff 	mov    %rdi,-0x91b8(%rbp)
  800420fc38:	48 89 b5 40 6e ff ff 	mov    %rsi,-0x91c0(%rbp)
	static struct Env* lastenv = NULL;
	void* elf;    
	Dwarf_Section *sect;
	Dwarf_CU cu;
	Dwarf_Die die, cudie, die2;
	Dwarf_Regtable *rt = NULL;
  800420fc3f:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420fc46:	00 
	//Set up initial pc
	uint64_t pc  = (uintptr_t)addr;
  800420fc47:	48 8b 85 48 6e ff ff 	mov    -0x91b8(%rbp),%rax
  800420fc4e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    
	// Initialize *info
	info->rip_file = "<unknown>";
  800420fc52:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420fc59:	48 bf cf 0d 22 04 80 	movabs $0x8004220dcf,%rdi
  800420fc60:	00 00 00 
  800420fc63:	48 89 38             	mov    %rdi,(%rax)
	info->rip_line = 0;
  800420fc66:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420fc6d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	info->rip_fn_name = "<unknown>";
  800420fc74:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420fc7b:	48 bf cf 0d 22 04 80 	movabs $0x8004220dcf,%rdi
  800420fc82:	00 00 00 
  800420fc85:	48 89 78 10          	mov    %rdi,0x10(%rax)
	info->rip_fn_namelen = 9;
  800420fc89:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420fc90:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
	info->rip_fn_addr = addr;
  800420fc97:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420fc9e:	48 8b 95 48 6e ff ff 	mov    -0x91b8(%rbp),%rdx
  800420fca5:	48 89 50 20          	mov    %rdx,0x20(%rax)
	info->rip_fn_narg = 0;
  800420fca9:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420fcb0:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
    
	// Find the relevant set of stabs
	if (addr >= ULIM) {
  800420fcb7:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420fcbe:	00 00 00 
  800420fcc1:	48 39 85 48 6e ff ff 	cmp    %rax,-0x91b8(%rbp)
  800420fcc8:	76 13                	jbe    800420fcdd <debuginfo_rip+0xb7>
		elf = (void *)0x10000 + KERNBASE;
  800420fcca:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800420fcd1:	00 00 00 
  800420fcd4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420fcd8:	e9 04 01 00 00       	jmpq   800420fde1 <debuginfo_rip+0x1bb>
	} else {

		if(curenv != lastenv) {
  800420fcdd:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420fce4:	00 00 00 
  800420fce7:	ff d0                	callq  *%rax
  800420fce9:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420fcf0:	00 00 00 
  800420fcf3:	48 98                	cltq   
  800420fcf5:	48 c1 e0 03          	shl    $0x3,%rax
  800420fcf9:	48 89 c1             	mov    %rax,%rcx
  800420fcfc:	48 c1 e1 04          	shl    $0x4,%rcx
  800420fd00:	48 01 c8             	add    %rcx,%rax
  800420fd03:	48 01 d0             	add    %rdx,%rax
  800420fd06:	48 83 c0 08          	add    $0x8,%rax
  800420fd0a:	48 8b 10             	mov    (%rax),%rdx
  800420fd0d:	48 b8 98 e2 4d 04 80 	movabs $0x80044de298,%rax
  800420fd14:	00 00 00 
  800420fd17:	48 8b 00             	mov    (%rax),%rax
  800420fd1a:	48 39 c2             	cmp    %rax,%rdx
  800420fd1d:	0f 84 83 00 00 00    	je     800420fda6 <debuginfo_rip+0x180>
			find_debug_sections((uintptr_t)curenv->elf);
  800420fd23:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420fd2a:	00 00 00 
  800420fd2d:	ff d0                	callq  *%rax
  800420fd2f:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420fd36:	00 00 00 
  800420fd39:	48 98                	cltq   
  800420fd3b:	48 c1 e0 03          	shl    $0x3,%rax
  800420fd3f:	48 89 c1             	mov    %rax,%rcx
  800420fd42:	48 c1 e1 04          	shl    $0x4,%rcx
  800420fd46:	48 01 c8             	add    %rcx,%rax
  800420fd49:	48 01 d0             	add    %rdx,%rax
  800420fd4c:	48 83 c0 08          	add    $0x8,%rax
  800420fd50:	48 8b 00             	mov    (%rax),%rax
  800420fd53:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420fd5a:	48 89 c7             	mov    %rax,%rdi
  800420fd5d:	48 b8 1c 66 21 04 80 	movabs $0x800421661c,%rax
  800420fd64:	00 00 00 
  800420fd67:	ff d0                	callq  *%rax
			lastenv = curenv;
  800420fd69:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420fd70:	00 00 00 
  800420fd73:	ff d0                	callq  *%rax
  800420fd75:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420fd7c:	00 00 00 
  800420fd7f:	48 98                	cltq   
  800420fd81:	48 c1 e0 03          	shl    $0x3,%rax
  800420fd85:	48 89 c1             	mov    %rax,%rcx
  800420fd88:	48 c1 e1 04          	shl    $0x4,%rcx
  800420fd8c:	48 01 c8             	add    %rcx,%rax
  800420fd8f:	48 01 d0             	add    %rdx,%rax
  800420fd92:	48 83 c0 08          	add    $0x8,%rax
  800420fd96:	48 8b 10             	mov    (%rax),%rdx
  800420fd99:	48 b8 98 e2 4d 04 80 	movabs $0x80044de298,%rax
  800420fda0:	00 00 00 
  800420fda3:	48 89 10             	mov    %rdx,(%rax)
		}
		elf = curenv->elf;
  800420fda6:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800420fdad:	00 00 00 
  800420fdb0:	ff d0                	callq  *%rax
  800420fdb2:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800420fdb9:	00 00 00 
  800420fdbc:	48 98                	cltq   
  800420fdbe:	48 c1 e0 03          	shl    $0x3,%rax
  800420fdc2:	48 89 c1             	mov    %rax,%rcx
  800420fdc5:	48 c1 e1 04          	shl    $0x4,%rcx
  800420fdc9:	48 01 c8             	add    %rcx,%rax
  800420fdcc:	48 01 d0             	add    %rdx,%rax
  800420fdcf:	48 83 c0 08          	add    $0x8,%rax
  800420fdd3:	48 8b 00             	mov    (%rax),%rax
  800420fdd6:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420fddd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	}
	_dwarf_init(dbg, elf);
  800420fde1:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  800420fde8:	00 00 00 
  800420fdeb:	48 8b 00             	mov    (%rax),%rax
  800420fdee:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fdf2:	48 89 d6             	mov    %rdx,%rsi
  800420fdf5:	48 89 c7             	mov    %rax,%rdi
  800420fdf8:	48 b8 d1 1d 21 04 80 	movabs $0x8004211dd1,%rax
  800420fdff:	00 00 00 
  800420fe02:	ff d0                	callq  *%rax

	sect = _dwarf_find_section(".debug_info");	
  800420fe04:	48 bf d9 0d 22 04 80 	movabs $0x8004220dd9,%rdi
  800420fe0b:	00 00 00 
  800420fe0e:	48 b8 9c 65 21 04 80 	movabs $0x800421659c,%rax
  800420fe15:	00 00 00 
  800420fe18:	ff d0                	callq  *%rax
  800420fe1a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
  800420fe1e:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  800420fe25:	00 00 00 
  800420fe28:	48 8b 00             	mov    (%rax),%rax
  800420fe2b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420fe2f:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420fe33:	48 89 50 08          	mov    %rdx,0x8(%rax)
	dbg->dbg_info_size = sect->ds_size;
  800420fe37:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  800420fe3e:	00 00 00 
  800420fe41:	48 8b 00             	mov    (%rax),%rax
  800420fe44:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420fe48:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  800420fe4c:	48 89 50 10          	mov    %rdx,0x10(%rax)

	assert(dbg->dbg_info_size);
  800420fe50:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  800420fe57:	00 00 00 
  800420fe5a:	48 8b 00             	mov    (%rax),%rax
  800420fe5d:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420fe61:	48 85 c0             	test   %rax,%rax
  800420fe64:	0f 85 78 01 00 00    	jne    800420ffe2 <debuginfo_rip+0x3bc>
  800420fe6a:	48 b9 e5 0d 22 04 80 	movabs $0x8004220de5,%rcx
  800420fe71:	00 00 00 
  800420fe74:	48 ba ac 0d 22 04 80 	movabs $0x8004220dac,%rdx
  800420fe7b:	00 00 00 
  800420fe7e:	be 3d 01 00 00       	mov    $0x13d,%esi
  800420fe83:	48 bf c1 0d 22 04 80 	movabs $0x8004220dc1,%rdi
  800420fe8a:	00 00 00 
  800420fe8d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fe92:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800420fe99:	00 00 00 
  800420fe9c:	41 ff d0             	callq  *%r8
	while(_get_next_cu(dbg, &cu) == 0)
	{
		if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
  800420fe9f:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  800420fea6:	00 00 00 
  800420fea9:	48 8b 00             	mov    (%rax),%rax
  800420feac:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
  800420feb0:	48 8d 95 c0 9e ff ff 	lea    -0x6140(%rbp),%rdx
  800420feb7:	be 00 00 00 00       	mov    $0x0,%esi
  800420febc:	48 89 c7             	mov    %rax,%rdi
  800420febf:	48 b8 fc 2e 21 04 80 	movabs $0x8004212efc,%rax
  800420fec6:	00 00 00 
  800420fec9:	ff d0                	callq  *%rax
  800420fecb:	83 f8 04             	cmp    $0x4,%eax
  800420fece:	75 05                	jne    800420fed5 <debuginfo_rip+0x2af>
			continue;
  800420fed0:	e9 0d 01 00 00       	jmpq   800420ffe2 <debuginfo_rip+0x3bc>

		cudie.cu_header = &cu;
  800420fed5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420fed9:	48 89 85 20 a2 ff ff 	mov    %rax,-0x5de0(%rbp)
		cudie.cu_die = NULL;
  800420fee0:	48 c7 85 28 a2 ff ff 	movq   $0x0,-0x5dd8(%rbp)
  800420fee7:	00 00 00 00 

		if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
  800420feeb:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  800420fef2:	00 00 00 
  800420fef5:	48 8b 00             	mov    (%rax),%rax
  800420fef8:	48 8d 8d 30 cf ff ff 	lea    -0x30d0(%rbp),%rcx
  800420feff:	48 8d 95 c0 9e ff ff 	lea    -0x6140(%rbp),%rdx
  800420ff06:	48 8d 75 a0          	lea    -0x60(%rbp),%rsi
  800420ff0a:	48 89 c7             	mov    %rax,%rdi
  800420ff0d:	48 b8 fe 30 21 04 80 	movabs $0x80042130fe,%rax
  800420ff14:	00 00 00 
  800420ff17:	ff d0                	callq  *%rax
  800420ff19:	83 f8 04             	cmp    $0x4,%eax
  800420ff1c:	75 05                	jne    800420ff23 <debuginfo_rip+0x2fd>
			continue;
  800420ff1e:	e9 bf 00 00 00       	jmpq   800420ffe2 <debuginfo_rip+0x3bc>

		die.cu_header = &cu;
  800420ff23:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420ff27:	48 89 85 90 d2 ff ff 	mov    %rax,-0x2d70(%rbp)
		die.cu_die = &cudie;
  800420ff2e:	48 8d 85 c0 9e ff ff 	lea    -0x6140(%rbp),%rax
  800420ff35:	48 89 85 98 d2 ff ff 	mov    %rax,-0x2d68(%rbp)
		while(1)
		{
			if(list_func_die(info, &die, addr))
  800420ff3c:	48 8b 95 48 6e ff ff 	mov    -0x91b8(%rbp),%rdx
  800420ff43:	48 8d 8d 30 cf ff ff 	lea    -0x30d0(%rbp),%rcx
  800420ff4a:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420ff51:	48 89 ce             	mov    %rcx,%rsi
  800420ff54:	48 89 c7             	mov    %rax,%rdi
  800420ff57:	48 b8 00 f5 20 04 80 	movabs $0x800420f500,%rax
  800420ff5e:	00 00 00 
  800420ff61:	ff d0                	callq  *%rax
  800420ff63:	85 c0                	test   %eax,%eax
  800420ff65:	0f 85 ac 00 00 00    	jne    8004210017 <debuginfo_rip+0x3f1>
				goto find_done;
			if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
  800420ff6b:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  800420ff72:	00 00 00 
  800420ff75:	48 8b 00             	mov    (%rax),%rax
  800420ff78:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
  800420ff7c:	48 8d 95 50 6e ff ff 	lea    -0x91b0(%rbp),%rdx
  800420ff83:	48 8d b5 30 cf ff ff 	lea    -0x30d0(%rbp),%rsi
  800420ff8a:	48 89 c7             	mov    %rax,%rdi
  800420ff8d:	48 b8 fc 2e 21 04 80 	movabs $0x8004212efc,%rax
  800420ff94:	00 00 00 
  800420ff97:	ff d0                	callq  *%rax
  800420ff99:	85 c0                	test   %eax,%eax
  800420ff9b:	79 02                	jns    800420ff9f <debuginfo_rip+0x379>
				break; 
  800420ff9d:	eb 43                	jmp    800420ffe2 <debuginfo_rip+0x3bc>
			die = die2;
  800420ff9f:	48 8d 85 30 cf ff ff 	lea    -0x30d0(%rbp),%rax
  800420ffa6:	48 8d 8d 50 6e ff ff 	lea    -0x91b0(%rbp),%rcx
  800420ffad:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420ffb2:	48 89 ce             	mov    %rcx,%rsi
  800420ffb5:	48 89 c7             	mov    %rax,%rdi
  800420ffb8:	48 b8 2d 11 21 04 80 	movabs $0x800421112d,%rax
  800420ffbf:	00 00 00 
  800420ffc2:	ff d0                	callq  *%rax
			die.cu_header = &cu;
  800420ffc4:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420ffc8:	48 89 85 90 d2 ff ff 	mov    %rax,-0x2d70(%rbp)
			die.cu_die = &cudie;
  800420ffcf:	48 8d 85 c0 9e ff ff 	lea    -0x6140(%rbp),%rax
  800420ffd6:	48 89 85 98 d2 ff ff 	mov    %rax,-0x2d68(%rbp)
		}
  800420ffdd:	e9 5a ff ff ff       	jmpq   800420ff3c <debuginfo_rip+0x316>
	sect = _dwarf_find_section(".debug_info");	
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
	dbg->dbg_info_size = sect->ds_size;

	assert(dbg->dbg_info_size);
	while(_get_next_cu(dbg, &cu) == 0)
  800420ffe2:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  800420ffe9:	00 00 00 
  800420ffec:	48 8b 00             	mov    (%rax),%rax
  800420ffef:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800420fff3:	48 89 d6             	mov    %rdx,%rsi
  800420fff6:	48 89 c7             	mov    %rax,%rdi
  800420fff9:	48 b8 ad 1e 21 04 80 	movabs $0x8004211ead,%rax
  8004210000:	00 00 00 
  8004210003:	ff d0                	callq  *%rax
  8004210005:	85 c0                	test   %eax,%eax
  8004210007:	0f 84 92 fe ff ff    	je     800420fe9f <debuginfo_rip+0x279>
			die.cu_header = &cu;
			die.cu_die = &cudie;
		}
	}

	return -1;
  800421000d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210012:	e9 c7 00 00 00       	jmpq   80042100de <debuginfo_rip+0x4b8>
		die.cu_header = &cu;
		die.cu_die = &cudie;
		while(1)
		{
			if(list_func_die(info, &die, addr))
				goto find_done;
  8004210017:	90                   	nop

	return -1;

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
  8004210018:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  800421001f:	00 00 00 
  8004210022:	48 8b 00             	mov    (%rax),%rax
  8004210025:	be 00 00 00 00       	mov    $0x0,%esi
  800421002a:	48 89 c7             	mov    %rax,%rdi
  800421002d:	48 b8 14 58 21 04 80 	movabs $0x8004215814,%rax
  8004210034:	00 00 00 
  8004210037:	ff d0                	callq  *%rax
  8004210039:	83 f8 01             	cmp    $0x1,%eax
  800421003c:	75 0a                	jne    8004210048 <debuginfo_rip+0x422>
		return -1;
  800421003e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210043:	e9 96 00 00 00       	jmpq   80042100de <debuginfo_rip+0x4b8>

	if (dwarf_get_fde_at_pc(dbg, addr, fde, cie, NULL) == DW_DLV_OK) {
  8004210048:	48 b8 80 36 23 04 80 	movabs $0x8004233680,%rax
  800421004f:	00 00 00 
  8004210052:	48 8b 08             	mov    (%rax),%rcx
  8004210055:	48 b8 78 36 23 04 80 	movabs $0x8004233678,%rax
  800421005c:	00 00 00 
  800421005f:	48 8b 10             	mov    (%rax),%rdx
  8004210062:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  8004210069:	00 00 00 
  800421006c:	48 8b 00             	mov    (%rax),%rax
  800421006f:	48 8b b5 48 6e ff ff 	mov    -0x91b8(%rbp),%rsi
  8004210076:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800421007c:	48 89 c7             	mov    %rax,%rdi
  800421007f:	48 b8 1c 33 21 04 80 	movabs $0x800421331c,%rax
  8004210086:	00 00 00 
  8004210089:	ff d0                	callq  *%rax
  800421008b:	85 c0                	test   %eax,%eax
  800421008d:	75 4a                	jne    80042100d9 <debuginfo_rip+0x4b3>
		dwarf_get_fde_info_for_all_regs(dbg, fde, addr,
  800421008f:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  8004210096:	48 8d 88 a8 00 00 00 	lea    0xa8(%rax),%rcx
  800421009d:	48 b8 78 36 23 04 80 	movabs $0x8004233678,%rax
  80042100a4:	00 00 00 
  80042100a7:	48 8b 30             	mov    (%rax),%rsi
  80042100aa:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  80042100b1:	00 00 00 
  80042100b4:	48 8b 00             	mov    (%rax),%rax
  80042100b7:	48 8b 95 48 6e ff ff 	mov    -0x91b8(%rbp),%rdx
  80042100be:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80042100c4:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80042100ca:	48 89 c7             	mov    %rax,%rdi
  80042100cd:	48 b8 0c 46 21 04 80 	movabs $0x800421460c,%rax
  80042100d4:	00 00 00 
  80042100d7:	ff d0                	callq  *%rax
					break;
			}
		}
#endif
	}
	return 0;
  80042100d9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042100de:	c9                   	leaveq 
  80042100df:	c3                   	retq   

00000080042100e0 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80042100e0:	55                   	push   %rbp
  80042100e1:	48 89 e5             	mov    %rsp,%rbp
  80042100e4:	48 83 ec 30          	sub    $0x30,%rsp
  80042100e8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80042100ec:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80042100f0:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80042100f4:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
  80042100f7:	44 89 45 e0          	mov    %r8d,-0x20(%rbp)
  80042100fb:	44 89 4d dc          	mov    %r9d,-0x24(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  80042100ff:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210102:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004210106:	77 54                	ja     800421015c <printnum+0x7c>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  8004210108:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421010b:	8d 78 ff             	lea    -0x1(%rax),%edi
  800421010e:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  8004210111:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210115:	ba 00 00 00 00       	mov    $0x0,%edx
  800421011a:	48 f7 f6             	div    %rsi
  800421011d:	49 89 c2             	mov    %rax,%r10
  8004210120:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  8004210123:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004210126:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800421012a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421012e:	41 89 c9             	mov    %ecx,%r9d
  8004210131:	41 89 f8             	mov    %edi,%r8d
  8004210134:	89 d1                	mov    %edx,%ecx
  8004210136:	4c 89 d2             	mov    %r10,%rdx
  8004210139:	48 89 c7             	mov    %rax,%rdi
  800421013c:	48 b8 e0 00 21 04 80 	movabs $0x80042100e0,%rax
  8004210143:	00 00 00 
  8004210146:	ff d0                	callq  *%rax
  8004210148:	eb 1c                	jmp    8004210166 <printnum+0x86>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  800421014a:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800421014e:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004210151:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210155:	48 89 ce             	mov    %rcx,%rsi
  8004210158:	89 d7                	mov    %edx,%edi
  800421015a:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800421015c:	83 6d e0 01          	subl   $0x1,-0x20(%rbp)
  8004210160:	83 7d e0 00          	cmpl   $0x0,-0x20(%rbp)
  8004210164:	7f e4                	jg     800421014a <printnum+0x6a>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  8004210166:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004210169:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421016d:	ba 00 00 00 00       	mov    $0x0,%edx
  8004210172:	48 f7 f1             	div    %rcx
  8004210175:	48 b8 f0 0f 22 04 80 	movabs $0x8004220ff0,%rax
  800421017c:	00 00 00 
  800421017f:	0f b6 04 10          	movzbl (%rax,%rdx,1),%eax
  8004210183:	0f be d0             	movsbl %al,%edx
  8004210186:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800421018a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421018e:	48 89 ce             	mov    %rcx,%rsi
  8004210191:	89 d7                	mov    %edx,%edi
  8004210193:	ff d0                	callq  *%rax
}
  8004210195:	90                   	nop
  8004210196:	c9                   	leaveq 
  8004210197:	c3                   	retq   

0000008004210198 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  8004210198:	55                   	push   %rbp
  8004210199:	48 89 e5             	mov    %rsp,%rbp
  800421019c:	48 83 ec 20          	sub    $0x20,%rsp
  80042101a0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042101a4:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  80042101a7:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  80042101ab:	7e 4f                	jle    80042101fc <getuint+0x64>
		x= va_arg(*ap, unsigned long long);
  80042101ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042101b1:	8b 00                	mov    (%rax),%eax
  80042101b3:	83 f8 30             	cmp    $0x30,%eax
  80042101b6:	73 24                	jae    80042101dc <getuint+0x44>
  80042101b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042101bc:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042101c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042101c4:	8b 00                	mov    (%rax),%eax
  80042101c6:	89 c0                	mov    %eax,%eax
  80042101c8:	48 01 d0             	add    %rdx,%rax
  80042101cb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042101cf:	8b 12                	mov    (%rdx),%edx
  80042101d1:	8d 4a 08             	lea    0x8(%rdx),%ecx
  80042101d4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042101d8:	89 0a                	mov    %ecx,(%rdx)
  80042101da:	eb 14                	jmp    80042101f0 <getuint+0x58>
  80042101dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042101e0:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042101e4:	48 8d 48 08          	lea    0x8(%rax),%rcx
  80042101e8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042101ec:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  80042101f0:	48 8b 00             	mov    (%rax),%rax
  80042101f3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042101f7:	e9 9d 00 00 00       	jmpq   8004210299 <getuint+0x101>
	else if (lflag)
  80042101fc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004210200:	74 4c                	je     800421024e <getuint+0xb6>
		x= va_arg(*ap, unsigned long);
  8004210202:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210206:	8b 00                	mov    (%rax),%eax
  8004210208:	83 f8 30             	cmp    $0x30,%eax
  800421020b:	73 24                	jae    8004210231 <getuint+0x99>
  800421020d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210211:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004210215:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210219:	8b 00                	mov    (%rax),%eax
  800421021b:	89 c0                	mov    %eax,%eax
  800421021d:	48 01 d0             	add    %rdx,%rax
  8004210220:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210224:	8b 12                	mov    (%rdx),%edx
  8004210226:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8004210229:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421022d:	89 0a                	mov    %ecx,(%rdx)
  800421022f:	eb 14                	jmp    8004210245 <getuint+0xad>
  8004210231:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210235:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210239:	48 8d 48 08          	lea    0x8(%rax),%rcx
  800421023d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210241:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8004210245:	48 8b 00             	mov    (%rax),%rax
  8004210248:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421024c:	eb 4b                	jmp    8004210299 <getuint+0x101>
	else
		x= va_arg(*ap, unsigned int);
  800421024e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210252:	8b 00                	mov    (%rax),%eax
  8004210254:	83 f8 30             	cmp    $0x30,%eax
  8004210257:	73 24                	jae    800421027d <getuint+0xe5>
  8004210259:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421025d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004210261:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210265:	8b 00                	mov    (%rax),%eax
  8004210267:	89 c0                	mov    %eax,%eax
  8004210269:	48 01 d0             	add    %rdx,%rax
  800421026c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210270:	8b 12                	mov    (%rdx),%edx
  8004210272:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8004210275:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210279:	89 0a                	mov    %ecx,(%rdx)
  800421027b:	eb 14                	jmp    8004210291 <getuint+0xf9>
  800421027d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210281:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210285:	48 8d 48 08          	lea    0x8(%rax),%rcx
  8004210289:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421028d:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8004210291:	8b 00                	mov    (%rax),%eax
  8004210293:	89 c0                	mov    %eax,%eax
  8004210295:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  8004210299:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421029d:	c9                   	leaveq 
  800421029e:	c3                   	retq   

000000800421029f <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  800421029f:	55                   	push   %rbp
  80042102a0:	48 89 e5             	mov    %rsp,%rbp
  80042102a3:	48 83 ec 20          	sub    $0x20,%rsp
  80042102a7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042102ab:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  80042102ae:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  80042102b2:	7e 4f                	jle    8004210303 <getint+0x64>
		x=va_arg(*ap, long long);
  80042102b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042102b8:	8b 00                	mov    (%rax),%eax
  80042102ba:	83 f8 30             	cmp    $0x30,%eax
  80042102bd:	73 24                	jae    80042102e3 <getint+0x44>
  80042102bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042102c3:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042102c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042102cb:	8b 00                	mov    (%rax),%eax
  80042102cd:	89 c0                	mov    %eax,%eax
  80042102cf:	48 01 d0             	add    %rdx,%rax
  80042102d2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042102d6:	8b 12                	mov    (%rdx),%edx
  80042102d8:	8d 4a 08             	lea    0x8(%rdx),%ecx
  80042102db:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042102df:	89 0a                	mov    %ecx,(%rdx)
  80042102e1:	eb 14                	jmp    80042102f7 <getint+0x58>
  80042102e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042102e7:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042102eb:	48 8d 48 08          	lea    0x8(%rax),%rcx
  80042102ef:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042102f3:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  80042102f7:	48 8b 00             	mov    (%rax),%rax
  80042102fa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042102fe:	e9 9d 00 00 00       	jmpq   80042103a0 <getint+0x101>
	else if (lflag)
  8004210303:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004210307:	74 4c                	je     8004210355 <getint+0xb6>
		x=va_arg(*ap, long);
  8004210309:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421030d:	8b 00                	mov    (%rax),%eax
  800421030f:	83 f8 30             	cmp    $0x30,%eax
  8004210312:	73 24                	jae    8004210338 <getint+0x99>
  8004210314:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210318:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800421031c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210320:	8b 00                	mov    (%rax),%eax
  8004210322:	89 c0                	mov    %eax,%eax
  8004210324:	48 01 d0             	add    %rdx,%rax
  8004210327:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421032b:	8b 12                	mov    (%rdx),%edx
  800421032d:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8004210330:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210334:	89 0a                	mov    %ecx,(%rdx)
  8004210336:	eb 14                	jmp    800421034c <getint+0xad>
  8004210338:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421033c:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210340:	48 8d 48 08          	lea    0x8(%rax),%rcx
  8004210344:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210348:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800421034c:	48 8b 00             	mov    (%rax),%rax
  800421034f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210353:	eb 4b                	jmp    80042103a0 <getint+0x101>
	else
		x=va_arg(*ap, int);
  8004210355:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210359:	8b 00                	mov    (%rax),%eax
  800421035b:	83 f8 30             	cmp    $0x30,%eax
  800421035e:	73 24                	jae    8004210384 <getint+0xe5>
  8004210360:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210364:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004210368:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421036c:	8b 00                	mov    (%rax),%eax
  800421036e:	89 c0                	mov    %eax,%eax
  8004210370:	48 01 d0             	add    %rdx,%rax
  8004210373:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210377:	8b 12                	mov    (%rdx),%edx
  8004210379:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800421037c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210380:	89 0a                	mov    %ecx,(%rdx)
  8004210382:	eb 14                	jmp    8004210398 <getint+0xf9>
  8004210384:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210388:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421038c:	48 8d 48 08          	lea    0x8(%rax),%rcx
  8004210390:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210394:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8004210398:	8b 00                	mov    (%rax),%eax
  800421039a:	48 98                	cltq   
  800421039c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  80042103a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042103a4:	c9                   	leaveq 
  80042103a5:	c3                   	retq   

00000080042103a6 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  80042103a6:	55                   	push   %rbp
  80042103a7:	48 89 e5             	mov    %rsp,%rbp
  80042103aa:	41 54                	push   %r12
  80042103ac:	53                   	push   %rbx
  80042103ad:	48 83 ec 60          	sub    $0x60,%rsp
  80042103b1:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80042103b5:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  80042103b9:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  80042103bd:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  80042103c1:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  80042103c5:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042103c9:	48 8b 0a             	mov    (%rdx),%rcx
  80042103cc:	48 89 08             	mov    %rcx,(%rax)
  80042103cf:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042103d3:	48 89 48 08          	mov    %rcx,0x8(%rax)
  80042103d7:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80042103db:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80042103df:	eb 17                	jmp    80042103f8 <vprintfmt+0x52>
			if (ch == '\0')
  80042103e1:	85 db                	test   %ebx,%ebx
  80042103e3:	0f 84 b9 04 00 00    	je     80042108a2 <vprintfmt+0x4fc>
				return;
			putch(ch, putdat);
  80042103e9:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042103ed:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042103f1:	48 89 d6             	mov    %rdx,%rsi
  80042103f4:	89 df                	mov    %ebx,%edi
  80042103f6:	ff d0                	callq  *%rax
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80042103f8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042103fc:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210400:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  8004210404:	0f b6 00             	movzbl (%rax),%eax
  8004210407:	0f b6 d8             	movzbl %al,%ebx
  800421040a:	83 fb 25             	cmp    $0x25,%ebx
  800421040d:	75 d2                	jne    80042103e1 <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  800421040f:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  8004210413:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  800421041a:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  8004210421:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  8004210428:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800421042f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004210433:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210437:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800421043b:	0f b6 00             	movzbl (%rax),%eax
  800421043e:	0f b6 d8             	movzbl %al,%ebx
  8004210441:	8d 43 dd             	lea    -0x23(%rbx),%eax
  8004210444:	83 f8 55             	cmp    $0x55,%eax
  8004210447:	0f 87 22 04 00 00    	ja     800421086f <vprintfmt+0x4c9>
  800421044d:	89 c0                	mov    %eax,%eax
  800421044f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004210456:	00 
  8004210457:	48 b8 18 10 22 04 80 	movabs $0x8004221018,%rax
  800421045e:	00 00 00 
  8004210461:	48 01 d0             	add    %rdx,%rax
  8004210464:	48 8b 00             	mov    (%rax),%rax
  8004210467:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  8004210469:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  800421046d:	eb c0                	jmp    800421042f <vprintfmt+0x89>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800421046f:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  8004210473:	eb ba                	jmp    800421042f <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  8004210475:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  800421047c:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800421047f:	89 d0                	mov    %edx,%eax
  8004210481:	c1 e0 02             	shl    $0x2,%eax
  8004210484:	01 d0                	add    %edx,%eax
  8004210486:	01 c0                	add    %eax,%eax
  8004210488:	01 d8                	add    %ebx,%eax
  800421048a:	83 e8 30             	sub    $0x30,%eax
  800421048d:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  8004210490:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004210494:	0f b6 00             	movzbl (%rax),%eax
  8004210497:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  800421049a:	83 fb 2f             	cmp    $0x2f,%ebx
  800421049d:	7e 60                	jle    80042104ff <vprintfmt+0x159>
  800421049f:	83 fb 39             	cmp    $0x39,%ebx
  80042104a2:	7f 5b                	jg     80042104ff <vprintfmt+0x159>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  80042104a4:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  80042104a9:	eb d1                	jmp    800421047c <vprintfmt+0xd6>
			goto process_precision;

		case '*':
			precision = va_arg(aq, int);
  80042104ab:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80042104ae:	83 f8 30             	cmp    $0x30,%eax
  80042104b1:	73 17                	jae    80042104ca <vprintfmt+0x124>
  80042104b3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042104b7:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80042104ba:	89 d2                	mov    %edx,%edx
  80042104bc:	48 01 d0             	add    %rdx,%rax
  80042104bf:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80042104c2:	83 c2 08             	add    $0x8,%edx
  80042104c5:	89 55 b8             	mov    %edx,-0x48(%rbp)
  80042104c8:	eb 0c                	jmp    80042104d6 <vprintfmt+0x130>
  80042104ca:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042104ce:	48 8d 50 08          	lea    0x8(%rax),%rdx
  80042104d2:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  80042104d6:	8b 00                	mov    (%rax),%eax
  80042104d8:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  80042104db:	eb 23                	jmp    8004210500 <vprintfmt+0x15a>

		case '.':
			if (width < 0)
  80042104dd:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042104e1:	0f 89 48 ff ff ff    	jns    800421042f <vprintfmt+0x89>
				width = 0;
  80042104e7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  80042104ee:	e9 3c ff ff ff       	jmpq   800421042f <vprintfmt+0x89>

		case '#':
			altflag = 1;
  80042104f3:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  80042104fa:	e9 30 ff ff ff       	jmpq   800421042f <vprintfmt+0x89>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
  80042104ff:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
  8004210500:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004210504:	0f 89 25 ff ff ff    	jns    800421042f <vprintfmt+0x89>
				width = precision, precision = -1;
  800421050a:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421050d:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004210510:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  8004210517:	e9 13 ff ff ff       	jmpq   800421042f <vprintfmt+0x89>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  800421051c:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  8004210520:	e9 0a ff ff ff       	jmpq   800421042f <vprintfmt+0x89>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  8004210525:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8004210528:	83 f8 30             	cmp    $0x30,%eax
  800421052b:	73 17                	jae    8004210544 <vprintfmt+0x19e>
  800421052d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210531:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8004210534:	89 d2                	mov    %edx,%edx
  8004210536:	48 01 d0             	add    %rdx,%rax
  8004210539:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800421053c:	83 c2 08             	add    $0x8,%edx
  800421053f:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8004210542:	eb 0c                	jmp    8004210550 <vprintfmt+0x1aa>
  8004210544:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210548:	48 8d 50 08          	lea    0x8(%rax),%rdx
  800421054c:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8004210550:	8b 10                	mov    (%rax),%edx
  8004210552:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004210556:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421055a:	48 89 ce             	mov    %rcx,%rsi
  800421055d:	89 d7                	mov    %edx,%edi
  800421055f:	ff d0                	callq  *%rax
			break;
  8004210561:	e9 37 03 00 00       	jmpq   800421089d <vprintfmt+0x4f7>

			// error message
		case 'e':
			err = va_arg(aq, int);
  8004210566:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8004210569:	83 f8 30             	cmp    $0x30,%eax
  800421056c:	73 17                	jae    8004210585 <vprintfmt+0x1df>
  800421056e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210572:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8004210575:	89 d2                	mov    %edx,%edx
  8004210577:	48 01 d0             	add    %rdx,%rax
  800421057a:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800421057d:	83 c2 08             	add    $0x8,%edx
  8004210580:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8004210583:	eb 0c                	jmp    8004210591 <vprintfmt+0x1eb>
  8004210585:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210589:	48 8d 50 08          	lea    0x8(%rax),%rdx
  800421058d:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8004210591:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  8004210593:	85 db                	test   %ebx,%ebx
  8004210595:	79 02                	jns    8004210599 <vprintfmt+0x1f3>
				err = -err;
  8004210597:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  8004210599:	83 fb 15             	cmp    $0x15,%ebx
  800421059c:	7f 16                	jg     80042105b4 <vprintfmt+0x20e>
  800421059e:	48 b8 40 0f 22 04 80 	movabs $0x8004220f40,%rax
  80042105a5:	00 00 00 
  80042105a8:	48 63 d3             	movslq %ebx,%rdx
  80042105ab:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  80042105af:	4d 85 e4             	test   %r12,%r12
  80042105b2:	75 2e                	jne    80042105e2 <vprintfmt+0x23c>
				printfmt(putch, putdat, "error %d", err);
  80042105b4:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  80042105b8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042105bc:	89 d9                	mov    %ebx,%ecx
  80042105be:	48 ba 01 10 22 04 80 	movabs $0x8004221001,%rdx
  80042105c5:	00 00 00 
  80042105c8:	48 89 c7             	mov    %rax,%rdi
  80042105cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042105d0:	49 b8 ac 08 21 04 80 	movabs $0x80042108ac,%r8
  80042105d7:	00 00 00 
  80042105da:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  80042105dd:	e9 bb 02 00 00       	jmpq   800421089d <vprintfmt+0x4f7>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  80042105e2:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  80042105e6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042105ea:	4c 89 e1             	mov    %r12,%rcx
  80042105ed:	48 ba 0a 10 22 04 80 	movabs $0x800422100a,%rdx
  80042105f4:	00 00 00 
  80042105f7:	48 89 c7             	mov    %rax,%rdi
  80042105fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042105ff:	49 b8 ac 08 21 04 80 	movabs $0x80042108ac,%r8
  8004210606:	00 00 00 
  8004210609:	41 ff d0             	callq  *%r8
			break;
  800421060c:	e9 8c 02 00 00       	jmpq   800421089d <vprintfmt+0x4f7>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  8004210611:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8004210614:	83 f8 30             	cmp    $0x30,%eax
  8004210617:	73 17                	jae    8004210630 <vprintfmt+0x28a>
  8004210619:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421061d:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8004210620:	89 d2                	mov    %edx,%edx
  8004210622:	48 01 d0             	add    %rdx,%rax
  8004210625:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8004210628:	83 c2 08             	add    $0x8,%edx
  800421062b:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800421062e:	eb 0c                	jmp    800421063c <vprintfmt+0x296>
  8004210630:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210634:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004210638:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800421063c:	4c 8b 20             	mov    (%rax),%r12
  800421063f:	4d 85 e4             	test   %r12,%r12
  8004210642:	75 0a                	jne    800421064e <vprintfmt+0x2a8>
				p = "(null)";
  8004210644:	49 bc 0d 10 22 04 80 	movabs $0x800422100d,%r12
  800421064b:	00 00 00 
			if (width > 0 && padc != '-')
  800421064e:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004210652:	7e 78                	jle    80042106cc <vprintfmt+0x326>
  8004210654:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  8004210658:	74 72                	je     80042106cc <vprintfmt+0x326>
				for (width -= strnlen(p, precision); width > 0; width--)
  800421065a:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421065d:	48 98                	cltq   
  800421065f:	48 89 c6             	mov    %rax,%rsi
  8004210662:	4c 89 e7             	mov    %r12,%rdi
  8004210665:	48 b8 b3 0c 21 04 80 	movabs $0x8004210cb3,%rax
  800421066c:	00 00 00 
  800421066f:	ff d0                	callq  *%rax
  8004210671:	29 45 dc             	sub    %eax,-0x24(%rbp)
  8004210674:	eb 17                	jmp    800421068d <vprintfmt+0x2e7>
					putch(padc, putdat);
  8004210676:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  800421067a:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800421067e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210682:	48 89 ce             	mov    %rcx,%rsi
  8004210685:	89 d7                	mov    %edx,%edi
  8004210687:	ff d0                	callq  *%rax
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  8004210689:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800421068d:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004210691:	7f e3                	jg     8004210676 <vprintfmt+0x2d0>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  8004210693:	eb 37                	jmp    80042106cc <vprintfmt+0x326>
				if (altflag && (ch < ' ' || ch > '~'))
  8004210695:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  8004210699:	74 1e                	je     80042106b9 <vprintfmt+0x313>
  800421069b:	83 fb 1f             	cmp    $0x1f,%ebx
  800421069e:	7e 05                	jle    80042106a5 <vprintfmt+0x2ff>
  80042106a0:	83 fb 7e             	cmp    $0x7e,%ebx
  80042106a3:	7e 14                	jle    80042106b9 <vprintfmt+0x313>
					putch('?', putdat);
  80042106a5:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042106a9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042106ad:	48 89 d6             	mov    %rdx,%rsi
  80042106b0:	bf 3f 00 00 00       	mov    $0x3f,%edi
  80042106b5:	ff d0                	callq  *%rax
  80042106b7:	eb 0f                	jmp    80042106c8 <vprintfmt+0x322>
				else
					putch(ch, putdat);
  80042106b9:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042106bd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042106c1:	48 89 d6             	mov    %rdx,%rsi
  80042106c4:	89 df                	mov    %ebx,%edi
  80042106c6:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80042106c8:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  80042106cc:	4c 89 e0             	mov    %r12,%rax
  80042106cf:	4c 8d 60 01          	lea    0x1(%rax),%r12
  80042106d3:	0f b6 00             	movzbl (%rax),%eax
  80042106d6:	0f be d8             	movsbl %al,%ebx
  80042106d9:	85 db                	test   %ebx,%ebx
  80042106db:	74 28                	je     8004210705 <vprintfmt+0x35f>
  80042106dd:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  80042106e1:	78 b2                	js     8004210695 <vprintfmt+0x2ef>
  80042106e3:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  80042106e7:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  80042106eb:	79 a8                	jns    8004210695 <vprintfmt+0x2ef>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  80042106ed:	eb 16                	jmp    8004210705 <vprintfmt+0x35f>
				putch(' ', putdat);
  80042106ef:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042106f3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042106f7:	48 89 d6             	mov    %rdx,%rsi
  80042106fa:	bf 20 00 00 00       	mov    $0x20,%edi
  80042106ff:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  8004210701:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  8004210705:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004210709:	7f e4                	jg     80042106ef <vprintfmt+0x349>
				putch(' ', putdat);
			break;
  800421070b:	e9 8d 01 00 00       	jmpq   800421089d <vprintfmt+0x4f7>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  8004210710:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8004210714:	be 03 00 00 00       	mov    $0x3,%esi
  8004210719:	48 89 c7             	mov    %rax,%rdi
  800421071c:	48 b8 9f 02 21 04 80 	movabs $0x800421029f,%rax
  8004210723:	00 00 00 
  8004210726:	ff d0                	callq  *%rax
  8004210728:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  800421072c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210730:	48 85 c0             	test   %rax,%rax
  8004210733:	79 1d                	jns    8004210752 <vprintfmt+0x3ac>
				putch('-', putdat);
  8004210735:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004210739:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421073d:	48 89 d6             	mov    %rdx,%rsi
  8004210740:	bf 2d 00 00 00       	mov    $0x2d,%edi
  8004210745:	ff d0                	callq  *%rax
				num = -(long long) num;
  8004210747:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421074b:	48 f7 d8             	neg    %rax
  800421074e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  8004210752:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  8004210759:	e9 d2 00 00 00       	jmpq   8004210830 <vprintfmt+0x48a>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  800421075e:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8004210762:	be 03 00 00 00       	mov    $0x3,%esi
  8004210767:	48 89 c7             	mov    %rax,%rdi
  800421076a:	48 b8 98 01 21 04 80 	movabs $0x8004210198,%rax
  8004210771:	00 00 00 
  8004210774:	ff d0                	callq  *%rax
  8004210776:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  800421077a:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  8004210781:	e9 aa 00 00 00       	jmpq   8004210830 <vprintfmt+0x48a>

			// (unsigned) octal
		case 'o':

			num = getuint(&aq, 3);
  8004210786:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800421078a:	be 03 00 00 00       	mov    $0x3,%esi
  800421078f:	48 89 c7             	mov    %rax,%rdi
  8004210792:	48 b8 98 01 21 04 80 	movabs $0x8004210198,%rax
  8004210799:	00 00 00 
  800421079c:	ff d0                	callq  *%rax
  800421079e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 8;
  80042107a2:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
			goto number;
  80042107a9:	e9 82 00 00 00       	jmpq   8004210830 <vprintfmt+0x48a>


			// pointer
		case 'p':
			putch('0', putdat);
  80042107ae:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042107b2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042107b6:	48 89 d6             	mov    %rdx,%rsi
  80042107b9:	bf 30 00 00 00       	mov    $0x30,%edi
  80042107be:	ff d0                	callq  *%rax
			putch('x', putdat);
  80042107c0:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042107c4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042107c8:	48 89 d6             	mov    %rdx,%rsi
  80042107cb:	bf 78 00 00 00       	mov    $0x78,%edi
  80042107d0:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  80042107d2:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80042107d5:	83 f8 30             	cmp    $0x30,%eax
  80042107d8:	73 17                	jae    80042107f1 <vprintfmt+0x44b>
  80042107da:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042107de:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80042107e1:	89 d2                	mov    %edx,%edx
  80042107e3:	48 01 d0             	add    %rdx,%rax
  80042107e6:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80042107e9:	83 c2 08             	add    $0x8,%edx
  80042107ec:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  80042107ef:	eb 0c                	jmp    80042107fd <vprintfmt+0x457>
				(uintptr_t) va_arg(aq, void *);
  80042107f1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042107f5:	48 8d 50 08          	lea    0x8(%rax),%rdx
  80042107f9:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  80042107fd:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  8004210800:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  8004210804:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  800421080b:	eb 23                	jmp    8004210830 <vprintfmt+0x48a>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  800421080d:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8004210811:	be 03 00 00 00       	mov    $0x3,%esi
  8004210816:	48 89 c7             	mov    %rax,%rdi
  8004210819:	48 b8 98 01 21 04 80 	movabs $0x8004210198,%rax
  8004210820:	00 00 00 
  8004210823:	ff d0                	callq  *%rax
  8004210825:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  8004210829:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  8004210830:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  8004210835:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004210838:	8b 7d dc             	mov    -0x24(%rbp),%edi
  800421083b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421083f:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  8004210843:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210847:	45 89 c1             	mov    %r8d,%r9d
  800421084a:	41 89 f8             	mov    %edi,%r8d
  800421084d:	48 89 c7             	mov    %rax,%rdi
  8004210850:	48 b8 e0 00 21 04 80 	movabs $0x80042100e0,%rax
  8004210857:	00 00 00 
  800421085a:	ff d0                	callq  *%rax
			break;
  800421085c:	eb 3f                	jmp    800421089d <vprintfmt+0x4f7>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  800421085e:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004210862:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210866:	48 89 d6             	mov    %rdx,%rsi
  8004210869:	89 df                	mov    %ebx,%edi
  800421086b:	ff d0                	callq  *%rax
			break;
  800421086d:	eb 2e                	jmp    800421089d <vprintfmt+0x4f7>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800421086f:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004210873:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210877:	48 89 d6             	mov    %rdx,%rsi
  800421087a:	bf 25 00 00 00       	mov    $0x25,%edi
  800421087f:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  8004210881:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  8004210886:	eb 05                	jmp    800421088d <vprintfmt+0x4e7>
  8004210888:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800421088d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004210891:	48 83 e8 01          	sub    $0x1,%rax
  8004210895:	0f b6 00             	movzbl (%rax),%eax
  8004210898:	3c 25                	cmp    $0x25,%al
  800421089a:	75 ec                	jne    8004210888 <vprintfmt+0x4e2>
				/* do nothing */;
			break;
  800421089c:	90                   	nop
		}
	}
  800421089d:	e9 3d fb ff ff       	jmpq   80042103df <vprintfmt+0x39>
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
  80042108a2:	90                   	nop
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  80042108a3:	48 83 c4 60          	add    $0x60,%rsp
  80042108a7:	5b                   	pop    %rbx
  80042108a8:	41 5c                	pop    %r12
  80042108aa:	5d                   	pop    %rbp
  80042108ab:	c3                   	retq   

00000080042108ac <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  80042108ac:	55                   	push   %rbp
  80042108ad:	48 89 e5             	mov    %rsp,%rbp
  80042108b0:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  80042108b7:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  80042108be:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  80042108c5:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
  80042108cc:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  80042108d3:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  80042108da:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  80042108e1:	84 c0                	test   %al,%al
  80042108e3:	74 20                	je     8004210905 <printfmt+0x59>
  80042108e5:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80042108e9:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  80042108ed:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  80042108f1:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80042108f5:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80042108f9:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  80042108fd:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004210901:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;

	va_start(ap, fmt);
  8004210905:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800421090c:	00 00 00 
  800421090f:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  8004210916:	00 00 00 
  8004210919:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800421091d:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004210924:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800421092b:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  8004210932:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  8004210939:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  8004210940:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  8004210947:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421094e:	48 89 c7             	mov    %rax,%rdi
  8004210951:	48 b8 a6 03 21 04 80 	movabs $0x80042103a6,%rax
  8004210958:	00 00 00 
  800421095b:	ff d0                	callq  *%rax
	va_end(ap);
}
  800421095d:	90                   	nop
  800421095e:	c9                   	leaveq 
  800421095f:	c3                   	retq   

0000008004210960 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  8004210960:	55                   	push   %rbp
  8004210961:	48 89 e5             	mov    %rsp,%rbp
  8004210964:	48 83 ec 10          	sub    $0x10,%rsp
  8004210968:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800421096b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  800421096f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210973:	8b 40 10             	mov    0x10(%rax),%eax
  8004210976:	8d 50 01             	lea    0x1(%rax),%edx
  8004210979:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421097d:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  8004210980:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210984:	48 8b 10             	mov    (%rax),%rdx
  8004210987:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421098b:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421098f:	48 39 c2             	cmp    %rax,%rdx
  8004210992:	73 17                	jae    80042109ab <sprintputch+0x4b>
		*b->buf++ = ch;
  8004210994:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210998:	48 8b 00             	mov    (%rax),%rax
  800421099b:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800421099f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042109a3:	48 89 0a             	mov    %rcx,(%rdx)
  80042109a6:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042109a9:	88 10                	mov    %dl,(%rax)
}
  80042109ab:	90                   	nop
  80042109ac:	c9                   	leaveq 
  80042109ad:	c3                   	retq   

00000080042109ae <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80042109ae:	55                   	push   %rbp
  80042109af:	48 89 e5             	mov    %rsp,%rbp
  80042109b2:	48 83 ec 50          	sub    $0x50,%rsp
  80042109b6:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042109ba:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  80042109bd:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042109c1:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  80042109c5:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  80042109c9:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042109cd:	48 8b 0a             	mov    (%rdx),%rcx
  80042109d0:	48 89 08             	mov    %rcx,(%rax)
  80042109d3:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042109d7:	48 89 48 08          	mov    %rcx,0x8(%rax)
  80042109db:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80042109df:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  80042109e3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042109e7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042109eb:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042109ee:	48 98                	cltq   
  80042109f0:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  80042109f4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042109f8:	48 01 d0             	add    %rdx,%rax
  80042109fb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042109ff:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  8004210a06:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210a0b:	74 06                	je     8004210a13 <vsnprintf+0x65>
  8004210a0d:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004210a11:	7f 07                	jg     8004210a1a <vsnprintf+0x6c>
		return -E_INVAL;
  8004210a13:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8004210a18:	eb 2f                	jmp    8004210a49 <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  8004210a1a:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  8004210a1e:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004210a22:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8004210a26:	48 89 c6             	mov    %rax,%rsi
  8004210a29:	48 bf 60 09 21 04 80 	movabs $0x8004210960,%rdi
  8004210a30:	00 00 00 
  8004210a33:	48 b8 a6 03 21 04 80 	movabs $0x80042103a6,%rax
  8004210a3a:	00 00 00 
  8004210a3d:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  8004210a3f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210a43:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  8004210a46:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  8004210a49:	c9                   	leaveq 
  8004210a4a:	c3                   	retq   

0000008004210a4b <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  8004210a4b:	55                   	push   %rbp
  8004210a4c:	48 89 e5             	mov    %rsp,%rbp
  8004210a4f:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  8004210a56:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  8004210a5d:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  8004210a63:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
  8004210a6a:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004210a71:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004210a78:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004210a7f:	84 c0                	test   %al,%al
  8004210a81:	74 20                	je     8004210aa3 <snprintf+0x58>
  8004210a83:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004210a87:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004210a8b:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004210a8f:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004210a93:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004210a97:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004210a9b:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004210a9f:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  8004210aa3:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  8004210aaa:	00 00 00 
  8004210aad:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  8004210ab4:	00 00 00 
  8004210ab7:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004210abb:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004210ac2:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004210ac9:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  8004210ad0:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  8004210ad7:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8004210ade:	48 8b 0a             	mov    (%rdx),%rcx
  8004210ae1:	48 89 08             	mov    %rcx,(%rax)
  8004210ae4:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004210ae8:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004210aec:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004210af0:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  8004210af4:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  8004210afb:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004210b02:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  8004210b08:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004210b0f:	48 89 c7             	mov    %rax,%rdi
  8004210b12:	48 b8 ae 09 21 04 80 	movabs $0x80042109ae,%rax
  8004210b19:	00 00 00 
  8004210b1c:	ff d0                	callq  *%rax
  8004210b1e:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  8004210b24:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8004210b2a:	c9                   	leaveq 
  8004210b2b:	c3                   	retq   

0000008004210b2c <readline>:
#define BUFLEN 1024
static char buf[BUFLEN];

char *
readline(const char *prompt)
{
  8004210b2c:	55                   	push   %rbp
  8004210b2d:	48 89 e5             	mov    %rsp,%rbp
  8004210b30:	48 83 ec 20          	sub    $0x20,%rsp
  8004210b34:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, c, echoing;


#if JOS_KERNEL
	if (prompt != NULL)
  8004210b38:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210b3d:	74 22                	je     8004210b61 <readline+0x35>
		cprintf("%s", prompt);
  8004210b3f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210b43:	48 89 c6             	mov    %rax,%rsi
  8004210b46:	48 bf c8 12 22 04 80 	movabs $0x80042212c8,%rdi
  8004210b4d:	00 00 00 
  8004210b50:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210b55:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004210b5c:	00 00 00 
  8004210b5f:	ff d2                	callq  *%rdx
	if (prompt != NULL)
		fprintf(1, "%s", prompt);
#endif


	i = 0;
  8004210b61:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	echoing = iscons(0);
  8004210b68:	bf 00 00 00 00       	mov    $0x0,%edi
  8004210b6d:	48 b8 9c 12 20 04 80 	movabs $0x800420129c,%rax
  8004210b74:	00 00 00 
  8004210b77:	ff d0                	callq  *%rax
  8004210b79:	89 45 f8             	mov    %eax,-0x8(%rbp)
	while (1) {
		c = getchar();
  8004210b7c:	48 b8 7a 12 20 04 80 	movabs $0x800420127a,%rax
  8004210b83:	00 00 00 
  8004210b86:	ff d0                	callq  *%rax
  8004210b88:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (c < 0) {
  8004210b8b:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004210b8f:	79 30                	jns    8004210bc1 <readline+0x95>

			if (c != -E_EOF)
  8004210b91:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%rbp)
  8004210b95:	74 20                	je     8004210bb7 <readline+0x8b>
				cprintf("read error: %e\n", c);
  8004210b97:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210b9a:	89 c6                	mov    %eax,%esi
  8004210b9c:	48 bf cb 12 22 04 80 	movabs $0x80042212cb,%rdi
  8004210ba3:	00 00 00 
  8004210ba6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210bab:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004210bb2:	00 00 00 
  8004210bb5:	ff d2                	callq  *%rdx

			return NULL;
  8004210bb7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210bbc:	e9 c2 00 00 00       	jmpq   8004210c83 <readline+0x157>
		} else if ((c == '\b' || c == '\x7f') && i > 0) {
  8004210bc1:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  8004210bc5:	74 06                	je     8004210bcd <readline+0xa1>
  8004210bc7:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  8004210bcb:	75 26                	jne    8004210bf3 <readline+0xc7>
  8004210bcd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004210bd1:	7e 20                	jle    8004210bf3 <readline+0xc7>
			if (echoing)
  8004210bd3:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004210bd7:	74 11                	je     8004210bea <readline+0xbe>
				cputchar('\b');
  8004210bd9:	bf 08 00 00 00       	mov    $0x8,%edi
  8004210bde:	48 b8 5b 12 20 04 80 	movabs $0x800420125b,%rax
  8004210be5:	00 00 00 
  8004210be8:	ff d0                	callq  *%rax
			i--;
  8004210bea:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  8004210bee:	e9 8b 00 00 00       	jmpq   8004210c7e <readline+0x152>
		} else if (c >= ' ' && i < BUFLEN-1) {
  8004210bf3:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  8004210bf7:	7e 3f                	jle    8004210c38 <readline+0x10c>
  8004210bf9:	81 7d fc fe 03 00 00 	cmpl   $0x3fe,-0x4(%rbp)
  8004210c00:	7f 36                	jg     8004210c38 <readline+0x10c>
			if (echoing)
  8004210c02:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004210c06:	74 11                	je     8004210c19 <readline+0xed>
				cputchar(c);
  8004210c08:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210c0b:	89 c7                	mov    %eax,%edi
  8004210c0d:	48 b8 5b 12 20 04 80 	movabs $0x800420125b,%rax
  8004210c14:	00 00 00 
  8004210c17:	ff d0                	callq  *%rax
			buf[i++] = c;
  8004210c19:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004210c1c:	8d 50 01             	lea    0x1(%rax),%edx
  8004210c1f:	89 55 fc             	mov    %edx,-0x4(%rbp)
  8004210c22:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004210c25:	89 d1                	mov    %edx,%ecx
  8004210c27:	48 ba a0 e2 4d 04 80 	movabs $0x80044de2a0,%rdx
  8004210c2e:	00 00 00 
  8004210c31:	48 98                	cltq   
  8004210c33:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  8004210c36:	eb 46                	jmp    8004210c7e <readline+0x152>
		} else if (c == '\n' || c == '\r') {
  8004210c38:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  8004210c3c:	74 0a                	je     8004210c48 <readline+0x11c>
  8004210c3e:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  8004210c42:	0f 85 34 ff ff ff    	jne    8004210b7c <readline+0x50>
			if (echoing)
  8004210c48:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004210c4c:	74 11                	je     8004210c5f <readline+0x133>
				cputchar('\n');
  8004210c4e:	bf 0a 00 00 00       	mov    $0xa,%edi
  8004210c53:	48 b8 5b 12 20 04 80 	movabs $0x800420125b,%rax
  8004210c5a:	00 00 00 
  8004210c5d:	ff d0                	callq  *%rax
			buf[i] = 0;
  8004210c5f:	48 ba a0 e2 4d 04 80 	movabs $0x80044de2a0,%rdx
  8004210c66:	00 00 00 
  8004210c69:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004210c6c:	48 98                	cltq   
  8004210c6e:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
			return buf;
  8004210c72:	48 b8 a0 e2 4d 04 80 	movabs $0x80044de2a0,%rax
  8004210c79:	00 00 00 
  8004210c7c:	eb 05                	jmp    8004210c83 <readline+0x157>
		}
	}
  8004210c7e:	e9 f9 fe ff ff       	jmpq   8004210b7c <readline+0x50>
}
  8004210c83:	c9                   	leaveq 
  8004210c84:	c3                   	retq   

0000008004210c85 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  8004210c85:	55                   	push   %rbp
  8004210c86:	48 89 e5             	mov    %rsp,%rbp
  8004210c89:	48 83 ec 18          	sub    $0x18,%rsp
  8004210c8d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  8004210c91:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004210c98:	eb 09                	jmp    8004210ca3 <strlen+0x1e>
		n++;
  8004210c9a:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  8004210c9e:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004210ca3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210ca7:	0f b6 00             	movzbl (%rax),%eax
  8004210caa:	84 c0                	test   %al,%al
  8004210cac:	75 ec                	jne    8004210c9a <strlen+0x15>
		n++;
	return n;
  8004210cae:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004210cb1:	c9                   	leaveq 
  8004210cb2:	c3                   	retq   

0000008004210cb3 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  8004210cb3:	55                   	push   %rbp
  8004210cb4:	48 89 e5             	mov    %rsp,%rbp
  8004210cb7:	48 83 ec 20          	sub    $0x20,%rsp
  8004210cbb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210cbf:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  8004210cc3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004210cca:	eb 0e                	jmp    8004210cda <strnlen+0x27>
		n++;
  8004210ccc:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  8004210cd0:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004210cd5:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  8004210cda:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004210cdf:	74 0b                	je     8004210cec <strnlen+0x39>
  8004210ce1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210ce5:	0f b6 00             	movzbl (%rax),%eax
  8004210ce8:	84 c0                	test   %al,%al
  8004210cea:	75 e0                	jne    8004210ccc <strnlen+0x19>
		n++;
	return n;
  8004210cec:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004210cef:	c9                   	leaveq 
  8004210cf0:	c3                   	retq   

0000008004210cf1 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  8004210cf1:	55                   	push   %rbp
  8004210cf2:	48 89 e5             	mov    %rsp,%rbp
  8004210cf5:	48 83 ec 20          	sub    $0x20,%rsp
  8004210cf9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210cfd:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  8004210d01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210d05:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  8004210d09:	90                   	nop
  8004210d0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210d0e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210d12:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210d16:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210d1a:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  8004210d1e:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  8004210d22:	0f b6 12             	movzbl (%rdx),%edx
  8004210d25:	88 10                	mov    %dl,(%rax)
  8004210d27:	0f b6 00             	movzbl (%rax),%eax
  8004210d2a:	84 c0                	test   %al,%al
  8004210d2c:	75 dc                	jne    8004210d0a <strcpy+0x19>
		/* do nothing */;
	return ret;
  8004210d2e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210d32:	c9                   	leaveq 
  8004210d33:	c3                   	retq   

0000008004210d34 <strcat>:

char *
strcat(char *dst, const char *src)
{
  8004210d34:	55                   	push   %rbp
  8004210d35:	48 89 e5             	mov    %rsp,%rbp
  8004210d38:	48 83 ec 20          	sub    $0x20,%rsp
  8004210d3c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210d40:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  8004210d44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210d48:	48 89 c7             	mov    %rax,%rdi
  8004210d4b:	48 b8 85 0c 21 04 80 	movabs $0x8004210c85,%rax
  8004210d52:	00 00 00 
  8004210d55:	ff d0                	callq  *%rax
  8004210d57:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  8004210d5a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004210d5d:	48 63 d0             	movslq %eax,%rdx
  8004210d60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210d64:	48 01 c2             	add    %rax,%rdx
  8004210d67:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210d6b:	48 89 c6             	mov    %rax,%rsi
  8004210d6e:	48 89 d7             	mov    %rdx,%rdi
  8004210d71:	48 b8 f1 0c 21 04 80 	movabs $0x8004210cf1,%rax
  8004210d78:	00 00 00 
  8004210d7b:	ff d0                	callq  *%rax
	return dst;
  8004210d7d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004210d81:	c9                   	leaveq 
  8004210d82:	c3                   	retq   

0000008004210d83 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  8004210d83:	55                   	push   %rbp
  8004210d84:	48 89 e5             	mov    %rsp,%rbp
  8004210d87:	48 83 ec 28          	sub    $0x28,%rsp
  8004210d8b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210d8f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210d93:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  8004210d97:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210d9b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  8004210d9f:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210da6:	00 
  8004210da7:	eb 2a                	jmp    8004210dd3 <strncpy+0x50>
		*dst++ = *src;
  8004210da9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210dad:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210db1:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210db5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210db9:	0f b6 12             	movzbl (%rdx),%edx
  8004210dbc:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  8004210dbe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210dc2:	0f b6 00             	movzbl (%rax),%eax
  8004210dc5:	84 c0                	test   %al,%al
  8004210dc7:	74 05                	je     8004210dce <strncpy+0x4b>
			src++;
  8004210dc9:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  8004210dce:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004210dd3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210dd7:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004210ddb:	72 cc                	jb     8004210da9 <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  8004210ddd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  8004210de1:	c9                   	leaveq 
  8004210de2:	c3                   	retq   

0000008004210de3 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  8004210de3:	55                   	push   %rbp
  8004210de4:	48 89 e5             	mov    %rsp,%rbp
  8004210de7:	48 83 ec 28          	sub    $0x28,%rsp
  8004210deb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210def:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210df3:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  8004210df7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210dfb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  8004210dff:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210e04:	74 3d                	je     8004210e43 <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  8004210e06:	eb 1d                	jmp    8004210e25 <strlcpy+0x42>
			*dst++ = *src++;
  8004210e08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210e0c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210e10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210e14:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210e18:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  8004210e1c:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  8004210e20:	0f b6 12             	movzbl (%rdx),%edx
  8004210e23:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  8004210e25:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  8004210e2a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210e2f:	74 0b                	je     8004210e3c <strlcpy+0x59>
  8004210e31:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210e35:	0f b6 00             	movzbl (%rax),%eax
  8004210e38:	84 c0                	test   %al,%al
  8004210e3a:	75 cc                	jne    8004210e08 <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  8004210e3c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210e40:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  8004210e43:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210e47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210e4b:	48 29 c2             	sub    %rax,%rdx
  8004210e4e:	48 89 d0             	mov    %rdx,%rax
}
  8004210e51:	c9                   	leaveq 
  8004210e52:	c3                   	retq   

0000008004210e53 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  8004210e53:	55                   	push   %rbp
  8004210e54:	48 89 e5             	mov    %rsp,%rbp
  8004210e57:	48 83 ec 10          	sub    $0x10,%rsp
  8004210e5b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004210e5f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  8004210e63:	eb 0a                	jmp    8004210e6f <strcmp+0x1c>
		p++, q++;
  8004210e65:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004210e6a:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  8004210e6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210e73:	0f b6 00             	movzbl (%rax),%eax
  8004210e76:	84 c0                	test   %al,%al
  8004210e78:	74 12                	je     8004210e8c <strcmp+0x39>
  8004210e7a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210e7e:	0f b6 10             	movzbl (%rax),%edx
  8004210e81:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210e85:	0f b6 00             	movzbl (%rax),%eax
  8004210e88:	38 c2                	cmp    %al,%dl
  8004210e8a:	74 d9                	je     8004210e65 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  8004210e8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210e90:	0f b6 00             	movzbl (%rax),%eax
  8004210e93:	0f b6 d0             	movzbl %al,%edx
  8004210e96:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210e9a:	0f b6 00             	movzbl (%rax),%eax
  8004210e9d:	0f b6 c0             	movzbl %al,%eax
  8004210ea0:	29 c2                	sub    %eax,%edx
  8004210ea2:	89 d0                	mov    %edx,%eax
}
  8004210ea4:	c9                   	leaveq 
  8004210ea5:	c3                   	retq   

0000008004210ea6 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  8004210ea6:	55                   	push   %rbp
  8004210ea7:	48 89 e5             	mov    %rsp,%rbp
  8004210eaa:	48 83 ec 18          	sub    $0x18,%rsp
  8004210eae:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004210eb2:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004210eb6:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  8004210eba:	eb 0f                	jmp    8004210ecb <strncmp+0x25>
		n--, p++, q++;
  8004210ebc:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  8004210ec1:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004210ec6:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  8004210ecb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210ed0:	74 1d                	je     8004210eef <strncmp+0x49>
  8004210ed2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210ed6:	0f b6 00             	movzbl (%rax),%eax
  8004210ed9:	84 c0                	test   %al,%al
  8004210edb:	74 12                	je     8004210eef <strncmp+0x49>
  8004210edd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210ee1:	0f b6 10             	movzbl (%rax),%edx
  8004210ee4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210ee8:	0f b6 00             	movzbl (%rax),%eax
  8004210eeb:	38 c2                	cmp    %al,%dl
  8004210eed:	74 cd                	je     8004210ebc <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  8004210eef:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210ef4:	75 07                	jne    8004210efd <strncmp+0x57>
		return 0;
  8004210ef6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210efb:	eb 18                	jmp    8004210f15 <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  8004210efd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210f01:	0f b6 00             	movzbl (%rax),%eax
  8004210f04:	0f b6 d0             	movzbl %al,%edx
  8004210f07:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210f0b:	0f b6 00             	movzbl (%rax),%eax
  8004210f0e:	0f b6 c0             	movzbl %al,%eax
  8004210f11:	29 c2                	sub    %eax,%edx
  8004210f13:	89 d0                	mov    %edx,%eax
}
  8004210f15:	c9                   	leaveq 
  8004210f16:	c3                   	retq   

0000008004210f17 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  8004210f17:	55                   	push   %rbp
  8004210f18:	48 89 e5             	mov    %rsp,%rbp
  8004210f1b:	48 83 ec 10          	sub    $0x10,%rsp
  8004210f1f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004210f23:	89 f0                	mov    %esi,%eax
  8004210f25:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  8004210f28:	eb 17                	jmp    8004210f41 <strchr+0x2a>
		if (*s == c)
  8004210f2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210f2e:	0f b6 00             	movzbl (%rax),%eax
  8004210f31:	3a 45 f4             	cmp    -0xc(%rbp),%al
  8004210f34:	75 06                	jne    8004210f3c <strchr+0x25>
			return (char *) s;
  8004210f36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210f3a:	eb 15                	jmp    8004210f51 <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  8004210f3c:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004210f41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210f45:	0f b6 00             	movzbl (%rax),%eax
  8004210f48:	84 c0                	test   %al,%al
  8004210f4a:	75 de                	jne    8004210f2a <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  8004210f4c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210f51:	c9                   	leaveq 
  8004210f52:	c3                   	retq   

0000008004210f53 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  8004210f53:	55                   	push   %rbp
  8004210f54:	48 89 e5             	mov    %rsp,%rbp
  8004210f57:	48 83 ec 10          	sub    $0x10,%rsp
  8004210f5b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004210f5f:	89 f0                	mov    %esi,%eax
  8004210f61:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  8004210f64:	eb 11                	jmp    8004210f77 <strfind+0x24>
		if (*s == c)
  8004210f66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210f6a:	0f b6 00             	movzbl (%rax),%eax
  8004210f6d:	3a 45 f4             	cmp    -0xc(%rbp),%al
  8004210f70:	74 12                	je     8004210f84 <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  8004210f72:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004210f77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210f7b:	0f b6 00             	movzbl (%rax),%eax
  8004210f7e:	84 c0                	test   %al,%al
  8004210f80:	75 e4                	jne    8004210f66 <strfind+0x13>
  8004210f82:	eb 01                	jmp    8004210f85 <strfind+0x32>
		if (*s == c)
			break;
  8004210f84:	90                   	nop
	return (char *) s;
  8004210f85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210f89:	c9                   	leaveq 
  8004210f8a:	c3                   	retq   

0000008004210f8b <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  8004210f8b:	55                   	push   %rbp
  8004210f8c:	48 89 e5             	mov    %rsp,%rbp
  8004210f8f:	48 83 ec 18          	sub    $0x18,%rsp
  8004210f93:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004210f97:	89 75 f4             	mov    %esi,-0xc(%rbp)
  8004210f9a:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  8004210f9e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210fa3:	75 06                	jne    8004210fab <memset+0x20>
		return v;
  8004210fa5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210fa9:	eb 69                	jmp    8004211014 <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  8004210fab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210faf:	83 e0 03             	and    $0x3,%eax
  8004210fb2:	48 85 c0             	test   %rax,%rax
  8004210fb5:	75 48                	jne    8004210fff <memset+0x74>
  8004210fb7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210fbb:	83 e0 03             	and    $0x3,%eax
  8004210fbe:	48 85 c0             	test   %rax,%rax
  8004210fc1:	75 3c                	jne    8004210fff <memset+0x74>
		c &= 0xFF;
  8004210fc3:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  8004210fca:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210fcd:	c1 e0 18             	shl    $0x18,%eax
  8004210fd0:	89 c2                	mov    %eax,%edx
  8004210fd2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210fd5:	c1 e0 10             	shl    $0x10,%eax
  8004210fd8:	09 c2                	or     %eax,%edx
  8004210fda:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210fdd:	c1 e0 08             	shl    $0x8,%eax
  8004210fe0:	09 d0                	or     %edx,%eax
  8004210fe2:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  8004210fe5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210fe9:	48 c1 e8 02          	shr    $0x2,%rax
  8004210fed:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  8004210ff0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210ff4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210ff7:	48 89 d7             	mov    %rdx,%rdi
  8004210ffa:	fc                   	cld    
  8004210ffb:	f3 ab                	rep stos %eax,%es:(%rdi)
  8004210ffd:	eb 11                	jmp    8004211010 <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  8004210fff:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211003:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211006:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421100a:	48 89 d7             	mov    %rdx,%rdi
  800421100d:	fc                   	cld    
  800421100e:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  8004211010:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004211014:	c9                   	leaveq 
  8004211015:	c3                   	retq   

0000008004211016 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  8004211016:	55                   	push   %rbp
  8004211017:	48 89 e5             	mov    %rsp,%rbp
  800421101a:	48 83 ec 28          	sub    $0x28,%rsp
  800421101e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211022:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211026:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  800421102a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421102e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  8004211032:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211036:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  800421103a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421103e:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004211042:	0f 83 88 00 00 00    	jae    80042110d0 <memmove+0xba>
  8004211048:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421104c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211050:	48 01 d0             	add    %rdx,%rax
  8004211053:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004211057:	76 77                	jbe    80042110d0 <memmove+0xba>
		s += n;
  8004211059:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421105d:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  8004211061:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211065:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  8004211069:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421106d:	83 e0 03             	and    $0x3,%eax
  8004211070:	48 85 c0             	test   %rax,%rax
  8004211073:	75 3b                	jne    80042110b0 <memmove+0x9a>
  8004211075:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211079:	83 e0 03             	and    $0x3,%eax
  800421107c:	48 85 c0             	test   %rax,%rax
  800421107f:	75 2f                	jne    80042110b0 <memmove+0x9a>
  8004211081:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211085:	83 e0 03             	and    $0x3,%eax
  8004211088:	48 85 c0             	test   %rax,%rax
  800421108b:	75 23                	jne    80042110b0 <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  800421108d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211091:	48 83 e8 04          	sub    $0x4,%rax
  8004211095:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211099:	48 83 ea 04          	sub    $0x4,%rdx
  800421109d:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042110a1:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  80042110a5:	48 89 c7             	mov    %rax,%rdi
  80042110a8:	48 89 d6             	mov    %rdx,%rsi
  80042110ab:	fd                   	std    
  80042110ac:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  80042110ae:	eb 1d                	jmp    80042110cd <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  80042110b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042110b4:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  80042110b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042110bc:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  80042110c0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042110c4:	48 89 d7             	mov    %rdx,%rdi
  80042110c7:	48 89 c1             	mov    %rax,%rcx
  80042110ca:	fd                   	std    
  80042110cb:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80042110cd:	fc                   	cld    
  80042110ce:	eb 57                	jmp    8004211127 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  80042110d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042110d4:	83 e0 03             	and    $0x3,%eax
  80042110d7:	48 85 c0             	test   %rax,%rax
  80042110da:	75 36                	jne    8004211112 <memmove+0xfc>
  80042110dc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042110e0:	83 e0 03             	and    $0x3,%eax
  80042110e3:	48 85 c0             	test   %rax,%rax
  80042110e6:	75 2a                	jne    8004211112 <memmove+0xfc>
  80042110e8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042110ec:	83 e0 03             	and    $0x3,%eax
  80042110ef:	48 85 c0             	test   %rax,%rax
  80042110f2:	75 1e                	jne    8004211112 <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80042110f4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042110f8:	48 c1 e8 02          	shr    $0x2,%rax
  80042110fc:	48 89 c1             	mov    %rax,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  80042110ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211103:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211107:	48 89 c7             	mov    %rax,%rdi
  800421110a:	48 89 d6             	mov    %rdx,%rsi
  800421110d:	fc                   	cld    
  800421110e:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  8004211110:	eb 15                	jmp    8004211127 <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  8004211112:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211116:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421111a:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421111e:	48 89 c7             	mov    %rax,%rdi
  8004211121:	48 89 d6             	mov    %rdx,%rsi
  8004211124:	fc                   	cld    
  8004211125:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  8004211127:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800421112b:	c9                   	leaveq 
  800421112c:	c3                   	retq   

000000800421112d <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  800421112d:	55                   	push   %rbp
  800421112e:	48 89 e5             	mov    %rsp,%rbp
  8004211131:	48 83 ec 18          	sub    $0x18,%rsp
  8004211135:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004211139:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800421113d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  8004211141:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211145:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8004211149:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421114d:	48 89 ce             	mov    %rcx,%rsi
  8004211150:	48 89 c7             	mov    %rax,%rdi
  8004211153:	48 b8 16 10 21 04 80 	movabs $0x8004211016,%rax
  800421115a:	00 00 00 
  800421115d:	ff d0                	callq  *%rax
}
  800421115f:	c9                   	leaveq 
  8004211160:	c3                   	retq   

0000008004211161 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  8004211161:	55                   	push   %rbp
  8004211162:	48 89 e5             	mov    %rsp,%rbp
  8004211165:	48 83 ec 28          	sub    $0x28,%rsp
  8004211169:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421116d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211171:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  8004211175:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211179:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  800421117d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211181:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  8004211185:	eb 36                	jmp    80042111bd <memcmp+0x5c>
		if (*s1 != *s2)
  8004211187:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421118b:	0f b6 10             	movzbl (%rax),%edx
  800421118e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211192:	0f b6 00             	movzbl (%rax),%eax
  8004211195:	38 c2                	cmp    %al,%dl
  8004211197:	74 1a                	je     80042111b3 <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  8004211199:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421119d:	0f b6 00             	movzbl (%rax),%eax
  80042111a0:	0f b6 d0             	movzbl %al,%edx
  80042111a3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042111a7:	0f b6 00             	movzbl (%rax),%eax
  80042111aa:	0f b6 c0             	movzbl %al,%eax
  80042111ad:	29 c2                	sub    %eax,%edx
  80042111af:	89 d0                	mov    %edx,%eax
  80042111b1:	eb 20                	jmp    80042111d3 <memcmp+0x72>
		s1++, s2++;
  80042111b3:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80042111b8:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80042111bd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042111c1:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  80042111c5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80042111c9:	48 85 c0             	test   %rax,%rax
  80042111cc:	75 b9                	jne    8004211187 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  80042111ce:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042111d3:	c9                   	leaveq 
  80042111d4:	c3                   	retq   

00000080042111d5 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80042111d5:	55                   	push   %rbp
  80042111d6:	48 89 e5             	mov    %rsp,%rbp
  80042111d9:	48 83 ec 28          	sub    $0x28,%rsp
  80042111dd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042111e1:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  80042111e4:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  80042111e8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042111ec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042111f0:	48 01 d0             	add    %rdx,%rax
  80042111f3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  80042111f7:	eb 19                	jmp    8004211212 <memfind+0x3d>
		if (*(const unsigned char *) s == (unsigned char) c)
  80042111f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042111fd:	0f b6 00             	movzbl (%rax),%eax
  8004211200:	0f b6 d0             	movzbl %al,%edx
  8004211203:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004211206:	0f b6 c0             	movzbl %al,%eax
  8004211209:	39 c2                	cmp    %eax,%edx
  800421120b:	74 11                	je     800421121e <memfind+0x49>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  800421120d:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004211212:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211216:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800421121a:	72 dd                	jb     80042111f9 <memfind+0x24>
  800421121c:	eb 01                	jmp    800421121f <memfind+0x4a>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
  800421121e:	90                   	nop
	return (void *) s;
  800421121f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004211223:	c9                   	leaveq 
  8004211224:	c3                   	retq   

0000008004211225 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  8004211225:	55                   	push   %rbp
  8004211226:	48 89 e5             	mov    %rsp,%rbp
  8004211229:	48 83 ec 38          	sub    $0x38,%rsp
  800421122d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004211231:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004211235:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  8004211238:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  800421123f:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004211246:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  8004211247:	eb 05                	jmp    800421124e <strtol+0x29>
		s++;
  8004211249:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800421124e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211252:	0f b6 00             	movzbl (%rax),%eax
  8004211255:	3c 20                	cmp    $0x20,%al
  8004211257:	74 f0                	je     8004211249 <strtol+0x24>
  8004211259:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421125d:	0f b6 00             	movzbl (%rax),%eax
  8004211260:	3c 09                	cmp    $0x9,%al
  8004211262:	74 e5                	je     8004211249 <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  8004211264:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211268:	0f b6 00             	movzbl (%rax),%eax
  800421126b:	3c 2b                	cmp    $0x2b,%al
  800421126d:	75 07                	jne    8004211276 <strtol+0x51>
		s++;
  800421126f:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8004211274:	eb 17                	jmp    800421128d <strtol+0x68>
	else if (*s == '-')
  8004211276:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421127a:	0f b6 00             	movzbl (%rax),%eax
  800421127d:	3c 2d                	cmp    $0x2d,%al
  800421127f:	75 0c                	jne    800421128d <strtol+0x68>
		s++, neg = 1;
  8004211281:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8004211286:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  800421128d:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004211291:	74 06                	je     8004211299 <strtol+0x74>
  8004211293:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  8004211297:	75 28                	jne    80042112c1 <strtol+0x9c>
  8004211299:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421129d:	0f b6 00             	movzbl (%rax),%eax
  80042112a0:	3c 30                	cmp    $0x30,%al
  80042112a2:	75 1d                	jne    80042112c1 <strtol+0x9c>
  80042112a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042112a8:	48 83 c0 01          	add    $0x1,%rax
  80042112ac:	0f b6 00             	movzbl (%rax),%eax
  80042112af:	3c 78                	cmp    $0x78,%al
  80042112b1:	75 0e                	jne    80042112c1 <strtol+0x9c>
		s += 2, base = 16;
  80042112b3:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  80042112b8:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  80042112bf:	eb 2c                	jmp    80042112ed <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  80042112c1:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80042112c5:	75 19                	jne    80042112e0 <strtol+0xbb>
  80042112c7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042112cb:	0f b6 00             	movzbl (%rax),%eax
  80042112ce:	3c 30                	cmp    $0x30,%al
  80042112d0:	75 0e                	jne    80042112e0 <strtol+0xbb>
		s++, base = 8;
  80042112d2:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  80042112d7:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  80042112de:	eb 0d                	jmp    80042112ed <strtol+0xc8>
	else if (base == 0)
  80042112e0:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80042112e4:	75 07                	jne    80042112ed <strtol+0xc8>
		base = 10;
  80042112e6:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  80042112ed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042112f1:	0f b6 00             	movzbl (%rax),%eax
  80042112f4:	3c 2f                	cmp    $0x2f,%al
  80042112f6:	7e 1d                	jle    8004211315 <strtol+0xf0>
  80042112f8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042112fc:	0f b6 00             	movzbl (%rax),%eax
  80042112ff:	3c 39                	cmp    $0x39,%al
  8004211301:	7f 12                	jg     8004211315 <strtol+0xf0>
			dig = *s - '0';
  8004211303:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211307:	0f b6 00             	movzbl (%rax),%eax
  800421130a:	0f be c0             	movsbl %al,%eax
  800421130d:	83 e8 30             	sub    $0x30,%eax
  8004211310:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004211313:	eb 4e                	jmp    8004211363 <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  8004211315:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211319:	0f b6 00             	movzbl (%rax),%eax
  800421131c:	3c 60                	cmp    $0x60,%al
  800421131e:	7e 1d                	jle    800421133d <strtol+0x118>
  8004211320:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211324:	0f b6 00             	movzbl (%rax),%eax
  8004211327:	3c 7a                	cmp    $0x7a,%al
  8004211329:	7f 12                	jg     800421133d <strtol+0x118>
			dig = *s - 'a' + 10;
  800421132b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421132f:	0f b6 00             	movzbl (%rax),%eax
  8004211332:	0f be c0             	movsbl %al,%eax
  8004211335:	83 e8 57             	sub    $0x57,%eax
  8004211338:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800421133b:	eb 26                	jmp    8004211363 <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  800421133d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211341:	0f b6 00             	movzbl (%rax),%eax
  8004211344:	3c 40                	cmp    $0x40,%al
  8004211346:	7e 47                	jle    800421138f <strtol+0x16a>
  8004211348:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421134c:	0f b6 00             	movzbl (%rax),%eax
  800421134f:	3c 5a                	cmp    $0x5a,%al
  8004211351:	7f 3c                	jg     800421138f <strtol+0x16a>
			dig = *s - 'A' + 10;
  8004211353:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211357:	0f b6 00             	movzbl (%rax),%eax
  800421135a:	0f be c0             	movsbl %al,%eax
  800421135d:	83 e8 37             	sub    $0x37,%eax
  8004211360:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  8004211363:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004211366:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  8004211369:	7d 23                	jge    800421138e <strtol+0x169>
			break;
		s++, val = (val * base) + dig;
  800421136b:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8004211370:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004211373:	48 98                	cltq   
  8004211375:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  800421137a:	48 89 c2             	mov    %rax,%rdx
  800421137d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004211380:	48 98                	cltq   
  8004211382:	48 01 d0             	add    %rdx,%rax
  8004211385:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  8004211389:	e9 5f ff ff ff       	jmpq   80042112ed <strtol+0xc8>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
  800421138e:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
  800421138f:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211394:	74 0b                	je     80042113a1 <strtol+0x17c>
		*endptr = (char *) s;
  8004211396:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421139a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421139e:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  80042113a1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042113a5:	74 09                	je     80042113b0 <strtol+0x18b>
  80042113a7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042113ab:	48 f7 d8             	neg    %rax
  80042113ae:	eb 04                	jmp    80042113b4 <strtol+0x18f>
  80042113b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80042113b4:	c9                   	leaveq 
  80042113b5:	c3                   	retq   

00000080042113b6 <strstr>:

char * strstr(const char *in, const char *str)
{
  80042113b6:	55                   	push   %rbp
  80042113b7:	48 89 e5             	mov    %rsp,%rbp
  80042113ba:	48 83 ec 30          	sub    $0x30,%rsp
  80042113be:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042113c2:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  80042113c6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042113ca:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042113ce:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  80042113d2:	0f b6 00             	movzbl (%rax),%eax
  80042113d5:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  80042113d8:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80042113dc:	75 06                	jne    80042113e4 <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  80042113de:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042113e2:	eb 6b                	jmp    800421144f <strstr+0x99>

	len = strlen(str);
  80042113e4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042113e8:	48 89 c7             	mov    %rax,%rdi
  80042113eb:	48 b8 85 0c 21 04 80 	movabs $0x8004210c85,%rax
  80042113f2:	00 00 00 
  80042113f5:	ff d0                	callq  *%rax
  80042113f7:	48 98                	cltq   
  80042113f9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  80042113fd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211401:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211405:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004211409:	0f b6 00             	movzbl (%rax),%eax
  800421140c:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  800421140f:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  8004211413:	75 07                	jne    800421141c <strstr+0x66>
				return (char *) 0;
  8004211415:	b8 00 00 00 00       	mov    $0x0,%eax
  800421141a:	eb 33                	jmp    800421144f <strstr+0x99>
		} while (sc != c);
  800421141c:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004211420:	3a 45 ff             	cmp    -0x1(%rbp),%al
  8004211423:	75 d8                	jne    80042113fd <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  8004211425:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211429:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800421142d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211431:	48 89 ce             	mov    %rcx,%rsi
  8004211434:	48 89 c7             	mov    %rax,%rdi
  8004211437:	48 b8 a6 0e 21 04 80 	movabs $0x8004210ea6,%rax
  800421143e:	00 00 00 
  8004211441:	ff d0                	callq  *%rax
  8004211443:	85 c0                	test   %eax,%eax
  8004211445:	75 b6                	jne    80042113fd <strstr+0x47>

	return (char *) (in - 1);
  8004211447:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421144b:	48 83 e8 01          	sub    $0x1,%rax
}
  800421144f:	c9                   	leaveq 
  8004211450:	c3                   	retq   

0000008004211451 <_dwarf_read_lsb>:
Dwarf_Section *
_dwarf_find_section(const char *name);

uint64_t
_dwarf_read_lsb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  8004211451:	55                   	push   %rbp
  8004211452:	48 89 e5             	mov    %rsp,%rbp
  8004211455:	48 83 ec 28          	sub    $0x28,%rsp
  8004211459:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421145d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211461:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  8004211464:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211468:	48 8b 10             	mov    (%rax),%rdx
  800421146b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421146f:	48 01 d0             	add    %rdx,%rax
  8004211472:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  8004211476:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800421147d:	00 
	switch (bytes_to_read) {
  800421147e:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004211481:	83 f8 02             	cmp    $0x2,%eax
  8004211484:	0f 84 ab 00 00 00    	je     8004211535 <_dwarf_read_lsb+0xe4>
  800421148a:	83 f8 02             	cmp    $0x2,%eax
  800421148d:	7f 0e                	jg     800421149d <_dwarf_read_lsb+0x4c>
  800421148f:	83 f8 01             	cmp    $0x1,%eax
  8004211492:	0f 84 b3 00 00 00    	je     800421154b <_dwarf_read_lsb+0xfa>
  8004211498:	e9 d9 00 00 00       	jmpq   8004211576 <_dwarf_read_lsb+0x125>
  800421149d:	83 f8 04             	cmp    $0x4,%eax
  80042114a0:	74 65                	je     8004211507 <_dwarf_read_lsb+0xb6>
  80042114a2:	83 f8 08             	cmp    $0x8,%eax
  80042114a5:	0f 85 cb 00 00 00    	jne    8004211576 <_dwarf_read_lsb+0x125>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  80042114ab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042114af:	48 83 c0 04          	add    $0x4,%rax
  80042114b3:	0f b6 00             	movzbl (%rax),%eax
  80042114b6:	0f b6 c0             	movzbl %al,%eax
  80042114b9:	48 c1 e0 20          	shl    $0x20,%rax
  80042114bd:	48 89 c2             	mov    %rax,%rdx
  80042114c0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042114c4:	48 83 c0 05          	add    $0x5,%rax
  80042114c8:	0f b6 00             	movzbl (%rax),%eax
  80042114cb:	0f b6 c0             	movzbl %al,%eax
  80042114ce:	48 c1 e0 28          	shl    $0x28,%rax
  80042114d2:	48 09 d0             	or     %rdx,%rax
  80042114d5:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  80042114d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042114dd:	48 83 c0 06          	add    $0x6,%rax
  80042114e1:	0f b6 00             	movzbl (%rax),%eax
  80042114e4:	0f b6 c0             	movzbl %al,%eax
  80042114e7:	48 c1 e0 30          	shl    $0x30,%rax
  80042114eb:	48 89 c2             	mov    %rax,%rdx
  80042114ee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042114f2:	48 83 c0 07          	add    $0x7,%rax
  80042114f6:	0f b6 00             	movzbl (%rax),%eax
  80042114f9:	0f b6 c0             	movzbl %al,%eax
  80042114fc:	48 c1 e0 38          	shl    $0x38,%rax
  8004211500:	48 09 d0             	or     %rdx,%rax
  8004211503:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  8004211507:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421150b:	48 83 c0 02          	add    $0x2,%rax
  800421150f:	0f b6 00             	movzbl (%rax),%eax
  8004211512:	0f b6 c0             	movzbl %al,%eax
  8004211515:	48 c1 e0 10          	shl    $0x10,%rax
  8004211519:	48 89 c2             	mov    %rax,%rdx
  800421151c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211520:	48 83 c0 03          	add    $0x3,%rax
  8004211524:	0f b6 00             	movzbl (%rax),%eax
  8004211527:	0f b6 c0             	movzbl %al,%eax
  800421152a:	48 c1 e0 18          	shl    $0x18,%rax
  800421152e:	48 09 d0             	or     %rdx,%rax
  8004211531:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  8004211535:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211539:	48 83 c0 01          	add    $0x1,%rax
  800421153d:	0f b6 00             	movzbl (%rax),%eax
  8004211540:	0f b6 c0             	movzbl %al,%eax
  8004211543:	48 c1 e0 08          	shl    $0x8,%rax
  8004211547:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800421154b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421154f:	0f b6 00             	movzbl (%rax),%eax
  8004211552:	0f b6 c0             	movzbl %al,%eax
  8004211555:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004211559:	90                   	nop
	default:
		return (0);
	}

	*offsetp += bytes_to_read;
  800421155a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421155e:	48 8b 10             	mov    (%rax),%rdx
  8004211561:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004211564:	48 98                	cltq   
  8004211566:	48 01 c2             	add    %rax,%rdx
  8004211569:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421156d:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004211570:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211574:	eb 05                	jmp    800421157b <_dwarf_read_lsb+0x12a>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  8004211576:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*offsetp += bytes_to_read;

	return (ret);
}
  800421157b:	c9                   	leaveq 
  800421157c:	c3                   	retq   

000000800421157d <_dwarf_decode_lsb>:

uint64_t
_dwarf_decode_lsb(uint8_t **data, int bytes_to_read)
{
  800421157d:	55                   	push   %rbp
  800421157e:	48 89 e5             	mov    %rsp,%rbp
  8004211581:	48 83 ec 20          	sub    $0x20,%rsp
  8004211585:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211589:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800421158c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211590:	48 8b 00             	mov    (%rax),%rax
  8004211593:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  8004211597:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800421159e:	00 
	switch (bytes_to_read) {
  800421159f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042115a2:	83 f8 02             	cmp    $0x2,%eax
  80042115a5:	0f 84 ab 00 00 00    	je     8004211656 <_dwarf_decode_lsb+0xd9>
  80042115ab:	83 f8 02             	cmp    $0x2,%eax
  80042115ae:	7f 0e                	jg     80042115be <_dwarf_decode_lsb+0x41>
  80042115b0:	83 f8 01             	cmp    $0x1,%eax
  80042115b3:	0f 84 b3 00 00 00    	je     800421166c <_dwarf_decode_lsb+0xef>
  80042115b9:	e9 d9 00 00 00       	jmpq   8004211697 <_dwarf_decode_lsb+0x11a>
  80042115be:	83 f8 04             	cmp    $0x4,%eax
  80042115c1:	74 65                	je     8004211628 <_dwarf_decode_lsb+0xab>
  80042115c3:	83 f8 08             	cmp    $0x8,%eax
  80042115c6:	0f 85 cb 00 00 00    	jne    8004211697 <_dwarf_decode_lsb+0x11a>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  80042115cc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042115d0:	48 83 c0 04          	add    $0x4,%rax
  80042115d4:	0f b6 00             	movzbl (%rax),%eax
  80042115d7:	0f b6 c0             	movzbl %al,%eax
  80042115da:	48 c1 e0 20          	shl    $0x20,%rax
  80042115de:	48 89 c2             	mov    %rax,%rdx
  80042115e1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042115e5:	48 83 c0 05          	add    $0x5,%rax
  80042115e9:	0f b6 00             	movzbl (%rax),%eax
  80042115ec:	0f b6 c0             	movzbl %al,%eax
  80042115ef:	48 c1 e0 28          	shl    $0x28,%rax
  80042115f3:	48 09 d0             	or     %rdx,%rax
  80042115f6:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  80042115fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042115fe:	48 83 c0 06          	add    $0x6,%rax
  8004211602:	0f b6 00             	movzbl (%rax),%eax
  8004211605:	0f b6 c0             	movzbl %al,%eax
  8004211608:	48 c1 e0 30          	shl    $0x30,%rax
  800421160c:	48 89 c2             	mov    %rax,%rdx
  800421160f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211613:	48 83 c0 07          	add    $0x7,%rax
  8004211617:	0f b6 00             	movzbl (%rax),%eax
  800421161a:	0f b6 c0             	movzbl %al,%eax
  800421161d:	48 c1 e0 38          	shl    $0x38,%rax
  8004211621:	48 09 d0             	or     %rdx,%rax
  8004211624:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  8004211628:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421162c:	48 83 c0 02          	add    $0x2,%rax
  8004211630:	0f b6 00             	movzbl (%rax),%eax
  8004211633:	0f b6 c0             	movzbl %al,%eax
  8004211636:	48 c1 e0 10          	shl    $0x10,%rax
  800421163a:	48 89 c2             	mov    %rax,%rdx
  800421163d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211641:	48 83 c0 03          	add    $0x3,%rax
  8004211645:	0f b6 00             	movzbl (%rax),%eax
  8004211648:	0f b6 c0             	movzbl %al,%eax
  800421164b:	48 c1 e0 18          	shl    $0x18,%rax
  800421164f:	48 09 d0             	or     %rdx,%rax
  8004211652:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  8004211656:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421165a:	48 83 c0 01          	add    $0x1,%rax
  800421165e:	0f b6 00             	movzbl (%rax),%eax
  8004211661:	0f b6 c0             	movzbl %al,%eax
  8004211664:	48 c1 e0 08          	shl    $0x8,%rax
  8004211668:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800421166c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211670:	0f b6 00             	movzbl (%rax),%eax
  8004211673:	0f b6 c0             	movzbl %al,%eax
  8004211676:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800421167a:	90                   	nop
	default:
		return (0);
	}

	*data += bytes_to_read;
  800421167b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421167f:	48 8b 10             	mov    (%rax),%rdx
  8004211682:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004211685:	48 98                	cltq   
  8004211687:	48 01 c2             	add    %rax,%rdx
  800421168a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421168e:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004211691:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211695:	eb 05                	jmp    800421169c <_dwarf_decode_lsb+0x11f>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  8004211697:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*data += bytes_to_read;

	return (ret);
}
  800421169c:	c9                   	leaveq 
  800421169d:	c3                   	retq   

000000800421169e <_dwarf_read_msb>:

uint64_t
_dwarf_read_msb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800421169e:	55                   	push   %rbp
  800421169f:	48 89 e5             	mov    %rsp,%rbp
  80042116a2:	48 83 ec 28          	sub    $0x28,%rsp
  80042116a6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042116aa:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042116ae:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  80042116b1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042116b5:	48 8b 10             	mov    (%rax),%rdx
  80042116b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042116bc:	48 01 d0             	add    %rdx,%rax
  80042116bf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	switch (bytes_to_read) {
  80042116c3:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042116c6:	83 f8 02             	cmp    $0x2,%eax
  80042116c9:	74 35                	je     8004211700 <_dwarf_read_msb+0x62>
  80042116cb:	83 f8 02             	cmp    $0x2,%eax
  80042116ce:	7f 0a                	jg     80042116da <_dwarf_read_msb+0x3c>
  80042116d0:	83 f8 01             	cmp    $0x1,%eax
  80042116d3:	74 18                	je     80042116ed <_dwarf_read_msb+0x4f>
  80042116d5:	e9 53 01 00 00       	jmpq   800421182d <_dwarf_read_msb+0x18f>
  80042116da:	83 f8 04             	cmp    $0x4,%eax
  80042116dd:	74 49                	je     8004211728 <_dwarf_read_msb+0x8a>
  80042116df:	83 f8 08             	cmp    $0x8,%eax
  80042116e2:	0f 84 96 00 00 00    	je     800421177e <_dwarf_read_msb+0xe0>
  80042116e8:	e9 40 01 00 00       	jmpq   800421182d <_dwarf_read_msb+0x18f>
	case 1:
		ret = src[0];
  80042116ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042116f1:	0f b6 00             	movzbl (%rax),%eax
  80042116f4:	0f b6 c0             	movzbl %al,%eax
  80042116f7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  80042116fb:	e9 34 01 00 00       	jmpq   8004211834 <_dwarf_read_msb+0x196>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  8004211700:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211704:	48 83 c0 01          	add    $0x1,%rax
  8004211708:	0f b6 00             	movzbl (%rax),%eax
  800421170b:	0f b6 d0             	movzbl %al,%edx
  800421170e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211712:	0f b6 00             	movzbl (%rax),%eax
  8004211715:	0f b6 c0             	movzbl %al,%eax
  8004211718:	48 c1 e0 08          	shl    $0x8,%rax
  800421171c:	48 09 d0             	or     %rdx,%rax
  800421171f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  8004211723:	e9 0c 01 00 00       	jmpq   8004211834 <_dwarf_read_msb+0x196>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  8004211728:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421172c:	48 83 c0 03          	add    $0x3,%rax
  8004211730:	0f b6 00             	movzbl (%rax),%eax
  8004211733:	0f b6 c0             	movzbl %al,%eax
  8004211736:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421173a:	48 83 c2 02          	add    $0x2,%rdx
  800421173e:	0f b6 12             	movzbl (%rdx),%edx
  8004211741:	0f b6 d2             	movzbl %dl,%edx
  8004211744:	48 c1 e2 08          	shl    $0x8,%rdx
  8004211748:	48 09 d0             	or     %rdx,%rax
  800421174b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800421174f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211753:	48 83 c0 01          	add    $0x1,%rax
  8004211757:	0f b6 00             	movzbl (%rax),%eax
  800421175a:	0f b6 c0             	movzbl %al,%eax
  800421175d:	48 c1 e0 10          	shl    $0x10,%rax
  8004211761:	48 89 c2             	mov    %rax,%rdx
  8004211764:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211768:	0f b6 00             	movzbl (%rax),%eax
  800421176b:	0f b6 c0             	movzbl %al,%eax
  800421176e:	48 c1 e0 18          	shl    $0x18,%rax
  8004211772:	48 09 d0             	or     %rdx,%rax
  8004211775:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004211779:	e9 b6 00 00 00       	jmpq   8004211834 <_dwarf_read_msb+0x196>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800421177e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211782:	48 83 c0 07          	add    $0x7,%rax
  8004211786:	0f b6 00             	movzbl (%rax),%eax
  8004211789:	0f b6 c0             	movzbl %al,%eax
  800421178c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211790:	48 83 c2 06          	add    $0x6,%rdx
  8004211794:	0f b6 12             	movzbl (%rdx),%edx
  8004211797:	0f b6 d2             	movzbl %dl,%edx
  800421179a:	48 c1 e2 08          	shl    $0x8,%rdx
  800421179e:	48 09 d0             	or     %rdx,%rax
  80042117a1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  80042117a5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042117a9:	48 83 c0 05          	add    $0x5,%rax
  80042117ad:	0f b6 00             	movzbl (%rax),%eax
  80042117b0:	0f b6 c0             	movzbl %al,%eax
  80042117b3:	48 c1 e0 10          	shl    $0x10,%rax
  80042117b7:	48 89 c2             	mov    %rax,%rdx
  80042117ba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042117be:	48 83 c0 04          	add    $0x4,%rax
  80042117c2:	0f b6 00             	movzbl (%rax),%eax
  80042117c5:	0f b6 c0             	movzbl %al,%eax
  80042117c8:	48 c1 e0 18          	shl    $0x18,%rax
  80042117cc:	48 09 d0             	or     %rdx,%rax
  80042117cf:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  80042117d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042117d7:	48 83 c0 03          	add    $0x3,%rax
  80042117db:	0f b6 00             	movzbl (%rax),%eax
  80042117de:	0f b6 c0             	movzbl %al,%eax
  80042117e1:	48 c1 e0 20          	shl    $0x20,%rax
  80042117e5:	48 89 c2             	mov    %rax,%rdx
  80042117e8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042117ec:	48 83 c0 02          	add    $0x2,%rax
  80042117f0:	0f b6 00             	movzbl (%rax),%eax
  80042117f3:	0f b6 c0             	movzbl %al,%eax
  80042117f6:	48 c1 e0 28          	shl    $0x28,%rax
  80042117fa:	48 09 d0             	or     %rdx,%rax
  80042117fd:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  8004211801:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211805:	48 83 c0 01          	add    $0x1,%rax
  8004211809:	0f b6 00             	movzbl (%rax),%eax
  800421180c:	0f b6 c0             	movzbl %al,%eax
  800421180f:	48 c1 e0 30          	shl    $0x30,%rax
  8004211813:	48 89 c2             	mov    %rax,%rdx
  8004211816:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421181a:	0f b6 00             	movzbl (%rax),%eax
  800421181d:	0f b6 c0             	movzbl %al,%eax
  8004211820:	48 c1 e0 38          	shl    $0x38,%rax
  8004211824:	48 09 d0             	or     %rdx,%rax
  8004211827:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800421182b:	eb 07                	jmp    8004211834 <_dwarf_read_msb+0x196>
	default:
		return (0);
  800421182d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211832:	eb 1a                	jmp    800421184e <_dwarf_read_msb+0x1b0>
	}

	*offsetp += bytes_to_read;
  8004211834:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211838:	48 8b 10             	mov    (%rax),%rdx
  800421183b:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421183e:	48 98                	cltq   
  8004211840:	48 01 c2             	add    %rax,%rdx
  8004211843:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211847:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800421184a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421184e:	c9                   	leaveq 
  800421184f:	c3                   	retq   

0000008004211850 <_dwarf_decode_msb>:

uint64_t
_dwarf_decode_msb(uint8_t **data, int bytes_to_read)
{
  8004211850:	55                   	push   %rbp
  8004211851:	48 89 e5             	mov    %rsp,%rbp
  8004211854:	48 83 ec 20          	sub    $0x20,%rsp
  8004211858:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421185c:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800421185f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211863:	48 8b 00             	mov    (%rax),%rax
  8004211866:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800421186a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004211871:	00 
	switch (bytes_to_read) {
  8004211872:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004211875:	83 f8 02             	cmp    $0x2,%eax
  8004211878:	74 35                	je     80042118af <_dwarf_decode_msb+0x5f>
  800421187a:	83 f8 02             	cmp    $0x2,%eax
  800421187d:	7f 0a                	jg     8004211889 <_dwarf_decode_msb+0x39>
  800421187f:	83 f8 01             	cmp    $0x1,%eax
  8004211882:	74 18                	je     800421189c <_dwarf_decode_msb+0x4c>
  8004211884:	e9 53 01 00 00       	jmpq   80042119dc <_dwarf_decode_msb+0x18c>
  8004211889:	83 f8 04             	cmp    $0x4,%eax
  800421188c:	74 49                	je     80042118d7 <_dwarf_decode_msb+0x87>
  800421188e:	83 f8 08             	cmp    $0x8,%eax
  8004211891:	0f 84 96 00 00 00    	je     800421192d <_dwarf_decode_msb+0xdd>
  8004211897:	e9 40 01 00 00       	jmpq   80042119dc <_dwarf_decode_msb+0x18c>
	case 1:
		ret = src[0];
  800421189c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042118a0:	0f b6 00             	movzbl (%rax),%eax
  80042118a3:	0f b6 c0             	movzbl %al,%eax
  80042118a6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  80042118aa:	e9 34 01 00 00       	jmpq   80042119e3 <_dwarf_decode_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  80042118af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042118b3:	48 83 c0 01          	add    $0x1,%rax
  80042118b7:	0f b6 00             	movzbl (%rax),%eax
  80042118ba:	0f b6 d0             	movzbl %al,%edx
  80042118bd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042118c1:	0f b6 00             	movzbl (%rax),%eax
  80042118c4:	0f b6 c0             	movzbl %al,%eax
  80042118c7:	48 c1 e0 08          	shl    $0x8,%rax
  80042118cb:	48 09 d0             	or     %rdx,%rax
  80042118ce:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  80042118d2:	e9 0c 01 00 00       	jmpq   80042119e3 <_dwarf_decode_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  80042118d7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042118db:	48 83 c0 03          	add    $0x3,%rax
  80042118df:	0f b6 00             	movzbl (%rax),%eax
  80042118e2:	0f b6 c0             	movzbl %al,%eax
  80042118e5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042118e9:	48 83 c2 02          	add    $0x2,%rdx
  80042118ed:	0f b6 12             	movzbl (%rdx),%edx
  80042118f0:	0f b6 d2             	movzbl %dl,%edx
  80042118f3:	48 c1 e2 08          	shl    $0x8,%rdx
  80042118f7:	48 09 d0             	or     %rdx,%rax
  80042118fa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  80042118fe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211902:	48 83 c0 01          	add    $0x1,%rax
  8004211906:	0f b6 00             	movzbl (%rax),%eax
  8004211909:	0f b6 c0             	movzbl %al,%eax
  800421190c:	48 c1 e0 10          	shl    $0x10,%rax
  8004211910:	48 89 c2             	mov    %rax,%rdx
  8004211913:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211917:	0f b6 00             	movzbl (%rax),%eax
  800421191a:	0f b6 c0             	movzbl %al,%eax
  800421191d:	48 c1 e0 18          	shl    $0x18,%rax
  8004211921:	48 09 d0             	or     %rdx,%rax
  8004211924:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004211928:	e9 b6 00 00 00       	jmpq   80042119e3 <_dwarf_decode_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800421192d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211931:	48 83 c0 07          	add    $0x7,%rax
  8004211935:	0f b6 00             	movzbl (%rax),%eax
  8004211938:	0f b6 c0             	movzbl %al,%eax
  800421193b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421193f:	48 83 c2 06          	add    $0x6,%rdx
  8004211943:	0f b6 12             	movzbl (%rdx),%edx
  8004211946:	0f b6 d2             	movzbl %dl,%edx
  8004211949:	48 c1 e2 08          	shl    $0x8,%rdx
  800421194d:	48 09 d0             	or     %rdx,%rax
  8004211950:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  8004211954:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211958:	48 83 c0 05          	add    $0x5,%rax
  800421195c:	0f b6 00             	movzbl (%rax),%eax
  800421195f:	0f b6 c0             	movzbl %al,%eax
  8004211962:	48 c1 e0 10          	shl    $0x10,%rax
  8004211966:	48 89 c2             	mov    %rax,%rdx
  8004211969:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421196d:	48 83 c0 04          	add    $0x4,%rax
  8004211971:	0f b6 00             	movzbl (%rax),%eax
  8004211974:	0f b6 c0             	movzbl %al,%eax
  8004211977:	48 c1 e0 18          	shl    $0x18,%rax
  800421197b:	48 09 d0             	or     %rdx,%rax
  800421197e:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  8004211982:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211986:	48 83 c0 03          	add    $0x3,%rax
  800421198a:	0f b6 00             	movzbl (%rax),%eax
  800421198d:	0f b6 c0             	movzbl %al,%eax
  8004211990:	48 c1 e0 20          	shl    $0x20,%rax
  8004211994:	48 89 c2             	mov    %rax,%rdx
  8004211997:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421199b:	48 83 c0 02          	add    $0x2,%rax
  800421199f:	0f b6 00             	movzbl (%rax),%eax
  80042119a2:	0f b6 c0             	movzbl %al,%eax
  80042119a5:	48 c1 e0 28          	shl    $0x28,%rax
  80042119a9:	48 09 d0             	or     %rdx,%rax
  80042119ac:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  80042119b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042119b4:	48 83 c0 01          	add    $0x1,%rax
  80042119b8:	0f b6 00             	movzbl (%rax),%eax
  80042119bb:	0f b6 c0             	movzbl %al,%eax
  80042119be:	48 c1 e0 30          	shl    $0x30,%rax
  80042119c2:	48 89 c2             	mov    %rax,%rdx
  80042119c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042119c9:	0f b6 00             	movzbl (%rax),%eax
  80042119cc:	0f b6 c0             	movzbl %al,%eax
  80042119cf:	48 c1 e0 38          	shl    $0x38,%rax
  80042119d3:	48 09 d0             	or     %rdx,%rax
  80042119d6:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  80042119da:	eb 07                	jmp    80042119e3 <_dwarf_decode_msb+0x193>
	default:
		return (0);
  80042119dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042119e1:	eb 1a                	jmp    80042119fd <_dwarf_decode_msb+0x1ad>
		break;
	}

	*data += bytes_to_read;
  80042119e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042119e7:	48 8b 10             	mov    (%rax),%rdx
  80042119ea:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042119ed:	48 98                	cltq   
  80042119ef:	48 01 c2             	add    %rax,%rdx
  80042119f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042119f6:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042119f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042119fd:	c9                   	leaveq 
  80042119fe:	c3                   	retq   

00000080042119ff <_dwarf_read_sleb128>:

int64_t
_dwarf_read_sleb128(uint8_t *data, uint64_t *offsetp)
{
  80042119ff:	55                   	push   %rbp
  8004211a00:	48 89 e5             	mov    %rsp,%rbp
  8004211a03:	48 83 ec 30          	sub    $0x30,%rsp
  8004211a07:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004211a0b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int64_t ret = 0;
  8004211a0f:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004211a16:	00 
	uint8_t b;
	int shift = 0;
  8004211a17:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  8004211a1e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211a22:	48 8b 10             	mov    (%rax),%rdx
  8004211a25:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211a29:	48 01 d0             	add    %rdx,%rax
  8004211a2c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  8004211a30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a34:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211a38:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004211a3c:	0f b6 00             	movzbl (%rax),%eax
  8004211a3f:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004211a42:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211a46:	83 e0 7f             	and    $0x7f,%eax
  8004211a49:	89 c2                	mov    %eax,%edx
  8004211a4b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211a4e:	89 c1                	mov    %eax,%ecx
  8004211a50:	d3 e2                	shl    %cl,%edx
  8004211a52:	89 d0                	mov    %edx,%eax
  8004211a54:	48 98                	cltq   
  8004211a56:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  8004211a5a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211a5e:	48 8b 00             	mov    (%rax),%rax
  8004211a61:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211a65:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211a69:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  8004211a6c:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004211a70:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211a74:	84 c0                	test   %al,%al
  8004211a76:	78 b8                	js     8004211a30 <_dwarf_read_sleb128+0x31>

	if (shift < 32 && (b & 0x40) != 0)
  8004211a78:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  8004211a7c:	7f 1f                	jg     8004211a9d <_dwarf_read_sleb128+0x9e>
  8004211a7e:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211a82:	83 e0 40             	and    $0x40,%eax
  8004211a85:	85 c0                	test   %eax,%eax
  8004211a87:	74 14                	je     8004211a9d <_dwarf_read_sleb128+0x9e>
		ret |= (-1 << shift);
  8004211a89:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211a8c:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8004211a91:	89 c1                	mov    %eax,%ecx
  8004211a93:	d3 e2                	shl    %cl,%edx
  8004211a95:	89 d0                	mov    %edx,%eax
  8004211a97:	48 98                	cltq   
  8004211a99:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	return (ret);
  8004211a9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004211aa1:	c9                   	leaveq 
  8004211aa2:	c3                   	retq   

0000008004211aa3 <_dwarf_read_uleb128>:

uint64_t
_dwarf_read_uleb128(uint8_t *data, uint64_t *offsetp)
{
  8004211aa3:	55                   	push   %rbp
  8004211aa4:	48 89 e5             	mov    %rsp,%rbp
  8004211aa7:	48 83 ec 30          	sub    $0x30,%rsp
  8004211aab:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004211aaf:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t ret = 0;
  8004211ab3:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004211aba:	00 
	uint8_t b;
	int shift = 0;
  8004211abb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  8004211ac2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211ac6:	48 8b 10             	mov    (%rax),%rdx
  8004211ac9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211acd:	48 01 d0             	add    %rdx,%rax
  8004211ad0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  8004211ad4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ad8:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211adc:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004211ae0:	0f b6 00             	movzbl (%rax),%eax
  8004211ae3:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004211ae6:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211aea:	83 e0 7f             	and    $0x7f,%eax
  8004211aed:	89 c2                	mov    %eax,%edx
  8004211aef:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211af2:	89 c1                	mov    %eax,%ecx
  8004211af4:	d3 e2                	shl    %cl,%edx
  8004211af6:	89 d0                	mov    %edx,%eax
  8004211af8:	48 98                	cltq   
  8004211afa:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  8004211afe:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211b02:	48 8b 00             	mov    (%rax),%rax
  8004211b05:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211b09:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211b0d:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  8004211b10:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004211b14:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211b18:	84 c0                	test   %al,%al
  8004211b1a:	78 b8                	js     8004211ad4 <_dwarf_read_uleb128+0x31>

	return (ret);
  8004211b1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004211b20:	c9                   	leaveq 
  8004211b21:	c3                   	retq   

0000008004211b22 <_dwarf_decode_sleb128>:

int64_t
_dwarf_decode_sleb128(uint8_t **dp)
{
  8004211b22:	55                   	push   %rbp
  8004211b23:	48 89 e5             	mov    %rsp,%rbp
  8004211b26:	48 83 ec 28          	sub    $0x28,%rsp
  8004211b2a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int64_t ret = 0;
  8004211b2e:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004211b35:	00 
	uint8_t b;
	int shift = 0;
  8004211b36:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  8004211b3d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211b41:	48 8b 00             	mov    (%rax),%rax
  8004211b44:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  8004211b48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211b4c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211b50:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004211b54:	0f b6 00             	movzbl (%rax),%eax
  8004211b57:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004211b5a:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211b5e:	83 e0 7f             	and    $0x7f,%eax
  8004211b61:	89 c2                	mov    %eax,%edx
  8004211b63:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211b66:	89 c1                	mov    %eax,%ecx
  8004211b68:	d3 e2                	shl    %cl,%edx
  8004211b6a:	89 d0                	mov    %edx,%eax
  8004211b6c:	48 98                	cltq   
  8004211b6e:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  8004211b72:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004211b76:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211b7a:	84 c0                	test   %al,%al
  8004211b7c:	78 ca                	js     8004211b48 <_dwarf_decode_sleb128+0x26>

	if (shift < 32 && (b & 0x40) != 0)
  8004211b7e:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  8004211b82:	7f 1f                	jg     8004211ba3 <_dwarf_decode_sleb128+0x81>
  8004211b84:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211b88:	83 e0 40             	and    $0x40,%eax
  8004211b8b:	85 c0                	test   %eax,%eax
  8004211b8d:	74 14                	je     8004211ba3 <_dwarf_decode_sleb128+0x81>
		ret |= (-1 << shift);
  8004211b8f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211b92:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8004211b97:	89 c1                	mov    %eax,%ecx
  8004211b99:	d3 e2                	shl    %cl,%edx
  8004211b9b:	89 d0                	mov    %edx,%eax
  8004211b9d:	48 98                	cltq   
  8004211b9f:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	*dp = src;
  8004211ba3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211ba7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211bab:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004211bae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004211bb2:	c9                   	leaveq 
  8004211bb3:	c3                   	retq   

0000008004211bb4 <_dwarf_decode_uleb128>:

uint64_t
_dwarf_decode_uleb128(uint8_t **dp)
{
  8004211bb4:	55                   	push   %rbp
  8004211bb5:	48 89 e5             	mov    %rsp,%rbp
  8004211bb8:	48 83 ec 28          	sub    $0x28,%rsp
  8004211bbc:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint64_t ret = 0;
  8004211bc0:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004211bc7:	00 
	uint8_t b;
	int shift = 0;
  8004211bc8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  8004211bcf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211bd3:	48 8b 00             	mov    (%rax),%rax
  8004211bd6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  8004211bda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211bde:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211be2:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004211be6:	0f b6 00             	movzbl (%rax),%eax
  8004211be9:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004211bec:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211bf0:	83 e0 7f             	and    $0x7f,%eax
  8004211bf3:	89 c2                	mov    %eax,%edx
  8004211bf5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211bf8:	89 c1                	mov    %eax,%ecx
  8004211bfa:	d3 e2                	shl    %cl,%edx
  8004211bfc:	89 d0                	mov    %edx,%eax
  8004211bfe:	48 98                	cltq   
  8004211c00:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  8004211c04:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004211c08:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211c0c:	84 c0                	test   %al,%al
  8004211c0e:	78 ca                	js     8004211bda <_dwarf_decode_uleb128+0x26>

	*dp = src;
  8004211c10:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211c14:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211c18:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004211c1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004211c1f:	c9                   	leaveq 
  8004211c20:	c3                   	retq   

0000008004211c21 <_dwarf_read_string>:

#define Dwarf_Unsigned uint64_t

char *
_dwarf_read_string(void *data, Dwarf_Unsigned size, uint64_t *offsetp)
{
  8004211c21:	55                   	push   %rbp
  8004211c22:	48 89 e5             	mov    %rsp,%rbp
  8004211c25:	48 83 ec 28          	sub    $0x28,%rsp
  8004211c29:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211c2d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211c31:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *ret, *src;

	ret = src = (char *) data + *offsetp;
  8004211c35:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211c39:	48 8b 10             	mov    (%rax),%rdx
  8004211c3c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c40:	48 01 d0             	add    %rdx,%rax
  8004211c43:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211c47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211c4b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (*src != '\0' && *offsetp < size) {
  8004211c4f:	eb 17                	jmp    8004211c68 <_dwarf_read_string+0x47>
		src++;
  8004211c51:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
		(*offsetp)++;
  8004211c56:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211c5a:	48 8b 00             	mov    (%rax),%rax
  8004211c5d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211c61:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211c65:	48 89 10             	mov    %rdx,(%rax)
{
	char *ret, *src;

	ret = src = (char *) data + *offsetp;

	while (*src != '\0' && *offsetp < size) {
  8004211c68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211c6c:	0f b6 00             	movzbl (%rax),%eax
  8004211c6f:	84 c0                	test   %al,%al
  8004211c71:	74 0d                	je     8004211c80 <_dwarf_read_string+0x5f>
  8004211c73:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211c77:	48 8b 00             	mov    (%rax),%rax
  8004211c7a:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211c7e:	72 d1                	jb     8004211c51 <_dwarf_read_string+0x30>
		src++;
		(*offsetp)++;
	}

	if (*src == '\0' && *offsetp < size)
  8004211c80:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211c84:	0f b6 00             	movzbl (%rax),%eax
  8004211c87:	84 c0                	test   %al,%al
  8004211c89:	75 1f                	jne    8004211caa <_dwarf_read_string+0x89>
  8004211c8b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211c8f:	48 8b 00             	mov    (%rax),%rax
  8004211c92:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211c96:	73 12                	jae    8004211caa <_dwarf_read_string+0x89>
		(*offsetp)++;
  8004211c98:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211c9c:	48 8b 00             	mov    (%rax),%rax
  8004211c9f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211ca3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211ca7:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004211caa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  8004211cae:	c9                   	leaveq 
  8004211caf:	c3                   	retq   

0000008004211cb0 <_dwarf_read_block>:

uint8_t *
_dwarf_read_block(void *data, uint64_t *offsetp, uint64_t length)
{
  8004211cb0:	55                   	push   %rbp
  8004211cb1:	48 89 e5             	mov    %rsp,%rbp
  8004211cb4:	48 83 ec 28          	sub    $0x28,%rsp
  8004211cb8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211cbc:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211cc0:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t *ret, *src;

	ret = src = (uint8_t *) data + *offsetp;
  8004211cc4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211cc8:	48 8b 10             	mov    (%rax),%rdx
  8004211ccb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ccf:	48 01 d0             	add    %rdx,%rax
  8004211cd2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211cd6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211cda:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	(*offsetp) += length;
  8004211cde:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211ce2:	48 8b 10             	mov    (%rax),%rdx
  8004211ce5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211ce9:	48 01 c2             	add    %rax,%rdx
  8004211cec:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211cf0:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004211cf3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  8004211cf7:	c9                   	leaveq 
  8004211cf8:	c3                   	retq   

0000008004211cf9 <_dwarf_elf_get_byte_order>:

Dwarf_Endianness
_dwarf_elf_get_byte_order(void *obj)
{
  8004211cf9:	55                   	push   %rbp
  8004211cfa:	48 89 e5             	mov    %rsp,%rbp
  8004211cfd:	48 83 ec 20          	sub    $0x20,%rsp
  8004211d01:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *)obj;
  8004211d05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211d09:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  8004211d0d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004211d12:	75 35                	jne    8004211d49 <_dwarf_elf_get_byte_order+0x50>
  8004211d14:	48 b9 e0 12 22 04 80 	movabs $0x80042212e0,%rcx
  8004211d1b:	00 00 00 
  8004211d1e:	48 ba ea 12 22 04 80 	movabs $0x80042212ea,%rdx
  8004211d25:	00 00 00 
  8004211d28:	be 29 01 00 00       	mov    $0x129,%esi
  8004211d2d:	48 bf ff 12 22 04 80 	movabs $0x80042212ff,%rdi
  8004211d34:	00 00 00 
  8004211d37:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211d3c:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004211d43:	00 00 00 
  8004211d46:	41 ff d0             	callq  *%r8

//TODO: Need to check for 64bit here. Because currently Elf header for
//      64bit doesn't have any memeber e_ident. But need to see what is
//      similar in 64bit.
	switch (e->e_ident[EI_DATA]) {
  8004211d49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211d4d:	0f b6 40 05          	movzbl 0x5(%rax),%eax
  8004211d51:	0f b6 c0             	movzbl %al,%eax
  8004211d54:	83 f8 02             	cmp    $0x2,%eax
  8004211d57:	75 07                	jne    8004211d60 <_dwarf_elf_get_byte_order+0x67>
	case ELFDATA2MSB:
		return (DW_OBJECT_MSB);
  8004211d59:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211d5e:	eb 05                	jmp    8004211d65 <_dwarf_elf_get_byte_order+0x6c>

	case ELFDATA2LSB:
	case ELFDATANONE:
	default:
		return (DW_OBJECT_LSB);
  8004211d60:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
  8004211d65:	c9                   	leaveq 
  8004211d66:	c3                   	retq   

0000008004211d67 <_dwarf_elf_get_pointer_size>:

Dwarf_Small
_dwarf_elf_get_pointer_size(void *obj)
{
  8004211d67:	55                   	push   %rbp
  8004211d68:	48 89 e5             	mov    %rsp,%rbp
  8004211d6b:	48 83 ec 20          	sub    $0x20,%rsp
  8004211d6f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *) obj;
  8004211d73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211d77:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  8004211d7b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004211d80:	75 35                	jne    8004211db7 <_dwarf_elf_get_pointer_size+0x50>
  8004211d82:	48 b9 e0 12 22 04 80 	movabs $0x80042212e0,%rcx
  8004211d89:	00 00 00 
  8004211d8c:	48 ba ea 12 22 04 80 	movabs $0x80042212ea,%rdx
  8004211d93:	00 00 00 
  8004211d96:	be 3f 01 00 00       	mov    $0x13f,%esi
  8004211d9b:	48 bf ff 12 22 04 80 	movabs $0x80042212ff,%rdi
  8004211da2:	00 00 00 
  8004211da5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211daa:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004211db1:	00 00 00 
  8004211db4:	41 ff d0             	callq  *%r8

	if (e->e_ident[4] == ELFCLASS32)
  8004211db7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211dbb:	0f b6 40 04          	movzbl 0x4(%rax),%eax
  8004211dbf:	3c 01                	cmp    $0x1,%al
  8004211dc1:	75 07                	jne    8004211dca <_dwarf_elf_get_pointer_size+0x63>
		return (4);
  8004211dc3:	b8 04 00 00 00       	mov    $0x4,%eax
  8004211dc8:	eb 05                	jmp    8004211dcf <_dwarf_elf_get_pointer_size+0x68>
	else
		return (8);
  8004211dca:	b8 08 00 00 00       	mov    $0x8,%eax
}
  8004211dcf:	c9                   	leaveq 
  8004211dd0:	c3                   	retq   

0000008004211dd1 <_dwarf_init>:

//Return 0 on success
int _dwarf_init(Dwarf_Debug dbg, void *obj)
{
  8004211dd1:	55                   	push   %rbp
  8004211dd2:	48 89 e5             	mov    %rsp,%rbp
  8004211dd5:	48 83 ec 10          	sub    $0x10,%rsp
  8004211dd9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004211ddd:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	memset(dbg, 0, sizeof(struct _Dwarf_Debug));
  8004211de1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211de5:	ba 60 00 00 00       	mov    $0x60,%edx
  8004211dea:	be 00 00 00 00       	mov    $0x0,%esi
  8004211def:	48 89 c7             	mov    %rax,%rdi
  8004211df2:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  8004211df9:	00 00 00 
  8004211dfc:	ff d0                	callq  *%rax
	dbg->curr_off_dbginfo = 0;
  8004211dfe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e02:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	dbg->dbg_info_size = 0;
  8004211e09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e0d:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004211e14:	00 
	dbg->dbg_pointer_size = _dwarf_elf_get_pointer_size(obj); 
  8004211e15:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211e19:	48 89 c7             	mov    %rax,%rdi
  8004211e1c:	48 b8 67 1d 21 04 80 	movabs $0x8004211d67,%rax
  8004211e23:	00 00 00 
  8004211e26:	ff d0                	callq  *%rax
  8004211e28:	0f b6 d0             	movzbl %al,%edx
  8004211e2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e2f:	89 50 28             	mov    %edx,0x28(%rax)

	if (_dwarf_elf_get_byte_order(obj) == DW_OBJECT_MSB) {
  8004211e32:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211e36:	48 89 c7             	mov    %rax,%rdi
  8004211e39:	48 b8 f9 1c 21 04 80 	movabs $0x8004211cf9,%rax
  8004211e40:	00 00 00 
  8004211e43:	ff d0                	callq  *%rax
  8004211e45:	85 c0                	test   %eax,%eax
  8004211e47:	75 26                	jne    8004211e6f <_dwarf_init+0x9e>
		dbg->read = _dwarf_read_msb;
  8004211e49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e4d:	48 b9 9e 16 21 04 80 	movabs $0x800421169e,%rcx
  8004211e54:	00 00 00 
  8004211e57:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_msb;
  8004211e5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e5f:	48 b9 50 18 21 04 80 	movabs $0x8004211850,%rcx
  8004211e66:	00 00 00 
  8004211e69:	48 89 48 20          	mov    %rcx,0x20(%rax)
  8004211e6d:	eb 24                	jmp    8004211e93 <_dwarf_init+0xc2>
	} else {
		dbg->read = _dwarf_read_lsb;
  8004211e6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e73:	48 be 51 14 21 04 80 	movabs $0x8004211451,%rsi
  8004211e7a:	00 00 00 
  8004211e7d:	48 89 70 18          	mov    %rsi,0x18(%rax)
		dbg->decode = _dwarf_decode_lsb;
  8004211e81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e85:	48 ba 7d 15 21 04 80 	movabs $0x800421157d,%rdx
  8004211e8c:	00 00 00 
  8004211e8f:	48 89 50 20          	mov    %rdx,0x20(%rax)
	}
	_dwarf_frame_params_init(dbg);
  8004211e93:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e97:	48 89 c7             	mov    %rax,%rdi
  8004211e9a:	48 b8 db 32 21 04 80 	movabs $0x80042132db,%rax
  8004211ea1:	00 00 00 
  8004211ea4:	ff d0                	callq  *%rax
	return 0;
  8004211ea6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211eab:	c9                   	leaveq 
  8004211eac:	c3                   	retq   

0000008004211ead <_get_next_cu>:

//Return 0 on success
int _get_next_cu(Dwarf_Debug dbg, Dwarf_CU *cu)
{
  8004211ead:	55                   	push   %rbp
  8004211eae:	48 89 e5             	mov    %rsp,%rbp
  8004211eb1:	48 83 ec 20          	sub    $0x20,%rsp
  8004211eb5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211eb9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint32_t length;
	uint64_t offset;
	uint8_t dwarf_size;

	if(dbg->curr_off_dbginfo > dbg->dbg_info_size)
  8004211ebd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ec1:	48 8b 10             	mov    (%rax),%rdx
  8004211ec4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ec8:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004211ecc:	48 39 c2             	cmp    %rax,%rdx
  8004211ecf:	76 0a                	jbe    8004211edb <_get_next_cu+0x2e>
		return -1;
  8004211ed1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211ed6:	e9 71 01 00 00       	jmpq   800421204c <_get_next_cu+0x19f>

	offset = dbg->curr_off_dbginfo;
  8004211edb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211edf:	48 8b 00             	mov    (%rax),%rax
  8004211ee2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cu->cu_offset = offset;
  8004211ee6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211eea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211eee:	48 89 50 30          	mov    %rdx,0x30(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset,4);
  8004211ef2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ef6:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211efa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211efe:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004211f02:	48 89 d7             	mov    %rdx,%rdi
  8004211f05:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  8004211f09:	ba 04 00 00 00       	mov    $0x4,%edx
  8004211f0e:	48 89 ce             	mov    %rcx,%rsi
  8004211f11:	ff d0                	callq  *%rax
  8004211f13:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (length == 0xffffffff) {
  8004211f16:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  8004211f1a:	75 2a                	jne    8004211f46 <_get_next_cu+0x99>
		length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 8);
  8004211f1c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211f20:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211f24:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211f28:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004211f2c:	48 89 d7             	mov    %rdx,%rdi
  8004211f2f:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  8004211f33:	ba 08 00 00 00       	mov    $0x8,%edx
  8004211f38:	48 89 ce             	mov    %rcx,%rsi
  8004211f3b:	ff d0                	callq  *%rax
  8004211f3d:	89 45 fc             	mov    %eax,-0x4(%rbp)
		dwarf_size = 8;
  8004211f40:	c6 45 fb 08          	movb   $0x8,-0x5(%rbp)
  8004211f44:	eb 04                	jmp    8004211f4a <_get_next_cu+0x9d>
	} else {
		dwarf_size = 4;
  8004211f46:	c6 45 fb 04          	movb   $0x4,-0x5(%rbp)
	}

	cu->cu_dwarf_size = dwarf_size;
  8004211f4a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211f4e:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  8004211f52:	88 50 19             	mov    %dl,0x19(%rax)
	 if (length > ds->ds_size - offset) {
	 return (DW_DLE_CU_LENGTH_ERROR);
	 }*/

	/* Compute the offset to the next compilation unit: */
	dbg->curr_off_dbginfo = offset + length;
  8004211f55:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004211f58:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211f5c:	48 01 c2             	add    %rax,%rdx
  8004211f5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211f63:	48 89 10             	mov    %rdx,(%rax)
	cu->cu_next_offset   = dbg->curr_off_dbginfo;
  8004211f66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211f6a:	48 8b 10             	mov    (%rax),%rdx
  8004211f6d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211f71:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/* Initialise the compilation unit. */
	cu->cu_length = (uint64_t)length;
  8004211f75:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004211f78:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211f7c:	48 89 10             	mov    %rdx,(%rax)

	cu->cu_length_size   = (dwarf_size == 4 ? 4 : 12);
  8004211f7f:	80 7d fb 04          	cmpb   $0x4,-0x5(%rbp)
  8004211f83:	75 07                	jne    8004211f8c <_get_next_cu+0xdf>
  8004211f85:	ba 04 00 00 00       	mov    $0x4,%edx
  8004211f8a:	eb 05                	jmp    8004211f91 <_get_next_cu+0xe4>
  8004211f8c:	ba 0c 00 00 00       	mov    $0xc,%edx
  8004211f91:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211f95:	88 50 18             	mov    %dl,0x18(%rax)
	cu->version              = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 2);
  8004211f98:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211f9c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211fa0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211fa4:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004211fa8:	48 89 d7             	mov    %rdx,%rdi
  8004211fab:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  8004211faf:	ba 02 00 00 00       	mov    $0x2,%edx
  8004211fb4:	48 89 ce             	mov    %rcx,%rsi
  8004211fb7:	ff d0                	callq  *%rax
  8004211fb9:	89 c2                	mov    %eax,%edx
  8004211fbb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211fbf:	66 89 50 08          	mov    %dx,0x8(%rax)
	cu->debug_abbrev_offset  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, dwarf_size);
  8004211fc3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211fc7:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211fcb:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  8004211fcf:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211fd3:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  8004211fd7:	48 89 cf             	mov    %rcx,%rdi
  8004211fda:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  8004211fde:	48 89 ce             	mov    %rcx,%rsi
  8004211fe1:	ff d0                	callq  *%rax
  8004211fe3:	48 89 c2             	mov    %rax,%rdx
  8004211fe6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211fea:	48 89 50 10          	mov    %rdx,0x10(%rax)
	//cu->cu_abbrev_offset_cur = cu->cu_abbrev_offset;
	cu->addr_size  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 1);
  8004211fee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ff2:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211ff6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211ffa:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004211ffe:	48 89 d7             	mov    %rdx,%rdi
  8004212001:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  8004212005:	ba 01 00 00 00       	mov    $0x1,%edx
  800421200a:	48 89 ce             	mov    %rcx,%rsi
  800421200d:	ff d0                	callq  *%rax
  800421200f:	89 c2                	mov    %eax,%edx
  8004212011:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212015:	88 50 0a             	mov    %dl,0xa(%rax)

	if (cu->version < 2 || cu->version > 4) {
  8004212018:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421201c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004212020:	66 83 f8 01          	cmp    $0x1,%ax
  8004212024:	76 0e                	jbe    8004212034 <_get_next_cu+0x187>
  8004212026:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421202a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800421202e:	66 83 f8 04          	cmp    $0x4,%ax
  8004212032:	76 07                	jbe    800421203b <_get_next_cu+0x18e>
		return -1;
  8004212034:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212039:	eb 11                	jmp    800421204c <_get_next_cu+0x19f>
	}

	cu->cu_die_offset = offset;
  800421203b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421203f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212043:	48 89 50 28          	mov    %rdx,0x28(%rax)

	return 0;
  8004212047:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421204c:	c9                   	leaveq 
  800421204d:	c3                   	retq   

000000800421204e <print_cu>:

void print_cu(Dwarf_CU cu)
{
  800421204e:	55                   	push   %rbp
  800421204f:	48 89 e5             	mov    %rsp,%rbp
	cprintf("%ld---%du--%d\n",cu.cu_length,cu.version,cu.addr_size);
  8004212052:	0f b6 45 1a          	movzbl 0x1a(%rbp),%eax
  8004212056:	0f b6 c8             	movzbl %al,%ecx
  8004212059:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
  800421205d:	0f b7 d0             	movzwl %ax,%edx
  8004212060:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8004212064:	48 89 c6             	mov    %rax,%rsi
  8004212067:	48 bf 12 13 22 04 80 	movabs $0x8004221312,%rdi
  800421206e:	00 00 00 
  8004212071:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212076:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421207d:	00 00 00 
  8004212080:	41 ff d0             	callq  *%r8
}
  8004212083:	90                   	nop
  8004212084:	5d                   	pop    %rbp
  8004212085:	c3                   	retq   

0000008004212086 <_dwarf_abbrev_parse>:

//Return 0 on success
int
_dwarf_abbrev_parse(Dwarf_Debug dbg, Dwarf_CU cu, Dwarf_Unsigned *offset,
		    Dwarf_Abbrev *abp, Dwarf_Section *ds)
{
  8004212086:	55                   	push   %rbp
  8004212087:	48 89 e5             	mov    %rsp,%rbp
  800421208a:	48 83 ec 60          	sub    $0x60,%rsp
  800421208e:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004212092:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004212096:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  800421209a:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
	uint64_t tag;
	uint8_t children;
	uint64_t abbr_addr;
	int ret;

	assert(abp != NULL);
  800421209e:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  80042120a3:	75 35                	jne    80042120da <_dwarf_abbrev_parse+0x54>
  80042120a5:	48 b9 21 13 22 04 80 	movabs $0x8004221321,%rcx
  80042120ac:	00 00 00 
  80042120af:	48 ba ea 12 22 04 80 	movabs $0x80042212ea,%rdx
  80042120b6:	00 00 00 
  80042120b9:	be a4 01 00 00       	mov    $0x1a4,%esi
  80042120be:	48 bf ff 12 22 04 80 	movabs $0x80042212ff,%rdi
  80042120c5:	00 00 00 
  80042120c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042120cd:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042120d4:	00 00 00 
  80042120d7:	41 ff d0             	callq  *%r8
	assert(ds != NULL);
  80042120da:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  80042120df:	75 35                	jne    8004212116 <_dwarf_abbrev_parse+0x90>
  80042120e1:	48 b9 2d 13 22 04 80 	movabs $0x800422132d,%rcx
  80042120e8:	00 00 00 
  80042120eb:	48 ba ea 12 22 04 80 	movabs $0x80042212ea,%rdx
  80042120f2:	00 00 00 
  80042120f5:	be a5 01 00 00       	mov    $0x1a5,%esi
  80042120fa:	48 bf ff 12 22 04 80 	movabs $0x80042212ff,%rdi
  8004212101:	00 00 00 
  8004212104:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212109:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004212110:	00 00 00 
  8004212113:	41 ff d0             	callq  *%r8

	if (*offset >= ds->ds_size)
  8004212116:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421211a:	48 8b 10             	mov    (%rax),%rdx
  800421211d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212121:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212125:	48 39 c2             	cmp    %rax,%rdx
  8004212128:	72 0a                	jb     8004212134 <_dwarf_abbrev_parse+0xae>
        	return (DW_DLE_NO_ENTRY);
  800421212a:	b8 04 00 00 00       	mov    $0x4,%eax
  800421212f:	e9 d3 01 00 00       	jmpq   8004212307 <_dwarf_abbrev_parse+0x281>

	aboff = *offset;
  8004212134:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212138:	48 8b 00             	mov    (%rax),%rax
  800421213b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	abbr_addr = (uint64_t)ds->ds_data; //(uint64_t)((uint8_t *)elf_base_ptr + ds->sh_offset);
  800421213f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212143:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212147:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	entry = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800421214b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421214f:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004212153:	48 89 d6             	mov    %rdx,%rsi
  8004212156:	48 89 c7             	mov    %rax,%rdi
  8004212159:	48 b8 a3 1a 21 04 80 	movabs $0x8004211aa3,%rax
  8004212160:	00 00 00 
  8004212163:	ff d0                	callq  *%rax
  8004212165:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if (entry == 0) {
  8004212169:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800421216e:	75 15                	jne    8004212185 <_dwarf_abbrev_parse+0xff>
		/* Last entry. */
		//Need to make connection from below function
		abp->ab_entry = 0;
  8004212170:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004212174:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return DW_DLE_NONE;
  800421217b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212180:	e9 82 01 00 00       	jmpq   8004212307 <_dwarf_abbrev_parse+0x281>
	}

	tag = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004212185:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212189:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800421218d:	48 89 d6             	mov    %rdx,%rsi
  8004212190:	48 89 c7             	mov    %rax,%rdi
  8004212193:	48 b8 a3 1a 21 04 80 	movabs $0x8004211aa3,%rax
  800421219a:	00 00 00 
  800421219d:	ff d0                	callq  *%rax
  800421219f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	children = dbg->read((uint8_t *)abbr_addr, offset, 1);
  80042121a3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042121a7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042121ab:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80042121af:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80042121b3:	ba 01 00 00 00       	mov    $0x1,%edx
  80042121b8:	48 89 cf             	mov    %rcx,%rdi
  80042121bb:	ff d0                	callq  *%rax
  80042121bd:	88 45 df             	mov    %al,-0x21(%rbp)

	abp->ab_entry    = entry;
  80042121c0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042121c4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042121c8:	48 89 10             	mov    %rdx,(%rax)
	abp->ab_tag      = tag;
  80042121cb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042121cf:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042121d3:	48 89 50 08          	mov    %rdx,0x8(%rax)
	abp->ab_children = children;
  80042121d7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042121db:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  80042121df:	88 50 10             	mov    %dl,0x10(%rax)
	abp->ab_offset   = aboff;
  80042121e2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042121e6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042121ea:	48 89 50 18          	mov    %rdx,0x18(%rax)
	abp->ab_length   = 0;    /* fill in later. */
  80042121ee:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042121f2:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  80042121f9:	00 
	abp->ab_atnum    = 0;
  80042121fa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042121fe:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  8004212205:	00 

	/* Parse attribute definitions. */
	do {
		adoff = *offset;
  8004212206:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421220a:	48 8b 00             	mov    (%rax),%rax
  800421220d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		attr = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004212211:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212215:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004212219:	48 89 d6             	mov    %rdx,%rsi
  800421221c:	48 89 c7             	mov    %rax,%rdi
  800421221f:	48 b8 a3 1a 21 04 80 	movabs $0x8004211aa3,%rax
  8004212226:	00 00 00 
  8004212229:	ff d0                	callq  *%rax
  800421222b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		form = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800421222f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212233:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004212237:	48 89 d6             	mov    %rdx,%rsi
  800421223a:	48 89 c7             	mov    %rax,%rdi
  800421223d:	48 b8 a3 1a 21 04 80 	movabs $0x8004211aa3,%rax
  8004212244:	00 00 00 
  8004212247:	ff d0                	callq  *%rax
  8004212249:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		if (attr != 0)
  800421224d:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004212252:	0f 84 89 00 00 00    	je     80042122e1 <_dwarf_abbrev_parse+0x25b>
		{
			/* Initialise the attribute definition structure. */
			abp->ab_attrdef[abp->ab_atnum].ad_attrib = attr;
  8004212258:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421225c:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004212260:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004212264:	48 89 d0             	mov    %rdx,%rax
  8004212267:	48 01 c0             	add    %rax,%rax
  800421226a:	48 01 d0             	add    %rdx,%rax
  800421226d:	48 c1 e0 03          	shl    $0x3,%rax
  8004212271:	48 01 c8             	add    %rcx,%rax
  8004212274:	48 8d 50 30          	lea    0x30(%rax),%rdx
  8004212278:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421227c:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_form   = form;
  800421227f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004212283:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004212287:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800421228b:	48 89 d0             	mov    %rdx,%rax
  800421228e:	48 01 c0             	add    %rax,%rax
  8004212291:	48 01 d0             	add    %rdx,%rax
  8004212294:	48 c1 e0 03          	shl    $0x3,%rax
  8004212298:	48 01 c8             	add    %rcx,%rax
  800421229b:	48 8d 50 38          	lea    0x38(%rax),%rdx
  800421229f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042122a3:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_offset = adoff;
  80042122a6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042122aa:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042122ae:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  80042122b2:	48 89 d0             	mov    %rdx,%rax
  80042122b5:	48 01 c0             	add    %rax,%rax
  80042122b8:	48 01 d0             	add    %rdx,%rax
  80042122bb:	48 c1 e0 03          	shl    $0x3,%rax
  80042122bf:	48 01 c8             	add    %rcx,%rax
  80042122c2:	48 8d 50 40          	lea    0x40(%rax),%rdx
  80042122c6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042122ca:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_atnum++;
  80042122cd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042122d1:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042122d5:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042122d9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042122dd:	48 89 50 28          	mov    %rdx,0x28(%rax)
		}
	} while (attr != 0);
  80042122e1:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042122e6:	0f 85 1a ff ff ff    	jne    8004212206 <_dwarf_abbrev_parse+0x180>

	//(*abp)->ab_length = *offset - aboff;
	abp->ab_length = (uint64_t)(*offset - aboff);
  80042122ec:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042122f0:	48 8b 00             	mov    (%rax),%rax
  80042122f3:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  80042122f7:	48 89 c2             	mov    %rax,%rdx
  80042122fa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042122fe:	48 89 50 20          	mov    %rdx,0x20(%rax)

	return DW_DLV_OK;
  8004212302:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212307:	c9                   	leaveq 
  8004212308:	c3                   	retq   

0000008004212309 <_dwarf_abbrev_find>:

//Return 0 on success
int
_dwarf_abbrev_find(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t entry, Dwarf_Abbrev *abp)
{
  8004212309:	55                   	push   %rbp
  800421230a:	48 89 e5             	mov    %rsp,%rbp
  800421230d:	48 83 ec 40          	sub    $0x40,%rsp
  8004212311:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004212315:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004212319:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	Dwarf_Section *ds;
	uint64_t offset;
	int ret;

	if (entry == 0)
  800421231d:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004212322:	75 0a                	jne    800421232e <_dwarf_abbrev_find+0x25>
	{
		return (DW_DLE_NO_ENTRY);
  8004212324:	b8 04 00 00 00       	mov    $0x4,%eax
  8004212329:	e9 e3 00 00 00       	jmpq   8004212411 <_dwarf_abbrev_find+0x108>
	}

	/* Load and search the abbrev table. */
	ds = _dwarf_find_section(".debug_abbrev");
  800421232e:	48 bf 38 13 22 04 80 	movabs $0x8004221338,%rdi
  8004212335:	00 00 00 
  8004212338:	48 b8 9c 65 21 04 80 	movabs $0x800421659c,%rax
  800421233f:	00 00 00 
  8004212342:	ff d0                	callq  *%rax
  8004212344:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(ds != NULL);
  8004212348:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421234d:	75 35                	jne    8004212384 <_dwarf_abbrev_find+0x7b>
  800421234f:	48 b9 2d 13 22 04 80 	movabs $0x800422132d,%rcx
  8004212356:	00 00 00 
  8004212359:	48 ba ea 12 22 04 80 	movabs $0x80042212ea,%rdx
  8004212360:	00 00 00 
  8004212363:	be e5 01 00 00       	mov    $0x1e5,%esi
  8004212368:	48 bf ff 12 22 04 80 	movabs $0x80042212ff,%rdi
  800421236f:	00 00 00 
  8004212372:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212377:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421237e:	00 00 00 
  8004212381:	41 ff d0             	callq  *%r8

	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
  8004212384:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212388:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	while (offset < ds->ds_size) {
  800421238c:	eb 6a                	jmp    80042123f8 <_dwarf_abbrev_find+0xef>
		ret = _dwarf_abbrev_parse(dbg, cu, &offset, abp, ds);
  800421238e:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004212392:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212396:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  800421239a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421239e:	48 83 ec 08          	sub    $0x8,%rsp
  80042123a2:	ff 75 40             	pushq  0x40(%rbp)
  80042123a5:	ff 75 38             	pushq  0x38(%rbp)
  80042123a8:	ff 75 30             	pushq  0x30(%rbp)
  80042123ab:	ff 75 28             	pushq  0x28(%rbp)
  80042123ae:	ff 75 20             	pushq  0x20(%rbp)
  80042123b1:	ff 75 18             	pushq  0x18(%rbp)
  80042123b4:	ff 75 10             	pushq  0x10(%rbp)
  80042123b7:	48 89 c7             	mov    %rax,%rdi
  80042123ba:	48 b8 86 20 21 04 80 	movabs $0x8004212086,%rax
  80042123c1:	00 00 00 
  80042123c4:	ff d0                	callq  *%rax
  80042123c6:	48 83 c4 40          	add    $0x40,%rsp
  80042123ca:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (ret != DW_DLE_NONE)
  80042123cd:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  80042123d1:	74 05                	je     80042123d8 <_dwarf_abbrev_find+0xcf>
			return (ret);
  80042123d3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042123d6:	eb 39                	jmp    8004212411 <_dwarf_abbrev_find+0x108>
		if (abp->ab_entry == entry) {
  80042123d8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042123dc:	48 8b 00             	mov    (%rax),%rax
  80042123df:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042123e3:	75 07                	jne    80042123ec <_dwarf_abbrev_find+0xe3>
			//cu->cu_abbrev_offset_cur = offset;
			return DW_DLE_NONE;
  80042123e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042123ea:	eb 25                	jmp    8004212411 <_dwarf_abbrev_find+0x108>
		}
		if (abp->ab_entry == 0) {
  80042123ec:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042123f0:	48 8b 00             	mov    (%rax),%rax
  80042123f3:	48 85 c0             	test   %rax,%rax
  80042123f6:	74 13                	je     800421240b <_dwarf_abbrev_find+0x102>
	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
	while (offset < ds->ds_size) {
  80042123f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042123fc:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004212400:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212404:	48 39 c2             	cmp    %rax,%rdx
  8004212407:	77 85                	ja     800421238e <_dwarf_abbrev_find+0x85>
  8004212409:	eb 01                	jmp    800421240c <_dwarf_abbrev_find+0x103>
			return DW_DLE_NONE;
		}
		if (abp->ab_entry == 0) {
			//cu->cu_abbrev_offset_cur = offset;
			//cu->cu_abbrev_loaded = 1;
			break;
  800421240b:	90                   	nop
		}
	}

	return DW_DLE_NO_ENTRY;
  800421240c:	b8 04 00 00 00       	mov    $0x4,%eax
}
  8004212411:	c9                   	leaveq 
  8004212412:	c3                   	retq   

0000008004212413 <_dwarf_attr_init>:

//Return 0 on success
int
_dwarf_attr_init(Dwarf_Debug dbg, uint64_t *offsetp, Dwarf_CU *cu, Dwarf_Die *ret_die, Dwarf_AttrDef *ad,
		 uint64_t form, int indirect)
{
  8004212413:	55                   	push   %rbp
  8004212414:	48 89 e5             	mov    %rsp,%rbp
  8004212417:	48 81 ec c0 00 00 00 	sub    $0xc0,%rsp
  800421241e:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004212425:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  800421242c:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004212433:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  800421243a:	4c 89 85 48 ff ff ff 	mov    %r8,-0xb8(%rbp)
  8004212441:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
	struct _Dwarf_Attribute atref;
	Dwarf_Section *str;
	int ret;
	Dwarf_Section *ds = _dwarf_find_section(".debug_info");
  8004212448:	48 bf 46 13 22 04 80 	movabs $0x8004221346,%rdi
  800421244f:	00 00 00 
  8004212452:	48 b8 9c 65 21 04 80 	movabs $0x800421659c,%rax
  8004212459:	00 00 00 
  800421245c:	ff d0                	callq  *%rax
  800421245e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	uint8_t *ds_data = (uint8_t *)ds->ds_data; //(uint8_t *)dbg->dbg_info_offset_elf;
  8004212462:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212466:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421246a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint8_t dwarf_size = cu->cu_dwarf_size;
  800421246e:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004212475:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004212479:	88 45 e7             	mov    %al,-0x19(%rbp)

	ret = DW_DLE_NONE;
  800421247c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	memset(&atref, 0, sizeof(atref));
  8004212483:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  800421248a:	ba 60 00 00 00       	mov    $0x60,%edx
  800421248f:	be 00 00 00 00       	mov    $0x0,%esi
  8004212494:	48 89 c7             	mov    %rax,%rdi
  8004212497:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  800421249e:	00 00 00 
  80042124a1:	ff d0                	callq  *%rax
	atref.at_die = ret_die;
  80042124a3:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042124aa:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	atref.at_attrib = ad->ad_attrib;
  80042124b1:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042124b8:	48 8b 00             	mov    (%rax),%rax
  80042124bb:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	atref.at_form = ad->ad_form;
  80042124bf:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042124c6:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042124ca:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	atref.at_indirect = indirect;
  80042124ce:	8b 45 10             	mov    0x10(%rbp),%eax
  80042124d1:	89 45 90             	mov    %eax,-0x70(%rbp)
	atref.at_ld = NULL;
  80042124d4:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  80042124db:	00 

	switch (form) {
  80042124dc:	48 83 bd 40 ff ff ff 	cmpq   $0x20,-0xc0(%rbp)
  80042124e3:	20 
  80042124e4:	0f 87 87 04 00 00    	ja     8004212971 <_dwarf_attr_init+0x55e>
  80042124ea:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  80042124f1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042124f8:	00 
  80042124f9:	48 b8 70 13 22 04 80 	movabs $0x8004221370,%rax
  8004212500:	00 00 00 
  8004212503:	48 01 d0             	add    %rdx,%rax
  8004212506:	48 8b 00             	mov    (%rax),%rax
  8004212509:	ff e0                	jmpq   *%rax
	case DW_FORM_addr:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  800421250b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004212512:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212516:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800421251d:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004212521:	0f b6 d2             	movzbl %dl,%edx
  8004212524:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421252b:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421252f:	48 89 cf             	mov    %rcx,%rdi
  8004212532:	ff d0                	callq  *%rax
  8004212534:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004212538:	e9 3e 04 00 00       	jmpq   800421297b <_dwarf_attr_init+0x568>
	case DW_FORM_block:
	case DW_FORM_exprloc:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  800421253d:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004212544:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212548:	48 89 d6             	mov    %rdx,%rsi
  800421254b:	48 89 c7             	mov    %rax,%rdi
  800421254e:	48 b8 a3 1a 21 04 80 	movabs $0x8004211aa3,%rax
  8004212555:	00 00 00 
  8004212558:	ff d0                	callq  *%rax
  800421255a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800421255e:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004212562:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004212569:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421256d:	48 89 ce             	mov    %rcx,%rsi
  8004212570:	48 89 c7             	mov    %rax,%rdi
  8004212573:	48 b8 b0 1c 21 04 80 	movabs $0x8004211cb0,%rax
  800421257a:	00 00 00 
  800421257d:	ff d0                	callq  *%rax
  800421257f:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004212583:	e9 f3 03 00 00       	jmpq   800421297b <_dwarf_attr_init+0x568>
	case DW_FORM_block1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  8004212588:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421258f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212593:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421259a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421259e:	ba 01 00 00 00       	mov    $0x1,%edx
  80042125a3:	48 89 cf             	mov    %rcx,%rdi
  80042125a6:	ff d0                	callq  *%rax
  80042125a8:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  80042125ac:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042125b0:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042125b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042125bb:	48 89 ce             	mov    %rcx,%rsi
  80042125be:	48 89 c7             	mov    %rax,%rdi
  80042125c1:	48 b8 b0 1c 21 04 80 	movabs $0x8004211cb0,%rax
  80042125c8:	00 00 00 
  80042125cb:	ff d0                	callq  *%rax
  80042125cd:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  80042125d1:	e9 a5 03 00 00       	jmpq   800421297b <_dwarf_attr_init+0x568>
	case DW_FORM_block2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  80042125d6:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042125dd:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042125e1:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042125e8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042125ec:	ba 02 00 00 00       	mov    $0x2,%edx
  80042125f1:	48 89 cf             	mov    %rcx,%rdi
  80042125f4:	ff d0                	callq  *%rax
  80042125f6:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  80042125fa:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042125fe:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004212605:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212609:	48 89 ce             	mov    %rcx,%rsi
  800421260c:	48 89 c7             	mov    %rax,%rdi
  800421260f:	48 b8 b0 1c 21 04 80 	movabs $0x8004211cb0,%rax
  8004212616:	00 00 00 
  8004212619:	ff d0                	callq  *%rax
  800421261b:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800421261f:	e9 57 03 00 00       	jmpq   800421297b <_dwarf_attr_init+0x568>
	case DW_FORM_block4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  8004212624:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421262b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421262f:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004212636:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421263a:	ba 04 00 00 00       	mov    $0x4,%edx
  800421263f:	48 89 cf             	mov    %rcx,%rdi
  8004212642:	ff d0                	callq  *%rax
  8004212644:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004212648:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421264c:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004212653:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212657:	48 89 ce             	mov    %rcx,%rsi
  800421265a:	48 89 c7             	mov    %rax,%rdi
  800421265d:	48 b8 b0 1c 21 04 80 	movabs $0x8004211cb0,%rax
  8004212664:	00 00 00 
  8004212667:	ff d0                	callq  *%rax
  8004212669:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800421266d:	e9 09 03 00 00       	jmpq   800421297b <_dwarf_attr_init+0x568>
	case DW_FORM_data1:
	case DW_FORM_flag:
	case DW_FORM_ref1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  8004212672:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004212679:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421267d:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004212684:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212688:	ba 01 00 00 00       	mov    $0x1,%edx
  800421268d:	48 89 cf             	mov    %rcx,%rdi
  8004212690:	ff d0                	callq  *%rax
  8004212692:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004212696:	e9 e0 02 00 00       	jmpq   800421297b <_dwarf_attr_init+0x568>
	case DW_FORM_data2:
	case DW_FORM_ref2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  800421269b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042126a2:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042126a6:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042126ad:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042126b1:	ba 02 00 00 00       	mov    $0x2,%edx
  80042126b6:	48 89 cf             	mov    %rcx,%rdi
  80042126b9:	ff d0                	callq  *%rax
  80042126bb:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042126bf:	e9 b7 02 00 00       	jmpq   800421297b <_dwarf_attr_init+0x568>
	case DW_FORM_data4:
	case DW_FORM_ref4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  80042126c4:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042126cb:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042126cf:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042126d6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042126da:	ba 04 00 00 00       	mov    $0x4,%edx
  80042126df:	48 89 cf             	mov    %rcx,%rdi
  80042126e2:	ff d0                	callq  *%rax
  80042126e4:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042126e8:	e9 8e 02 00 00       	jmpq   800421297b <_dwarf_attr_init+0x568>
	case DW_FORM_data8:
	case DW_FORM_ref8:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 8);
  80042126ed:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042126f4:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042126f8:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042126ff:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212703:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212708:	48 89 cf             	mov    %rcx,%rdi
  800421270b:	ff d0                	callq  *%rax
  800421270d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004212711:	e9 65 02 00 00       	jmpq   800421297b <_dwarf_attr_init+0x568>
	case DW_FORM_indirect:
		form = _dwarf_read_uleb128(ds_data, offsetp);
  8004212716:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421271d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212721:	48 89 d6             	mov    %rdx,%rsi
  8004212724:	48 89 c7             	mov    %rax,%rdi
  8004212727:	48 b8 a3 1a 21 04 80 	movabs $0x8004211aa3,%rax
  800421272e:	00 00 00 
  8004212731:	ff d0                	callq  *%rax
  8004212733:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
		return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
  800421273a:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
  8004212741:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  8004212748:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  800421274f:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004212756:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421275d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004212764:	48 83 ec 08          	sub    $0x8,%rsp
  8004212768:	6a 01                	pushq  $0x1
  800421276a:	4d 89 c1             	mov    %r8,%r9
  800421276d:	49 89 f8             	mov    %rdi,%r8
  8004212770:	48 89 c7             	mov    %rax,%rdi
  8004212773:	48 b8 13 24 21 04 80 	movabs $0x8004212413,%rax
  800421277a:	00 00 00 
  800421277d:	ff d0                	callq  *%rax
  800421277f:	48 83 c4 10          	add    $0x10,%rsp
  8004212783:	e9 21 03 00 00       	jmpq   8004212aa9 <_dwarf_attr_init+0x696>
	case DW_FORM_ref_addr:
		if (cu->version == 2)
  8004212788:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800421278f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004212793:	66 83 f8 02          	cmp    $0x2,%ax
  8004212797:	75 32                	jne    80042127cb <_dwarf_attr_init+0x3b8>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  8004212799:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042127a0:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042127a4:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  80042127ab:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  80042127af:	0f b6 d2             	movzbl %dl,%edx
  80042127b2:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042127b9:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042127bd:	48 89 cf             	mov    %rcx,%rdi
  80042127c0:	ff d0                	callq  *%rax
  80042127c2:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		else if (cu->version == 3)
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
		break;
  80042127c6:	e9 af 01 00 00       	jmpq   800421297a <_dwarf_attr_init+0x567>
		form = _dwarf_read_uleb128(ds_data, offsetp);
		return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
	case DW_FORM_ref_addr:
		if (cu->version == 2)
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
		else if (cu->version == 3)
  80042127cb:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042127d2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042127d6:	66 83 f8 03          	cmp    $0x3,%ax
  80042127da:	0f 85 9a 01 00 00    	jne    800421297a <_dwarf_attr_init+0x567>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  80042127e0:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042127e7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042127eb:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  80042127ef:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042127f6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042127fa:	48 89 cf             	mov    %rcx,%rdi
  80042127fd:	ff d0                	callq  *%rax
  80042127ff:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004212803:	e9 72 01 00 00       	jmpq   800421297a <_dwarf_attr_init+0x567>
	case DW_FORM_ref_udata:
	case DW_FORM_udata:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  8004212808:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421280f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212813:	48 89 d6             	mov    %rdx,%rsi
  8004212816:	48 89 c7             	mov    %rax,%rdi
  8004212819:	48 b8 a3 1a 21 04 80 	movabs $0x8004211aa3,%rax
  8004212820:	00 00 00 
  8004212823:	ff d0                	callq  *%rax
  8004212825:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004212829:	e9 4d 01 00 00       	jmpq   800421297b <_dwarf_attr_init+0x568>
	case DW_FORM_sdata:
		atref.u[0].s64 = _dwarf_read_sleb128(ds_data, offsetp);
  800421282e:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004212835:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212839:	48 89 d6             	mov    %rdx,%rsi
  800421283c:	48 89 c7             	mov    %rax,%rdi
  800421283f:	48 b8 ff 19 21 04 80 	movabs $0x80042119ff,%rax
  8004212846:	00 00 00 
  8004212849:	ff d0                	callq  *%rax
  800421284b:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421284f:	e9 27 01 00 00       	jmpq   800421297b <_dwarf_attr_init+0x568>
	case DW_FORM_sec_offset:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004212854:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421285b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421285f:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004212863:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421286a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421286e:	48 89 cf             	mov    %rcx,%rdi
  8004212871:	ff d0                	callq  *%rax
  8004212873:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004212877:	e9 ff 00 00 00       	jmpq   800421297b <_dwarf_attr_init+0x568>
	case DW_FORM_string:
		atref.u[0].s =(char*) _dwarf_read_string(ds_data, (uint64_t)ds->ds_size, offsetp);
  800421287c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212880:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004212884:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421288b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421288f:	48 89 ce             	mov    %rcx,%rsi
  8004212892:	48 89 c7             	mov    %rax,%rdi
  8004212895:	48 b8 21 1c 21 04 80 	movabs $0x8004211c21,%rax
  800421289c:	00 00 00 
  800421289f:	ff d0                	callq  *%rax
  80042128a1:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042128a5:	e9 d1 00 00 00       	jmpq   800421297b <_dwarf_attr_init+0x568>
	case DW_FORM_strp:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  80042128aa:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042128b1:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042128b5:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  80042128b9:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042128c0:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042128c4:	48 89 cf             	mov    %rcx,%rdi
  80042128c7:	ff d0                	callq  *%rax
  80042128c9:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		str = _dwarf_find_section(".debug_str");
  80042128cd:	48 bf 52 13 22 04 80 	movabs $0x8004221352,%rdi
  80042128d4:	00 00 00 
  80042128d7:	48 b8 9c 65 21 04 80 	movabs $0x800421659c,%rax
  80042128de:	00 00 00 
  80042128e1:	ff d0                	callq  *%rax
  80042128e3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		assert(str != NULL);
  80042128e7:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042128ec:	75 35                	jne    8004212923 <_dwarf_attr_init+0x510>
  80042128ee:	48 b9 5d 13 22 04 80 	movabs $0x800422135d,%rcx
  80042128f5:	00 00 00 
  80042128f8:	48 ba ea 12 22 04 80 	movabs $0x80042212ea,%rdx
  80042128ff:	00 00 00 
  8004212902:	be 51 02 00 00       	mov    $0x251,%esi
  8004212907:	48 bf ff 12 22 04 80 	movabs $0x80042212ff,%rdi
  800421290e:	00 00 00 
  8004212911:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212916:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421291d:	00 00 00 
  8004212920:	41 ff d0             	callq  *%r8
		//atref.u[1].s = (char *)(elf_base_ptr + str->sh_offset) + atref.u[0].u64;
		atref.u[1].s = (char *)str->ds_data + atref.u[0].u64;
  8004212923:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212927:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800421292b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421292f:	48 01 d0             	add    %rdx,%rax
  8004212932:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004212936:	eb 43                	jmp    800421297b <_dwarf_attr_init+0x568>
	case DW_FORM_ref_sig8:
		atref.u[0].u64 = 8;
  8004212938:	48 c7 45 98 08 00 00 	movq   $0x8,-0x68(%rbp)
  800421293f:	00 
		atref.u[1].u8p = (uint8_t*)(_dwarf_read_block(ds_data, offsetp, atref.u[0].u64));
  8004212940:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004212944:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800421294b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421294f:	48 89 ce             	mov    %rcx,%rsi
  8004212952:	48 89 c7             	mov    %rax,%rdi
  8004212955:	48 b8 b0 1c 21 04 80 	movabs $0x8004211cb0,%rax
  800421295c:	00 00 00 
  800421295f:	ff d0                	callq  *%rax
  8004212961:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004212965:	eb 14                	jmp    800421297b <_dwarf_attr_init+0x568>
	case DW_FORM_flag_present:
		/* This form has no value encoded in the DIE. */
		atref.u[0].u64 = 1;
  8004212967:	48 c7 45 98 01 00 00 	movq   $0x1,-0x68(%rbp)
  800421296e:	00 
		break;
  800421296f:	eb 0a                	jmp    800421297b <_dwarf_attr_init+0x568>
	default:
		//DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
		ret = DW_DLE_ATTR_FORM_BAD;
  8004212971:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%rbp)
		break;
  8004212978:	eb 01                	jmp    800421297b <_dwarf_attr_init+0x568>
	case DW_FORM_ref_addr:
		if (cu->version == 2)
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
		else if (cu->version == 3)
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
		break;
  800421297a:	90                   	nop
		//DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
		ret = DW_DLE_ATTR_FORM_BAD;
		break;
	}

	if (ret == DW_DLE_NONE) {
  800421297b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800421297f:	0f 85 21 01 00 00    	jne    8004212aa6 <_dwarf_attr_init+0x693>
		if (form == DW_FORM_block || form == DW_FORM_block1 ||
  8004212985:	48 83 bd 40 ff ff ff 	cmpq   $0x9,-0xc0(%rbp)
  800421298c:	09 
  800421298d:	74 1e                	je     80042129ad <_dwarf_attr_init+0x59a>
  800421298f:	48 83 bd 40 ff ff ff 	cmpq   $0xa,-0xc0(%rbp)
  8004212996:	0a 
  8004212997:	74 14                	je     80042129ad <_dwarf_attr_init+0x59a>
  8004212999:	48 83 bd 40 ff ff ff 	cmpq   $0x3,-0xc0(%rbp)
  80042129a0:	03 
  80042129a1:	74 0a                	je     80042129ad <_dwarf_attr_init+0x59a>
		    form == DW_FORM_block2 || form == DW_FORM_block4) {
  80042129a3:	48 83 bd 40 ff ff ff 	cmpq   $0x4,-0xc0(%rbp)
  80042129aa:	04 
  80042129ab:	75 10                	jne    80042129bd <_dwarf_attr_init+0x5aa>
			atref.at_block.bl_len = atref.u[0].u64;
  80042129ad:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042129b1:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			atref.at_block.bl_data = atref.u[1].u8p;
  80042129b5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042129b9:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
  80042129bd:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042129c1:	48 83 f8 03          	cmp    $0x3,%rax
  80042129c5:	75 39                	jne    8004212a00 <_dwarf_attr_init+0x5ed>
			switch (atref.at_form) {
  80042129c7:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042129cb:	48 83 f8 08          	cmp    $0x8,%rax
  80042129cf:	74 1c                	je     80042129ed <_dwarf_attr_init+0x5da>
  80042129d1:	48 83 f8 0e          	cmp    $0xe,%rax
  80042129d5:	74 02                	je     80042129d9 <_dwarf_attr_init+0x5c6>
				break;
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
				break;
			default:
				break;
  80042129d7:	eb 27                	jmp    8004212a00 <_dwarf_attr_init+0x5ed>
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
			switch (atref.at_form) {
			case DW_FORM_strp:
				ret_die->die_name = atref.u[1].s;
  80042129d9:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042129dd:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042129e4:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  80042129eb:	eb 13                	jmp    8004212a00 <_dwarf_attr_init+0x5ed>
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
  80042129ed:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042129f1:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042129f8:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  80042129ff:	90                   	nop
			default:
				break;
			}
		}
		ret_die->die_attr[ret_die->die_attr_count++] = atref;
  8004212a00:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004212a07:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004212a0e:	8d 48 01             	lea    0x1(%rax),%ecx
  8004212a11:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  8004212a18:	88 8a 58 03 00 00    	mov    %cl,0x358(%rdx)
  8004212a1e:	0f b6 c0             	movzbl %al,%eax
  8004212a21:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  8004212a28:	48 63 d0             	movslq %eax,%rdx
  8004212a2b:	48 89 d0             	mov    %rdx,%rax
  8004212a2e:	48 01 c0             	add    %rax,%rax
  8004212a31:	48 01 d0             	add    %rdx,%rax
  8004212a34:	48 c1 e0 05          	shl    $0x5,%rax
  8004212a38:	48 01 c8             	add    %rcx,%rax
  8004212a3b:	48 05 70 03 00 00    	add    $0x370,%rax
  8004212a41:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004212a48:	48 89 10             	mov    %rdx,(%rax)
  8004212a4b:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004212a52:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004212a56:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004212a5a:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004212a5e:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  8004212a62:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004212a66:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004212a6a:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004212a6e:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004212a72:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004212a76:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004212a7a:	48 89 50 30          	mov    %rdx,0x30(%rax)
  8004212a7e:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004212a82:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004212a86:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004212a8a:	48 89 50 40          	mov    %rdx,0x40(%rax)
  8004212a8e:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212a92:	48 89 50 48          	mov    %rdx,0x48(%rax)
  8004212a96:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212a9a:	48 89 50 50          	mov    %rdx,0x50(%rax)
  8004212a9e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212aa2:	48 89 50 58          	mov    %rdx,0x58(%rax)
	}

	return (ret);
  8004212aa6:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004212aa9:	c9                   	leaveq 
  8004212aaa:	c3                   	retq   

0000008004212aab <dwarf_search_die_within_cu>:

int
dwarf_search_die_within_cu(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t offset, Dwarf_Die *ret_die, int search_sibling)
{
  8004212aab:	55                   	push   %rbp
  8004212aac:	48 89 e5             	mov    %rsp,%rbp
  8004212aaf:	48 81 ec 90 03 00 00 	sub    $0x390,%rsp
  8004212ab6:	48 89 bd 88 fc ff ff 	mov    %rdi,-0x378(%rbp)
  8004212abd:	48 89 b5 80 fc ff ff 	mov    %rsi,-0x380(%rbp)
  8004212ac4:	48 89 95 78 fc ff ff 	mov    %rdx,-0x388(%rbp)
  8004212acb:	89 8d 74 fc ff ff    	mov    %ecx,-0x38c(%rbp)
	uint64_t abnum;
	uint64_t die_offset;
	int ret, level;
	int i;

	assert(dbg);
  8004212ad1:	48 83 bd 88 fc ff ff 	cmpq   $0x0,-0x378(%rbp)
  8004212ad8:	00 
  8004212ad9:	75 35                	jne    8004212b10 <dwarf_search_die_within_cu+0x65>
  8004212adb:	48 b9 78 14 22 04 80 	movabs $0x8004221478,%rcx
  8004212ae2:	00 00 00 
  8004212ae5:	48 ba ea 12 22 04 80 	movabs $0x80042212ea,%rdx
  8004212aec:	00 00 00 
  8004212aef:	be 86 02 00 00       	mov    $0x286,%esi
  8004212af4:	48 bf ff 12 22 04 80 	movabs $0x80042212ff,%rdi
  8004212afb:	00 00 00 
  8004212afe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212b03:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004212b0a:	00 00 00 
  8004212b0d:	41 ff d0             	callq  *%r8
	//assert(cu);
	assert(ret_die);
  8004212b10:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
  8004212b17:	00 
  8004212b18:	75 35                	jne    8004212b4f <dwarf_search_die_within_cu+0xa4>
  8004212b1a:	48 b9 7c 14 22 04 80 	movabs $0x800422147c,%rcx
  8004212b21:	00 00 00 
  8004212b24:	48 ba ea 12 22 04 80 	movabs $0x80042212ea,%rdx
  8004212b2b:	00 00 00 
  8004212b2e:	be 88 02 00 00       	mov    $0x288,%esi
  8004212b33:	48 bf ff 12 22 04 80 	movabs $0x80042212ff,%rdi
  8004212b3a:	00 00 00 
  8004212b3d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212b42:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004212b49:	00 00 00 
  8004212b4c:	41 ff d0             	callq  *%r8

	level = 1;
  8004212b4f:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004212b56:	e9 fa 01 00 00       	jmpq   8004212d55 <dwarf_search_die_within_cu+0x2aa>

		die_offset = offset;
  8004212b5b:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004212b62:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		abnum = _dwarf_read_uleb128((uint8_t *)dbg->dbg_info_offset_elf, &offset);
  8004212b66:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004212b6d:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212b71:	48 89 c2             	mov    %rax,%rdx
  8004212b74:	48 8d 85 80 fc ff ff 	lea    -0x380(%rbp),%rax
  8004212b7b:	48 89 c6             	mov    %rax,%rsi
  8004212b7e:	48 89 d7             	mov    %rdx,%rdi
  8004212b81:	48 b8 a3 1a 21 04 80 	movabs $0x8004211aa3,%rax
  8004212b88:	00 00 00 
  8004212b8b:	ff d0                	callq  *%rax
  8004212b8d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		if (abnum == 0) {
  8004212b91:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004212b96:	75 22                	jne    8004212bba <dwarf_search_die_within_cu+0x10f>
			if (level == 0 || !search_sibling) {
  8004212b98:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004212b9c:	74 09                	je     8004212ba7 <dwarf_search_die_within_cu+0xfc>
  8004212b9e:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  8004212ba5:	75 0a                	jne    8004212bb1 <dwarf_search_die_within_cu+0x106>
				//No more entry
				return (DW_DLE_NO_ENTRY);
  8004212ba7:	b8 04 00 00 00       	mov    $0x4,%eax
  8004212bac:	e9 d4 01 00 00       	jmpq   8004212d85 <dwarf_search_die_within_cu+0x2da>
			}
			/*
			 * Return to previous DIE level.
			 */
			level--;
  8004212bb1:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
			continue;
  8004212bb5:	e9 9b 01 00 00       	jmpq   8004212d55 <dwarf_search_die_within_cu+0x2aa>
		}

		if ((ret = _dwarf_abbrev_find(dbg, cu, abnum, &ab)) != DW_DLE_NONE)
  8004212bba:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  8004212bc1:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212bc5:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004212bcc:	48 83 ec 08          	sub    $0x8,%rsp
  8004212bd0:	ff 75 40             	pushq  0x40(%rbp)
  8004212bd3:	ff 75 38             	pushq  0x38(%rbp)
  8004212bd6:	ff 75 30             	pushq  0x30(%rbp)
  8004212bd9:	ff 75 28             	pushq  0x28(%rbp)
  8004212bdc:	ff 75 20             	pushq  0x20(%rbp)
  8004212bdf:	ff 75 18             	pushq  0x18(%rbp)
  8004212be2:	ff 75 10             	pushq  0x10(%rbp)
  8004212be5:	48 89 ce             	mov    %rcx,%rsi
  8004212be8:	48 89 c7             	mov    %rax,%rdi
  8004212beb:	48 b8 09 23 21 04 80 	movabs $0x8004212309,%rax
  8004212bf2:	00 00 00 
  8004212bf5:	ff d0                	callq  *%rax
  8004212bf7:	48 83 c4 40          	add    $0x40,%rsp
  8004212bfb:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004212bfe:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004212c02:	74 08                	je     8004212c0c <dwarf_search_die_within_cu+0x161>
			return (ret);
  8004212c04:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004212c07:	e9 79 01 00 00       	jmpq   8004212d85 <dwarf_search_die_within_cu+0x2da>
		ret_die->die_offset = die_offset;
  8004212c0c:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212c13:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004212c17:	48 89 10             	mov    %rdx,(%rax)
		ret_die->die_abnum  = abnum;
  8004212c1a:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212c21:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212c25:	48 89 50 10          	mov    %rdx,0x10(%rax)
		ret_die->die_ab  = ab;
  8004212c29:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212c30:	48 8d 50 20          	lea    0x20(%rax),%rdx
  8004212c34:	48 8d 85 b0 fc ff ff 	lea    -0x350(%rbp),%rax
  8004212c3b:	b9 66 00 00 00       	mov    $0x66,%ecx
  8004212c40:	48 89 d7             	mov    %rdx,%rdi
  8004212c43:	48 89 c6             	mov    %rax,%rsi
  8004212c46:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		ret_die->die_attr_count = 0;
  8004212c49:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212c50:	c6 80 58 03 00 00 00 	movb   $0x0,0x358(%rax)
		ret_die->die_tag = ab.ab_tag;
  8004212c57:	48 8b 95 b8 fc ff ff 	mov    -0x348(%rbp),%rdx
  8004212c5e:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212c65:	48 89 50 18          	mov    %rdx,0x18(%rax)
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  8004212c69:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8004212c70:	e9 91 00 00 00       	jmpq   8004212d06 <dwarf_search_die_within_cu+0x25b>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
  8004212c75:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004212c78:	48 63 d0             	movslq %eax,%rdx
  8004212c7b:	48 89 d0             	mov    %rdx,%rax
  8004212c7e:	48 01 c0             	add    %rax,%rax
  8004212c81:	48 01 d0             	add    %rdx,%rax
  8004212c84:	48 c1 e0 03          	shl    $0x3,%rax
  8004212c88:	48 01 e8             	add    %rbp,%rax
  8004212c8b:	48 2d 18 03 00 00    	sub    $0x318,%rax
  8004212c91:	48 8b 08             	mov    (%rax),%rcx
  8004212c94:	48 8d b5 b0 fc ff ff 	lea    -0x350(%rbp),%rsi
  8004212c9b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004212c9e:	48 63 d0             	movslq %eax,%rdx
  8004212ca1:	48 89 d0             	mov    %rdx,%rax
  8004212ca4:	48 01 c0             	add    %rax,%rax
  8004212ca7:	48 01 d0             	add    %rdx,%rax
  8004212caa:	48 c1 e0 03          	shl    $0x3,%rax
  8004212cae:	48 83 c0 30          	add    $0x30,%rax
  8004212cb2:	48 8d 3c 06          	lea    (%rsi,%rax,1),%rdi
  8004212cb6:	48 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%rdx
  8004212cbd:	48 8d b5 80 fc ff ff 	lea    -0x380(%rbp),%rsi
  8004212cc4:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004212ccb:	48 83 ec 08          	sub    $0x8,%rsp
  8004212ccf:	6a 00                	pushq  $0x0
  8004212cd1:	49 89 c9             	mov    %rcx,%r9
  8004212cd4:	49 89 f8             	mov    %rdi,%r8
  8004212cd7:	48 89 d1             	mov    %rdx,%rcx
  8004212cda:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  8004212cde:	48 89 c7             	mov    %rax,%rdi
  8004212ce1:	48 b8 13 24 21 04 80 	movabs $0x8004212413,%rax
  8004212ce8:	00 00 00 
  8004212ceb:	ff d0                	callq  *%rax
  8004212ced:	48 83 c4 10          	add    $0x10,%rsp
  8004212cf1:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004212cf4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004212cf8:	74 08                	je     8004212d02 <dwarf_search_die_within_cu+0x257>
				return (ret);
  8004212cfa:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004212cfd:	e9 83 00 00 00       	jmpq   8004212d85 <dwarf_search_die_within_cu+0x2da>
		ret_die->die_attr_count = 0;
		ret_die->die_tag = ab.ab_tag;
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  8004212d02:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004212d06:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004212d09:	48 63 d0             	movslq %eax,%rdx
  8004212d0c:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  8004212d13:	48 39 c2             	cmp    %rax,%rdx
  8004212d16:	0f 82 59 ff ff ff    	jb     8004212c75 <dwarf_search_die_within_cu+0x1ca>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
				return (ret);
		}

		ret_die->die_next_off = offset;
  8004212d1c:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
  8004212d23:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212d2a:	48 89 50 08          	mov    %rdx,0x8(%rax)
		if (search_sibling && level > 0) {
  8004212d2e:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  8004212d35:	74 17                	je     8004212d4e <dwarf_search_die_within_cu+0x2a3>
  8004212d37:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004212d3b:	7e 11                	jle    8004212d4e <dwarf_search_die_within_cu+0x2a3>
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  8004212d3d:	0f b6 85 c0 fc ff ff 	movzbl -0x340(%rbp),%eax
  8004212d44:	3c 01                	cmp    $0x1,%al
  8004212d46:	75 0d                	jne    8004212d55 <dwarf_search_die_within_cu+0x2aa>
				/* Advance to next DIE level. */
				level++;
  8004212d48:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
		}

		ret_die->die_next_off = offset;
		if (search_sibling && level > 0) {
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  8004212d4c:	eb 07                	jmp    8004212d55 <dwarf_search_die_within_cu+0x2aa>
				/* Advance to next DIE level. */
				level++;
			}
		} else {
			//*ret_die = die;
			return (DW_DLE_NONE);
  8004212d4e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212d53:	eb 30                	jmp    8004212d85 <dwarf_search_die_within_cu+0x2da>
	//assert(cu);
	assert(ret_die);

	level = 1;

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004212d55:	48 8b 55 30          	mov    0x30(%rbp),%rdx
  8004212d59:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004212d60:	48 39 c2             	cmp    %rax,%rdx
  8004212d63:	76 1b                	jbe    8004212d80 <dwarf_search_die_within_cu+0x2d5>
  8004212d65:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004212d6c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004212d70:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004212d77:	48 39 c2             	cmp    %rax,%rdx
  8004212d7a:	0f 87 db fd ff ff    	ja     8004212b5b <dwarf_search_die_within_cu+0xb0>
			//*ret_die = die;
			return (DW_DLE_NONE);
		}
	}

	return (DW_DLE_NO_ENTRY);
  8004212d80:	b8 04 00 00 00       	mov    $0x4,%eax
}
  8004212d85:	c9                   	leaveq 
  8004212d86:	c3                   	retq   

0000008004212d87 <dwarf_offdie>:

//Return 0 on success
int
dwarf_offdie(Dwarf_Debug dbg, uint64_t offset, Dwarf_Die *ret_die, Dwarf_CU cu)
{
  8004212d87:	55                   	push   %rbp
  8004212d88:	48 89 e5             	mov    %rsp,%rbp
  8004212d8b:	48 83 ec 30          	sub    $0x30,%rsp
  8004212d8f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004212d93:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004212d97:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int ret;

	assert(dbg);
  8004212d9b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004212da0:	75 35                	jne    8004212dd7 <dwarf_offdie+0x50>
  8004212da2:	48 b9 78 14 22 04 80 	movabs $0x8004221478,%rcx
  8004212da9:	00 00 00 
  8004212dac:	48 ba ea 12 22 04 80 	movabs $0x80042212ea,%rdx
  8004212db3:	00 00 00 
  8004212db6:	be c4 02 00 00       	mov    $0x2c4,%esi
  8004212dbb:	48 bf ff 12 22 04 80 	movabs $0x80042212ff,%rdi
  8004212dc2:	00 00 00 
  8004212dc5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212dca:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004212dd1:	00 00 00 
  8004212dd4:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004212dd7:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004212ddc:	75 35                	jne    8004212e13 <dwarf_offdie+0x8c>
  8004212dde:	48 b9 7c 14 22 04 80 	movabs $0x800422147c,%rcx
  8004212de5:	00 00 00 
  8004212de8:	48 ba ea 12 22 04 80 	movabs $0x80042212ea,%rdx
  8004212def:	00 00 00 
  8004212df2:	be c5 02 00 00       	mov    $0x2c5,%esi
  8004212df7:	48 bf ff 12 22 04 80 	movabs $0x80042212ff,%rdi
  8004212dfe:	00 00 00 
  8004212e01:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212e06:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004212e0d:	00 00 00 
  8004212e10:	41 ff d0             	callq  *%r8

	/* First search the current CU. */
	if (offset < cu.cu_next_offset) {
  8004212e13:	48 8b 45 30          	mov    0x30(%rbp),%rax
  8004212e17:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004212e1b:	76 45                	jbe    8004212e62 <dwarf_offdie+0xdb>
		ret = dwarf_search_die_within_cu(dbg, cu, offset, ret_die, 0);
  8004212e1d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004212e21:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8004212e25:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e29:	48 83 ec 08          	sub    $0x8,%rsp
  8004212e2d:	ff 75 40             	pushq  0x40(%rbp)
  8004212e30:	ff 75 38             	pushq  0x38(%rbp)
  8004212e33:	ff 75 30             	pushq  0x30(%rbp)
  8004212e36:	ff 75 28             	pushq  0x28(%rbp)
  8004212e39:	ff 75 20             	pushq  0x20(%rbp)
  8004212e3c:	ff 75 18             	pushq  0x18(%rbp)
  8004212e3f:	ff 75 10             	pushq  0x10(%rbp)
  8004212e42:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004212e47:	48 89 c7             	mov    %rax,%rdi
  8004212e4a:	48 b8 ab 2a 21 04 80 	movabs $0x8004212aab,%rax
  8004212e51:	00 00 00 
  8004212e54:	ff d0                	callq  *%rax
  8004212e56:	48 83 c4 40          	add    $0x40,%rsp
  8004212e5a:	89 45 fc             	mov    %eax,-0x4(%rbp)
		return ret;
  8004212e5d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004212e60:	eb 05                	jmp    8004212e67 <dwarf_offdie+0xe0>
	}

	/*TODO: Search other CU*/
	return DW_DLV_OK;
  8004212e62:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212e67:	c9                   	leaveq 
  8004212e68:	c3                   	retq   

0000008004212e69 <_dwarf_attr_find>:

Dwarf_Attribute*
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
  8004212e69:	55                   	push   %rbp
  8004212e6a:	48 89 e5             	mov    %rsp,%rbp
  8004212e6d:	48 83 ec 20          	sub    $0x20,%rsp
  8004212e71:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004212e75:	89 f0                	mov    %esi,%eax
  8004212e77:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Attribute *myat = NULL;
  8004212e7b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004212e82:	00 
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  8004212e83:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004212e8a:	eb 57                	jmp    8004212ee3 <_dwarf_attr_find+0x7a>
	{
		if (die->die_attr[i].at_attrib == attr)
  8004212e8c:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212e90:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004212e93:	48 63 d0             	movslq %eax,%rdx
  8004212e96:	48 89 d0             	mov    %rdx,%rax
  8004212e99:	48 01 c0             	add    %rax,%rax
  8004212e9c:	48 01 d0             	add    %rdx,%rax
  8004212e9f:	48 c1 e0 05          	shl    $0x5,%rax
  8004212ea3:	48 01 c8             	add    %rcx,%rax
  8004212ea6:	48 05 80 03 00 00    	add    $0x380,%rax
  8004212eac:	48 8b 10             	mov    (%rax),%rdx
  8004212eaf:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  8004212eb3:	48 39 c2             	cmp    %rax,%rdx
  8004212eb6:	75 27                	jne    8004212edf <_dwarf_attr_find+0x76>
		{
			myat = &(die->die_attr[i]);
  8004212eb8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004212ebb:	48 63 d0             	movslq %eax,%rdx
  8004212ebe:	48 89 d0             	mov    %rdx,%rax
  8004212ec1:	48 01 c0             	add    %rax,%rax
  8004212ec4:	48 01 d0             	add    %rdx,%rax
  8004212ec7:	48 c1 e0 05          	shl    $0x5,%rax
  8004212ecb:	48 8d 90 70 03 00 00 	lea    0x370(%rax),%rdx
  8004212ed2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ed6:	48 01 d0             	add    %rdx,%rax
  8004212ed9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  8004212edd:	eb 17                	jmp    8004212ef6 <_dwarf_attr_find+0x8d>
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
	Dwarf_Attribute *myat = NULL;
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  8004212edf:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004212ee3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ee7:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004212eee:	0f b6 c0             	movzbl %al,%eax
  8004212ef1:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8004212ef4:	7f 96                	jg     8004212e8c <_dwarf_attr_find+0x23>
			myat = &(die->die_attr[i]);
			break;
		}
	}

	return myat;
  8004212ef6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004212efa:	c9                   	leaveq 
  8004212efb:	c3                   	retq   

0000008004212efc <dwarf_siblingof>:

//Return 0 on success
int
dwarf_siblingof(Dwarf_Debug dbg, Dwarf_Die *die, Dwarf_Die *ret_die,
		Dwarf_CU *cu)
{
  8004212efc:	55                   	push   %rbp
  8004212efd:	48 89 e5             	mov    %rsp,%rbp
  8004212f00:	48 83 ec 40          	sub    $0x40,%rsp
  8004212f04:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004212f08:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004212f0c:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004212f10:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	Dwarf_Attribute *at;
	uint64_t offset;
	int ret, search_sibling;

	assert(dbg);
  8004212f14:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004212f19:	75 35                	jne    8004212f50 <dwarf_siblingof+0x54>
  8004212f1b:	48 b9 78 14 22 04 80 	movabs $0x8004221478,%rcx
  8004212f22:	00 00 00 
  8004212f25:	48 ba ea 12 22 04 80 	movabs $0x80042212ea,%rdx
  8004212f2c:	00 00 00 
  8004212f2f:	be ec 02 00 00       	mov    $0x2ec,%esi
  8004212f34:	48 bf ff 12 22 04 80 	movabs $0x80042212ff,%rdi
  8004212f3b:	00 00 00 
  8004212f3e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212f43:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004212f4a:	00 00 00 
  8004212f4d:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004212f50:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004212f55:	75 35                	jne    8004212f8c <dwarf_siblingof+0x90>
  8004212f57:	48 b9 7c 14 22 04 80 	movabs $0x800422147c,%rcx
  8004212f5e:	00 00 00 
  8004212f61:	48 ba ea 12 22 04 80 	movabs $0x80042212ea,%rdx
  8004212f68:	00 00 00 
  8004212f6b:	be ed 02 00 00       	mov    $0x2ed,%esi
  8004212f70:	48 bf ff 12 22 04 80 	movabs $0x80042212ff,%rdi
  8004212f77:	00 00 00 
  8004212f7a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212f7f:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004212f86:	00 00 00 
  8004212f89:	41 ff d0             	callq  *%r8
	assert(cu);
  8004212f8c:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004212f91:	75 35                	jne    8004212fc8 <dwarf_siblingof+0xcc>
  8004212f93:	48 b9 84 14 22 04 80 	movabs $0x8004221484,%rcx
  8004212f9a:	00 00 00 
  8004212f9d:	48 ba ea 12 22 04 80 	movabs $0x80042212ea,%rdx
  8004212fa4:	00 00 00 
  8004212fa7:	be ee 02 00 00       	mov    $0x2ee,%esi
  8004212fac:	48 bf ff 12 22 04 80 	movabs $0x80042212ff,%rdi
  8004212fb3:	00 00 00 
  8004212fb6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212fbb:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004212fc2:	00 00 00 
  8004212fc5:	41 ff d0             	callq  *%r8

	/* Application requests the first DIE in this CU. */
	if (die == NULL)
  8004212fc8:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004212fcd:	75 44                	jne    8004213013 <dwarf_siblingof+0x117>
		return (dwarf_offdie(dbg, cu->cu_die_offset, ret_die, *cu));
  8004212fcf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212fd3:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004212fd7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212fdb:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004212fdf:	48 83 ec 08          	sub    $0x8,%rsp
  8004212fe3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212fe7:	ff 70 30             	pushq  0x30(%rax)
  8004212fea:	ff 70 28             	pushq  0x28(%rax)
  8004212fed:	ff 70 20             	pushq  0x20(%rax)
  8004212ff0:	ff 70 18             	pushq  0x18(%rax)
  8004212ff3:	ff 70 10             	pushq  0x10(%rax)
  8004212ff6:	ff 70 08             	pushq  0x8(%rax)
  8004212ff9:	ff 30                	pushq  (%rax)
  8004212ffb:	48 89 cf             	mov    %rcx,%rdi
  8004212ffe:	48 b8 87 2d 21 04 80 	movabs $0x8004212d87,%rax
  8004213005:	00 00 00 
  8004213008:	ff d0                	callq  *%rax
  800421300a:	48 83 c4 40          	add    $0x40,%rsp
  800421300e:	e9 e9 00 00 00       	jmpq   80042130fc <dwarf_siblingof+0x200>

	/*
	 * If the DIE doesn't have any children, its sibling sits next
	 * right to it.
	 */
	search_sibling = 0;
  8004213013:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	if (die->die_ab.ab_children == DW_CHILDREN_no)
  800421301a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421301e:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004213022:	84 c0                	test   %al,%al
  8004213024:	75 0e                	jne    8004213034 <dwarf_siblingof+0x138>
		offset = die->die_next_off;
  8004213026:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421302a:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421302e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004213032:	eb 6b                	jmp    800421309f <dwarf_siblingof+0x1a3>
	else {
		/*
		 * Look for DW_AT_sibling attribute for the offset of
		 * its sibling.
		 */
		if ((at = _dwarf_attr_find(die, DW_AT_sibling)) != NULL) {
  8004213034:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213038:	be 01 00 00 00       	mov    $0x1,%esi
  800421303d:	48 89 c7             	mov    %rax,%rdi
  8004213040:	48 b8 69 2e 21 04 80 	movabs $0x8004212e69,%rax
  8004213047:	00 00 00 
  800421304a:	ff d0                	callq  *%rax
  800421304c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004213050:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004213055:	74 35                	je     800421308c <dwarf_siblingof+0x190>
			if (at->at_form != DW_FORM_ref_addr)
  8004213057:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421305b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421305f:	48 83 f8 10          	cmp    $0x10,%rax
  8004213063:	74 19                	je     800421307e <dwarf_siblingof+0x182>
				offset = at->u[0].u64 + cu->cu_offset;
  8004213065:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213069:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800421306d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213071:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004213075:	48 01 d0             	add    %rdx,%rax
  8004213078:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421307c:	eb 21                	jmp    800421309f <dwarf_siblingof+0x1a3>
			else
				offset = at->u[0].u64;
  800421307e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213082:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213086:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421308a:	eb 13                	jmp    800421309f <dwarf_siblingof+0x1a3>
		} else {
			offset = die->die_next_off;
  800421308c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213090:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213094:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			search_sibling = 1;
  8004213098:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
		}
	}

	ret = dwarf_search_die_within_cu(dbg, *cu, offset, ret_die, search_sibling);
  800421309f:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80042130a2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042130a6:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  80042130aa:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  80042130ae:	48 83 ec 08          	sub    $0x8,%rsp
  80042130b2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042130b6:	ff 70 30             	pushq  0x30(%rax)
  80042130b9:	ff 70 28             	pushq  0x28(%rax)
  80042130bc:	ff 70 20             	pushq  0x20(%rax)
  80042130bf:	ff 70 18             	pushq  0x18(%rax)
  80042130c2:	ff 70 10             	pushq  0x10(%rax)
  80042130c5:	ff 70 08             	pushq  0x8(%rax)
  80042130c8:	ff 30                	pushq  (%rax)
  80042130ca:	48 b8 ab 2a 21 04 80 	movabs $0x8004212aab,%rax
  80042130d1:	00 00 00 
  80042130d4:	ff d0                	callq  *%rax
  80042130d6:	48 83 c4 40          	add    $0x40,%rsp
  80042130da:	89 45 e4             	mov    %eax,-0x1c(%rbp)


	if (ret == DW_DLE_NO_ENTRY) {
  80042130dd:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  80042130e1:	75 07                	jne    80042130ea <dwarf_siblingof+0x1ee>
		return (DW_DLV_NO_ENTRY);
  80042130e3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042130e8:	eb 12                	jmp    80042130fc <dwarf_siblingof+0x200>
	} else if (ret != DW_DLE_NONE)
  80042130ea:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042130ee:	74 07                	je     80042130f7 <dwarf_siblingof+0x1fb>
		return (DW_DLV_ERROR);
  80042130f0:	b8 01 00 00 00       	mov    $0x1,%eax
  80042130f5:	eb 05                	jmp    80042130fc <dwarf_siblingof+0x200>


	return (DW_DLV_OK);
  80042130f7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042130fc:	c9                   	leaveq 
  80042130fd:	c3                   	retq   

00000080042130fe <dwarf_child>:

int
dwarf_child(Dwarf_Debug dbg, Dwarf_CU *cu, Dwarf_Die *die, Dwarf_Die *ret_die)
{
  80042130fe:	55                   	push   %rbp
  80042130ff:	48 89 e5             	mov    %rsp,%rbp
  8004213102:	48 83 ec 30          	sub    $0x30,%rsp
  8004213106:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421310a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421310e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004213112:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	int ret;

	assert(die);
  8004213116:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421311b:	75 35                	jne    8004213152 <dwarf_child+0x54>
  800421311d:	48 b9 87 14 22 04 80 	movabs $0x8004221487,%rcx
  8004213124:	00 00 00 
  8004213127:	48 ba ea 12 22 04 80 	movabs $0x80042212ea,%rdx
  800421312e:	00 00 00 
  8004213131:	be 1c 03 00 00       	mov    $0x31c,%esi
  8004213136:	48 bf ff 12 22 04 80 	movabs $0x80042212ff,%rdi
  800421313d:	00 00 00 
  8004213140:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213145:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421314c:	00 00 00 
  800421314f:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004213152:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004213157:	75 35                	jne    800421318e <dwarf_child+0x90>
  8004213159:	48 b9 7c 14 22 04 80 	movabs $0x800422147c,%rcx
  8004213160:	00 00 00 
  8004213163:	48 ba ea 12 22 04 80 	movabs $0x80042212ea,%rdx
  800421316a:	00 00 00 
  800421316d:	be 1d 03 00 00       	mov    $0x31d,%esi
  8004213172:	48 bf ff 12 22 04 80 	movabs $0x80042212ff,%rdi
  8004213179:	00 00 00 
  800421317c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213181:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004213188:	00 00 00 
  800421318b:	41 ff d0             	callq  *%r8
	assert(dbg);
  800421318e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004213193:	75 35                	jne    80042131ca <dwarf_child+0xcc>
  8004213195:	48 b9 78 14 22 04 80 	movabs $0x8004221478,%rcx
  800421319c:	00 00 00 
  800421319f:	48 ba ea 12 22 04 80 	movabs $0x80042212ea,%rdx
  80042131a6:	00 00 00 
  80042131a9:	be 1e 03 00 00       	mov    $0x31e,%esi
  80042131ae:	48 bf ff 12 22 04 80 	movabs $0x80042212ff,%rdi
  80042131b5:	00 00 00 
  80042131b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042131bd:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042131c4:	00 00 00 
  80042131c7:	41 ff d0             	callq  *%r8
	assert(cu);
  80042131ca:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042131cf:	75 35                	jne    8004213206 <dwarf_child+0x108>
  80042131d1:	48 b9 84 14 22 04 80 	movabs $0x8004221484,%rcx
  80042131d8:	00 00 00 
  80042131db:	48 ba ea 12 22 04 80 	movabs $0x80042212ea,%rdx
  80042131e2:	00 00 00 
  80042131e5:	be 1f 03 00 00       	mov    $0x31f,%esi
  80042131ea:	48 bf ff 12 22 04 80 	movabs $0x80042212ff,%rdi
  80042131f1:	00 00 00 
  80042131f4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042131f9:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004213200:	00 00 00 
  8004213203:	41 ff d0             	callq  *%r8

	if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004213206:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421320a:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  800421320e:	84 c0                	test   %al,%al
  8004213210:	75 07                	jne    8004213219 <dwarf_child+0x11b>
		return (DW_DLE_NO_ENTRY);
  8004213212:	b8 04 00 00 00       	mov    $0x4,%eax
  8004213217:	eb 63                	jmp    800421327c <dwarf_child+0x17e>

	ret = dwarf_search_die_within_cu(dbg, *cu, die->die_next_off, ret_die, 0);
  8004213219:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421321d:	48 8b 70 08          	mov    0x8(%rax),%rsi
  8004213221:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213225:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  8004213229:	48 83 ec 08          	sub    $0x8,%rsp
  800421322d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213231:	ff 70 30             	pushq  0x30(%rax)
  8004213234:	ff 70 28             	pushq  0x28(%rax)
  8004213237:	ff 70 20             	pushq  0x20(%rax)
  800421323a:	ff 70 18             	pushq  0x18(%rax)
  800421323d:	ff 70 10             	pushq  0x10(%rax)
  8004213240:	ff 70 08             	pushq  0x8(%rax)
  8004213243:	ff 30                	pushq  (%rax)
  8004213245:	b9 00 00 00 00       	mov    $0x0,%ecx
  800421324a:	48 b8 ab 2a 21 04 80 	movabs $0x8004212aab,%rax
  8004213251:	00 00 00 
  8004213254:	ff d0                	callq  *%rax
  8004213256:	48 83 c4 40          	add    $0x40,%rsp
  800421325a:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if (ret == DW_DLE_NO_ENTRY) {
  800421325d:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004213261:	75 07                	jne    800421326a <dwarf_child+0x16c>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  8004213263:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213268:	eb 12                	jmp    800421327c <dwarf_child+0x17e>
	} else if (ret != DW_DLE_NONE)
  800421326a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800421326e:	74 07                	je     8004213277 <dwarf_child+0x179>
		return (DW_DLV_ERROR);
  8004213270:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213275:	eb 05                	jmp    800421327c <dwarf_child+0x17e>

	return (DW_DLV_OK);
  8004213277:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421327c:	c9                   	leaveq 
  800421327d:	c3                   	retq   

000000800421327e <_dwarf_find_section_enhanced>:


int  _dwarf_find_section_enhanced(Dwarf_Section *ds)
{
  800421327e:	55                   	push   %rbp
  800421327f:	48 89 e5             	mov    %rsp,%rbp
  8004213282:	48 83 ec 20          	sub    $0x20,%rsp
  8004213286:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *secthdr = _dwarf_find_section(ds->ds_name);
  800421328a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421328e:	48 8b 00             	mov    (%rax),%rax
  8004213291:	48 89 c7             	mov    %rax,%rdi
  8004213294:	48 b8 9c 65 21 04 80 	movabs $0x800421659c,%rax
  800421329b:	00 00 00 
  800421329e:	ff d0                	callq  *%rax
  80042132a0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	ds->ds_data = secthdr->ds_data;//(Dwarf_Small*)((uint8_t *)elf_base_ptr + secthdr->sh_offset);
  80042132a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042132a8:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042132ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042132b0:	48 89 50 08          	mov    %rdx,0x8(%rax)
	ds->ds_addr = secthdr->ds_addr;
  80042132b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042132b8:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042132bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042132c0:	48 89 50 10          	mov    %rdx,0x10(%rax)
	ds->ds_size = secthdr->ds_size;
  80042132c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042132c8:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042132cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042132d0:	48 89 50 18          	mov    %rdx,0x18(%rax)
	return 0;
  80042132d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042132d9:	c9                   	leaveq 
  80042132da:	c3                   	retq   

00000080042132db <_dwarf_frame_params_init>:

extern int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

void
_dwarf_frame_params_init(Dwarf_Debug dbg)
{
  80042132db:	55                   	push   %rbp
  80042132dc:	48 89 e5             	mov    %rsp,%rbp
  80042132df:	48 83 ec 08          	sub    $0x8,%rsp
  80042132e3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	/* Initialise call frame related parameters. */
	dbg->dbg_frame_rule_table_size = DW_FRAME_LAST_REG_NUM;
  80042132e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042132eb:	66 c7 40 48 42 00    	movw   $0x42,0x48(%rax)
	dbg->dbg_frame_rule_initial_value = DW_FRAME_REG_INITIAL_VALUE;
  80042132f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042132f5:	66 c7 40 4a 0b 04    	movw   $0x40b,0x4a(%rax)
	dbg->dbg_frame_cfa_value = DW_FRAME_CFA_COL3;
  80042132fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042132ff:	66 c7 40 4c 9c 05    	movw   $0x59c,0x4c(%rax)
	dbg->dbg_frame_same_value = DW_FRAME_SAME_VAL;
  8004213305:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213309:	66 c7 40 4e 0b 04    	movw   $0x40b,0x4e(%rax)
	dbg->dbg_frame_undefined_value = DW_FRAME_UNDEFINED_VAL;
  800421330f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213313:	66 c7 40 50 0a 04    	movw   $0x40a,0x50(%rax)
}
  8004213319:	90                   	nop
  800421331a:	c9                   	leaveq 
  800421331b:	c3                   	retq   

000000800421331c <dwarf_get_fde_at_pc>:

int
dwarf_get_fde_at_pc(Dwarf_Debug dbg, Dwarf_Addr pc,
		    struct _Dwarf_Fde *ret_fde, Dwarf_Cie cie,
		    Dwarf_Error *error)
{
  800421331c:	55                   	push   %rbp
  800421331d:	48 89 e5             	mov    %rsp,%rbp
  8004213320:	48 83 ec 40          	sub    $0x40,%rsp
  8004213324:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004213328:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421332c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004213330:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004213334:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
	Dwarf_Fde fde = ret_fde;
  8004213338:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421333c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(fde, 0, sizeof(struct _Dwarf_Fde));
  8004213340:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213344:	ba 80 00 00 00       	mov    $0x80,%edx
  8004213349:	be 00 00 00 00       	mov    $0x0,%esi
  800421334e:	48 89 c7             	mov    %rax,%rdi
  8004213351:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  8004213358:	00 00 00 
  800421335b:	ff d0                	callq  *%rax
	fde->fde_cie = cie;
  800421335d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213361:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213365:	48 89 50 08          	mov    %rdx,0x8(%rax)
	
	if (ret_fde == NULL)
  8004213369:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421336e:	75 60                	jne    80042133d0 <dwarf_get_fde_at_pc+0xb4>
		return (DW_DLV_ERROR);
  8004213370:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213375:	eb 73                	jmp    80042133ea <dwarf_get_fde_at_pc+0xce>

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
  8004213377:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800421337b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421337f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213383:	be 01 00 00 00       	mov    $0x1,%esi
  8004213388:	48 89 c7             	mov    %rax,%rdi
  800421338b:	48 b8 8c 55 21 04 80 	movabs $0x800421558c,%rax
  8004213392:	00 00 00 
  8004213395:	ff d0                	callq  *%rax
  8004213397:	85 c0                	test   %eax,%eax
  8004213399:	79 07                	jns    80042133a2 <dwarf_get_fde_at_pc+0x86>
		{
			return DW_DLV_NO_ENTRY;
  800421339b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042133a0:	eb 48                	jmp    80042133ea <dwarf_get_fde_at_pc+0xce>
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  80042133a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042133a6:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042133aa:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042133ae:	77 20                	ja     80042133d0 <dwarf_get_fde_at_pc+0xb4>
  80042133b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042133b4:	48 8b 50 30          	mov    0x30(%rax),%rdx
		    fde->fde_adrange)
  80042133b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042133bc:	48 8b 40 38          	mov    0x38(%rax),%rax
	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
		{
			return DW_DLV_NO_ENTRY;
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  80042133c0:	48 01 d0             	add    %rdx,%rax
  80042133c3:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042133c7:	76 07                	jbe    80042133d0 <dwarf_get_fde_at_pc+0xb4>
		    fde->fde_adrange)
			return (DW_DLV_OK);
  80042133c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042133ce:	eb 1a                	jmp    80042133ea <dwarf_get_fde_at_pc+0xce>
	fde->fde_cie = cie;
	
	if (ret_fde == NULL)
		return (DW_DLV_ERROR);

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  80042133d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042133d4:	48 8b 50 30          	mov    0x30(%rax),%rdx
  80042133d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042133dc:	48 8b 40 40          	mov    0x40(%rax),%rax
  80042133e0:	48 39 c2             	cmp    %rax,%rdx
  80042133e3:	72 92                	jb     8004213377 <dwarf_get_fde_at_pc+0x5b>
		    fde->fde_adrange)
			return (DW_DLV_OK);
	}

	DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
	return (DW_DLV_NO_ENTRY);
  80042133e5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80042133ea:	c9                   	leaveq 
  80042133eb:	c3                   	retq   

00000080042133ec <_dwarf_frame_regtable_copy>:

int
_dwarf_frame_regtable_copy(Dwarf_Debug dbg, Dwarf_Regtable3 **dest,
			   Dwarf_Regtable3 *src, Dwarf_Error *error)
{
  80042133ec:	55                   	push   %rbp
  80042133ed:	48 89 e5             	mov    %rsp,%rbp
  80042133f0:	48 83 ec 30          	sub    $0x30,%rsp
  80042133f4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042133f8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042133fc:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004213400:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	int i;

	assert(dest != NULL);
  8004213404:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004213409:	75 35                	jne    8004213440 <_dwarf_frame_regtable_copy+0x54>
  800421340b:	48 b9 9a 14 22 04 80 	movabs $0x800422149a,%rcx
  8004213412:	00 00 00 
  8004213415:	48 ba a7 14 22 04 80 	movabs $0x80042214a7,%rdx
  800421341c:	00 00 00 
  800421341f:	be 57 00 00 00       	mov    $0x57,%esi
  8004213424:	48 bf bc 14 22 04 80 	movabs $0x80042214bc,%rdi
  800421342b:	00 00 00 
  800421342e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213433:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421343a:	00 00 00 
  800421343d:	41 ff d0             	callq  *%r8
	assert(src != NULL);
  8004213440:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004213445:	75 35                	jne    800421347c <_dwarf_frame_regtable_copy+0x90>
  8004213447:	48 b9 d2 14 22 04 80 	movabs $0x80042214d2,%rcx
  800421344e:	00 00 00 
  8004213451:	48 ba a7 14 22 04 80 	movabs $0x80042214a7,%rdx
  8004213458:	00 00 00 
  800421345b:	be 58 00 00 00       	mov    $0x58,%esi
  8004213460:	48 bf bc 14 22 04 80 	movabs $0x80042214bc,%rdi
  8004213467:	00 00 00 
  800421346a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421346f:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004213476:	00 00 00 
  8004213479:	41 ff d0             	callq  *%r8

	if (*dest == NULL) {
  800421347c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213480:	48 8b 00             	mov    (%rax),%rax
  8004213483:	48 85 c0             	test   %rax,%rax
  8004213486:	75 39                	jne    80042134c1 <_dwarf_frame_regtable_copy+0xd5>
		*dest = &global_rt_table_shadow;
  8004213488:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421348c:	48 bf e0 e6 4d 04 80 	movabs $0x80044de6e0,%rdi
  8004213493:	00 00 00 
  8004213496:	48 89 38             	mov    %rdi,(%rax)
		(*dest)->rt3_reg_table_size = src->rt3_reg_table_size;
  8004213499:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421349d:	48 8b 00             	mov    (%rax),%rax
  80042134a0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042134a4:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
  80042134a8:	66 89 50 18          	mov    %dx,0x18(%rax)
		(*dest)->rt3_rules = global_rules_shadow;
  80042134ac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042134b0:	48 8b 00             	mov    (%rax),%rax
  80042134b3:	48 be 00 c8 6d 04 80 	movabs $0x80046dc800,%rsi
  80042134ba:	00 00 00 
  80042134bd:	48 89 70 20          	mov    %rsi,0x20(%rax)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
  80042134c1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042134c5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042134c9:	48 8b 12             	mov    (%rdx),%rdx
  80042134cc:	48 89 d1             	mov    %rdx,%rcx
  80042134cf:	ba 18 00 00 00       	mov    $0x18,%edx
  80042134d4:	48 89 c6             	mov    %rax,%rsi
  80042134d7:	48 89 cf             	mov    %rcx,%rdi
  80042134da:	48 b8 2d 11 21 04 80 	movabs $0x800421112d,%rax
  80042134e1:	00 00 00 
  80042134e4:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  80042134e6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042134ed:	eb 5a                	jmp    8004213549 <_dwarf_frame_regtable_copy+0x15d>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
  80042134ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042134f3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042134f7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042134fa:	48 63 d0             	movslq %eax,%rdx
  80042134fd:	48 89 d0             	mov    %rdx,%rax
  8004213500:	48 01 c0             	add    %rax,%rax
  8004213503:	48 01 d0             	add    %rdx,%rax
  8004213506:	48 c1 e0 03          	shl    $0x3,%rax
  800421350a:	48 01 c1             	add    %rax,%rcx
  800421350d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213511:	48 8b 00             	mov    (%rax),%rax
  8004213514:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004213518:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421351b:	48 63 d0             	movslq %eax,%rdx
  800421351e:	48 89 d0             	mov    %rdx,%rax
  8004213521:	48 01 c0             	add    %rax,%rax
  8004213524:	48 01 d0             	add    %rdx,%rax
  8004213527:	48 c1 e0 03          	shl    $0x3,%rax
  800421352b:	48 01 f0             	add    %rsi,%rax
  800421352e:	ba 18 00 00 00       	mov    $0x18,%edx
  8004213533:	48 89 ce             	mov    %rcx,%rsi
  8004213536:	48 89 c7             	mov    %rax,%rdi
  8004213539:	48 b8 2d 11 21 04 80 	movabs $0x800421112d,%rax
  8004213540:	00 00 00 
  8004213543:	ff d0                	callq  *%rax

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
  8004213545:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004213549:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421354d:	48 8b 00             	mov    (%rax),%rax
  8004213550:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213554:	0f b7 c0             	movzwl %ax,%eax
  8004213557:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800421355a:	7e 44                	jle    80042135a0 <_dwarf_frame_regtable_copy+0x1b4>
		     i < src->rt3_reg_table_size; i++)
  800421355c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213560:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213564:	0f b7 c0             	movzwl %ax,%eax
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004213567:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800421356a:	7f 83                	jg     80042134ef <_dwarf_frame_regtable_copy+0x103>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  800421356c:	eb 32                	jmp    80042135a0 <_dwarf_frame_regtable_copy+0x1b4>
		(*dest)->rt3_rules[i].dw_regnum =
  800421356e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213572:	48 8b 00             	mov    (%rax),%rax
  8004213575:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213579:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421357c:	48 63 d0             	movslq %eax,%rdx
  800421357f:	48 89 d0             	mov    %rdx,%rax
  8004213582:	48 01 c0             	add    %rax,%rax
  8004213585:	48 01 d0             	add    %rdx,%rax
  8004213588:	48 c1 e0 03          	shl    $0x3,%rax
  800421358c:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
			dbg->dbg_frame_undefined_value;
  8004213590:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213594:	0f b7 40 50          	movzwl 0x50(%rax),%eax
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
		(*dest)->rt3_rules[i].dw_regnum =
  8004213598:	66 89 42 02          	mov    %ax,0x2(%rdx)
	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  800421359c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042135a0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042135a4:	48 8b 00             	mov    (%rax),%rax
  80042135a7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042135ab:	0f b7 c0             	movzwl %ax,%eax
  80042135ae:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042135b1:	7f bb                	jg     800421356e <_dwarf_frame_regtable_copy+0x182>
		(*dest)->rt3_rules[i].dw_regnum =
			dbg->dbg_frame_undefined_value;

	return (DW_DLE_NONE);
  80042135b3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042135b8:	c9                   	leaveq 
  80042135b9:	c3                   	retq   

00000080042135ba <_dwarf_frame_run_inst>:

static int
_dwarf_frame_run_inst(Dwarf_Debug dbg, Dwarf_Regtable3 *rt, uint8_t *insts,
		      Dwarf_Unsigned len, Dwarf_Unsigned caf, Dwarf_Signed daf, Dwarf_Addr pc,
		      Dwarf_Addr pc_req, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  80042135ba:	55                   	push   %rbp
  80042135bb:	48 89 e5             	mov    %rsp,%rbp
  80042135be:	53                   	push   %rbx
  80042135bf:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  80042135c6:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  80042135ca:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  80042135ce:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  80042135d2:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  80042135d6:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  80042135dd:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
			ret = DW_DLE_DF_REG_NUM_TOO_HIGH;               \
			goto program_done;                              \
		}                                                       \
	} while(0)

	ret = DW_DLE_NONE;
  80042135e4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	init_rt = saved_rt = NULL;
  80042135eb:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  80042135f2:	00 
  80042135f3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042135f7:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	*row_pc = pc;
  80042135fb:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042135ff:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213603:	48 89 10             	mov    %rdx,(%rax)

	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
  8004213606:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800421360a:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800421360e:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
  8004213612:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213616:	48 89 c7             	mov    %rax,%rdi
  8004213619:	48 b8 ec 33 21 04 80 	movabs $0x80042133ec,%rax
  8004213620:	00 00 00 
  8004213623:	ff d0                	callq  *%rax
	p = insts;
  8004213625:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004213629:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	pe = p + len;
  800421362d:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004213631:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213635:	48 01 d0             	add    %rdx,%rax
  8004213638:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	while (p < pe) {
  800421363c:	e9 38 0d 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		if (*p == DW_CFA_nop) {
  8004213641:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213645:	0f b6 00             	movzbl (%rax),%eax
  8004213648:	84 c0                	test   %al,%al
  800421364a:	75 11                	jne    800421365d <_dwarf_frame_run_inst+0xa3>
			p++;
  800421364c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213650:	48 83 c0 01          	add    $0x1,%rax
  8004213654:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			continue;
  8004213658:	e9 1c 0d 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		}

		high2 = *p & 0xc0;
  800421365d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213661:	0f b6 00             	movzbl (%rax),%eax
  8004213664:	83 e0 c0             	and    $0xffffffc0,%eax
  8004213667:	88 45 df             	mov    %al,-0x21(%rbp)
		low6 = *p & 0x3f;
  800421366a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421366e:	0f b6 00             	movzbl (%rax),%eax
  8004213671:	83 e0 3f             	and    $0x3f,%eax
  8004213674:	88 45 de             	mov    %al,-0x22(%rbp)
		p++;
  8004213677:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421367b:	48 83 c0 01          	add    $0x1,%rax
  800421367f:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

		if (high2 > 0) {
  8004213683:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  8004213687:	0f 84 a4 01 00 00    	je     8004213831 <_dwarf_frame_run_inst+0x277>
			switch (high2) {
  800421368d:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004213691:	3d 80 00 00 00       	cmp    $0x80,%eax
  8004213696:	74 37                	je     80042136cf <_dwarf_frame_run_inst+0x115>
  8004213698:	3d c0 00 00 00       	cmp    $0xc0,%eax
  800421369d:	0f 84 03 01 00 00    	je     80042137a6 <_dwarf_frame_run_inst+0x1ec>
  80042136a3:	83 f8 40             	cmp    $0x40,%eax
  80042136a6:	0f 85 73 01 00 00    	jne    800421381f <_dwarf_frame_run_inst+0x265>
			case DW_CFA_advance_loc:
			        pc += low6 * caf;
  80042136ac:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  80042136b0:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042136b7:	ff 
  80042136b8:	48 01 45 10          	add    %rax,0x10(%rbp)
			        if (pc_req < pc)
  80042136bc:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042136c0:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042136c4:	0f 83 61 01 00 00    	jae    800421382b <_dwarf_frame_run_inst+0x271>
			                goto program_done;
  80042136ca:	e9 c4 0c 00 00       	jmpq   8004214393 <_dwarf_frame_run_inst+0xdd9>
			        break;
			case DW_CFA_offset:
			        *row_pc = pc;
  80042136cf:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042136d3:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042136d7:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  80042136da:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042136de:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042136e2:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042136e6:	66 39 c2             	cmp    %ax,%dx
  80042136e9:	72 0c                	jb     80042136f7 <_dwarf_frame_run_inst+0x13d>
  80042136eb:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042136f2:	e9 9c 0c 00 00       	jmpq   8004214393 <_dwarf_frame_run_inst+0xdd9>
			        RL[low6].dw_offset_relevant = 1;
  80042136f7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042136fb:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042136ff:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004213703:	48 89 d0             	mov    %rdx,%rax
  8004213706:	48 01 c0             	add    %rax,%rax
  8004213709:	48 01 d0             	add    %rdx,%rax
  800421370c:	48 c1 e0 03          	shl    $0x3,%rax
  8004213710:	48 01 c8             	add    %rcx,%rax
  8004213713:	c6 00 01             	movb   $0x1,(%rax)
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
  8004213716:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421371a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421371e:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004213722:	48 89 d0             	mov    %rdx,%rax
  8004213725:	48 01 c0             	add    %rax,%rax
  8004213728:	48 01 d0             	add    %rdx,%rax
  800421372b:	48 c1 e0 03          	shl    $0x3,%rax
  800421372f:	48 01 c8             	add    %rcx,%rax
  8004213732:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
  8004213736:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421373a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421373e:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004213742:	48 89 d0             	mov    %rdx,%rax
  8004213745:	48 01 c0             	add    %rax,%rax
  8004213748:	48 01 d0             	add    %rdx,%rax
  800421374b:	48 c1 e0 03          	shl    $0x3,%rax
  800421374f:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213753:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213757:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800421375b:	66 89 42 02          	mov    %ax,0x2(%rdx)
			        RL[low6].dw_offset_or_block_len =
  800421375f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213763:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213767:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421376b:	48 89 d0             	mov    %rdx,%rax
  800421376e:	48 01 c0             	add    %rax,%rax
  8004213771:	48 01 d0             	add    %rdx,%rax
  8004213774:	48 c1 e0 03          	shl    $0x3,%rax
  8004213778:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
					_dwarf_decode_uleb128(&p) * daf;
  800421377c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213780:	48 89 c7             	mov    %rax,%rdi
  8004213783:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  800421378a:	00 00 00 
  800421378d:	ff d0                	callq  *%rax
  800421378f:	48 89 c2             	mov    %rax,%rdx
  8004213792:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004213799:	48 0f af c2          	imul   %rdx,%rax
			        *row_pc = pc;
			        CHECK_TABLE_SIZE(low6);
			        RL[low6].dw_offset_relevant = 1;
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
			        RL[low6].dw_offset_or_block_len =
  800421379d:	48 89 43 08          	mov    %rax,0x8(%rbx)
					_dwarf_decode_uleb128(&p) * daf;
			        break;
  80042137a1:	e9 86 00 00 00       	jmpq   800421382c <_dwarf_frame_run_inst+0x272>
			case DW_CFA_restore:
			        *row_pc = pc;
  80042137a6:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042137aa:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042137ae:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  80042137b1:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042137b5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042137b9:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042137bd:	66 39 c2             	cmp    %ax,%dx
  80042137c0:	72 0c                	jb     80042137ce <_dwarf_frame_run_inst+0x214>
  80042137c2:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042137c9:	e9 c5 0b 00 00       	jmpq   8004214393 <_dwarf_frame_run_inst+0xdd9>
			        memcpy(&RL[low6], &INITRL[low6],
  80042137ce:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042137d2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042137d6:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042137da:	48 89 d0             	mov    %rdx,%rax
  80042137dd:	48 01 c0             	add    %rax,%rax
  80042137e0:	48 01 d0             	add    %rdx,%rax
  80042137e3:	48 c1 e0 03          	shl    $0x3,%rax
  80042137e7:	48 01 c1             	add    %rax,%rcx
  80042137ea:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042137ee:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042137f2:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042137f6:	48 89 d0             	mov    %rdx,%rax
  80042137f9:	48 01 c0             	add    %rax,%rax
  80042137fc:	48 01 d0             	add    %rdx,%rax
  80042137ff:	48 c1 e0 03          	shl    $0x3,%rax
  8004213803:	48 01 f0             	add    %rsi,%rax
  8004213806:	ba 18 00 00 00       	mov    $0x18,%edx
  800421380b:	48 89 ce             	mov    %rcx,%rsi
  800421380e:	48 89 c7             	mov    %rax,%rdi
  8004213811:	48 b8 2d 11 21 04 80 	movabs $0x800421112d,%rax
  8004213818:	00 00 00 
  800421381b:	ff d0                	callq  *%rax
				       sizeof(Dwarf_Regtable_Entry3));
			        break;
  800421381d:	eb 0d                	jmp    800421382c <_dwarf_frame_run_inst+0x272>
			default:
			        DWARF_SET_ERROR(dbg, error,
						DW_DLE_FRAME_INSTR_EXEC_ERROR);
			        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  800421381f:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			        goto program_done;
  8004213826:	e9 68 0b 00 00       	jmpq   8004214393 <_dwarf_frame_run_inst+0xdd9>
			switch (high2) {
			case DW_CFA_advance_loc:
			        pc += low6 * caf;
			        if (pc_req < pc)
			                goto program_done;
			        break;
  800421382b:	90                   	nop
						DW_DLE_FRAME_INSTR_EXEC_ERROR);
			        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
			        goto program_done;
			}

			continue;
  800421382c:	e9 48 0b 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		}

		switch (low6) {
  8004213831:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  8004213835:	83 f8 16             	cmp    $0x16,%eax
  8004213838:	0f 87 32 0b 00 00    	ja     8004214370 <_dwarf_frame_run_inst+0xdb6>
  800421383e:	89 c0                	mov    %eax,%eax
  8004213840:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004213847:	00 
  8004213848:	48 b8 e0 14 22 04 80 	movabs $0x80042214e0,%rax
  800421384f:	00 00 00 
  8004213852:	48 01 d0             	add    %rdx,%rax
  8004213855:	48 8b 00             	mov    (%rax),%rax
  8004213858:	ff e0                	jmpq   *%rax
		case DW_CFA_set_loc:
			pc = dbg->decode(&p, dbg->dbg_pointer_size);
  800421385a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421385e:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004213862:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004213866:	8b 4a 28             	mov    0x28(%rdx),%ecx
  8004213869:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800421386d:	89 ce                	mov    %ecx,%esi
  800421386f:	48 89 d7             	mov    %rdx,%rdi
  8004213872:	ff d0                	callq  *%rax
  8004213874:	48 89 45 10          	mov    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004213878:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800421387c:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004213880:	0f 82 03 0b 00 00    	jb     8004214389 <_dwarf_frame_run_inst+0xdcf>
			        goto program_done;
			break;
  8004213886:	e9 ee 0a 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_advance_loc1:
			pc += dbg->decode(&p, 1) * caf;
  800421388b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421388f:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004213893:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004213897:	be 01 00 00 00       	mov    $0x1,%esi
  800421389c:	48 89 d7             	mov    %rdx,%rdi
  800421389f:	ff d0                	callq  *%rax
  80042138a1:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042138a8:	ff 
  80042138a9:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  80042138ad:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042138b1:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042138b5:	0f 82 d1 0a 00 00    	jb     800421438c <_dwarf_frame_run_inst+0xdd2>
			        goto program_done;
			break;
  80042138bb:	e9 b9 0a 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_advance_loc2:
			pc += dbg->decode(&p, 2) * caf;
  80042138c0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042138c4:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042138c8:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  80042138cc:	be 02 00 00 00       	mov    $0x2,%esi
  80042138d1:	48 89 d7             	mov    %rdx,%rdi
  80042138d4:	ff d0                	callq  *%rax
  80042138d6:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042138dd:	ff 
  80042138de:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  80042138e2:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042138e6:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042138ea:	0f 82 9f 0a 00 00    	jb     800421438f <_dwarf_frame_run_inst+0xdd5>
			        goto program_done;
			break;
  80042138f0:	e9 84 0a 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_advance_loc4:
			pc += dbg->decode(&p, 4) * caf;
  80042138f5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042138f9:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042138fd:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004213901:	be 04 00 00 00       	mov    $0x4,%esi
  8004213906:	48 89 d7             	mov    %rdx,%rdi
  8004213909:	ff d0                	callq  *%rax
  800421390b:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004213912:	ff 
  8004213913:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004213917:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800421391b:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800421391f:	0f 82 6d 0a 00 00    	jb     8004214392 <_dwarf_frame_run_inst+0xdd8>
			        goto program_done;
			break;
  8004213925:	e9 4f 0a 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_offset_extended:
			*row_pc = pc;
  800421392a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421392e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213932:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004213935:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213939:	48 89 c7             	mov    %rax,%rdi
  800421393c:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004213943:	00 00 00 
  8004213946:	ff d0                	callq  *%rax
  8004213948:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  800421394c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213950:	48 89 c7             	mov    %rax,%rdi
  8004213953:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  800421395a:	00 00 00 
  800421395d:	ff d0                	callq  *%rax
  800421395f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004213963:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213967:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421396b:	0f b7 c0             	movzwl %ax,%eax
  800421396e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213972:	77 0c                	ja     8004213980 <_dwarf_frame_run_inst+0x3c6>
  8004213974:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421397b:	e9 13 0a 00 00       	jmpq   8004214393 <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 1;
  8004213980:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213984:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213988:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421398c:	48 89 d0             	mov    %rdx,%rax
  800421398f:	48 01 c0             	add    %rax,%rax
  8004213992:	48 01 d0             	add    %rdx,%rax
  8004213995:	48 c1 e0 03          	shl    $0x3,%rax
  8004213999:	48 01 c8             	add    %rcx,%rax
  800421399c:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  800421399f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042139a3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042139a7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042139ab:	48 89 d0             	mov    %rdx,%rax
  80042139ae:	48 01 c0             	add    %rax,%rax
  80042139b1:	48 01 d0             	add    %rdx,%rax
  80042139b4:	48 c1 e0 03          	shl    $0x3,%rax
  80042139b8:	48 01 c8             	add    %rcx,%rax
  80042139bb:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  80042139bf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042139c3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042139c7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042139cb:	48 89 d0             	mov    %rdx,%rax
  80042139ce:	48 01 c0             	add    %rax,%rax
  80042139d1:	48 01 d0             	add    %rdx,%rax
  80042139d4:	48 c1 e0 03          	shl    $0x3,%rax
  80042139d8:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042139dc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042139e0:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042139e4:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  80042139e8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042139ec:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042139f0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042139f4:	48 89 d0             	mov    %rdx,%rax
  80042139f7:	48 01 c0             	add    %rax,%rax
  80042139fa:	48 01 d0             	add    %rdx,%rax
  80042139fd:	48 c1 e0 03          	shl    $0x3,%rax
  8004213a01:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213a05:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004213a0c:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004213a11:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004213a15:	e9 5f 09 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_restore_extended:
			*row_pc = pc;
  8004213a1a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213a1e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213a22:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004213a25:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213a29:	48 89 c7             	mov    %rax,%rdi
  8004213a2c:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004213a33:	00 00 00 
  8004213a36:	ff d0                	callq  *%rax
  8004213a38:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004213a3c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213a40:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213a44:	0f b7 c0             	movzwl %ax,%eax
  8004213a47:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213a4b:	77 0c                	ja     8004213a59 <_dwarf_frame_run_inst+0x49f>
  8004213a4d:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213a54:	e9 3a 09 00 00       	jmpq   8004214393 <_dwarf_frame_run_inst+0xdd9>
			memcpy(&RL[reg], &INITRL[reg],
  8004213a59:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213a5d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213a61:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213a65:	48 89 d0             	mov    %rdx,%rax
  8004213a68:	48 01 c0             	add    %rax,%rax
  8004213a6b:	48 01 d0             	add    %rdx,%rax
  8004213a6e:	48 c1 e0 03          	shl    $0x3,%rax
  8004213a72:	48 01 c1             	add    %rax,%rcx
  8004213a75:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213a79:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004213a7d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213a81:	48 89 d0             	mov    %rdx,%rax
  8004213a84:	48 01 c0             	add    %rax,%rax
  8004213a87:	48 01 d0             	add    %rdx,%rax
  8004213a8a:	48 c1 e0 03          	shl    $0x3,%rax
  8004213a8e:	48 01 f0             	add    %rsi,%rax
  8004213a91:	ba 18 00 00 00       	mov    $0x18,%edx
  8004213a96:	48 89 ce             	mov    %rcx,%rsi
  8004213a99:	48 89 c7             	mov    %rax,%rdi
  8004213a9c:	48 b8 2d 11 21 04 80 	movabs $0x800421112d,%rax
  8004213aa3:	00 00 00 
  8004213aa6:	ff d0                	callq  *%rax
			       sizeof(Dwarf_Regtable_Entry3));
			break;
  8004213aa8:	e9 cc 08 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_undefined:
			*row_pc = pc;
  8004213aad:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213ab1:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213ab5:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004213ab8:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213abc:	48 89 c7             	mov    %rax,%rdi
  8004213abf:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004213ac6:	00 00 00 
  8004213ac9:	ff d0                	callq  *%rax
  8004213acb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004213acf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213ad3:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213ad7:	0f b7 c0             	movzwl %ax,%eax
  8004213ada:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213ade:	77 0c                	ja     8004213aec <_dwarf_frame_run_inst+0x532>
  8004213ae0:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213ae7:	e9 a7 08 00 00       	jmpq   8004214393 <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 0;
  8004213aec:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213af0:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213af4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213af8:	48 89 d0             	mov    %rdx,%rax
  8004213afb:	48 01 c0             	add    %rax,%rax
  8004213afe:	48 01 d0             	add    %rdx,%rax
  8004213b01:	48 c1 e0 03          	shl    $0x3,%rax
  8004213b05:	48 01 c8             	add    %rcx,%rax
  8004213b08:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_undefined_value;
  8004213b0b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213b0f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213b13:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213b17:	48 89 d0             	mov    %rdx,%rax
  8004213b1a:	48 01 c0             	add    %rax,%rax
  8004213b1d:	48 01 d0             	add    %rdx,%rax
  8004213b20:	48 c1 e0 03          	shl    $0x3,%rax
  8004213b24:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213b28:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213b2c:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  8004213b30:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  8004213b34:	e9 40 08 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_same_value:
			reg = _dwarf_decode_uleb128(&p);
  8004213b39:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213b3d:	48 89 c7             	mov    %rax,%rdi
  8004213b40:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004213b47:	00 00 00 
  8004213b4a:	ff d0                	callq  *%rax
  8004213b4c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004213b50:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213b54:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213b58:	0f b7 c0             	movzwl %ax,%eax
  8004213b5b:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213b5f:	77 0c                	ja     8004213b6d <_dwarf_frame_run_inst+0x5b3>
  8004213b61:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213b68:	e9 26 08 00 00       	jmpq   8004214393 <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 0;
  8004213b6d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213b71:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213b75:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213b79:	48 89 d0             	mov    %rdx,%rax
  8004213b7c:	48 01 c0             	add    %rax,%rax
  8004213b7f:	48 01 d0             	add    %rdx,%rax
  8004213b82:	48 c1 e0 03          	shl    $0x3,%rax
  8004213b86:	48 01 c8             	add    %rcx,%rax
  8004213b89:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_same_value;
  8004213b8c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213b90:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213b94:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213b98:	48 89 d0             	mov    %rdx,%rax
  8004213b9b:	48 01 c0             	add    %rax,%rax
  8004213b9e:	48 01 d0             	add    %rdx,%rax
  8004213ba1:	48 c1 e0 03          	shl    $0x3,%rax
  8004213ba5:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213ba9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213bad:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  8004213bb1:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  8004213bb5:	e9 bf 07 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_register:
			*row_pc = pc;
  8004213bba:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213bbe:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213bc2:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004213bc5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213bc9:	48 89 c7             	mov    %rax,%rdi
  8004213bcc:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004213bd3:	00 00 00 
  8004213bd6:	ff d0                	callq  *%rax
  8004213bd8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			reg2 = _dwarf_decode_uleb128(&p);
  8004213bdc:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213be0:	48 89 c7             	mov    %rax,%rdi
  8004213be3:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004213bea:	00 00 00 
  8004213bed:	ff d0                	callq  *%rax
  8004213bef:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004213bf3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213bf7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213bfb:	0f b7 c0             	movzwl %ax,%eax
  8004213bfe:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213c02:	77 0c                	ja     8004213c10 <_dwarf_frame_run_inst+0x656>
  8004213c04:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213c0b:	e9 83 07 00 00       	jmpq   8004214393 <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 0;
  8004213c10:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213c14:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213c18:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213c1c:	48 89 d0             	mov    %rdx,%rax
  8004213c1f:	48 01 c0             	add    %rax,%rax
  8004213c22:	48 01 d0             	add    %rdx,%rax
  8004213c25:	48 c1 e0 03          	shl    $0x3,%rax
  8004213c29:	48 01 c8             	add    %rcx,%rax
  8004213c2c:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = reg2;
  8004213c2f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213c33:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213c37:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213c3b:	48 89 d0             	mov    %rdx,%rax
  8004213c3e:	48 01 c0             	add    %rax,%rax
  8004213c41:	48 01 d0             	add    %rdx,%rax
  8004213c44:	48 c1 e0 03          	shl    $0x3,%rax
  8004213c48:	48 01 c8             	add    %rcx,%rax
  8004213c4b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213c4f:	66 89 50 02          	mov    %dx,0x2(%rax)
			break;
  8004213c53:	e9 21 07 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_remember_state:
			_dwarf_frame_regtable_copy(dbg, &saved_rt, rt, error);
  8004213c58:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004213c5c:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004213c60:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  8004213c64:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213c68:	48 89 c7             	mov    %rax,%rdi
  8004213c6b:	48 b8 ec 33 21 04 80 	movabs $0x80042133ec,%rax
  8004213c72:	00 00 00 
  8004213c75:	ff d0                	callq  *%rax
			break;
  8004213c77:	e9 fd 06 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_restore_state:
			*row_pc = pc;
  8004213c7c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213c80:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213c84:	48 89 10             	mov    %rdx,(%rax)
			_dwarf_frame_regtable_copy(dbg, &rt, saved_rt, error);
  8004213c87:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004213c8b:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004213c8f:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  8004213c93:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213c97:	48 89 c7             	mov    %rax,%rdi
  8004213c9a:	48 b8 ec 33 21 04 80 	movabs $0x80042133ec,%rax
  8004213ca1:	00 00 00 
  8004213ca4:	ff d0                	callq  *%rax
			break;
  8004213ca6:	e9 ce 06 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_def_cfa:
			*row_pc = pc;
  8004213cab:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213caf:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213cb3:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004213cb6:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213cba:	48 89 c7             	mov    %rax,%rdi
  8004213cbd:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004213cc4:	00 00 00 
  8004213cc7:	ff d0                	callq  *%rax
  8004213cc9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  8004213ccd:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213cd1:	48 89 c7             	mov    %rax,%rdi
  8004213cd4:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004213cdb:	00 00 00 
  8004213cde:	ff d0                	callq  *%rax
  8004213ce0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  8004213ce4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213ce8:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004213ceb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213cef:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  8004213cf3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213cf7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213cfb:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = uoff;
  8004213cff:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213d03:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213d07:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004213d0b:	e9 69 06 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_def_cfa_register:
			*row_pc = pc;
  8004213d10:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213d14:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213d18:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004213d1b:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213d1f:	48 89 c7             	mov    %rax,%rdi
  8004213d22:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004213d29:	00 00 00 
  8004213d2c:	ff d0                	callq  *%rax
  8004213d2e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CFA.dw_regnum = reg;
  8004213d32:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213d36:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213d3a:	66 89 50 02          	mov    %dx,0x2(%rax)
			 * Note that DW_CFA_def_cfa_register change the CFA
			 * rule register while keep the old offset. So we
			 * should not touch the CFA.dw_offset_relevant flag
			 * here.
			 */
			break;
  8004213d3e:	e9 36 06 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_def_cfa_offset:
			*row_pc = pc;
  8004213d43:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213d47:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213d4b:	48 89 10             	mov    %rdx,(%rax)
			uoff = _dwarf_decode_uleb128(&p);
  8004213d4e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213d52:	48 89 c7             	mov    %rax,%rdi
  8004213d55:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004213d5c:	00 00 00 
  8004213d5f:	ff d0                	callq  *%rax
  8004213d61:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  8004213d65:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213d69:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004213d6c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213d70:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = uoff;
  8004213d74:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213d78:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213d7c:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004213d80:	e9 f4 05 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_def_cfa_expression:
			*row_pc = pc;
  8004213d85:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213d89:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213d8d:	48 89 10             	mov    %rdx,(%rax)
			CFA.dw_offset_relevant = 0;
  8004213d90:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213d94:	c6 00 00             	movb   $0x0,(%rax)
			CFA.dw_value_type = DW_EXPR_EXPRESSION;
  8004213d97:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213d9b:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			CFA.dw_offset_or_block_len = _dwarf_decode_uleb128(&p);
  8004213d9f:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  8004213da3:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213da7:	48 89 c7             	mov    %rax,%rdi
  8004213daa:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004213db1:	00 00 00 
  8004213db4:	ff d0                	callq  *%rax
  8004213db6:	48 89 43 08          	mov    %rax,0x8(%rbx)
			CFA.dw_block_ptr = p;
  8004213dba:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213dbe:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004213dc2:	48 89 50 10          	mov    %rdx,0x10(%rax)
			p += CFA.dw_offset_or_block_len;
  8004213dc6:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004213dca:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213dce:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213dd2:	48 01 d0             	add    %rdx,%rax
  8004213dd5:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  8004213dd9:	e9 9b 05 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_expression:
			*row_pc = pc;
  8004213dde:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213de2:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213de6:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004213de9:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213ded:	48 89 c7             	mov    %rax,%rdi
  8004213df0:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004213df7:	00 00 00 
  8004213dfa:	ff d0                	callq  *%rax
  8004213dfc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004213e00:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213e04:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213e08:	0f b7 c0             	movzwl %ax,%eax
  8004213e0b:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213e0f:	77 0c                	ja     8004213e1d <_dwarf_frame_run_inst+0x863>
  8004213e11:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213e18:	e9 76 05 00 00       	jmpq   8004214393 <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 0;
  8004213e1d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213e21:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213e25:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213e29:	48 89 d0             	mov    %rdx,%rax
  8004213e2c:	48 01 c0             	add    %rax,%rax
  8004213e2f:	48 01 d0             	add    %rdx,%rax
  8004213e32:	48 c1 e0 03          	shl    $0x3,%rax
  8004213e36:	48 01 c8             	add    %rcx,%rax
  8004213e39:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
  8004213e3c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213e40:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213e44:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213e48:	48 89 d0             	mov    %rdx,%rax
  8004213e4b:	48 01 c0             	add    %rax,%rax
  8004213e4e:	48 01 d0             	add    %rdx,%rax
  8004213e51:	48 c1 e0 03          	shl    $0x3,%rax
  8004213e55:	48 01 c8             	add    %rcx,%rax
  8004213e58:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  8004213e5c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213e60:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213e64:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213e68:	48 89 d0             	mov    %rdx,%rax
  8004213e6b:	48 01 c0             	add    %rax,%rax
  8004213e6e:	48 01 d0             	add    %rdx,%rax
  8004213e71:	48 c1 e0 03          	shl    $0x3,%rax
  8004213e75:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004213e79:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213e7d:	48 89 c7             	mov    %rax,%rdi
  8004213e80:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004213e87:	00 00 00 
  8004213e8a:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  8004213e8c:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  8004213e90:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213e94:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213e98:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213e9c:	48 89 d0             	mov    %rdx,%rax
  8004213e9f:	48 01 c0             	add    %rax,%rax
  8004213ea2:	48 01 d0             	add    %rdx,%rax
  8004213ea5:	48 c1 e0 03          	shl    $0x3,%rax
  8004213ea9:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213ead:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213eb1:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  8004213eb5:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004213eb9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213ebd:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004213ec1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213ec5:	48 89 d0             	mov    %rdx,%rax
  8004213ec8:	48 01 c0             	add    %rax,%rax
  8004213ecb:	48 01 d0             	add    %rdx,%rax
  8004213ece:	48 c1 e0 03          	shl    $0x3,%rax
  8004213ed2:	48 01 f0             	add    %rsi,%rax
  8004213ed5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213ed9:	48 01 c8             	add    %rcx,%rax
  8004213edc:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  8004213ee0:	e9 94 04 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_offset_extended_sf:
			*row_pc = pc;
  8004213ee5:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213ee9:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213eed:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004213ef0:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213ef4:	48 89 c7             	mov    %rax,%rdi
  8004213ef7:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004213efe:	00 00 00 
  8004213f01:	ff d0                	callq  *%rax
  8004213f03:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004213f07:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213f0b:	48 89 c7             	mov    %rax,%rdi
  8004213f0e:	48 b8 22 1b 21 04 80 	movabs $0x8004211b22,%rax
  8004213f15:	00 00 00 
  8004213f18:	ff d0                	callq  *%rax
  8004213f1a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004213f1e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213f22:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213f26:	0f b7 c0             	movzwl %ax,%eax
  8004213f29:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213f2d:	77 0c                	ja     8004213f3b <_dwarf_frame_run_inst+0x981>
  8004213f2f:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213f36:	e9 58 04 00 00       	jmpq   8004214393 <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 1;
  8004213f3b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213f3f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213f43:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213f47:	48 89 d0             	mov    %rdx,%rax
  8004213f4a:	48 01 c0             	add    %rax,%rax
  8004213f4d:	48 01 d0             	add    %rdx,%rax
  8004213f50:	48 c1 e0 03          	shl    $0x3,%rax
  8004213f54:	48 01 c8             	add    %rcx,%rax
  8004213f57:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004213f5a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213f5e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213f62:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213f66:	48 89 d0             	mov    %rdx,%rax
  8004213f69:	48 01 c0             	add    %rax,%rax
  8004213f6c:	48 01 d0             	add    %rdx,%rax
  8004213f6f:	48 c1 e0 03          	shl    $0x3,%rax
  8004213f73:	48 01 c8             	add    %rcx,%rax
  8004213f76:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004213f7a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213f7e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213f82:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213f86:	48 89 d0             	mov    %rdx,%rax
  8004213f89:	48 01 c0             	add    %rax,%rax
  8004213f8c:	48 01 d0             	add    %rdx,%rax
  8004213f8f:	48 c1 e0 03          	shl    $0x3,%rax
  8004213f93:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213f97:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213f9b:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004213f9f:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  8004213fa3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213fa7:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213fab:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213faf:	48 89 d0             	mov    %rdx,%rax
  8004213fb2:	48 01 c0             	add    %rax,%rax
  8004213fb5:	48 01 d0             	add    %rdx,%rax
  8004213fb8:	48 c1 e0 03          	shl    $0x3,%rax
  8004213fbc:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213fc0:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004213fc7:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004213fcc:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004213fd0:	e9 a4 03 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_def_cfa_sf:
			*row_pc = pc;
  8004213fd5:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213fd9:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213fdd:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004213fe0:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213fe4:	48 89 c7             	mov    %rax,%rdi
  8004213fe7:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004213fee:	00 00 00 
  8004213ff1:	ff d0                	callq  *%rax
  8004213ff3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004213ff7:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213ffb:	48 89 c7             	mov    %rax,%rdi
  8004213ffe:	48 b8 22 1b 21 04 80 	movabs $0x8004211b22,%rax
  8004214005:	00 00 00 
  8004214008:	ff d0                	callq  *%rax
  800421400a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  800421400e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214012:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004214015:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214019:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  800421401d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214021:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214025:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  8004214029:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421402d:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004214034:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004214039:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  800421403d:	e9 37 03 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_def_cfa_offset_sf:
			*row_pc = pc;
  8004214042:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004214046:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421404a:	48 89 10             	mov    %rdx,(%rax)
			soff = _dwarf_decode_sleb128(&p);
  800421404d:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004214051:	48 89 c7             	mov    %rax,%rdi
  8004214054:	48 b8 22 1b 21 04 80 	movabs $0x8004211b22,%rax
  800421405b:	00 00 00 
  800421405e:	ff d0                	callq  *%rax
  8004214060:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  8004214064:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214068:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  800421406b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421406f:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  8004214073:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214077:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800421407e:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004214083:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004214087:	e9 ed 02 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_val_offset:
			*row_pc = pc;
  800421408c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004214090:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004214094:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004214097:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421409b:	48 89 c7             	mov    %rax,%rdi
  800421409e:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  80042140a5:	00 00 00 
  80042140a8:	ff d0                	callq  *%rax
  80042140aa:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  80042140ae:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042140b2:	48 89 c7             	mov    %rax,%rdi
  80042140b5:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  80042140bc:	00 00 00 
  80042140bf:	ff d0                	callq  *%rax
  80042140c1:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042140c5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042140c9:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042140cd:	0f b7 c0             	movzwl %ax,%eax
  80042140d0:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042140d4:	77 0c                	ja     80042140e2 <_dwarf_frame_run_inst+0xb28>
  80042140d6:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042140dd:	e9 b1 02 00 00       	jmpq   8004214393 <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 1;
  80042140e2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042140e6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042140ea:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042140ee:	48 89 d0             	mov    %rdx,%rax
  80042140f1:	48 01 c0             	add    %rax,%rax
  80042140f4:	48 01 d0             	add    %rdx,%rax
  80042140f7:	48 c1 e0 03          	shl    $0x3,%rax
  80042140fb:	48 01 c8             	add    %rcx,%rax
  80042140fe:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004214101:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214105:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214109:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421410d:	48 89 d0             	mov    %rdx,%rax
  8004214110:	48 01 c0             	add    %rax,%rax
  8004214113:	48 01 d0             	add    %rdx,%rax
  8004214116:	48 c1 e0 03          	shl    $0x3,%rax
  800421411a:	48 01 c8             	add    %rcx,%rax
  800421411d:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004214121:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214125:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214129:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421412d:	48 89 d0             	mov    %rdx,%rax
  8004214130:	48 01 c0             	add    %rax,%rax
  8004214133:	48 01 d0             	add    %rdx,%rax
  8004214136:	48 c1 e0 03          	shl    $0x3,%rax
  800421413a:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421413e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004214142:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004214146:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  800421414a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421414e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214152:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214156:	48 89 d0             	mov    %rdx,%rax
  8004214159:	48 01 c0             	add    %rax,%rax
  800421415c:	48 01 d0             	add    %rdx,%rax
  800421415f:	48 c1 e0 03          	shl    $0x3,%rax
  8004214163:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004214167:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800421416e:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004214173:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004214177:	e9 fd 01 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_val_offset_sf:
			*row_pc = pc;
  800421417c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004214180:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004214184:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004214187:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421418b:	48 89 c7             	mov    %rax,%rdi
  800421418e:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004214195:	00 00 00 
  8004214198:	ff d0                	callq  *%rax
  800421419a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  800421419e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042141a2:	48 89 c7             	mov    %rax,%rdi
  80042141a5:	48 b8 22 1b 21 04 80 	movabs $0x8004211b22,%rax
  80042141ac:	00 00 00 
  80042141af:	ff d0                	callq  *%rax
  80042141b1:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042141b5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042141b9:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042141bd:	0f b7 c0             	movzwl %ax,%eax
  80042141c0:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042141c4:	77 0c                	ja     80042141d2 <_dwarf_frame_run_inst+0xc18>
  80042141c6:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042141cd:	e9 c1 01 00 00       	jmpq   8004214393 <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 1;
  80042141d2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042141d6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042141da:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042141de:	48 89 d0             	mov    %rdx,%rax
  80042141e1:	48 01 c0             	add    %rax,%rax
  80042141e4:	48 01 d0             	add    %rdx,%rax
  80042141e7:	48 c1 e0 03          	shl    $0x3,%rax
  80042141eb:	48 01 c8             	add    %rcx,%rax
  80042141ee:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  80042141f1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042141f5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042141f9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042141fd:	48 89 d0             	mov    %rdx,%rax
  8004214200:	48 01 c0             	add    %rax,%rax
  8004214203:	48 01 d0             	add    %rdx,%rax
  8004214206:	48 c1 e0 03          	shl    $0x3,%rax
  800421420a:	48 01 c8             	add    %rcx,%rax
  800421420d:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004214211:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214215:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214219:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421421d:	48 89 d0             	mov    %rdx,%rax
  8004214220:	48 01 c0             	add    %rax,%rax
  8004214223:	48 01 d0             	add    %rdx,%rax
  8004214226:	48 c1 e0 03          	shl    $0x3,%rax
  800421422a:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421422e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004214232:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004214236:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  800421423a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421423e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214242:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214246:	48 89 d0             	mov    %rdx,%rax
  8004214249:	48 01 c0             	add    %rax,%rax
  800421424c:	48 01 d0             	add    %rdx,%rax
  800421424f:	48 c1 e0 03          	shl    $0x3,%rax
  8004214253:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004214257:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800421425e:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004214263:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004214267:	e9 0d 01 00 00       	jmpq   8004214379 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_val_expression:
			*row_pc = pc;
  800421426c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004214270:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004214274:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004214277:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421427b:	48 89 c7             	mov    %rax,%rdi
  800421427e:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004214285:	00 00 00 
  8004214288:	ff d0                	callq  *%rax
  800421428a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800421428e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214292:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004214296:	0f b7 c0             	movzwl %ax,%eax
  8004214299:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421429d:	77 0c                	ja     80042142ab <_dwarf_frame_run_inst+0xcf1>
  800421429f:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042142a6:	e9 e8 00 00 00       	jmpq   8004214393 <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 0;
  80042142ab:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042142af:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042142b3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042142b7:	48 89 d0             	mov    %rdx,%rax
  80042142ba:	48 01 c0             	add    %rax,%rax
  80042142bd:	48 01 d0             	add    %rdx,%rax
  80042142c0:	48 c1 e0 03          	shl    $0x3,%rax
  80042142c4:	48 01 c8             	add    %rcx,%rax
  80042142c7:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
  80042142ca:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042142ce:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042142d2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042142d6:	48 89 d0             	mov    %rdx,%rax
  80042142d9:	48 01 c0             	add    %rax,%rax
  80042142dc:	48 01 d0             	add    %rdx,%rax
  80042142df:	48 c1 e0 03          	shl    $0x3,%rax
  80042142e3:	48 01 c8             	add    %rcx,%rax
  80042142e6:	c6 40 01 03          	movb   $0x3,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  80042142ea:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042142ee:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042142f2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042142f6:	48 89 d0             	mov    %rdx,%rax
  80042142f9:	48 01 c0             	add    %rax,%rax
  80042142fc:	48 01 d0             	add    %rdx,%rax
  80042142ff:	48 c1 e0 03          	shl    $0x3,%rax
  8004214303:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004214307:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421430b:	48 89 c7             	mov    %rax,%rdi
  800421430e:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004214315:	00 00 00 
  8004214318:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  800421431a:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  800421431e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214322:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214326:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421432a:	48 89 d0             	mov    %rdx,%rax
  800421432d:	48 01 c0             	add    %rax,%rax
  8004214330:	48 01 d0             	add    %rdx,%rax
  8004214333:	48 c1 e0 03          	shl    $0x3,%rax
  8004214337:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421433b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421433f:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  8004214343:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004214347:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421434b:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421434f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214353:	48 89 d0             	mov    %rdx,%rax
  8004214356:	48 01 c0             	add    %rax,%rax
  8004214359:	48 01 d0             	add    %rdx,%rax
  800421435c:	48 c1 e0 03          	shl    $0x3,%rax
  8004214360:	48 01 f0             	add    %rsi,%rax
  8004214363:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214367:	48 01 c8             	add    %rcx,%rax
  800421436a:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  800421436e:	eb 09                	jmp    8004214379 <_dwarf_frame_run_inst+0xdbf>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_INSTR_EXEC_ERROR);
			ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  8004214370:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			goto program_done;
  8004214377:	eb 1a                	jmp    8004214393 <_dwarf_frame_run_inst+0xdd9>
	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
	p = insts;
	pe = p + len;

	while (p < pe) {
  8004214379:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421437d:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004214381:	0f 82 ba f2 ff ff    	jb     8004213641 <_dwarf_frame_run_inst+0x87>
  8004214387:	eb 0a                	jmp    8004214393 <_dwarf_frame_run_inst+0xdd9>

		switch (low6) {
		case DW_CFA_set_loc:
			pc = dbg->decode(&p, dbg->dbg_pointer_size);
			if (pc_req < pc)
			        goto program_done;
  8004214389:	90                   	nop
  800421438a:	eb 07                	jmp    8004214393 <_dwarf_frame_run_inst+0xdd9>
			break;
		case DW_CFA_advance_loc1:
			pc += dbg->decode(&p, 1) * caf;
			if (pc_req < pc)
			        goto program_done;
  800421438c:	90                   	nop
  800421438d:	eb 04                	jmp    8004214393 <_dwarf_frame_run_inst+0xdd9>
			break;
		case DW_CFA_advance_loc2:
			pc += dbg->decode(&p, 2) * caf;
			if (pc_req < pc)
			        goto program_done;
  800421438f:	90                   	nop
  8004214390:	eb 01                	jmp    8004214393 <_dwarf_frame_run_inst+0xdd9>
			break;
		case DW_CFA_advance_loc4:
			pc += dbg->decode(&p, 4) * caf;
			if (pc_req < pc)
			        goto program_done;
  8004214392:	90                   	nop
			goto program_done;
		}
	}

program_done:
	return (ret);
  8004214393:	8b 45 ec             	mov    -0x14(%rbp),%eax
#undef  CFA
#undef  INITCFA
#undef  RL
#undef  INITRL
#undef  CHECK_TABLE_SIZE
}
  8004214396:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  800421439d:	5b                   	pop    %rbx
  800421439e:	5d                   	pop    %rbp
  800421439f:	c3                   	retq   

00000080042143a0 <_dwarf_frame_get_internal_table>:
int
_dwarf_frame_get_internal_table(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_req, Dwarf_Regtable3 **ret_rt,
				Dwarf_Addr *ret_row_pc,
				Dwarf_Error *error)
{
  80042143a0:	55                   	push   %rbp
  80042143a1:	48 89 e5             	mov    %rsp,%rbp
  80042143a4:	48 83 ec 60          	sub    $0x60,%rsp
  80042143a8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042143ac:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042143b0:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042143b4:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80042143b8:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  80042143bc:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Cie cie;
	Dwarf_Regtable3 *rt;
	Dwarf_Addr row_pc;
	int i, ret;

	assert(ret_rt != NULL);
  80042143c0:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  80042143c5:	75 35                	jne    80042143fc <_dwarf_frame_get_internal_table+0x5c>
  80042143c7:	48 b9 98 15 22 04 80 	movabs $0x8004221598,%rcx
  80042143ce:	00 00 00 
  80042143d1:	48 ba a7 14 22 04 80 	movabs $0x80042214a7,%rdx
  80042143d8:	00 00 00 
  80042143db:	be 83 01 00 00       	mov    $0x183,%esi
  80042143e0:	48 bf bc 14 22 04 80 	movabs $0x80042214bc,%rdi
  80042143e7:	00 00 00 
  80042143ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80042143ef:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042143f6:	00 00 00 
  80042143f9:	41 ff d0             	callq  *%r8

	//dbg = fde->fde_dbg;
	assert(dbg != NULL);
  80042143fc:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004214401:	75 35                	jne    8004214438 <_dwarf_frame_get_internal_table+0x98>
  8004214403:	48 b9 a7 15 22 04 80 	movabs $0x80042215a7,%rcx
  800421440a:	00 00 00 
  800421440d:	48 ba a7 14 22 04 80 	movabs $0x80042214a7,%rdx
  8004214414:	00 00 00 
  8004214417:	be 86 01 00 00       	mov    $0x186,%esi
  800421441c:	48 bf bc 14 22 04 80 	movabs $0x80042214bc,%rdi
  8004214423:	00 00 00 
  8004214426:	b8 00 00 00 00       	mov    $0x0,%eax
  800421442b:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004214432:	00 00 00 
  8004214435:	41 ff d0             	callq  *%r8

	rt = dbg->dbg_internal_reg_table;
  8004214438:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421443c:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004214440:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	/* Clear the content of regtable from previous run. */
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
  8004214444:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214448:	ba 18 00 00 00       	mov    $0x18,%edx
  800421444d:	be 00 00 00 00       	mov    $0x0,%esi
  8004214452:	48 89 c7             	mov    %rax,%rdi
  8004214455:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  800421445c:	00 00 00 
  800421445f:	ff d0                	callq  *%rax
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
  8004214461:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214465:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004214469:	0f b7 d0             	movzwl %ax,%edx
  800421446c:	48 89 d0             	mov    %rdx,%rax
  800421446f:	48 01 c0             	add    %rax,%rax
  8004214472:	48 01 d0             	add    %rdx,%rax
  8004214475:	48 c1 e0 03          	shl    $0x3,%rax
  8004214479:	48 89 c2             	mov    %rax,%rdx
  800421447c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214480:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214484:	be 00 00 00 00       	mov    $0x0,%esi
  8004214489:	48 89 c7             	mov    %rax,%rdi
  800421448c:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  8004214493:	00 00 00 
  8004214496:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004214498:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421449f:	eb 2f                	jmp    80042144d0 <_dwarf_frame_get_internal_table+0x130>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;
  80042144a1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042144a5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042144a9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042144ac:	48 63 d0             	movslq %eax,%rdx
  80042144af:	48 89 d0             	mov    %rdx,%rax
  80042144b2:	48 01 c0             	add    %rax,%rax
  80042144b5:	48 01 d0             	add    %rdx,%rax
  80042144b8:	48 c1 e0 03          	shl    $0x3,%rax
  80042144bc:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042144c0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042144c4:	0f b7 40 4a          	movzwl 0x4a(%rax),%eax
  80042144c8:	66 89 42 02          	mov    %ax,0x2(%rdx)
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  80042144cc:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042144d0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042144d4:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042144d8:	0f b7 c0             	movzwl %ax,%eax
  80042144db:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042144de:	7f c1                	jg     80042144a1 <_dwarf_frame_get_internal_table+0x101>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

	/* Run initial instructions in CIE. */
	cie = fde->fde_cie;
  80042144e0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042144e4:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042144e8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	assert(cie != NULL);
  80042144ec:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042144f1:	75 35                	jne    8004214528 <_dwarf_frame_get_internal_table+0x188>
  80042144f3:	48 b9 b3 15 22 04 80 	movabs $0x80042215b3,%rcx
  80042144fa:	00 00 00 
  80042144fd:	48 ba a7 14 22 04 80 	movabs $0x80042214a7,%rdx
  8004214504:	00 00 00 
  8004214507:	be 95 01 00 00       	mov    $0x195,%esi
  800421450c:	48 bf bc 14 22 04 80 	movabs $0x80042214bc,%rdi
  8004214513:	00 00 00 
  8004214516:	b8 00 00 00 00       	mov    $0x0,%eax
  800421451b:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004214522:	00 00 00 
  8004214525:	41 ff d0             	callq  *%r8
	ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  8004214528:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421452c:	4c 8b 48 40          	mov    0x40(%rax),%r9
  8004214530:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214534:	4c 8b 40 38          	mov    0x38(%rax),%r8
  8004214538:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421453c:	48 8b 48 70          	mov    0x70(%rax),%rcx
  8004214540:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214544:	48 8b 50 68          	mov    0x68(%rax),%rdx
  8004214548:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800421454c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214550:	ff 75 a0             	pushq  -0x60(%rbp)
  8004214553:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  8004214557:	57                   	push   %rdi
  8004214558:	6a ff                	pushq  $0xffffffffffffffff
  800421455a:	6a 00                	pushq  $0x0
  800421455c:	48 89 c7             	mov    %rax,%rdi
  800421455f:	48 b8 ba 35 21 04 80 	movabs $0x80042135ba,%rax
  8004214566:	00 00 00 
  8004214569:	ff d0                	callq  *%rax
  800421456b:	48 83 c4 20          	add    $0x20,%rsp
  800421456f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				    cie->cie_instlen, cie->cie_caf,
				    cie->cie_daf, 0, ~0ULL,
				    &row_pc, error);
	if (ret != DW_DLE_NONE)
  8004214572:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004214576:	74 08                	je     8004214580 <_dwarf_frame_get_internal_table+0x1e0>
		return (ret);
  8004214578:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421457b:	e9 8a 00 00 00       	jmpq   800421460a <_dwarf_frame_get_internal_table+0x26a>
	/* Run instructions in FDE. */
	if (pc_req >= fde->fde_initloc) {
  8004214580:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214584:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004214588:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  800421458c:	77 61                	ja     80042145ef <_dwarf_frame_get_internal_table+0x24f>
		ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  800421458e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214592:	48 8b 78 30          	mov    0x30(%rax),%rdi
  8004214596:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421459a:	4c 8b 48 40          	mov    0x40(%rax),%r9
  800421459e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042145a2:	4c 8b 50 38          	mov    0x38(%rax),%r10
  80042145a6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042145aa:	48 8b 48 58          	mov    0x58(%rax),%rcx
  80042145ae:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042145b2:	48 8b 50 50          	mov    0x50(%rax),%rdx
  80042145b6:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042145ba:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042145be:	ff 75 a0             	pushq  -0x60(%rbp)
  80042145c1:	4c 8d 45 d8          	lea    -0x28(%rbp),%r8
  80042145c5:	41 50                	push   %r8
  80042145c7:	ff 75 b8             	pushq  -0x48(%rbp)
  80042145ca:	57                   	push   %rdi
  80042145cb:	4d 89 d0             	mov    %r10,%r8
  80042145ce:	48 89 c7             	mov    %rax,%rdi
  80042145d1:	48 b8 ba 35 21 04 80 	movabs $0x80042135ba,%rax
  80042145d8:	00 00 00 
  80042145db:	ff d0                	callq  *%rax
  80042145dd:	48 83 c4 20          	add    $0x20,%rsp
  80042145e1:	89 45 e4             	mov    %eax,-0x1c(%rbp)
					    fde->fde_instlen, cie->cie_caf,
					    cie->cie_daf,
					    fde->fde_initloc, pc_req,
					    &row_pc, error);
		if (ret != DW_DLE_NONE)
  80042145e4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042145e8:	74 05                	je     80042145ef <_dwarf_frame_get_internal_table+0x24f>
			return (ret);
  80042145ea:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042145ed:	eb 1b                	jmp    800421460a <_dwarf_frame_get_internal_table+0x26a>
	}

	*ret_rt = rt;
  80042145ef:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042145f3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042145f7:	48 89 10             	mov    %rdx,(%rax)
	*ret_row_pc = row_pc;
  80042145fa:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042145fe:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004214602:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  8004214605:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421460a:	c9                   	leaveq 
  800421460b:	c3                   	retq   

000000800421460c <dwarf_get_fde_info_for_all_regs>:
int
dwarf_get_fde_info_for_all_regs(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_requested,
				Dwarf_Regtable *reg_table, Dwarf_Addr *row_pc,
				Dwarf_Error *error)
{
  800421460c:	55                   	push   %rbp
  800421460d:	48 89 e5             	mov    %rsp,%rbp
  8004214610:	48 83 ec 50          	sub    $0x50,%rsp
  8004214614:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004214618:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421461c:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004214620:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004214624:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  8004214628:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
	Dwarf_Regtable3 *rt;
	Dwarf_Addr pc;
	Dwarf_Half cfa;
	int i, ret;

	if (fde == NULL || reg_table == NULL) {
  800421462c:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004214631:	74 07                	je     800421463a <dwarf_get_fde_info_for_all_regs+0x2e>
  8004214633:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004214638:	75 0a                	jne    8004214644 <dwarf_get_fde_info_for_all_regs+0x38>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  800421463a:	b8 01 00 00 00       	mov    $0x1,%eax
  800421463f:	e9 f9 02 00 00       	jmpq   800421493d <dwarf_get_fde_info_for_all_regs+0x331>
	}

	assert(dbg != NULL);
  8004214644:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004214649:	75 35                	jne    8004214680 <dwarf_get_fde_info_for_all_regs+0x74>
  800421464b:	48 b9 a7 15 22 04 80 	movabs $0x80042215a7,%rcx
  8004214652:	00 00 00 
  8004214655:	48 ba a7 14 22 04 80 	movabs $0x80042214a7,%rdx
  800421465c:	00 00 00 
  800421465f:	be bf 01 00 00       	mov    $0x1bf,%esi
  8004214664:	48 bf bc 14 22 04 80 	movabs $0x80042214bc,%rdi
  800421466b:	00 00 00 
  800421466e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214673:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421467a:	00 00 00 
  800421467d:	41 ff d0             	callq  *%r8

	if (pc_requested < fde->fde_initloc ||
  8004214680:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214684:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004214688:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  800421468c:	77 19                	ja     80042146a7 <dwarf_get_fde_info_for_all_regs+0x9b>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
  800421468e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214692:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004214696:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421469a:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421469e:	48 01 d0             	add    %rdx,%rax
		return (DW_DLV_ERROR);
	}

	assert(dbg != NULL);

	if (pc_requested < fde->fde_initloc ||
  80042146a1:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042146a5:	77 0a                	ja     80042146b1 <dwarf_get_fde_info_for_all_regs+0xa5>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
		return (DW_DLV_ERROR);
  80042146a7:	b8 01 00 00 00       	mov    $0x1,%eax
  80042146ac:	e9 8c 02 00 00       	jmpq   800421493d <dwarf_get_fde_info_for_all_regs+0x331>
	}

	ret = _dwarf_frame_get_internal_table(dbg, fde, pc_requested, &rt, &pc,
  80042146b1:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
  80042146b5:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
  80042146b9:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  80042146bd:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042146c1:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042146c5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042146c9:	4d 89 c1             	mov    %r8,%r9
  80042146cc:	49 89 f8             	mov    %rdi,%r8
  80042146cf:	48 89 c7             	mov    %rax,%rdi
  80042146d2:	48 b8 a0 43 21 04 80 	movabs $0x80042143a0,%rax
  80042146d9:	00 00 00 
  80042146dc:	ff d0                	callq  *%rax
  80042146de:	89 45 f8             	mov    %eax,-0x8(%rbp)
					      error);
	if (ret != DW_DLE_NONE)
  80042146e1:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80042146e5:	74 0a                	je     80042146f1 <dwarf_get_fde_info_for_all_regs+0xe5>
		return (DW_DLV_ERROR);
  80042146e7:	b8 01 00 00 00       	mov    $0x1,%eax
  80042146ec:	e9 4c 02 00 00       	jmpq   800421493d <dwarf_get_fde_info_for_all_regs+0x331>
	/*
	 * Copy the CFA rule to the column intended for holding the CFA,
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
  80042146f1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042146f5:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042146f9:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	if (cfa < DW_REG_TABLE_SIZE) {
  80042146fd:	66 83 7d f6 41       	cmpw   $0x41,-0xa(%rbp)
  8004214702:	0f 87 b7 00 00 00    	ja     80042147bf <dwarf_get_fde_info_for_all_regs+0x1b3>
		reg_table->rules[cfa].dw_offset_relevant =
  8004214708:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
			CFA.dw_offset_relevant;
  800421470c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214710:	0f b6 00             	movzbl (%rax),%eax
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
	if (cfa < DW_REG_TABLE_SIZE) {
		reg_table->rules[cfa].dw_offset_relevant =
  8004214713:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214717:	48 63 c9             	movslq %ecx,%rcx
  800421471a:	48 83 c1 01          	add    $0x1,%rcx
  800421471e:	48 c1 e1 04          	shl    $0x4,%rcx
  8004214722:	48 01 ca             	add    %rcx,%rdx
  8004214725:	88 02                	mov    %al,(%rdx)
			CFA.dw_offset_relevant;
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
  8004214727:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800421472b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421472f:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8004214733:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214737:	48 63 c9             	movslq %ecx,%rcx
  800421473a:	48 83 c1 01          	add    $0x1,%rcx
  800421473e:	48 c1 e1 04          	shl    $0x4,%rcx
  8004214742:	48 01 ca             	add    %rcx,%rdx
  8004214745:	48 83 c2 01          	add    $0x1,%rdx
  8004214749:	88 02                	mov    %al,(%rdx)
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
  800421474b:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800421474f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214753:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004214757:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421475b:	48 63 c9             	movslq %ecx,%rcx
  800421475e:	48 83 c1 01          	add    $0x1,%rcx
  8004214762:	48 c1 e1 04          	shl    $0x4,%rcx
  8004214766:	48 01 ca             	add    %rcx,%rdx
  8004214769:	48 83 c2 02          	add    $0x2,%rdx
  800421476d:	66 89 02             	mov    %ax,(%rdx)
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
  8004214770:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004214774:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214778:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421477c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214780:	48 63 c9             	movslq %ecx,%rcx
  8004214783:	48 83 c1 01          	add    $0x1,%rcx
  8004214787:	48 c1 e1 04          	shl    $0x4,%rcx
  800421478b:	48 01 ca             	add    %rcx,%rdx
  800421478e:	48 83 c2 08          	add    $0x8,%rdx
  8004214792:	48 89 02             	mov    %rax,(%rdx)
		reg_table->cfa_rule = reg_table->rules[cfa];
  8004214795:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004214799:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800421479d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042147a1:	48 63 d2             	movslq %edx,%rdx
  80042147a4:	48 83 c2 01          	add    $0x1,%rdx
  80042147a8:	48 c1 e2 04          	shl    $0x4,%rdx
  80042147ac:	48 01 d0             	add    %rdx,%rax
  80042147af:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042147b3:	48 8b 00             	mov    (%rax),%rax
  80042147b6:	48 89 01             	mov    %rax,(%rcx)
  80042147b9:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  80042147bd:	eb 3c                	jmp    80042147fb <dwarf_get_fde_info_for_all_regs+0x1ef>
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
		    CFA.dw_offset_relevant;
  80042147bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042147c3:	0f b6 10             	movzbl (%rax),%edx
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
		reg_table->cfa_rule = reg_table->rules[cfa];
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
  80042147c6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042147ca:	88 10                	mov    %dl,(%rax)
		    CFA.dw_offset_relevant;
		reg_table->cfa_rule.dw_value_type = CFA.dw_value_type;
  80042147cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042147d0:	0f b6 50 01          	movzbl 0x1(%rax),%edx
  80042147d4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042147d8:	88 50 01             	mov    %dl,0x1(%rax)
		reg_table->cfa_rule.dw_regnum = CFA.dw_regnum;
  80042147db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042147df:	0f b7 50 02          	movzwl 0x2(%rax),%edx
  80042147e3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042147e7:	66 89 50 02          	mov    %dx,0x2(%rax)
		reg_table->cfa_rule.dw_offset = CFA.dw_offset_or_block_len;
  80042147eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042147ef:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042147f3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042147f7:	48 89 50 08          	mov    %rdx,0x8(%rax)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  80042147fb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004214802:	e9 05 01 00 00       	jmpq   800421490c <dwarf_get_fde_info_for_all_regs+0x300>
	     i++) {

		/* Do not overwrite CFA column */
		if (i == cfa)
  8004214807:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  800421480b:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800421480e:	0f 84 f3 00 00 00    	je     8004214907 <dwarf_get_fde_info_for_all_regs+0x2fb>
			continue;

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
  8004214814:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214818:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421481c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421481f:	48 63 d0             	movslq %eax,%rdx
  8004214822:	48 89 d0             	mov    %rdx,%rax
  8004214825:	48 01 c0             	add    %rax,%rax
  8004214828:	48 01 d0             	add    %rdx,%rax
  800421482b:	48 c1 e0 03          	shl    $0x3,%rax
  800421482f:	48 01 c8             	add    %rcx,%rax
  8004214832:	0f b6 00             	movzbl (%rax),%eax

		/* Do not overwrite CFA column */
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
  8004214835:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214839:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800421483c:	48 63 c9             	movslq %ecx,%rcx
  800421483f:	48 83 c1 01          	add    $0x1,%rcx
  8004214843:	48 c1 e1 04          	shl    $0x4,%rcx
  8004214847:	48 01 ca             	add    %rcx,%rdx
  800421484a:	88 02                	mov    %al,(%rdx)
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
  800421484c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214850:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214854:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004214857:	48 63 d0             	movslq %eax,%rdx
  800421485a:	48 89 d0             	mov    %rdx,%rax
  800421485d:	48 01 c0             	add    %rax,%rax
  8004214860:	48 01 d0             	add    %rdx,%rax
  8004214863:	48 c1 e0 03          	shl    $0x3,%rax
  8004214867:	48 01 c8             	add    %rcx,%rax
  800421486a:	0f b6 40 01          	movzbl 0x1(%rax),%eax
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
  800421486e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214872:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004214875:	48 63 c9             	movslq %ecx,%rcx
  8004214878:	48 83 c1 01          	add    $0x1,%rcx
  800421487c:	48 c1 e1 04          	shl    $0x4,%rcx
  8004214880:	48 01 ca             	add    %rcx,%rdx
  8004214883:	48 83 c2 01          	add    $0x1,%rdx
  8004214887:	88 02                	mov    %al,(%rdx)
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
  8004214889:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421488d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214891:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004214894:	48 63 d0             	movslq %eax,%rdx
  8004214897:	48 89 d0             	mov    %rdx,%rax
  800421489a:	48 01 c0             	add    %rax,%rax
  800421489d:	48 01 d0             	add    %rdx,%rax
  80042148a0:	48 c1 e0 03          	shl    $0x3,%rax
  80042148a4:	48 01 c8             	add    %rcx,%rax
  80042148a7:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80042148ab:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042148af:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042148b2:	48 63 c9             	movslq %ecx,%rcx
  80042148b5:	48 83 c1 01          	add    $0x1,%rcx
  80042148b9:	48 c1 e1 04          	shl    $0x4,%rcx
  80042148bd:	48 01 ca             	add    %rcx,%rdx
  80042148c0:	48 83 c2 02          	add    $0x2,%rdx
  80042148c4:	66 89 02             	mov    %ax,(%rdx)
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
  80042148c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042148cb:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042148cf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042148d2:	48 63 d0             	movslq %eax,%rdx
  80042148d5:	48 89 d0             	mov    %rdx,%rax
  80042148d8:	48 01 c0             	add    %rax,%rax
  80042148db:	48 01 d0             	add    %rdx,%rax
  80042148de:	48 c1 e0 03          	shl    $0x3,%rax
  80042148e2:	48 01 c8             	add    %rcx,%rax
  80042148e5:	48 8b 40 08          	mov    0x8(%rax),%rax
		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
  80042148e9:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042148ed:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042148f0:	48 63 c9             	movslq %ecx,%rcx
  80042148f3:	48 83 c1 01          	add    $0x1,%rcx
  80042148f7:	48 c1 e1 04          	shl    $0x4,%rcx
  80042148fb:	48 01 ca             	add    %rcx,%rdx
  80042148fe:	48 83 c2 08          	add    $0x8,%rdx
  8004214902:	48 89 02             	mov    %rax,(%rdx)
  8004214905:	eb 01                	jmp    8004214908 <dwarf_get_fde_info_for_all_regs+0x2fc>
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
	     i++) {

		/* Do not overwrite CFA column */
		if (i == cfa)
			continue;
  8004214907:	90                   	nop

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
	     i++) {
  8004214908:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  800421490c:	83 7d fc 41          	cmpl   $0x41,-0x4(%rbp)
  8004214910:	7f 14                	jg     8004214926 <dwarf_get_fde_info_for_all_regs+0x31a>
  8004214912:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214916:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  800421491a:	0f b7 c0             	movzwl %ax,%eax
  800421491d:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004214920:	0f 8f e1 fe ff ff    	jg     8004214807 <dwarf_get_fde_info_for_all_regs+0x1fb>
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
	}

	if (row_pc) *row_pc = pc;
  8004214926:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  800421492b:	74 0b                	je     8004214938 <dwarf_get_fde_info_for_all_regs+0x32c>
  800421492d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214931:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214935:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLV_OK);
  8004214938:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421493d:	c9                   	leaveq 
  800421493e:	c3                   	retq   

000000800421493f <_dwarf_frame_read_lsb_encoded>:

static int
_dwarf_frame_read_lsb_encoded(Dwarf_Debug dbg, uint64_t *val, uint8_t *data,
			      uint64_t *offsetp, uint8_t encode, Dwarf_Addr pc, Dwarf_Error *error)
{
  800421493f:	55                   	push   %rbp
  8004214940:	48 89 e5             	mov    %rsp,%rbp
  8004214943:	48 83 ec 40          	sub    $0x40,%rsp
  8004214947:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421494b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421494f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004214953:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004214957:	44 89 c0             	mov    %r8d,%eax
  800421495a:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  800421495e:	88 45 cc             	mov    %al,-0x34(%rbp)
	uint8_t application;

	if (encode == DW_EH_PE_omit)
  8004214961:	80 7d cc ff          	cmpb   $0xff,-0x34(%rbp)
  8004214965:	75 0a                	jne    8004214971 <_dwarf_frame_read_lsb_encoded+0x32>
		return (DW_DLE_NONE);
  8004214967:	b8 00 00 00 00       	mov    $0x0,%eax
  800421496c:	e9 f8 01 00 00       	jmpq   8004214b69 <_dwarf_frame_read_lsb_encoded+0x22a>

	application = encode & 0xf0;
  8004214971:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004214975:	83 e0 f0             	and    $0xfffffff0,%eax
  8004214978:	88 45 ff             	mov    %al,-0x1(%rbp)
	encode &= 0x0f;
  800421497b:	80 65 cc 0f          	andb   $0xf,-0x34(%rbp)

	switch (encode) {
  800421497f:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004214983:	83 f8 0c             	cmp    $0xc,%eax
  8004214986:	0f 87 84 01 00 00    	ja     8004214b10 <_dwarf_frame_read_lsb_encoded+0x1d1>
  800421498c:	89 c0                	mov    %eax,%eax
  800421498e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004214995:	00 
  8004214996:	48 b8 c0 15 22 04 80 	movabs $0x80042215c0,%rax
  800421499d:	00 00 00 
  80042149a0:	48 01 d0             	add    %rdx,%rax
  80042149a3:	48 8b 00             	mov    (%rax),%rax
  80042149a6:	ff e0                	jmpq   *%rax
	case DW_EH_PE_absptr:
		*val = dbg->read(data, offsetp, dbg->dbg_pointer_size);
  80042149a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042149ac:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042149b0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042149b4:	8b 52 28             	mov    0x28(%rdx),%edx
  80042149b7:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042149bb:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042149bf:	48 89 cf             	mov    %rcx,%rdi
  80042149c2:	ff d0                	callq  *%rax
  80042149c4:	48 89 c2             	mov    %rax,%rdx
  80042149c7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042149cb:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042149ce:	e9 44 01 00 00       	jmpq   8004214b17 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_uleb128:
		*val = _dwarf_read_uleb128(data, offsetp);
  80042149d3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042149d7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042149db:	48 89 d6             	mov    %rdx,%rsi
  80042149de:	48 89 c7             	mov    %rax,%rdi
  80042149e1:	48 b8 a3 1a 21 04 80 	movabs $0x8004211aa3,%rax
  80042149e8:	00 00 00 
  80042149eb:	ff d0                	callq  *%rax
  80042149ed:	48 89 c2             	mov    %rax,%rdx
  80042149f0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042149f4:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042149f7:	e9 1b 01 00 00       	jmpq   8004214b17 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_udata2:
		*val = dbg->read(data, offsetp, 2);
  80042149fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214a00:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214a04:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004214a08:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004214a0c:	ba 02 00 00 00       	mov    $0x2,%edx
  8004214a11:	48 89 cf             	mov    %rcx,%rdi
  8004214a14:	ff d0                	callq  *%rax
  8004214a16:	48 89 c2             	mov    %rax,%rdx
  8004214a19:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214a1d:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004214a20:	e9 f2 00 00 00       	jmpq   8004214b17 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_udata4:
		*val = dbg->read(data, offsetp, 4);
  8004214a25:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214a29:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214a2d:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004214a31:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004214a35:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214a3a:	48 89 cf             	mov    %rcx,%rdi
  8004214a3d:	ff d0                	callq  *%rax
  8004214a3f:	48 89 c2             	mov    %rax,%rdx
  8004214a42:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214a46:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004214a49:	e9 c9 00 00 00       	jmpq   8004214b17 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_udata8:
		*val = dbg->read(data, offsetp, 8);
  8004214a4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214a52:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214a56:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004214a5a:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004214a5e:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214a63:	48 89 cf             	mov    %rcx,%rdi
  8004214a66:	ff d0                	callq  *%rax
  8004214a68:	48 89 c2             	mov    %rax,%rdx
  8004214a6b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214a6f:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004214a72:	e9 a0 00 00 00       	jmpq   8004214b17 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_sleb128:
		*val = _dwarf_read_sleb128(data, offsetp);
  8004214a77:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214a7b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214a7f:	48 89 d6             	mov    %rdx,%rsi
  8004214a82:	48 89 c7             	mov    %rax,%rdi
  8004214a85:	48 b8 ff 19 21 04 80 	movabs $0x80042119ff,%rax
  8004214a8c:	00 00 00 
  8004214a8f:	ff d0                	callq  *%rax
  8004214a91:	48 89 c2             	mov    %rax,%rdx
  8004214a94:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214a98:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004214a9b:	eb 7a                	jmp    8004214b17 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_sdata2:
		*val = (int16_t) dbg->read(data, offsetp, 2);
  8004214a9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214aa1:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214aa5:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004214aa9:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004214aad:	ba 02 00 00 00       	mov    $0x2,%edx
  8004214ab2:	48 89 cf             	mov    %rcx,%rdi
  8004214ab5:	ff d0                	callq  *%rax
  8004214ab7:	48 0f bf d0          	movswq %ax,%rdx
  8004214abb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214abf:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004214ac2:	eb 53                	jmp    8004214b17 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_sdata4:
		*val = (int32_t) dbg->read(data, offsetp, 4);
  8004214ac4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214ac8:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214acc:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004214ad0:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004214ad4:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214ad9:	48 89 cf             	mov    %rcx,%rdi
  8004214adc:	ff d0                	callq  *%rax
  8004214ade:	48 63 d0             	movslq %eax,%rdx
  8004214ae1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214ae5:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004214ae8:	eb 2d                	jmp    8004214b17 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_sdata8:
		*val = dbg->read(data, offsetp, 8);
  8004214aea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214aee:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214af2:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004214af6:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004214afa:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214aff:	48 89 cf             	mov    %rcx,%rdi
  8004214b02:	ff d0                	callq  *%rax
  8004214b04:	48 89 c2             	mov    %rax,%rdx
  8004214b07:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214b0b:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004214b0e:	eb 07                	jmp    8004214b17 <_dwarf_frame_read_lsb_encoded+0x1d8>
	default:
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004214b10:	b8 14 00 00 00       	mov    $0x14,%eax
  8004214b15:	eb 52                	jmp    8004214b69 <_dwarf_frame_read_lsb_encoded+0x22a>
	}

	if (application == DW_EH_PE_pcrel) {
  8004214b17:	80 7d ff 10          	cmpb   $0x10,-0x1(%rbp)
  8004214b1b:	75 47                	jne    8004214b64 <_dwarf_frame_read_lsb_encoded+0x225>
		/*
		 * Value is relative to .eh_frame section virtual addr.
		 */
		switch (encode) {
  8004214b1d:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004214b21:	83 f8 01             	cmp    $0x1,%eax
  8004214b24:	7c 3d                	jl     8004214b63 <_dwarf_frame_read_lsb_encoded+0x224>
  8004214b26:	83 f8 04             	cmp    $0x4,%eax
  8004214b29:	7e 0a                	jle    8004214b35 <_dwarf_frame_read_lsb_encoded+0x1f6>
  8004214b2b:	83 e8 09             	sub    $0x9,%eax
  8004214b2e:	83 f8 03             	cmp    $0x3,%eax
  8004214b31:	77 30                	ja     8004214b63 <_dwarf_frame_read_lsb_encoded+0x224>
  8004214b33:	eb 17                	jmp    8004214b4c <_dwarf_frame_read_lsb_encoded+0x20d>
		case DW_EH_PE_uleb128:
		case DW_EH_PE_udata2:
		case DW_EH_PE_udata4:
		case DW_EH_PE_udata8:
			*val += pc;
  8004214b35:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214b39:	48 8b 10             	mov    (%rax),%rdx
  8004214b3c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214b40:	48 01 c2             	add    %rax,%rdx
  8004214b43:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214b47:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004214b4a:	eb 18                	jmp    8004214b64 <_dwarf_frame_read_lsb_encoded+0x225>
		case DW_EH_PE_sleb128:
		case DW_EH_PE_sdata2:
		case DW_EH_PE_sdata4:
		case DW_EH_PE_sdata8:
			*val = pc + (int64_t) *val;
  8004214b4c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214b50:	48 8b 10             	mov    (%rax),%rdx
  8004214b53:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214b57:	48 01 c2             	add    %rax,%rdx
  8004214b5a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214b5e:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004214b61:	eb 01                	jmp    8004214b64 <_dwarf_frame_read_lsb_encoded+0x225>
		default:
			/* DW_EH_PE_absptr is absolute value. */
			break;
  8004214b63:	90                   	nop
		}
	}

	/* XXX Applications other than DW_EH_PE_pcrel are not handled. */

	return (DW_DLE_NONE);
  8004214b64:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214b69:	c9                   	leaveq 
  8004214b6a:	c3                   	retq   

0000008004214b6b <_dwarf_frame_parse_lsb_cie_augment>:

static int
_dwarf_frame_parse_lsb_cie_augment(Dwarf_Debug dbg, Dwarf_Cie cie,
				   Dwarf_Error *error)
{
  8004214b6b:	55                   	push   %rbp
  8004214b6c:	48 89 e5             	mov    %rsp,%rbp
  8004214b6f:	48 83 ec 50          	sub    $0x50,%rsp
  8004214b73:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004214b77:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004214b7b:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	uint8_t *aug_p, *augdata_p;
	uint64_t val, offset;
	uint8_t encode;
	int ret;

	assert(cie->cie_augment != NULL && *cie->cie_augment == 'z');
  8004214b7f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214b83:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214b87:	48 85 c0             	test   %rax,%rax
  8004214b8a:	74 0f                	je     8004214b9b <_dwarf_frame_parse_lsb_cie_augment+0x30>
  8004214b8c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214b90:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214b94:	0f b6 00             	movzbl (%rax),%eax
  8004214b97:	3c 7a                	cmp    $0x7a,%al
  8004214b99:	74 35                	je     8004214bd0 <_dwarf_frame_parse_lsb_cie_augment+0x65>
  8004214b9b:	48 b9 28 16 22 04 80 	movabs $0x8004221628,%rcx
  8004214ba2:	00 00 00 
  8004214ba5:	48 ba a7 14 22 04 80 	movabs $0x80042214a7,%rdx
  8004214bac:	00 00 00 
  8004214baf:	be 4a 02 00 00       	mov    $0x24a,%esi
  8004214bb4:	48 bf bc 14 22 04 80 	movabs $0x80042214bc,%rdi
  8004214bbb:	00 00 00 
  8004214bbe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214bc3:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004214bca:	00 00 00 
  8004214bcd:	41 ff d0             	callq  *%r8
	/*
	 * Here we're only interested in the presence of augment 'R'
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
  8004214bd0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214bd4:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214bd8:	48 83 c0 01          	add    $0x1,%rax
  8004214bdc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	augdata_p = cie->cie_augdata;
  8004214be0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214be4:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004214be8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (*aug_p != '\0') {
  8004214bec:	e9 b4 00 00 00       	jmpq   8004214ca5 <_dwarf_frame_parse_lsb_cie_augment+0x13a>
		switch (*aug_p) {
  8004214bf1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214bf5:	0f b6 00             	movzbl (%rax),%eax
  8004214bf8:	0f b6 c0             	movzbl %al,%eax
  8004214bfb:	83 f8 50             	cmp    $0x50,%eax
  8004214bfe:	74 18                	je     8004214c18 <_dwarf_frame_parse_lsb_cie_augment+0xad>
  8004214c00:	83 f8 52             	cmp    $0x52,%eax
  8004214c03:	74 7c                	je     8004214c81 <_dwarf_frame_parse_lsb_cie_augment+0x116>
  8004214c05:	83 f8 4c             	cmp    $0x4c,%eax
  8004214c08:	0f 85 8b 00 00 00    	jne    8004214c99 <_dwarf_frame_parse_lsb_cie_augment+0x12e>
		case 'L':
			/* Skip one augment in augment data. */
			augdata_p++;
  8004214c0e:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  8004214c13:	e9 88 00 00 00       	jmpq   8004214ca0 <_dwarf_frame_parse_lsb_cie_augment+0x135>
		case 'P':
			/* Skip two augments in augment data. */
			encode = *augdata_p++;
  8004214c18:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214c1c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214c20:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004214c24:	0f b6 00             	movzbl (%rax),%eax
  8004214c27:	88 45 ef             	mov    %al,-0x11(%rbp)
			offset = 0;
  8004214c2a:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004214c31:	00 
			ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004214c32:	0f b6 7d ef          	movzbl -0x11(%rbp),%edi
  8004214c36:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004214c3a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004214c3e:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8004214c42:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214c46:	48 83 ec 08          	sub    $0x8,%rsp
  8004214c4a:	ff 75 b8             	pushq  -0x48(%rbp)
  8004214c4d:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004214c53:	41 89 f8             	mov    %edi,%r8d
  8004214c56:	48 89 c7             	mov    %rax,%rdi
  8004214c59:	48 b8 3f 49 21 04 80 	movabs $0x800421493f,%rax
  8004214c60:	00 00 00 
  8004214c63:	ff d0                	callq  *%rax
  8004214c65:	48 83 c4 10          	add    $0x10,%rsp
  8004214c69:	89 45 e8             	mov    %eax,-0x18(%rbp)
							    augdata_p, &offset, encode, 0, error);
			if (ret != DW_DLE_NONE)
  8004214c6c:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  8004214c70:	74 05                	je     8004214c77 <_dwarf_frame_parse_lsb_cie_augment+0x10c>
				return (ret);
  8004214c72:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004214c75:	eb 42                	jmp    8004214cb9 <_dwarf_frame_parse_lsb_cie_augment+0x14e>
			augdata_p += offset;
  8004214c77:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214c7b:	48 01 45 f0          	add    %rax,-0x10(%rbp)
			break;
  8004214c7f:	eb 1f                	jmp    8004214ca0 <_dwarf_frame_parse_lsb_cie_augment+0x135>
		case 'R':
			cie->cie_fde_encode = *augdata_p++;
  8004214c81:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214c85:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214c89:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004214c8d:	0f b6 10             	movzbl (%rax),%edx
  8004214c90:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214c94:	88 50 60             	mov    %dl,0x60(%rax)
			break;
  8004214c97:	eb 07                	jmp    8004214ca0 <_dwarf_frame_parse_lsb_cie_augment+0x135>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004214c99:	b8 14 00 00 00       	mov    $0x14,%eax
  8004214c9e:	eb 19                	jmp    8004214cb9 <_dwarf_frame_parse_lsb_cie_augment+0x14e>
		}
		aug_p++;
  8004214ca0:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
	augdata_p = cie->cie_augdata;
	while (*aug_p != '\0') {
  8004214ca5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214ca9:	0f b6 00             	movzbl (%rax),%eax
  8004214cac:	84 c0                	test   %al,%al
  8004214cae:	0f 85 3d ff ff ff    	jne    8004214bf1 <_dwarf_frame_parse_lsb_cie_augment+0x86>
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		}
		aug_p++;
	}

	return (DW_DLE_NONE);
  8004214cb4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214cb9:	c9                   	leaveq 
  8004214cba:	c3                   	retq   

0000008004214cbb <_dwarf_frame_set_cie>:


static int
_dwarf_frame_set_cie(Dwarf_Debug dbg, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, Dwarf_Cie ret_cie, Dwarf_Error *error)
{
  8004214cbb:	55                   	push   %rbp
  8004214cbc:	48 89 e5             	mov    %rsp,%rbp
  8004214cbf:	48 83 ec 60          	sub    $0x60,%rsp
  8004214cc3:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004214cc7:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004214ccb:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004214ccf:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004214cd3:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
	Dwarf_Cie cie;
	uint64_t length;
	int dwarf_size, ret;
	char *p;

	assert(ret_cie);
  8004214cd7:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004214cdc:	75 35                	jne    8004214d13 <_dwarf_frame_set_cie+0x58>
  8004214cde:	48 b9 5d 16 22 04 80 	movabs $0x800422165d,%rcx
  8004214ce5:	00 00 00 
  8004214ce8:	48 ba a7 14 22 04 80 	movabs $0x80042214a7,%rdx
  8004214cef:	00 00 00 
  8004214cf2:	be 7b 02 00 00       	mov    $0x27b,%esi
  8004214cf7:	48 bf bc 14 22 04 80 	movabs $0x80042214bc,%rdi
  8004214cfe:	00 00 00 
  8004214d01:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214d06:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004214d0d:	00 00 00 
  8004214d10:	41 ff d0             	callq  *%r8
	cie = ret_cie;
  8004214d13:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214d17:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cie->cie_dbg = dbg;
  8004214d1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214d1f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214d23:	48 89 10             	mov    %rdx,(%rax)
	cie->cie_offset = *off;
  8004214d26:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214d2a:	48 8b 10             	mov    (%rax),%rdx
  8004214d2d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214d31:	48 89 50 10          	mov    %rdx,0x10(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004214d35:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214d39:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214d3d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214d41:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214d45:	48 89 d7             	mov    %rdx,%rdi
  8004214d48:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004214d4c:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214d51:	48 89 ce             	mov    %rcx,%rsi
  8004214d54:	ff d0                	callq  *%rax
  8004214d56:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004214d5a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214d5f:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004214d63:	75 2e                	jne    8004214d93 <_dwarf_frame_set_cie+0xd8>
		dwarf_size = 8;
  8004214d65:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004214d6c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214d70:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214d74:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214d78:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214d7c:	48 89 d7             	mov    %rdx,%rdi
  8004214d7f:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004214d83:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214d88:	48 89 ce             	mov    %rcx,%rsi
  8004214d8b:	ff d0                	callq  *%rax
  8004214d8d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004214d91:	eb 07                	jmp    8004214d9a <_dwarf_frame_set_cie+0xdf>
	} else
		dwarf_size = 4;
  8004214d93:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004214d9a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214d9e:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004214da2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214da6:	48 8b 00             	mov    (%rax),%rax
  8004214da9:	48 29 c2             	sub    %rax,%rdx
  8004214dac:	48 89 d0             	mov    %rdx,%rax
  8004214daf:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004214db3:	73 0a                	jae    8004214dbf <_dwarf_frame_set_cie+0x104>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004214db5:	b8 12 00 00 00       	mov    $0x12,%eax
  8004214dba:	e9 7e 03 00 00       	jmpq   800421513d <_dwarf_frame_set_cie+0x482>
	}

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
  8004214dbf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214dc3:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214dc7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214dcb:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214dcf:	48 89 d7             	mov    %rdx,%rdi
  8004214dd2:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004214dd5:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004214dd9:	48 89 ce             	mov    %rcx,%rsi
  8004214ddc:	ff d0                	callq  *%rax
	cie->cie_length = length;
  8004214dde:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214de2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214de6:	48 89 50 18          	mov    %rdx,0x18(%rax)

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004214dea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214dee:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214df2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214df6:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214dfa:	48 89 d7             	mov    %rdx,%rdi
  8004214dfd:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004214e01:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214e06:	48 89 ce             	mov    %rcx,%rsi
  8004214e09:	ff d0                	callq  *%rax
  8004214e0b:	89 c2                	mov    %eax,%edx
  8004214e0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214e11:	66 89 50 20          	mov    %dx,0x20(%rax)
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004214e15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214e19:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004214e1d:	66 83 f8 01          	cmp    $0x1,%ax
  8004214e21:	74 26                	je     8004214e49 <_dwarf_frame_set_cie+0x18e>
  8004214e23:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214e27:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004214e2b:	66 83 f8 03          	cmp    $0x3,%ax
  8004214e2f:	74 18                	je     8004214e49 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
  8004214e31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214e35:	0f b7 40 20          	movzwl 0x20(%rax),%eax

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
	cie->cie_length = length;

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004214e39:	66 83 f8 04          	cmp    $0x4,%ax
  8004214e3d:	74 0a                	je     8004214e49 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_VERSION_BAD);
		return (DW_DLE_FRAME_VERSION_BAD);
  8004214e3f:	b8 16 00 00 00       	mov    $0x16,%eax
  8004214e44:	e9 f4 02 00 00       	jmpq   800421513d <_dwarf_frame_set_cie+0x482>
	}

	cie->cie_augment = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004214e49:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214e4d:	48 8b 10             	mov    (%rax),%rdx
  8004214e50:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214e54:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214e58:	48 01 d0             	add    %rdx,%rax
  8004214e5b:	48 89 c2             	mov    %rax,%rdx
  8004214e5e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214e62:	48 89 50 28          	mov    %rdx,0x28(%rax)
	p = (char *)dbg->dbg_eh_offset;
  8004214e66:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214e6a:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214e6e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while (p[(*off)++] != '\0')
  8004214e72:	90                   	nop
  8004214e73:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214e77:	48 8b 00             	mov    (%rax),%rax
  8004214e7a:	48 8d 48 01          	lea    0x1(%rax),%rcx
  8004214e7e:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004214e82:	48 89 0a             	mov    %rcx,(%rdx)
  8004214e85:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214e89:	48 01 d0             	add    %rdx,%rax
  8004214e8c:	0f b6 00             	movzbl (%rax),%eax
  8004214e8f:	84 c0                	test   %al,%al
  8004214e91:	75 e0                	jne    8004214e73 <_dwarf_frame_set_cie+0x1b8>
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
  8004214e93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214e97:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214e9b:	0f b6 00             	movzbl (%rax),%eax
  8004214e9e:	84 c0                	test   %al,%al
  8004214ea0:	74 48                	je     8004214eea <_dwarf_frame_set_cie+0x22f>
  8004214ea2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214ea6:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214eaa:	0f b6 00             	movzbl (%rax),%eax
  8004214ead:	3c 7a                	cmp    $0x7a,%al
  8004214eaf:	74 39                	je     8004214eea <_dwarf_frame_set_cie+0x22f>
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004214eb1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214eb5:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004214eb9:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004214ebd:	75 07                	jne    8004214ec6 <_dwarf_frame_set_cie+0x20b>
  8004214ebf:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214ec4:	eb 05                	jmp    8004214ecb <_dwarf_frame_set_cie+0x210>
  8004214ec6:	ba 0c 00 00 00       	mov    $0xc,%edx
  8004214ecb:	48 01 c2             	add    %rax,%rdx
			cie->cie_length;
  8004214ece:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214ed2:	48 8b 40 18          	mov    0x18(%rax),%rax
	while (p[(*off)++] != '\0')
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004214ed6:	48 01 c2             	add    %rax,%rdx
  8004214ed9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214edd:	48 89 10             	mov    %rdx,(%rax)
			cie->cie_length;
		return (DW_DLE_NONE);
  8004214ee0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214ee5:	e9 53 02 00 00       	jmpq   800421513d <_dwarf_frame_set_cie+0x482>
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
  8004214eea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214eee:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214ef2:	48 be 65 16 22 04 80 	movabs $0x8004221665,%rsi
  8004214ef9:	00 00 00 
  8004214efc:	48 89 c7             	mov    %rax,%rdi
  8004214eff:	48 b8 b6 13 21 04 80 	movabs $0x80042113b6,%rax
  8004214f06:	00 00 00 
  8004214f09:	ff d0                	callq  *%rax
  8004214f0b:	48 85 c0             	test   %rax,%rax
  8004214f0e:	74 2e                	je     8004214f3e <_dwarf_frame_set_cie+0x283>
		cie->cie_ehdata = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004214f10:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214f14:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214f18:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214f1c:	8b 52 28             	mov    0x28(%rdx),%edx
  8004214f1f:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004214f23:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004214f27:	48 89 cf             	mov    %rcx,%rdi
  8004214f2a:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004214f2e:	48 89 ce             	mov    %rcx,%rsi
  8004214f31:	ff d0                	callq  *%rax
  8004214f33:	48 89 c2             	mov    %rax,%rdx
  8004214f36:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214f3a:	48 89 50 30          	mov    %rdx,0x30(%rax)
					    dbg->dbg_pointer_size);

	cie->cie_caf = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004214f3e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214f42:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214f46:	48 89 c2             	mov    %rax,%rdx
  8004214f49:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214f4d:	48 89 c6             	mov    %rax,%rsi
  8004214f50:	48 89 d7             	mov    %rdx,%rdi
  8004214f53:	48 b8 a3 1a 21 04 80 	movabs $0x8004211aa3,%rax
  8004214f5a:	00 00 00 
  8004214f5d:	ff d0                	callq  *%rax
  8004214f5f:	48 89 c2             	mov    %rax,%rdx
  8004214f62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214f66:	48 89 50 38          	mov    %rdx,0x38(%rax)
	cie->cie_daf = _dwarf_read_sleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004214f6a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214f6e:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214f72:	48 89 c2             	mov    %rax,%rdx
  8004214f75:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214f79:	48 89 c6             	mov    %rax,%rsi
  8004214f7c:	48 89 d7             	mov    %rdx,%rdi
  8004214f7f:	48 b8 ff 19 21 04 80 	movabs $0x80042119ff,%rax
  8004214f86:	00 00 00 
  8004214f89:	ff d0                	callq  *%rax
  8004214f8b:	48 89 c2             	mov    %rax,%rdx
  8004214f8e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214f92:	48 89 50 40          	mov    %rdx,0x40(%rax)

	/* Return address register. */
	if (cie->cie_version == 1)
  8004214f96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214f9a:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004214f9e:	66 83 f8 01          	cmp    $0x1,%ax
  8004214fa2:	75 2e                	jne    8004214fd2 <_dwarf_frame_set_cie+0x317>
		cie->cie_ra = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004214fa4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214fa8:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214fac:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214fb0:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214fb4:	48 89 d7             	mov    %rdx,%rdi
  8004214fb7:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004214fbb:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214fc0:	48 89 ce             	mov    %rcx,%rsi
  8004214fc3:	ff d0                	callq  *%rax
  8004214fc5:	48 89 c2             	mov    %rax,%rdx
  8004214fc8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214fcc:	48 89 50 48          	mov    %rdx,0x48(%rax)
  8004214fd0:	eb 2c                	jmp    8004214ffe <_dwarf_frame_set_cie+0x343>
	else
		cie->cie_ra = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004214fd2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214fd6:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214fda:	48 89 c2             	mov    %rax,%rdx
  8004214fdd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214fe1:	48 89 c6             	mov    %rax,%rsi
  8004214fe4:	48 89 d7             	mov    %rdx,%rdi
  8004214fe7:	48 b8 a3 1a 21 04 80 	movabs $0x8004211aa3,%rax
  8004214fee:	00 00 00 
  8004214ff1:	ff d0                	callq  *%rax
  8004214ff3:	48 89 c2             	mov    %rax,%rdx
  8004214ff6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214ffa:	48 89 50 48          	mov    %rdx,0x48(%rax)

	/* Optional CIE augmentation data for .eh_frame section. */
	if (*cie->cie_augment == 'z') {
  8004214ffe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215002:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004215006:	0f b6 00             	movzbl (%rax),%eax
  8004215009:	3c 7a                	cmp    $0x7a,%al
  800421500b:	0f 85 99 00 00 00    	jne    80042150aa <_dwarf_frame_set_cie+0x3ef>
		cie->cie_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004215011:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215015:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004215019:	48 89 c2             	mov    %rax,%rdx
  800421501c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215020:	48 89 c6             	mov    %rax,%rsi
  8004215023:	48 89 d7             	mov    %rdx,%rdi
  8004215026:	48 b8 a3 1a 21 04 80 	movabs $0x8004211aa3,%rax
  800421502d:	00 00 00 
  8004215030:	ff d0                	callq  *%rax
  8004215032:	48 89 c2             	mov    %rax,%rdx
  8004215035:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215039:	48 89 50 50          	mov    %rdx,0x50(%rax)
		cie->cie_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  800421503d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215041:	48 8b 10             	mov    (%rax),%rdx
  8004215044:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215048:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421504c:	48 01 d0             	add    %rdx,%rax
  800421504f:	48 89 c2             	mov    %rax,%rdx
  8004215052:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215056:	48 89 50 58          	mov    %rdx,0x58(%rax)
		*off += cie->cie_auglen;
  800421505a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421505e:	48 8b 10             	mov    (%rax),%rdx
  8004215061:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215065:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004215069:	48 01 c2             	add    %rax,%rdx
  800421506c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215070:	48 89 10             	mov    %rdx,(%rax)
		/*
		 * XXX Use DW_EH_PE_absptr for default FDE PC start/range,
		 * in case _dwarf_frame_parse_lsb_cie_augment fails to
		 * find out the real encode.
		 */
		cie->cie_fde_encode = DW_EH_PE_absptr;
  8004215073:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215077:	c6 40 60 00          	movb   $0x0,0x60(%rax)
		ret = _dwarf_frame_parse_lsb_cie_augment(dbg, cie, error);
  800421507b:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800421507f:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004215083:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215087:	48 89 ce             	mov    %rcx,%rsi
  800421508a:	48 89 c7             	mov    %rax,%rdi
  800421508d:	48 b8 6b 4b 21 04 80 	movabs $0x8004214b6b,%rax
  8004215094:	00 00 00 
  8004215097:	ff d0                	callq  *%rax
  8004215099:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  800421509c:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042150a0:	74 08                	je     80042150aa <_dwarf_frame_set_cie+0x3ef>
			return (ret);
  80042150a2:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042150a5:	e9 93 00 00 00       	jmpq   800421513d <_dwarf_frame_set_cie+0x482>
	}

	/* CIE Initial instructions. */
	cie->cie_initinst = (uint8_t *)dbg->dbg_eh_offset + *off;
  80042150aa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042150ae:	48 8b 10             	mov    (%rax),%rdx
  80042150b1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042150b5:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042150b9:	48 01 d0             	add    %rdx,%rax
  80042150bc:	48 89 c2             	mov    %rax,%rdx
  80042150bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042150c3:	48 89 50 68          	mov    %rdx,0x68(%rax)
	if (dwarf_size == 4)
  80042150c7:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042150cb:	75 2a                	jne    80042150f7 <_dwarf_frame_set_cie+0x43c>
		cie->cie_instlen = cie->cie_offset + 4 + length - *off;
  80042150cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042150d1:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042150d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042150d9:	48 01 c2             	add    %rax,%rdx
  80042150dc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042150e0:	48 8b 00             	mov    (%rax),%rax
  80042150e3:	48 f7 d8             	neg    %rax
  80042150e6:	48 01 d0             	add    %rdx,%rax
  80042150e9:	48 8d 50 04          	lea    0x4(%rax),%rdx
  80042150ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042150f1:	48 89 50 70          	mov    %rdx,0x70(%rax)
  80042150f5:	eb 28                	jmp    800421511f <_dwarf_frame_set_cie+0x464>
	else
		cie->cie_instlen = cie->cie_offset + 12 + length - *off;
  80042150f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042150fb:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042150ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215103:	48 01 c2             	add    %rax,%rdx
  8004215106:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421510a:	48 8b 00             	mov    (%rax),%rax
  800421510d:	48 f7 d8             	neg    %rax
  8004215110:	48 01 d0             	add    %rdx,%rax
  8004215113:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004215117:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421511b:	48 89 50 70          	mov    %rdx,0x70(%rax)

	*off += cie->cie_instlen;
  800421511f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215123:	48 8b 10             	mov    (%rax),%rdx
  8004215126:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421512a:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421512e:	48 01 c2             	add    %rax,%rdx
  8004215131:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215135:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004215138:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421513d:	c9                   	leaveq 
  800421513e:	c3                   	retq   

000000800421513f <_dwarf_frame_set_fde>:

static int
_dwarf_frame_set_fde(Dwarf_Debug dbg, Dwarf_Fde ret_fde, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, int eh_frame, Dwarf_Cie cie, Dwarf_Error *error)
{
  800421513f:	55                   	push   %rbp
  8004215140:	48 89 e5             	mov    %rsp,%rbp
  8004215143:	48 83 ec 60          	sub    $0x60,%rsp
  8004215147:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421514b:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421514f:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004215153:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004215157:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
  800421515b:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Fde fde;
	Dwarf_Unsigned cieoff;
	uint64_t length, val;
	int dwarf_size, ret;

	fde = ret_fde;
  800421515f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215163:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	fde->fde_dbg = dbg;
  8004215167:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421516b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421516f:	48 89 10             	mov    %rdx,(%rax)
	fde->fde_addr = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004215172:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215176:	48 8b 10             	mov    (%rax),%rdx
  8004215179:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421517d:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004215181:	48 01 d0             	add    %rdx,%rax
  8004215184:	48 89 c2             	mov    %rax,%rdx
  8004215187:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421518b:	48 89 50 10          	mov    %rdx,0x10(%rax)
	fde->fde_offset = *off;
  800421518f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215193:	48 8b 10             	mov    (%rax),%rdx
  8004215196:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421519a:	48 89 50 18          	mov    %rdx,0x18(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  800421519e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042151a2:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042151a6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042151aa:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042151ae:	48 89 d7             	mov    %rdx,%rdi
  80042151b1:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042151b5:	ba 04 00 00 00       	mov    $0x4,%edx
  80042151ba:	48 89 ce             	mov    %rcx,%rsi
  80042151bd:	ff d0                	callq  *%rax
  80042151bf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  80042151c3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042151c8:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042151cc:	75 2e                	jne    80042151fc <_dwarf_frame_set_fde+0xbd>
		dwarf_size = 8;
  80042151ce:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  80042151d5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042151d9:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042151dd:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042151e1:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042151e5:	48 89 d7             	mov    %rdx,%rdi
  80042151e8:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042151ec:	ba 08 00 00 00       	mov    $0x8,%edx
  80042151f1:	48 89 ce             	mov    %rcx,%rsi
  80042151f4:	ff d0                	callq  *%rax
  80042151f6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042151fa:	eb 07                	jmp    8004215203 <_dwarf_frame_set_fde+0xc4>
	} else
		dwarf_size = 4;
  80042151fc:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004215203:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215207:	48 8b 50 40          	mov    0x40(%rax),%rdx
  800421520b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421520f:	48 8b 00             	mov    (%rax),%rax
  8004215212:	48 29 c2             	sub    %rax,%rdx
  8004215215:	48 89 d0             	mov    %rdx,%rax
  8004215218:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800421521c:	73 0a                	jae    8004215228 <_dwarf_frame_set_fde+0xe9>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  800421521e:	b8 12 00 00 00       	mov    $0x12,%eax
  8004215223:	e9 fb 02 00 00       	jmpq   8004215523 <_dwarf_frame_set_fde+0x3e4>
	}

	fde->fde_length = length;
  8004215228:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421522c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215230:	48 89 50 20          	mov    %rdx,0x20(%rax)

	if (eh_frame) {
  8004215234:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004215238:	74 61                	je     800421529b <_dwarf_frame_set_fde+0x15c>
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  800421523a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421523e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215242:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004215246:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421524a:	48 89 d7             	mov    %rdx,%rdi
  800421524d:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004215251:	ba 04 00 00 00       	mov    $0x4,%edx
  8004215256:	48 89 ce             	mov    %rcx,%rsi
  8004215259:	ff d0                	callq  *%rax
  800421525b:	48 89 c2             	mov    %rax,%rdx
  800421525e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215262:	48 89 50 28          	mov    %rdx,0x28(%rax)
		cieoff = *off - (4 + fde->fde_cieoff);
  8004215266:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421526a:	48 8b 10             	mov    (%rax),%rdx
  800421526d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215271:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004215275:	48 29 c2             	sub    %rax,%rdx
  8004215278:	48 89 d0             	mov    %rdx,%rax
  800421527b:	48 83 e8 04          	sub    $0x4,%rax
  800421527f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		/* This delta should never be 0. */
		if (cieoff == fde->fde_offset) {
  8004215283:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215287:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421528b:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800421528f:	75 40                	jne    80042152d1 <_dwarf_frame_set_fde+0x192>
			DWARF_SET_ERROR(dbg, error, DW_DLE_NO_CIE_FOR_FDE);
			return (DW_DLE_NO_CIE_FOR_FDE);
  8004215291:	b8 13 00 00 00       	mov    $0x13,%eax
  8004215296:	e9 88 02 00 00       	jmpq   8004215523 <_dwarf_frame_set_fde+0x3e4>
		}
	} else {
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size);
  800421529b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421529f:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042152a3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042152a7:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042152ab:	48 89 d7             	mov    %rdx,%rdi
  80042152ae:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042152b1:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042152b5:	48 89 ce             	mov    %rcx,%rsi
  80042152b8:	ff d0                	callq  *%rax
  80042152ba:	48 89 c2             	mov    %rax,%rdx
  80042152bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042152c1:	48 89 50 28          	mov    %rdx,0x28(%rax)
		cieoff = fde->fde_cieoff;
  80042152c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042152c9:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042152cd:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	if (eh_frame) {
  80042152d1:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  80042152d5:	0f 84 e2 00 00 00    	je     80042153bd <_dwarf_frame_set_fde+0x27e>
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  80042152db:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042152df:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042152e3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042152e7:	48 8b 00             	mov    (%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  80042152ea:	48 8d 3c 02          	lea    (%rdx,%rax,1),%rdi
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  80042152ee:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042152f2:	0f b6 40 60          	movzbl 0x60(%rax),%eax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  80042152f6:	0f b6 c8             	movzbl %al,%ecx
						    (uint8_t *)dbg->dbg_eh_offset,
  80042152f9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042152fd:	48 8b 40 38          	mov    0x38(%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004215301:	49 89 c2             	mov    %rax,%r10
  8004215304:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004215308:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  800421530c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215310:	48 83 ec 08          	sub    $0x8,%rsp
  8004215314:	ff 75 10             	pushq  0x10(%rbp)
  8004215317:	49 89 f9             	mov    %rdi,%r9
  800421531a:	41 89 c8             	mov    %ecx,%r8d
  800421531d:	48 89 d1             	mov    %rdx,%rcx
  8004215320:	4c 89 d2             	mov    %r10,%rdx
  8004215323:	48 89 c7             	mov    %rax,%rdi
  8004215326:	48 b8 3f 49 21 04 80 	movabs $0x800421493f,%rax
  800421532d:	00 00 00 
  8004215330:	ff d0                	callq  *%rax
  8004215332:	48 83 c4 10          	add    $0x10,%rsp
  8004215336:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
		if (ret != DW_DLE_NONE)
  8004215339:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800421533d:	74 08                	je     8004215347 <_dwarf_frame_set_fde+0x208>
			return (ret);
  800421533f:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004215342:	e9 dc 01 00 00       	jmpq   8004215523 <_dwarf_frame_set_fde+0x3e4>
		fde->fde_initloc = val;
  8004215347:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421534b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421534f:	48 89 50 30          	mov    %rdx,0x30(%rax)
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
  8004215353:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215357:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  800421535b:	0f b6 c8             	movzbl %al,%ecx
						    (uint8_t *)dbg->dbg_eh_offset,
  800421535e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215362:	48 8b 40 38          	mov    0x38(%rax),%rax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004215366:	48 89 c7             	mov    %rax,%rdi
  8004215369:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800421536d:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004215371:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215375:	48 83 ec 08          	sub    $0x8,%rsp
  8004215379:	ff 75 10             	pushq  0x10(%rbp)
  800421537c:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004215382:	41 89 c8             	mov    %ecx,%r8d
  8004215385:	48 89 d1             	mov    %rdx,%rcx
  8004215388:	48 89 fa             	mov    %rdi,%rdx
  800421538b:	48 89 c7             	mov    %rax,%rdi
  800421538e:	48 b8 3f 49 21 04 80 	movabs $0x800421493f,%rax
  8004215395:	00 00 00 
  8004215398:	ff d0                	callq  *%rax
  800421539a:	48 83 c4 10          	add    $0x10,%rsp
  800421539e:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
  80042153a1:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042153a5:	74 08                	je     80042153af <_dwarf_frame_set_fde+0x270>
			return (ret);
  80042153a7:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042153aa:	e9 74 01 00 00       	jmpq   8004215523 <_dwarf_frame_set_fde+0x3e4>
		fde->fde_adrange = val;
  80042153af:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042153b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042153b7:	48 89 50 38          	mov    %rdx,0x38(%rax)
  80042153bb:	eb 5c                	jmp    8004215419 <_dwarf_frame_set_fde+0x2da>
	} else {
		fde->fde_initloc = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  80042153bd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042153c1:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042153c5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042153c9:	8b 52 28             	mov    0x28(%rdx),%edx
  80042153cc:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80042153d0:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  80042153d4:	48 89 cf             	mov    %rcx,%rdi
  80042153d7:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042153db:	48 89 ce             	mov    %rcx,%rsi
  80042153de:	ff d0                	callq  *%rax
  80042153e0:	48 89 c2             	mov    %rax,%rdx
  80042153e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042153e7:	48 89 50 30          	mov    %rdx,0x30(%rax)
					     dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  80042153eb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042153ef:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042153f3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042153f7:	8b 52 28             	mov    0x28(%rdx),%edx
  80042153fa:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80042153fe:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004215402:	48 89 cf             	mov    %rcx,%rdi
  8004215405:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004215409:	48 89 ce             	mov    %rcx,%rsi
  800421540c:	ff d0                	callq  *%rax
  800421540e:	48 89 c2             	mov    %rax,%rdx
  8004215411:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215415:	48 89 50 38          	mov    %rdx,0x38(%rax)
					     dbg->dbg_pointer_size);
	}

	/* Optional FDE augmentation data for .eh_frame section. (ignored) */
	if (eh_frame && *cie->cie_augment == 'z') {
  8004215419:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  800421541d:	74 71                	je     8004215490 <_dwarf_frame_set_fde+0x351>
  800421541f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215423:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004215427:	0f b6 00             	movzbl (%rax),%eax
  800421542a:	3c 7a                	cmp    $0x7a,%al
  800421542c:	75 62                	jne    8004215490 <_dwarf_frame_set_fde+0x351>
		fde->fde_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  800421542e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215432:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004215436:	48 89 c2             	mov    %rax,%rdx
  8004215439:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421543d:	48 89 c6             	mov    %rax,%rsi
  8004215440:	48 89 d7             	mov    %rdx,%rdi
  8004215443:	48 b8 a3 1a 21 04 80 	movabs $0x8004211aa3,%rax
  800421544a:	00 00 00 
  800421544d:	ff d0                	callq  *%rax
  800421544f:	48 89 c2             	mov    %rax,%rdx
  8004215452:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215456:	48 89 50 40          	mov    %rdx,0x40(%rax)
		fde->fde_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  800421545a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421545e:	48 8b 10             	mov    (%rax),%rdx
  8004215461:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215465:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004215469:	48 01 d0             	add    %rdx,%rax
  800421546c:	48 89 c2             	mov    %rax,%rdx
  800421546f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215473:	48 89 50 48          	mov    %rdx,0x48(%rax)
		*off += fde->fde_auglen;
  8004215477:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421547b:	48 8b 10             	mov    (%rax),%rdx
  800421547e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215482:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004215486:	48 01 c2             	add    %rax,%rdx
  8004215489:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421548d:	48 89 10             	mov    %rdx,(%rax)
	}

	fde->fde_inst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004215490:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215494:	48 8b 10             	mov    (%rax),%rdx
  8004215497:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421549b:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421549f:	48 01 d0             	add    %rdx,%rax
  80042154a2:	48 89 c2             	mov    %rax,%rdx
  80042154a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042154a9:	48 89 50 50          	mov    %rdx,0x50(%rax)
	if (dwarf_size == 4)
  80042154ad:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042154b1:	75 2a                	jne    80042154dd <_dwarf_frame_set_fde+0x39e>
		fde->fde_instlen = fde->fde_offset + 4 + length - *off;
  80042154b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042154b7:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042154bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042154bf:	48 01 c2             	add    %rax,%rdx
  80042154c2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042154c6:	48 8b 00             	mov    (%rax),%rax
  80042154c9:	48 f7 d8             	neg    %rax
  80042154cc:	48 01 d0             	add    %rdx,%rax
  80042154cf:	48 8d 50 04          	lea    0x4(%rax),%rdx
  80042154d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042154d7:	48 89 50 58          	mov    %rdx,0x58(%rax)
  80042154db:	eb 28                	jmp    8004215505 <_dwarf_frame_set_fde+0x3c6>
	else
		fde->fde_instlen = fde->fde_offset + 12 + length - *off;
  80042154dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042154e1:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042154e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042154e9:	48 01 c2             	add    %rax,%rdx
  80042154ec:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042154f0:	48 8b 00             	mov    (%rax),%rax
  80042154f3:	48 f7 d8             	neg    %rax
  80042154f6:	48 01 d0             	add    %rdx,%rax
  80042154f9:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  80042154fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215501:	48 89 50 58          	mov    %rdx,0x58(%rax)

	*off += fde->fde_instlen;
  8004215505:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215509:	48 8b 10             	mov    (%rax),%rdx
  800421550c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215510:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004215514:	48 01 c2             	add    %rax,%rdx
  8004215517:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421551b:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  800421551e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215523:	c9                   	leaveq 
  8004215524:	c3                   	retq   

0000008004215525 <_dwarf_frame_interal_table_init>:


int
_dwarf_frame_interal_table_init(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004215525:	55                   	push   %rbp
  8004215526:	48 89 e5             	mov    %rsp,%rbp
  8004215529:	48 83 ec 20          	sub    $0x20,%rsp
  800421552d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004215531:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	Dwarf_Regtable3 *rt = &global_rt_table;
  8004215535:	48 b8 a0 e6 4d 04 80 	movabs $0x80044de6a0,%rax
  800421553c:	00 00 00 
  800421553f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if (dbg->dbg_internal_reg_table != NULL)
  8004215543:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215547:	48 8b 40 58          	mov    0x58(%rax),%rax
  800421554b:	48 85 c0             	test   %rax,%rax
  800421554e:	74 07                	je     8004215557 <_dwarf_frame_interal_table_init+0x32>
		return (DW_DLE_NONE);
  8004215550:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215555:	eb 33                	jmp    800421558a <_dwarf_frame_interal_table_init+0x65>

	rt->rt3_reg_table_size = dbg->dbg_frame_rule_table_size;
  8004215557:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421555b:	0f b7 50 48          	movzwl 0x48(%rax),%edx
  800421555f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215563:	66 89 50 18          	mov    %dx,0x18(%rax)
	rt->rt3_rules = global_rules;
  8004215567:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421556b:	48 b9 40 ce 6d 04 80 	movabs $0x80046dce40,%rcx
  8004215572:	00 00 00 
  8004215575:	48 89 48 20          	mov    %rcx,0x20(%rax)

	dbg->dbg_internal_reg_table = rt;
  8004215579:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421557d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215581:	48 89 50 58          	mov    %rdx,0x58(%rax)

	return (DW_DLE_NONE);
  8004215585:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421558a:	c9                   	leaveq 
  800421558b:	c3                   	retq   

000000800421558c <_dwarf_get_next_fde>:

static int
_dwarf_get_next_fde(Dwarf_Debug dbg,
		    int eh_frame, Dwarf_Error *error, Dwarf_Fde ret_fde)
{
  800421558c:	55                   	push   %rbp
  800421558d:	48 89 e5             	mov    %rsp,%rbp
  8004215590:	48 83 ec 50          	sub    $0x50,%rsp
  8004215594:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004215598:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800421559b:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800421559f:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	Dwarf_Section *ds = &debug_frame_sec; 
  80042155a3:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  80042155aa:	00 00 00 
  80042155ad:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint64_t length, offset, cie_id, entry_off;
	int dwarf_size, i, ret=-1;
  80042155b1:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%rbp)

	offset = dbg->curr_off_eh;
  80042155b8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042155bc:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042155c0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	if (offset < dbg->dbg_eh_size) {
  80042155c4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042155c8:	48 8b 50 40          	mov    0x40(%rax),%rdx
  80042155cc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042155d0:	48 39 c2             	cmp    %rax,%rdx
  80042155d3:	0f 86 04 02 00 00    	jbe    80042157dd <_dwarf_get_next_fde+0x251>
		entry_off = offset;
  80042155d9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042155dd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 4);
  80042155e1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042155e5:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042155e9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042155ed:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042155f1:	48 89 d7             	mov    %rdx,%rdi
  80042155f4:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  80042155f8:	ba 04 00 00 00       	mov    $0x4,%edx
  80042155fd:	48 89 ce             	mov    %rcx,%rsi
  8004215600:	ff d0                	callq  *%rax
  8004215602:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (length == 0xffffffff) {
  8004215606:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421560b:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421560f:	75 2e                	jne    800421563f <_dwarf_get_next_fde+0xb3>
			dwarf_size = 8;
  8004215611:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
			length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 8);
  8004215618:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421561c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215620:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004215624:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004215628:	48 89 d7             	mov    %rdx,%rdi
  800421562b:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800421562f:	ba 08 00 00 00       	mov    $0x8,%edx
  8004215634:	48 89 ce             	mov    %rcx,%rsi
  8004215637:	ff d0                	callq  *%rax
  8004215639:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421563d:	eb 07                	jmp    8004215646 <_dwarf_get_next_fde+0xba>
		} else
			dwarf_size = 4;
  800421563f:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

		if (length > dbg->dbg_eh_size - offset || (length == 0 && !eh_frame)) {
  8004215646:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421564a:	48 8b 50 40          	mov    0x40(%rax),%rdx
  800421564e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215652:	48 29 c2             	sub    %rax,%rdx
  8004215655:	48 89 d0             	mov    %rdx,%rax
  8004215658:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800421565c:	72 0d                	jb     800421566b <_dwarf_get_next_fde+0xdf>
  800421565e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004215663:	75 10                	jne    8004215675 <_dwarf_get_next_fde+0xe9>
  8004215665:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004215669:	75 0a                	jne    8004215675 <_dwarf_get_next_fde+0xe9>
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_DEBUG_FRAME_LENGTH_BAD);
			return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  800421566b:	b8 12 00 00 00       	mov    $0x12,%eax
  8004215670:	e9 6d 01 00 00       	jmpq   80042157e2 <_dwarf_get_next_fde+0x256>
		}

		/* Check terminator for .eh_frame */
		if (eh_frame && length == 0)
  8004215675:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004215679:	74 11                	je     800421568c <_dwarf_get_next_fde+0x100>
  800421567b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004215680:	75 0a                	jne    800421568c <_dwarf_get_next_fde+0x100>
			return(-1);
  8004215682:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004215687:	e9 56 01 00 00       	jmpq   80042157e2 <_dwarf_get_next_fde+0x256>

		cie_id = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, dwarf_size);
  800421568c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215690:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215694:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004215698:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421569c:	48 89 d7             	mov    %rdx,%rdi
  800421569f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042156a2:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  80042156a6:	48 89 ce             	mov    %rcx,%rsi
  80042156a9:	ff d0                	callq  *%rax
  80042156ab:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

		if (eh_frame) {
  80042156af:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80042156b3:	74 7c                	je     8004215731 <_dwarf_get_next_fde+0x1a5>
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
  80042156b5:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042156ba:	75 32                	jne    80042156ee <_dwarf_get_next_fde+0x162>
				ret = _dwarf_frame_set_cie(dbg, ds,
  80042156bc:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042156c0:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042156c4:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042156c8:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80042156cc:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  80042156d0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042156d4:	49 89 f8             	mov    %rdi,%r8
  80042156d7:	48 89 c7             	mov    %rax,%rdi
  80042156da:	48 b8 bb 4c 21 04 80 	movabs $0x8004214cbb,%rax
  80042156e1:	00 00 00 
  80042156e4:	ff d0                	callq  *%rax
  80042156e6:	89 45 f0             	mov    %eax,-0x10(%rbp)
  80042156e9:	e9 ce 00 00 00       	jmpq   80042157bc <_dwarf_get_next_fde+0x230>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
  80042156ee:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042156f2:	48 8b 78 08          	mov    0x8(%rax),%rdi
  80042156f6:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80042156fa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042156fe:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004215702:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215706:	48 83 ec 08          	sub    $0x8,%rsp
  800421570a:	ff 75 b8             	pushq  -0x48(%rbp)
  800421570d:	49 89 f9             	mov    %rdi,%r9
  8004215710:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8004215716:	48 89 c7             	mov    %rax,%rdi
  8004215719:	48 b8 3f 51 21 04 80 	movabs $0x800421513f,%rax
  8004215720:	00 00 00 
  8004215723:	ff d0                	callq  *%rax
  8004215725:	48 83 c4 10          	add    $0x10,%rsp
  8004215729:	89 45 f0             	mov    %eax,-0x10(%rbp)
  800421572c:	e9 8b 00 00 00       	jmpq   80042157bc <_dwarf_get_next_fde+0x230>
							   &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
  8004215731:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004215735:	75 0b                	jne    8004215742 <_dwarf_get_next_fde+0x1b6>
  8004215737:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421573c:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004215740:	74 0d                	je     800421574f <_dwarf_get_next_fde+0x1c3>
  8004215742:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  8004215746:	75 36                	jne    800421577e <_dwarf_get_next_fde+0x1f2>
			    (dwarf_size == 8 && cie_id == ~0ULL))
  8004215748:	48 83 7d e0 ff       	cmpq   $0xffffffffffffffff,-0x20(%rbp)
  800421574d:	75 2f                	jne    800421577e <_dwarf_get_next_fde+0x1f2>
				ret = _dwarf_frame_set_cie(dbg, ds,
  800421574f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215753:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004215757:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  800421575b:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800421575f:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8004215763:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215767:	49 89 f8             	mov    %rdi,%r8
  800421576a:	48 89 c7             	mov    %rax,%rdi
  800421576d:	48 b8 bb 4c 21 04 80 	movabs $0x8004214cbb,%rax
  8004215774:	00 00 00 
  8004215777:	ff d0                	callq  *%rax
  8004215779:	89 45 f0             	mov    %eax,-0x10(%rbp)
  800421577c:	eb 3e                	jmp    80042157bc <_dwarf_get_next_fde+0x230>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
  800421577e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215782:	48 8b 78 08          	mov    0x8(%rax),%rdi
  8004215786:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800421578a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421578e:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004215792:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215796:	48 83 ec 08          	sub    $0x8,%rsp
  800421579a:	ff 75 b8             	pushq  -0x48(%rbp)
  800421579d:	49 89 f9             	mov    %rdi,%r9
  80042157a0:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80042157a6:	48 89 c7             	mov    %rax,%rdi
  80042157a9:	48 b8 3f 51 21 04 80 	movabs $0x800421513f,%rax
  80042157b0:	00 00 00 
  80042157b3:	ff d0                	callq  *%rax
  80042157b5:	48 83 c4 10          	add    $0x10,%rsp
  80042157b9:	89 45 f0             	mov    %eax,-0x10(%rbp)
							   &entry_off, 0, ret_fde->fde_cie, error);
		}

		if (ret != DW_DLE_NONE)
  80042157bc:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  80042157c0:	74 07                	je     80042157c9 <_dwarf_get_next_fde+0x23d>
			return(-1);
  80042157c2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042157c7:	eb 19                	jmp    80042157e2 <_dwarf_get_next_fde+0x256>

		offset = entry_off;
  80042157c9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042157cd:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		dbg->curr_off_eh = offset;
  80042157d1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042157d5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042157d9:	48 89 50 30          	mov    %rdx,0x30(%rax)
	}

	return (0);
  80042157dd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042157e2:	c9                   	leaveq 
  80042157e3:	c3                   	retq   

00000080042157e4 <dwarf_set_frame_cfa_value>:

Dwarf_Half
dwarf_set_frame_cfa_value(Dwarf_Debug dbg, Dwarf_Half value)
{
  80042157e4:	55                   	push   %rbp
  80042157e5:	48 89 e5             	mov    %rsp,%rbp
  80042157e8:	48 83 ec 20          	sub    $0x20,%rsp
  80042157ec:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042157f0:	89 f0                	mov    %esi,%eax
  80042157f2:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Half old_value;

	old_value = dbg->dbg_frame_cfa_value;
  80042157f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042157fa:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042157fe:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
	dbg->dbg_frame_cfa_value = value;
  8004215802:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215806:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  800421580a:	66 89 50 4c          	mov    %dx,0x4c(%rax)

	return (old_value);
  800421580e:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
  8004215812:	c9                   	leaveq 
  8004215813:	c3                   	retq   

0000008004215814 <dwarf_init_eh_section>:

int dwarf_init_eh_section(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004215814:	55                   	push   %rbp
  8004215815:	48 89 e5             	mov    %rsp,%rbp
  8004215818:	48 83 ec 10          	sub    $0x10,%rsp
  800421581c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004215820:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	Dwarf_Section *section;

	if (dbg == NULL) {
  8004215824:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004215829:	75 0a                	jne    8004215835 <dwarf_init_eh_section+0x21>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  800421582b:	b8 01 00 00 00       	mov    $0x1,%eax
  8004215830:	e9 85 00 00 00       	jmpq   80042158ba <dwarf_init_eh_section+0xa6>
	}

	if (dbg->dbg_internal_reg_table == NULL) {
  8004215835:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215839:	48 8b 40 58          	mov    0x58(%rax),%rax
  800421583d:	48 85 c0             	test   %rax,%rax
  8004215840:	75 25                	jne    8004215867 <dwarf_init_eh_section+0x53>
		if (_dwarf_frame_interal_table_init(dbg, error) != DW_DLE_NONE)
  8004215842:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004215846:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421584a:	48 89 d6             	mov    %rdx,%rsi
  800421584d:	48 89 c7             	mov    %rax,%rdi
  8004215850:	48 b8 25 55 21 04 80 	movabs $0x8004215525,%rax
  8004215857:	00 00 00 
  800421585a:	ff d0                	callq  *%rax
  800421585c:	85 c0                	test   %eax,%eax
  800421585e:	74 07                	je     8004215867 <dwarf_init_eh_section+0x53>
			return (DW_DLV_ERROR);
  8004215860:	b8 01 00 00 00       	mov    $0x1,%eax
  8004215865:	eb 53                	jmp    80042158ba <dwarf_init_eh_section+0xa6>
	}

	_dwarf_find_section_enhanced(&debug_frame_sec);
  8004215867:	48 bf a0 36 23 04 80 	movabs $0x80042336a0,%rdi
  800421586e:	00 00 00 
  8004215871:	48 b8 7e 32 21 04 80 	movabs $0x800421327e,%rax
  8004215878:	00 00 00 
  800421587b:	ff d0                	callq  *%rax

	dbg->curr_off_eh = 0;
  800421587d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215881:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  8004215888:	00 
	dbg->dbg_eh_offset = debug_frame_sec.ds_addr;
  8004215889:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004215890:	00 00 00 
  8004215893:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004215897:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421589b:	48 89 50 38          	mov    %rdx,0x38(%rax)
	dbg->dbg_eh_size = debug_frame_sec.ds_size;
  800421589f:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  80042158a6:	00 00 00 
  80042158a9:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042158ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042158b1:	48 89 50 40          	mov    %rdx,0x40(%rax)

	return (DW_DLV_OK);
  80042158b5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042158ba:	c9                   	leaveq 
  80042158bb:	c3                   	retq   

00000080042158bc <_dwarf_lineno_run_program>:
int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

static int
_dwarf_lineno_run_program(Dwarf_CU *cu, Dwarf_LineInfo li, uint8_t *p,
			  uint8_t *pe, Dwarf_Addr pc, Dwarf_Error *error)
{
  80042158bc:	55                   	push   %rbp
  80042158bd:	48 89 e5             	mov    %rsp,%rbp
  80042158c0:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  80042158c7:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  80042158cb:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  80042158cf:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  80042158d3:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  80042158d7:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  80042158de:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
	uint64_t address, file, line, column, isa, opsize;
	int is_stmt, basic_block, end_sequence;
	int prologue_end, epilogue_begin;
	int ret;

	ln = &li->li_line;
  80042158e5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042158e9:	48 83 c0 48          	add    $0x48,%rax
  80042158ed:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	/*
	 *   ln->ln_li     = li;             \
	 * Set registers to their default values.
	 */
	RESET_REGISTERS;
  80042158f1:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042158f8:	00 
  80042158f9:	48 c7 45 f0 01 00 00 	movq   $0x1,-0x10(%rbp)
  8004215900:	00 
  8004215901:	48 c7 45 e8 01 00 00 	movq   $0x1,-0x18(%rbp)
  8004215908:	00 
  8004215909:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004215910:	00 
  8004215911:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215915:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004215919:	0f b6 c0             	movzbl %al,%eax
  800421591c:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800421591f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
  8004215926:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  800421592d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004215934:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  800421593b:	e9 b4 04 00 00       	jmpq   8004215df4 <_dwarf_lineno_run_program+0x538>
		if (*p == 0) {
  8004215940:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215944:	0f b6 00             	movzbl (%rax),%eax
  8004215947:	84 c0                	test   %al,%al
  8004215949:	0f 85 4c 01 00 00    	jne    8004215a9b <_dwarf_lineno_run_program+0x1df>

			/*
			 * Extended Opcodes.
			 */

			p++;
  800421594f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215953:	48 83 c0 01          	add    $0x1,%rax
  8004215957:	48 89 45 88          	mov    %rax,-0x78(%rbp)
			opsize = _dwarf_decode_uleb128(&p);
  800421595b:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  800421595f:	48 89 c7             	mov    %rax,%rdi
  8004215962:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004215969:	00 00 00 
  800421596c:	ff d0                	callq  *%rax
  800421596e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			switch (*p) {
  8004215972:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215976:	0f b6 00             	movzbl (%rax),%eax
  8004215979:	0f b6 c0             	movzbl %al,%eax
  800421597c:	83 f8 02             	cmp    $0x2,%eax
  800421597f:	74 74                	je     80042159f5 <_dwarf_lineno_run_program+0x139>
  8004215981:	83 f8 03             	cmp    $0x3,%eax
  8004215984:	0f 84 a7 00 00 00    	je     8004215a31 <_dwarf_lineno_run_program+0x175>
  800421598a:	83 f8 01             	cmp    $0x1,%eax
  800421598d:	0f 85 ee 00 00 00    	jne    8004215a81 <_dwarf_lineno_run_program+0x1c5>
			case DW_LNE_end_sequence:
				p++;
  8004215993:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215997:	48 83 c0 01          	add    $0x1,%rax
  800421599b:	48 89 45 88          	mov    %rax,-0x78(%rbp)
				end_sequence = 1;
  800421599f:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
				RESET_REGISTERS;
  80042159a6:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042159ad:	00 
  80042159ae:	48 c7 45 f0 01 00 00 	movq   $0x1,-0x10(%rbp)
  80042159b5:	00 
  80042159b6:	48 c7 45 e8 01 00 00 	movq   $0x1,-0x18(%rbp)
  80042159bd:	00 
  80042159be:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042159c5:	00 
  80042159c6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042159ca:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  80042159ce:	0f b6 c0             	movzbl %al,%eax
  80042159d1:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042159d4:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
  80042159db:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  80042159e2:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  80042159e9:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
				break;
  80042159f0:	e9 ff 03 00 00       	jmpq   8004215df4 <_dwarf_lineno_run_program+0x538>
			case DW_LNE_set_address:
				p++;
  80042159f5:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042159f9:	48 83 c0 01          	add    $0x1,%rax
  80042159fd:	48 89 45 88          	mov    %rax,-0x78(%rbp)
				address = dbg->decode(&p, cu->addr_size);
  8004215a01:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  8004215a08:	00 00 00 
  8004215a0b:	48 8b 00             	mov    (%rax),%rax
  8004215a0e:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215a12:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004215a16:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004215a1a:	0f b6 ca             	movzbl %dl,%ecx
  8004215a1d:	48 8d 55 88          	lea    -0x78(%rbp),%rdx
  8004215a21:	89 ce                	mov    %ecx,%esi
  8004215a23:	48 89 d7             	mov    %rdx,%rdi
  8004215a26:	ff d0                	callq  *%rax
  8004215a28:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				break;
  8004215a2c:	e9 c3 03 00 00       	jmpq   8004215df4 <_dwarf_lineno_run_program+0x538>
			case DW_LNE_define_file:
				p++;
  8004215a31:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215a35:	48 83 c0 01          	add    $0x1,%rax
  8004215a39:	48 89 45 88          	mov    %rax,-0x78(%rbp)
				ret = _dwarf_lineno_add_file(li, &p, NULL,
  8004215a3d:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  8004215a44:	00 00 00 
  8004215a47:	48 8b 08             	mov    (%rax),%rcx
  8004215a4a:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004215a51:	48 8d 75 88          	lea    -0x78(%rbp),%rsi
  8004215a55:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215a59:	49 89 c8             	mov    %rcx,%r8
  8004215a5c:	48 89 d1             	mov    %rdx,%rcx
  8004215a5f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004215a64:	48 89 c7             	mov    %rax,%rdi
  8004215a67:	48 b8 0e 5e 21 04 80 	movabs $0x8004215e0e,%rax
  8004215a6e:	00 00 00 
  8004215a71:	ff d0                	callq  *%rax
  8004215a73:	89 45 b4             	mov    %eax,-0x4c(%rbp)
							     error, dbg);
				if (ret != DW_DLE_NONE)
  8004215a76:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  8004215a7a:	74 19                	je     8004215a95 <_dwarf_lineno_run_program+0x1d9>
					goto prog_fail;
  8004215a7c:	e9 88 03 00 00       	jmpq   8004215e09 <_dwarf_lineno_run_program+0x54d>
				break;
			default:
				/* Unrecognized extened opcodes. */
				p += opsize;
  8004215a81:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  8004215a85:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215a89:	48 01 d0             	add    %rdx,%rax
  8004215a8c:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004215a90:	e9 5f 03 00 00       	jmpq   8004215df4 <_dwarf_lineno_run_program+0x538>
				p++;
				ret = _dwarf_lineno_add_file(li, &p, NULL,
							     error, dbg);
				if (ret != DW_DLE_NONE)
					goto prog_fail;
				break;
  8004215a95:	90                   	nop
  8004215a96:	e9 59 03 00 00       	jmpq   8004215df4 <_dwarf_lineno_run_program+0x538>
			default:
				/* Unrecognized extened opcodes. */
				p += opsize;
			}

		} else if (*p > 0 && *p < li->li_opbase) {
  8004215a9b:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215a9f:	0f b6 00             	movzbl (%rax),%eax
  8004215aa2:	84 c0                	test   %al,%al
  8004215aa4:	0f 84 24 02 00 00    	je     8004215cce <_dwarf_lineno_run_program+0x412>
  8004215aaa:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215aae:	0f b6 10             	movzbl (%rax),%edx
  8004215ab1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215ab5:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004215ab9:	38 c2                	cmp    %al,%dl
  8004215abb:	0f 83 0d 02 00 00    	jae    8004215cce <_dwarf_lineno_run_program+0x412>

			/*
			 * Standard Opcodes.
			 */

			switch (*p++) {
  8004215ac1:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215ac5:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004215ac9:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  8004215acd:	0f b6 00             	movzbl (%rax),%eax
  8004215ad0:	0f b6 c0             	movzbl %al,%eax
  8004215ad3:	83 f8 0c             	cmp    $0xc,%eax
  8004215ad6:	0f 87 ec 01 00 00    	ja     8004215cc8 <_dwarf_lineno_run_program+0x40c>
  8004215adc:	89 c0                	mov    %eax,%eax
  8004215ade:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004215ae5:	00 
  8004215ae6:	48 b8 68 16 22 04 80 	movabs $0x8004221668,%rax
  8004215aed:	00 00 00 
  8004215af0:	48 01 d0             	add    %rdx,%rax
  8004215af3:	48 8b 00             	mov    (%rax),%rax
  8004215af6:	ff e0                	jmpq   *%rax
			case DW_LNS_copy:
				APPEND_ROW;
  8004215af8:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004215aff:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004215b03:	73 0a                	jae    8004215b0f <_dwarf_lineno_run_program+0x253>
  8004215b05:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215b0a:	e9 fd 02 00 00       	jmpq   8004215e0c <_dwarf_lineno_run_program+0x550>
  8004215b0f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215b13:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215b17:	48 89 10             	mov    %rdx,(%rax)
  8004215b1a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215b1e:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004215b25:	00 
  8004215b26:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215b2a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004215b2e:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004215b32:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215b36:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215b3a:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004215b3e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215b42:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215b46:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004215b4a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215b4e:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8004215b51:	89 50 28             	mov    %edx,0x28(%rax)
  8004215b54:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215b58:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215b5b:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004215b5e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215b62:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004215b65:	89 50 30             	mov    %edx,0x30(%rax)
  8004215b68:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215b6c:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004215b73:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004215b77:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215b7b:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
				basic_block = 0;
  8004215b82:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				prologue_end = 0;
  8004215b89:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
				epilogue_begin = 0;
  8004215b90:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
				break;
  8004215b97:	e9 2d 01 00 00       	jmpq   8004215cc9 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004215b9c:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  8004215ba0:	48 89 c7             	mov    %rax,%rdi
  8004215ba3:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004215baa:	00 00 00 
  8004215bad:	ff d0                	callq  *%rax
  8004215baf:	48 89 c2             	mov    %rax,%rdx
					li->li_minlen;
  8004215bb2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215bb6:	0f b6 40 18          	movzbl 0x18(%rax),%eax
				basic_block = 0;
				prologue_end = 0;
				epilogue_begin = 0;
				break;
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004215bba:	0f b6 c0             	movzbl %al,%eax
  8004215bbd:	48 0f af c2          	imul   %rdx,%rax
  8004215bc1:	48 01 45 f8          	add    %rax,-0x8(%rbp)
					li->li_minlen;
				break;
  8004215bc5:	e9 ff 00 00 00       	jmpq   8004215cc9 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_advance_line:
				line += _dwarf_decode_sleb128(&p);
  8004215bca:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  8004215bce:	48 89 c7             	mov    %rax,%rdi
  8004215bd1:	48 b8 22 1b 21 04 80 	movabs $0x8004211b22,%rax
  8004215bd8:	00 00 00 
  8004215bdb:	ff d0                	callq  *%rax
  8004215bdd:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  8004215be1:	e9 e3 00 00 00       	jmpq   8004215cc9 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_set_file:
				file = _dwarf_decode_uleb128(&p);
  8004215be6:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  8004215bea:	48 89 c7             	mov    %rax,%rdi
  8004215bed:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004215bf4:	00 00 00 
  8004215bf7:	ff d0                	callq  *%rax
  8004215bf9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
				break;
  8004215bfd:	e9 c7 00 00 00       	jmpq   8004215cc9 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_set_column:
				column = _dwarf_decode_uleb128(&p);
  8004215c02:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  8004215c06:	48 89 c7             	mov    %rax,%rdi
  8004215c09:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004215c10:	00 00 00 
  8004215c13:	ff d0                	callq  *%rax
  8004215c15:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				break;
  8004215c19:	e9 ab 00 00 00       	jmpq   8004215cc9 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_negate_stmt:
				is_stmt = !is_stmt;
  8004215c1e:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004215c22:	0f 94 c0             	sete   %al
  8004215c25:	0f b6 c0             	movzbl %al,%eax
  8004215c28:	89 45 dc             	mov    %eax,-0x24(%rbp)
				break;
  8004215c2b:	e9 99 00 00 00       	jmpq   8004215cc9 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_set_basic_block:
				basic_block = 1;
  8004215c30:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
				break;
  8004215c37:	e9 8d 00 00 00       	jmpq   8004215cc9 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_const_add_pc:
				address += ADDRESS(255);
  8004215c3c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215c40:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004215c44:	0f b6 c0             	movzbl %al,%eax
  8004215c47:	ba ff 00 00 00       	mov    $0xff,%edx
  8004215c4c:	89 d1                	mov    %edx,%ecx
  8004215c4e:	29 c1                	sub    %eax,%ecx
  8004215c50:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215c54:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004215c58:	0f b6 f0             	movzbl %al,%esi
  8004215c5b:	89 c8                	mov    %ecx,%eax
  8004215c5d:	99                   	cltd   
  8004215c5e:	f7 fe                	idiv   %esi
  8004215c60:	89 c2                	mov    %eax,%edx
  8004215c62:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215c66:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004215c6a:	0f b6 c0             	movzbl %al,%eax
  8004215c6d:	0f af c2             	imul   %edx,%eax
  8004215c70:	48 98                	cltq   
  8004215c72:	48 01 45 f8          	add    %rax,-0x8(%rbp)
				break;
  8004215c76:	eb 51                	jmp    8004215cc9 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_fixed_advance_pc:
				address += dbg->decode(&p, 2);
  8004215c78:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  8004215c7f:	00 00 00 
  8004215c82:	48 8b 00             	mov    (%rax),%rax
  8004215c85:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215c89:	48 8d 55 88          	lea    -0x78(%rbp),%rdx
  8004215c8d:	be 02 00 00 00       	mov    $0x2,%esi
  8004215c92:	48 89 d7             	mov    %rdx,%rdi
  8004215c95:	ff d0                	callq  *%rax
  8004215c97:	48 01 45 f8          	add    %rax,-0x8(%rbp)
				break;
  8004215c9b:	eb 2c                	jmp    8004215cc9 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_set_prologue_end:
				prologue_end = 1;
  8004215c9d:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
				break;
  8004215ca4:	eb 23                	jmp    8004215cc9 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_set_epilogue_begin:
				epilogue_begin = 1;
  8004215ca6:	c7 45 c0 01 00 00 00 	movl   $0x1,-0x40(%rbp)
				break;
  8004215cad:	eb 1a                	jmp    8004215cc9 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_set_isa:
				isa = _dwarf_decode_uleb128(&p);
  8004215caf:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  8004215cb3:	48 89 c7             	mov    %rax,%rdi
  8004215cb6:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004215cbd:	00 00 00 
  8004215cc0:	ff d0                	callq  *%rax
  8004215cc2:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
				break;
  8004215cc6:	eb 01                	jmp    8004215cc9 <_dwarf_lineno_run_program+0x40d>
			default:
				/* Unrecognized extened opcodes. What to do? */
				break;
  8004215cc8:	90                   	nop
			}

		} else {
  8004215cc9:	e9 26 01 00 00       	jmpq   8004215df4 <_dwarf_lineno_run_program+0x538>

			/*
			 * Special Opcodes.
			 */

			line += LINE(*p);
  8004215cce:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215cd2:	0f b6 40 1a          	movzbl 0x1a(%rax),%eax
  8004215cd6:	0f be c8             	movsbl %al,%ecx
  8004215cd9:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215cdd:	0f b6 00             	movzbl (%rax),%eax
  8004215ce0:	0f b6 d0             	movzbl %al,%edx
  8004215ce3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215ce7:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004215ceb:	0f b6 c0             	movzbl %al,%eax
  8004215cee:	29 c2                	sub    %eax,%edx
  8004215cf0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215cf4:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004215cf8:	0f b6 f0             	movzbl %al,%esi
  8004215cfb:	89 d0                	mov    %edx,%eax
  8004215cfd:	99                   	cltd   
  8004215cfe:	f7 fe                	idiv   %esi
  8004215d00:	89 d0                	mov    %edx,%eax
  8004215d02:	01 c8                	add    %ecx,%eax
  8004215d04:	48 98                	cltq   
  8004215d06:	48 01 45 e8          	add    %rax,-0x18(%rbp)
			address += ADDRESS(*p);
  8004215d0a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215d0e:	0f b6 00             	movzbl (%rax),%eax
  8004215d11:	0f b6 d0             	movzbl %al,%edx
  8004215d14:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215d18:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004215d1c:	0f b6 c0             	movzbl %al,%eax
  8004215d1f:	89 d1                	mov    %edx,%ecx
  8004215d21:	29 c1                	sub    %eax,%ecx
  8004215d23:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215d27:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004215d2b:	0f b6 f0             	movzbl %al,%esi
  8004215d2e:	89 c8                	mov    %ecx,%eax
  8004215d30:	99                   	cltd   
  8004215d31:	f7 fe                	idiv   %esi
  8004215d33:	89 c2                	mov    %eax,%edx
  8004215d35:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215d39:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004215d3d:	0f b6 c0             	movzbl %al,%eax
  8004215d40:	0f af c2             	imul   %edx,%eax
  8004215d43:	48 98                	cltq   
  8004215d45:	48 01 45 f8          	add    %rax,-0x8(%rbp)
			APPEND_ROW;
  8004215d49:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004215d50:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004215d54:	73 0a                	jae    8004215d60 <_dwarf_lineno_run_program+0x4a4>
  8004215d56:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215d5b:	e9 ac 00 00 00       	jmpq   8004215e0c <_dwarf_lineno_run_program+0x550>
  8004215d60:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215d64:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215d68:	48 89 10             	mov    %rdx,(%rax)
  8004215d6b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215d6f:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004215d76:	00 
  8004215d77:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215d7b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004215d7f:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004215d83:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215d87:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215d8b:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004215d8f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215d93:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215d97:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004215d9b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215d9f:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8004215da2:	89 50 28             	mov    %edx,0x28(%rax)
  8004215da5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215da9:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215dac:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004215daf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215db3:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004215db6:	89 50 30             	mov    %edx,0x30(%rax)
  8004215db9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215dbd:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004215dc4:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004215dc8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215dcc:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
			basic_block = 0;
  8004215dd3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
			prologue_end = 0;
  8004215dda:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
			epilogue_begin = 0;
  8004215de1:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
			p++;
  8004215de8:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215dec:	48 83 c0 01          	add    $0x1,%rax
  8004215df0:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	RESET_REGISTERS;

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  8004215df4:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215df8:	48 3b 45 80          	cmp    -0x80(%rbp),%rax
  8004215dfc:	0f 82 3e fb ff ff    	jb     8004215940 <_dwarf_lineno_run_program+0x84>
			epilogue_begin = 0;
			p++;
		}
	}

	return (DW_DLE_NONE);
  8004215e02:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215e07:	eb 03                	jmp    8004215e0c <_dwarf_lineno_run_program+0x550>

prog_fail:

	return (ret);
  8004215e09:	8b 45 b4             	mov    -0x4c(%rbp),%eax

#undef  RESET_REGISTERS
#undef  APPEND_ROW
#undef  LINE
#undef  ADDRESS
}
  8004215e0c:	c9                   	leaveq 
  8004215e0d:	c3                   	retq   

0000008004215e0e <_dwarf_lineno_add_file>:

static int
_dwarf_lineno_add_file(Dwarf_LineInfo li, uint8_t **p, const char *compdir,
		       Dwarf_Error *error, Dwarf_Debug dbg)
{
  8004215e0e:	55                   	push   %rbp
  8004215e0f:	48 89 e5             	mov    %rsp,%rbp
  8004215e12:	48 83 ec 40          	sub    $0x40,%rsp
  8004215e16:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004215e1a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004215e1e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004215e22:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004215e26:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
	char *fname;
	//const char *dirname;
	uint8_t *src;
	int slen;

	src = *p;
  8004215e2a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215e2e:	48 8b 00             	mov    (%rax),%rax
  8004215e31:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
  return (DW_DLE_MEMORY);
  }
*/  
	//lf->lf_fullpath = NULL;
	fname = (char *) src;
  8004215e35:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215e39:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	src += strlen(fname) + 1;
  8004215e3d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215e41:	48 89 c7             	mov    %rax,%rdi
  8004215e44:	48 b8 85 0c 21 04 80 	movabs $0x8004210c85,%rax
  8004215e4b:	00 00 00 
  8004215e4e:	ff d0                	callq  *%rax
  8004215e50:	83 c0 01             	add    $0x1,%eax
  8004215e53:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004215e57:	48 98                	cltq   
  8004215e59:	48 01 d0             	add    %rdx,%rax
  8004215e5c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	_dwarf_decode_uleb128(&src);
  8004215e60:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8004215e64:	48 89 c7             	mov    %rax,%rdi
  8004215e67:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004215e6e:	00 00 00 
  8004215e71:	ff d0                	callq  *%rax
	   snprintf(lf->lf_fullpath, slen, "%s/%s", dirname,
	   lf->lf_fname);
	   }
	   }
	*/
	_dwarf_decode_uleb128(&src);
  8004215e73:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8004215e77:	48 89 c7             	mov    %rax,%rdi
  8004215e7a:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004215e81:	00 00 00 
  8004215e84:	ff d0                	callq  *%rax
	_dwarf_decode_uleb128(&src);
  8004215e86:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8004215e8a:	48 89 c7             	mov    %rax,%rdi
  8004215e8d:	48 b8 b4 1b 21 04 80 	movabs $0x8004211bb4,%rax
  8004215e94:	00 00 00 
  8004215e97:	ff d0                	callq  *%rax
	//STAILQ_INSERT_TAIL(&li->li_lflist, lf, lf_next);
	//li->li_lflen++;

	*p = src;
  8004215e99:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004215e9d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215ea1:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  8004215ea4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215ea9:	c9                   	leaveq 
  8004215eaa:	c3                   	retq   

0000008004215eab <_dwarf_lineno_init>:

int     
_dwarf_lineno_init(Dwarf_Die *die, uint64_t offset, Dwarf_LineInfo linfo, Dwarf_Addr pc, Dwarf_Error *error)
{   
  8004215eab:	55                   	push   %rbp
  8004215eac:	48 89 e5             	mov    %rsp,%rbp
  8004215eaf:	53                   	push   %rbx
  8004215eb0:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  8004215eb7:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  8004215ebe:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  8004215ec5:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  8004215ecc:	48 89 8d 00 ff ff ff 	mov    %rcx,-0x100(%rbp)
  8004215ed3:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
	Dwarf_Section myds = {.ds_name = ".debug_line"};
  8004215eda:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8004215ee1:	00 
  8004215ee2:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  8004215ee9:	00 
  8004215eea:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  8004215ef1:	00 
  8004215ef2:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004215ef9:	00 
  8004215efa:	48 b8 d0 16 22 04 80 	movabs $0x80042216d0,%rax
  8004215f01:	00 00 00 
  8004215f04:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	Dwarf_Section *ds = &myds;
  8004215f08:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8004215f0c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//Dwarf_LineFile lf, tlf;
	uint64_t length, hdroff, endoff;
	uint8_t *p;
	int dwarf_size, i, ret;
            
	cu = die->cu_header;
  8004215f10:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004215f17:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  8004215f1e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	assert(cu != NULL); 
  8004215f22:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004215f27:	75 35                	jne    8004215f5e <_dwarf_lineno_init+0xb3>
  8004215f29:	48 b9 dc 16 22 04 80 	movabs $0x80042216dc,%rcx
  8004215f30:	00 00 00 
  8004215f33:	48 ba e7 16 22 04 80 	movabs $0x80042216e7,%rdx
  8004215f3a:	00 00 00 
  8004215f3d:	be 13 01 00 00       	mov    $0x113,%esi
  8004215f42:	48 bf fc 16 22 04 80 	movabs $0x80042216fc,%rdi
  8004215f49:	00 00 00 
  8004215f4c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215f51:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004215f58:	00 00 00 
  8004215f5b:	41 ff d0             	callq  *%r8
	assert(dbg != NULL);
  8004215f5e:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  8004215f65:	00 00 00 
  8004215f68:	48 8b 00             	mov    (%rax),%rax
  8004215f6b:	48 85 c0             	test   %rax,%rax
  8004215f6e:	75 35                	jne    8004215fa5 <_dwarf_lineno_init+0xfa>
  8004215f70:	48 b9 13 17 22 04 80 	movabs $0x8004221713,%rcx
  8004215f77:	00 00 00 
  8004215f7a:	48 ba e7 16 22 04 80 	movabs $0x80042216e7,%rdx
  8004215f81:	00 00 00 
  8004215f84:	be 14 01 00 00       	mov    $0x114,%esi
  8004215f89:	48 bf fc 16 22 04 80 	movabs $0x80042216fc,%rdi
  8004215f90:	00 00 00 
  8004215f93:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215f98:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004215f9f:	00 00 00 
  8004215fa2:	41 ff d0             	callq  *%r8

	if ((_dwarf_find_section_enhanced(ds)) != 0)
  8004215fa5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215fa9:	48 89 c7             	mov    %rax,%rdi
  8004215fac:	48 b8 7e 32 21 04 80 	movabs $0x800421327e,%rax
  8004215fb3:	00 00 00 
  8004215fb6:	ff d0                	callq  *%rax
  8004215fb8:	85 c0                	test   %eax,%eax
  8004215fba:	74 0a                	je     8004215fc6 <_dwarf_lineno_init+0x11b>
		return (DW_DLE_NONE);
  8004215fbc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215fc1:	e9 51 04 00 00       	jmpq   8004216417 <_dwarf_lineno_init+0x56c>

	li = linfo;
  8004215fc6:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004215fcd:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	 break;
	 }
	 }
	*/

	length = dbg->read(ds->ds_data, &offset, 4);
  8004215fd1:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  8004215fd8:	00 00 00 
  8004215fdb:	48 8b 00             	mov    (%rax),%rax
  8004215fde:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215fe2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215fe6:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004215fea:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004215ff1:	ba 04 00 00 00       	mov    $0x4,%edx
  8004215ff6:	48 89 cf             	mov    %rcx,%rdi
  8004215ff9:	ff d0                	callq  *%rax
  8004215ffb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (length == 0xffffffff) {
  8004215fff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004216004:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004216008:	75 37                	jne    8004216041 <_dwarf_lineno_init+0x196>
		dwarf_size = 8;
  800421600a:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
		length = dbg->read(ds->ds_data, &offset, 8);
  8004216011:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  8004216018:	00 00 00 
  800421601b:	48 8b 00             	mov    (%rax),%rax
  800421601e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216022:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004216026:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800421602a:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004216031:	ba 08 00 00 00       	mov    $0x8,%edx
  8004216036:	48 89 cf             	mov    %rcx,%rdi
  8004216039:	ff d0                	callq  *%rax
  800421603b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800421603f:	eb 07                	jmp    8004216048 <_dwarf_lineno_init+0x19d>
	} else
		dwarf_size = 4;
  8004216041:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)

	if (length > ds->ds_size - offset) {
  8004216048:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421604c:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216050:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004216057:	48 29 c2             	sub    %rax,%rdx
  800421605a:	48 89 d0             	mov    %rdx,%rax
  800421605d:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004216061:	73 0a                	jae    800421606d <_dwarf_lineno_init+0x1c2>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_LINE_LENGTH_BAD);
		return (DW_DLE_DEBUG_LINE_LENGTH_BAD);
  8004216063:	b8 0f 00 00 00       	mov    $0xf,%eax
  8004216068:	e9 aa 03 00 00       	jmpq   8004216417 <_dwarf_lineno_init+0x56c>
	}
	/*
	 * Read in line number program header.
	 */
	li->li_length = length;
  800421606d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004216071:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004216075:	48 89 10             	mov    %rdx,(%rax)
	endoff = offset + length;
  8004216078:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  800421607f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216083:	48 01 d0             	add    %rdx,%rax
  8004216086:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	li->li_version = dbg->read(ds->ds_data, &offset, 2); /* FIXME: verify version */
  800421608a:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  8004216091:	00 00 00 
  8004216094:	48 8b 00             	mov    (%rax),%rax
  8004216097:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421609b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421609f:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042160a3:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042160aa:	ba 02 00 00 00       	mov    $0x2,%edx
  80042160af:	48 89 cf             	mov    %rcx,%rdi
  80042160b2:	ff d0                	callq  *%rax
  80042160b4:	89 c2                	mov    %eax,%edx
  80042160b6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042160ba:	66 89 50 08          	mov    %dx,0x8(%rax)
	li->li_hdrlen = dbg->read(ds->ds_data, &offset, dwarf_size);
  80042160be:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  80042160c5:	00 00 00 
  80042160c8:	48 8b 00             	mov    (%rax),%rax
  80042160cb:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042160cf:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042160d3:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042160d7:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042160da:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042160e1:	48 89 cf             	mov    %rcx,%rdi
  80042160e4:	ff d0                	callq  *%rax
  80042160e6:	48 89 c2             	mov    %rax,%rdx
  80042160e9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042160ed:	48 89 50 10          	mov    %rdx,0x10(%rax)
	hdroff = offset;
  80042160f1:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042160f8:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	li->li_minlen = dbg->read(ds->ds_data, &offset, 1);
  80042160fc:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  8004216103:	00 00 00 
  8004216106:	48 8b 00             	mov    (%rax),%rax
  8004216109:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421610d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004216111:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004216115:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  800421611c:	ba 01 00 00 00       	mov    $0x1,%edx
  8004216121:	48 89 cf             	mov    %rcx,%rdi
  8004216124:	ff d0                	callq  *%rax
  8004216126:	89 c2                	mov    %eax,%edx
  8004216128:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421612c:	88 50 18             	mov    %dl,0x18(%rax)
	li->li_defstmt = dbg->read(ds->ds_data, &offset, 1);
  800421612f:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  8004216136:	00 00 00 
  8004216139:	48 8b 00             	mov    (%rax),%rax
  800421613c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216140:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004216144:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004216148:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  800421614f:	ba 01 00 00 00       	mov    $0x1,%edx
  8004216154:	48 89 cf             	mov    %rcx,%rdi
  8004216157:	ff d0                	callq  *%rax
  8004216159:	89 c2                	mov    %eax,%edx
  800421615b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421615f:	88 50 19             	mov    %dl,0x19(%rax)
	li->li_lbase = dbg->read(ds->ds_data, &offset, 1);
  8004216162:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  8004216169:	00 00 00 
  800421616c:	48 8b 00             	mov    (%rax),%rax
  800421616f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216173:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004216177:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800421617b:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004216182:	ba 01 00 00 00       	mov    $0x1,%edx
  8004216187:	48 89 cf             	mov    %rcx,%rdi
  800421618a:	ff d0                	callq  *%rax
  800421618c:	89 c2                	mov    %eax,%edx
  800421618e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004216192:	88 50 1a             	mov    %dl,0x1a(%rax)
	li->li_lrange = dbg->read(ds->ds_data, &offset, 1);
  8004216195:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  800421619c:	00 00 00 
  800421619f:	48 8b 00             	mov    (%rax),%rax
  80042161a2:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042161a6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042161aa:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042161ae:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042161b5:	ba 01 00 00 00       	mov    $0x1,%edx
  80042161ba:	48 89 cf             	mov    %rcx,%rdi
  80042161bd:	ff d0                	callq  *%rax
  80042161bf:	89 c2                	mov    %eax,%edx
  80042161c1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042161c5:	88 50 1b             	mov    %dl,0x1b(%rax)
	li->li_opbase = dbg->read(ds->ds_data, &offset, 1);
  80042161c8:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  80042161cf:	00 00 00 
  80042161d2:	48 8b 00             	mov    (%rax),%rax
  80042161d5:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042161d9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042161dd:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042161e1:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042161e8:	ba 01 00 00 00       	mov    $0x1,%edx
  80042161ed:	48 89 cf             	mov    %rcx,%rdi
  80042161f0:	ff d0                	callq  *%rax
  80042161f2:	89 c2                	mov    %eax,%edx
  80042161f4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042161f8:	88 50 1c             	mov    %dl,0x1c(%rax)
	//STAILQ_INIT(&li->li_lflist);
	//STAILQ_INIT(&li->li_lnlist);

	if ((int)li->li_hdrlen - 5 < li->li_opbase - 1) {
  80042161fb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042161ff:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216203:	8d 50 fb             	lea    -0x5(%rax),%edx
  8004216206:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421620a:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  800421620e:	0f b6 c0             	movzbl %al,%eax
  8004216211:	83 e8 01             	sub    $0x1,%eax
  8004216214:	39 c2                	cmp    %eax,%edx
  8004216216:	7d 0c                	jge    8004216224 <_dwarf_lineno_init+0x379>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004216218:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  800421621f:	e9 f0 01 00 00       	jmpq   8004216414 <_dwarf_lineno_init+0x569>
	}

	li->li_oplen = global_std_op;
  8004216224:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004216228:	48 bb 80 d4 6d 04 80 	movabs $0x80046dd480,%rbx
  800421622f:	00 00 00 
  8004216232:	48 89 58 20          	mov    %rbx,0x20(%rax)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004216236:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  800421623d:	eb 41                	jmp    8004216280 <_dwarf_lineno_init+0x3d5>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);
  800421623f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004216243:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216247:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421624a:	48 98                	cltq   
  800421624c:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004216250:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  8004216257:	00 00 00 
  800421625a:	48 8b 00             	mov    (%rax),%rax
  800421625d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216261:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004216265:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004216269:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004216270:	ba 01 00 00 00       	mov    $0x1,%edx
  8004216275:	48 89 cf             	mov    %rcx,%rdi
  8004216278:	ff d0                	callq  *%rax
  800421627a:	88 03                	mov    %al,(%rbx)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  800421627c:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  8004216280:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004216284:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004216288:	0f b6 c0             	movzbl %al,%eax
  800421628b:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  800421628e:	7f af                	jg     800421623f <_dwarf_lineno_init+0x394>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);

	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
  8004216290:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004216297:	00 
	p = ds->ds_data + offset;
  8004216298:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421629c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042162a0:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042162a7:	48 01 d0             	add    %rdx,%rax
  80042162aa:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	while (*p != '\0') {
  80042162b1:	eb 1f                	jmp    80042162d2 <_dwarf_lineno_init+0x427>
		while (*p++ != '\0')
  80042162b3:	90                   	nop
  80042162b4:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042162bb:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042162bf:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
  80042162c6:	0f b6 00             	movzbl (%rax),%eax
  80042162c9:	84 c0                	test   %al,%al
  80042162cb:	75 e7                	jne    80042162b4 <_dwarf_lineno_init+0x409>
			;
		length++;
  80042162cd:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
	p = ds->ds_data + offset;
	while (*p != '\0') {
  80042162d2:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042162d9:	0f b6 00             	movzbl (%rax),%eax
  80042162dc:	84 c0                	test   %al,%al
  80042162de:	75 d3                	jne    80042162b3 <_dwarf_lineno_init+0x408>
		while (*p++ != '\0')
			;
		length++;
	}
	li->li_inclen = length;
  80042162e0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042162e4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042162e8:	48 89 50 30          	mov    %rdx,0x30(%rax)

	/* Sanity check. */
	if (p - ds->ds_data > (int) ds->ds_size) {
  80042162ec:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042162f3:	48 89 c2             	mov    %rax,%rdx
  80042162f6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042162fa:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042162fe:	48 29 c2             	sub    %rax,%rdx
  8004216301:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216305:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216309:	48 98                	cltq   
  800421630b:	48 39 c2             	cmp    %rax,%rdx
  800421630e:	7e 0c                	jle    800421631c <_dwarf_lineno_init+0x471>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004216310:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004216317:	e9 f8 00 00 00       	jmpq   8004216414 <_dwarf_lineno_init+0x569>
	}
	p++;
  800421631c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004216323:	48 83 c0 01          	add    $0x1,%rax
  8004216327:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  800421632e:	eb 3c                	jmp    800421636c <_dwarf_lineno_init+0x4c1>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
  8004216330:	48 b8 88 36 23 04 80 	movabs $0x8004233688,%rax
  8004216337:	00 00 00 
  800421633a:	48 8b 08             	mov    (%rax),%rcx
  800421633d:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004216344:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
  800421634b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421634f:	49 89 c8             	mov    %rcx,%r8
  8004216352:	48 89 d1             	mov    %rdx,%rcx
  8004216355:	ba 00 00 00 00       	mov    $0x0,%edx
  800421635a:	48 89 c7             	mov    %rax,%rdi
  800421635d:	48 b8 0e 5e 21 04 80 	movabs $0x8004215e0e,%rax
  8004216364:	00 00 00 
  8004216367:	ff d0                	callq  *%rax
  8004216369:	89 45 dc             	mov    %eax,-0x24(%rbp)
	p++;

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  800421636c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004216373:	0f b6 00             	movzbl (%rax),%eax
  8004216376:	84 c0                	test   %al,%al
  8004216378:	75 b6                	jne    8004216330 <_dwarf_lineno_init+0x485>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
		//p++;
	}

	p++;
  800421637a:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004216381:	48 83 c0 01          	add    $0x1,%rax
  8004216385:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	/* Sanity check. */
	if (p - ds->ds_data - hdroff != li->li_hdrlen) {
  800421638c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004216393:	48 89 c2             	mov    %rax,%rdx
  8004216396:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421639a:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421639e:	48 29 c2             	sub    %rax,%rdx
  80042163a1:	48 89 d0             	mov    %rdx,%rax
  80042163a4:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
  80042163a8:	48 89 c2             	mov    %rax,%rdx
  80042163ab:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042163af:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042163b3:	48 39 c2             	cmp    %rax,%rdx
  80042163b6:	74 09                	je     80042163c1 <_dwarf_lineno_init+0x516>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  80042163b8:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  80042163bf:	eb 53                	jmp    8004216414 <_dwarf_lineno_init+0x569>
	}

	/*
	 * Process line number program.
	 */
	ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
  80042163c1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042163c5:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042163c9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042163cd:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  80042163d1:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  80042163d8:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
  80042163df:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
  80042163e6:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042163ea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042163ee:	4d 89 c1             	mov    %r8,%r9
  80042163f1:	49 89 f8             	mov    %rdi,%r8
  80042163f4:	48 89 c7             	mov    %rax,%rdi
  80042163f7:	48 b8 bc 58 21 04 80 	movabs $0x80042158bc,%rax
  80042163fe:	00 00 00 
  8004216401:	ff d0                	callq  *%rax
  8004216403:	89 45 dc             	mov    %eax,-0x24(%rbp)
					error);
	if (ret != DW_DLE_NONE)
  8004216406:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800421640a:	75 07                	jne    8004216413 <_dwarf_lineno_init+0x568>
		goto fail_cleanup;

	//cu->cu_lineinfo = li;

	return (DW_DLE_NONE);
  800421640c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216411:	eb 04                	jmp    8004216417 <_dwarf_lineno_init+0x56c>
	 * Process line number program.
	 */
	ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
					error);
	if (ret != DW_DLE_NONE)
		goto fail_cleanup;
  8004216413:	90                   	nop
fail_cleanup:

	/*if (li->li_oplen)
	  free(li->li_oplen);*/

	return (ret);
  8004216414:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  8004216417:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  800421641e:	5b                   	pop    %rbx
  800421641f:	5d                   	pop    %rbp
  8004216420:	c3                   	retq   

0000008004216421 <dwarf_srclines>:

int
dwarf_srclines(Dwarf_Die *die, Dwarf_Line linebuf, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004216421:	55                   	push   %rbp
  8004216422:	48 89 e5             	mov    %rsp,%rbp
  8004216425:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  800421642c:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004216433:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  800421643a:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004216441:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
	_Dwarf_LineInfo li;
	Dwarf_Attribute *at;

	assert(die);
  8004216448:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  800421644f:	00 
  8004216450:	75 35                	jne    8004216487 <dwarf_srclines+0x66>
  8004216452:	48 b9 1f 17 22 04 80 	movabs $0x800422171f,%rcx
  8004216459:	00 00 00 
  800421645c:	48 ba e7 16 22 04 80 	movabs $0x80042216e7,%rdx
  8004216463:	00 00 00 
  8004216466:	be 9a 01 00 00       	mov    $0x19a,%esi
  800421646b:	48 bf fc 16 22 04 80 	movabs $0x80042216fc,%rdi
  8004216472:	00 00 00 
  8004216475:	b8 00 00 00 00       	mov    $0x0,%eax
  800421647a:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004216481:	00 00 00 
  8004216484:	41 ff d0             	callq  *%r8
	assert(linebuf);
  8004216487:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  800421648e:	00 
  800421648f:	75 35                	jne    80042164c6 <dwarf_srclines+0xa5>
  8004216491:	48 b9 23 17 22 04 80 	movabs $0x8004221723,%rcx
  8004216498:	00 00 00 
  800421649b:	48 ba e7 16 22 04 80 	movabs $0x80042216e7,%rdx
  80042164a2:	00 00 00 
  80042164a5:	be 9b 01 00 00       	mov    $0x19b,%esi
  80042164aa:	48 bf fc 16 22 04 80 	movabs $0x80042216fc,%rdi
  80042164b1:	00 00 00 
  80042164b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042164b9:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042164c0:	00 00 00 
  80042164c3:	41 ff d0             	callq  *%r8

	memset(&li, 0, sizeof(_Dwarf_LineInfo));
  80042164c6:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  80042164cd:	ba 88 00 00 00       	mov    $0x88,%edx
  80042164d2:	be 00 00 00 00       	mov    $0x0,%esi
  80042164d7:	48 89 c7             	mov    %rax,%rdi
  80042164da:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  80042164e1:	00 00 00 
  80042164e4:	ff d0                	callq  *%rax

	if ((at = _dwarf_attr_find(die, DW_AT_stmt_list)) == NULL) {
  80042164e6:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042164ed:	be 10 00 00 00       	mov    $0x10,%esi
  80042164f2:	48 89 c7             	mov    %rax,%rdi
  80042164f5:	48 b8 69 2e 21 04 80 	movabs $0x8004212e69,%rax
  80042164fc:	00 00 00 
  80042164ff:	ff d0                	callq  *%rax
  8004216501:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004216505:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421650a:	75 0a                	jne    8004216516 <dwarf_srclines+0xf5>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  800421650c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004216511:	e9 84 00 00 00       	jmpq   800421659a <dwarf_srclines+0x179>
	}

	if (_dwarf_lineno_init(die, at->u[0].u64, &li, pc, error) !=
  8004216516:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421651a:	48 8b 70 28          	mov    0x28(%rax),%rsi
  800421651e:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  8004216525:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  800421652c:	48 8d 95 70 ff ff ff 	lea    -0x90(%rbp),%rdx
  8004216533:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421653a:	49 89 f8             	mov    %rdi,%r8
  800421653d:	48 89 c7             	mov    %rax,%rdi
  8004216540:	48 b8 ab 5e 21 04 80 	movabs $0x8004215eab,%rax
  8004216547:	00 00 00 
  800421654a:	ff d0                	callq  *%rax
  800421654c:	85 c0                	test   %eax,%eax
  800421654e:	74 07                	je     8004216557 <dwarf_srclines+0x136>
	    DW_DLE_NONE)
	{
		return (DW_DLV_ERROR);
  8004216550:	b8 01 00 00 00       	mov    $0x1,%eax
  8004216555:	eb 43                	jmp    800421659a <dwarf_srclines+0x179>
	}
	*linebuf = li.li_line;
  8004216557:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800421655e:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004216562:	48 89 10             	mov    %rdx,(%rax)
  8004216565:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004216569:	48 89 50 08          	mov    %rdx,0x8(%rax)
  800421656d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004216571:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004216575:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004216579:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421657d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004216581:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004216585:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004216589:	48 89 50 28          	mov    %rdx,0x28(%rax)
  800421658d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004216591:	48 89 50 30          	mov    %rdx,0x30(%rax)

	return (DW_DLV_OK);
  8004216595:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421659a:	c9                   	leaveq 
  800421659b:	c3                   	retq   

000000800421659c <_dwarf_find_section>:
uintptr_t
read_section_headers(uintptr_t, uintptr_t);

Dwarf_Section *
_dwarf_find_section(const char *name)
{
  800421659c:	55                   	push   %rbp
  800421659d:	48 89 e5             	mov    %rsp,%rbp
  80042165a0:	48 83 ec 20          	sub    $0x20,%rsp
  80042165a4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *ret=NULL;
  80042165a8:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042165af:	00 
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  80042165b0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042165b7:	eb 57                	jmp    8004216610 <_dwarf_find_section+0x74>
		if(!strcmp(section_info[i].ds_name, name)) {
  80042165b9:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  80042165c0:	00 00 00 
  80042165c3:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042165c6:	48 63 d2             	movslq %edx,%rdx
  80042165c9:	48 c1 e2 05          	shl    $0x5,%rdx
  80042165cd:	48 01 d0             	add    %rdx,%rax
  80042165d0:	48 8b 00             	mov    (%rax),%rax
  80042165d3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042165d7:	48 89 d6             	mov    %rdx,%rsi
  80042165da:	48 89 c7             	mov    %rax,%rdi
  80042165dd:	48 b8 53 0e 21 04 80 	movabs $0x8004210e53,%rax
  80042165e4:	00 00 00 
  80042165e7:	ff d0                	callq  *%rax
  80042165e9:	85 c0                	test   %eax,%eax
  80042165eb:	75 1f                	jne    800421660c <_dwarf_find_section+0x70>
			ret = (section_info + i);
  80042165ed:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042165f0:	48 98                	cltq   
  80042165f2:	48 c1 e0 05          	shl    $0x5,%rax
  80042165f6:	48 89 c2             	mov    %rax,%rdx
  80042165f9:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216600:	00 00 00 
  8004216603:	48 01 d0             	add    %rdx,%rax
  8004216606:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800421660a:	eb 0a                	jmp    8004216616 <_dwarf_find_section+0x7a>
_dwarf_find_section(const char *name)
{
	Dwarf_Section *ret=NULL;
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  800421660c:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216610:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004216614:	7e a3                	jle    80042165b9 <_dwarf_find_section+0x1d>
			ret = (section_info + i);
			break;
		}
	}

	return ret;
  8004216616:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421661a:	c9                   	leaveq 
  800421661b:	c3                   	retq   

000000800421661c <find_debug_sections>:

void find_debug_sections(uintptr_t elf) 
{
  800421661c:	55                   	push   %rbp
  800421661d:	48 89 e5             	mov    %rsp,%rbp
  8004216620:	48 83 ec 40          	sub    $0x40,%rsp
  8004216624:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	Elf *ehdr = (Elf *)elf;
  8004216628:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421662c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uintptr_t debug_address = USTABDATA;
  8004216630:	48 c7 45 f8 00 00 20 	movq   $0x200000,-0x8(%rbp)
  8004216637:	00 
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
  8004216638:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421663c:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004216640:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216644:	48 01 d0             	add    %rdx,%rax
  8004216647:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
  800421664b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421664f:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004216653:	0f b7 c0             	movzwl %ax,%eax
  8004216656:	48 c1 e0 06          	shl    $0x6,%rax
  800421665a:	48 89 c2             	mov    %rax,%rdx
  800421665d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216661:	48 01 d0             	add    %rdx,%rax
  8004216664:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Secthdr* esh = sh + ehdr->e_shnum;
  8004216668:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421666c:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004216670:	0f b7 c0             	movzwl %ax,%eax
  8004216673:	48 c1 e0 06          	shl    $0x6,%rax
  8004216677:	48 89 c2             	mov    %rax,%rdx
  800421667a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421667e:	48 01 d0             	add    %rdx,%rax
  8004216681:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;sh < esh; sh++) {
  8004216685:	e9 4b 02 00 00       	jmpq   80042168d5 <find_debug_sections+0x2b9>
		char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  800421668a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421668e:	8b 00                	mov    (%rax),%eax
  8004216690:	89 c1                	mov    %eax,%ecx
  8004216692:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216696:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421669a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421669e:	48 01 d0             	add    %rdx,%rax
  80042166a1:	48 01 c8             	add    %rcx,%rax
  80042166a4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!strcmp(name, ".debug_info")) {
  80042166a8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042166ac:	48 be 2b 17 22 04 80 	movabs $0x800422172b,%rsi
  80042166b3:	00 00 00 
  80042166b6:	48 89 c7             	mov    %rax,%rdi
  80042166b9:	48 b8 53 0e 21 04 80 	movabs $0x8004210e53,%rax
  80042166c0:	00 00 00 
  80042166c3:	ff d0                	callq  *%rax
  80042166c5:	85 c0                	test   %eax,%eax
  80042166c7:	75 4b                	jne    8004216714 <find_debug_sections+0xf8>
			section_info[DEBUG_INFO].ds_data = (uint8_t*)debug_address;
  80042166c9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042166cd:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  80042166d4:	00 00 00 
  80042166d7:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = debug_address;
  80042166db:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  80042166e2:	00 00 00 
  80042166e5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042166e9:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = sh->sh_size;
  80042166ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042166f1:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042166f5:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  80042166fc:	00 00 00 
  80042166ff:	48 89 50 18          	mov    %rdx,0x18(%rax)
			debug_address += sh->sh_size;
  8004216703:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216707:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421670b:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  800421670f:	e9 bc 01 00 00       	jmpq   80042168d0 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_abbrev")) {
  8004216714:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216718:	48 be 37 17 22 04 80 	movabs $0x8004221737,%rsi
  800421671f:	00 00 00 
  8004216722:	48 89 c7             	mov    %rax,%rdi
  8004216725:	48 b8 53 0e 21 04 80 	movabs $0x8004210e53,%rax
  800421672c:	00 00 00 
  800421672f:	ff d0                	callq  *%rax
  8004216731:	85 c0                	test   %eax,%eax
  8004216733:	75 4b                	jne    8004216780 <find_debug_sections+0x164>
			section_info[DEBUG_ABBREV].ds_data = (uint8_t*)debug_address;
  8004216735:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004216739:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216740:	00 00 00 
  8004216743:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = debug_address;
  8004216747:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  800421674e:	00 00 00 
  8004216751:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004216755:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = sh->sh_size;
  8004216759:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421675d:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216761:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216768:	00 00 00 
  800421676b:	48 89 50 38          	mov    %rdx,0x38(%rax)
			debug_address += sh->sh_size;
  800421676f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216773:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004216777:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  800421677b:	e9 50 01 00 00       	jmpq   80042168d0 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_line")){
  8004216780:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216784:	48 be 4f 17 22 04 80 	movabs $0x800422174f,%rsi
  800421678b:	00 00 00 
  800421678e:	48 89 c7             	mov    %rax,%rdi
  8004216791:	48 b8 53 0e 21 04 80 	movabs $0x8004210e53,%rax
  8004216798:	00 00 00 
  800421679b:	ff d0                	callq  *%rax
  800421679d:	85 c0                	test   %eax,%eax
  800421679f:	75 4b                	jne    80042167ec <find_debug_sections+0x1d0>
			section_info[DEBUG_LINE].ds_data = (uint8_t*)debug_address;
  80042167a1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042167a5:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  80042167ac:	00 00 00 
  80042167af:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = debug_address;
  80042167b3:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  80042167ba:	00 00 00 
  80042167bd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042167c1:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = sh->sh_size;
  80042167c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042167c9:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042167cd:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  80042167d4:	00 00 00 
  80042167d7:	48 89 50 78          	mov    %rdx,0x78(%rax)
			debug_address += sh->sh_size;
  80042167db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042167df:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042167e3:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042167e7:	e9 e4 00 00 00       	jmpq   80042168d0 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".eh_frame")){
  80042167ec:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042167f0:	48 be 45 17 22 04 80 	movabs $0x8004221745,%rsi
  80042167f7:	00 00 00 
  80042167fa:	48 89 c7             	mov    %rax,%rdi
  80042167fd:	48 b8 53 0e 21 04 80 	movabs $0x8004210e53,%rax
  8004216804:	00 00 00 
  8004216807:	ff d0                	callq  *%rax
  8004216809:	85 c0                	test   %eax,%eax
  800421680b:	75 53                	jne    8004216860 <find_debug_sections+0x244>
			section_info[DEBUG_FRAME].ds_data = (uint8_t*)sh->sh_addr;
  800421680d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216811:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216815:	48 89 c2             	mov    %rax,%rdx
  8004216818:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  800421681f:	00 00 00 
  8004216822:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = sh->sh_addr;
  8004216826:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421682a:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800421682e:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216835:	00 00 00 
  8004216838:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = sh->sh_size;
  800421683c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216840:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216844:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  800421684b:	00 00 00 
  800421684e:	48 89 50 58          	mov    %rdx,0x58(%rax)
			debug_address += sh->sh_size;
  8004216852:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216856:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421685a:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  800421685e:	eb 70                	jmp    80042168d0 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_str")) {
  8004216860:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216864:	48 be 5b 17 22 04 80 	movabs $0x800422175b,%rsi
  800421686b:	00 00 00 
  800421686e:	48 89 c7             	mov    %rax,%rdi
  8004216871:	48 b8 53 0e 21 04 80 	movabs $0x8004210e53,%rax
  8004216878:	00 00 00 
  800421687b:	ff d0                	callq  *%rax
  800421687d:	85 c0                	test   %eax,%eax
  800421687f:	75 4f                	jne    80042168d0 <find_debug_sections+0x2b4>
			section_info[DEBUG_STR].ds_data = (uint8_t*)debug_address;
  8004216881:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004216885:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  800421688c:	00 00 00 
  800421688f:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = debug_address;
  8004216896:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  800421689d:	00 00 00 
  80042168a0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042168a4:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = sh->sh_size;
  80042168ab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042168af:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042168b3:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  80042168ba:	00 00 00 
  80042168bd:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
			debug_address += sh->sh_size;
  80042168c4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042168c8:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042168cc:	48 01 45 f8          	add    %rax,-0x8(%rbp)
	Elf *ehdr = (Elf *)elf;
	uintptr_t debug_address = USTABDATA;
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
	Secthdr* esh = sh + ehdr->e_shnum;
	for(;sh < esh; sh++) {
  80042168d0:	48 83 45 f0 40       	addq   $0x40,-0x10(%rbp)
  80042168d5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042168d9:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80042168dd:	0f 82 a7 fd ff ff    	jb     800421668a <find_debug_sections+0x6e>
			section_info[DEBUG_STR].ds_size = sh->sh_size;
			debug_address += sh->sh_size;
		}
	}

}
  80042168e3:	90                   	nop
  80042168e4:	c9                   	leaveq 
  80042168e5:	c3                   	retq   

00000080042168e6 <read_section_headers>:

uint64_t
read_section_headers(uintptr_t elfhdr, uintptr_t to_va)
{
  80042168e6:	55                   	push   %rbp
  80042168e7:	48 89 e5             	mov    %rsp,%rbp
  80042168ea:	48 81 ec 60 01 00 00 	sub    $0x160,%rsp
  80042168f1:	48 89 bd a8 fe ff ff 	mov    %rdi,-0x158(%rbp)
  80042168f8:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
	Secthdr* secthdr_ptr[20] = {0};
  80042168ff:	48 8d 95 c0 fe ff ff 	lea    -0x140(%rbp),%rdx
  8004216906:	b8 00 00 00 00       	mov    $0x0,%eax
  800421690b:	b9 14 00 00 00       	mov    $0x14,%ecx
  8004216910:	48 89 d7             	mov    %rdx,%rdi
  8004216913:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	char* kvbase = ROUNDUP((char*)to_va, SECTSIZE);
  8004216916:	48 c7 45 e8 00 02 00 	movq   $0x200,-0x18(%rbp)
  800421691d:	00 
  800421691e:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  8004216925:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216929:	48 01 d0             	add    %rdx,%rax
  800421692c:	48 83 e8 01          	sub    $0x1,%rax
  8004216930:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004216934:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216938:	ba 00 00 00 00       	mov    $0x0,%edx
  800421693d:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004216941:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216945:	48 29 d0             	sub    %rdx,%rax
  8004216948:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	uint64_t kvoffset = 0;
  800421694c:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  8004216953:	00 00 00 00 
	char *orig_secthdr = (char*)kvbase;
  8004216957:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421695b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	char * secthdr = NULL;
  800421695f:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8004216966:	00 
	uint64_t offset;
	if(elfhdr == KELFHDR)
  8004216967:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800421696e:	00 00 00 
  8004216971:	48 39 85 a8 fe ff ff 	cmp    %rax,-0x158(%rbp)
  8004216978:	75 11                	jne    800421698b <read_section_headers+0xa5>
		offset = ((Elf*)elfhdr)->e_shoff;
  800421697a:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004216981:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004216985:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004216989:	eb 26                	jmp    80042169b1 <read_section_headers+0xcb>
	else
		offset = ((Elf*)elfhdr)->e_shoff + (elfhdr - KERNBASE);
  800421698b:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004216992:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004216996:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421699d:	48 01 c2             	add    %rax,%rdx
  80042169a0:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  80042169a7:	ff ff ff 
  80042169aa:	48 01 d0             	add    %rdx,%rax
  80042169ad:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	int numSectionHeaders = ((Elf*)elfhdr)->e_shnum;
  80042169b1:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042169b8:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  80042169bc:	0f b7 c0             	movzwl %ax,%eax
  80042169bf:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	int sizeSections = ((Elf*)elfhdr)->e_shentsize;
  80042169c2:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042169c9:	0f b7 40 3a          	movzwl 0x3a(%rax),%eax
  80042169cd:	0f b7 c0             	movzwl %ax,%eax
  80042169d0:	89 45 c0             	mov    %eax,-0x40(%rbp)
	char *nametab;
	int i;
	uint64_t temp;
	char *name;

	Elf *ehdr = (Elf *)elfhdr;
  80042169d3:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042169da:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
  80042169de:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042169e1:	0f af 45 c0          	imul   -0x40(%rbp),%eax
  80042169e5:	48 63 f0             	movslq %eax,%rsi
  80042169e8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042169ec:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042169f3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042169f7:	48 89 c7             	mov    %rax,%rdi
  80042169fa:	48 b8 2b 70 21 04 80 	movabs $0x800421702b,%rax
  8004216a01:	00 00 00 
  8004216a04:	ff d0                	callq  *%rax
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
  8004216a06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216a0a:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004216a0e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004216a12:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004216a18:	48 89 c2             	mov    %rax,%rdx
  8004216a1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216a1f:	48 29 d0             	sub    %rdx,%rax
  8004216a22:	48 89 c2             	mov    %rax,%rdx
  8004216a25:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216a29:	48 01 d0             	add    %rdx,%rax
  8004216a2c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < numSectionHeaders; i++)
  8004216a30:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004216a37:	eb 24                	jmp    8004216a5d <read_section_headers+0x177>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
  8004216a39:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216a3c:	48 98                	cltq   
  8004216a3e:	48 c1 e0 06          	shl    $0x6,%rax
  8004216a42:	48 89 c2             	mov    %rax,%rdx
  8004216a45:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004216a49:	48 01 c2             	add    %rax,%rdx
  8004216a4c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216a4f:	48 98                	cltq   
  8004216a51:	48 89 94 c5 c0 fe ff 	mov    %rdx,-0x140(%rbp,%rax,8)
  8004216a58:	ff 
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
	for (i = 0; i < numSectionHeaders; i++)
  8004216a59:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216a5d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216a60:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004216a63:	7c d4                	jl     8004216a39 <read_section_headers+0x153>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
  8004216a65:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004216a69:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004216a6d:	0f b7 c0             	movzwl %ax,%eax
  8004216a70:	48 98                	cltq   
  8004216a72:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216a79:	ff 
  8004216a7a:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	temp = kvoffset;
  8004216a7e:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004216a85:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
  8004216a89:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004216a8d:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216a91:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004216a95:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004216a99:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  8004216aa0:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004216aa4:	48 01 f1             	add    %rsi,%rcx
  8004216aa7:	48 89 cf             	mov    %rcx,%rdi
  8004216aaa:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004216ab1:	48 89 c6             	mov    %rax,%rsi
  8004216ab4:	48 b8 2b 70 21 04 80 	movabs $0x800421702b,%rax
  8004216abb:	00 00 00 
  8004216abe:	ff d0                	callq  *%rax
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	
  8004216ac0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004216ac4:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216ac8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004216acc:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216ad0:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  8004216ad4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004216ad8:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004216ade:	48 29 c2             	sub    %rax,%rdx
  8004216ae1:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004216ae5:	48 01 c2             	add    %rax,%rdx
  8004216ae8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216aec:	48 01 d0             	add    %rdx,%rax
  8004216aef:	48 89 45 90          	mov    %rax,-0x70(%rbp)

	for (i = 0; i < numSectionHeaders; i++)
  8004216af3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004216afa:	e9 10 05 00 00       	jmpq   800421700f <read_section_headers+0x729>
	{
		name = (char *)(nametab + secthdr_ptr[i]->sh_name);
  8004216aff:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216b02:	48 98                	cltq   
  8004216b04:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216b0b:	ff 
  8004216b0c:	8b 00                	mov    (%rax),%eax
  8004216b0e:	89 c2                	mov    %eax,%edx
  8004216b10:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004216b14:	48 01 d0             	add    %rdx,%rax
  8004216b17:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		assert(kvoffset % SECTSIZE == 0);
  8004216b1b:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004216b22:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004216b27:	48 85 c0             	test   %rax,%rax
  8004216b2a:	74 35                	je     8004216b61 <read_section_headers+0x27b>
  8004216b2c:	48 b9 66 17 22 04 80 	movabs $0x8004221766,%rcx
  8004216b33:	00 00 00 
  8004216b36:	48 ba 7f 17 22 04 80 	movabs $0x800422177f,%rdx
  8004216b3d:	00 00 00 
  8004216b40:	be 88 00 00 00       	mov    $0x88,%esi
  8004216b45:	48 bf 94 17 22 04 80 	movabs $0x8004221794,%rdi
  8004216b4c:	00 00 00 
  8004216b4f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216b54:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004216b5b:	00 00 00 
  8004216b5e:	41 ff d0             	callq  *%r8
		temp = kvoffset;
  8004216b61:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004216b68:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
  8004216b6c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216b70:	48 be 2b 17 22 04 80 	movabs $0x800422172b,%rsi
  8004216b77:	00 00 00 
  8004216b7a:	48 89 c7             	mov    %rax,%rdi
  8004216b7d:	48 b8 53 0e 21 04 80 	movabs $0x8004210e53,%rax
  8004216b84:	00 00 00 
  8004216b87:	ff d0                	callq  *%rax
  8004216b89:	85 c0                	test   %eax,%eax
  8004216b8b:	0f 85 db 00 00 00    	jne    8004216c6c <read_section_headers+0x386>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004216b91:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216b94:	48 98                	cltq   
  8004216b96:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216b9d:	ff 
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004216b9e:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216ba2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216ba5:	48 98                	cltq   
  8004216ba7:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216bae:	ff 
  8004216baf:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004216bb3:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  8004216bba:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004216bbe:	48 01 f1             	add    %rsi,%rcx
  8004216bc1:	48 89 cf             	mov    %rcx,%rdi
  8004216bc4:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004216bcb:	48 89 c6             	mov    %rax,%rsi
  8004216bce:	48 b8 2b 70 21 04 80 	movabs $0x800421702b,%rax
  8004216bd5:	00 00 00 
  8004216bd8:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_INFO].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004216bda:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216bdd:	48 98                	cltq   
  8004216bdf:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216be6:	ff 
  8004216be7:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216beb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216bee:	48 98                	cltq   
  8004216bf0:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216bf7:	ff 
  8004216bf8:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216bfc:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  8004216c00:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004216c04:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004216c0a:	48 29 c2             	sub    %rax,%rdx
  8004216c0d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004216c11:	48 01 c2             	add    %rax,%rdx
  8004216c14:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216c18:	48 01 c2             	add    %rax,%rdx
  8004216c1b:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216c22:	00 00 00 
  8004216c25:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
  8004216c29:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216c30:	00 00 00 
  8004216c33:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004216c37:	48 89 c2             	mov    %rax,%rdx
  8004216c3a:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216c41:	00 00 00 
  8004216c44:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
  8004216c48:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216c4b:	48 98                	cltq   
  8004216c4d:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216c54:	ff 
  8004216c55:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216c59:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216c60:	00 00 00 
  8004216c63:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004216c67:	e9 9f 03 00 00       	jmpq   800421700b <read_section_headers+0x725>
		}
		else if(!strcmp(name, ".debug_abbrev"))
  8004216c6c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216c70:	48 be 37 17 22 04 80 	movabs $0x8004221737,%rsi
  8004216c77:	00 00 00 
  8004216c7a:	48 89 c7             	mov    %rax,%rdi
  8004216c7d:	48 b8 53 0e 21 04 80 	movabs $0x8004210e53,%rax
  8004216c84:	00 00 00 
  8004216c87:	ff d0                	callq  *%rax
  8004216c89:	85 c0                	test   %eax,%eax
  8004216c8b:	0f 85 e1 00 00 00    	jne    8004216d72 <read_section_headers+0x48c>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004216c91:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216c94:	48 98                	cltq   
  8004216c96:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216c9d:	ff 
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_abbrev"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004216c9e:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216ca2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216ca5:	48 98                	cltq   
  8004216ca7:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216cae:	ff 
  8004216caf:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004216cb3:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  8004216cba:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004216cbe:	48 01 f1             	add    %rsi,%rcx
  8004216cc1:	48 89 cf             	mov    %rcx,%rdi
  8004216cc4:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004216ccb:	48 89 c6             	mov    %rax,%rsi
  8004216cce:	48 b8 2b 70 21 04 80 	movabs $0x800421702b,%rax
  8004216cd5:	00 00 00 
  8004216cd8:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_ABBREV].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004216cda:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216cdd:	48 98                	cltq   
  8004216cdf:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216ce6:	ff 
  8004216ce7:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216ceb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216cee:	48 98                	cltq   
  8004216cf0:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216cf7:	ff 
  8004216cf8:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216cfc:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004216d03:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004216d0a:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004216d10:	48 29 c2             	sub    %rax,%rdx
  8004216d13:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004216d17:	48 01 c2             	add    %rax,%rdx
  8004216d1a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216d1e:	48 01 c2             	add    %rax,%rdx
  8004216d21:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216d28:	00 00 00 
  8004216d2b:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
  8004216d2f:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216d36:	00 00 00 
  8004216d39:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004216d3d:	48 89 c2             	mov    %rax,%rdx
  8004216d40:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216d47:	00 00 00 
  8004216d4a:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
  8004216d4e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216d51:	48 98                	cltq   
  8004216d53:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216d5a:	ff 
  8004216d5b:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216d5f:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216d66:	00 00 00 
  8004216d69:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004216d6d:	e9 99 02 00 00       	jmpq   800421700b <read_section_headers+0x725>
		}
		else if(!strcmp(name, ".debug_line"))
  8004216d72:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216d76:	48 be 4f 17 22 04 80 	movabs $0x800422174f,%rsi
  8004216d7d:	00 00 00 
  8004216d80:	48 89 c7             	mov    %rax,%rdi
  8004216d83:	48 b8 53 0e 21 04 80 	movabs $0x8004210e53,%rax
  8004216d8a:	00 00 00 
  8004216d8d:	ff d0                	callq  *%rax
  8004216d8f:	85 c0                	test   %eax,%eax
  8004216d91:	0f 85 e1 00 00 00    	jne    8004216e78 <read_section_headers+0x592>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004216d97:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216d9a:	48 98                	cltq   
  8004216d9c:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216da3:	ff 
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_line"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004216da4:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216da8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216dab:	48 98                	cltq   
  8004216dad:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216db4:	ff 
  8004216db5:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004216db9:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  8004216dc0:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004216dc4:	48 01 f1             	add    %rsi,%rcx
  8004216dc7:	48 89 cf             	mov    %rcx,%rdi
  8004216dca:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004216dd1:	48 89 c6             	mov    %rax,%rsi
  8004216dd4:	48 b8 2b 70 21 04 80 	movabs $0x800421702b,%rax
  8004216ddb:	00 00 00 
  8004216dde:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_LINE].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004216de0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216de3:	48 98                	cltq   
  8004216de5:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216dec:	ff 
  8004216ded:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216df1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216df4:	48 98                	cltq   
  8004216df6:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216dfd:	ff 
  8004216dfe:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216e02:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8004216e09:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004216e10:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004216e16:	48 29 c2             	sub    %rax,%rdx
  8004216e19:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004216e1d:	48 01 c2             	add    %rax,%rdx
  8004216e20:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216e24:	48 01 c2             	add    %rax,%rdx
  8004216e27:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216e2e:	00 00 00 
  8004216e31:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = (uintptr_t)section_info[DEBUG_LINE].ds_data;
  8004216e35:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216e3c:	00 00 00 
  8004216e3f:	48 8b 40 68          	mov    0x68(%rax),%rax
  8004216e43:	48 89 c2             	mov    %rax,%rdx
  8004216e46:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216e4d:	00 00 00 
  8004216e50:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = secthdr_ptr[i]->sh_size;
  8004216e54:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216e57:	48 98                	cltq   
  8004216e59:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216e60:	ff 
  8004216e61:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216e65:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216e6c:	00 00 00 
  8004216e6f:	48 89 50 78          	mov    %rdx,0x78(%rax)
  8004216e73:	e9 93 01 00 00       	jmpq   800421700b <read_section_headers+0x725>
		}
		else if(!strcmp(name, ".eh_frame"))
  8004216e78:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216e7c:	48 be 45 17 22 04 80 	movabs $0x8004221745,%rsi
  8004216e83:	00 00 00 
  8004216e86:	48 89 c7             	mov    %rax,%rdi
  8004216e89:	48 b8 53 0e 21 04 80 	movabs $0x8004210e53,%rax
  8004216e90:	00 00 00 
  8004216e93:	ff d0                	callq  *%rax
  8004216e95:	85 c0                	test   %eax,%eax
  8004216e97:	75 65                	jne    8004216efe <read_section_headers+0x618>
		{
			section_info[DEBUG_FRAME].ds_data = (uint8_t *)secthdr_ptr[i]->sh_addr;
  8004216e99:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216e9c:	48 98                	cltq   
  8004216e9e:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216ea5:	ff 
  8004216ea6:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216eaa:	48 89 c2             	mov    %rax,%rdx
  8004216ead:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216eb4:	00 00 00 
  8004216eb7:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
  8004216ebb:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216ec2:	00 00 00 
  8004216ec5:	48 8b 40 48          	mov    0x48(%rax),%rax
  8004216ec9:	48 89 c2             	mov    %rax,%rdx
  8004216ecc:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216ed3:	00 00 00 
  8004216ed6:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
  8004216eda:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216edd:	48 98                	cltq   
  8004216edf:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216ee6:	ff 
  8004216ee7:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216eeb:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216ef2:	00 00 00 
  8004216ef5:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004216ef9:	e9 0d 01 00 00       	jmpq   800421700b <read_section_headers+0x725>
		}
		else if(!strcmp(name, ".debug_str"))
  8004216efe:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216f02:	48 be 5b 17 22 04 80 	movabs $0x800422175b,%rsi
  8004216f09:	00 00 00 
  8004216f0c:	48 89 c7             	mov    %rax,%rdi
  8004216f0f:	48 b8 53 0e 21 04 80 	movabs $0x8004210e53,%rax
  8004216f16:	00 00 00 
  8004216f19:	ff d0                	callq  *%rax
  8004216f1b:	85 c0                	test   %eax,%eax
  8004216f1d:	0f 85 e8 00 00 00    	jne    800421700b <read_section_headers+0x725>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004216f23:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216f26:	48 98                	cltq   
  8004216f28:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216f2f:	ff 
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_str"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004216f30:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216f34:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216f37:	48 98                	cltq   
  8004216f39:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216f40:	ff 
  8004216f41:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004216f45:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  8004216f4c:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004216f50:	48 01 f1             	add    %rsi,%rcx
  8004216f53:	48 89 cf             	mov    %rcx,%rdi
  8004216f56:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004216f5d:	48 89 c6             	mov    %rax,%rsi
  8004216f60:	48 b8 2b 70 21 04 80 	movabs $0x800421702b,%rax
  8004216f67:	00 00 00 
  8004216f6a:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_STR].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004216f6c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216f6f:	48 98                	cltq   
  8004216f71:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216f78:	ff 
  8004216f79:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216f7d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216f80:	48 98                	cltq   
  8004216f82:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216f89:	ff 
  8004216f8a:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216f8e:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  8004216f95:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004216f9c:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004216fa2:	48 29 c2             	sub    %rax,%rdx
  8004216fa5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004216fa9:	48 01 c2             	add    %rax,%rdx
  8004216fac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216fb0:	48 01 c2             	add    %rax,%rdx
  8004216fb3:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216fba:	00 00 00 
  8004216fbd:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
  8004216fc4:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216fcb:	00 00 00 
  8004216fce:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004216fd5:	48 89 c2             	mov    %rax,%rdx
  8004216fd8:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004216fdf:	00 00 00 
  8004216fe2:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
  8004216fe9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216fec:	48 98                	cltq   
  8004216fee:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216ff5:	ff 
  8004216ff6:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216ffa:	48 b8 c0 36 23 04 80 	movabs $0x80042336c0,%rax
  8004217001:	00 00 00 
  8004217004:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	temp = kvoffset;
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	

	for (i = 0; i < numSectionHeaders; i++)
  800421700b:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800421700f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004217012:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004217015:	0f 8c e4 fa ff ff    	jl     8004216aff <read_section_headers+0x219>
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
		}
	}
	
	return ((uintptr_t)kvbase + kvoffset);
  800421701b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421701f:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004217026:	48 01 d0             	add    %rdx,%rax
}
  8004217029:	c9                   	leaveq 
  800421702a:	c3                   	retq   

000000800421702b <readseg>:

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint64_t pa, uint64_t count, uint64_t offset, uint64_t* kvoffset)
{
  800421702b:	55                   	push   %rbp
  800421702c:	48 89 e5             	mov    %rsp,%rbp
  800421702f:	48 83 ec 30          	sub    $0x30,%rsp
  8004217033:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004217037:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421703b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800421703f:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	uint64_t end_pa;
	uint64_t orgoff = offset;
  8004217043:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217047:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	end_pa = pa + count;
  800421704b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421704f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217053:	48 01 d0             	add    %rdx,%rax
  8004217056:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	assert(pa % SECTSIZE == 0);	
  800421705a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421705e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004217063:	48 85 c0             	test   %rax,%rax
  8004217066:	74 35                	je     800421709d <readseg+0x72>
  8004217068:	48 b9 a2 17 22 04 80 	movabs $0x80042217a2,%rcx
  800421706f:	00 00 00 
  8004217072:	48 ba 7f 17 22 04 80 	movabs $0x800422177f,%rdx
  8004217079:	00 00 00 
  800421707c:	be c2 00 00 00       	mov    $0xc2,%esi
  8004217081:	48 bf 94 17 22 04 80 	movabs $0x8004221794,%rdi
  8004217088:	00 00 00 
  800421708b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217090:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004217097:	00 00 00 
  800421709a:	41 ff d0             	callq  *%r8
	// round down to sector boundary
	pa &= ~(SECTSIZE - 1);
  800421709d:	48 81 65 e8 00 fe ff 	andq   $0xfffffffffffffe00,-0x18(%rbp)
  80042170a4:	ff 

	// translate from bytes to sectors, and kernel starts at sector 1
	offset = (offset / SECTSIZE) + 1;
  80042170a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042170a9:	48 c1 e8 09          	shr    $0x9,%rax
  80042170ad:	48 83 c0 01          	add    $0x1,%rax
  80042170b1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  80042170b5:	eb 3c                	jmp    80042170f3 <readseg+0xc8>
		readsect((uint8_t*) pa, offset);
  80042170b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042170bb:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042170bf:	48 89 d6             	mov    %rdx,%rsi
  80042170c2:	48 89 c7             	mov    %rax,%rdi
  80042170c5:	48 b8 bd 71 21 04 80 	movabs $0x80042171bd,%rax
  80042170cc:	00 00 00 
  80042170cf:	ff d0                	callq  *%rax
		pa += SECTSIZE;
  80042170d1:	48 81 45 e8 00 02 00 	addq   $0x200,-0x18(%rbp)
  80042170d8:	00 
		*kvoffset += SECTSIZE;
  80042170d9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042170dd:	48 8b 00             	mov    (%rax),%rax
  80042170e0:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  80042170e7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042170eb:	48 89 10             	mov    %rdx,(%rax)
		offset++;
  80042170ee:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	offset = (offset / SECTSIZE) + 1;

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  80042170f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042170f7:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80042170fb:	72 ba                	jb     80042170b7 <readseg+0x8c>
		pa += SECTSIZE;
		*kvoffset += SECTSIZE;
		offset++;
	}

	if(((orgoff % SECTSIZE) + count) > SECTSIZE)
  80042170fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217101:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004217106:	48 89 c2             	mov    %rax,%rdx
  8004217109:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421710d:	48 01 d0             	add    %rdx,%rax
  8004217110:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  8004217116:	76 2f                	jbe    8004217147 <readseg+0x11c>
	{
		readsect((uint8_t*) pa, offset);
  8004217118:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421711c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004217120:	48 89 d6             	mov    %rdx,%rsi
  8004217123:	48 89 c7             	mov    %rax,%rdi
  8004217126:	48 b8 bd 71 21 04 80 	movabs $0x80042171bd,%rax
  800421712d:	00 00 00 
  8004217130:	ff d0                	callq  *%rax
		*kvoffset += SECTSIZE;
  8004217132:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004217136:	48 8b 00             	mov    (%rax),%rax
  8004217139:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004217140:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004217144:	48 89 10             	mov    %rdx,(%rax)
	}
	assert(*kvoffset % SECTSIZE == 0);
  8004217147:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421714b:	48 8b 00             	mov    (%rax),%rax
  800421714e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004217153:	48 85 c0             	test   %rax,%rax
  8004217156:	74 35                	je     800421718d <readseg+0x162>
  8004217158:	48 b9 b5 17 22 04 80 	movabs $0x80042217b5,%rcx
  800421715f:	00 00 00 
  8004217162:	48 ba 7f 17 22 04 80 	movabs $0x800422177f,%rdx
  8004217169:	00 00 00 
  800421716c:	be d8 00 00 00       	mov    $0xd8,%esi
  8004217171:	48 bf 94 17 22 04 80 	movabs $0x8004221794,%rdi
  8004217178:	00 00 00 
  800421717b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217180:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004217187:	00 00 00 
  800421718a:	41 ff d0             	callq  *%r8
}
  800421718d:	90                   	nop
  800421718e:	c9                   	leaveq 
  800421718f:	c3                   	retq   

0000008004217190 <waitdisk>:

void
waitdisk(void)
{
  8004217190:	55                   	push   %rbp
  8004217191:	48 89 e5             	mov    %rsp,%rbp
  8004217194:	48 83 ec 10          	sub    $0x10,%rsp
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
  8004217198:	90                   	nop
  8004217199:	c7 45 fc f7 01 00 00 	movl   $0x1f7,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042171a0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042171a3:	89 c2                	mov    %eax,%edx
  80042171a5:	ec                   	in     (%dx),%al
  80042171a6:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  80042171a9:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042171ad:	0f b6 c0             	movzbl %al,%eax
  80042171b0:	25 c0 00 00 00       	and    $0xc0,%eax
  80042171b5:	83 f8 40             	cmp    $0x40,%eax
  80042171b8:	75 df                	jne    8004217199 <waitdisk+0x9>
		/* do nothing */;
}
  80042171ba:	90                   	nop
  80042171bb:	c9                   	leaveq 
  80042171bc:	c3                   	retq   

00000080042171bd <readsect>:

void
readsect(void *dst, uint64_t offset)
{
  80042171bd:	55                   	push   %rbp
  80042171be:	48 89 e5             	mov    %rsp,%rbp
  80042171c1:	48 83 ec 50          	sub    $0x50,%rsp
  80042171c5:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  80042171c9:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
	// wait for disk to be ready
	waitdisk();
  80042171cd:	48 b8 90 71 21 04 80 	movabs $0x8004217190,%rax
  80042171d4:	00 00 00 
  80042171d7:	ff d0                	callq  *%rax
  80042171d9:	c7 45 fc f2 01 00 00 	movl   $0x1f2,-0x4(%rbp)
  80042171e0:	c6 45 ce 01          	movb   $0x1,-0x32(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042171e4:	0f b6 45 ce          	movzbl -0x32(%rbp),%eax
  80042171e8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042171eb:	ee                   	out    %al,(%dx)

	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
  80042171ec:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042171f0:	0f b6 c0             	movzbl %al,%eax
  80042171f3:	c7 45 f8 f3 01 00 00 	movl   $0x1f3,-0x8(%rbp)
  80042171fa:	88 45 cf             	mov    %al,-0x31(%rbp)
  80042171fd:	0f b6 45 cf          	movzbl -0x31(%rbp),%eax
  8004217201:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004217204:	ee                   	out    %al,(%dx)
	outb(0x1F4, offset >> 8);
  8004217205:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004217209:	48 c1 e8 08          	shr    $0x8,%rax
  800421720d:	0f b6 c0             	movzbl %al,%eax
  8004217210:	c7 45 f4 f4 01 00 00 	movl   $0x1f4,-0xc(%rbp)
  8004217217:	88 45 d0             	mov    %al,-0x30(%rbp)
  800421721a:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
  800421721e:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004217221:	ee                   	out    %al,(%dx)
	outb(0x1F5, offset >> 16);
  8004217222:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004217226:	48 c1 e8 10          	shr    $0x10,%rax
  800421722a:	0f b6 c0             	movzbl %al,%eax
  800421722d:	c7 45 f0 f5 01 00 00 	movl   $0x1f5,-0x10(%rbp)
  8004217234:	88 45 d1             	mov    %al,-0x2f(%rbp)
  8004217237:	0f b6 45 d1          	movzbl -0x2f(%rbp),%eax
  800421723b:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800421723e:	ee                   	out    %al,(%dx)
	outb(0x1F6, (offset >> 24) | 0xE0);
  800421723f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004217243:	48 c1 e8 18          	shr    $0x18,%rax
  8004217247:	83 c8 e0             	or     $0xffffffe0,%eax
  800421724a:	0f b6 c0             	movzbl %al,%eax
  800421724d:	c7 45 ec f6 01 00 00 	movl   $0x1f6,-0x14(%rbp)
  8004217254:	88 45 d2             	mov    %al,-0x2e(%rbp)
  8004217257:	0f b6 45 d2          	movzbl -0x2e(%rbp),%eax
  800421725b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421725e:	ee                   	out    %al,(%dx)
  800421725f:	c7 45 e8 f7 01 00 00 	movl   $0x1f7,-0x18(%rbp)
  8004217266:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
  800421726a:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  800421726e:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004217271:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();
  8004217272:	48 b8 90 71 21 04 80 	movabs $0x8004217190,%rax
  8004217279:	00 00 00 
  800421727c:	ff d0                	callq  *%rax
  800421727e:	c7 45 e4 f0 01 00 00 	movl   $0x1f0,-0x1c(%rbp)
  8004217285:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004217289:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800421728d:	c7 45 d4 80 00 00 00 	movl   $0x80,-0x2c(%rbp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
  8004217294:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004217297:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421729b:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421729e:	48 89 ce             	mov    %rcx,%rsi
  80042172a1:	48 89 f7             	mov    %rsi,%rdi
  80042172a4:	89 c1                	mov    %eax,%ecx
  80042172a6:	fc                   	cld    
  80042172a7:	f2 6d                	repnz insl (%dx),%es:(%rdi)
  80042172a9:	89 c8                	mov    %ecx,%eax
  80042172ab:	48 89 fe             	mov    %rdi,%rsi
  80042172ae:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  80042172b2:	89 45 d4             	mov    %eax,-0x2c(%rbp)

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}
  80042172b5:	90                   	nop
  80042172b6:	c9                   	leaveq 
  80042172b7:	c3                   	retq   

00000080042172b8 <mpentry_start>:
.set pml4, pml4phys

.code16           
.globl mpentry_start
mpentry_start:
	cli
  80042172b8:	fa                   	cli    
	xorw    %ax, %ax
  80042172b9:	31 c0                	xor    %eax,%eax
	movw    %ax, %ds
  80042172bb:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  80042172bd:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  80042172bf:	8e d0                	mov    %eax,%ss
	
	
	lgdt    MPBOOTPHYS(gdt32desc)   // load 32 bit global descritor table
  80042172c1:	0f 01 16             	lgdt   (%rsi)
  80042172c4:	e0 70                	loopne 8004217336 <start64+0x10>
	movl    %cr0, %eax
  80042172c6:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  80042172c9:	66 83 c8 01          	or     $0x1,%ax
	movl    %eax, %cr0
  80042172cd:	0f 22 c0             	mov    %rax,%cr0
	ljmp	$(PROT_MODE_CSEG),$(MPBOOTPHYS(start32))
  80042172d0:	ea                   	(bad)  
  80042172d1:	1d                   	.byte 0x1d
  80042172d2:	70 08                	jo     80042172dc <start32+0x7>
	...

00000080042172d5 <start32>:

.code32
start32:
	
	movw    $(PROT_MODE_DSEG), %ax
  80042172d5:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  80042172d9:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  80042172db:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  80042172dd:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  80042172df:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  80042172e3:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  80042172e5:	8e e8                	mov    %eax,%gs

#ifndef VMM_GUEST
	movl $CR4_PAE,%eax
#else
	movl $(CR4_PAE|CR4_VMXE),%eax
  80042172e7:	b8 20 20 00 00       	mov    $0x2020,%eax
#endif

	movl %eax,%cr4
  80042172ec:	0f 22 e0             	mov    %rax,%cr4
	
	lgdt    MPBOOTPHYS(gdtdesc)
  80042172ef:	0f 01 15 c0 70 00 00 	lgdt   0x70c0(%rip)        # 800421e3b6 <handle_wrmsr+0x40>
	movl    %cr0, %eax
  80042172f6:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  80042172f9:	83 c8 01             	or     $0x1,%eax
	movl    %eax, %cr0
  80042172fc:	0f 22 c0             	mov    %rax,%cr0
	
	# Set up initial page table. We cannot use kern_pgdir yet because
	# we are still running at a low EIP.
	movl    $pml4, %eax
  80042172ff:	b8 00 20 10 00       	mov    $0x102000,%eax
	movl    %eax, %cr3
  8004217304:	0f 22 d8             	mov    %rax,%cr3
	
	# enable the long mode in MSR
	movl $EFER_MSR,%ecx
  8004217307:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
  800421730c:	0f 32                	rdmsr  
	btsl $EFER_LME,%eax
  800421730e:	0f ba e8 08          	bts    $0x8,%eax
	wrmsr
  8004217312:	0f 30                	wrmsr  
	
	# Turn on paging.
	movl    %cr0, %eax
  8004217314:	0f 20 c0             	mov    %cr0,%rax
	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
  8004217317:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl    %eax, %cr0
  800421731c:	0f 22 c0             	mov    %rax,%cr0
	

	ljmpl   $(LONG_MODE_CSEG), $(MPBOOTPHYS(start64))
  800421731f:	ea                   	(bad)  
  8004217320:	6e                   	outsb  %ds:(%rsi),(%dx)
  8004217321:	70 00                	jo     8004217323 <start32+0x4e>
  8004217323:	00 08                	add    %cl,(%rax)
	...

0000008004217326 <start64>:

.code64
start64:
	movw    $(LONG_MODE_DSEG), %ax
  8004217326:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  800421732a:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  800421732c:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  800421732e:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004217330:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004217334:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004217336:	8e e8                	mov    %eax,%gs

	# Switch to the per-cpu stack allocated in boot_aps()
	movabs    mpentry_kstack, %rax
  8004217338:	48 a1 e0 c5 6d 04 80 	movabs 0x80046dc5e0,%rax
  800421733f:	00 00 00 
	movq    %rax,%rsp
  8004217342:	48 89 c4             	mov    %rax,%rsp
	movq    $0x0, %rbp       # nuke frame pointer
  8004217345:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movabs    $mp_main, %rax
  800421734c:	48 b8 2d 04 20 04 80 	movabs $0x800420042d,%rax
  8004217353:	00 00 00 
	call    *%rax
  8004217356:	ff d0                	callq  *%rax

0000008004217358 <spin>:

	# If mp_main returns (it shouldn't), loop.
spin:
	jmp     spin
  8004217358:	eb fe                	jmp    8004217358 <spin>
  800421735a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000008004217360 <gdt>:
	...
  8004217368:	ff                   	(bad)  
  8004217369:	ff 00                	incl   (%rax)
  800421736b:	00 00                	add    %al,(%rax)
  800421736d:	9a                   	(bad)  
  800421736e:	af                   	scas   %es:(%rdi),%eax
  800421736f:	00 ff                	add    %bh,%bh
  8004217371:	ff 00                	incl   (%rax)
  8004217373:	00 00                	add    %al,(%rax)
  8004217375:	92                   	xchg   %eax,%edx
  8004217376:	af                   	scas   %es:(%rdi),%eax
	...

0000008004217378 <gdtdesc>:
  8004217378:	17                   	(bad)  
  8004217379:	00 a8 70 00 00 66    	add    %ch,0x66000070(%rax)
  800421737f:	90                   	nop

0000008004217380 <gdt32>:
	...
  8004217388:	ff                   	(bad)  
  8004217389:	ff 00                	incl   (%rax)
  800421738b:	00 00                	add    %al,(%rax)
  800421738d:	9a                   	(bad)  
  800421738e:	cf                   	iret   
  800421738f:	00 ff                	add    %bh,%bh
  8004217391:	ff 00                	incl   (%rax)
  8004217393:	00 00                	add    %al,(%rax)
  8004217395:	92                   	xchg   %eax,%edx
  8004217396:	cf                   	iret   
	...

0000008004217398 <gdt32desc>:
  8004217398:	17                   	(bad)  
  8004217399:	00 c8                	add    %cl,%al
  800421739b:	70 00                	jo     800421739d <gdt32desc+0x5>
	...

000000800421739e <mpentry_end>:
	.long   MPBOOTPHYS(gdt32)			# address gdt


.globl mpentry_end
mpentry_end:
	nop
  800421739e:	90                   	nop

000000800421739f <sum>:
#define MPIOINTR  0x03  // One per bus interrupt source
#define MPLINTR   0x04  // One per system interrupt source

static uint8_t
sum(void *addr, int len)
{
  800421739f:	55                   	push   %rbp
  80042173a0:	48 89 e5             	mov    %rsp,%rbp
  80042173a3:	48 83 ec 20          	sub    $0x20,%rsp
  80042173a7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042173ab:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int i, sum;

	sum = 0;
  80042173ae:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < len; i++)
  80042173b5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042173bc:	eb 1a                	jmp    80042173d8 <sum+0x39>
		sum += ((uint8_t *)addr)[i];
  80042173be:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042173c1:	48 63 d0             	movslq %eax,%rdx
  80042173c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042173c8:	48 01 d0             	add    %rdx,%rax
  80042173cb:	0f b6 00             	movzbl (%rax),%eax
  80042173ce:	0f b6 c0             	movzbl %al,%eax
  80042173d1:	01 45 f8             	add    %eax,-0x8(%rbp)
sum(void *addr, int len)
{
	int i, sum;

	sum = 0;
	for (i = 0; i < len; i++)
  80042173d4:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042173d8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042173db:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  80042173de:	7c de                	jl     80042173be <sum+0x1f>
		sum += ((uint8_t *)addr)[i];
	return sum;
  80042173e0:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  80042173e3:	c9                   	leaveq 
  80042173e4:	c3                   	retq   

00000080042173e5 <mpsearch1>:

// Look for an MP structure in the len bytes at physical address addr.
static struct mp *
mpsearch1(physaddr_t a, int len)
{
  80042173e5:	55                   	push   %rbp
  80042173e6:	48 89 e5             	mov    %rsp,%rbp
  80042173e9:	48 83 ec 40          	sub    $0x40,%rsp
  80042173ed:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042173f1:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	struct mp *mp = KADDR(a), *end = KADDR(a + len);
  80042173f4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042173f8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042173fc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004217400:	48 c1 e8 0c          	shr    $0xc,%rax
  8004217404:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004217407:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421740a:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004217411:	00 00 00 
  8004217414:	48 8b 00             	mov    (%rax),%rax
  8004217417:	48 39 c2             	cmp    %rax,%rdx
  800421741a:	72 32                	jb     800421744e <mpsearch1+0x69>
  800421741c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004217420:	48 89 c1             	mov    %rax,%rcx
  8004217423:	48 ba d0 17 22 04 80 	movabs $0x80042217d0,%rdx
  800421742a:	00 00 00 
  800421742d:	be 5a 00 00 00       	mov    $0x5a,%esi
  8004217432:	48 bf f3 17 22 04 80 	movabs $0x80042217f3,%rdi
  8004217439:	00 00 00 
  800421743c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217441:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004217448:	00 00 00 
  800421744b:	41 ff d0             	callq  *%r8
  800421744e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004217455:	00 00 00 
  8004217458:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421745c:	48 01 d0             	add    %rdx,%rax
  800421745f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004217463:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004217466:	48 63 d0             	movslq %eax,%rdx
  8004217469:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421746d:	48 01 d0             	add    %rdx,%rax
  8004217470:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004217474:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217478:	48 c1 e8 0c          	shr    $0xc,%rax
  800421747c:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800421747f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004217482:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004217489:	00 00 00 
  800421748c:	48 8b 00             	mov    (%rax),%rax
  800421748f:	48 39 c2             	cmp    %rax,%rdx
  8004217492:	72 32                	jb     80042174c6 <mpsearch1+0xe1>
  8004217494:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217498:	48 89 c1             	mov    %rax,%rcx
  800421749b:	48 ba d0 17 22 04 80 	movabs $0x80042217d0,%rdx
  80042174a2:	00 00 00 
  80042174a5:	be 5a 00 00 00       	mov    $0x5a,%esi
  80042174aa:	48 bf f3 17 22 04 80 	movabs $0x80042217f3,%rdi
  80042174b1:	00 00 00 
  80042174b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042174b9:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042174c0:	00 00 00 
  80042174c3:	41 ff d0             	callq  *%r8
  80042174c6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042174cd:	00 00 00 
  80042174d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042174d4:	48 01 d0             	add    %rdx,%rax
  80042174d7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	for (; mp < end; mp++)
  80042174db:	eb 4d                	jmp    800421752a <mpsearch1+0x145>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  80042174dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042174e1:	ba 04 00 00 00       	mov    $0x4,%edx
  80042174e6:	48 be 03 18 22 04 80 	movabs $0x8004221803,%rsi
  80042174ed:	00 00 00 
  80042174f0:	48 89 c7             	mov    %rax,%rdi
  80042174f3:	48 b8 61 11 21 04 80 	movabs $0x8004211161,%rax
  80042174fa:	00 00 00 
  80042174fd:	ff d0                	callq  *%rax
  80042174ff:	85 c0                	test   %eax,%eax
  8004217501:	75 22                	jne    8004217525 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
  8004217503:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217507:	be 10 00 00 00       	mov    $0x10,%esi
  800421750c:	48 89 c7             	mov    %rax,%rdi
  800421750f:	48 b8 9f 73 21 04 80 	movabs $0x800421739f,%rax
  8004217516:	00 00 00 
  8004217519:	ff d0                	callq  *%rax
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  800421751b:	84 c0                	test   %al,%al
  800421751d:	75 06                	jne    8004217525 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
  800421751f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217523:	eb 14                	jmp    8004217539 <mpsearch1+0x154>
static struct mp *
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
  8004217525:	48 83 45 f8 10       	addq   $0x10,-0x8(%rbp)
  800421752a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421752e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004217532:	72 a9                	jb     80042174dd <mpsearch1+0xf8>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
	return NULL;
  8004217534:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004217539:	c9                   	leaveq 
  800421753a:	c3                   	retq   

000000800421753b <mpsearch>:
// 1) in the first KB of the EBDA;
// 2) if there is no EBDA, in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp *
mpsearch(void)
{
  800421753b:	55                   	push   %rbp
  800421753c:	48 89 e5             	mov    %rsp,%rbp
  800421753f:	48 83 ec 30          	sub    $0x30,%rsp
	struct mp *mp;

	//static_assert(sizeof(*mp) == 32);

	// The BIOS data area lives in 16-bit segment 0x40.
	bda = (uint8_t *) KADDR(0x40 << 4);
  8004217543:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  800421754a:	00 
  800421754b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421754f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004217553:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004217556:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004217559:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004217560:	00 00 00 
  8004217563:	48 8b 00             	mov    (%rax),%rax
  8004217566:	48 39 c2             	cmp    %rax,%rdx
  8004217569:	72 32                	jb     800421759d <mpsearch+0x62>
  800421756b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421756f:	48 89 c1             	mov    %rax,%rcx
  8004217572:	48 ba d0 17 22 04 80 	movabs $0x80042217d0,%rdx
  8004217579:	00 00 00 
  800421757c:	be 72 00 00 00       	mov    $0x72,%esi
  8004217581:	48 bf f3 17 22 04 80 	movabs $0x80042217f3,%rdi
  8004217588:	00 00 00 
  800421758b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217590:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004217597:	00 00 00 
  800421759a:	41 ff d0             	callq  *%r8
  800421759d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042175a4:	00 00 00 
  80042175a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042175ab:	48 01 d0             	add    %rdx,%rax
  80042175ae:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// [MP 4] The 16-bit segment of the EBDA is in the two bytes
	// starting at byte 0x0E of the BDA.  0 if not present.
	if ((p = *(uint16_t *) (bda + 0x0E))) {
  80042175b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042175b6:	48 83 c0 0e          	add    $0xe,%rax
  80042175ba:	0f b7 00             	movzwl (%rax),%eax
  80042175bd:	0f b7 c0             	movzwl %ax,%eax
  80042175c0:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  80042175c3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042175c7:	74 2c                	je     80042175f5 <mpsearch+0xba>
		p <<= 4;	// Translate from segment to PA
  80042175c9:	c1 65 e4 04          	shll   $0x4,-0x1c(%rbp)
		if ((mp = mpsearch1(p, 1024)))
  80042175cd:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042175d0:	be 00 04 00 00       	mov    $0x400,%esi
  80042175d5:	48 89 c7             	mov    %rax,%rdi
  80042175d8:	48 b8 e5 73 21 04 80 	movabs $0x80042173e5,%rax
  80042175df:	00 00 00 
  80042175e2:	ff d0                	callq  *%rax
  80042175e4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042175e8:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042175ed:	74 49                	je     8004217638 <mpsearch+0xfd>
			return mp;
  80042175ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042175f3:	eb 59                	jmp    800421764e <mpsearch+0x113>
	} else {
		// The size of base memory, in KB is in the two bytes
		// starting at 0x13 of the BDA.
		p = *(uint16_t *) (bda + 0x13) * 1024;
  80042175f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042175f9:	48 83 c0 13          	add    $0x13,%rax
  80042175fd:	0f b7 00             	movzwl (%rax),%eax
  8004217600:	0f b7 c0             	movzwl %ax,%eax
  8004217603:	c1 e0 0a             	shl    $0xa,%eax
  8004217606:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if ((mp = mpsearch1(p - 1024, 1024)))
  8004217609:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421760c:	2d 00 04 00 00       	sub    $0x400,%eax
  8004217611:	89 c0                	mov    %eax,%eax
  8004217613:	be 00 04 00 00       	mov    $0x400,%esi
  8004217618:	48 89 c7             	mov    %rax,%rdi
  800421761b:	48 b8 e5 73 21 04 80 	movabs $0x80042173e5,%rax
  8004217622:	00 00 00 
  8004217625:	ff d0                	callq  *%rax
  8004217627:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800421762b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004217630:	74 06                	je     8004217638 <mpsearch+0xfd>
			return mp;
  8004217632:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217636:	eb 16                	jmp    800421764e <mpsearch+0x113>
	}
	return mpsearch1(0xF0000, 0x10000);
  8004217638:	be 00 00 01 00       	mov    $0x10000,%esi
  800421763d:	bf 00 00 0f 00       	mov    $0xf0000,%edi
  8004217642:	48 b8 e5 73 21 04 80 	movabs $0x80042173e5,%rax
  8004217649:	00 00 00 
  800421764c:	ff d0                	callq  *%rax
}
  800421764e:	c9                   	leaveq 
  800421764f:	c3                   	retq   

0000008004217650 <mpconfig>:
// Search for an MP configuration table.  For now, don't accept the
// default configurations (physaddr == 0).
// Check for the correct signature, checksum, and version.
static struct mpconf *
mpconfig(struct mp **pmp)
{
  8004217650:	55                   	push   %rbp
  8004217651:	48 89 e5             	mov    %rsp,%rbp
  8004217654:	48 83 ec 30          	sub    $0x30,%rsp
  8004217658:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	struct mpconf *conf;
	struct mp *mp;

	if ((mp = mpsearch()) == 0)
  800421765c:	48 b8 3b 75 21 04 80 	movabs $0x800421753b,%rax
  8004217663:	00 00 00 
  8004217666:	ff d0                	callq  *%rax
  8004217668:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421766c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004217671:	75 0a                	jne    800421767d <mpconfig+0x2d>
		return NULL;
  8004217673:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217678:	e9 f8 01 00 00       	jmpq   8004217875 <mpconfig+0x225>
	if (mp->physaddr == 0 || mp->type != 0) {
  800421767d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217681:	8b 40 04             	mov    0x4(%rax),%eax
  8004217684:	85 c0                	test   %eax,%eax
  8004217686:	74 0c                	je     8004217694 <mpconfig+0x44>
  8004217688:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421768c:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8004217690:	84 c0                	test   %al,%al
  8004217692:	74 25                	je     80042176b9 <mpconfig+0x69>
		cprintf("SMP: Default configurations not implemented\n");
  8004217694:	48 bf 08 18 22 04 80 	movabs $0x8004221808,%rdi
  800421769b:	00 00 00 
  800421769e:	b8 00 00 00 00       	mov    $0x0,%eax
  80042176a3:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  80042176aa:	00 00 00 
  80042176ad:	ff d2                	callq  *%rdx
		return NULL;
  80042176af:	b8 00 00 00 00       	mov    $0x0,%eax
  80042176b4:	e9 bc 01 00 00       	jmpq   8004217875 <mpconfig+0x225>
	}
	conf = (struct mpconf *) KADDR(mp->physaddr);
  80042176b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042176bd:	8b 40 04             	mov    0x4(%rax),%eax
  80042176c0:	89 c0                	mov    %eax,%eax
  80042176c2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042176c6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042176ca:	48 c1 e8 0c          	shr    $0xc,%rax
  80042176ce:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042176d1:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042176d4:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  80042176db:	00 00 00 
  80042176de:	48 8b 00             	mov    (%rax),%rax
  80042176e1:	48 39 c2             	cmp    %rax,%rdx
  80042176e4:	72 32                	jb     8004217718 <mpconfig+0xc8>
  80042176e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042176ea:	48 89 c1             	mov    %rax,%rcx
  80042176ed:	48 ba d0 17 22 04 80 	movabs $0x80042217d0,%rdx
  80042176f4:	00 00 00 
  80042176f7:	be 93 00 00 00       	mov    $0x93,%esi
  80042176fc:	48 bf f3 17 22 04 80 	movabs $0x80042217f3,%rdi
  8004217703:	00 00 00 
  8004217706:	b8 00 00 00 00       	mov    $0x0,%eax
  800421770b:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004217712:	00 00 00 
  8004217715:	41 ff d0             	callq  *%r8
  8004217718:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421771f:	00 00 00 
  8004217722:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004217726:	48 01 d0             	add    %rdx,%rax
  8004217729:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (memcmp(conf, "PCMP", 4) != 0) {
  800421772d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217731:	ba 04 00 00 00       	mov    $0x4,%edx
  8004217736:	48 be 35 18 22 04 80 	movabs $0x8004221835,%rsi
  800421773d:	00 00 00 
  8004217740:	48 89 c7             	mov    %rax,%rdi
  8004217743:	48 b8 61 11 21 04 80 	movabs $0x8004211161,%rax
  800421774a:	00 00 00 
  800421774d:	ff d0                	callq  *%rax
  800421774f:	85 c0                	test   %eax,%eax
  8004217751:	74 25                	je     8004217778 <mpconfig+0x128>
		cprintf("SMP: Incorrect MP configuration table signature\n");
  8004217753:	48 bf 40 18 22 04 80 	movabs $0x8004221840,%rdi
  800421775a:	00 00 00 
  800421775d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217762:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004217769:	00 00 00 
  800421776c:	ff d2                	callq  *%rdx
		return NULL;
  800421776e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217773:	e9 fd 00 00 00       	jmpq   8004217875 <mpconfig+0x225>
	}
	if (sum(conf, conf->length) != 0) {
  8004217778:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421777c:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  8004217780:	0f b7 d0             	movzwl %ax,%edx
  8004217783:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217787:	89 d6                	mov    %edx,%esi
  8004217789:	48 89 c7             	mov    %rax,%rdi
  800421778c:	48 b8 9f 73 21 04 80 	movabs $0x800421739f,%rax
  8004217793:	00 00 00 
  8004217796:	ff d0                	callq  *%rax
  8004217798:	84 c0                	test   %al,%al
  800421779a:	74 25                	je     80042177c1 <mpconfig+0x171>
		cprintf("SMP: Bad MP configuration checksum\n");
  800421779c:	48 bf 78 18 22 04 80 	movabs $0x8004221878,%rdi
  80042177a3:	00 00 00 
  80042177a6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042177ab:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  80042177b2:	00 00 00 
  80042177b5:	ff d2                	callq  *%rdx
		return NULL;
  80042177b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042177bc:	e9 b4 00 00 00       	jmpq   8004217875 <mpconfig+0x225>
	}
	if (conf->version != 1 && conf->version != 4) {
  80042177c1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042177c5:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042177c9:	3c 01                	cmp    $0x1,%al
  80042177cb:	74 3b                	je     8004217808 <mpconfig+0x1b8>
  80042177cd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042177d1:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042177d5:	3c 04                	cmp    $0x4,%al
  80042177d7:	74 2f                	je     8004217808 <mpconfig+0x1b8>
		cprintf("SMP: Unsupported MP version %d\n", conf->version);
  80042177d9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042177dd:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042177e1:	0f b6 c0             	movzbl %al,%eax
  80042177e4:	89 c6                	mov    %eax,%esi
  80042177e6:	48 bf a0 18 22 04 80 	movabs $0x80042218a0,%rdi
  80042177ed:	00 00 00 
  80042177f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042177f5:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  80042177fc:	00 00 00 
  80042177ff:	ff d2                	callq  *%rdx
		return NULL;
  8004217801:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217806:	eb 6d                	jmp    8004217875 <mpconfig+0x225>
	}
	if (sum((uint8_t *)conf + conf->length, conf->xlength) != conf->xchecksum) {
  8004217808:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421780c:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  8004217810:	0f b7 c0             	movzwl %ax,%eax
  8004217813:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004217817:	0f b7 52 04          	movzwl 0x4(%rdx),%edx
  800421781b:	0f b7 ca             	movzwl %dx,%ecx
  800421781e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004217822:	48 01 ca             	add    %rcx,%rdx
  8004217825:	89 c6                	mov    %eax,%esi
  8004217827:	48 89 d7             	mov    %rdx,%rdi
  800421782a:	48 b8 9f 73 21 04 80 	movabs $0x800421739f,%rax
  8004217831:	00 00 00 
  8004217834:	ff d0                	callq  *%rax
  8004217836:	89 c2                	mov    %eax,%edx
  8004217838:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421783c:	0f b6 40 2a          	movzbl 0x2a(%rax),%eax
  8004217840:	38 c2                	cmp    %al,%dl
  8004217842:	74 22                	je     8004217866 <mpconfig+0x216>
		cprintf("SMP: Bad MP configuration extended checksum\n");
  8004217844:	48 bf c0 18 22 04 80 	movabs $0x80042218c0,%rdi
  800421784b:	00 00 00 
  800421784e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217853:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421785a:	00 00 00 
  800421785d:	ff d2                	callq  *%rdx
		return NULL;
  800421785f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217864:	eb 0f                	jmp    8004217875 <mpconfig+0x225>
	}
	*pmp = mp;
  8004217866:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421786a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421786e:	48 89 10             	mov    %rdx,(%rax)
	return conf;
  8004217871:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  8004217875:	c9                   	leaveq 
  8004217876:	c3                   	retq   

0000008004217877 <mp_init>:

void
mp_init(void)
{
  8004217877:	55                   	push   %rbp
  8004217878:	48 89 e5             	mov    %rsp,%rbp
  800421787b:	48 83 ec 40          	sub    $0x40,%rsp
	struct mpconf *conf;
	struct mpproc *proc;
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
  800421787f:	48 b8 40 e2 6d 04 80 	movabs $0x80046de240,%rax
  8004217886:	00 00 00 
  8004217889:	48 be 20 e0 6d 04 80 	movabs $0x80046de020,%rsi
  8004217890:	00 00 00 
  8004217893:	48 89 30             	mov    %rsi,(%rax)
	if ((conf = mpconfig(&mp)) == 0)
  8004217896:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  800421789a:	48 89 c7             	mov    %rax,%rdi
  800421789d:	48 b8 50 76 21 04 80 	movabs $0x8004217650,%rax
  80042178a4:	00 00 00 
  80042178a7:	ff d0                	callq  *%rax
  80042178a9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042178ad:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042178b2:	0f 84 d3 03 00 00    	je     8004217c8b <mp_init+0x414>
		return;
	ismp = 1;
  80042178b8:	48 b8 00 e0 6d 04 80 	movabs $0x80046de000,%rax
  80042178bf:	00 00 00 
  80042178c2:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	lapicaddr = conf->lapicaddr;
  80042178c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042178cc:	8b 40 24             	mov    0x24(%rax),%eax
  80042178cf:	89 c2                	mov    %eax,%edx
  80042178d1:	48 b8 00 f0 71 04 80 	movabs $0x800471f000,%rax
  80042178d8:	00 00 00 
  80042178db:	48 89 10             	mov    %rdx,(%rax)

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  80042178de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042178e2:	48 83 c0 2c          	add    $0x2c,%rax
  80042178e6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042178ea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042178f1:	e9 17 02 00 00       	jmpq   8004217b0d <mp_init+0x296>
		switch (*p) {
  80042178f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042178fa:	0f b6 00             	movzbl (%rax),%eax
  80042178fd:	0f b6 c0             	movzbl %al,%eax
  8004217900:	85 c0                	test   %eax,%eax
  8004217902:	74 16                	je     800421791a <mp_init+0xa3>
  8004217904:	85 c0                	test   %eax,%eax
  8004217906:	0f 88 b8 01 00 00    	js     8004217ac4 <mp_init+0x24d>
  800421790c:	83 f8 04             	cmp    $0x4,%eax
  800421790f:	0f 8f af 01 00 00    	jg     8004217ac4 <mp_init+0x24d>
  8004217915:	e9 a3 01 00 00       	jmpq   8004217abd <mp_init+0x246>
		case MPPROC:
			proc = (struct mpproc *)p;
  800421791a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421791e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
			if (proc->flags & MPPROC_BOOT) {
  8004217922:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217926:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  800421792a:	0f b6 c0             	movzbl %al,%eax
  800421792d:	83 e0 02             	and    $0x2,%eax
  8004217930:	85 c0                	test   %eax,%eax
  8004217932:	74 51                	je     8004217985 <mp_init+0x10e>
				bootcpu = &cpus[ncpu];
  8004217934:	48 b8 48 e2 6d 04 80 	movabs $0x80046de248,%rax
  800421793b:	00 00 00 
  800421793e:	8b 00                	mov    (%rax),%eax
  8004217940:	48 98                	cltq   
  8004217942:	48 c1 e0 03          	shl    $0x3,%rax
  8004217946:	48 89 c2             	mov    %rax,%rdx
  8004217949:	48 c1 e2 04          	shl    $0x4,%rdx
  800421794d:	48 01 d0             	add    %rdx,%rax
  8004217950:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  8004217957:	00 00 00 
  800421795a:	48 01 c2             	add    %rax,%rdx
  800421795d:	48 b8 40 e2 6d 04 80 	movabs $0x80046de240,%rax
  8004217964:	00 00 00 
  8004217967:	48 89 10             	mov    %rdx,(%rax)
				cprintf("Found boot cpu..\n");
  800421796a:	48 bf ed 18 22 04 80 	movabs $0x80042218ed,%rdi
  8004217971:	00 00 00 
  8004217974:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217979:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004217980:	00 00 00 
  8004217983:	ff d2                	callq  *%rdx
			}
			if (ncpu < NCPU) {
  8004217985:	48 b8 48 e2 6d 04 80 	movabs $0x80046de248,%rax
  800421798c:	00 00 00 
  800421798f:	8b 00                	mov    (%rax),%eax
  8004217991:	83 f8 03             	cmp    $0x3,%eax
  8004217994:	0f 8f f4 00 00 00    	jg     8004217a8e <mp_init+0x217>
				cprintf("type: %d apicid:%d version:%d signature:%x feature:%x flags:%x reserved:%x\n", proc->type, proc->apicid, proc->version, proc->signature, proc->feature, proc->flags, proc->reserved);
  800421799a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421799e:	4c 8d 40 0c          	lea    0xc(%rax),%r8
  80042179a2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042179a6:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  80042179aa:	0f b6 f0             	movzbl %al,%esi
  80042179ad:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042179b1:	8b 78 08             	mov    0x8(%rax),%edi
  80042179b4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042179b8:	4c 8d 50 04          	lea    0x4(%rax),%r10
  80042179bc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042179c0:	0f b6 40 02          	movzbl 0x2(%rax),%eax
  80042179c4:	0f b6 c8             	movzbl %al,%ecx
  80042179c7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042179cb:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80042179cf:	0f b6 d0             	movzbl %al,%edx
  80042179d2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042179d6:	0f b6 00             	movzbl (%rax),%eax
  80042179d9:	0f b6 c0             	movzbl %al,%eax
  80042179dc:	41 50                	push   %r8
  80042179de:	56                   	push   %rsi
  80042179df:	41 89 f9             	mov    %edi,%r9d
  80042179e2:	4d 89 d0             	mov    %r10,%r8
  80042179e5:	89 c6                	mov    %eax,%esi
  80042179e7:	48 bf 00 19 22 04 80 	movabs $0x8004221900,%rdi
  80042179ee:	00 00 00 
  80042179f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042179f6:	49 ba 09 9d 20 04 80 	movabs $0x8004209d09,%r10
  80042179fd:	00 00 00 
  8004217a00:	41 ff d2             	callq  *%r10
  8004217a03:	48 83 c4 10          	add    $0x10,%rsp
				if (proc->flags & MPROC_EN) {
  8004217a07:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217a0b:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  8004217a0f:	0f b6 c0             	movzbl %al,%eax
  8004217a12:	83 e0 01             	and    $0x1,%eax
  8004217a15:	85 c0                	test   %eax,%eax
  8004217a17:	74 58                	je     8004217a71 <mp_init+0x1fa>
					cpus[ncpu].cpu_id = ncpu;
  8004217a19:	48 b8 48 e2 6d 04 80 	movabs $0x80046de248,%rax
  8004217a20:	00 00 00 
  8004217a23:	8b 08                	mov    (%rax),%ecx
  8004217a25:	48 b8 48 e2 6d 04 80 	movabs $0x80046de248,%rax
  8004217a2c:	00 00 00 
  8004217a2f:	8b 00                	mov    (%rax),%eax
  8004217a31:	89 c6                	mov    %eax,%esi
  8004217a33:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  8004217a3a:	00 00 00 
  8004217a3d:	48 63 c1             	movslq %ecx,%rax
  8004217a40:	48 c1 e0 03          	shl    $0x3,%rax
  8004217a44:	48 89 c1             	mov    %rax,%rcx
  8004217a47:	48 c1 e1 04          	shl    $0x4,%rcx
  8004217a4b:	48 01 c8             	add    %rcx,%rax
  8004217a4e:	48 01 d0             	add    %rdx,%rax
  8004217a51:	40 88 30             	mov    %sil,(%rax)
					ncpu++;
  8004217a54:	48 b8 48 e2 6d 04 80 	movabs $0x80046de248,%rax
  8004217a5b:	00 00 00 
  8004217a5e:	8b 00                	mov    (%rax),%eax
  8004217a60:	8d 50 01             	lea    0x1(%rax),%edx
  8004217a63:	48 b8 48 e2 6d 04 80 	movabs $0x80046de248,%rax
  8004217a6a:	00 00 00 
  8004217a6d:	89 10                	mov    %edx,(%rax)
  8004217a6f:	eb 45                	jmp    8004217ab6 <mp_init+0x23f>
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
  8004217a71:	48 bf 50 19 22 04 80 	movabs $0x8004221950,%rdi
  8004217a78:	00 00 00 
  8004217a7b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217a80:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004217a87:	00 00 00 
  8004217a8a:	ff d2                	callq  *%rdx
  8004217a8c:	eb 28                	jmp    8004217ab6 <mp_init+0x23f>
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
					proc->apicid);
  8004217a8e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217a92:	0f b6 40 01          	movzbl 0x1(%rax),%eax
					ncpu++;
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
  8004217a96:	0f b6 c0             	movzbl %al,%eax
  8004217a99:	89 c6                	mov    %eax,%esi
  8004217a9b:	48 bf 80 19 22 04 80 	movabs $0x8004221980,%rdi
  8004217aa2:	00 00 00 
  8004217aa5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217aaa:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004217ab1:	00 00 00 
  8004217ab4:	ff d2                	callq  *%rdx
					proc->apicid);
			}
			p += sizeof(struct mpproc);
  8004217ab6:	48 83 45 f8 14       	addq   $0x14,-0x8(%rbp)
			continue;
  8004217abb:	eb 4c                	jmp    8004217b09 <mp_init+0x292>
		case MPBUS:
		case MPIOAPIC:
		case MPIOINTR:
		case MPLINTR:

		p += 8;
  8004217abd:	48 83 45 f8 08       	addq   $0x8,-0x8(%rbp)
		continue;
  8004217ac2:	eb 45                	jmp    8004217b09 <mp_init+0x292>
		default:
			cprintf("mpinit: unknown config type %x\n", *p);
  8004217ac4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217ac8:	0f b6 00             	movzbl (%rax),%eax
  8004217acb:	0f b6 c0             	movzbl %al,%eax
  8004217ace:	89 c6                	mov    %eax,%esi
  8004217ad0:	48 bf a8 19 22 04 80 	movabs $0x80042219a8,%rdi
  8004217ad7:	00 00 00 
  8004217ada:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217adf:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004217ae6:	00 00 00 
  8004217ae9:	ff d2                	callq  *%rdx
			ismp = 0;
  8004217aeb:	48 b8 00 e0 6d 04 80 	movabs $0x80046de000,%rax
  8004217af2:	00 00 00 
  8004217af5:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
			i = conf->entry;
  8004217afb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217aff:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004217b03:	0f b7 c0             	movzwl %ax,%eax
  8004217b06:	89 45 f4             	mov    %eax,-0xc(%rbp)
	if ((conf = mpconfig(&mp)) == 0)
		return;
	ismp = 1;
	lapicaddr = conf->lapicaddr;

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  8004217b09:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004217b0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217b11:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004217b15:	0f b7 c0             	movzwl %ax,%eax
  8004217b18:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8004217b1b:	0f 87 d5 fd ff ff    	ja     80042178f6 <mp_init+0x7f>
			i = conf->entry;
		}
	}


	for (i=0; i< NCPU; ++i) {
  8004217b21:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004217b28:	eb 52                	jmp    8004217b7c <mp_init+0x305>
		cpus[i].is_vmx_root = false;
  8004217b2a:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  8004217b31:	00 00 00 
  8004217b34:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004217b37:	48 c1 e0 03          	shl    $0x3,%rax
  8004217b3b:	48 89 c1             	mov    %rax,%rcx
  8004217b3e:	48 c1 e1 04          	shl    $0x4,%rcx
  8004217b42:	48 01 c8             	add    %rcx,%rax
  8004217b45:	48 01 d0             	add    %rdx,%rax
  8004217b48:	48 83 c0 78          	add    $0x78,%rax
  8004217b4c:	c6 00 00             	movb   $0x0,(%rax)
		cpus[i].vmxon_region = 0;
  8004217b4f:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  8004217b56:	00 00 00 
  8004217b59:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004217b5c:	48 c1 e0 03          	shl    $0x3,%rax
  8004217b60:	48 89 c1             	mov    %rax,%rcx
  8004217b63:	48 c1 e1 04          	shl    $0x4,%rcx
  8004217b67:	48 01 c8             	add    %rcx,%rax
  8004217b6a:	48 01 d0             	add    %rdx,%rax
  8004217b6d:	48 83 e8 80          	sub    $0xffffffffffffff80,%rax
  8004217b71:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			i = conf->entry;
		}
	}


	for (i=0; i< NCPU; ++i) {
  8004217b78:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004217b7c:	83 7d f4 03          	cmpl   $0x3,-0xc(%rbp)
  8004217b80:	76 a8                	jbe    8004217b2a <mp_init+0x2b3>
		cpus[i].is_vmx_root = false;
		cpus[i].vmxon_region = 0;
	}


	bootcpu->cpu_status = CPU_STARTED;
  8004217b82:	48 b8 40 e2 6d 04 80 	movabs $0x80046de240,%rax
  8004217b89:	00 00 00 
  8004217b8c:	48 8b 00             	mov    (%rax),%rax
  8004217b8f:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
	if (!ismp) {
  8004217b96:	48 b8 00 e0 6d 04 80 	movabs $0x80046de000,%rax
  8004217b9d:	00 00 00 
  8004217ba0:	8b 00                	mov    (%rax),%eax
  8004217ba2:	85 c0                	test   %eax,%eax
  8004217ba4:	75 41                	jne    8004217be7 <mp_init+0x370>
		// Didn't like what we found; fall back to no MP.
		ncpu = 1;
  8004217ba6:	48 b8 48 e2 6d 04 80 	movabs $0x80046de248,%rax
  8004217bad:	00 00 00 
  8004217bb0:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
		lapicaddr = 0;
  8004217bb6:	48 b8 00 f0 71 04 80 	movabs $0x800471f000,%rax
  8004217bbd:	00 00 00 
  8004217bc0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		cprintf("SMP: configuration not found, SMP disabled\n");
  8004217bc7:	48 bf c8 19 22 04 80 	movabs $0x80042219c8,%rdi
  8004217bce:	00 00 00 
  8004217bd1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217bd6:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004217bdd:	00 00 00 
  8004217be0:	ff d2                	callq  *%rdx
		return;
  8004217be2:	e9 a5 00 00 00       	jmpq   8004217c8c <mp_init+0x415>
	}
	cprintf("SMP: CPU %d found %d CPU(s)\n", bootcpu->cpu_id,  ncpu);
  8004217be7:	48 b8 48 e2 6d 04 80 	movabs $0x80046de248,%rax
  8004217bee:	00 00 00 
  8004217bf1:	8b 10                	mov    (%rax),%edx
  8004217bf3:	48 b8 40 e2 6d 04 80 	movabs $0x80046de240,%rax
  8004217bfa:	00 00 00 
  8004217bfd:	48 8b 00             	mov    (%rax),%rax
  8004217c00:	0f b6 00             	movzbl (%rax),%eax
  8004217c03:	0f b6 c0             	movzbl %al,%eax
  8004217c06:	89 c6                	mov    %eax,%esi
  8004217c08:	48 bf f4 19 22 04 80 	movabs $0x80042219f4,%rdi
  8004217c0f:	00 00 00 
  8004217c12:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217c17:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  8004217c1e:	00 00 00 
  8004217c21:	ff d1                	callq  *%rcx

	if (mp->imcrp) {
  8004217c23:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004217c27:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  8004217c2b:	84 c0                	test   %al,%al
  8004217c2d:	74 5d                	je     8004217c8c <mp_init+0x415>
		// [MP 3.2.6.1] If the hardware implements PIC mode,
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
  8004217c2f:	48 bf 18 1a 22 04 80 	movabs $0x8004221a18,%rdi
  8004217c36:	00 00 00 
  8004217c39:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217c3e:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004217c45:	00 00 00 
  8004217c48:	ff d2                	callq  *%rdx
  8004217c4a:	c7 45 dc 22 00 00 00 	movl   $0x22,-0x24(%rbp)
  8004217c51:	c6 45 d1 70          	movb   $0x70,-0x2f(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004217c55:	0f b6 45 d1          	movzbl -0x2f(%rbp),%eax
  8004217c59:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004217c5c:	ee                   	out    %al,(%dx)
  8004217c5d:	c7 45 d8 23 00 00 00 	movl   $0x23,-0x28(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004217c64:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8004217c67:	89 c2                	mov    %eax,%edx
  8004217c69:	ec                   	in     (%dx),%al
  8004217c6a:	88 45 d2             	mov    %al,-0x2e(%rbp)
	return data;
  8004217c6d:	0f b6 45 d2          	movzbl -0x2e(%rbp),%eax
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  8004217c71:	83 c8 01             	or     $0x1,%eax
  8004217c74:	0f b6 c0             	movzbl %al,%eax
  8004217c77:	c7 45 d4 23 00 00 00 	movl   $0x23,-0x2c(%rbp)
  8004217c7e:	88 45 d3             	mov    %al,-0x2d(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004217c81:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004217c85:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004217c88:	ee                   	out    %al,(%dx)
  8004217c89:	eb 01                	jmp    8004217c8c <mp_init+0x415>
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
	if ((conf = mpconfig(&mp)) == 0)
		return;
  8004217c8b:	90                   	nop
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
	}
}
  8004217c8c:	c9                   	leaveq 
  8004217c8d:	c3                   	retq   

0000008004217c8e <lapicw>:
physaddr_t lapicaddr;        // Initialized in mpconfig.c
volatile uint32_t *lapic;

static void
lapicw(int index, int value)
{
  8004217c8e:	55                   	push   %rbp
  8004217c8f:	48 89 e5             	mov    %rsp,%rbp
  8004217c92:	48 83 ec 08          	sub    $0x8,%rsp
  8004217c96:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004217c99:	89 75 f8             	mov    %esi,-0x8(%rbp)
	lapic[index] = value;
  8004217c9c:	48 b8 08 f0 71 04 80 	movabs $0x800471f008,%rax
  8004217ca3:	00 00 00 
  8004217ca6:	48 8b 00             	mov    (%rax),%rax
  8004217ca9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004217cac:	48 63 d2             	movslq %edx,%rdx
  8004217caf:	48 c1 e2 02          	shl    $0x2,%rdx
  8004217cb3:	48 01 c2             	add    %rax,%rdx
  8004217cb6:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004217cb9:	89 02                	mov    %eax,(%rdx)
	lapic[ID];  // wait for write to finish, by reading
  8004217cbb:	48 b8 08 f0 71 04 80 	movabs $0x800471f008,%rax
  8004217cc2:	00 00 00 
  8004217cc5:	48 8b 00             	mov    (%rax),%rax
  8004217cc8:	48 83 c0 20          	add    $0x20,%rax
  8004217ccc:	8b 00                	mov    (%rax),%eax
}
  8004217cce:	90                   	nop
  8004217ccf:	c9                   	leaveq 
  8004217cd0:	c3                   	retq   

0000008004217cd1 <lapic_init>:

void
lapic_init(void)
{
  8004217cd1:	55                   	push   %rbp
  8004217cd2:	48 89 e5             	mov    %rsp,%rbp
	if (!lapicaddr)
  8004217cd5:	48 b8 00 f0 71 04 80 	movabs $0x800471f000,%rax
  8004217cdc:	00 00 00 
  8004217cdf:	48 8b 00             	mov    (%rax),%rax
  8004217ce2:	48 85 c0             	test   %rax,%rax
  8004217ce5:	0f 84 df 01 00 00    	je     8004217eca <lapic_init+0x1f9>
		return;

	// lapicaddr is the physical address of the LAPIC's 4K MMIO
	// region.  Map it in to virtual memory so we can access it.
	lapic = mmio_map_region(lapicaddr, 4096);
  8004217ceb:	48 b8 00 f0 71 04 80 	movabs $0x800471f000,%rax
  8004217cf2:	00 00 00 
  8004217cf5:	48 8b 00             	mov    (%rax),%rax
  8004217cf8:	be 00 10 00 00       	mov    $0x1000,%esi
  8004217cfd:	48 89 c7             	mov    %rax,%rdi
  8004217d00:	48 b8 c0 3f 20 04 80 	movabs $0x8004203fc0,%rax
  8004217d07:	00 00 00 
  8004217d0a:	ff d0                	callq  *%rax
  8004217d0c:	48 89 c2             	mov    %rax,%rdx
  8004217d0f:	48 b8 08 f0 71 04 80 	movabs $0x800471f008,%rax
  8004217d16:	00 00 00 
  8004217d19:	48 89 10             	mov    %rdx,(%rax)

	// Enable local APIC; set spurious interrupt vector.
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));
  8004217d1c:	be 27 01 00 00       	mov    $0x127,%esi
  8004217d21:	bf 3c 00 00 00       	mov    $0x3c,%edi
  8004217d26:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  8004217d2d:	00 00 00 
  8004217d30:	ff d0                	callq  *%rax

	// The timer repeatedly counts down at bus frequency
	// from lapic[TICR] and then issues an interrupt.  
	// If we cared more about precise timekeeping,
	// TICR would be calibrated using an external time source.
	lapicw(TDCR, X1);
  8004217d32:	be 0b 00 00 00       	mov    $0xb,%esi
  8004217d37:	bf f8 00 00 00       	mov    $0xf8,%edi
  8004217d3c:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  8004217d43:	00 00 00 
  8004217d46:	ff d0                	callq  *%rax
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
  8004217d48:	be 20 00 02 00       	mov    $0x20020,%esi
  8004217d4d:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004217d52:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  8004217d59:	00 00 00 
  8004217d5c:	ff d0                	callq  *%rax
	lapicw(TICR, 10000000); 
  8004217d5e:	be 80 96 98 00       	mov    $0x989680,%esi
  8004217d63:	bf e0 00 00 00       	mov    $0xe0,%edi
  8004217d68:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  8004217d6f:	00 00 00 
  8004217d72:	ff d0                	callq  *%rax
	//
	// According to Intel MP Specification, the BIOS should initialize
	// BSP's local APIC in Virtual Wire Mode, in which 8259A's
	// INTR is virtually connected to BSP's LINTIN0. In this mode,
	// we do not need to program the IOAPIC.
	if (thiscpu != bootcpu)
  8004217d74:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  8004217d7b:	00 00 00 
  8004217d7e:	ff d0                	callq  *%rax
  8004217d80:	48 98                	cltq   
  8004217d82:	48 c1 e0 03          	shl    $0x3,%rax
  8004217d86:	48 89 c2             	mov    %rax,%rdx
  8004217d89:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217d8d:	48 01 d0             	add    %rdx,%rax
  8004217d90:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  8004217d97:	00 00 00 
  8004217d9a:	48 01 c2             	add    %rax,%rdx
  8004217d9d:	48 b8 40 e2 6d 04 80 	movabs $0x80046de240,%rax
  8004217da4:	00 00 00 
  8004217da7:	48 8b 00             	mov    (%rax),%rax
  8004217daa:	48 39 c2             	cmp    %rax,%rdx
  8004217dad:	74 16                	je     8004217dc5 <lapic_init+0xf4>
		lapicw(LINT0, MASKED);
  8004217daf:	be 00 00 01 00       	mov    $0x10000,%esi
  8004217db4:	bf d4 00 00 00       	mov    $0xd4,%edi
  8004217db9:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  8004217dc0:	00 00 00 
  8004217dc3:	ff d0                	callq  *%rax

	// Disable NMI (LINT1) on all CPUs
	lapicw(LINT1, MASKED);
  8004217dc5:	be 00 00 01 00       	mov    $0x10000,%esi
  8004217dca:	bf d8 00 00 00       	mov    $0xd8,%edi
  8004217dcf:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  8004217dd6:	00 00 00 
  8004217dd9:	ff d0                	callq  *%rax

	// Disable performance counter overflow interrupts
	// on machines that provide that interrupt entry.
	if (((lapic[VER]>>16) & 0xFF) >= 4)
  8004217ddb:	48 b8 08 f0 71 04 80 	movabs $0x800471f008,%rax
  8004217de2:	00 00 00 
  8004217de5:	48 8b 00             	mov    (%rax),%rax
  8004217de8:	48 83 c0 30          	add    $0x30,%rax
  8004217dec:	8b 00                	mov    (%rax),%eax
  8004217dee:	c1 e8 10             	shr    $0x10,%eax
  8004217df1:	0f b6 c0             	movzbl %al,%eax
  8004217df4:	83 f8 03             	cmp    $0x3,%eax
  8004217df7:	76 16                	jbe    8004217e0f <lapic_init+0x13e>
		lapicw(PCINT, MASKED);
  8004217df9:	be 00 00 01 00       	mov    $0x10000,%esi
  8004217dfe:	bf d0 00 00 00       	mov    $0xd0,%edi
  8004217e03:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  8004217e0a:	00 00 00 
  8004217e0d:	ff d0                	callq  *%rax

	// Map error interrupt to IRQ_ERROR.
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);
  8004217e0f:	be 33 00 00 00       	mov    $0x33,%esi
  8004217e14:	bf dc 00 00 00       	mov    $0xdc,%edi
  8004217e19:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  8004217e20:	00 00 00 
  8004217e23:	ff d0                	callq  *%rax

	// Clear error status register (requires back-to-back writes).
	lapicw(ESR, 0);
  8004217e25:	be 00 00 00 00       	mov    $0x0,%esi
  8004217e2a:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004217e2f:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  8004217e36:	00 00 00 
  8004217e39:	ff d0                	callq  *%rax
	lapicw(ESR, 0);
  8004217e3b:	be 00 00 00 00       	mov    $0x0,%esi
  8004217e40:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004217e45:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  8004217e4c:	00 00 00 
  8004217e4f:	ff d0                	callq  *%rax

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);
  8004217e51:	be 00 00 00 00       	mov    $0x0,%esi
  8004217e56:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004217e5b:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  8004217e62:	00 00 00 
  8004217e65:	ff d0                	callq  *%rax

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
  8004217e67:	be 00 00 00 00       	mov    $0x0,%esi
  8004217e6c:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004217e71:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  8004217e78:	00 00 00 
  8004217e7b:	ff d0                	callq  *%rax
	lapicw(ICRLO, BCAST | INIT | LEVEL);
  8004217e7d:	be 00 85 08 00       	mov    $0x88500,%esi
  8004217e82:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004217e87:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  8004217e8e:	00 00 00 
  8004217e91:	ff d0                	callq  *%rax
	while(lapic[ICRLO] & DELIVS)
  8004217e93:	90                   	nop
  8004217e94:	48 b8 08 f0 71 04 80 	movabs $0x800471f008,%rax
  8004217e9b:	00 00 00 
  8004217e9e:	48 8b 00             	mov    (%rax),%rax
  8004217ea1:	48 05 00 03 00 00    	add    $0x300,%rax
  8004217ea7:	8b 00                	mov    (%rax),%eax
  8004217ea9:	25 00 10 00 00       	and    $0x1000,%eax
  8004217eae:	85 c0                	test   %eax,%eax
  8004217eb0:	75 e2                	jne    8004217e94 <lapic_init+0x1c3>
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
  8004217eb2:	be 00 00 00 00       	mov    $0x0,%esi
  8004217eb7:	bf 20 00 00 00       	mov    $0x20,%edi
  8004217ebc:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  8004217ec3:	00 00 00 
  8004217ec6:	ff d0                	callq  *%rax
  8004217ec8:	eb 01                	jmp    8004217ecb <lapic_init+0x1fa>

void
lapic_init(void)
{
	if (!lapicaddr)
		return;
  8004217eca:	90                   	nop
	while(lapic[ICRLO] & DELIVS)
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
}
  8004217ecb:	5d                   	pop    %rbp
  8004217ecc:	c3                   	retq   

0000008004217ecd <cpunum>:

int
cpunum(void)
{
  8004217ecd:	55                   	push   %rbp
  8004217ece:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004217ed1:	48 b8 08 f0 71 04 80 	movabs $0x800471f008,%rax
  8004217ed8:	00 00 00 
  8004217edb:	48 8b 00             	mov    (%rax),%rax
  8004217ede:	48 85 c0             	test   %rax,%rax
  8004217ee1:	74 18                	je     8004217efb <cpunum+0x2e>
		return lapic[ID] >> 24;
  8004217ee3:	48 b8 08 f0 71 04 80 	movabs $0x800471f008,%rax
  8004217eea:	00 00 00 
  8004217eed:	48 8b 00             	mov    (%rax),%rax
  8004217ef0:	48 83 c0 20          	add    $0x20,%rax
  8004217ef4:	8b 00                	mov    (%rax),%eax
  8004217ef6:	c1 e8 18             	shr    $0x18,%eax
  8004217ef9:	eb 05                	jmp    8004217f00 <cpunum+0x33>
	return 0;
  8004217efb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004217f00:	5d                   	pop    %rbp
  8004217f01:	c3                   	retq   

0000008004217f02 <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  8004217f02:	55                   	push   %rbp
  8004217f03:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004217f06:	48 b8 08 f0 71 04 80 	movabs $0x800471f008,%rax
  8004217f0d:	00 00 00 
  8004217f10:	48 8b 00             	mov    (%rax),%rax
  8004217f13:	48 85 c0             	test   %rax,%rax
  8004217f16:	74 16                	je     8004217f2e <lapic_eoi+0x2c>
		lapicw(EOI, 0);
  8004217f18:	be 00 00 00 00       	mov    $0x0,%esi
  8004217f1d:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004217f22:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  8004217f29:	00 00 00 
  8004217f2c:	ff d0                	callq  *%rax
}
  8004217f2e:	90                   	nop
  8004217f2f:	5d                   	pop    %rbp
  8004217f30:	c3                   	retq   

0000008004217f31 <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  8004217f31:	55                   	push   %rbp
  8004217f32:	48 89 e5             	mov    %rsp,%rbp
  8004217f35:	48 83 ec 08          	sub    $0x8,%rsp
  8004217f39:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
  8004217f3c:	90                   	nop
  8004217f3d:	c9                   	leaveq 
  8004217f3e:	c3                   	retq   

0000008004217f3f <lapic_startap>:

// Start additional processor running entry code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uint8_t apicid, uint32_t addr)
{
  8004217f3f:	55                   	push   %rbp
  8004217f40:	48 89 e5             	mov    %rsp,%rbp
  8004217f43:	48 83 ec 40          	sub    $0x40,%rsp
  8004217f47:	89 f8                	mov    %edi,%eax
  8004217f49:	89 75 c8             	mov    %esi,-0x38(%rbp)
  8004217f4c:	88 45 cc             	mov    %al,-0x34(%rbp)
  8004217f4f:	c7 45 f8 70 00 00 00 	movl   $0x70,-0x8(%rbp)
  8004217f56:	c6 45 da 0f          	movb   $0xf,-0x26(%rbp)
  8004217f5a:	0f b6 45 da          	movzbl -0x26(%rbp),%eax
  8004217f5e:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004217f61:	ee                   	out    %al,(%dx)
  8004217f62:	c7 45 dc 71 00 00 00 	movl   $0x71,-0x24(%rbp)
  8004217f69:	c6 45 db 0a          	movb   $0xa,-0x25(%rbp)
  8004217f6d:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004217f71:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004217f74:	ee                   	out    %al,(%dx)
	// "The BSP must initialize CMOS shutdown code to 0AH
	// and the warm reset vector (DWORD based at 40:67) to point at
	// the AP startup code prior to the [universal startup algorithm]."
	outb(IO_RTC, 0xF);  // offset 0xF is shutdown code
	outb(IO_RTC+1, 0x0A);
	wrv = (uint16_t *)KADDR((0x40 << 4 | 0x67));  // Warm reset vector
  8004217f75:	48 c7 45 f0 67 04 00 	movq   $0x467,-0x10(%rbp)
  8004217f7c:	00 
  8004217f7d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004217f81:	48 c1 e8 0c          	shr    $0xc,%rax
  8004217f85:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004217f88:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004217f8b:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004217f92:	00 00 00 
  8004217f95:	48 8b 00             	mov    (%rax),%rax
  8004217f98:	48 39 c2             	cmp    %rax,%rdx
  8004217f9b:	72 32                	jb     8004217fcf <lapic_startap+0x90>
  8004217f9d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004217fa1:	48 89 c1             	mov    %rax,%rcx
  8004217fa4:	48 ba 60 1a 22 04 80 	movabs $0x8004221a60,%rdx
  8004217fab:	00 00 00 
  8004217fae:	be 99 00 00 00       	mov    $0x99,%esi
  8004217fb3:	48 bf 83 1a 22 04 80 	movabs $0x8004221a83,%rdi
  8004217fba:	00 00 00 
  8004217fbd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217fc2:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004217fc9:	00 00 00 
  8004217fcc:	41 ff d0             	callq  *%r8
  8004217fcf:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004217fd6:	00 00 00 
  8004217fd9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004217fdd:	48 01 d0             	add    %rdx,%rax
  8004217fe0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	wrv[0] = 0;
  8004217fe4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217fe8:	66 c7 00 00 00       	movw   $0x0,(%rax)
	wrv[1] = addr >> 4;
  8004217fed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217ff1:	48 83 c0 02          	add    $0x2,%rax
  8004217ff5:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004217ff8:	c1 ea 04             	shr    $0x4,%edx
  8004217ffb:	66 89 10             	mov    %dx,(%rax)

	// "Universal startup algorithm."
	// Send INIT (level-triggered) interrupt to reset other CPU.
	lapicw(ICRHI, apicid << 24);
  8004217ffe:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004218002:	c1 e0 18             	shl    $0x18,%eax
  8004218005:	89 c6                	mov    %eax,%esi
  8004218007:	bf c4 00 00 00       	mov    $0xc4,%edi
  800421800c:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  8004218013:	00 00 00 
  8004218016:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL | ASSERT);
  8004218018:	be 00 c5 00 00       	mov    $0xc500,%esi
  800421801d:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004218022:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  8004218029:	00 00 00 
  800421802c:	ff d0                	callq  *%rax
	microdelay(200);
  800421802e:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004218033:	48 b8 31 7f 21 04 80 	movabs $0x8004217f31,%rax
  800421803a:	00 00 00 
  800421803d:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL);
  800421803f:	be 00 85 00 00       	mov    $0x8500,%esi
  8004218044:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004218049:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  8004218050:	00 00 00 
  8004218053:	ff d0                	callq  *%rax
	microdelay(100);    // should be 10ms, but too slow in Bochs!
  8004218055:	bf 64 00 00 00       	mov    $0x64,%edi
  800421805a:	48 b8 31 7f 21 04 80 	movabs $0x8004217f31,%rax
  8004218061:	00 00 00 
  8004218064:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004218066:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421806d:	eb 4b                	jmp    80042180ba <lapic_startap+0x17b>
		lapicw(ICRHI, apicid << 24);
  800421806f:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004218073:	c1 e0 18             	shl    $0x18,%eax
  8004218076:	89 c6                	mov    %eax,%esi
  8004218078:	bf c4 00 00 00       	mov    $0xc4,%edi
  800421807d:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  8004218084:	00 00 00 
  8004218087:	ff d0                	callq  *%rax
		lapicw(ICRLO, STARTUP | (addr >> 12));
  8004218089:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421808c:	c1 e8 0c             	shr    $0xc,%eax
  800421808f:	80 cc 06             	or     $0x6,%ah
  8004218092:	89 c6                	mov    %eax,%esi
  8004218094:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004218099:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  80042180a0:	00 00 00 
  80042180a3:	ff d0                	callq  *%rax
		microdelay(200);
  80042180a5:	bf c8 00 00 00       	mov    $0xc8,%edi
  80042180aa:	48 b8 31 7f 21 04 80 	movabs $0x8004217f31,%rax
  80042180b1:	00 00 00 
  80042180b4:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  80042180b6:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042180ba:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  80042180be:	7e af                	jle    800421806f <lapic_startap+0x130>
		lapicw(ICRHI, apicid << 24);
		lapicw(ICRLO, STARTUP | (addr >> 12));
		microdelay(200);
	}
}
  80042180c0:	90                   	nop
  80042180c1:	c9                   	leaveq 
  80042180c2:	c3                   	retq   

00000080042180c3 <lapic_ipi>:

void
lapic_ipi(int vector)
{
  80042180c3:	55                   	push   %rbp
  80042180c4:	48 89 e5             	mov    %rsp,%rbp
  80042180c7:	48 83 ec 08          	sub    $0x8,%rsp
  80042180cb:	89 7d fc             	mov    %edi,-0x4(%rbp)
	lapicw(ICRLO, OTHERS | FIXED | vector);
  80042180ce:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042180d1:	0d 00 00 0c 00       	or     $0xc0000,%eax
  80042180d6:	89 c6                	mov    %eax,%esi
  80042180d8:	bf c0 00 00 00       	mov    $0xc0,%edi
  80042180dd:	48 b8 8e 7c 21 04 80 	movabs $0x8004217c8e,%rax
  80042180e4:	00 00 00 
  80042180e7:	ff d0                	callq  *%rax
	while (lapic[ICRLO] & DELIVS)
  80042180e9:	90                   	nop
  80042180ea:	48 b8 08 f0 71 04 80 	movabs $0x800471f008,%rax
  80042180f1:	00 00 00 
  80042180f4:	48 8b 00             	mov    (%rax),%rax
  80042180f7:	48 05 00 03 00 00    	add    $0x300,%rax
  80042180fd:	8b 00                	mov    (%rax),%eax
  80042180ff:	25 00 10 00 00       	and    $0x1000,%eax
  8004218104:	85 c0                	test   %eax,%eax
  8004218106:	75 e2                	jne    80042180ea <lapic_ipi+0x27>
		;
}
  8004218108:	90                   	nop
  8004218109:	c9                   	leaveq 
  800421810a:	c3                   	retq   

000000800421810b <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800421810b:	55                   	push   %rbp
  800421810c:	48 89 e5             	mov    %rsp,%rbp
  800421810f:	48 83 ec 20          	sub    $0x20,%rsp
  8004218113:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004218117:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800421811a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421811e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004218121:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004218125:	f0 87 02             	lock xchg %eax,(%rdx)
  8004218128:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800421812b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800421812e:	c9                   	leaveq 
  800421812f:	c3                   	retq   

0000008004218130 <get_caller_pcs>:

#ifdef DEBUG_SPINLOCK
// Record the current call stack in pcs[] by following the %ebp chain.
static void
get_caller_pcs(uint64_t pcs[])
{
  8004218130:	55                   	push   %rbp
  8004218131:	48 89 e5             	mov    %rsp,%rbp
  8004218134:	48 83 ec 28          	sub    $0x28,%rsp
  8004218138:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)

static __inline uint64_t
read_rbp(void)
{
	uint64_t rbp;
	__asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  800421813c:	48 89 e8             	mov    %rbp,%rax
  800421813f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	return rbp;
  8004218143:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
  8004218147:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (i = 0; i < 10; i++){
  800421814b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004218152:	eb 45                	jmp    8004218199 <get_caller_pcs+0x69>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
  8004218154:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004218159:	74 65                	je     80042181c0 <get_caller_pcs+0x90>
  800421815b:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004218162:	00 00 00 
  8004218165:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004218169:	76 55                	jbe    80042181c0 <get_caller_pcs+0x90>
			break;
		pcs[i] = rbp[1];          // saved %rip
  800421816b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421816e:	48 98                	cltq   
  8004218170:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004218177:	00 
  8004218178:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421817c:	48 01 c2             	add    %rax,%rdx
  800421817f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218183:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004218187:	48 89 02             	mov    %rax,(%rdx)
		rbp = (uint64_t *)rbp[0]; // saved %rbp
  800421818a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421818e:	48 8b 00             	mov    (%rax),%rax
  8004218191:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
{
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
	for (i = 0; i < 10; i++){
  8004218195:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004218199:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  800421819d:	7e b5                	jle    8004218154 <get_caller_pcs+0x24>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  800421819f:	eb 1f                	jmp    80042181c0 <get_caller_pcs+0x90>
		pcs[i] = 0;
  80042181a1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042181a4:	48 98                	cltq   
  80042181a6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042181ad:	00 
  80042181ae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042181b2:	48 01 d0             	add    %rdx,%rax
  80042181b5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  80042181bc:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042181c0:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  80042181c4:	7e db                	jle    80042181a1 <get_caller_pcs+0x71>
		pcs[i] = 0;
}
  80042181c6:	90                   	nop
  80042181c7:	c9                   	leaveq 
  80042181c8:	c3                   	retq   

00000080042181c9 <holding>:

// Check whether this CPU is holding the lock.
static int
holding(struct spinlock *lock)
{
  80042181c9:	55                   	push   %rbp
  80042181ca:	48 89 e5             	mov    %rsp,%rbp
  80042181cd:	53                   	push   %rbx
  80042181ce:	48 83 ec 18          	sub    $0x18,%rsp
  80042181d2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return lock->locked && lock->cpu == thiscpu;
  80042181d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042181da:	8b 00                	mov    (%rax),%eax
  80042181dc:	85 c0                	test   %eax,%eax
  80042181de:	74 3d                	je     800421821d <holding+0x54>
  80042181e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042181e4:	48 8b 58 10          	mov    0x10(%rax),%rbx
  80042181e8:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  80042181ef:	00 00 00 
  80042181f2:	ff d0                	callq  *%rax
  80042181f4:	48 98                	cltq   
  80042181f6:	48 c1 e0 03          	shl    $0x3,%rax
  80042181fa:	48 89 c2             	mov    %rax,%rdx
  80042181fd:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218201:	48 01 d0             	add    %rdx,%rax
  8004218204:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421820b:	00 00 00 
  800421820e:	48 01 d0             	add    %rdx,%rax
  8004218211:	48 39 c3             	cmp    %rax,%rbx
  8004218214:	75 07                	jne    800421821d <holding+0x54>
  8004218216:	b8 01 00 00 00       	mov    $0x1,%eax
  800421821b:	eb 05                	jmp    8004218222 <holding+0x59>
  800421821d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004218222:	48 83 c4 18          	add    $0x18,%rsp
  8004218226:	5b                   	pop    %rbx
  8004218227:	5d                   	pop    %rbp
  8004218228:	c3                   	retq   

0000008004218229 <__spin_initlock>:
#endif

void
__spin_initlock(struct spinlock *lk, char *name)
{
  8004218229:	55                   	push   %rbp
  800421822a:	48 89 e5             	mov    %rsp,%rbp
  800421822d:	48 83 ec 10          	sub    $0x10,%rsp
  8004218231:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004218235:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	lk->locked = 0;
  8004218239:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421823d:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
#ifdef DEBUG_SPINLOCK
	lk->name = name;
  8004218243:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218247:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421824b:	48 89 50 08          	mov    %rdx,0x8(%rax)
	lk->cpu = 0;
  800421824f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218253:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800421825a:	00 
#endif
}
  800421825b:	90                   	nop
  800421825c:	c9                   	leaveq 
  800421825d:	c3                   	retq   

000000800421825e <spin_lock>:
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
spin_lock(struct spinlock *lk)
{
  800421825e:	55                   	push   %rbp
  800421825f:	48 89 e5             	mov    %rsp,%rbp
  8004218262:	53                   	push   %rbx
  8004218263:	48 83 ec 18          	sub    $0x18,%rsp
  8004218267:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef DEBUG_SPINLOCK
	if (holding(lk))
  800421826b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421826f:	48 89 c7             	mov    %rax,%rdi
  8004218272:	48 b8 c9 81 21 04 80 	movabs $0x80042181c9,%rax
  8004218279:	00 00 00 
  800421827c:	ff d0                	callq  *%rax
  800421827e:	85 c0                	test   %eax,%eax
  8004218280:	74 46                	je     80042182c8 <spin_lock+0x6a>
		panic("CPU %d cannot acquire %s: already holding", cpunum(), lk->name);
  8004218282:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218286:	48 8b 58 08          	mov    0x8(%rax),%rbx
  800421828a:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  8004218291:	00 00 00 
  8004218294:	ff d0                	callq  *%rax
  8004218296:	49 89 d8             	mov    %rbx,%r8
  8004218299:	89 c1                	mov    %eax,%ecx
  800421829b:	48 ba a0 1a 22 04 80 	movabs $0x8004221aa0,%rdx
  80042182a2:	00 00 00 
  80042182a5:	be 42 00 00 00       	mov    $0x42,%esi
  80042182aa:	48 bf ca 1a 22 04 80 	movabs $0x8004221aca,%rdi
  80042182b1:	00 00 00 
  80042182b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042182b9:	49 b9 f3 04 20 04 80 	movabs $0x80042004f3,%r9
  80042182c0:	00 00 00 
  80042182c3:	41 ff d1             	callq  *%r9

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
		asm volatile ("pause");
  80042182c6:	f3 90                	pause  
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  80042182c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042182cc:	be 01 00 00 00       	mov    $0x1,%esi
  80042182d1:	48 89 c7             	mov    %rax,%rdi
  80042182d4:	48 b8 0b 81 21 04 80 	movabs $0x800421810b,%rax
  80042182db:	00 00 00 
  80042182de:	ff d0                	callq  *%rax
  80042182e0:	85 c0                	test   %eax,%eax
  80042182e2:	75 e2                	jne    80042182c6 <spin_lock+0x68>
		asm volatile ("pause");

	// Record info about lock acquisition for debugging.
#ifdef DEBUG_SPINLOCK
	lk->cpu = thiscpu;
  80042182e4:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  80042182eb:	00 00 00 
  80042182ee:	ff d0                	callq  *%rax
  80042182f0:	48 98                	cltq   
  80042182f2:	48 c1 e0 03          	shl    $0x3,%rax
  80042182f6:	48 89 c2             	mov    %rax,%rdx
  80042182f9:	48 c1 e2 04          	shl    $0x4,%rdx
  80042182fd:	48 01 d0             	add    %rdx,%rax
  8004218300:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  8004218307:	00 00 00 
  800421830a:	48 01 c2             	add    %rax,%rdx
  800421830d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218311:	48 89 50 10          	mov    %rdx,0x10(%rax)
	get_caller_pcs(lk->pcs);
  8004218315:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218319:	48 83 c0 18          	add    $0x18,%rax
  800421831d:	48 89 c7             	mov    %rax,%rdi
  8004218320:	48 b8 30 81 21 04 80 	movabs $0x8004218130,%rax
  8004218327:	00 00 00 
  800421832a:	ff d0                	callq  *%rax
#endif
}
  800421832c:	90                   	nop
  800421832d:	48 83 c4 18          	add    $0x18,%rsp
  8004218331:	5b                   	pop    %rbx
  8004218332:	5d                   	pop    %rbp
  8004218333:	c3                   	retq   

0000008004218334 <spin_unlock>:

// Release the lock.
void
spin_unlock(struct spinlock *lk)
{
  8004218334:	55                   	push   %rbp
  8004218335:	48 89 e5             	mov    %rsp,%rbp
  8004218338:	41 54                	push   %r12
  800421833a:	53                   	push   %rbx
  800421833b:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  8004218342:	48 89 bd d8 fa ff ff 	mov    %rdi,-0x528(%rbp)
#ifdef DEBUG_SPINLOCK
	if (!holding(lk)) {
  8004218349:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004218350:	48 89 c7             	mov    %rax,%rdi
  8004218353:	48 b8 c9 81 21 04 80 	movabs $0x80042181c9,%rax
  800421835a:	00 00 00 
  800421835d:	ff d0                	callq  *%rax
  800421835f:	85 c0                	test   %eax,%eax
  8004218361:	0f 85 d8 01 00 00    	jne    800421853f <spin_unlock+0x20b>
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
  8004218367:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  800421836e:	48 8d 48 18          	lea    0x18(%rax),%rcx
  8004218372:	48 8d 85 e0 fa ff ff 	lea    -0x520(%rbp),%rax
  8004218379:	ba 28 00 00 00       	mov    $0x28,%edx
  800421837e:	48 89 ce             	mov    %rcx,%rsi
  8004218381:	48 89 c7             	mov    %rax,%rdi
  8004218384:	48 b8 16 10 21 04 80 	movabs $0x8004211016,%rax
  800421838b:	00 00 00 
  800421838e:	ff d0                	callq  *%rax
		if (!lk->cpu) 
  8004218390:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004218397:	48 8b 40 10          	mov    0x10(%rax),%rax
  800421839b:	48 85 c0             	test   %rax,%rax
  800421839e:	75 39                	jne    80042183d9 <spin_unlock+0xa5>
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
  80042183a0:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042183a7:	48 8b 58 08          	mov    0x8(%rax),%rbx
  80042183ab:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  80042183b2:	00 00 00 
  80042183b5:	ff d0                	callq  *%rax
  80042183b7:	48 89 da             	mov    %rbx,%rdx
  80042183ba:	89 c6                	mov    %eax,%esi
  80042183bc:	48 bf e0 1a 22 04 80 	movabs $0x8004221ae0,%rdi
  80042183c3:	00 00 00 
  80042183c6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042183cb:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  80042183d2:	00 00 00 
  80042183d5:	ff d1                	callq  *%rcx
  80042183d7:	eb 4d                	jmp    8004218426 <spin_unlock+0xf2>
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
  80042183d9:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042183e0:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042183e4:	0f b6 00             	movzbl (%rax),%eax
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  80042183e7:	44 0f b6 e0          	movzbl %al,%r12d
  80042183eb:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042183f2:	48 8b 58 08          	mov    0x8(%rax),%rbx
  80042183f6:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  80042183fd:	00 00 00 
  8004218400:	ff d0                	callq  *%rax
  8004218402:	44 89 e1             	mov    %r12d,%ecx
  8004218405:	48 89 da             	mov    %rbx,%rdx
  8004218408:	89 c6                	mov    %eax,%esi
  800421840a:	48 bf 20 1b 22 04 80 	movabs $0x8004221b20,%rdi
  8004218411:	00 00 00 
  8004218414:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218419:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  8004218420:	00 00 00 
  8004218423:	41 ff d0             	callq  *%r8
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004218426:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  800421842d:	e9 c9 00 00 00       	jmpq   80042184fb <spin_unlock+0x1c7>
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
  8004218432:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218435:	48 98                	cltq   
  8004218437:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  800421843e:	89 c2                	mov    %eax,%edx
  8004218440:	48 8d 85 10 fb ff ff 	lea    -0x4f0(%rbp),%rax
  8004218447:	48 89 c6             	mov    %rax,%rsi
  800421844a:	48 89 d7             	mov    %rdx,%rdi
  800421844d:	48 b8 26 fc 20 04 80 	movabs $0x800420fc26,%rax
  8004218454:	00 00 00 
  8004218457:	ff d0                	callq  *%rax
  8004218459:	85 c0                	test   %eax,%eax
  800421845b:	78 71                	js     80042184ce <spin_unlock+0x19a>
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  800421845d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218460:	48 98                	cltq   
  8004218462:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004218469:	89 c2                	mov    %eax,%edx
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  800421846b:	48 8b 85 30 fb ff ff 	mov    -0x4d0(%rbp),%rax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004218472:	48 29 c2             	sub    %rax,%rdx
  8004218475:	49 89 d0             	mov    %rdx,%r8
  8004218478:	48 8b bd 20 fb ff ff 	mov    -0x4e0(%rbp),%rdi
  800421847f:	8b b5 28 fb ff ff    	mov    -0x4d8(%rbp),%esi
  8004218485:	8b 8d 18 fb ff ff    	mov    -0x4e8(%rbp),%ecx
  800421848b:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  8004218492:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218495:	48 98                	cltq   
  8004218497:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  800421849e:	48 83 ec 08          	sub    $0x8,%rsp
  80042184a2:	41 50                	push   %r8
  80042184a4:	49 89 f9             	mov    %rdi,%r9
  80042184a7:	41 89 f0             	mov    %esi,%r8d
  80042184aa:	89 c6                	mov    %eax,%esi
  80042184ac:	48 bf 56 1b 22 04 80 	movabs $0x8004221b56,%rdi
  80042184b3:	00 00 00 
  80042184b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042184bb:	49 ba 09 9d 20 04 80 	movabs $0x8004209d09,%r10
  80042184c2:	00 00 00 
  80042184c5:	41 ff d2             	callq  *%r10
  80042184c8:	48 83 c4 10          	add    $0x10,%rsp
  80042184cc:	eb 29                	jmp    80042184f7 <spin_unlock+0x1c3>
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
  80042184ce:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042184d1:	48 98                	cltq   
  80042184d3:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  80042184da:	89 c6                	mov    %eax,%esi
  80042184dc:	48 bf 6d 1b 22 04 80 	movabs $0x8004221b6d,%rdi
  80042184e3:	00 00 00 
  80042184e6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042184eb:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  80042184f2:	00 00 00 
  80042184f5:	ff d2                	callq  *%rdx
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  80042184f7:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042184fb:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  80042184ff:	7f 14                	jg     8004218515 <spin_unlock+0x1e1>
  8004218501:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218504:	48 98                	cltq   
  8004218506:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  800421850d:	85 c0                	test   %eax,%eax
  800421850f:	0f 85 1d ff ff ff    	jne    8004218432 <spin_unlock+0xfe>
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
		}
		panic("spin_unlock");
  8004218515:	48 ba 75 1b 22 04 80 	movabs $0x8004221b75,%rdx
  800421851c:	00 00 00 
  800421851f:	be 6c 00 00 00       	mov    $0x6c,%esi
  8004218524:	48 bf ca 1a 22 04 80 	movabs $0x8004221aca,%rdi
  800421852b:	00 00 00 
  800421852e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218533:	48 b9 f3 04 20 04 80 	movabs $0x80042004f3,%rcx
  800421853a:	00 00 00 
  800421853d:	ff d1                	callq  *%rcx
	}

	lk->pcs[0] = 0;
  800421853f:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004218546:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  800421854d:	00 
	lk->cpu = 0;
  800421854e:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004218555:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800421855c:	00 
	// But the 2007 Intel 64 Architecture Memory Ordering White
	// Paper says that Intel 64 and IA-32 will not move a load
	// after a store. So lock->locked = 0 would work here.
	// The xchg being asm volatile ensures gcc emits it after
	// the above assignments (and after the critical section).
	xchg(&lk->locked, 0);
  800421855d:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004218564:	be 00 00 00 00       	mov    $0x0,%esi
  8004218569:	48 89 c7             	mov    %rax,%rdi
  800421856c:	48 b8 0b 81 21 04 80 	movabs $0x800421810b,%rax
  8004218573:	00 00 00 
  8004218576:	ff d0                	callq  *%rax
}
  8004218578:	90                   	nop
  8004218579:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  800421857d:	5b                   	pop    %rbx
  800421857e:	41 5c                	pop    %r12
  8004218580:	5d                   	pop    %rbp
  8004218581:	c3                   	retq   

0000008004218582 <e1000_attach>:
static struct rx_desc rx_ring[RX_RING_SIZE] __attribute__((aligned(16)));
static char rx_data[RX_RING_SIZE][2048];

int
e1000_attach(struct pci_func *pcif)
{
  8004218582:	55                   	push   %rbp
  8004218583:	48 89 e5             	mov    %rsp,%rbp
  8004218586:	48 83 ec 40          	sub    $0x40,%rsp
  800421858a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	int i;

	pci_func_enable(pcif);
  800421858e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004218592:	48 89 c7             	mov    %rax,%rdi
  8004218595:	48 b8 63 94 21 04 80 	movabs $0x8004219463,%rax
  800421859c:	00 00 00 
  800421859f:	ff d0                	callq  *%rax

	// [E1000 Table 4-2] BAR 0 gives the register base address.
	regs = mmio_map_region(pcif->reg_base[0], pcif->reg_size[0]);
  80042185a1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042185a5:	8b 40 30             	mov    0x30(%rax),%eax
  80042185a8:	89 c2                	mov    %eax,%edx
  80042185aa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042185ae:	8b 40 18             	mov    0x18(%rax),%eax
  80042185b1:	89 c0                	mov    %eax,%eax
  80042185b3:	48 89 d6             	mov    %rdx,%rsi
  80042185b6:	48 89 c7             	mov    %rax,%rdi
  80042185b9:	48 b8 c0 3f 20 04 80 	movabs $0x8004203fc0,%rax
  80042185c0:	00 00 00 
  80042185c3:	ff d0                	callq  *%rax
  80042185c5:	48 89 c2             	mov    %rax,%rdx
  80042185c8:	48 b8 20 e7 4d 04 80 	movabs $0x80044de720,%rax
  80042185cf:	00 00 00 
  80042185d2:	48 89 10             	mov    %rdx,(%rax)

	// [E1000 14.5] Transmit initialization
	for (i = 0; i < TX_RING_SIZE; i++) {
  80042185d5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042185dc:	e9 ac 00 00 00       	jmpq   800421868d <e1000_attach+0x10b>
		tx_ring[i].addr = PADDR(tx_data[i]);
  80042185e1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042185e4:	48 98                	cltq   
  80042185e6:	48 69 d0 ee 05 00 00 	imul   $0x5ee,%rax,%rdx
  80042185ed:	48 b8 40 e8 4d 04 80 	movabs $0x80044de840,%rax
  80042185f4:	00 00 00 
  80042185f7:	48 01 d0             	add    %rdx,%rax
  80042185fa:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042185fe:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004218605:	00 00 00 
  8004218608:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800421860c:	77 32                	ja     8004218640 <e1000_attach+0xbe>
  800421860e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004218612:	48 89 c1             	mov    %rax,%rcx
  8004218615:	48 ba 88 1b 22 04 80 	movabs $0x8004221b88,%rdx
  800421861c:	00 00 00 
  800421861f:	be 97 00 00 00       	mov    $0x97,%esi
  8004218624:	48 bf ac 1b 22 04 80 	movabs $0x8004221bac,%rdi
  800421862b:	00 00 00 
  800421862e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218633:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421863a:	00 00 00 
  800421863d:	41 ff d0             	callq  *%r8
  8004218640:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004218647:	ff ff ff 
  800421864a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421864e:	48 01 c2             	add    %rax,%rdx
  8004218651:	48 b8 30 e7 4d 04 80 	movabs $0x80044de730,%rax
  8004218658:	00 00 00 
  800421865b:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800421865e:	48 63 c9             	movslq %ecx,%rcx
  8004218661:	48 c1 e1 04          	shl    $0x4,%rcx
  8004218665:	48 01 c8             	add    %rcx,%rax
  8004218668:	48 89 10             	mov    %rdx,(%rax)
		tx_ring[i].status = E1000_TXD_STAT_DD;
  800421866b:	48 b8 30 e7 4d 04 80 	movabs $0x80044de730,%rax
  8004218672:	00 00 00 
  8004218675:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004218678:	48 63 d2             	movslq %edx,%rdx
  800421867b:	48 c1 e2 04          	shl    $0x4,%rdx
  800421867f:	48 01 d0             	add    %rdx,%rax
  8004218682:	48 83 c0 0c          	add    $0xc,%rax
  8004218686:	c6 00 01             	movb   $0x1,(%rax)

	// [E1000 Table 4-2] BAR 0 gives the register base address.
	regs = mmio_map_region(pcif->reg_base[0], pcif->reg_size[0]);

	// [E1000 14.5] Transmit initialization
	for (i = 0; i < TX_RING_SIZE; i++) {
  8004218689:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421868d:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  8004218691:	0f 8e 4a ff ff ff    	jle    80042185e1 <e1000_attach+0x5f>
		tx_ring[i].addr = PADDR(tx_data[i]);
		tx_ring[i].status = E1000_TXD_STAT_DD;
	}
	regs[E1000_TDBAL] = PADDR(tx_ring);
  8004218697:	48 b8 20 e7 4d 04 80 	movabs $0x80044de720,%rax
  800421869e:	00 00 00 
  80042186a1:	48 8b 00             	mov    (%rax),%rax
  80042186a4:	48 8d 90 00 38 00 00 	lea    0x3800(%rax),%rdx
  80042186ab:	48 b8 30 e7 4d 04 80 	movabs $0x80044de730,%rax
  80042186b2:	00 00 00 
  80042186b5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042186b9:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042186c0:	00 00 00 
  80042186c3:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80042186c7:	77 32                	ja     80042186fb <e1000_attach+0x179>
  80042186c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042186cd:	48 89 c1             	mov    %rax,%rcx
  80042186d0:	48 ba 88 1b 22 04 80 	movabs $0x8004221b88,%rdx
  80042186d7:	00 00 00 
  80042186da:	be 9a 00 00 00       	mov    $0x9a,%esi
  80042186df:	48 bf ac 1b 22 04 80 	movabs $0x8004221bac,%rdi
  80042186e6:	00 00 00 
  80042186e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042186ee:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042186f5:	00 00 00 
  80042186f8:	41 ff d0             	callq  *%r8
  80042186fb:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004218702:	ff ff ff 
  8004218705:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218709:	48 01 c8             	add    %rcx,%rax
  800421870c:	89 02                	mov    %eax,(%rdx)
	static_assert(sizeof(tx_ring) % 128 == 0);
	regs[E1000_TDLEN] = sizeof(tx_ring);
  800421870e:	48 b8 20 e7 4d 04 80 	movabs $0x80044de720,%rax
  8004218715:	00 00 00 
  8004218718:	48 8b 00             	mov    (%rax),%rax
  800421871b:	48 05 08 38 00 00    	add    $0x3808,%rax
  8004218721:	c7 00 00 01 00 00    	movl   $0x100,(%rax)
	regs[E1000_TDH] = regs[E1000_TDT] = 0;
  8004218727:	48 b8 20 e7 4d 04 80 	movabs $0x80044de720,%rax
  800421872e:	00 00 00 
  8004218731:	48 8b 00             	mov    (%rax),%rax
  8004218734:	48 8d 90 10 38 00 00 	lea    0x3810(%rax),%rdx
  800421873b:	48 b8 20 e7 4d 04 80 	movabs $0x80044de720,%rax
  8004218742:	00 00 00 
  8004218745:	48 8b 00             	mov    (%rax),%rax
  8004218748:	48 8d 88 18 38 00 00 	lea    0x3818(%rax),%rcx
  800421874f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218754:	89 01                	mov    %eax,(%rcx)
  8004218756:	89 02                	mov    %eax,(%rdx)
	regs[E1000_TCTL] = (E1000_TCTL_EN | E1000_TCTL_PSP |
  8004218758:	48 b8 20 e7 4d 04 80 	movabs $0x80044de720,%rax
  800421875f:	00 00 00 
  8004218762:	48 8b 00             	mov    (%rax),%rax
  8004218765:	48 05 00 04 00 00    	add    $0x400,%rax
  800421876b:	c7 00 0a 01 04 00    	movl   $0x4010a,(%rax)
			    (0x10 << E1000_TCTL_CT_SHIFT) |
			    (0x40 << E1000_TCTL_COLD_SHIFT));
	regs[E1000_TIPG] = 10 | (8<<10) | (6<<20);
  8004218771:	48 b8 20 e7 4d 04 80 	movabs $0x80044de720,%rax
  8004218778:	00 00 00 
  800421877b:	48 8b 00             	mov    (%rax),%rax
  800421877e:	48 05 10 04 00 00    	add    $0x410,%rax
  8004218784:	c7 00 0a 20 60 00    	movl   $0x60200a,(%rax)
	regs[E1000_RAH] = regs[E1000_EERD] >> 16;

	regs[E1000_RAH] |= 0x1 << 31;
#endif

	for (i = 0; i < RX_RING_SIZE; i++) {
  800421878a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004218791:	e9 8e 00 00 00       	jmpq   8004218824 <e1000_attach+0x2a2>
		rx_ring[i].addr = PADDR(rx_data[i]);
  8004218796:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218799:	48 98                	cltq   
  800421879b:	48 c1 e0 0b          	shl    $0xb,%rax
  800421879f:	48 89 c2             	mov    %rax,%rdx
  80042187a2:	48 b8 a0 85 4e 04 80 	movabs $0x80044e85a0,%rax
  80042187a9:	00 00 00 
  80042187ac:	48 01 d0             	add    %rdx,%rax
  80042187af:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042187b3:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042187ba:	00 00 00 
  80042187bd:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  80042187c1:	77 32                	ja     80042187f5 <e1000_attach+0x273>
  80042187c3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042187c7:	48 89 c1             	mov    %rax,%rcx
  80042187ca:	48 ba 88 1b 22 04 80 	movabs $0x8004221b88,%rdx
  80042187d1:	00 00 00 
  80042187d4:	be b8 00 00 00       	mov    $0xb8,%esi
  80042187d9:	48 bf ac 1b 22 04 80 	movabs $0x8004221bac,%rdi
  80042187e0:	00 00 00 
  80042187e3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042187e8:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042187ef:	00 00 00 
  80042187f2:	41 ff d0             	callq  *%r8
  80042187f5:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042187fc:	ff ff ff 
  80042187ff:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218803:	48 01 c2             	add    %rax,%rdx
  8004218806:	48 b8 20 47 4e 04 80 	movabs $0x80044e4720,%rax
  800421880d:	00 00 00 
  8004218810:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004218813:	48 63 c9             	movslq %ecx,%rcx
  8004218816:	48 c1 e1 04          	shl    $0x4,%rcx
  800421881a:	48 01 c8             	add    %rcx,%rax
  800421881d:	48 89 10             	mov    %rdx,(%rax)
	regs[E1000_RAH] = regs[E1000_EERD] >> 16;

	regs[E1000_RAH] |= 0x1 << 31;
#endif

	for (i = 0; i < RX_RING_SIZE; i++) {
  8004218820:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004218824:	81 7d fc e7 03 00 00 	cmpl   $0x3e7,-0x4(%rbp)
  800421882b:	0f 8e 65 ff ff ff    	jle    8004218796 <e1000_attach+0x214>
		rx_ring[i].addr = PADDR(rx_data[i]);
	}
	regs[E1000_RDBAL] = PADDR(rx_ring);
  8004218831:	48 b8 20 e7 4d 04 80 	movabs $0x80044de720,%rax
  8004218838:	00 00 00 
  800421883b:	48 8b 00             	mov    (%rax),%rax
  800421883e:	48 8d 90 00 28 00 00 	lea    0x2800(%rax),%rdx
  8004218845:	48 b8 20 47 4e 04 80 	movabs $0x80044e4720,%rax
  800421884c:	00 00 00 
  800421884f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004218853:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421885a:	00 00 00 
  800421885d:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004218861:	77 32                	ja     8004218895 <e1000_attach+0x313>
  8004218863:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218867:	48 89 c1             	mov    %rax,%rcx
  800421886a:	48 ba 88 1b 22 04 80 	movabs $0x8004221b88,%rdx
  8004218871:	00 00 00 
  8004218874:	be ba 00 00 00       	mov    $0xba,%esi
  8004218879:	48 bf ac 1b 22 04 80 	movabs $0x8004221bac,%rdi
  8004218880:	00 00 00 
  8004218883:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218888:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421888f:	00 00 00 
  8004218892:	41 ff d0             	callq  *%r8
  8004218895:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  800421889c:	ff ff ff 
  800421889f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042188a3:	48 01 c8             	add    %rcx,%rax
  80042188a6:	89 02                	mov    %eax,(%rdx)
	static_assert(sizeof(rx_ring) % 128 == 0);
	regs[E1000_RDLEN] = sizeof(rx_ring);
  80042188a8:	48 b8 20 e7 4d 04 80 	movabs $0x80044de720,%rax
  80042188af:	00 00 00 
  80042188b2:	48 8b 00             	mov    (%rax),%rax
  80042188b5:	48 05 08 28 00 00    	add    $0x2808,%rax
  80042188bb:	c7 00 80 3e 00 00    	movl   $0x3e80,(%rax)
	regs[E1000_RDH] = 0;
  80042188c1:	48 b8 20 e7 4d 04 80 	movabs $0x80044de720,%rax
  80042188c8:	00 00 00 
  80042188cb:	48 8b 00             	mov    (%rax),%rax
  80042188ce:	48 05 10 28 00 00    	add    $0x2810,%rax
  80042188d4:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	regs[E1000_RDT] = RX_RING_SIZE - 1;
  80042188da:	48 b8 20 e7 4d 04 80 	movabs $0x80044de720,%rax
  80042188e1:	00 00 00 
  80042188e4:	48 8b 00             	mov    (%rax),%rax
  80042188e7:	48 05 18 28 00 00    	add    $0x2818,%rax
  80042188ed:	c7 00 e7 03 00 00    	movl   $0x3e7,(%rax)
	// Strip CRC because that's what the grade script expects
	regs[E1000_RCTL] = E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_SZ_2048
  80042188f3:	48 b8 20 e7 4d 04 80 	movabs $0x80044de720,%rax
  80042188fa:	00 00 00 
  80042188fd:	48 8b 00             	mov    (%rax),%rax
  8004218900:	48 05 00 01 00 00    	add    $0x100,%rax
  8004218906:	c7 00 02 80 00 04    	movl   $0x4008002,(%rax)
		| E1000_RCTL_SECRC;

	return 0;
  800421890c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004218911:	c9                   	leaveq 
  8004218912:	c3                   	retq   

0000008004218913 <e1000_transmit>:

int
e1000_transmit(const char *buf, unsigned int len)
{
  8004218913:	55                   	push   %rbp
  8004218914:	48 89 e5             	mov    %rsp,%rbp
  8004218917:	48 83 ec 20          	sub    $0x20,%rsp
  800421891b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421891f:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	if (!regs || len > DATA_MAX)
  8004218922:	48 b8 20 e7 4d 04 80 	movabs $0x80044de720,%rax
  8004218929:	00 00 00 
  800421892c:	48 8b 00             	mov    (%rax),%rax
  800421892f:	48 85 c0             	test   %rax,%rax
  8004218932:	74 09                	je     800421893d <e1000_transmit+0x2a>
  8004218934:	81 7d e4 ee 05 00 00 	cmpl   $0x5ee,-0x1c(%rbp)
  800421893b:	76 0a                	jbe    8004218947 <e1000_transmit+0x34>
		return -E_INVAL;
  800421893d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8004218942:	e9 4a 01 00 00       	jmpq   8004218a91 <e1000_transmit+0x17e>

	int tail = regs[E1000_TDT];
  8004218947:	48 b8 20 e7 4d 04 80 	movabs $0x80044de720,%rax
  800421894e:	00 00 00 
  8004218951:	48 8b 00             	mov    (%rax),%rax
  8004218954:	48 05 18 38 00 00    	add    $0x3818,%rax
  800421895a:	8b 00                	mov    (%rax),%eax
  800421895c:	89 45 fc             	mov    %eax,-0x4(%rbp)

	// [E1000 3.3.3.2] Check if this descriptor is done.
	// According to [E1000 13.4.39], using TDH for this is not
	// reliable.
	if (!(tx_ring[tail].status & E1000_TXD_STAT_DD)) {
  800421895f:	48 b8 30 e7 4d 04 80 	movabs $0x80044de730,%rax
  8004218966:	00 00 00 
  8004218969:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800421896c:	48 63 d2             	movslq %edx,%rdx
  800421896f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218973:	48 01 d0             	add    %rdx,%rax
  8004218976:	48 83 c0 0c          	add    $0xc,%rax
  800421897a:	0f b6 00             	movzbl (%rax),%eax
  800421897d:	0f b6 c0             	movzbl %al,%eax
  8004218980:	83 e0 01             	and    $0x1,%eax
  8004218983:	85 c0                	test   %eax,%eax
  8004218985:	75 25                	jne    80042189ac <e1000_transmit+0x99>
		cprintf("TX ring overflow\n");
  8004218987:	48 bf b9 1b 22 04 80 	movabs $0x8004221bb9,%rdi
  800421898e:	00 00 00 
  8004218991:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218996:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421899d:	00 00 00 
  80042189a0:	ff d2                	callq  *%rdx
		return 0;
  80042189a2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042189a7:	e9 e5 00 00 00       	jmpq   8004218a91 <e1000_transmit+0x17e>
	}

	// Fill in the next descriptor
	memmove(tx_data[tail], buf, len);
  80042189ac:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042189af:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042189b2:	48 98                	cltq   
  80042189b4:	48 69 c8 ee 05 00 00 	imul   $0x5ee,%rax,%rcx
  80042189bb:	48 b8 40 e8 4d 04 80 	movabs $0x80044de840,%rax
  80042189c2:	00 00 00 
  80042189c5:	48 01 c1             	add    %rax,%rcx
  80042189c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042189cc:	48 89 c6             	mov    %rax,%rsi
  80042189cf:	48 89 cf             	mov    %rcx,%rdi
  80042189d2:	48 b8 16 10 21 04 80 	movabs $0x8004211016,%rax
  80042189d9:	00 00 00 
  80042189dc:	ff d0                	callq  *%rax
	tx_ring[tail].length = len;
  80042189de:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042189e1:	89 c1                	mov    %eax,%ecx
  80042189e3:	48 b8 30 e7 4d 04 80 	movabs $0x80044de730,%rax
  80042189ea:	00 00 00 
  80042189ed:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042189f0:	48 63 d2             	movslq %edx,%rdx
  80042189f3:	48 c1 e2 04          	shl    $0x4,%rdx
  80042189f7:	48 01 d0             	add    %rdx,%rax
  80042189fa:	48 83 c0 08          	add    $0x8,%rax
  80042189fe:	66 89 08             	mov    %cx,(%rax)
	tx_ring[tail].status &= ~E1000_TXD_STAT_DD;
  8004218a01:	48 b8 30 e7 4d 04 80 	movabs $0x80044de730,%rax
  8004218a08:	00 00 00 
  8004218a0b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004218a0e:	48 63 d2             	movslq %edx,%rdx
  8004218a11:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218a15:	48 01 d0             	add    %rdx,%rax
  8004218a18:	48 83 c0 0c          	add    $0xc,%rax
  8004218a1c:	0f b6 00             	movzbl (%rax),%eax
  8004218a1f:	83 e0 fe             	and    $0xfffffffe,%eax
  8004218a22:	89 c2                	mov    %eax,%edx
  8004218a24:	48 b8 30 e7 4d 04 80 	movabs $0x80044de730,%rax
  8004218a2b:	00 00 00 
  8004218a2e:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004218a31:	48 63 c9             	movslq %ecx,%rcx
  8004218a34:	48 c1 e1 04          	shl    $0x4,%rcx
  8004218a38:	48 01 c8             	add    %rcx,%rax
  8004218a3b:	48 83 c0 0c          	add    $0xc,%rax
  8004218a3f:	88 10                	mov    %dl,(%rax)
	// Set EOP to actually send this packet.  Set RS to get DD
	// status bit when sent.
	tx_ring[tail].cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;
  8004218a41:	48 b8 30 e7 4d 04 80 	movabs $0x80044de730,%rax
  8004218a48:	00 00 00 
  8004218a4b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004218a4e:	48 63 d2             	movslq %edx,%rdx
  8004218a51:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218a55:	48 01 d0             	add    %rdx,%rax
  8004218a58:	48 83 c0 0b          	add    $0xb,%rax
  8004218a5c:	c6 00 09             	movb   $0x9,(%rax)

	// Move the tail pointer
	regs[E1000_TDT] = (tail + 1) % TX_RING_SIZE;
  8004218a5f:	48 b8 20 e7 4d 04 80 	movabs $0x80044de720,%rax
  8004218a66:	00 00 00 
  8004218a69:	48 8b 00             	mov    (%rax),%rax
  8004218a6c:	48 8d 88 18 38 00 00 	lea    0x3818(%rax),%rcx
  8004218a73:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218a76:	8d 50 01             	lea    0x1(%rax),%edx
  8004218a79:	89 d0                	mov    %edx,%eax
  8004218a7b:	c1 f8 1f             	sar    $0x1f,%eax
  8004218a7e:	c1 e8 1c             	shr    $0x1c,%eax
  8004218a81:	01 c2                	add    %eax,%edx
  8004218a83:	83 e2 0f             	and    $0xf,%edx
  8004218a86:	29 c2                	sub    %eax,%edx
  8004218a88:	89 d0                	mov    %edx,%eax
  8004218a8a:	89 01                	mov    %eax,(%rcx)

	return 0;
  8004218a8c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004218a91:	c9                   	leaveq 
  8004218a92:	c3                   	retq   

0000008004218a93 <e1000_receive>:

int
e1000_receive(char *buf, unsigned int len)
{
  8004218a93:	55                   	push   %rbp
  8004218a94:	48 89 e5             	mov    %rsp,%rbp
  8004218a97:	48 83 ec 20          	sub    $0x20,%rsp
  8004218a9b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004218a9f:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	if (!regs)
  8004218aa2:	48 b8 20 e7 4d 04 80 	movabs $0x80044de720,%rax
  8004218aa9:	00 00 00 
  8004218aac:	48 8b 00             	mov    (%rax),%rax
  8004218aaf:	48 85 c0             	test   %rax,%rax
  8004218ab2:	75 0a                	jne    8004218abe <e1000_receive+0x2b>
		return 0;
  8004218ab4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218ab9:	e9 65 01 00 00       	jmpq   8004218c23 <e1000_receive+0x190>

	int tail = (regs[E1000_RDT] + 1) % RX_RING_SIZE;
  8004218abe:	48 b8 20 e7 4d 04 80 	movabs $0x80044de720,%rax
  8004218ac5:	00 00 00 
  8004218ac8:	48 8b 00             	mov    (%rax),%rax
  8004218acb:	48 05 18 28 00 00    	add    $0x2818,%rax
  8004218ad1:	8b 00                	mov    (%rax),%eax
  8004218ad3:	8d 48 01             	lea    0x1(%rax),%ecx
  8004218ad6:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8004218adb:	89 c8                	mov    %ecx,%eax
  8004218add:	f7 e2                	mul    %edx
  8004218adf:	89 d0                	mov    %edx,%eax
  8004218ae1:	c1 e8 06             	shr    $0x6,%eax
  8004218ae4:	69 c0 e8 03 00 00    	imul   $0x3e8,%eax,%eax
  8004218aea:	29 c1                	sub    %eax,%ecx
  8004218aec:	89 c8                	mov    %ecx,%eax
  8004218aee:	89 45 fc             	mov    %eax,-0x4(%rbp)

	// Check if the descriptor has been filled
	if (!(rx_ring[tail].status & E1000_RXD_STAT_DD))
  8004218af1:	48 b8 20 47 4e 04 80 	movabs $0x80044e4720,%rax
  8004218af8:	00 00 00 
  8004218afb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004218afe:	48 63 d2             	movslq %edx,%rdx
  8004218b01:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218b05:	48 01 d0             	add    %rdx,%rax
  8004218b08:	48 83 c0 0c          	add    $0xc,%rax
  8004218b0c:	0f b6 00             	movzbl (%rax),%eax
  8004218b0f:	0f b6 c0             	movzbl %al,%eax
  8004218b12:	83 e0 01             	and    $0x1,%eax
  8004218b15:	85 c0                	test   %eax,%eax
  8004218b17:	75 0a                	jne    8004218b23 <e1000_receive+0x90>
		return 0;
  8004218b19:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218b1e:	e9 00 01 00 00       	jmpq   8004218c23 <e1000_receive+0x190>
	assert(rx_ring[tail].status & E1000_RXD_STAT_EOP);
  8004218b23:	48 b8 20 47 4e 04 80 	movabs $0x80044e4720,%rax
  8004218b2a:	00 00 00 
  8004218b2d:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004218b30:	48 63 d2             	movslq %edx,%rdx
  8004218b33:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218b37:	48 01 d0             	add    %rdx,%rax
  8004218b3a:	48 83 c0 0c          	add    $0xc,%rax
  8004218b3e:	0f b6 00             	movzbl (%rax),%eax
  8004218b41:	0f b6 c0             	movzbl %al,%eax
  8004218b44:	83 e0 02             	and    $0x2,%eax
  8004218b47:	85 c0                	test   %eax,%eax
  8004218b49:	75 35                	jne    8004218b80 <e1000_receive+0xed>
  8004218b4b:	48 b9 d0 1b 22 04 80 	movabs $0x8004221bd0,%rcx
  8004218b52:	00 00 00 
  8004218b55:	48 ba fa 1b 22 04 80 	movabs $0x8004221bfa,%rdx
  8004218b5c:	00 00 00 
  8004218b5f:	be ef 00 00 00       	mov    $0xef,%esi
  8004218b64:	48 bf ac 1b 22 04 80 	movabs $0x8004221bac,%rdi
  8004218b6b:	00 00 00 
  8004218b6e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218b73:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004218b7a:	00 00 00 
  8004218b7d:	41 ff d0             	callq  *%r8

	// Copy the packet data
	len = MIN(len, rx_ring[tail].length);
  8004218b80:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004218b83:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004218b86:	48 b8 20 47 4e 04 80 	movabs $0x80044e4720,%rax
  8004218b8d:	00 00 00 
  8004218b90:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004218b93:	48 63 d2             	movslq %edx,%rdx
  8004218b96:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218b9a:	48 01 d0             	add    %rdx,%rax
  8004218b9d:	48 83 c0 08          	add    $0x8,%rax
  8004218ba1:	0f b7 00             	movzwl (%rax),%eax
  8004218ba4:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  8004218ba8:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004218bac:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004218baf:	39 c2                	cmp    %eax,%edx
  8004218bb1:	0f 46 c2             	cmovbe %edx,%eax
  8004218bb4:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	memmove(buf, rx_data[tail], len);
  8004218bb7:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004218bba:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218bbd:	48 98                	cltq   
  8004218bbf:	48 c1 e0 0b          	shl    $0xb,%rax
  8004218bc3:	48 89 c1             	mov    %rax,%rcx
  8004218bc6:	48 b8 a0 85 4e 04 80 	movabs $0x80044e85a0,%rax
  8004218bcd:	00 00 00 
  8004218bd0:	48 01 c1             	add    %rax,%rcx
  8004218bd3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218bd7:	48 89 ce             	mov    %rcx,%rsi
  8004218bda:	48 89 c7             	mov    %rax,%rdi
  8004218bdd:	48 b8 16 10 21 04 80 	movabs $0x8004211016,%rax
  8004218be4:	00 00 00 
  8004218be7:	ff d0                	callq  *%rax
	rx_ring[tail].status = 0;
  8004218be9:	48 b8 20 47 4e 04 80 	movabs $0x80044e4720,%rax
  8004218bf0:	00 00 00 
  8004218bf3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004218bf6:	48 63 d2             	movslq %edx,%rdx
  8004218bf9:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218bfd:	48 01 d0             	add    %rdx,%rax
  8004218c00:	48 83 c0 0c          	add    $0xc,%rax
  8004218c04:	c6 00 00             	movb   $0x0,(%rax)

	// Move the tail pointer
	regs[E1000_RDT] = tail;
  8004218c07:	48 b8 20 e7 4d 04 80 	movabs $0x80044de720,%rax
  8004218c0e:	00 00 00 
  8004218c11:	48 8b 00             	mov    (%rax),%rax
  8004218c14:	48 8d 90 18 28 00 00 	lea    0x2818(%rax),%rdx
  8004218c1b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218c1e:	89 02                	mov    %eax,(%rdx)
	return len;
  8004218c20:	8b 45 e4             	mov    -0x1c(%rbp),%eax
}
  8004218c23:	c9                   	leaveq 
  8004218c24:	c3                   	retq   

0000008004218c25 <pci_conf1_set_addr>:
static void
pci_conf1_set_addr(uint32_t bus,
		   uint32_t dev,
		   uint32_t func,
		   uint32_t offset)
{
  8004218c25:	55                   	push   %rbp
  8004218c26:	48 89 e5             	mov    %rsp,%rbp
  8004218c29:	48 83 ec 20          	sub    $0x20,%rsp
  8004218c2d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004218c30:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8004218c33:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  8004218c36:	89 4d e0             	mov    %ecx,-0x20(%rbp)
	assert(bus < 256);
  8004218c39:	81 7d ec ff 00 00 00 	cmpl   $0xff,-0x14(%rbp)
  8004218c40:	76 35                	jbe    8004218c77 <pci_conf1_set_addr+0x52>
  8004218c42:	48 b9 10 1c 22 04 80 	movabs $0x8004221c10,%rcx
  8004218c49:	00 00 00 
  8004218c4c:	48 ba 1a 1c 22 04 80 	movabs $0x8004221c1a,%rdx
  8004218c53:	00 00 00 
  8004218c56:	be 31 00 00 00       	mov    $0x31,%esi
  8004218c5b:	48 bf 2f 1c 22 04 80 	movabs $0x8004221c2f,%rdi
  8004218c62:	00 00 00 
  8004218c65:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218c6a:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004218c71:	00 00 00 
  8004218c74:	41 ff d0             	callq  *%r8
	assert(dev < 32);
  8004218c77:	83 7d e8 1f          	cmpl   $0x1f,-0x18(%rbp)
  8004218c7b:	76 35                	jbe    8004218cb2 <pci_conf1_set_addr+0x8d>
  8004218c7d:	48 b9 3a 1c 22 04 80 	movabs $0x8004221c3a,%rcx
  8004218c84:	00 00 00 
  8004218c87:	48 ba 1a 1c 22 04 80 	movabs $0x8004221c1a,%rdx
  8004218c8e:	00 00 00 
  8004218c91:	be 32 00 00 00       	mov    $0x32,%esi
  8004218c96:	48 bf 2f 1c 22 04 80 	movabs $0x8004221c2f,%rdi
  8004218c9d:	00 00 00 
  8004218ca0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218ca5:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004218cac:	00 00 00 
  8004218caf:	41 ff d0             	callq  *%r8
	assert(func < 8);
  8004218cb2:	83 7d e4 07          	cmpl   $0x7,-0x1c(%rbp)
  8004218cb6:	76 35                	jbe    8004218ced <pci_conf1_set_addr+0xc8>
  8004218cb8:	48 b9 43 1c 22 04 80 	movabs $0x8004221c43,%rcx
  8004218cbf:	00 00 00 
  8004218cc2:	48 ba 1a 1c 22 04 80 	movabs $0x8004221c1a,%rdx
  8004218cc9:	00 00 00 
  8004218ccc:	be 33 00 00 00       	mov    $0x33,%esi
  8004218cd1:	48 bf 2f 1c 22 04 80 	movabs $0x8004221c2f,%rdi
  8004218cd8:	00 00 00 
  8004218cdb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218ce0:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004218ce7:	00 00 00 
  8004218cea:	41 ff d0             	callq  *%r8
	assert(offset < 256);
  8004218ced:	81 7d e0 ff 00 00 00 	cmpl   $0xff,-0x20(%rbp)
  8004218cf4:	76 35                	jbe    8004218d2b <pci_conf1_set_addr+0x106>
  8004218cf6:	48 b9 4c 1c 22 04 80 	movabs $0x8004221c4c,%rcx
  8004218cfd:	00 00 00 
  8004218d00:	48 ba 1a 1c 22 04 80 	movabs $0x8004221c1a,%rdx
  8004218d07:	00 00 00 
  8004218d0a:	be 34 00 00 00       	mov    $0x34,%esi
  8004218d0f:	48 bf 2f 1c 22 04 80 	movabs $0x8004221c2f,%rdi
  8004218d16:	00 00 00 
  8004218d19:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218d1e:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004218d25:	00 00 00 
  8004218d28:	41 ff d0             	callq  *%r8
	assert((offset & 0x3) == 0);
  8004218d2b:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004218d2e:	83 e0 03             	and    $0x3,%eax
  8004218d31:	85 c0                	test   %eax,%eax
  8004218d33:	74 35                	je     8004218d6a <pci_conf1_set_addr+0x145>
  8004218d35:	48 b9 59 1c 22 04 80 	movabs $0x8004221c59,%rcx
  8004218d3c:	00 00 00 
  8004218d3f:	48 ba 1a 1c 22 04 80 	movabs $0x8004221c1a,%rdx
  8004218d46:	00 00 00 
  8004218d49:	be 35 00 00 00       	mov    $0x35,%esi
  8004218d4e:	48 bf 2f 1c 22 04 80 	movabs $0x8004221c2f,%rdi
  8004218d55:	00 00 00 
  8004218d58:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218d5d:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004218d64:	00 00 00 
  8004218d67:	41 ff d0             	callq  *%r8

	uint32_t v = (1 << 31) |		// config-space
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
  8004218d6a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218d6d:	c1 e0 10             	shl    $0x10,%eax
  8004218d70:	89 c2                	mov    %eax,%edx
  8004218d72:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004218d75:	c1 e0 0b             	shl    $0xb,%eax
  8004218d78:	09 c2                	or     %eax,%edx
  8004218d7a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004218d7d:	c1 e0 08             	shl    $0x8,%eax
  8004218d80:	09 d0                	or     %edx,%eax
  8004218d82:	0b 45 e0             	or     -0x20(%rbp),%eax
	assert(dev < 32);
	assert(func < 8);
	assert(offset < 256);
	assert((offset & 0x3) == 0);

	uint32_t v = (1 << 31) |		// config-space
  8004218d85:	0d 00 00 00 80       	or     $0x80000000,%eax
  8004218d8a:	89 45 fc             	mov    %eax,-0x4(%rbp)
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
	outl(pci_conf1_addr_ioport, v);
  8004218d8d:	48 b8 e4 37 23 04 80 	movabs $0x80042337e4,%rax
  8004218d94:	00 00 00 
  8004218d97:	8b 00                	mov    (%rax),%eax
  8004218d99:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004218d9c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218d9f:	89 45 f4             	mov    %eax,-0xc(%rbp)
}

static __inline void
outl(int port, uint32_t data)
{
	__asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  8004218da2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004218da5:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004218da8:	ef                   	out    %eax,(%dx)
}
  8004218da9:	90                   	nop
  8004218daa:	c9                   	leaveq 
  8004218dab:	c3                   	retq   

0000008004218dac <pci_conf_read>:

static uint32_t
pci_conf_read(struct pci_func *f, uint32_t off)
{
  8004218dac:	55                   	push   %rbp
  8004218dad:	48 89 e5             	mov    %rsp,%rbp
  8004218db0:	48 83 ec 20          	sub    $0x20,%rsp
  8004218db4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004218db8:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  8004218dbb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218dbf:	8b 50 0c             	mov    0xc(%rax),%edx
  8004218dc2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218dc6:	8b 70 08             	mov    0x8(%rax),%esi
  8004218dc9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218dcd:	48 8b 00             	mov    (%rax),%rax
  8004218dd0:	8b 40 08             	mov    0x8(%rax),%eax
  8004218dd3:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004218dd6:	89 c7                	mov    %eax,%edi
  8004218dd8:	48 b8 25 8c 21 04 80 	movabs $0x8004218c25,%rax
  8004218ddf:	00 00 00 
  8004218de2:	ff d0                	callq  *%rax
	return inl(pci_conf1_data_ioport);
  8004218de4:	48 b8 e8 37 23 04 80 	movabs $0x80042337e8,%rax
  8004218deb:	00 00 00 
  8004218dee:	8b 00                	mov    (%rax),%eax
  8004218df0:	89 45 fc             	mov    %eax,-0x4(%rbp)

static __inline uint32_t
inl(int port)
{
	uint32_t data;
	__asm __volatile("inl %w1,%0" : "=a" (data) : "d" (port));
  8004218df3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218df6:	89 c2                	mov    %eax,%edx
  8004218df8:	ed                   	in     (%dx),%eax
  8004218df9:	89 45 f8             	mov    %eax,-0x8(%rbp)
	return data;
  8004218dfc:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004218dff:	90                   	nop
}
  8004218e00:	c9                   	leaveq 
  8004218e01:	c3                   	retq   

0000008004218e02 <pci_conf_write>:

static void
pci_conf_write(struct pci_func *f, uint32_t off, uint32_t v)
{
  8004218e02:	55                   	push   %rbp
  8004218e03:	48 89 e5             	mov    %rsp,%rbp
  8004218e06:	48 83 ec 20          	sub    $0x20,%rsp
  8004218e0a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004218e0e:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  8004218e11:	89 55 e0             	mov    %edx,-0x20(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  8004218e14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218e18:	8b 50 0c             	mov    0xc(%rax),%edx
  8004218e1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218e1f:	8b 70 08             	mov    0x8(%rax),%esi
  8004218e22:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218e26:	48 8b 00             	mov    (%rax),%rax
  8004218e29:	8b 40 08             	mov    0x8(%rax),%eax
  8004218e2c:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004218e2f:	89 c7                	mov    %eax,%edi
  8004218e31:	48 b8 25 8c 21 04 80 	movabs $0x8004218c25,%rax
  8004218e38:	00 00 00 
  8004218e3b:	ff d0                	callq  *%rax
	outl(pci_conf1_data_ioport, v);
  8004218e3d:	48 b8 e8 37 23 04 80 	movabs $0x80042337e8,%rax
  8004218e44:	00 00 00 
  8004218e47:	8b 00                	mov    (%rax),%eax
  8004218e49:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004218e4c:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004218e4f:	89 45 f8             	mov    %eax,-0x8(%rbp)
}

static __inline void
outl(int port, uint32_t data)
{
	__asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  8004218e52:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004218e55:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004218e58:	ef                   	out    %eax,(%dx)
}
  8004218e59:	90                   	nop
  8004218e5a:	c9                   	leaveq 
  8004218e5b:	c3                   	retq   

0000008004218e5c <pci_attach_match>:

static int __attribute__((warn_unused_result))
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
  8004218e5c:	55                   	push   %rbp
  8004218e5d:	48 89 e5             	mov    %rsp,%rbp
  8004218e60:	48 83 ec 30          	sub    $0x30,%rsp
  8004218e64:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004218e67:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8004218e6a:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  8004218e6e:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  8004218e72:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004218e79:	e9 aa 00 00 00       	jmpq   8004218f28 <pci_attach_match+0xcc>
		if (list[i].key1 == key1 && list[i].key2 == key2) {
  8004218e7e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218e81:	48 c1 e0 04          	shl    $0x4,%rax
  8004218e85:	48 89 c2             	mov    %rax,%rdx
  8004218e88:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218e8c:	48 01 d0             	add    %rdx,%rax
  8004218e8f:	8b 00                	mov    (%rax),%eax
  8004218e91:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004218e94:	0f 85 8a 00 00 00    	jne    8004218f24 <pci_attach_match+0xc8>
  8004218e9a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218e9d:	48 c1 e0 04          	shl    $0x4,%rax
  8004218ea1:	48 89 c2             	mov    %rax,%rdx
  8004218ea4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218ea8:	48 01 d0             	add    %rdx,%rax
  8004218eab:	8b 40 04             	mov    0x4(%rax),%eax
  8004218eae:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004218eb1:	75 71                	jne    8004218f24 <pci_attach_match+0xc8>
			int r = list[i].attachfn(pcif);
  8004218eb3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218eb6:	48 c1 e0 04          	shl    $0x4,%rax
  8004218eba:	48 89 c2             	mov    %rax,%rdx
  8004218ebd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218ec1:	48 01 d0             	add    %rdx,%rax
  8004218ec4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004218ec8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004218ecc:	48 89 d7             	mov    %rdx,%rdi
  8004218ecf:	ff d0                	callq  *%rax
  8004218ed1:	89 45 f8             	mov    %eax,-0x8(%rbp)
			if (r > 0)
  8004218ed4:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004218ed8:	7e 05                	jle    8004218edf <pci_attach_match+0x83>
				return r;
  8004218eda:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004218edd:	eb 6c                	jmp    8004218f4b <pci_attach_match+0xef>
			if (r < 0)
  8004218edf:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004218ee3:	79 3f                	jns    8004218f24 <pci_attach_match+0xc8>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
  8004218ee5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218ee8:	48 c1 e0 04          	shl    $0x4,%rax
  8004218eec:	48 89 c2             	mov    %rax,%rdx
  8004218eef:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218ef3:	48 01 d0             	add    %rdx,%rax
		if (list[i].key1 == key1 && list[i].key2 == key2) {
			int r = list[i].attachfn(pcif);
			if (r > 0)
				return r;
			if (r < 0)
				cprintf("pci_attach_match: attaching "
  8004218ef6:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004218efa:	8b 75 f8             	mov    -0x8(%rbp),%esi
  8004218efd:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004218f00:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218f03:	41 89 f0             	mov    %esi,%r8d
  8004218f06:	89 c6                	mov    %eax,%esi
  8004218f08:	48 bf 70 1c 22 04 80 	movabs $0x8004221c70,%rdi
  8004218f0f:	00 00 00 
  8004218f12:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218f17:	49 b9 09 9d 20 04 80 	movabs $0x8004209d09,%r9
  8004218f1e:	00 00 00 
  8004218f21:	41 ff d1             	callq  *%r9
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  8004218f24:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004218f28:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218f2b:	48 c1 e0 04          	shl    $0x4,%rax
  8004218f2f:	48 89 c2             	mov    %rax,%rdx
  8004218f32:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218f36:	48 01 d0             	add    %rdx,%rax
  8004218f39:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004218f3d:	48 85 c0             	test   %rax,%rax
  8004218f40:	0f 85 38 ff ff ff    	jne    8004218e7e <pci_attach_match+0x22>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
		}
	}
	return 0;
  8004218f46:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004218f4b:	c9                   	leaveq 
  8004218f4c:	c3                   	retq   

0000008004218f4d <pci_attach>:

static int
pci_attach(struct pci_func *f)
{
  8004218f4d:	55                   	push   %rbp
  8004218f4e:	48 89 e5             	mov    %rsp,%rbp
  8004218f51:	48 83 ec 10          	sub    $0x10,%rsp
  8004218f55:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
  8004218f59:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218f5d:	8b 40 14             	mov    0x14(%rax),%eax
  8004218f60:	c1 e8 10             	shr    $0x10,%eax

static int
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
  8004218f63:	0f b6 c0             	movzbl %al,%eax
  8004218f66:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004218f6a:	8b 52 14             	mov    0x14(%rdx),%edx
  8004218f6d:	89 d7                	mov    %edx,%edi
  8004218f6f:	c1 ef 18             	shr    $0x18,%edi
  8004218f72:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004218f76:	48 89 d1             	mov    %rdx,%rcx
  8004218f79:	48 ba 00 38 23 04 80 	movabs $0x8004233800,%rdx
  8004218f80:	00 00 00 
  8004218f83:	89 c6                	mov    %eax,%esi
  8004218f85:	48 b8 5c 8e 21 04 80 	movabs $0x8004218e5c,%rax
  8004218f8c:	00 00 00 
  8004218f8f:	ff d0                	callq  *%rax
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
  8004218f91:	85 c0                	test   %eax,%eax
  8004218f93:	75 39                	jne    8004218fce <pci_attach+0x81>
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
  8004218f95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218f99:	8b 40 10             	mov    0x10(%rax),%eax
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
		pci_attach_match(PCI_VENDOR(f->dev_id),
  8004218f9c:	c1 e8 10             	shr    $0x10,%eax
  8004218f9f:	89 c6                	mov    %eax,%esi
  8004218fa1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218fa5:	8b 40 10             	mov    0x10(%rax),%eax
  8004218fa8:	0f b7 c0             	movzwl %ax,%eax
  8004218fab:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004218faf:	48 89 d1             	mov    %rdx,%rcx
  8004218fb2:	48 ba 20 38 23 04 80 	movabs $0x8004233820,%rdx
  8004218fb9:	00 00 00 
  8004218fbc:	89 c7                	mov    %eax,%edi
  8004218fbe:	48 b8 5c 8e 21 04 80 	movabs $0x8004218e5c,%rax
  8004218fc5:	00 00 00 
  8004218fc8:	ff d0                	callq  *%rax
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
  8004218fca:	85 c0                	test   %eax,%eax
  8004218fcc:	74 07                	je     8004218fd5 <pci_attach+0x88>
  8004218fce:	b8 01 00 00 00       	mov    $0x1,%eax
  8004218fd3:	eb 05                	jmp    8004218fda <pci_attach+0x8d>
  8004218fd5:	b8 00 00 00 00       	mov    $0x0,%eax
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
				 &pci_attach_vendor[0], f);
}
  8004218fda:	c9                   	leaveq 
  8004218fdb:	c3                   	retq   

0000008004218fdc <pci_print_func>:
	[0x6] = "Bridge device",
};

static void
pci_print_func(struct pci_func *f)
{
  8004218fdc:	55                   	push   %rbp
  8004218fdd:	48 89 e5             	mov    %rsp,%rbp
  8004218fe0:	48 83 ec 20          	sub    $0x20,%rsp
  8004218fe4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	const char *class = pci_class[0];
  8004218fe8:	48 b8 40 38 23 04 80 	movabs $0x8004233840,%rax
  8004218fef:	00 00 00 
  8004218ff2:	48 8b 00             	mov    (%rax),%rax
  8004218ff5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
  8004218ff9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218ffd:	8b 40 14             	mov    0x14(%rax),%eax
  8004219000:	c1 e8 18             	shr    $0x18,%eax
  8004219003:	83 f8 06             	cmp    $0x6,%eax
  8004219006:	77 20                	ja     8004219028 <pci_print_func+0x4c>
		class = pci_class[PCI_CLASS(f->dev_class)];
  8004219008:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421900c:	8b 40 14             	mov    0x14(%rax),%eax
  800421900f:	c1 e8 18             	shr    $0x18,%eax
  8004219012:	89 c2                	mov    %eax,%edx
  8004219014:	48 b8 40 38 23 04 80 	movabs $0x8004233840,%rax
  800421901b:	00 00 00 
  800421901e:	89 d2                	mov    %edx,%edx
  8004219020:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004219024:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
  8004219028:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421902c:	0f b6 40 48          	movzbl 0x48(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004219030:	0f b6 f8             	movzbl %al,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  8004219033:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219037:	8b 40 14             	mov    0x14(%rax),%eax
  800421903a:	c1 e8 10             	shr    $0x10,%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  800421903d:	0f b6 f0             	movzbl %al,%esi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  8004219040:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219044:	8b 40 14             	mov    0x14(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004219047:	c1 e8 18             	shr    $0x18,%eax
  800421904a:	41 89 c1             	mov    %eax,%r9d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  800421904d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219051:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004219054:	c1 e8 10             	shr    $0x10,%eax
  8004219057:	41 89 c2             	mov    %eax,%r10d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  800421905a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421905e:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004219061:	44 0f b7 c0          	movzwl %ax,%r8d
  8004219065:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219069:	8b 48 0c             	mov    0xc(%rax),%ecx
  800421906c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219070:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  8004219073:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219077:	48 8b 00             	mov    (%rax),%rax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  800421907a:	8b 40 08             	mov    0x8(%rax),%eax
  800421907d:	57                   	push   %rdi
  800421907e:	ff 75 f8             	pushq  -0x8(%rbp)
  8004219081:	56                   	push   %rsi
  8004219082:	41 51                	push   %r9
  8004219084:	45 89 d1             	mov    %r10d,%r9d
  8004219087:	89 c6                	mov    %eax,%esi
  8004219089:	48 bf 10 1d 22 04 80 	movabs $0x8004221d10,%rdi
  8004219090:	00 00 00 
  8004219093:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219098:	49 ba 09 9d 20 04 80 	movabs $0x8004209d09,%r10
  800421909f:	00 00 00 
  80042190a2:	41 ff d2             	callq  *%r10
  80042190a5:	48 83 c4 20          	add    $0x20,%rsp
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
}
  80042190a9:	90                   	nop
  80042190aa:	c9                   	leaveq 
  80042190ab:	c3                   	retq   

00000080042190ac <pci_scan_bus>:

static int
pci_scan_bus(struct pci_bus *bus)
{
  80042190ac:	55                   	push   %rbp
  80042190ad:	48 89 e5             	mov    %rsp,%rbp
  80042190b0:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  80042190b7:	48 89 bd f8 fe ff ff 	mov    %rdi,-0x108(%rbp)
	int totaldev = 0;
  80042190be:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct pci_func df;
	memset(&df, 0, sizeof(df));
  80042190c5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042190c9:	ba 50 00 00 00       	mov    $0x50,%edx
  80042190ce:	be 00 00 00 00       	mov    $0x0,%esi
  80042190d3:	48 89 c7             	mov    %rax,%rdi
  80042190d6:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  80042190dd:	00 00 00 
  80042190e0:	ff d0                	callq  *%rax
	df.bus = bus;
  80042190e2:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  80042190e9:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

	for (df.dev = 0; df.dev < 32; df.dev++) {
  80042190ed:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%rbp)
  80042190f4:	e9 29 02 00 00       	jmpq   8004219322 <pci_scan_bus+0x276>
		uint32_t bhlc = pci_conf_read(&df, PCI_BHLC_REG);
  80042190f9:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042190fd:	be 0c 00 00 00       	mov    $0xc,%esi
  8004219102:	48 89 c7             	mov    %rax,%rdi
  8004219105:	48 b8 ac 8d 21 04 80 	movabs $0x8004218dac,%rax
  800421910c:	00 00 00 
  800421910f:	ff d0                	callq  *%rax
  8004219111:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (PCI_HDRTYPE_TYPE(bhlc) > 1)	    // Unsupported or no device
  8004219114:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004219117:	c1 e8 10             	shr    $0x10,%eax
  800421911a:	83 e0 7f             	and    $0x7f,%eax
  800421911d:	83 f8 01             	cmp    $0x1,%eax
  8004219120:	0f 87 f2 01 00 00    	ja     8004219318 <pci_scan_bus+0x26c>
			continue;

		totaldev++;
  8004219126:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)

		struct pci_func f = df;
  800421912a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421912e:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  8004219135:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004219139:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  8004219140:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004219144:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  800421914b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421914f:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  8004219156:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421915a:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  8004219161:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004219165:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  800421916c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004219170:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  8004219177:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421917b:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004219182:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219186:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800421918d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219191:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  8004219198:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%rbp)
  800421919f:	00 00 00 
  80042191a2:	e9 48 01 00 00       	jmpq   80042192ef <pci_scan_bus+0x243>
		     f.func++) {
			struct pci_func af = f;
  80042191a7:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  80042191ae:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  80042191b5:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  80042191bc:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  80042191c3:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042191ca:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  80042191d1:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042191d8:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  80042191df:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  80042191e6:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  80042191ed:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042191f4:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  80042191fb:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  8004219202:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  8004219206:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  800421920d:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004219211:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004219218:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  800421921c:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004219223:	48 89 45 98          	mov    %rax,-0x68(%rbp)

			af.dev_id = pci_conf_read(&f, PCI_ID_REG);
  8004219227:	48 8d 85 00 ff ff ff 	lea    -0x100(%rbp),%rax
  800421922e:	be 00 00 00 00       	mov    $0x0,%esi
  8004219233:	48 89 c7             	mov    %rax,%rdi
  8004219236:	48 b8 ac 8d 21 04 80 	movabs $0x8004218dac,%rax
  800421923d:	00 00 00 
  8004219240:	ff d0                	callq  *%rax
  8004219242:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
			if (PCI_VENDOR(af.dev_id) == 0xffff)
  8004219248:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
  800421924e:	0f b7 c0             	movzwl %ax,%eax
  8004219251:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004219256:	0f 84 83 00 00 00    	je     80042192df <pci_scan_bus+0x233>
				continue;

			uint32_t intr = pci_conf_read(&af, PCI_INTERRUPT_REG);
  800421925c:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004219263:	be 3c 00 00 00       	mov    $0x3c,%esi
  8004219268:	48 89 c7             	mov    %rax,%rdi
  800421926b:	48 b8 ac 8d 21 04 80 	movabs $0x8004218dac,%rax
  8004219272:	00 00 00 
  8004219275:	ff d0                	callq  *%rax
  8004219277:	89 45 f4             	mov    %eax,-0xc(%rbp)
			af.irq_line = PCI_INTERRUPT_LINE(intr);
  800421927a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421927d:	88 45 98             	mov    %al,-0x68(%rbp)

			af.dev_class = pci_conf_read(&af, PCI_CLASS_REG);
  8004219280:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004219287:	be 08 00 00 00       	mov    $0x8,%esi
  800421928c:	48 89 c7             	mov    %rax,%rdi
  800421928f:	48 b8 ac 8d 21 04 80 	movabs $0x8004218dac,%rax
  8004219296:	00 00 00 
  8004219299:	ff d0                	callq  *%rax
  800421929b:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%rbp)
			if (pci_show_devs)
  80042192a1:	48 b8 e0 37 23 04 80 	movabs $0x80042337e0,%rax
  80042192a8:	00 00 00 
  80042192ab:	8b 00                	mov    (%rax),%eax
  80042192ad:	85 c0                	test   %eax,%eax
  80042192af:	74 16                	je     80042192c7 <pci_scan_bus+0x21b>
				pci_print_func(&af);
  80042192b1:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042192b8:	48 89 c7             	mov    %rax,%rdi
  80042192bb:	48 b8 dc 8f 21 04 80 	movabs $0x8004218fdc,%rax
  80042192c2:	00 00 00 
  80042192c5:	ff d0                	callq  *%rax
			pci_attach(&af);
  80042192c7:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042192ce:	48 89 c7             	mov    %rax,%rdi
  80042192d1:	48 b8 4d 8f 21 04 80 	movabs $0x8004218f4d,%rax
  80042192d8:	00 00 00 
  80042192db:	ff d0                	callq  *%rax
  80042192dd:	eb 01                	jmp    80042192e0 <pci_scan_bus+0x234>
		     f.func++) {
			struct pci_func af = f;

			af.dev_id = pci_conf_read(&f, PCI_ID_REG);
			if (PCI_VENDOR(af.dev_id) == 0xffff)
				continue;
  80042192df:	90                   	nop

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
		     f.func++) {
  80042192e0:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  80042192e6:	83 c0 01             	add    $0x1,%eax
  80042192e9:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
			continue;

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  80042192ef:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  80042192f5:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80042192f8:	81 e2 00 00 80 00    	and    $0x800000,%edx
  80042192fe:	85 d2                	test   %edx,%edx
  8004219300:	74 07                	je     8004219309 <pci_scan_bus+0x25d>
  8004219302:	ba 08 00 00 00       	mov    $0x8,%edx
  8004219307:	eb 05                	jmp    800421930e <pci_scan_bus+0x262>
  8004219309:	ba 01 00 00 00       	mov    $0x1,%edx
  800421930e:	39 d0                	cmp    %edx,%eax
  8004219310:	0f 82 91 fe ff ff    	jb     80042191a7 <pci_scan_bus+0xfb>
  8004219316:	eb 01                	jmp    8004219319 <pci_scan_bus+0x26d>
	df.bus = bus;

	for (df.dev = 0; df.dev < 32; df.dev++) {
		uint32_t bhlc = pci_conf_read(&df, PCI_BHLC_REG);
		if (PCI_HDRTYPE_TYPE(bhlc) > 1)	    // Unsupported or no device
			continue;
  8004219318:	90                   	nop
	int totaldev = 0;
	struct pci_func df;
	memset(&df, 0, sizeof(df));
	df.bus = bus;

	for (df.dev = 0; df.dev < 32; df.dev++) {
  8004219319:	8b 45 a8             	mov    -0x58(%rbp),%eax
  800421931c:	83 c0 01             	add    $0x1,%eax
  800421931f:	89 45 a8             	mov    %eax,-0x58(%rbp)
  8004219322:	8b 45 a8             	mov    -0x58(%rbp),%eax
  8004219325:	83 f8 1f             	cmp    $0x1f,%eax
  8004219328:	0f 86 cb fd ff ff    	jbe    80042190f9 <pci_scan_bus+0x4d>
				pci_print_func(&af);
			pci_attach(&af);
		}
	}

	return totaldev;
  800421932e:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004219331:	c9                   	leaveq 
  8004219332:	c3                   	retq   

0000008004219333 <pci_bridge_attach>:

static int
pci_bridge_attach(struct pci_func *pcif)
{
  8004219333:	55                   	push   %rbp
  8004219334:	48 89 e5             	mov    %rsp,%rbp
  8004219337:	48 83 ec 30          	sub    $0x30,%rsp
  800421933b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
  800421933f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219343:	be 1c 00 00 00       	mov    $0x1c,%esi
  8004219348:	48 89 c7             	mov    %rax,%rdi
  800421934b:	48 b8 ac 8d 21 04 80 	movabs $0x8004218dac,%rax
  8004219352:	00 00 00 
  8004219355:	ff d0                	callq  *%rax
  8004219357:	89 45 fc             	mov    %eax,-0x4(%rbp)
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);
  800421935a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421935e:	be 18 00 00 00       	mov    $0x18,%esi
  8004219363:	48 89 c7             	mov    %rax,%rdi
  8004219366:	48 b8 ac 8d 21 04 80 	movabs $0x8004218dac,%rax
  800421936d:	00 00 00 
  8004219370:	ff d0                	callq  *%rax
  8004219372:	89 45 f8             	mov    %eax,-0x8(%rbp)

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
  8004219375:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219378:	83 e0 0f             	and    $0xf,%eax
  800421937b:	83 f8 01             	cmp    $0x1,%eax
  800421937e:	75 40                	jne    80042193c0 <pci_bridge_attach+0x8d>
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  8004219380:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219384:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004219387:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421938b:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func);
  800421938e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219392:	48 8b 00             	mov    (%rax),%rax
{
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  8004219395:	8b 40 08             	mov    0x8(%rax),%eax
  8004219398:	89 c6                	mov    %eax,%esi
  800421939a:	48 bf 50 1d 22 04 80 	movabs $0x8004221d50,%rdi
  80042193a1:	00 00 00 
  80042193a4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042193a9:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  80042193b0:	00 00 00 
  80042193b3:	41 ff d0             	callq  *%r8
			pcif->bus->busno, pcif->dev, pcif->func);
		return 0;
  80042193b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042193bb:	e9 a1 00 00 00       	jmpq   8004219461 <pci_bridge_attach+0x12e>
	}

	struct pci_bus nbus;
	memset(&nbus, 0, sizeof(nbus));
  80042193c0:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80042193c4:	ba 10 00 00 00       	mov    $0x10,%edx
  80042193c9:	be 00 00 00 00       	mov    $0x0,%esi
  80042193ce:	48 89 c7             	mov    %rax,%rdi
  80042193d1:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  80042193d8:	00 00 00 
  80042193db:	ff d0                	callq  *%rax
	nbus.parent_bridge = pcif;
  80042193dd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042193e1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;
  80042193e5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042193e8:	c1 e8 08             	shr    $0x8,%eax
  80042193eb:	0f b6 c0             	movzbl %al,%eax
  80042193ee:	89 45 e8             	mov    %eax,-0x18(%rbp)

	if (pci_show_devs)
  80042193f1:	48 b8 e0 37 23 04 80 	movabs $0x80042337e0,%rax
  80042193f8:	00 00 00 
  80042193fb:	8b 00                	mov    (%rax),%eax
  80042193fd:	85 c0                	test   %eax,%eax
  80042193ff:	74 48                	je     8004219449 <pci_bridge_attach+0x116>
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);
  8004219401:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004219404:	c1 e8 10             	shr    $0x10,%eax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  8004219407:	0f b6 f8             	movzbl %al,%edi
  800421940a:	8b 75 e8             	mov    -0x18(%rbp),%esi
  800421940d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219411:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004219414:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219418:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func,
  800421941b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421941f:	48 8b 00             	mov    (%rax),%rax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  8004219422:	8b 40 08             	mov    0x8(%rax),%eax
  8004219425:	41 89 f9             	mov    %edi,%r9d
  8004219428:	41 89 f0             	mov    %esi,%r8d
  800421942b:	89 c6                	mov    %eax,%esi
  800421942d:	48 bf 88 1d 22 04 80 	movabs $0x8004221d88,%rdi
  8004219434:	00 00 00 
  8004219437:	b8 00 00 00 00       	mov    $0x0,%eax
  800421943c:	49 ba 09 9d 20 04 80 	movabs $0x8004209d09,%r10
  8004219443:	00 00 00 
  8004219446:	41 ff d2             	callq  *%r10
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);

	pci_scan_bus(&nbus);
  8004219449:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800421944d:	48 89 c7             	mov    %rax,%rdi
  8004219450:	48 b8 ac 90 21 04 80 	movabs $0x80042190ac,%rax
  8004219457:	00 00 00 
  800421945a:	ff d0                	callq  *%rax
	return 1;
  800421945c:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004219461:	c9                   	leaveq 
  8004219462:	c3                   	retq   

0000008004219463 <pci_func_enable>:

// External PCI subsystem interface

void
pci_func_enable(struct pci_func *f)
{
  8004219463:	55                   	push   %rbp
  8004219464:	48 89 e5             	mov    %rsp,%rbp
  8004219467:	48 83 ec 30          	sub    $0x30,%rsp
  800421946b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	pci_conf_write(f, PCI_COMMAND_STATUS_REG,
  800421946f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219473:	ba 07 00 00 00       	mov    $0x7,%edx
  8004219478:	be 04 00 00 00       	mov    $0x4,%esi
  800421947d:	48 89 c7             	mov    %rax,%rdi
  8004219480:	48 b8 02 8e 21 04 80 	movabs $0x8004218e02,%rax
  8004219487:	00 00 00 
  800421948a:	ff d0                	callq  *%rax
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  800421948c:	c7 45 f8 10 00 00 00 	movl   $0x10,-0x8(%rbp)
  8004219493:	e9 f0 01 00 00       	jmpq   8004219688 <pci_func_enable+0x225>
	     bar += bar_width)
	{
		uint32_t oldv = pci_conf_read(f, bar);
  8004219498:	8b 55 f8             	mov    -0x8(%rbp),%edx
  800421949b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421949f:	89 d6                	mov    %edx,%esi
  80042194a1:	48 89 c7             	mov    %rax,%rdi
  80042194a4:	48 b8 ac 8d 21 04 80 	movabs $0x8004218dac,%rax
  80042194ab:	00 00 00 
  80042194ae:	ff d0                	callq  *%rax
  80042194b0:	89 45 ec             	mov    %eax,-0x14(%rbp)

		bar_width = 4;
  80042194b3:	c7 45 fc 04 00 00 00 	movl   $0x4,-0x4(%rbp)
		pci_conf_write(f, bar, 0xffffffff);
  80042194ba:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  80042194bd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042194c1:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80042194c6:	89 ce                	mov    %ecx,%esi
  80042194c8:	48 89 c7             	mov    %rax,%rdi
  80042194cb:	48 b8 02 8e 21 04 80 	movabs $0x8004218e02,%rax
  80042194d2:	00 00 00 
  80042194d5:	ff d0                	callq  *%rax
		uint32_t rv = pci_conf_read(f, bar);
  80042194d7:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80042194da:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042194de:	89 d6                	mov    %edx,%esi
  80042194e0:	48 89 c7             	mov    %rax,%rdi
  80042194e3:	48 b8 ac 8d 21 04 80 	movabs $0x8004218dac,%rax
  80042194ea:	00 00 00 
  80042194ed:	ff d0                	callq  *%rax
  80042194ef:	89 45 e8             	mov    %eax,-0x18(%rbp)

		if (rv == 0)
  80042194f2:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80042194f6:	0f 84 85 01 00 00    	je     8004219681 <pci_func_enable+0x21e>
			continue;

		int regnum = PCI_MAPREG_NUM(bar);
  80042194fc:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042194ff:	83 e8 10             	sub    $0x10,%eax
  8004219502:	c1 e8 02             	shr    $0x2,%eax
  8004219505:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		uint32_t base, size;
		if (PCI_MAPREG_TYPE(rv) == PCI_MAPREG_TYPE_MEM) {
  8004219508:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421950b:	83 e0 01             	and    $0x1,%eax
  800421950e:	85 c0                	test   %eax,%eax
  8004219510:	75 65                	jne    8004219577 <pci_func_enable+0x114>
			if (PCI_MAPREG_MEM_TYPE(rv) == PCI_MAPREG_MEM_TYPE_64BIT)
  8004219512:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004219515:	83 e0 06             	and    $0x6,%eax
  8004219518:	83 f8 04             	cmp    $0x4,%eax
  800421951b:	75 07                	jne    8004219524 <pci_func_enable+0xc1>
				bar_width = 8;
  800421951d:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%rbp)

			size = PCI_MAPREG_MEM_SIZE(rv);
  8004219524:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004219527:	83 e0 f0             	and    $0xfffffff0,%eax
  800421952a:	f7 d8                	neg    %eax
  800421952c:	23 45 e8             	and    -0x18(%rbp),%eax
  800421952f:	83 e0 f0             	and    $0xfffffff0,%eax
  8004219532:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_MEM_ADDR(oldv);
  8004219535:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004219538:	83 e0 f0             	and    $0xfffffff0,%eax
  800421953b:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  800421953e:	48 b8 a0 c5 6d 04 80 	movabs $0x80046dc5a0,%rax
  8004219545:	00 00 00 
  8004219548:	8b 00                	mov    (%rax),%eax
  800421954a:	85 c0                	test   %eax,%eax
  800421954c:	74 7a                	je     80042195c8 <pci_func_enable+0x165>
				cprintf("  mem region %d: %d bytes at 0x%x\n",
  800421954e:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004219551:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004219554:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004219557:	89 c6                	mov    %eax,%esi
  8004219559:	48 bf b8 1d 22 04 80 	movabs $0x8004221db8,%rdi
  8004219560:	00 00 00 
  8004219563:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219568:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421956f:	00 00 00 
  8004219572:	41 ff d0             	callq  *%r8
  8004219575:	eb 51                	jmp    80042195c8 <pci_func_enable+0x165>
					regnum, size, base);
		} else {
			size = PCI_MAPREG_IO_SIZE(rv);
  8004219577:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421957a:	83 e0 fc             	and    $0xfffffffc,%eax
  800421957d:	f7 d8                	neg    %eax
  800421957f:	23 45 e8             	and    -0x18(%rbp),%eax
  8004219582:	83 e0 fc             	and    $0xfffffffc,%eax
  8004219585:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_IO_ADDR(oldv);
  8004219588:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421958b:	83 e0 fc             	and    $0xfffffffc,%eax
  800421958e:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  8004219591:	48 b8 a0 c5 6d 04 80 	movabs $0x80046dc5a0,%rax
  8004219598:	00 00 00 
  800421959b:	8b 00                	mov    (%rax),%eax
  800421959d:	85 c0                	test   %eax,%eax
  800421959f:	74 27                	je     80042195c8 <pci_func_enable+0x165>
				cprintf("  io region %d: %d bytes at 0x%x\n",
  80042195a1:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80042195a4:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042195a7:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042195aa:	89 c6                	mov    %eax,%esi
  80042195ac:	48 bf e0 1d 22 04 80 	movabs $0x8004221de0,%rdi
  80042195b3:	00 00 00 
  80042195b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042195bb:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  80042195c2:	00 00 00 
  80042195c5:	41 ff d0             	callq  *%r8
					regnum, size, base);
		}

		pci_conf_write(f, bar, oldv);
  80042195c8:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042195cb:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  80042195ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042195d2:	89 ce                	mov    %ecx,%esi
  80042195d4:	48 89 c7             	mov    %rax,%rdi
  80042195d7:	48 b8 02 8e 21 04 80 	movabs $0x8004218e02,%rax
  80042195de:	00 00 00 
  80042195e1:	ff d0                	callq  *%rax
		f->reg_base[regnum] = base;
  80042195e3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042195e7:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042195ea:	48 63 d2             	movslq %edx,%rdx
  80042195ed:	48 8d 4a 04          	lea    0x4(%rdx),%rcx
  80042195f1:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042195f4:	89 54 88 08          	mov    %edx,0x8(%rax,%rcx,4)
		f->reg_size[regnum] = size;
  80042195f8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042195fc:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042195ff:	48 63 d2             	movslq %edx,%rdx
  8004219602:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  8004219606:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004219609:	89 14 88             	mov    %edx,(%rax,%rcx,4)

		if (size && !base)
  800421960c:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8004219610:	74 70                	je     8004219682 <pci_func_enable+0x21f>
  8004219612:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004219616:	75 6a                	jne    8004219682 <pci_func_enable+0x21f>
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004219618:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421961c:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  800421961f:	c1 e8 10             	shr    $0x10,%eax
  8004219622:	41 89 c0             	mov    %eax,%r8d
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004219625:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219629:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  800421962c:	0f b7 f8             	movzwl %ax,%edi
  800421962f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219633:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004219636:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421963a:	8b 50 08             	mov    0x8(%rax),%edx
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
  800421963d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219641:	48 8b 00             	mov    (%rax),%rax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004219644:	8b 40 08             	mov    0x8(%rax),%eax
  8004219647:	48 83 ec 08          	sub    $0x8,%rsp
  800421964b:	8b 75 f0             	mov    -0x10(%rbp),%esi
  800421964e:	56                   	push   %rsi
  800421964f:	8b 75 f4             	mov    -0xc(%rbp),%esi
  8004219652:	56                   	push   %rsi
  8004219653:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  8004219656:	56                   	push   %rsi
  8004219657:	45 89 c1             	mov    %r8d,%r9d
  800421965a:	41 89 f8             	mov    %edi,%r8d
  800421965d:	89 c6                	mov    %eax,%esi
  800421965f:	48 bf 08 1e 22 04 80 	movabs $0x8004221e08,%rdi
  8004219666:	00 00 00 
  8004219669:	b8 00 00 00 00       	mov    $0x0,%eax
  800421966e:	49 ba 09 9d 20 04 80 	movabs $0x8004209d09,%r10
  8004219675:	00 00 00 
  8004219678:	41 ff d2             	callq  *%r10
  800421967b:	48 83 c4 20          	add    $0x20,%rsp
  800421967f:	eb 01                	jmp    8004219682 <pci_func_enable+0x21f>
		bar_width = 4;
		pci_conf_write(f, bar, 0xffffffff);
		uint32_t rv = pci_conf_read(f, bar);

		if (rv == 0)
			continue;
  8004219681:	90                   	nop
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
	     bar += bar_width)
  8004219682:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219685:	01 45 f8             	add    %eax,-0x8(%rbp)
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  8004219688:	83 7d f8 27          	cmpl   $0x27,-0x8(%rbp)
  800421968c:	0f 86 06 fe ff ff    	jbe    8004219498 <pci_func_enable+0x35>
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  8004219692:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219696:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004219699:	c1 e8 10             	shr    $0x10,%eax
  800421969c:	89 c7                	mov    %eax,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  800421969e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042196a2:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  80042196a5:	0f b7 f0             	movzwl %ax,%esi
  80042196a8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042196ac:	8b 48 0c             	mov    0xc(%rax),%ecx
  80042196af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042196b3:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  80042196b6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042196ba:	48 8b 00             	mov    (%rax),%rax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  80042196bd:	8b 40 08             	mov    0x8(%rax),%eax
  80042196c0:	41 89 f9             	mov    %edi,%r9d
  80042196c3:	41 89 f0             	mov    %esi,%r8d
  80042196c6:	89 c6                	mov    %eax,%esi
  80042196c8:	48 bf 68 1e 22 04 80 	movabs $0x8004221e68,%rdi
  80042196cf:	00 00 00 
  80042196d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042196d7:	49 ba 09 9d 20 04 80 	movabs $0x8004209d09,%r10
  80042196de:	00 00 00 
  80042196e1:	41 ff d2             	callq  *%r10
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
}
  80042196e4:	90                   	nop
  80042196e5:	c9                   	leaveq 
  80042196e6:	c3                   	retq   

00000080042196e7 <pci_init>:

int
pci_init(void)
{
  80042196e7:	55                   	push   %rbp
  80042196e8:	48 89 e5             	mov    %rsp,%rbp
	static struct pci_bus root_bus;
	memset(&root_bus, 0, sizeof(root_bus));
  80042196eb:	ba 10 00 00 00       	mov    $0x10,%edx
  80042196f0:	be 00 00 00 00       	mov    $0x0,%esi
  80042196f5:	48 bf b0 c5 6d 04 80 	movabs $0x80046dc5b0,%rdi
  80042196fc:	00 00 00 
  80042196ff:	48 b8 8b 0f 21 04 80 	movabs $0x8004210f8b,%rax
  8004219706:	00 00 00 
  8004219709:	ff d0                	callq  *%rax

	return pci_scan_bus(&root_bus);
  800421970b:	48 bf b0 c5 6d 04 80 	movabs $0x80046dc5b0,%rdi
  8004219712:	00 00 00 
  8004219715:	48 b8 ac 90 21 04 80 	movabs $0x80042190ac,%rax
  800421971c:	00 00 00 
  800421971f:	ff d0                	callq  *%rax
}
  8004219721:	5d                   	pop    %rbp
  8004219722:	c3                   	retq   

0000008004219723 <time_init>:

static unsigned int ticks;

void
time_init(void)
{
  8004219723:	55                   	push   %rbp
  8004219724:	48 89 e5             	mov    %rsp,%rbp
	ticks = 0;
  8004219727:	48 b8 c0 c5 6d 04 80 	movabs $0x80046dc5c0,%rax
  800421972e:	00 00 00 
  8004219731:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
  8004219737:	90                   	nop
  8004219738:	5d                   	pop    %rbp
  8004219739:	c3                   	retq   

000000800421973a <time_tick>:

// This should be called once per timer interrupt.  A timer interrupt
// fires every 10 ms.
void
time_tick(void)
{
  800421973a:	55                   	push   %rbp
  800421973b:	48 89 e5             	mov    %rsp,%rbp
	ticks++;
  800421973e:	48 b8 c0 c5 6d 04 80 	movabs $0x80046dc5c0,%rax
  8004219745:	00 00 00 
  8004219748:	8b 00                	mov    (%rax),%eax
  800421974a:	8d 50 01             	lea    0x1(%rax),%edx
  800421974d:	48 b8 c0 c5 6d 04 80 	movabs $0x80046dc5c0,%rax
  8004219754:	00 00 00 
  8004219757:	89 10                	mov    %edx,(%rax)
	if (ticks * 10 < ticks)
  8004219759:	48 b8 c0 c5 6d 04 80 	movabs $0x80046dc5c0,%rax
  8004219760:	00 00 00 
  8004219763:	8b 10                	mov    (%rax),%edx
  8004219765:	89 d0                	mov    %edx,%eax
  8004219767:	c1 e0 02             	shl    $0x2,%eax
  800421976a:	01 d0                	add    %edx,%eax
  800421976c:	01 c0                	add    %eax,%eax
  800421976e:	89 c2                	mov    %eax,%edx
  8004219770:	48 b8 c0 c5 6d 04 80 	movabs $0x80046dc5c0,%rax
  8004219777:	00 00 00 
  800421977a:	8b 00                	mov    (%rax),%eax
  800421977c:	39 c2                	cmp    %eax,%edx
  800421977e:	73 2a                	jae    80042197aa <time_tick+0x70>
		panic("time_tick: time overflowed");
  8004219780:	48 ba 97 1e 22 04 80 	movabs $0x8004221e97,%rdx
  8004219787:	00 00 00 
  800421978a:	be 14 00 00 00       	mov    $0x14,%esi
  800421978f:	48 bf b2 1e 22 04 80 	movabs $0x8004221eb2,%rdi
  8004219796:	00 00 00 
  8004219799:	b8 00 00 00 00       	mov    $0x0,%eax
  800421979e:	48 b9 f3 04 20 04 80 	movabs $0x80042004f3,%rcx
  80042197a5:	00 00 00 
  80042197a8:	ff d1                	callq  *%rcx
}
  80042197aa:	90                   	nop
  80042197ab:	5d                   	pop    %rbp
  80042197ac:	c3                   	retq   

00000080042197ad <time_msec>:

unsigned int
time_msec(void)
{
  80042197ad:	55                   	push   %rbp
  80042197ae:	48 89 e5             	mov    %rsp,%rbp
	return ticks * 10;
  80042197b1:	48 b8 c0 c5 6d 04 80 	movabs $0x80046dc5c0,%rax
  80042197b8:	00 00 00 
  80042197bb:	8b 10                	mov    (%rax),%edx
  80042197bd:	89 d0                	mov    %edx,%eax
  80042197bf:	c1 e0 02             	shl    $0x2,%eax
  80042197c2:	01 d0                	add    %edx,%eax
  80042197c4:	01 c0                	add    %eax,%eax
}
  80042197c6:	5d                   	pop    %rbp
  80042197c7:	c3                   	retq   

00000080042197c8 <page2ppn>:
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);


static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  80042197c8:	55                   	push   %rbp
  80042197c9:	48 89 e5             	mov    %rsp,%rbp
  80042197cc:	48 83 ec 08          	sub    $0x8,%rsp
  80042197d0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  80042197d4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042197d8:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  80042197df:	00 00 00 
  80042197e2:	48 8b 00             	mov    (%rax),%rax
  80042197e5:	48 29 c2             	sub    %rax,%rdx
  80042197e8:	48 89 d0             	mov    %rdx,%rax
  80042197eb:	48 c1 f8 04          	sar    $0x4,%rax
}
  80042197ef:	c9                   	leaveq 
  80042197f0:	c3                   	retq   

00000080042197f1 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  80042197f1:	55                   	push   %rbp
  80042197f2:	48 89 e5             	mov    %rsp,%rbp
  80042197f5:	48 83 ec 08          	sub    $0x8,%rsp
  80042197f9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  80042197fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004219801:	48 89 c7             	mov    %rax,%rdi
  8004219804:	48 b8 c8 97 21 04 80 	movabs $0x80042197c8,%rax
  800421980b:	00 00 00 
  800421980e:	ff d0                	callq  *%rax
  8004219810:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004219814:	c9                   	leaveq 
  8004219815:	c3                   	retq   

0000008004219816 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004219816:	55                   	push   %rbp
  8004219817:	48 89 e5             	mov    %rsp,%rbp
  800421981a:	48 83 ec 10          	sub    $0x10,%rsp
  800421981e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004219822:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004219826:	48 c1 e8 0c          	shr    $0xc,%rax
  800421982a:	48 89 c2             	mov    %rax,%rdx
  800421982d:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004219834:	00 00 00 
  8004219837:	48 8b 00             	mov    (%rax),%rax
  800421983a:	48 39 c2             	cmp    %rax,%rdx
  800421983d:	72 2a                	jb     8004219869 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  800421983f:	48 ba c0 1e 22 04 80 	movabs $0x8004221ec0,%rdx
  8004219846:	00 00 00 
  8004219849:	be 5a 00 00 00       	mov    $0x5a,%esi
  800421984e:	48 bf df 1e 22 04 80 	movabs $0x8004221edf,%rdi
  8004219855:	00 00 00 
  8004219858:	b8 00 00 00 00       	mov    $0x0,%eax
  800421985d:	48 b9 f3 04 20 04 80 	movabs $0x80042004f3,%rcx
  8004219864:	00 00 00 
  8004219867:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004219869:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  8004219870:	00 00 00 
  8004219873:	48 8b 00             	mov    (%rax),%rax
  8004219876:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421987a:	48 c1 ea 0c          	shr    $0xc,%rdx
  800421987e:	48 c1 e2 04          	shl    $0x4,%rdx
  8004219882:	48 01 d0             	add    %rdx,%rax
}
  8004219885:	c9                   	leaveq 
  8004219886:	c3                   	retq   

0000008004219887 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004219887:	55                   	push   %rbp
  8004219888:	48 89 e5             	mov    %rsp,%rbp
  800421988b:	48 83 ec 20          	sub    $0x20,%rsp
  800421988f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004219893:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219897:	48 89 c7             	mov    %rax,%rdi
  800421989a:	48 b8 f1 97 21 04 80 	movabs $0x80042197f1,%rax
  80042198a1:	00 00 00 
  80042198a4:	ff d0                	callq  *%rax
  80042198a6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042198aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042198ae:	48 c1 e8 0c          	shr    $0xc,%rax
  80042198b2:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042198b5:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042198b8:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  80042198bf:	00 00 00 
  80042198c2:	48 8b 00             	mov    (%rax),%rax
  80042198c5:	48 39 c2             	cmp    %rax,%rdx
  80042198c8:	72 32                	jb     80042198fc <page2kva+0x75>
  80042198ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042198ce:	48 89 c1             	mov    %rax,%rcx
  80042198d1:	48 ba f0 1e 22 04 80 	movabs $0x8004221ef0,%rdx
  80042198d8:	00 00 00 
  80042198db:	be 61 00 00 00       	mov    $0x61,%esi
  80042198e0:	48 bf df 1e 22 04 80 	movabs $0x8004221edf,%rdi
  80042198e7:	00 00 00 
  80042198ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80042198ef:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  80042198f6:	00 00 00 
  80042198f9:	41 ff d0             	callq  *%r8
  80042198fc:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004219903:	00 00 00 
  8004219906:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421990a:	48 01 d0             	add    %rdx,%rax
}
  800421990d:	c9                   	leaveq 
  800421990e:	c3                   	retq   

000000800421990f <epte_addr>:
#include <kern/pmap.h>
#include <inc/string.h>

// Return the physical address of an ept entry
static inline uintptr_t epte_addr(epte_t epte)
{
  800421990f:	55                   	push   %rbp
  8004219910:	48 89 e5             	mov    %rsp,%rbp
  8004219913:	48 83 ec 08          	sub    $0x8,%rsp
  8004219917:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return (epte & EPTE_ADDR);
  800421991b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421991f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  8004219925:	c9                   	leaveq 
  8004219926:	c3                   	retq   

0000008004219927 <epte_present>:
	return (epte & EPTE_FLAGS);
}

// Return true if an ept entry's mapping is present
static inline int epte_present(epte_t epte)
{
  8004219927:	55                   	push   %rbp
  8004219928:	48 89 e5             	mov    %rsp,%rbp
  800421992b:	48 83 ec 08          	sub    $0x8,%rsp
  800421992f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return (epte & __EPTE_FULL) > 0;
  8004219933:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004219937:	83 e0 07             	and    $0x7,%eax
  800421993a:	48 85 c0             	test   %rax,%rax
  800421993d:	0f 95 c0             	setne  %al
  8004219940:	0f b6 c0             	movzbl %al,%eax
}
  8004219943:	c9                   	leaveq 
  8004219944:	c3                   	retq   

0000008004219945 <ept_lookup_gpa>:
//
// Hint: Set the permissions of intermediate ept entries to __EPTE_FULL.
//       The hardware ANDs the permissions at each level, so removing a permission
//       bit at the last level entry is sufficient (and the bookkeeping is much simpler).
static int ept_lookup_gpa(epte_t* eptrt, void *gpa, 
			  int create, epte_t **epte_out) {
  8004219945:	55                   	push   %rbp
  8004219946:	48 89 e5             	mov    %rsp,%rbp
  8004219949:	48 83 ec 30          	sub    $0x30,%rsp
  800421994d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004219951:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004219955:	89 55 dc             	mov    %edx,-0x24(%rbp)
  8004219958:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
    	/* Your code here */
	
	if (eptrt == NULL) 
  800421995c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004219961:	75 07                	jne    800421996a <ept_lookup_gpa+0x25>
		return -E_INVAL;
  8004219963:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8004219968:	eb 60                	jmp    80042199ca <ept_lookup_gpa+0x85>

	epte_t *epte = pml4e_walk(eptrt, gpa, create);
  800421996a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800421996d:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004219971:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219975:	48 89 ce             	mov    %rcx,%rsi
  8004219978:	48 89 c7             	mov    %rax,%rdi
  800421997b:	48 b8 73 30 20 04 80 	movabs $0x8004203073,%rax
  8004219982:	00 00 00 
  8004219985:	ff d0                	callq  *%rax
  8004219987:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	
	if (epte == NULL && create)
  800421998b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004219990:	75 0d                	jne    800421999f <ept_lookup_gpa+0x5a>
  8004219992:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004219996:	74 07                	je     800421999f <ept_lookup_gpa+0x5a>
		return -E_NO_MEM;
  8004219998:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800421999d:	eb 2b                	jmp    80042199ca <ept_lookup_gpa+0x85>

	if (epte == NULL && create == 0)
  800421999f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042199a4:	75 0d                	jne    80042199b3 <ept_lookup_gpa+0x6e>
  80042199a6:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042199aa:	75 07                	jne    80042199b3 <ept_lookup_gpa+0x6e>
		return -E_NO_ENT;
  80042199ac:	b8 eb ff ff ff       	mov    $0xffffffeb,%eax
  80042199b1:	eb 17                	jmp    80042199ca <ept_lookup_gpa+0x85>

	if (epte_out)
  80042199b3:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042199b8:	74 0b                	je     80042199c5 <ept_lookup_gpa+0x80>
		*epte_out = epte;
  80042199ba:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042199be:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042199c2:	48 89 10             	mov    %rdx,(%rax)
	
   	return 0;
  80042199c5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042199ca:	c9                   	leaveq 
  80042199cb:	c3                   	retq   

00000080042199cc <ept_gpa2hva>:

void ept_gpa2hva(epte_t* eptrt, void *gpa, void **hva) {
  80042199cc:	55                   	push   %rbp
  80042199cd:	48 89 e5             	mov    %rsp,%rbp
  80042199d0:	48 83 ec 40          	sub    $0x40,%rsp
  80042199d4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042199d8:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042199dc:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    epte_t* pte;
    int ret = ept_lookup_gpa(eptrt, gpa, 0, &pte);
  80042199e0:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  80042199e4:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042199e8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042199ec:	48 89 d1             	mov    %rdx,%rcx
  80042199ef:	ba 00 00 00 00       	mov    $0x0,%edx
  80042199f4:	48 89 c7             	mov    %rax,%rdi
  80042199f7:	48 b8 45 99 21 04 80 	movabs $0x8004219945,%rax
  80042199fe:	00 00 00 
  8004219a01:	ff d0                	callq  *%rax
  8004219a03:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if(ret < 0) {
  8004219a06:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004219a0a:	79 10                	jns    8004219a1c <ept_gpa2hva+0x50>
        *hva = NULL;
  8004219a0c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004219a10:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
           *hva = NULL;
        } else {
           *hva = KADDR(epte_addr(*pte));
        }
    }
}
  8004219a17:	e9 b1 00 00 00       	jmpq   8004219acd <ept_gpa2hva+0x101>
    epte_t* pte;
    int ret = ept_lookup_gpa(eptrt, gpa, 0, &pte);
    if(ret < 0) {
        *hva = NULL;
    } else {
        if(!epte_present(*pte)) {
  8004219a1c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219a20:	48 8b 00             	mov    (%rax),%rax
  8004219a23:	48 89 c7             	mov    %rax,%rdi
  8004219a26:	48 b8 27 99 21 04 80 	movabs $0x8004219927,%rax
  8004219a2d:	00 00 00 
  8004219a30:	ff d0                	callq  *%rax
  8004219a32:	85 c0                	test   %eax,%eax
  8004219a34:	75 10                	jne    8004219a46 <ept_gpa2hva+0x7a>
           *hva = NULL;
  8004219a36:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004219a3a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        } else {
           *hva = KADDR(epte_addr(*pte));
        }
    }
}
  8004219a41:	e9 87 00 00 00       	jmpq   8004219acd <ept_gpa2hva+0x101>
        *hva = NULL;
    } else {
        if(!epte_present(*pte)) {
           *hva = NULL;
        } else {
           *hva = KADDR(epte_addr(*pte));
  8004219a46:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219a4a:	48 8b 00             	mov    (%rax),%rax
  8004219a4d:	48 89 c7             	mov    %rax,%rdi
  8004219a50:	48 b8 0f 99 21 04 80 	movabs $0x800421990f,%rax
  8004219a57:	00 00 00 
  8004219a5a:	ff d0                	callq  *%rax
  8004219a5c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004219a60:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004219a64:	48 c1 e8 0c          	shr    $0xc,%rax
  8004219a68:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004219a6b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004219a6e:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004219a75:	00 00 00 
  8004219a78:	48 8b 00             	mov    (%rax),%rax
  8004219a7b:	48 39 c2             	cmp    %rax,%rdx
  8004219a7e:	72 32                	jb     8004219ab2 <ept_gpa2hva+0xe6>
  8004219a80:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004219a84:	48 89 c1             	mov    %rax,%rcx
  8004219a87:	48 ba f0 1e 22 04 80 	movabs $0x8004221ef0,%rdx
  8004219a8e:	00 00 00 
  8004219a91:	be 4f 00 00 00       	mov    $0x4f,%esi
  8004219a96:	48 bf 13 1f 22 04 80 	movabs $0x8004221f13,%rdi
  8004219a9d:	00 00 00 
  8004219aa0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219aa5:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004219aac:	00 00 00 
  8004219aaf:	41 ff d0             	callq  *%r8
  8004219ab2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004219ab9:	00 00 00 
  8004219abc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004219ac0:	48 01 d0             	add    %rdx,%rax
  8004219ac3:	48 89 c2             	mov    %rax,%rdx
  8004219ac6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004219aca:	48 89 10             	mov    %rdx,(%rax)
        }
    }
}
  8004219acd:	90                   	nop
  8004219ace:	c9                   	leaveq 
  8004219acf:	c3                   	retq   

0000008004219ad0 <free_ept_level>:

static void free_ept_level(epte_t* eptrt, int level) {
  8004219ad0:	55                   	push   %rbp
  8004219ad1:	48 89 e5             	mov    %rsp,%rbp
  8004219ad4:	48 83 ec 40          	sub    $0x40,%rsp
  8004219ad8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004219adc:	89 75 c4             	mov    %esi,-0x3c(%rbp)
    epte_t* dir = eptrt;
  8004219adf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004219ae3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    int i;

    for(i=0; i<NPTENTRIES; ++i) {
  8004219ae7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004219aee:	e9 82 01 00 00       	jmpq   8004219c75 <free_ept_level+0x1a5>
        if(level != 0) {
  8004219af3:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004219af7:	0f 84 fe 00 00 00    	je     8004219bfb <free_ept_level+0x12b>
            if(epte_present(dir[i])) {
  8004219afd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219b00:	48 98                	cltq   
  8004219b02:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004219b09:	00 
  8004219b0a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004219b0e:	48 01 d0             	add    %rdx,%rax
  8004219b11:	48 8b 00             	mov    (%rax),%rax
  8004219b14:	48 89 c7             	mov    %rax,%rdi
  8004219b17:	48 b8 27 99 21 04 80 	movabs $0x8004219927,%rax
  8004219b1e:	00 00 00 
  8004219b21:	ff d0                	callq  *%rax
  8004219b23:	85 c0                	test   %eax,%eax
  8004219b25:	0f 84 46 01 00 00    	je     8004219c71 <free_ept_level+0x1a1>
                physaddr_t pa = epte_addr(dir[i]);
  8004219b2b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219b2e:	48 98                	cltq   
  8004219b30:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004219b37:	00 
  8004219b38:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004219b3c:	48 01 d0             	add    %rdx,%rax
  8004219b3f:	48 8b 00             	mov    (%rax),%rax
  8004219b42:	48 89 c7             	mov    %rax,%rdi
  8004219b45:	48 b8 0f 99 21 04 80 	movabs $0x800421990f,%rax
  8004219b4c:	00 00 00 
  8004219b4f:	ff d0                	callq  *%rax
  8004219b51:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                free_ept_level((epte_t*) KADDR(pa), level-1);
  8004219b55:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004219b58:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004219b5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219b5f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004219b63:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219b67:	48 c1 e8 0c          	shr    $0xc,%rax
  8004219b6b:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004219b6e:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  8004219b71:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  8004219b78:	00 00 00 
  8004219b7b:	48 8b 00             	mov    (%rax),%rax
  8004219b7e:	48 39 c1             	cmp    %rax,%rcx
  8004219b81:	72 32                	jb     8004219bb5 <free_ept_level+0xe5>
  8004219b83:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219b87:	48 89 c1             	mov    %rax,%rcx
  8004219b8a:	48 ba f0 1e 22 04 80 	movabs $0x8004221ef0,%rdx
  8004219b91:	00 00 00 
  8004219b94:	be 5c 00 00 00       	mov    $0x5c,%esi
  8004219b99:	48 bf 13 1f 22 04 80 	movabs $0x8004221f13,%rdi
  8004219ba0:	00 00 00 
  8004219ba3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219ba8:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004219baf:	00 00 00 
  8004219bb2:	41 ff d0             	callq  *%r8
  8004219bb5:	48 b9 00 00 00 04 80 	movabs $0x8004000000,%rcx
  8004219bbc:	00 00 00 
  8004219bbf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219bc3:	48 01 c8             	add    %rcx,%rax
  8004219bc6:	89 d6                	mov    %edx,%esi
  8004219bc8:	48 89 c7             	mov    %rax,%rdi
  8004219bcb:	48 b8 d0 9a 21 04 80 	movabs $0x8004219ad0,%rax
  8004219bd2:	00 00 00 
  8004219bd5:	ff d0                	callq  *%rax
                // free the table.
                page_decref(pa2page(pa));
  8004219bd7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219bdb:	48 89 c7             	mov    %rax,%rdi
  8004219bde:	48 b8 16 98 21 04 80 	movabs $0x8004219816,%rax
  8004219be5:	00 00 00 
  8004219be8:	ff d0                	callq  *%rax
  8004219bea:	48 89 c7             	mov    %rax,%rdi
  8004219bed:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  8004219bf4:	00 00 00 
  8004219bf7:	ff d0                	callq  *%rax
  8004219bf9:	eb 76                	jmp    8004219c71 <free_ept_level+0x1a1>
            }
        } else {
            // Last level, free the guest physical page.
            if(epte_present(dir[i])) {
  8004219bfb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219bfe:	48 98                	cltq   
  8004219c00:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004219c07:	00 
  8004219c08:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004219c0c:	48 01 d0             	add    %rdx,%rax
  8004219c0f:	48 8b 00             	mov    (%rax),%rax
  8004219c12:	48 89 c7             	mov    %rax,%rdi
  8004219c15:	48 b8 27 99 21 04 80 	movabs $0x8004219927,%rax
  8004219c1c:	00 00 00 
  8004219c1f:	ff d0                	callq  *%rax
  8004219c21:	85 c0                	test   %eax,%eax
  8004219c23:	74 4c                	je     8004219c71 <free_ept_level+0x1a1>
                physaddr_t pa = epte_addr(dir[i]);                
  8004219c25:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219c28:	48 98                	cltq   
  8004219c2a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004219c31:	00 
  8004219c32:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004219c36:	48 01 d0             	add    %rdx,%rax
  8004219c39:	48 8b 00             	mov    (%rax),%rax
  8004219c3c:	48 89 c7             	mov    %rax,%rdi
  8004219c3f:	48 b8 0f 99 21 04 80 	movabs $0x800421990f,%rax
  8004219c46:	00 00 00 
  8004219c49:	ff d0                	callq  *%rax
  8004219c4b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                page_decref(pa2page(pa));
  8004219c4f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004219c53:	48 89 c7             	mov    %rax,%rdi
  8004219c56:	48 b8 16 98 21 04 80 	movabs $0x8004219816,%rax
  8004219c5d:	00 00 00 
  8004219c60:	ff d0                	callq  *%rax
  8004219c62:	48 89 c7             	mov    %rax,%rdi
  8004219c65:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  8004219c6c:	00 00 00 
  8004219c6f:	ff d0                	callq  *%rax

static void free_ept_level(epte_t* eptrt, int level) {
    epte_t* dir = eptrt;
    int i;

    for(i=0; i<NPTENTRIES; ++i) {
  8004219c71:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004219c75:	81 7d fc ff 01 00 00 	cmpl   $0x1ff,-0x4(%rbp)
  8004219c7c:	0f 8e 71 fe ff ff    	jle    8004219af3 <free_ept_level+0x23>
                physaddr_t pa = epte_addr(dir[i]);                
                page_decref(pa2page(pa));
            }
        }
    }
    return;
  8004219c82:	90                   	nop
}
  8004219c83:	c9                   	leaveq 
  8004219c84:	c3                   	retq   

0000008004219c85 <free_guest_mem>:

// Free the EPT table entries and the EPT tables.
// NOTE: Does not deallocate EPT PML4 page.
void free_guest_mem(epte_t* eptrt) {
  8004219c85:	55                   	push   %rbp
  8004219c86:	48 89 e5             	mov    %rsp,%rbp
  8004219c89:	48 83 ec 20          	sub    $0x20,%rsp
  8004219c8d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    free_ept_level(eptrt, EPT_LEVELS - 1);
  8004219c91:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219c95:	be 03 00 00 00       	mov    $0x3,%esi
  8004219c9a:	48 89 c7             	mov    %rax,%rdi
  8004219c9d:	48 b8 d0 9a 21 04 80 	movabs $0x8004219ad0,%rax
  8004219ca4:	00 00 00 
  8004219ca7:	ff d0                	callq  *%rax

static __inline void
tlbflush(void)
{
	uint64_t cr3;
	__asm __volatile("movq %%cr3,%0" : "=r" (cr3));
  8004219ca9:	0f 20 d8             	mov    %cr3,%rax
  8004219cac:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	__asm __volatile("movq %0,%%cr3" : : "r" (cr3));
  8004219cb0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004219cb4:	0f 22 d8             	mov    %rax,%cr3
    tlbflush();
}
  8004219cb7:	90                   	nop
  8004219cb8:	c9                   	leaveq 
  8004219cb9:	c3                   	retq   

0000008004219cba <ept_page_insert>:
//   successful insert.  If you overwrite a mapping, your code should
//   decrement the reference count of the old mapping.
// 
// Return 0 on success, <0 on failure.
//
int ept_page_insert(epte_t* eptrt, struct PageInfo* pp, void* gpa, int perm) {
  8004219cba:	55                   	push   %rbp
  8004219cbb:	48 89 e5             	mov    %rsp,%rbp
  8004219cbe:	53                   	push   %rbx
  8004219cbf:	48 83 ec 38          	sub    $0x38,%rsp
  8004219cc3:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004219cc7:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004219ccb:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004219ccf:	89 4d c4             	mov    %ecx,-0x3c(%rbp)

	/* Your code here */
	epte_t *pte;
	int r;

	if((r = ept_lookup_gpa(eptrt, gpa, 1, &pte)) < 0) {
  8004219cd2:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  8004219cd6:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8004219cda:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219cde:	48 89 d1             	mov    %rdx,%rcx
  8004219ce1:	ba 01 00 00 00       	mov    $0x1,%edx
  8004219ce6:	48 89 c7             	mov    %rax,%rdi
  8004219ce9:	48 b8 45 99 21 04 80 	movabs $0x8004219945,%rax
  8004219cf0:	00 00 00 
  8004219cf3:	ff d0                	callq  *%rax
  8004219cf5:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004219cf8:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8004219cfc:	79 1b                	jns    8004219d19 <ept_page_insert+0x5f>
		cprintf("ept page insert: failed\n");
  8004219cfe:	48 bf 1d 1f 22 04 80 	movabs $0x8004221f1d,%rdi
  8004219d05:	00 00 00 
  8004219d08:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219d0d:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  8004219d14:	00 00 00 
  8004219d17:	ff d2                	callq  *%rdx
	}

	if (epte_present(*pte))
  8004219d19:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219d1d:	48 8b 00             	mov    (%rax),%rax
  8004219d20:	48 89 c7             	mov    %rax,%rdi
  8004219d23:	48 b8 27 99 21 04 80 	movabs $0x8004219927,%rax
  8004219d2a:	00 00 00 
  8004219d2d:	ff d0                	callq  *%rax
  8004219d2f:	85 c0                	test   %eax,%eax
  8004219d31:	74 25                	je     8004219d58 <ept_page_insert+0x9e>
		page_decref(pa2page(*pte));
  8004219d33:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219d37:	48 8b 00             	mov    (%rax),%rax
  8004219d3a:	48 89 c7             	mov    %rax,%rdi
  8004219d3d:	48 b8 16 98 21 04 80 	movabs $0x8004219816,%rax
  8004219d44:	00 00 00 
  8004219d47:	ff d0                	callq  *%rax
  8004219d49:	48 89 c7             	mov    %rax,%rdi
  8004219d4c:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  8004219d53:	00 00 00 
  8004219d56:	ff d0                	callq  *%rax
	
	*pte = page2pa(pp) | perm;
  8004219d58:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  8004219d5c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004219d60:	48 89 c7             	mov    %rax,%rdi
  8004219d63:	48 b8 f1 97 21 04 80 	movabs $0x80042197f1,%rax
  8004219d6a:	00 00 00 
  8004219d6d:	ff d0                	callq  *%rax
  8004219d6f:	48 89 c2             	mov    %rax,%rdx
  8004219d72:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004219d75:	48 98                	cltq   
  8004219d77:	48 09 d0             	or     %rdx,%rax
  8004219d7a:	48 89 03             	mov    %rax,(%rbx)
	pp->pp_ref += 1;	
  8004219d7d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004219d81:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004219d85:	8d 50 01             	lea    0x1(%rax),%edx
  8004219d88:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004219d8c:	66 89 50 08          	mov    %dx,0x8(%rax)

    	return 0;
  8004219d90:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004219d95:	48 83 c4 38          	add    $0x38,%rsp
  8004219d99:	5b                   	pop    %rbx
  8004219d9a:	5d                   	pop    %rbp
  8004219d9b:	c3                   	retq   

0000008004219d9c <ept_map_hva2gpa>:
// 
// Hint: use ept_lookup_gpa to create the intermediate 
//       ept levels, and return the final epte_t pointer.
//       You should set the type to EPTE_TYPE_WB and set __EPTE_IPAT flag.
int ept_map_hva2gpa(epte_t* eptrt, void* hva, void* gpa, int perm, 
        int overwrite) {
  8004219d9c:	55                   	push   %rbp
  8004219d9d:	48 89 e5             	mov    %rsp,%rbp
  8004219da0:	48 83 ec 40          	sub    $0x40,%rsp
  8004219da4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004219da8:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004219dac:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004219db0:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
  8004219db3:	44 89 45 c0          	mov    %r8d,-0x40(%rbp)
	epte_t *epte;
	pte_t *pte;
	int ret = ept_lookup_gpa(eptrt, gpa, 1, &epte);
  8004219db7:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  8004219dbb:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8004219dbf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219dc3:	48 89 d1             	mov    %rdx,%rcx
  8004219dc6:	ba 01 00 00 00       	mov    $0x1,%edx
  8004219dcb:	48 89 c7             	mov    %rax,%rdi
  8004219dce:	48 b8 45 99 21 04 80 	movabs $0x8004219945,%rax
  8004219dd5:	00 00 00 
  8004219dd8:	ff d0                	callq  *%rax
  8004219dda:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if (ret == 0) {
  8004219ddd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004219de1:	0f 85 9d 00 00 00    	jne    8004219e84 <ept_map_hva2gpa+0xe8>
		if (epte_present(*epte) && overwrite == 0)
  8004219de7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219deb:	48 8b 00             	mov    (%rax),%rax
  8004219dee:	48 89 c7             	mov    %rax,%rdi
  8004219df1:	48 b8 27 99 21 04 80 	movabs $0x8004219927,%rax
  8004219df8:	00 00 00 
  8004219dfb:	ff d0                	callq  *%rax
  8004219dfd:	85 c0                	test   %eax,%eax
  8004219dff:	74 0d                	je     8004219e0e <ept_map_hva2gpa+0x72>
  8004219e01:	83 7d c0 00          	cmpl   $0x0,-0x40(%rbp)
  8004219e05:	75 07                	jne    8004219e0e <ept_map_hva2gpa+0x72>
			return -E_INVAL;
  8004219e07:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8004219e0c:	eb 7b                	jmp    8004219e89 <ept_map_hva2gpa+0xed>
		*epte = PADDR(hva)|perm|__EPTE_IPAT|__EPTE_TYPE(EPTE_TYPE_WB);
  8004219e0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219e12:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004219e16:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004219e1a:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004219e21:	00 00 00 
  8004219e24:	48 39 55 f0          	cmp    %rdx,-0x10(%rbp)
  8004219e28:	77 32                	ja     8004219e5c <ept_map_hva2gpa+0xc0>
  8004219e2a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004219e2e:	48 89 c1             	mov    %rax,%rcx
  8004219e31:	48 ba 38 1f 22 04 80 	movabs $0x8004221f38,%rdx
  8004219e38:	00 00 00 
  8004219e3b:	be a3 00 00 00       	mov    $0xa3,%esi
  8004219e40:	48 bf 13 1f 22 04 80 	movabs $0x8004221f13,%rdi
  8004219e47:	00 00 00 
  8004219e4a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219e4f:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  8004219e56:	00 00 00 
  8004219e59:	41 ff d0             	callq  *%r8
  8004219e5c:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004219e63:	ff ff ff 
  8004219e66:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004219e6a:	48 01 d1             	add    %rdx,%rcx
  8004219e6d:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004219e70:	48 63 d2             	movslq %edx,%rdx
  8004219e73:	48 09 ca             	or     %rcx,%rdx
  8004219e76:	48 83 ca 70          	or     $0x70,%rdx
  8004219e7a:	48 89 10             	mov    %rdx,(%rax)
	} else 
		return -E_NO_MEM;

    	return 0;
  8004219e7d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219e82:	eb 05                	jmp    8004219e89 <ept_map_hva2gpa+0xed>
	if (ret == 0) {
		if (epte_present(*epte) && overwrite == 0)
			return -E_INVAL;
		*epte = PADDR(hva)|perm|__EPTE_IPAT|__EPTE_TYPE(EPTE_TYPE_WB);
	} else 
		return -E_NO_MEM;
  8004219e84:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax

    	return 0;
}
  8004219e89:	c9                   	leaveq 
  8004219e8a:	c3                   	retq   

0000008004219e8b <ept_alloc_static>:

int ept_alloc_static(epte_t *eptrt, struct VmxGuestInfo *ginfo) {
  8004219e8b:	55                   	push   %rbp
  8004219e8c:	48 89 e5             	mov    %rsp,%rbp
  8004219e8f:	53                   	push   %rbx
  8004219e90:	48 83 ec 48          	sub    $0x48,%rsp
  8004219e94:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004219e98:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
    physaddr_t i;
    
    for(i=0x0; i < 0xA0000; i+=PGSIZE) {
  8004219e9c:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004219ea3:	00 
  8004219ea4:	eb 6e                	jmp    8004219f14 <ept_alloc_static+0x89>
        struct PageInfo *p = page_alloc(0);
  8004219ea6:	bf 00 00 00 00       	mov    $0x0,%edi
  8004219eab:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004219eb2:	00 00 00 
  8004219eb5:	ff d0                	callq  *%rax
  8004219eb7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        p->pp_ref += 1;
  8004219ebb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219ebf:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004219ec3:	8d 50 01             	lea    0x1(%rax),%edx
  8004219ec6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219eca:	66 89 50 08          	mov    %dx,0x8(%rax)
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
  8004219ece:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
  8004219ed2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219ed6:	48 89 c7             	mov    %rax,%rdi
  8004219ed9:	48 b8 87 98 21 04 80 	movabs $0x8004219887,%rax
  8004219ee0:	00 00 00 
  8004219ee3:	ff d0                	callq  *%rax
  8004219ee5:	48 89 c6             	mov    %rax,%rsi
  8004219ee8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004219eec:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8004219ef2:	b9 07 00 00 00       	mov    $0x7,%ecx
  8004219ef7:	48 89 da             	mov    %rbx,%rdx
  8004219efa:	48 89 c7             	mov    %rax,%rdi
  8004219efd:	48 b8 9c 9d 21 04 80 	movabs $0x8004219d9c,%rax
  8004219f04:	00 00 00 
  8004219f07:	ff d0                	callq  *%rax
  8004219f09:	89 45 dc             	mov    %eax,-0x24(%rbp)
}

int ept_alloc_static(epte_t *eptrt, struct VmxGuestInfo *ginfo) {
    physaddr_t i;
    
    for(i=0x0; i < 0xA0000; i+=PGSIZE) {
  8004219f0c:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  8004219f13:	00 
  8004219f14:	48 81 7d e8 ff ff 09 	cmpq   $0x9ffff,-0x18(%rbp)
  8004219f1b:	00 
  8004219f1c:	76 88                	jbe    8004219ea6 <ept_alloc_static+0x1b>
        struct PageInfo *p = page_alloc(0);
        p->pp_ref += 1;
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
    }

    for(i=0x100000; i < ginfo->phys_sz; i+=PGSIZE) {
  8004219f1e:	48 c7 45 e8 00 00 10 	movq   $0x100000,-0x18(%rbp)
  8004219f25:	00 
  8004219f26:	eb 6e                	jmp    8004219f96 <ept_alloc_static+0x10b>
        struct PageInfo *p = page_alloc(0);
  8004219f28:	bf 00 00 00 00       	mov    $0x0,%edi
  8004219f2d:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  8004219f34:	00 00 00 
  8004219f37:	ff d0                	callq  *%rax
  8004219f39:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        p->pp_ref += 1;
  8004219f3d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004219f41:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004219f45:	8d 50 01             	lea    0x1(%rax),%edx
  8004219f48:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004219f4c:	66 89 50 08          	mov    %dx,0x8(%rax)
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
  8004219f50:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
  8004219f54:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004219f58:	48 89 c7             	mov    %rax,%rdi
  8004219f5b:	48 b8 87 98 21 04 80 	movabs $0x8004219887,%rax
  8004219f62:	00 00 00 
  8004219f65:	ff d0                	callq  *%rax
  8004219f67:	48 89 c6             	mov    %rax,%rsi
  8004219f6a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004219f6e:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8004219f74:	b9 07 00 00 00       	mov    $0x7,%ecx
  8004219f79:	48 89 da             	mov    %rbx,%rdx
  8004219f7c:	48 89 c7             	mov    %rax,%rdi
  8004219f7f:	48 b8 9c 9d 21 04 80 	movabs $0x8004219d9c,%rax
  8004219f86:	00 00 00 
  8004219f89:	ff d0                	callq  *%rax
  8004219f8b:	89 45 cc             	mov    %eax,-0x34(%rbp)
        struct PageInfo *p = page_alloc(0);
        p->pp_ref += 1;
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
    }

    for(i=0x100000; i < ginfo->phys_sz; i+=PGSIZE) {
  8004219f8e:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  8004219f95:	00 
  8004219f96:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004219f9a:	48 8b 00             	mov    (%rax),%rax
  8004219f9d:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004219fa1:	77 85                	ja     8004219f28 <ept_alloc_static+0x9d>
        struct PageInfo *p = page_alloc(0);
        p->pp_ref += 1;
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
    }
    return 0;
  8004219fa3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004219fa8:	48 83 c4 48          	add    $0x48,%rsp
  8004219fac:	5b                   	pop    %rbx
  8004219fad:	5d                   	pop    %rbp
  8004219fae:	c3                   	retq   

0000008004219faf <vmcs_writel>:
#define IA32_VMX_EPT_VPID_CAP 0x48C
#define IA32_FEATURE_CONTROL 0x03A

#define BIT( val, x ) ( ( val >> x ) & 0x1 )

static __inline uint8_t vmcs_writel( uint32_t field, uint64_t value) {
  8004219faf:	55                   	push   %rbp
  8004219fb0:	48 89 e5             	mov    %rsp,%rbp
  8004219fb3:	48 83 ec 20          	sub    $0x20,%rsp
  8004219fb7:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004219fba:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint8_t error;

	__asm __volatile ( "clc; vmwrite %%rax, %%rdx; setna %0"
  8004219fbe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219fc2:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004219fc5:	f8                   	clc    
  8004219fc6:	0f 79 d0             	vmwrite %rax,%rdx
  8004219fc9:	0f 96 c0             	setbe  %al
  8004219fcc:	88 45 ff             	mov    %al,-0x1(%rbp)
		       : "=q"( error ) : "a"( value ), "d"( field ) : "cc");
    return error;
  8004219fcf:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  8004219fd3:	c9                   	leaveq 
  8004219fd4:	c3                   	retq   

0000008004219fd5 <vmcs_readl>:
static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
}

static __inline uint64_t vmcs_readl(uint32_t field)
{
  8004219fd5:	55                   	push   %rbp
  8004219fd6:	48 89 e5             	mov    %rsp,%rbp
  8004219fd9:	48 83 ec 18          	sub    $0x18,%rsp
  8004219fdd:	89 7d ec             	mov    %edi,-0x14(%rbp)
	uint64_t value;

	__asm __volatile ( "vmread %%rdx, %%rax;"
  8004219fe0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004219fe3:	89 c2                	mov    %eax,%edx
  8004219fe5:	0f 78 d0             	vmread %rdx,%rax
  8004219fe8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		      : "=a"(value) : "d"(field) : "cc");
	return value;
  8004219fec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004219ff0:	c9                   	leaveq 
  8004219ff1:	c3                   	retq   

0000008004219ff2 <cpuid>:

#define read_rip(var) __asm __volatile("leaq (%%rip), %0" : "=r" (var)::"cc","memory")

static __inline void
cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)
{
  8004219ff2:	55                   	push   %rbp
  8004219ff3:	48 89 e5             	mov    %rsp,%rbp
  8004219ff6:	53                   	push   %rbx
  8004219ff7:	48 83 ec 38          	sub    $0x38,%rsp
  8004219ffb:	89 7d e4             	mov    %edi,-0x1c(%rbp)
  8004219ffe:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  800421a002:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800421a006:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  800421a00a:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
	uint32_t eax, ebx, ecx, edx;
	asm volatile("cpuid" 
  800421a00e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421a011:	0f a2                	cpuid  
  800421a013:	89 de                	mov    %ebx,%esi
  800421a015:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800421a018:	89 75 f0             	mov    %esi,-0x10(%rbp)
  800421a01b:	89 4d ec             	mov    %ecx,-0x14(%rbp)
  800421a01e:	89 55 e8             	mov    %edx,-0x18(%rbp)
			 : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
			 : "a" (info));
	if (eaxp)
  800421a021:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421a026:	74 09                	je     800421a031 <cpuid+0x3f>
		*eaxp = eax;
  800421a028:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421a02c:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421a02f:	89 10                	mov    %edx,(%rax)
	if (ebxp)
  800421a031:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800421a036:	74 09                	je     800421a041 <cpuid+0x4f>
		*ebxp = ebx;
  800421a038:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421a03c:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800421a03f:	89 10                	mov    %edx,(%rax)
	if (ecxp)
  800421a041:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800421a046:	74 09                	je     800421a051 <cpuid+0x5f>
		*ecxp = ecx;
  800421a048:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421a04c:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421a04f:	89 10                	mov    %edx,(%rax)
	if (edxp)
  800421a051:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800421a056:	74 09                	je     800421a061 <cpuid+0x6f>
		*edxp = edx;
  800421a058:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421a05c:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800421a05f:	89 10                	mov    %edx,(%rax)
}
  800421a061:	90                   	nop
  800421a062:	48 83 c4 38          	add    $0x38,%rsp
  800421a066:	5b                   	pop    %rbx
  800421a067:	5d                   	pop    %rbp
  800421a068:	c3                   	retq   

000000800421a069 <page2ppn>:
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);


static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  800421a069:	55                   	push   %rbp
  800421a06a:	48 89 e5             	mov    %rsp,%rbp
  800421a06d:	48 83 ec 08          	sub    $0x8,%rsp
  800421a071:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  800421a075:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421a079:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  800421a080:	00 00 00 
  800421a083:	48 8b 00             	mov    (%rax),%rax
  800421a086:	48 29 c2             	sub    %rax,%rdx
  800421a089:	48 89 d0             	mov    %rdx,%rax
  800421a08c:	48 c1 f8 04          	sar    $0x4,%rax
}
  800421a090:	c9                   	leaveq 
  800421a091:	c3                   	retq   

000000800421a092 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  800421a092:	55                   	push   %rbp
  800421a093:	48 89 e5             	mov    %rsp,%rbp
  800421a096:	48 83 ec 08          	sub    $0x8,%rsp
  800421a09a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  800421a09e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421a0a2:	48 89 c7             	mov    %rax,%rdi
  800421a0a5:	48 b8 69 a0 21 04 80 	movabs $0x800421a069,%rax
  800421a0ac:	00 00 00 
  800421a0af:	ff d0                	callq  *%rax
  800421a0b1:	48 c1 e0 0c          	shl    $0xc,%rax
}
  800421a0b5:	c9                   	leaveq 
  800421a0b6:	c3                   	retq   

000000800421a0b7 <page2kva>:
	return &pages[PPN(pa)];
}

static inline void*
page2kva(struct PageInfo *pp)
{
  800421a0b7:	55                   	push   %rbp
  800421a0b8:	48 89 e5             	mov    %rsp,%rbp
  800421a0bb:	48 83 ec 20          	sub    $0x20,%rsp
  800421a0bf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  800421a0c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a0c7:	48 89 c7             	mov    %rax,%rdi
  800421a0ca:	48 b8 92 a0 21 04 80 	movabs $0x800421a092,%rax
  800421a0d1:	00 00 00 
  800421a0d4:	ff d0                	callq  *%rax
  800421a0d6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421a0da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421a0de:	48 c1 e8 0c          	shr    $0xc,%rax
  800421a0e2:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800421a0e5:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421a0e8:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  800421a0ef:	00 00 00 
  800421a0f2:	48 8b 00             	mov    (%rax),%rax
  800421a0f5:	48 39 c2             	cmp    %rax,%rdx
  800421a0f8:	72 32                	jb     800421a12c <page2kva+0x75>
  800421a0fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421a0fe:	48 89 c1             	mov    %rax,%rcx
  800421a101:	48 ba 60 1f 22 04 80 	movabs $0x8004221f60,%rdx
  800421a108:	00 00 00 
  800421a10b:	be 61 00 00 00       	mov    $0x61,%esi
  800421a110:	48 bf 83 1f 22 04 80 	movabs $0x8004221f83,%rdi
  800421a117:	00 00 00 
  800421a11a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a11f:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421a126:	00 00 00 
  800421a129:	41 ff d0             	callq  *%r8
  800421a12c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421a133:	00 00 00 
  800421a136:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421a13a:	48 01 d0             	add    %rdx,%rax
}
  800421a13d:	c9                   	leaveq 
  800421a13e:	c3                   	retq   

000000800421a13f <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  800421a13f:	55                   	push   %rbp
  800421a140:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  800421a143:	48 bf 60 37 23 04 80 	movabs $0x8004233760,%rdi
  800421a14a:	00 00 00 
  800421a14d:	48 b8 5e 82 21 04 80 	movabs $0x800421825e,%rax
  800421a154:	00 00 00 
  800421a157:	ff d0                	callq  *%rax
}
  800421a159:	90                   	nop
  800421a15a:	5d                   	pop    %rbp
  800421a15b:	c3                   	retq   

000000800421a15c <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800421a15c:	55                   	push   %rbp
  800421a15d:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800421a160:	48 bf 60 37 23 04 80 	movabs $0x8004233760,%rdi
  800421a167:	00 00 00 
  800421a16a:	48 b8 34 83 21 04 80 	movabs $0x8004218334,%rax
  800421a171:	00 00 00 
  800421a174:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800421a176:	f3 90                	pause  
}
  800421a178:	90                   	nop
  800421a179:	5d                   	pop    %rbp
  800421a17a:	c3                   	retq   

000000800421a17b <vmx_list_vms>:
#include <kern/console.h>
#include <kern/spinlock.h>
#include <kern/macro.h>


void vmx_list_vms() {
  800421a17b:	55                   	push   %rbp
  800421a17c:	48 89 e5             	mov    %rsp,%rbp
  800421a17f:	48 83 ec 10          	sub    $0x10,%rsp
	//findout how many VMs there
	int i;
	int vm_count = 0;
  800421a183:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < NENV; ++i) {
  800421a18a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421a191:	e9 96 00 00 00       	jmpq   800421a22c <vmx_list_vms+0xb1>
		if (envs[i].env_type == ENV_TYPE_GUEST) {
  800421a196:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  800421a19d:	00 00 00 
  800421a1a0:	48 8b 10             	mov    (%rax),%rdx
  800421a1a3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421a1a6:	48 98                	cltq   
  800421a1a8:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800421a1af:	48 01 d0             	add    %rdx,%rax
  800421a1b2:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800421a1b8:	83 f8 03             	cmp    $0x3,%eax
  800421a1bb:	75 6b                	jne    800421a228 <vmx_list_vms+0xad>
			if (vm_count == 0) {
  800421a1bd:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800421a1c1:	75 1b                	jne    800421a1de <vmx_list_vms+0x63>
				cprintf("Running VMs:\n");
  800421a1c3:	48 bf 91 1f 22 04 80 	movabs $0x8004221f91,%rdi
  800421a1ca:	00 00 00 
  800421a1cd:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a1d2:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421a1d9:	00 00 00 
  800421a1dc:	ff d2                	callq  *%rdx
			}
			vm_count++;
  800421a1de:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
			cprintf("%d.[%x]vm%d\n", vm_count, envs[i].env_id, vm_count);
  800421a1e2:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  800421a1e9:	00 00 00 
  800421a1ec:	48 8b 10             	mov    (%rax),%rdx
  800421a1ef:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421a1f2:	48 98                	cltq   
  800421a1f4:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800421a1fb:	48 01 d0             	add    %rdx,%rax
  800421a1fe:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800421a204:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  800421a207:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421a20a:	89 c6                	mov    %eax,%esi
  800421a20c:	48 bf 9f 1f 22 04 80 	movabs $0x8004221f9f,%rdi
  800421a213:	00 00 00 
  800421a216:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a21b:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421a222:	00 00 00 
  800421a225:	41 ff d0             	callq  *%r8

void vmx_list_vms() {
	//findout how many VMs there
	int i;
	int vm_count = 0;
	for (i = 0; i < NENV; ++i) {
  800421a228:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421a22c:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800421a233:	0f 8e 5d ff ff ff    	jle    800421a196 <vmx_list_vms+0x1b>
			}
			vm_count++;
			cprintf("%d.[%x]vm%d\n", vm_count, envs[i].env_id, vm_count);
		}
	}
}
  800421a239:	90                   	nop
  800421a23a:	c9                   	leaveq 
  800421a23b:	c3                   	retq   

000000800421a23c <vmx_sel_resume>:

bool vmx_sel_resume(int num) {
  800421a23c:	55                   	push   %rbp
  800421a23d:	48 89 e5             	mov    %rsp,%rbp
  800421a240:	48 83 ec 20          	sub    $0x20,%rsp
  800421a244:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int i;
	int vm_count = 0;
  800421a247:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < NENV; ++i) {
  800421a24e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421a255:	e9 84 00 00 00       	jmpq   800421a2de <vmx_sel_resume+0xa2>
		if (envs[i].env_type == ENV_TYPE_GUEST) {
  800421a25a:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  800421a261:	00 00 00 
  800421a264:	48 8b 10             	mov    (%rax),%rdx
  800421a267:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421a26a:	48 98                	cltq   
  800421a26c:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800421a273:	48 01 d0             	add    %rdx,%rax
  800421a276:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800421a27c:	83 f8 03             	cmp    $0x3,%eax
  800421a27f:	75 59                	jne    800421a2da <vmx_sel_resume+0x9e>
			vm_count++;
  800421a281:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
			if (vm_count == num) {
  800421a285:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421a288:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800421a28b:	75 4d                	jne    800421a2da <vmx_sel_resume+0x9e>
				cprintf("Resume vm.%d\n", num);	
  800421a28d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421a290:	89 c6                	mov    %eax,%esi
  800421a292:	48 bf ac 1f 22 04 80 	movabs $0x8004221fac,%rdi
  800421a299:	00 00 00 
  800421a29c:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a2a1:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421a2a8:	00 00 00 
  800421a2ab:	ff d2                	callq  *%rdx
				envs[i].env_status = ENV_RUNNABLE;
  800421a2ad:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  800421a2b4:	00 00 00 
  800421a2b7:	48 8b 10             	mov    (%rax),%rdx
  800421a2ba:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421a2bd:	48 98                	cltq   
  800421a2bf:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800421a2c6:	48 01 d0             	add    %rdx,%rax
  800421a2c9:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800421a2d0:	00 00 00 
				return true;
  800421a2d3:	b8 01 00 00 00       	mov    $0x1,%eax
  800421a2d8:	eb 36                	jmp    800421a310 <vmx_sel_resume+0xd4>
}

bool vmx_sel_resume(int num) {
	int i;
	int vm_count = 0;
	for (i = 0; i < NENV; ++i) {
  800421a2da:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421a2de:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800421a2e5:	0f 8e 6f ff ff ff    	jle    800421a25a <vmx_sel_resume+0x1e>
				envs[i].env_status = ENV_RUNNABLE;
				return true;
			}
		}
	}
	cprintf("Selected VM(No.%d VM) not found.\n", num);	
  800421a2eb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421a2ee:	89 c6                	mov    %eax,%esi
  800421a2f0:	48 bf c0 1f 22 04 80 	movabs $0x8004221fc0,%rdi
  800421a2f7:	00 00 00 
  800421a2fa:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a2ff:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421a306:	00 00 00 
  800421a309:	ff d2                	callq  *%rdx
	return false;
  800421a30b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421a310:	c9                   	leaveq 
  800421a311:	c3                   	retq   

000000800421a312 <vmx_check_support>:
 * See Section 23.6 of the Intel manual.
 * 
 * Hint: the TA solution uses the BIT() macro 
 *  to simplify the implementation.
 */
bool vmx_check_support() {
  800421a312:	55                   	push   %rbp
  800421a313:	48 89 e5             	mov    %rsp,%rbp
  800421a316:	48 83 ec 10          	sub    $0x10,%rsp
	uint32_t eax, ebx, ecx, edx;
	cpuid( 1, &eax, &ebx, &ecx, &edx );
  800421a31a:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800421a31e:	48 8d 4d f4          	lea    -0xc(%rbp),%rcx
  800421a322:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  800421a326:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  800421a32a:	49 89 f0             	mov    %rsi,%r8
  800421a32d:	48 89 c6             	mov    %rax,%rsi
  800421a330:	bf 01 00 00 00       	mov    $0x1,%edi
  800421a335:	48 b8 f2 9f 21 04 80 	movabs $0x8004219ff2,%rax
  800421a33c:	00 00 00 
  800421a33f:	ff d0                	callq  *%rax
    return true;	
  800421a341:	b8 01 00 00 00       	mov    $0x1,%eax
	if (BIT(ecx, 5) == 1)
		return true;

	cprintf("[VMM] VMX extension not supported.\n");
	return false;
}
  800421a346:	c9                   	leaveq 
  800421a347:	c3                   	retq   

000000800421a348 <vmx_check_ept>:
 *
 * Hint: This needs to check two MSR bits---first verifying
 *   that secondary VMX controls are enabled, and then that
 *   EPT is available.
 */
bool vmx_check_ept() {
  800421a348:	55                   	push   %rbp
  800421a349:	48 89 e5             	mov    %rsp,%rbp
  800421a34c:	48 83 ec 30          	sub    $0x30,%rsp
  800421a350:	c7 45 f8 82 04 00 00 	movl   $0x482,-0x8(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421a357:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421a35a:	89 c1                	mov    %eax,%ecx
  800421a35c:	0f 32                	rdmsr  
  800421a35e:	89 55 dc             	mov    %edx,-0x24(%rbp)
  800421a361:	89 45 d8             	mov    %eax,-0x28(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421a364:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  800421a36b:	00 
	ret = edx;
  800421a36c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421a36f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	ret = ret << 32;
  800421a373:	48 c1 65 d0 20       	shlq   $0x20,-0x30(%rbp)
	ret |= eax;
  800421a378:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421a37b:	48 09 45 d0          	or     %rax,-0x30(%rbp)

	return ret;
  800421a37f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
	/* Your code here */
	uint32_t vm_primary_msr = (uint32_t) (read_msr(IA32_VMX_PROCBASED_CTLS) >> 32); 
  800421a383:	48 c1 e8 20          	shr    $0x20,%rax
  800421a387:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800421a38a:	c7 45 f0 8b 04 00 00 	movl   $0x48b,-0x10(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421a391:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800421a394:	89 c1                	mov    %eax,%ecx
  800421a396:	0f 32                	rdmsr  
  800421a398:	89 55 ec             	mov    %edx,-0x14(%rbp)
  800421a39b:	89 45 e8             	mov    %eax,-0x18(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421a39e:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800421a3a5:	00 
	ret = edx;
  800421a3a6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421a3a9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	ret = ret << 32;
  800421a3ad:	48 c1 65 e0 20       	shlq   $0x20,-0x20(%rbp)
	ret |= eax;
  800421a3b2:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421a3b5:	48 09 45 e0          	or     %rax,-0x20(%rbp)

	return ret;
  800421a3b9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
	uint32_t vm_secondary_msr = (uint32_t) (read_msr(IA32_VMX_PROCBASED_CTLS2) >> 32);	
  800421a3bd:	48 c1 e8 20          	shr    $0x20,%rax
  800421a3c1:	89 45 f4             	mov    %eax,-0xc(%rbp)

    return true;
  800421a3c4:	b8 01 00 00 00       	mov    $0x1,%eax
	if (BIT(vm_primary_msr, 31) == 1 && BIT(vm_secondary_msr, 1) == 1)
		return true;

	cprintf("[VMM] EPT extension not supported.\n");
	return false;
}
  800421a3c9:	c9                   	leaveq 
  800421a3ca:	c3                   	retq   

000000800421a3cb <check_fixed_bits>:

/* Checks if curr_val is compatible with fixed0 and fixed1 
 * (allowed values read from the MSR). This is to ensure current processor
 * operating mode meets the required fixed bit requirement of VMX.  
 */
bool check_fixed_bits( uint64_t curr_val, uint64_t fixed0, uint64_t fixed1 ) {
  800421a3cb:	55                   	push   %rbp
  800421a3cc:	48 89 e5             	mov    %rsp,%rbp
  800421a3cf:	48 83 ec 30          	sub    $0x30,%rsp
  800421a3d3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421a3d7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421a3db:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// TODO: Simplify this code.
	int i;
	for( i = 0 ; i < sizeof( curr_val ) * 8 ; ++i ) {
  800421a3df:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421a3e6:	e9 96 00 00 00       	jmpq   800421a481 <check_fixed_bits+0xb6>
		int bit = BIT( curr_val, i );
  800421a3eb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421a3ee:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421a3f2:	89 c1                	mov    %eax,%ecx
  800421a3f4:	48 d3 ea             	shr    %cl,%rdx
  800421a3f7:	48 89 d0             	mov    %rdx,%rax
  800421a3fa:	83 e0 01             	and    $0x1,%eax
  800421a3fd:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if ( bit == 1 ) {
  800421a400:	83 7d f8 01          	cmpl   $0x1,-0x8(%rbp)
  800421a404:	75 1e                	jne    800421a424 <check_fixed_bits+0x59>
			// Check if this bit is fixed to 0.
			if ( BIT( fixed1, i ) == 0 ) {
  800421a406:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421a409:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421a40d:	89 c1                	mov    %eax,%ecx
  800421a40f:	48 d3 ea             	shr    %cl,%rdx
  800421a412:	48 89 d0             	mov    %rdx,%rax
  800421a415:	83 e0 01             	and    $0x1,%eax
  800421a418:	48 85 c0             	test   %rax,%rax
  800421a41b:	75 60                	jne    800421a47d <check_fixed_bits+0xb2>
				return false;
  800421a41d:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a422:	eb 6e                	jmp    800421a492 <check_fixed_bits+0xc7>
			}
		} else if ( bit == 0 ) {
  800421a424:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800421a428:	75 1e                	jne    800421a448 <check_fixed_bits+0x7d>
			// Check if this bit is fixed to 1.
			if ( BIT( fixed0, i ) == 1 ) {
  800421a42a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421a42d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421a431:	89 c1                	mov    %eax,%ecx
  800421a433:	48 d3 ea             	shr    %cl,%rdx
  800421a436:	48 89 d0             	mov    %rdx,%rax
  800421a439:	83 e0 01             	and    $0x1,%eax
  800421a43c:	48 85 c0             	test   %rax,%rax
  800421a43f:	74 3c                	je     800421a47d <check_fixed_bits+0xb2>
				return false;
  800421a441:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a446:	eb 4a                	jmp    800421a492 <check_fixed_bits+0xc7>
			}
		} else {
			assert(false);
  800421a448:	48 b9 e2 1f 22 04 80 	movabs $0x8004221fe2,%rcx
  800421a44f:	00 00 00 
  800421a452:	48 ba e8 1f 22 04 80 	movabs $0x8004221fe8,%rdx
  800421a459:	00 00 00 
  800421a45c:	be 78 00 00 00       	mov    $0x78,%esi
  800421a461:	48 bf fd 1f 22 04 80 	movabs $0x8004221ffd,%rdi
  800421a468:	00 00 00 
  800421a46b:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a470:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421a477:	00 00 00 
  800421a47a:	41 ff d0             	callq  *%r8
 * operating mode meets the required fixed bit requirement of VMX.  
 */
bool check_fixed_bits( uint64_t curr_val, uint64_t fixed0, uint64_t fixed1 ) {
	// TODO: Simplify this code.
	int i;
	for( i = 0 ; i < sizeof( curr_val ) * 8 ; ++i ) {
  800421a47d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421a481:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421a484:	83 f8 3f             	cmp    $0x3f,%eax
  800421a487:	0f 86 5e ff ff ff    	jbe    800421a3eb <check_fixed_bits+0x20>
			}
		} else {
			assert(false);
		}
	}
	return true;
  800421a48d:	b8 01 00 00 00       	mov    $0x1,%eax
}
  800421a492:	c9                   	leaveq 
  800421a493:	c3                   	retq   

000000800421a494 <vmx_init_vmcs>:

/* 
 * Allocate a page for the VMCS region and write the VMCS Rev. ID in the first 
 * 31 bits.
 */
struct PageInfo * vmx_init_vmcs() {
  800421a494:	55                   	push   %rbp
  800421a495:	48 89 e5             	mov    %rsp,%rbp
  800421a498:	48 83 ec 40          	sub    $0x40,%rsp
  800421a49c:	c7 45 dc 80 04 00 00 	movl   $0x480,-0x24(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421a4a3:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421a4a6:	89 c1                	mov    %eax,%ecx
  800421a4a8:	0f 32                	rdmsr  
  800421a4aa:	89 55 d8             	mov    %edx,-0x28(%rbp)
  800421a4ad:	89 45 d4             	mov    %eax,-0x2c(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421a4b0:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  800421a4b7:	00 
	ret = edx;
  800421a4b8:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421a4bb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	ret = ret << 32;
  800421a4bf:	48 c1 65 c8 20       	shlq   $0x20,-0x38(%rbp)
	ret |= eax;
  800421a4c4:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421a4c7:	48 09 45 c8          	or     %rax,-0x38(%rbp)

	return ret;
  800421a4cb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
	// Read the VMX_BASIC MSR.
	uint64_t vmx_basic_msr =  read_msr( IA32_VMX_BASIC );
  800421a4cf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	uint32_t vmcs_rev_id = (uint32_t) vmx_basic_msr; // Bits 30:0, Bit 31 is always 0.
  800421a4d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421a4d7:	89 45 c4             	mov    %eax,-0x3c(%rbp)

	uint32_t vmcs_num_bytes =  ( vmx_basic_msr >> 32 ) & 0xfff; // Bits 44:32.
  800421a4da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421a4de:	48 c1 e8 20          	shr    $0x20,%rax
  800421a4e2:	25 ff 0f 00 00       	and    $0xfff,%eax
  800421a4e7:	89 45 f4             	mov    %eax,-0xc(%rbp)
	assert( vmcs_num_bytes <= 4096 ); // VMCS can have a max size of 4096.
  800421a4ea:	81 7d f4 00 10 00 00 	cmpl   $0x1000,-0xc(%rbp)
  800421a4f1:	76 35                	jbe    800421a528 <vmx_init_vmcs+0x94>
  800421a4f3:	48 b9 07 20 22 04 80 	movabs $0x8004222007,%rcx
  800421a4fa:	00 00 00 
  800421a4fd:	48 ba e8 1f 22 04 80 	movabs $0x8004221fe8,%rdx
  800421a504:	00 00 00 
  800421a507:	be 88 00 00 00       	mov    $0x88,%esi
  800421a50c:	48 bf fd 1f 22 04 80 	movabs $0x8004221ffd,%rdi
  800421a513:	00 00 00 
  800421a516:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a51b:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421a522:	00 00 00 
  800421a525:	41 ff d0             	callq  *%r8

	//Alocate mem for VMCS region.
	struct PageInfo *p_vmxon_region = page_alloc( ALLOC_ZERO );
  800421a528:	bf 01 00 00 00       	mov    $0x1,%edi
  800421a52d:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  800421a534:	00 00 00 
  800421a537:	ff d0                	callq  *%rax
  800421a539:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if(!p_vmxon_region) {
  800421a53d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800421a542:	75 07                	jne    800421a54b <vmx_init_vmcs+0xb7>
		return NULL;
  800421a544:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a549:	eb 4d                	jmp    800421a598 <vmx_init_vmcs+0x104>
	}
	p_vmxon_region->pp_ref += 1; 
  800421a54b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a54f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800421a553:	8d 50 01             	lea    0x1(%rax),%edx
  800421a556:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a55a:	66 89 50 08          	mov    %dx,0x8(%rax)
    
	unsigned char* vmxon_region = (unsigned char *) page2kva( p_vmxon_region );
  800421a55e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a562:	48 89 c7             	mov    %rax,%rdi
  800421a565:	48 b8 b7 a0 21 04 80 	movabs $0x800421a0b7,%rax
  800421a56c:	00 00 00 
  800421a56f:	ff d0                	callq  *%rax
  800421a571:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memcpy( vmxon_region, &vmcs_rev_id, sizeof( vmcs_rev_id ) );
  800421a575:	48 8d 4d c4          	lea    -0x3c(%rbp),%rcx
  800421a579:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421a57d:	ba 04 00 00 00       	mov    $0x4,%edx
  800421a582:	48 89 ce             	mov    %rcx,%rsi
  800421a585:	48 89 c7             	mov    %rax,%rdi
  800421a588:	48 b8 2d 11 21 04 80 	movabs $0x800421112d,%rax
  800421a58f:	00 00 00 
  800421a592:	ff d0                	callq  *%rax

	return p_vmxon_region;
  800421a594:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800421a598:	c9                   	leaveq 
  800421a599:	c3                   	retq   

000000800421a59a <vmx_init_vmxon>:

/* 
 * Sets up a VMXON region and executes VMXON to put the processor in VMX root 
 * operation. Returns a >=0 value if VMX root operation is achieved.
 */
int vmx_init_vmxon() {
  800421a59a:	55                   	push   %rbp
  800421a59b:	48 89 e5             	mov    %rsp,%rbp
  800421a59e:	53                   	push   %rbx
  800421a59f:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
    
	//Alocate mem and init the VMXON region.
	struct PageInfo *p_vmxon_region = vmx_init_vmcs();
  800421a5a6:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a5ab:	48 ba 94 a4 21 04 80 	movabs $0x800421a494,%rdx
  800421a5b2:	00 00 00 
  800421a5b5:	ff d2                	callq  *%rdx
  800421a5b7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if(!p_vmxon_region)
  800421a5bb:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800421a5c0:	75 0a                	jne    800421a5cc <vmx_init_vmxon+0x32>
		return -E_NO_MEM;
  800421a5c2:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800421a5c7:	e9 6b 04 00 00       	jmpq   800421aa37 <vmx_init_vmxon+0x49d>

static __inline uint64_t
rcr0(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr0,%0" : "=r" (val));
  800421a5cc:	0f 20 c0             	mov    %cr0,%rax
  800421a5cf:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	return val;
  800421a5d3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax

	uint64_t cr0 = rcr0();
  800421a5d7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

static __inline uint64_t
rcr4(void)
{
	uint64_t cr4;
	__asm __volatile("movq %%cr4,%0" : "=r" (cr4));
  800421a5db:	0f 20 e0             	mov    %cr4,%rax
  800421a5de:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	return cr4;
  800421a5e2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
	uint64_t cr4 = rcr4();
  800421a5e6:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	// Paging and protected mode are enabled in JOS.
    
	// FIXME: Workaround for CR0.NE (bochs needs this to be set to 1)
	cr0 = cr0 | CR0_NE;
  800421a5ea:	48 83 4d d0 20       	orq    $0x20,-0x30(%rbp)
  800421a5ef:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421a5f3:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
}

static __inline void
lcr0(uint64_t val)
{
	__asm __volatile("movq %0,%%cr0" : : "r" (val));
  800421a5f7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421a5fb:	0f 22 c0             	mov    %rax,%cr0
  800421a5fe:	c7 45 ac 87 04 00 00 	movl   $0x487,-0x54(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421a605:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800421a608:	89 c1                	mov    %eax,%ecx
  800421a60a:	0f 32                	rdmsr  
  800421a60c:	89 95 6c ff ff ff    	mov    %edx,-0x94(%rbp)
  800421a612:	89 85 68 ff ff ff    	mov    %eax,-0x98(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421a618:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
  800421a61f:	00 00 00 00 
	ret = edx;
  800421a623:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
  800421a629:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
	ret = ret << 32;
  800421a630:	48 c1 a5 60 ff ff ff 	shlq   $0x20,-0xa0(%rbp)
  800421a637:	20 
	ret |= eax;
  800421a638:	8b 85 68 ff ff ff    	mov    -0x98(%rbp),%eax
  800421a63e:	48 09 85 60 ff ff ff 	or     %rax,-0xa0(%rbp)

	return ret;
  800421a645:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421a64c:	c7 45 80 86 04 00 00 	movl   $0x486,-0x80(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421a653:	8b 45 80             	mov    -0x80(%rbp),%eax
  800421a656:	89 c1                	mov    %eax,%ecx
  800421a658:	0f 32                	rdmsr  
  800421a65a:	89 95 7c ff ff ff    	mov    %edx,-0x84(%rbp)
  800421a660:	89 85 78 ff ff ff    	mov    %eax,-0x88(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421a666:	48 c7 85 70 ff ff ff 	movq   $0x0,-0x90(%rbp)
  800421a66d:	00 00 00 00 
	ret = edx;
  800421a671:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
  800421a677:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	ret = ret << 32;
  800421a67e:	48 c1 a5 70 ff ff ff 	shlq   $0x20,-0x90(%rbp)
  800421a685:	20 
	ret |= eax;
  800421a686:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
  800421a68c:	48 09 85 70 ff ff ff 	or     %rax,-0x90(%rbp)

	return ret;
  800421a693:	48 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%rcx
	lcr0( cr0 );

	bool ret =  check_fixed_bits( cr0,
  800421a69a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421a69e:	48 89 f2             	mov    %rsi,%rdx
  800421a6a1:	48 89 ce             	mov    %rcx,%rsi
  800421a6a4:	48 89 c7             	mov    %rax,%rdi
  800421a6a7:	48 b8 cb a3 21 04 80 	movabs $0x800421a3cb,%rax
  800421a6ae:	00 00 00 
  800421a6b1:	ff d0                	callq  *%rax
  800421a6b3:	88 45 ab             	mov    %al,-0x55(%rbp)
				      read_msr( IA32_VMX_CR0_FIXED0 ), 
				      read_msr( IA32_VMX_CR0_FIXED1 ) );
	if ( !ret ) {
  800421a6b6:	0f b6 45 ab          	movzbl -0x55(%rbp),%eax
  800421a6ba:	83 f0 01             	xor    $0x1,%eax
  800421a6bd:	84 c0                	test   %al,%al
  800421a6bf:	74 1d                	je     800421a6de <vmx_init_vmxon+0x144>
		page_decref( p_vmxon_region );
  800421a6c1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421a6c5:	48 89 c7             	mov    %rax,%rdi
  800421a6c8:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  800421a6cf:	00 00 00 
  800421a6d2:	ff d0                	callq  *%rax
		return -E_VMX_ON;
  800421a6d4:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
  800421a6d9:	e9 59 03 00 00       	jmpq   800421aa37 <vmx_init_vmxon+0x49d>
	}
	// Enable VMX in CR4.
	cr4 = cr4 | CR4_VMXE;
  800421a6de:	48 81 4d c0 00 20 00 	orq    $0x2000,-0x40(%rbp)
  800421a6e5:	00 
  800421a6e6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421a6ea:	48 89 45 98          	mov    %rax,-0x68(%rbp)
}

static __inline void
lcr4(uint64_t val)
{
	__asm __volatile("movq %0,%%cr4" : : "r" (val));
  800421a6ee:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421a6f2:	0f 22 e0             	mov    %rax,%cr4
  800421a6f5:	c7 45 94 89 04 00 00 	movl   $0x489,-0x6c(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421a6fc:	8b 45 94             	mov    -0x6c(%rbp),%eax
  800421a6ff:	89 c1                	mov    %eax,%ecx
  800421a701:	0f 32                	rdmsr  
  800421a703:	89 95 4c ff ff ff    	mov    %edx,-0xb4(%rbp)
  800421a709:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421a70f:	48 c7 85 40 ff ff ff 	movq   $0x0,-0xc0(%rbp)
  800421a716:	00 00 00 00 
	ret = edx;
  800421a71a:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
  800421a720:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	ret = ret << 32;
  800421a727:	48 c1 a5 40 ff ff ff 	shlq   $0x20,-0xc0(%rbp)
  800421a72e:	20 
	ret |= eax;
  800421a72f:	8b 85 48 ff ff ff    	mov    -0xb8(%rbp),%eax
  800421a735:	48 09 85 40 ff ff ff 	or     %rax,-0xc0(%rbp)

	return ret;
  800421a73c:	48 8b b5 40 ff ff ff 	mov    -0xc0(%rbp),%rsi
  800421a743:	c7 45 dc 88 04 00 00 	movl   $0x488,-0x24(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421a74a:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421a74d:	89 c1                	mov    %eax,%ecx
  800421a74f:	0f 32                	rdmsr  
  800421a751:	89 95 5c ff ff ff    	mov    %edx,-0xa4(%rbp)
  800421a757:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421a75d:	48 c7 85 50 ff ff ff 	movq   $0x0,-0xb0(%rbp)
  800421a764:	00 00 00 00 
	ret = edx;
  800421a768:	8b 85 5c ff ff ff    	mov    -0xa4(%rbp),%eax
  800421a76e:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
	ret = ret << 32;
  800421a775:	48 c1 a5 50 ff ff ff 	shlq   $0x20,-0xb0(%rbp)
  800421a77c:	20 
	ret |= eax;
  800421a77d:	8b 85 58 ff ff ff    	mov    -0xa8(%rbp),%eax
  800421a783:	48 09 85 50 ff ff ff 	or     %rax,-0xb0(%rbp)

	return ret;
  800421a78a:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
	lcr4( cr4 );
	ret =  check_fixed_bits( cr4,
  800421a791:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421a795:	48 89 f2             	mov    %rsi,%rdx
  800421a798:	48 89 ce             	mov    %rcx,%rsi
  800421a79b:	48 89 c7             	mov    %rax,%rdi
  800421a79e:	48 b8 cb a3 21 04 80 	movabs $0x800421a3cb,%rax
  800421a7a5:	00 00 00 
  800421a7a8:	ff d0                	callq  *%rax
  800421a7aa:	88 45 ab             	mov    %al,-0x55(%rbp)
				 read_msr( IA32_VMX_CR4_FIXED0 ), 
				 read_msr( IA32_VMX_CR4_FIXED1 ) );
	if ( !ret ) {
  800421a7ad:	0f b6 45 ab          	movzbl -0x55(%rbp),%eax
  800421a7b1:	83 f0 01             	xor    $0x1,%eax
  800421a7b4:	84 c0                	test   %al,%al
  800421a7b6:	74 1d                	je     800421a7d5 <vmx_init_vmxon+0x23b>
		page_decref( p_vmxon_region );
  800421a7b8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421a7bc:	48 89 c7             	mov    %rax,%rdi
  800421a7bf:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  800421a7c6:	00 00 00 
  800421a7c9:	ff d0                	callq  *%rax
		return -E_VMX_ON;
  800421a7cb:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
  800421a7d0:	e9 62 02 00 00       	jmpq   800421aa37 <vmx_init_vmxon+0x49d>
  800421a7d5:	c7 45 a4 3a 00 00 00 	movl   $0x3a,-0x5c(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421a7dc:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800421a7df:	89 c1                	mov    %eax,%ecx
  800421a7e1:	0f 32                	rdmsr  
  800421a7e3:	89 95 3c ff ff ff    	mov    %edx,-0xc4(%rbp)
  800421a7e9:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421a7ef:	48 c7 85 30 ff ff ff 	movq   $0x0,-0xd0(%rbp)
  800421a7f6:	00 00 00 00 
	ret = edx;
  800421a7fa:	8b 85 3c ff ff ff    	mov    -0xc4(%rbp),%eax
  800421a800:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
	ret = ret << 32;
  800421a807:	48 c1 a5 30 ff ff ff 	shlq   $0x20,-0xd0(%rbp)
  800421a80e:	20 
	ret |= eax;
  800421a80f:	8b 85 38 ff ff ff    	mov    -0xc8(%rbp),%eax
  800421a815:	48 09 85 30 ff ff ff 	or     %rax,-0xd0(%rbp)

	return ret;
  800421a81c:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
	}
	// Ensure that IA32_FEATURE_CONTROL MSR has been properly programmed and 
	// and that it's lock bit has been set.
	uint64_t feature_control = read_msr( IA32_FEATURE_CONTROL );
  800421a823:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if ( !BIT( feature_control, 2 )) {
  800421a827:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a82b:	83 e0 04             	and    $0x4,%eax
  800421a82e:	48 85 c0             	test   %rax,%rax
  800421a831:	0f 85 dc 00 00 00    	jne    800421a913 <vmx_init_vmxon+0x379>
		// DEP 1/14/17: qemu does not appear to properly implement a VMX-compatible BIOS.
		//   Assuming we will be running on qemu, let's just set the MSR bit in the vmm,
		//   which is how the qemu authors read the Intel manual.
		feature_control |= 0x4;
  800421a837:	48 83 4d e8 04       	orq    $0x4,-0x18(%rbp)
  800421a83c:	c7 45 88 3a 00 00 00 	movl   $0x3a,-0x78(%rbp)
  800421a843:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a847:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
}

static __inline void
write_msr( uint32_t ecx, uint64_t val ) {
	uint32_t edx, eax;
	eax = (uint32_t) val;
  800421a84e:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800421a855:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
	edx = (uint32_t) ( val >> 32 );
  800421a85b:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800421a862:	48 c1 e8 20          	shr    $0x20,%rax
  800421a866:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%rbp)
	__asm __volatile("wrmsr"
  800421a86c:	8b 4d 88             	mov    -0x78(%rbp),%ecx
  800421a86f:	8b 95 10 ff ff ff    	mov    -0xf0(%rbp),%edx
  800421a875:	8b 85 14 ff ff ff    	mov    -0xec(%rbp),%eax
  800421a87b:	0f 30                	wrmsr  
  800421a87d:	c7 45 90 3a 00 00 00 	movl   $0x3a,-0x70(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421a884:	8b 45 90             	mov    -0x70(%rbp),%eax
  800421a887:	89 c1                	mov    %eax,%ecx
  800421a889:	0f 32                	rdmsr  
  800421a88b:	89 95 2c ff ff ff    	mov    %edx,-0xd4(%rbp)
  800421a891:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421a897:	48 c7 85 20 ff ff ff 	movq   $0x0,-0xe0(%rbp)
  800421a89e:	00 00 00 00 
	ret = edx;
  800421a8a2:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
  800421a8a8:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
	ret = ret << 32;
  800421a8af:	48 c1 a5 20 ff ff ff 	shlq   $0x20,-0xe0(%rbp)
  800421a8b6:	20 
	ret |= eax;
  800421a8b7:	8b 85 28 ff ff ff    	mov    -0xd8(%rbp),%eax
  800421a8bd:	48 09 85 20 ff ff ff 	or     %rax,-0xe0(%rbp)

	return ret;
  800421a8c4:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
		write_msr( IA32_FEATURE_CONTROL, feature_control );   
		// See if the attempt "took"
		feature_control = read_msr( IA32_FEATURE_CONTROL );
  800421a8cb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if ( !BIT( feature_control, 2 )) {
  800421a8cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a8d3:	83 e0 04             	and    $0x4,%eax
  800421a8d6:	48 85 c0             	test   %rax,%rax
  800421a8d9:	75 38                	jne    800421a913 <vmx_init_vmxon+0x379>
			page_decref( p_vmxon_region );
  800421a8db:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421a8df:	48 89 c7             	mov    %rax,%rdi
  800421a8e2:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  800421a8e9:	00 00 00 
  800421a8ec:	ff d0                	callq  *%rax
			// VMX disabled in BIOS.
			cprintf("Unable to start VMM: VMX disabled in BIOS\n");
  800421a8ee:	48 bf 20 20 22 04 80 	movabs $0x8004222020,%rdi
  800421a8f5:	00 00 00 
  800421a8f8:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a8fd:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421a904:	00 00 00 
  800421a907:	ff d2                	callq  *%rdx
			return -E_NO_VMX;
  800421a909:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
  800421a90e:	e9 24 01 00 00       	jmpq   800421aa37 <vmx_init_vmxon+0x49d>
		}
	}
	if ( !BIT( feature_control, 0 )) {
  800421a913:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a917:	83 e0 01             	and    $0x1,%eax
  800421a91a:	48 85 c0             	test   %rax,%rax
  800421a91d:	75 46                	jne    800421a965 <vmx_init_vmxon+0x3cb>
		// Lock bit not set, try setting it.
		feature_control |= 0x1;
  800421a91f:	48 83 4d e8 01       	orq    $0x1,-0x18(%rbp)
  800421a924:	c7 45 8c 3a 00 00 00 	movl   $0x3a,-0x74(%rbp)
  800421a92b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a92f:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
}

static __inline void
write_msr( uint32_t ecx, uint64_t val ) {
	uint32_t edx, eax;
	eax = (uint32_t) val;
  800421a936:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800421a93d:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%rbp)
	edx = (uint32_t) ( val >> 32 );
  800421a943:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800421a94a:	48 c1 e8 20          	shr    $0x20,%rax
  800421a94e:	89 85 00 ff ff ff    	mov    %eax,-0x100(%rbp)
	__asm __volatile("wrmsr"
  800421a954:	8b 4d 8c             	mov    -0x74(%rbp),%ecx
  800421a957:	8b 95 00 ff ff ff    	mov    -0x100(%rbp),%edx
  800421a95d:	8b 85 04 ff ff ff    	mov    -0xfc(%rbp),%eax
  800421a963:	0f 30                	wrmsr  
		write_msr( IA32_FEATURE_CONTROL, feature_control );   
	}
    
	uint8_t error = vmxon( (physaddr_t) page2pa( p_vmxon_region ) );
  800421a965:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421a969:	48 89 c7             	mov    %rax,%rdi
  800421a96c:	48 b8 92 a0 21 04 80 	movabs $0x800421a092,%rax
  800421a973:	00 00 00 
  800421a976:	ff d0                	callq  *%rax
  800421a978:	48 89 85 f8 fe ff ff 	mov    %rax,-0x108(%rbp)
static __inline uint8_t vmptrld( physaddr_t vmcs_region ) __attribute((always_inline));


static __inline uint8_t
vmxon( physaddr_t vmxon_region ) {
	uint8_t error = 0;
  800421a97f:	c6 45 87 00          	movb   $0x0,-0x79(%rbp)

    __asm __volatile("clc; vmxon %1; setna %0"
  800421a983:	f8                   	clc    
  800421a984:	f3 0f c7 b5 f8 fe ff 	vmxon  -0x108(%rbp)
  800421a98b:	ff 
  800421a98c:	0f 96 c0             	setbe  %al
  800421a98f:	88 45 87             	mov    %al,-0x79(%rbp)
            : "=q"( error ) : "m" ( vmxon_region ): "cc" );
    return error;
  800421a992:	0f b6 45 87          	movzbl -0x79(%rbp),%eax
  800421a996:	88 45 86             	mov    %al,-0x7a(%rbp)
	if ( error ) { 
  800421a999:	80 7d 86 00          	cmpb   $0x0,-0x7a(%rbp)
  800421a99d:	74 1a                	je     800421a9b9 <vmx_init_vmxon+0x41f>
		page_decref( p_vmxon_region );
  800421a99f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421a9a3:	48 89 c7             	mov    %rax,%rdi
  800421a9a6:	48 b8 31 30 20 04 80 	movabs $0x8004203031,%rax
  800421a9ad:	00 00 00 
  800421a9b0:	ff d0                	callq  *%rax
		return -E_VMX_ON; 
  800421a9b2:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
  800421a9b7:	eb 7e                	jmp    800421aa37 <vmx_init_vmxon+0x49d>
	}

	thiscpu->is_vmx_root = true;
  800421a9b9:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421a9c0:	00 00 00 
  800421a9c3:	ff d0                	callq  *%rax
  800421a9c5:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421a9cc:	00 00 00 
  800421a9cf:	48 98                	cltq   
  800421a9d1:	48 c1 e0 03          	shl    $0x3,%rax
  800421a9d5:	48 89 c1             	mov    %rax,%rcx
  800421a9d8:	48 c1 e1 04          	shl    $0x4,%rcx
  800421a9dc:	48 01 c8             	add    %rcx,%rax
  800421a9df:	48 01 d0             	add    %rdx,%rax
  800421a9e2:	48 83 c0 78          	add    $0x78,%rax
  800421a9e6:	c6 00 01             	movb   $0x1,(%rax)
	thiscpu->vmxon_region = (uintptr_t) page2kva( p_vmxon_region );
  800421a9e9:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421a9f0:	00 00 00 
  800421a9f3:	ff d0                	callq  *%rax
  800421a9f5:	89 c3                	mov    %eax,%ebx
  800421a9f7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421a9fb:	48 89 c7             	mov    %rax,%rdi
  800421a9fe:	48 b8 b7 a0 21 04 80 	movabs $0x800421a0b7,%rax
  800421aa05:	00 00 00 
  800421aa08:	ff d0                	callq  *%rax
  800421aa0a:	48 89 c6             	mov    %rax,%rsi
  800421aa0d:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421aa14:	00 00 00 
  800421aa17:	48 63 c3             	movslq %ebx,%rax
  800421aa1a:	48 c1 e0 03          	shl    $0x3,%rax
  800421aa1e:	48 89 c1             	mov    %rax,%rcx
  800421aa21:	48 c1 e1 04          	shl    $0x4,%rcx
  800421aa25:	48 01 c8             	add    %rcx,%rax
  800421aa28:	48 01 d0             	add    %rdx,%rax
  800421aa2b:	48 83 e8 80          	sub    $0xffffffffffffff80,%rax
  800421aa2f:	48 89 30             	mov    %rsi,(%rax)

	return 0;
  800421aa32:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421aa37:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  800421aa3e:	5b                   	pop    %rbx
  800421aa3f:	5d                   	pop    %rbp
  800421aa40:	c3                   	retq   

000000800421aa41 <vmcs_host_init>:

void vmcs_host_init() {
  800421aa41:	55                   	push   %rbp
  800421aa42:	48 89 e5             	mov    %rsp,%rbp
  800421aa45:	48 81 ec 20 01 00 00 	sub    $0x120,%rsp

static __inline uint64_t
rcr0(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr0,%0" : "=r" (val));
  800421aa4c:	0f 20 c0             	mov    %cr0,%rax
  800421aa4f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return val;
  800421aa53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421aa57:	c7 45 f4 00 6c 00 00 	movl   $0x6c00,-0xc(%rbp)
  800421aa5e:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421aa65:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800421aa6c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421aa6f:	48 89 d6             	mov    %rdx,%rsi
  800421aa72:	89 c7                	mov    %eax,%edi
  800421aa74:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421aa7b:	00 00 00 
  800421aa7e:	ff d0                	callq  *%rax

static __inline uint64_t
rcr3(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr3,%0" : "=r" (val));
  800421aa80:	0f 20 d8             	mov    %cr3,%rax
  800421aa83:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	return val;
  800421aa87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421aa8b:	c7 45 e4 02 6c 00 00 	movl   $0x6c02,-0x1c(%rbp)
  800421aa92:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  800421aa99:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
  800421aaa0:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421aaa3:	48 89 d6             	mov    %rdx,%rsi
  800421aaa6:	89 c7                	mov    %eax,%edi
  800421aaa8:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421aaaf:	00 00 00 
  800421aab2:	ff d0                	callq  *%rax

static __inline uint64_t
rcr4(void)
{
	uint64_t cr4;
	__asm __volatile("movq %%cr4,%0" : "=r" (cr4));
  800421aab4:	0f 20 e0             	mov    %cr4,%rax
  800421aab7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	return cr4;
  800421aabb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421aabf:	c7 45 d4 04 6c 00 00 	movl   $0x6c04,-0x2c(%rbp)
  800421aac6:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  800421aacd:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  800421aad4:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421aad7:	48 89 d6             	mov    %rdx,%rsi
  800421aada:	89 c7                	mov    %eax,%edi
  800421aadc:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421aae3:	00 00 00 
  800421aae6:	ff d0                	callq  *%rax
  800421aae8:	c7 45 d0 00 0c 00 00 	movl   $0xc00,-0x30(%rbp)
  800421aaef:	66 c7 85 32 ff ff ff 	movw   $0x10,-0xce(%rbp)
  800421aaf6:	10 00 
		       : "=q"( error ) : "a"( value ), "d"( field ) : "cc");
    return error;
}

static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
  800421aaf8:	0f b7 95 32 ff ff ff 	movzwl -0xce(%rbp),%edx
  800421aaff:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800421ab02:	48 89 d6             	mov    %rdx,%rsi
  800421ab05:	89 c7                	mov    %eax,%edi
  800421ab07:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421ab0e:	00 00 00 
  800421ab11:	ff d0                	callq  *%rax
  800421ab13:	c7 45 cc 04 0c 00 00 	movl   $0xc04,-0x34(%rbp)
  800421ab1a:	66 c7 85 34 ff ff ff 	movw   $0x10,-0xcc(%rbp)
  800421ab21:	10 00 
  800421ab23:	0f b7 95 34 ff ff ff 	movzwl -0xcc(%rbp),%edx
  800421ab2a:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421ab2d:	48 89 d6             	mov    %rdx,%rsi
  800421ab30:	89 c7                	mov    %eax,%edi
  800421ab32:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421ab39:	00 00 00 
  800421ab3c:	ff d0                	callq  *%rax
  800421ab3e:	c7 45 c8 06 0c 00 00 	movl   $0xc06,-0x38(%rbp)
  800421ab45:	66 c7 85 36 ff ff ff 	movw   $0x10,-0xca(%rbp)
  800421ab4c:	10 00 
  800421ab4e:	0f b7 95 36 ff ff ff 	movzwl -0xca(%rbp),%edx
  800421ab55:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421ab58:	48 89 d6             	mov    %rdx,%rsi
  800421ab5b:	89 c7                	mov    %eax,%edi
  800421ab5d:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421ab64:	00 00 00 
  800421ab67:	ff d0                	callq  *%rax
  800421ab69:	c7 45 c4 08 0c 00 00 	movl   $0xc08,-0x3c(%rbp)
  800421ab70:	66 c7 85 38 ff ff ff 	movw   $0x10,-0xc8(%rbp)
  800421ab77:	10 00 
  800421ab79:	0f b7 95 38 ff ff ff 	movzwl -0xc8(%rbp),%edx
  800421ab80:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421ab83:	48 89 d6             	mov    %rdx,%rsi
  800421ab86:	89 c7                	mov    %eax,%edi
  800421ab88:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421ab8f:	00 00 00 
  800421ab92:	ff d0                	callq  *%rax
  800421ab94:	c7 45 c0 0a 0c 00 00 	movl   $0xc0a,-0x40(%rbp)
  800421ab9b:	66 c7 85 3a ff ff ff 	movw   $0x10,-0xc6(%rbp)
  800421aba2:	10 00 
  800421aba4:	0f b7 95 3a ff ff ff 	movzwl -0xc6(%rbp),%edx
  800421abab:	8b 45 c0             	mov    -0x40(%rbp),%eax
  800421abae:	48 89 d6             	mov    %rdx,%rsi
  800421abb1:	89 c7                	mov    %eax,%edi
  800421abb3:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421abba:	00 00 00 
  800421abbd:	ff d0                	callq  *%rax
  800421abbf:	c7 45 b8 02 0c 00 00 	movl   $0xc02,-0x48(%rbp)
  800421abc6:	66 c7 85 3c ff ff ff 	movw   $0x8,-0xc4(%rbp)
  800421abcd:	08 00 
  800421abcf:	0f b7 95 3c ff ff ff 	movzwl -0xc4(%rbp),%edx
  800421abd6:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800421abd9:	48 89 d6             	mov    %rdx,%rsi
  800421abdc:	89 c7                	mov    %eax,%edi
  800421abde:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421abe5:	00 00 00 
  800421abe8:	ff d0                	callq  *%rax
	vmcs_write16( VMCS_16BIT_HOST_DS_SELECTOR, GD_KD );
	vmcs_write16( VMCS_16BIT_HOST_FS_SELECTOR, GD_KD );
	vmcs_write16( VMCS_16BIT_HOST_GS_SELECTOR, GD_KD );
	vmcs_write16( VMCS_16BIT_HOST_CS_SELECTOR, GD_KT );

	int gd_tss = (GD_TSS0 >> 3) + thiscpu->cpu_id*2;
  800421abea:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421abf1:	00 00 00 
  800421abf4:	ff d0                	callq  *%rax
  800421abf6:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421abfd:	00 00 00 
  800421ac00:	48 98                	cltq   
  800421ac02:	48 c1 e0 03          	shl    $0x3,%rax
  800421ac06:	48 89 c1             	mov    %rax,%rcx
  800421ac09:	48 c1 e1 04          	shl    $0x4,%rcx
  800421ac0d:	48 01 c8             	add    %rcx,%rax
  800421ac10:	48 01 d0             	add    %rdx,%rax
  800421ac13:	0f b6 00             	movzbl (%rax),%eax
  800421ac16:	0f b6 c0             	movzbl %al,%eax
  800421ac19:	01 c0                	add    %eax,%eax
  800421ac1b:	83 c0 05             	add    $0x5,%eax
  800421ac1e:	89 45 bc             	mov    %eax,-0x44(%rbp)
	vmcs_write16( VMCS_16BIT_HOST_TR_SELECTOR, gd_tss << 3 );
  800421ac21:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800421ac24:	c1 e0 03             	shl    $0x3,%eax
  800421ac27:	0f b7 c0             	movzwl %ax,%eax
  800421ac2a:	c7 45 b4 0c 0c 00 00 	movl   $0xc0c,-0x4c(%rbp)
  800421ac31:	66 89 85 3e ff ff ff 	mov    %ax,-0xc2(%rbp)
  800421ac38:	0f b7 95 3e ff ff ff 	movzwl -0xc2(%rbp),%edx
  800421ac3f:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800421ac42:	48 89 d6             	mov    %rdx,%rsi
  800421ac45:	89 c7                	mov    %eax,%edi
  800421ac47:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421ac4e:	00 00 00 
  800421ac51:	ff d0                	callq  *%rax
  800421ac53:	48 8d 85 08 ff ff ff 	lea    -0xf8(%rbp),%rax
  800421ac5a:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  800421ac5e:	48 8d 85 16 ff ff ff 	lea    -0xea(%rbp),%rax
  800421ac65:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
static __inline void
read_idtr (uint64_t *idtbase, uint16_t *idtlimit)
{
	struct Pseudodesc idtr;

	asm volatile ("sidt %0"
  800421ac6c:	0f 01 8d f0 fe ff ff 	sidt   -0x110(%rbp)
			: "=m" (idtr));
	*idtbase = idtr.pd_base;
  800421ac73:	48 8b 95 f2 fe ff ff 	mov    -0x10e(%rbp),%rdx
  800421ac7a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421ac7e:	48 89 10             	mov    %rdx,(%rax)
	*idtlimit = idtr.pd_lim;
  800421ac81:	0f b7 95 f0 fe ff ff 	movzwl -0x110(%rbp),%edx
  800421ac88:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  800421ac8f:	66 89 10             	mov    %dx,(%rax)
    
	uint16_t xdtr_limit;
	uint64_t xdtr_base;
	read_idtr( &xdtr_base, &xdtr_limit );
	vmcs_write64( VMCS_HOST_IDTR_BASE, xdtr_base );
  800421ac92:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800421ac99:	c7 45 a4 0e 6c 00 00 	movl   $0x6c0e,-0x5c(%rbp)
  800421aca0:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421aca7:	48 8b 95 48 ff ff ff 	mov    -0xb8(%rbp),%rdx
  800421acae:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800421acb1:	48 89 d6             	mov    %rdx,%rsi
  800421acb4:	89 c7                	mov    %eax,%edi
  800421acb6:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421acbd:	00 00 00 
  800421acc0:	ff d0                	callq  *%rax
  800421acc2:	48 8d 85 08 ff ff ff 	lea    -0xf8(%rbp),%rax
  800421acc9:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  800421accd:	48 8d 85 16 ff ff ff 	lea    -0xea(%rbp),%rax
  800421acd4:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
static __inline void
read_gdtr (uint64_t *gdtbase, uint16_t *gdtlimit)
{
	struct Pseudodesc gdtr;

	asm volatile ("sgdt %0"
  800421acdb:	0f 01 85 e0 fe ff ff 	sgdt   -0x120(%rbp)
			: "=m" (gdtr));
	*gdtbase = gdtr.pd_base;
  800421ace2:	48 8b 95 e2 fe ff ff 	mov    -0x11e(%rbp),%rdx
  800421ace9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421aced:	48 89 10             	mov    %rdx,(%rax)
	*gdtlimit = gdtr.pd_lim;
  800421acf0:	0f b7 95 e0 fe ff ff 	movzwl -0x120(%rbp),%edx
  800421acf7:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800421acfe:	66 89 10             	mov    %dx,(%rax)

	read_gdtr( &xdtr_base, &xdtr_limit );
	vmcs_write64( VMCS_HOST_GDTR_BASE, xdtr_base );
  800421ad01:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800421ad08:	c7 45 94 0c 6c 00 00 	movl   $0x6c0c,-0x6c(%rbp)
  800421ad0f:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  800421ad16:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800421ad1d:	8b 45 94             	mov    -0x6c(%rbp),%eax
  800421ad20:	48 89 d6             	mov    %rdx,%rsi
  800421ad23:	89 c7                	mov    %eax,%edi
  800421ad25:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421ad2c:	00 00 00 
  800421ad2f:	ff d0                	callq  *%rax
  800421ad31:	c7 45 90 06 6c 00 00 	movl   $0x6c06,-0x70(%rbp)
  800421ad38:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
  800421ad3f:	00 00 00 00 
  800421ad43:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421ad4a:	8b 45 90             	mov    -0x70(%rbp),%eax
  800421ad4d:	48 89 d6             	mov    %rdx,%rsi
  800421ad50:	89 c7                	mov    %eax,%edi
  800421ad52:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421ad59:	00 00 00 
  800421ad5c:	ff d0                	callq  *%rax
  800421ad5e:	c7 45 8c 08 6c 00 00 	movl   $0x6c08,-0x74(%rbp)
  800421ad65:	48 c7 85 68 ff ff ff 	movq   $0x0,-0x98(%rbp)
  800421ad6c:	00 00 00 00 
  800421ad70:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  800421ad77:	8b 45 8c             	mov    -0x74(%rbp),%eax
  800421ad7a:	48 89 d6             	mov    %rdx,%rsi
  800421ad7d:	89 c7                	mov    %eax,%edi
  800421ad7f:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421ad86:	00 00 00 
  800421ad89:	ff d0                	callq  *%rax

	vmcs_write64( VMCS_HOST_FS_BASE, 0x0 );
	vmcs_write64( VMCS_HOST_GS_BASE, 0x0 );
	vmcs_write64( VMCS_HOST_TR_BASE, (uint64_t) &thiscpu->cpu_ts );
  800421ad8b:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421ad92:	00 00 00 
  800421ad95:	ff d0                	callq  *%rax
  800421ad97:	48 98                	cltq   
  800421ad99:	48 c1 e0 03          	shl    $0x3,%rax
  800421ad9d:	48 89 c2             	mov    %rax,%rdx
  800421ada0:	48 c1 e2 04          	shl    $0x4,%rdx
  800421ada4:	48 01 d0             	add    %rdx,%rax
  800421ada7:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800421adab:	48 b8 20 e0 6d 04 80 	movabs $0x80046de020,%rax
  800421adb2:	00 00 00 
  800421adb5:	48 01 d0             	add    %rdx,%rax
  800421adb8:	c7 85 7c ff ff ff 0a 	movl   $0x6c0a,-0x84(%rbp)
  800421adbf:	6c 00 00 
  800421adc2:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  800421adc9:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800421add0:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
  800421add6:	48 89 d6             	mov    %rdx,%rsi
  800421add9:	89 c7                	mov    %eax,%edi
  800421addb:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421ade2:	00 00 00 
  800421ade5:	ff d0                	callq  *%rax

	uint64_t tmpl;
	asm("movabs $.Lvmx_return, %0" : "=r"(tmpl));
  800421ade7:	48 b8 bf d8 21 04 80 	movabs $0x800421d8bf,%rax
  800421adee:	00 00 00 
  800421adf1:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	vmcs_writel(VMCS_HOST_RIP, tmpl);
  800421adf5:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421adf9:	48 89 c6             	mov    %rax,%rsi
  800421adfc:	bf 16 6c 00 00       	mov    $0x6c16,%edi
  800421ae01:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421ae08:	00 00 00 
  800421ae0b:	ff d0                	callq  *%rax
}
  800421ae0d:	90                   	nop
  800421ae0e:	c9                   	leaveq 
  800421ae0f:	c3                   	retq   

000000800421ae10 <vmcs_guest_init>:

void vmcs_guest_init() {
  800421ae10:	55                   	push   %rbp
  800421ae11:	48 89 e5             	mov    %rsp,%rbp
  800421ae14:	48 81 ec a0 01 00 00 	sub    $0x1a0,%rsp
  800421ae1b:	c7 45 fc 02 08 00 00 	movl   $0x802,-0x4(%rbp)
  800421ae22:	66 c7 85 60 fe ff ff 	movw   $0x0,-0x1a0(%rbp)
  800421ae29:	00 00 
		       : "=q"( error ) : "a"( value ), "d"( field ) : "cc");
    return error;
}

static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
  800421ae2b:	0f b7 95 60 fe ff ff 	movzwl -0x1a0(%rbp),%edx
  800421ae32:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421ae35:	48 89 d6             	mov    %rdx,%rsi
  800421ae38:	89 c7                	mov    %eax,%edi
  800421ae3a:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421ae41:	00 00 00 
  800421ae44:	ff d0                	callq  *%rax
  800421ae46:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%rbp)
  800421ae4d:	66 c7 85 62 fe ff ff 	movw   $0x0,-0x19e(%rbp)
  800421ae54:	00 00 
  800421ae56:	0f b7 95 62 fe ff ff 	movzwl -0x19e(%rbp),%edx
  800421ae5d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421ae60:	48 89 d6             	mov    %rdx,%rsi
  800421ae63:	89 c7                	mov    %eax,%edi
  800421ae65:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421ae6c:	00 00 00 
  800421ae6f:	ff d0                	callq  *%rax
  800421ae71:	c7 45 f4 04 08 00 00 	movl   $0x804,-0xc(%rbp)
  800421ae78:	66 c7 85 64 fe ff ff 	movw   $0x0,-0x19c(%rbp)
  800421ae7f:	00 00 
  800421ae81:	0f b7 95 64 fe ff ff 	movzwl -0x19c(%rbp),%edx
  800421ae88:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421ae8b:	48 89 d6             	mov    %rdx,%rsi
  800421ae8e:	89 c7                	mov    %eax,%edi
  800421ae90:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421ae97:	00 00 00 
  800421ae9a:	ff d0                	callq  *%rax
  800421ae9c:	c7 45 f0 06 08 00 00 	movl   $0x806,-0x10(%rbp)
  800421aea3:	66 c7 85 66 fe ff ff 	movw   $0x0,-0x19a(%rbp)
  800421aeaa:	00 00 
  800421aeac:	0f b7 95 66 fe ff ff 	movzwl -0x19a(%rbp),%edx
  800421aeb3:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800421aeb6:	48 89 d6             	mov    %rdx,%rsi
  800421aeb9:	89 c7                	mov    %eax,%edi
  800421aebb:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421aec2:	00 00 00 
  800421aec5:	ff d0                	callq  *%rax
  800421aec7:	c7 45 ec 08 08 00 00 	movl   $0x808,-0x14(%rbp)
  800421aece:	66 c7 85 68 fe ff ff 	movw   $0x0,-0x198(%rbp)
  800421aed5:	00 00 
  800421aed7:	0f b7 95 68 fe ff ff 	movzwl -0x198(%rbp),%edx
  800421aede:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421aee1:	48 89 d6             	mov    %rdx,%rsi
  800421aee4:	89 c7                	mov    %eax,%edi
  800421aee6:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421aeed:	00 00 00 
  800421aef0:	ff d0                	callq  *%rax
  800421aef2:	c7 45 e8 0a 08 00 00 	movl   $0x80a,-0x18(%rbp)
  800421aef9:	66 c7 85 6a fe ff ff 	movw   $0x0,-0x196(%rbp)
  800421af00:	00 00 
  800421af02:	0f b7 95 6a fe ff ff 	movzwl -0x196(%rbp),%edx
  800421af09:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421af0c:	48 89 d6             	mov    %rdx,%rsi
  800421af0f:	89 c7                	mov    %eax,%edi
  800421af11:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421af18:	00 00 00 
  800421af1b:	ff d0                	callq  *%rax
  800421af1d:	c7 45 e4 0e 08 00 00 	movl   $0x80e,-0x1c(%rbp)
  800421af24:	66 c7 85 6c fe ff ff 	movw   $0x0,-0x194(%rbp)
  800421af2b:	00 00 
  800421af2d:	0f b7 95 6c fe ff ff 	movzwl -0x194(%rbp),%edx
  800421af34:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421af37:	48 89 d6             	mov    %rdx,%rsi
  800421af3a:	89 c7                	mov    %eax,%edi
  800421af3c:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421af43:	00 00 00 
  800421af46:	ff d0                	callq  *%rax
  800421af48:	c7 45 e0 0c 08 00 00 	movl   $0x80c,-0x20(%rbp)
  800421af4f:	66 c7 85 6e fe ff ff 	movw   $0x0,-0x192(%rbp)
  800421af56:	00 00 
  800421af58:	0f b7 95 6e fe ff ff 	movzwl -0x192(%rbp),%edx
  800421af5f:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421af62:	48 89 d6             	mov    %rdx,%rsi
  800421af65:	89 c7                	mov    %eax,%edi
  800421af67:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421af6e:	00 00 00 
  800421af71:	ff d0                	callq  *%rax
  800421af73:	c7 45 dc 08 68 00 00 	movl   $0x6808,-0x24(%rbp)
  800421af7a:	48 c7 85 70 fe ff ff 	movq   $0x0,-0x190(%rbp)
  800421af81:	00 00 00 00 
static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421af85:	48 8b 95 70 fe ff ff 	mov    -0x190(%rbp),%rdx
  800421af8c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421af8f:	48 89 d6             	mov    %rdx,%rsi
  800421af92:	89 c7                	mov    %eax,%edi
  800421af94:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421af9b:	00 00 00 
  800421af9e:	ff d0                	callq  *%rax
  800421afa0:	c7 45 d8 06 68 00 00 	movl   $0x6806,-0x28(%rbp)
  800421afa7:	48 c7 85 78 fe ff ff 	movq   $0x0,-0x188(%rbp)
  800421afae:	00 00 00 00 
  800421afb2:	48 8b 95 78 fe ff ff 	mov    -0x188(%rbp),%rdx
  800421afb9:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421afbc:	48 89 d6             	mov    %rdx,%rsi
  800421afbf:	89 c7                	mov    %eax,%edi
  800421afc1:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421afc8:	00 00 00 
  800421afcb:	ff d0                	callq  *%rax
  800421afcd:	c7 45 d4 0a 68 00 00 	movl   $0x680a,-0x2c(%rbp)
  800421afd4:	48 c7 85 80 fe ff ff 	movq   $0x0,-0x180(%rbp)
  800421afdb:	00 00 00 00 
  800421afdf:	48 8b 95 80 fe ff ff 	mov    -0x180(%rbp),%rdx
  800421afe6:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421afe9:	48 89 d6             	mov    %rdx,%rsi
  800421afec:	89 c7                	mov    %eax,%edi
  800421afee:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421aff5:	00 00 00 
  800421aff8:	ff d0                	callq  *%rax
  800421affa:	c7 45 d0 0c 68 00 00 	movl   $0x680c,-0x30(%rbp)
  800421b001:	48 c7 85 88 fe ff ff 	movq   $0x0,-0x178(%rbp)
  800421b008:	00 00 00 00 
  800421b00c:	48 8b 95 88 fe ff ff 	mov    -0x178(%rbp),%rdx
  800421b013:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800421b016:	48 89 d6             	mov    %rdx,%rsi
  800421b019:	89 c7                	mov    %eax,%edi
  800421b01b:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b022:	00 00 00 
  800421b025:	ff d0                	callq  *%rax
  800421b027:	c7 45 cc 0e 68 00 00 	movl   $0x680e,-0x34(%rbp)
  800421b02e:	48 c7 85 90 fe ff ff 	movq   $0x0,-0x170(%rbp)
  800421b035:	00 00 00 00 
  800421b039:	48 8b 95 90 fe ff ff 	mov    -0x170(%rbp),%rdx
  800421b040:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421b043:	48 89 d6             	mov    %rdx,%rsi
  800421b046:	89 c7                	mov    %eax,%edi
  800421b048:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b04f:	00 00 00 
  800421b052:	ff d0                	callq  *%rax
  800421b054:	c7 45 c8 10 68 00 00 	movl   $0x6810,-0x38(%rbp)
  800421b05b:	48 c7 85 98 fe ff ff 	movq   $0x0,-0x168(%rbp)
  800421b062:	00 00 00 00 
  800421b066:	48 8b 95 98 fe ff ff 	mov    -0x168(%rbp),%rdx
  800421b06d:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421b070:	48 89 d6             	mov    %rdx,%rsi
  800421b073:	89 c7                	mov    %eax,%edi
  800421b075:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b07c:	00 00 00 
  800421b07f:	ff d0                	callq  *%rax
  800421b081:	c7 45 c4 12 68 00 00 	movl   $0x6812,-0x3c(%rbp)
  800421b088:	48 c7 85 a0 fe ff ff 	movq   $0x0,-0x160(%rbp)
  800421b08f:	00 00 00 00 
  800421b093:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  800421b09a:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421b09d:	48 89 d6             	mov    %rdx,%rsi
  800421b0a0:	89 c7                	mov    %eax,%edi
  800421b0a2:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b0a9:	00 00 00 
  800421b0ac:	ff d0                	callq  *%rax
  800421b0ae:	c7 45 c0 16 68 00 00 	movl   $0x6816,-0x40(%rbp)
  800421b0b5:	48 c7 85 a8 fe ff ff 	movq   $0x0,-0x158(%rbp)
  800421b0bc:	00 00 00 00 
  800421b0c0:	48 8b 95 a8 fe ff ff 	mov    -0x158(%rbp),%rdx
  800421b0c7:	8b 45 c0             	mov    -0x40(%rbp),%eax
  800421b0ca:	48 89 d6             	mov    %rdx,%rsi
  800421b0cd:	89 c7                	mov    %eax,%edi
  800421b0cf:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b0d6:	00 00 00 
  800421b0d9:	ff d0                	callq  *%rax
  800421b0db:	c7 45 bc 18 68 00 00 	movl   $0x6818,-0x44(%rbp)
  800421b0e2:	48 c7 85 b0 fe ff ff 	movq   $0x0,-0x150(%rbp)
  800421b0e9:	00 00 00 00 
  800421b0ed:	48 8b 95 b0 fe ff ff 	mov    -0x150(%rbp),%rdx
  800421b0f4:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800421b0f7:	48 89 d6             	mov    %rdx,%rsi
  800421b0fa:	89 c7                	mov    %eax,%edi
  800421b0fc:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b103:	00 00 00 
  800421b106:	ff d0                	callq  *%rax
  800421b108:	c7 45 b8 14 68 00 00 	movl   $0x6814,-0x48(%rbp)
  800421b10f:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  800421b116:	00 00 00 00 
  800421b11a:	48 8b 95 b8 fe ff ff 	mov    -0x148(%rbp),%rdx
  800421b121:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800421b124:	48 89 d6             	mov    %rdx,%rsi
  800421b127:	89 c7                	mov    %eax,%edi
  800421b129:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b130:	00 00 00 
  800421b133:	ff d0                	callq  *%rax
  800421b135:	c7 45 b4 02 48 00 00 	movl   $0x4802,-0x4c(%rbp)
  800421b13c:	c7 85 c0 fe ff ff ff 	movl   $0xffff,-0x140(%rbp)
  800421b143:	ff 00 00 
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421b146:	8b 95 c0 fe ff ff    	mov    -0x140(%rbp),%edx
  800421b14c:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800421b14f:	48 89 d6             	mov    %rdx,%rsi
  800421b152:	89 c7                	mov    %eax,%edi
  800421b154:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b15b:	00 00 00 
  800421b15e:	ff d0                	callq  *%rax
  800421b160:	c7 45 b0 00 48 00 00 	movl   $0x4800,-0x50(%rbp)
  800421b167:	c7 85 c4 fe ff ff ff 	movl   $0xffff,-0x13c(%rbp)
  800421b16e:	ff 00 00 
  800421b171:	8b 95 c4 fe ff ff    	mov    -0x13c(%rbp),%edx
  800421b177:	8b 45 b0             	mov    -0x50(%rbp),%eax
  800421b17a:	48 89 d6             	mov    %rdx,%rsi
  800421b17d:	89 c7                	mov    %eax,%edi
  800421b17f:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b186:	00 00 00 
  800421b189:	ff d0                	callq  *%rax
  800421b18b:	c7 45 ac 04 48 00 00 	movl   $0x4804,-0x54(%rbp)
  800421b192:	c7 85 c8 fe ff ff ff 	movl   $0xffff,-0x138(%rbp)
  800421b199:	ff 00 00 
  800421b19c:	8b 95 c8 fe ff ff    	mov    -0x138(%rbp),%edx
  800421b1a2:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800421b1a5:	48 89 d6             	mov    %rdx,%rsi
  800421b1a8:	89 c7                	mov    %eax,%edi
  800421b1aa:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b1b1:	00 00 00 
  800421b1b4:	ff d0                	callq  *%rax
  800421b1b6:	c7 45 a8 06 48 00 00 	movl   $0x4806,-0x58(%rbp)
  800421b1bd:	c7 85 cc fe ff ff ff 	movl   $0xffff,-0x134(%rbp)
  800421b1c4:	ff 00 00 
  800421b1c7:	8b 95 cc fe ff ff    	mov    -0x134(%rbp),%edx
  800421b1cd:	8b 45 a8             	mov    -0x58(%rbp),%eax
  800421b1d0:	48 89 d6             	mov    %rdx,%rsi
  800421b1d3:	89 c7                	mov    %eax,%edi
  800421b1d5:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b1dc:	00 00 00 
  800421b1df:	ff d0                	callq  *%rax
  800421b1e1:	c7 45 a4 08 48 00 00 	movl   $0x4808,-0x5c(%rbp)
  800421b1e8:	c7 85 d0 fe ff ff ff 	movl   $0xffff,-0x130(%rbp)
  800421b1ef:	ff 00 00 
  800421b1f2:	8b 95 d0 fe ff ff    	mov    -0x130(%rbp),%edx
  800421b1f8:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800421b1fb:	48 89 d6             	mov    %rdx,%rsi
  800421b1fe:	89 c7                	mov    %eax,%edi
  800421b200:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b207:	00 00 00 
  800421b20a:	ff d0                	callq  *%rax
  800421b20c:	c7 45 a0 0a 48 00 00 	movl   $0x480a,-0x60(%rbp)
  800421b213:	c7 85 d4 fe ff ff ff 	movl   $0xffff,-0x12c(%rbp)
  800421b21a:	ff 00 00 
  800421b21d:	8b 95 d4 fe ff ff    	mov    -0x12c(%rbp),%edx
  800421b223:	8b 45 a0             	mov    -0x60(%rbp),%eax
  800421b226:	48 89 d6             	mov    %rdx,%rsi
  800421b229:	89 c7                	mov    %eax,%edi
  800421b22b:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b232:	00 00 00 
  800421b235:	ff d0                	callq  *%rax
  800421b237:	c7 45 9c 0c 48 00 00 	movl   $0x480c,-0x64(%rbp)
  800421b23e:	c7 85 d8 fe ff ff ff 	movl   $0xffff,-0x128(%rbp)
  800421b245:	ff 00 00 
  800421b248:	8b 95 d8 fe ff ff    	mov    -0x128(%rbp),%edx
  800421b24e:	8b 45 9c             	mov    -0x64(%rbp),%eax
  800421b251:	48 89 d6             	mov    %rdx,%rsi
  800421b254:	89 c7                	mov    %eax,%edi
  800421b256:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b25d:	00 00 00 
  800421b260:	ff d0                	callq  *%rax
  800421b262:	c7 45 98 0e 48 00 00 	movl   $0x480e,-0x68(%rbp)
  800421b269:	c7 85 dc fe ff ff ff 	movl   $0xfffff,-0x124(%rbp)
  800421b270:	ff 0f 00 
  800421b273:	8b 95 dc fe ff ff    	mov    -0x124(%rbp),%edx
  800421b279:	8b 45 98             	mov    -0x68(%rbp),%eax
  800421b27c:	48 89 d6             	mov    %rdx,%rsi
  800421b27f:	89 c7                	mov    %eax,%edi
  800421b281:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b288:	00 00 00 
  800421b28b:	ff d0                	callq  *%rax
  800421b28d:	c7 45 94 10 48 00 00 	movl   $0x4810,-0x6c(%rbp)
  800421b294:	c7 85 e0 fe ff ff 30 	movl   $0x30,-0x120(%rbp)
  800421b29b:	00 00 00 
  800421b29e:	8b 95 e0 fe ff ff    	mov    -0x120(%rbp),%edx
  800421b2a4:	8b 45 94             	mov    -0x6c(%rbp),%eax
  800421b2a7:	48 89 d6             	mov    %rdx,%rsi
  800421b2aa:	89 c7                	mov    %eax,%edi
  800421b2ac:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b2b3:	00 00 00 
  800421b2b6:	ff d0                	callq  *%rax
  800421b2b8:	c7 45 90 12 48 00 00 	movl   $0x4812,-0x70(%rbp)
  800421b2bf:	c7 85 e4 fe ff ff ff 	movl   $0x3ff,-0x11c(%rbp)
  800421b2c6:	03 00 00 
  800421b2c9:	8b 95 e4 fe ff ff    	mov    -0x11c(%rbp),%edx
  800421b2cf:	8b 45 90             	mov    -0x70(%rbp),%eax
  800421b2d2:	48 89 d6             	mov    %rdx,%rsi
  800421b2d5:	89 c7                	mov    %eax,%edi
  800421b2d7:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b2de:	00 00 00 
  800421b2e1:	ff d0                	callq  *%rax
  800421b2e3:	c7 45 8c 16 48 00 00 	movl   $0x4816,-0x74(%rbp)
  800421b2ea:	c7 85 e8 fe ff ff 93 	movl   $0x93,-0x118(%rbp)
  800421b2f1:	00 00 00 
  800421b2f4:	8b 95 e8 fe ff ff    	mov    -0x118(%rbp),%edx
  800421b2fa:	8b 45 8c             	mov    -0x74(%rbp),%eax
  800421b2fd:	48 89 d6             	mov    %rdx,%rsi
  800421b300:	89 c7                	mov    %eax,%edi
  800421b302:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b309:	00 00 00 
  800421b30c:	ff d0                	callq  *%rax
  800421b30e:	c7 45 88 14 48 00 00 	movl   $0x4814,-0x78(%rbp)
  800421b315:	c7 85 ec fe ff ff 93 	movl   $0x93,-0x114(%rbp)
  800421b31c:	00 00 00 
  800421b31f:	8b 95 ec fe ff ff    	mov    -0x114(%rbp),%edx
  800421b325:	8b 45 88             	mov    -0x78(%rbp),%eax
  800421b328:	48 89 d6             	mov    %rdx,%rsi
  800421b32b:	89 c7                	mov    %eax,%edi
  800421b32d:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b334:	00 00 00 
  800421b337:	ff d0                	callq  *%rax
  800421b339:	c7 45 84 18 48 00 00 	movl   $0x4818,-0x7c(%rbp)
  800421b340:	c7 85 f0 fe ff ff 93 	movl   $0x93,-0x110(%rbp)
  800421b347:	00 00 00 
  800421b34a:	8b 95 f0 fe ff ff    	mov    -0x110(%rbp),%edx
  800421b350:	8b 45 84             	mov    -0x7c(%rbp),%eax
  800421b353:	48 89 d6             	mov    %rdx,%rsi
  800421b356:	89 c7                	mov    %eax,%edi
  800421b358:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b35f:	00 00 00 
  800421b362:	ff d0                	callq  *%rax
  800421b364:	c7 45 80 1a 48 00 00 	movl   $0x481a,-0x80(%rbp)
  800421b36b:	c7 85 f4 fe ff ff 93 	movl   $0x93,-0x10c(%rbp)
  800421b372:	00 00 00 
  800421b375:	8b 95 f4 fe ff ff    	mov    -0x10c(%rbp),%edx
  800421b37b:	8b 45 80             	mov    -0x80(%rbp),%eax
  800421b37e:	48 89 d6             	mov    %rdx,%rsi
  800421b381:	89 c7                	mov    %eax,%edi
  800421b383:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b38a:	00 00 00 
  800421b38d:	ff d0                	callq  *%rax
  800421b38f:	c7 85 7c ff ff ff 1c 	movl   $0x481c,-0x84(%rbp)
  800421b396:	48 00 00 
  800421b399:	c7 85 f8 fe ff ff 93 	movl   $0x93,-0x108(%rbp)
  800421b3a0:	00 00 00 
  800421b3a3:	8b 95 f8 fe ff ff    	mov    -0x108(%rbp),%edx
  800421b3a9:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
  800421b3af:	48 89 d6             	mov    %rdx,%rsi
  800421b3b2:	89 c7                	mov    %eax,%edi
  800421b3b4:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b3bb:	00 00 00 
  800421b3be:	ff d0                	callq  *%rax
  800421b3c0:	c7 85 78 ff ff ff 1e 	movl   $0x481e,-0x88(%rbp)
  800421b3c7:	48 00 00 
  800421b3ca:	c7 85 fc fe ff ff 93 	movl   $0x93,-0x104(%rbp)
  800421b3d1:	00 00 00 
  800421b3d4:	8b 95 fc fe ff ff    	mov    -0x104(%rbp),%edx
  800421b3da:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
  800421b3e0:	48 89 d6             	mov    %rdx,%rsi
  800421b3e3:	89 c7                	mov    %eax,%edi
  800421b3e5:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b3ec:	00 00 00 
  800421b3ef:	ff d0                	callq  *%rax
  800421b3f1:	c7 85 74 ff ff ff 20 	movl   $0x4820,-0x8c(%rbp)
  800421b3f8:	48 00 00 
  800421b3fb:	c7 85 00 ff ff ff 82 	movl   $0x82,-0x100(%rbp)
  800421b402:	00 00 00 
  800421b405:	8b 95 00 ff ff ff    	mov    -0x100(%rbp),%edx
  800421b40b:	8b 85 74 ff ff ff    	mov    -0x8c(%rbp),%eax
  800421b411:	48 89 d6             	mov    %rdx,%rsi
  800421b414:	89 c7                	mov    %eax,%edi
  800421b416:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b41d:	00 00 00 
  800421b420:	ff d0                	callq  *%rax
  800421b422:	c7 85 70 ff ff ff 22 	movl   $0x4822,-0x90(%rbp)
  800421b429:	48 00 00 
  800421b42c:	c7 85 04 ff ff ff 8b 	movl   $0x8b,-0xfc(%rbp)
  800421b433:	00 00 00 
  800421b436:	8b 95 04 ff ff ff    	mov    -0xfc(%rbp),%edx
  800421b43c:	8b 85 70 ff ff ff    	mov    -0x90(%rbp),%eax
  800421b442:	48 89 d6             	mov    %rdx,%rsi
  800421b445:	89 c7                	mov    %eax,%edi
  800421b447:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b44e:	00 00 00 
  800421b451:	ff d0                	callq  *%rax
  800421b453:	c7 85 6c ff ff ff 26 	movl   $0x4826,-0x94(%rbp)
  800421b45a:	48 00 00 
  800421b45d:	c7 85 08 ff ff ff 00 	movl   $0x0,-0xf8(%rbp)
  800421b464:	00 00 00 
  800421b467:	8b 95 08 ff ff ff    	mov    -0xf8(%rbp),%edx
  800421b46d:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
  800421b473:	48 89 d6             	mov    %rdx,%rsi
  800421b476:	89 c7                	mov    %eax,%edi
  800421b478:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b47f:	00 00 00 
  800421b482:	ff d0                	callq  *%rax
  800421b484:	c7 85 68 ff ff ff 24 	movl   $0x4824,-0x98(%rbp)
  800421b48b:	48 00 00 
  800421b48e:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%rbp)
  800421b495:	00 00 00 
  800421b498:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  800421b49e:	8b 85 68 ff ff ff    	mov    -0x98(%rbp),%eax
  800421b4a4:	48 89 d6             	mov    %rdx,%rsi
  800421b4a7:	89 c7                	mov    %eax,%edi
  800421b4a9:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b4b0:	00 00 00 
  800421b4b3:	ff d0                	callq  *%rax
  800421b4b5:	c7 85 64 ff ff ff 02 	movl   $0x6802,-0x9c(%rbp)
  800421b4bc:	68 00 00 
  800421b4bf:	48 c7 85 10 ff ff ff 	movq   $0x0,-0xf0(%rbp)
  800421b4c6:	00 00 00 00 
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421b4ca:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  800421b4d1:	8b 85 64 ff ff ff    	mov    -0x9c(%rbp),%eax
  800421b4d7:	48 89 d6             	mov    %rdx,%rsi
  800421b4da:	89 c7                	mov    %eax,%edi
  800421b4dc:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b4e3:	00 00 00 
  800421b4e6:	ff d0                	callq  *%rax
  800421b4e8:	c7 85 60 ff ff ff 00 	movl   $0x6800,-0xa0(%rbp)
  800421b4ef:	68 00 00 
  800421b4f2:	48 c7 85 18 ff ff ff 	movq   $0x20,-0xe8(%rbp)
  800421b4f9:	20 00 00 00 
  800421b4fd:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800421b504:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
  800421b50a:	48 89 d6             	mov    %rdx,%rsi
  800421b50d:	89 c7                	mov    %eax,%edi
  800421b50f:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b516:	00 00 00 
  800421b519:	ff d0                	callq  *%rax
  800421b51b:	c7 85 5c ff ff ff 04 	movl   $0x6804,-0xa4(%rbp)
  800421b522:	68 00 00 
  800421b525:	48 c7 85 20 ff ff ff 	movq   $0x2000,-0xe0(%rbp)
  800421b52c:	00 20 00 00 
  800421b530:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
  800421b537:	8b 85 5c ff ff ff    	mov    -0xa4(%rbp),%eax
  800421b53d:	48 89 d6             	mov    %rdx,%rsi
  800421b540:	89 c7                	mov    %eax,%edi
  800421b542:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b549:	00 00 00 
  800421b54c:	ff d0                	callq  *%rax
  800421b54e:	c7 85 58 ff ff ff 00 	movl   $0x2800,-0xa8(%rbp)
  800421b555:	28 00 00 
  800421b558:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421b55d:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  800421b564:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  800421b56b:	8b 85 58 ff ff ff    	mov    -0xa8(%rbp),%eax
  800421b571:	48 89 d6             	mov    %rdx,%rsi
  800421b574:	89 c7                	mov    %eax,%edi
  800421b576:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b57d:	00 00 00 
  800421b580:	ff d0                	callq  *%rax
  800421b582:	c7 85 54 ff ff ff 01 	movl   $0x2801,-0xac(%rbp)
  800421b589:	28 00 00 
  800421b58c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421b591:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  800421b598:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
  800421b59f:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
  800421b5a5:	48 89 d6             	mov    %rdx,%rsi
  800421b5a8:	89 c7                	mov    %eax,%edi
  800421b5aa:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b5b1:	00 00 00 
  800421b5b4:	ff d0                	callq  *%rax
  800421b5b6:	c7 85 50 ff ff ff 1a 	movl   $0x681a,-0xb0(%rbp)
  800421b5bd:	68 00 00 
  800421b5c0:	48 c7 85 38 ff ff ff 	movq   $0x0,-0xc8(%rbp)
  800421b5c7:	00 00 00 00 
  800421b5cb:	48 8b 95 38 ff ff ff 	mov    -0xc8(%rbp),%rdx
  800421b5d2:	8b 85 50 ff ff ff    	mov    -0xb0(%rbp),%eax
  800421b5d8:	48 89 d6             	mov    %rdx,%rsi
  800421b5db:	89 c7                	mov    %eax,%edi
  800421b5dd:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b5e4:	00 00 00 
  800421b5e7:	ff d0                	callq  *%rax
  800421b5e9:	c7 85 4c ff ff ff 20 	movl   $0x6820,-0xb4(%rbp)
  800421b5f0:	68 00 00 
  800421b5f3:	48 c7 85 40 ff ff ff 	movq   $0x2,-0xc0(%rbp)
  800421b5fa:	02 00 00 00 
  800421b5fe:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
  800421b605:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
  800421b60b:	48 89 d6             	mov    %rdx,%rsi
  800421b60e:	89 c7                	mov    %eax,%edi
  800421b610:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b617:	00 00 00 
  800421b61a:	ff d0                	callq  *%rax
	vmcs_write64( VMCS_64BIT_GUEST_LINK_POINTER, 0xffffffff );
	vmcs_write64( VMCS_64BIT_GUEST_LINK_POINTER_HI, 0xffffffff ); 
	vmcs_write64( VMCS_GUEST_DR7, 0x0 );
	vmcs_write64( VMCS_GUEST_RFLAGS, 0x2 );

}
  800421b61c:	90                   	nop
  800421b61d:	c9                   	leaveq 
  800421b61e:	c3                   	retq   

000000800421b61f <vmx_read_capability_msr>:

void vmx_read_capability_msr( uint32_t msr, uint32_t* hi, uint32_t* lo ) {
  800421b61f:	55                   	push   %rbp
  800421b620:	48 89 e5             	mov    %rsp,%rbp
  800421b623:	48 83 ec 38          	sub    $0x38,%rsp
  800421b627:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800421b62a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421b62e:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800421b632:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421b635:	89 45 f4             	mov    %eax,-0xc(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421b638:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421b63b:	89 c1                	mov    %eax,%ecx
  800421b63d:	0f 32                	rdmsr  
  800421b63f:	89 55 f0             	mov    %edx,-0x10(%rbp)
  800421b642:	89 45 ec             	mov    %eax,-0x14(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421b645:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800421b64c:	00 
	ret = edx;
  800421b64d:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800421b650:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	ret = ret << 32;
  800421b654:	48 c1 65 e0 20       	shlq   $0x20,-0x20(%rbp)
	ret |= eax;
  800421b659:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421b65c:	48 09 45 e0          	or     %rax,-0x20(%rbp)

	return ret;
  800421b660:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
	uint64_t msr_val = read_msr( msr );
  800421b664:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	*hi = (uint32_t)( msr_val >> 32 );
  800421b668:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421b66c:	48 c1 e8 20          	shr    $0x20,%rax
  800421b670:	89 c2                	mov    %eax,%edx
  800421b672:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421b676:	89 10                	mov    %edx,(%rax)
	*lo = (uint32_t)( msr_val );
  800421b678:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421b67c:	89 c2                	mov    %eax,%edx
  800421b67e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421b682:	89 10                	mov    %edx,(%rax)
}
  800421b684:	90                   	nop
  800421b685:	c9                   	leaveq 
  800421b686:	c3                   	retq   

000000800421b687 <vmcs_ctls_init>:

static void 
vmcs_ctls_init( struct Env* e ) {
  800421b687:	55                   	push   %rbp
  800421b688:	48 89 e5             	mov    %rsp,%rbp
  800421b68b:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800421b692:	48 89 bd f8 fe ff ff 	mov    %rdi,-0x108(%rbp)
	// Set pin based vm exec controls.
	uint32_t pinbased_ctls_or, pinbased_ctls_and;
	vmx_read_capability_msr( IA32_VMX_PINBASED_CTLS, 
  800421b699:	48 8d 95 2c ff ff ff 	lea    -0xd4(%rbp),%rdx
  800421b6a0:	48 8d 85 28 ff ff ff 	lea    -0xd8(%rbp),%rax
  800421b6a7:	48 89 c6             	mov    %rax,%rsi
  800421b6aa:	bf 81 04 00 00       	mov    $0x481,%edi
  800421b6af:	48 b8 1f b6 21 04 80 	movabs $0x800421b61f,%rax
  800421b6b6:	00 00 00 
  800421b6b9:	ff d0                	callq  *%rax
				 &pinbased_ctls_and, &pinbased_ctls_or );

	//enable the guest external interrupt exit    
	pinbased_ctls_or |= VMCS_PIN_BASED_VMEXEC_CTL_EXINTEXIT;
  800421b6bb:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
  800421b6c1:	83 c8 01             	or     $0x1,%eax
  800421b6c4:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
	vmcs_write32( VMCS_32BIT_CONTROL_PIN_BASED_EXEC_CONTROLS, 
  800421b6ca:	8b 95 2c ff ff ff    	mov    -0xd4(%rbp),%edx
  800421b6d0:	8b 85 28 ff ff ff    	mov    -0xd8(%rbp),%eax
  800421b6d6:	21 d0                	and    %edx,%eax
  800421b6d8:	c7 45 8c 00 40 00 00 	movl   $0x4000,-0x74(%rbp)
  800421b6df:	89 45 88             	mov    %eax,-0x78(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421b6e2:	8b 55 88             	mov    -0x78(%rbp),%edx
  800421b6e5:	8b 45 8c             	mov    -0x74(%rbp),%eax
  800421b6e8:	48 89 d6             	mov    %rdx,%rsi
  800421b6eb:	89 c7                	mov    %eax,%edi
  800421b6ed:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b6f4:	00 00 00 
  800421b6f7:	ff d0                	callq  *%rax
		      pinbased_ctls_or & pinbased_ctls_and );

	// Set proc-based controls.
	uint32_t procbased_ctls_or, procbased_ctls_and;
	vmx_read_capability_msr( IA32_VMX_PROCBASED_CTLS, 
  800421b6f9:	48 8d 95 24 ff ff ff 	lea    -0xdc(%rbp),%rdx
  800421b700:	48 8d 85 20 ff ff ff 	lea    -0xe0(%rbp),%rax
  800421b707:	48 89 c6             	mov    %rax,%rsi
  800421b70a:	bf 82 04 00 00       	mov    $0x482,%edi
  800421b70f:	48 b8 1f b6 21 04 80 	movabs $0x800421b61f,%rax
  800421b716:	00 00 00 
  800421b719:	ff d0                	callq  *%rax
				 &procbased_ctls_and, &procbased_ctls_or );
	// Make sure there are secondary controls.
	assert( BIT( procbased_ctls_and, 31 ) == 0x1 ); 
  800421b71b:	8b 85 20 ff ff ff    	mov    -0xe0(%rbp),%eax
  800421b721:	c1 e8 1f             	shr    $0x1f,%eax
  800421b724:	83 f8 01             	cmp    $0x1,%eax
  800421b727:	74 35                	je     800421b75e <vmcs_ctls_init+0xd7>
  800421b729:	48 b9 50 20 22 04 80 	movabs $0x8004222050,%rcx
  800421b730:	00 00 00 
  800421b733:	48 ba e8 1f 22 04 80 	movabs $0x8004221fe8,%rdx
  800421b73a:	00 00 00 
  800421b73d:	be 4f 01 00 00       	mov    $0x14f,%esi
  800421b742:	48 bf fd 1f 22 04 80 	movabs $0x8004221ffd,%rdi
  800421b749:	00 00 00 
  800421b74c:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b751:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421b758:	00 00 00 
  800421b75b:	41 ff d0             	callq  *%r8
   
	procbased_ctls_or |= VMCS_PROC_BASED_VMEXEC_CTL_ACTIVESECCTL; 
  800421b75e:	8b 85 24 ff ff ff    	mov    -0xdc(%rbp),%eax
  800421b764:	0d 00 00 00 80       	or     $0x80000000,%eax
  800421b769:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
	procbased_ctls_or |= VMCS_PROC_BASED_VMEXEC_CTL_HLTEXIT;
  800421b76f:	8b 85 24 ff ff ff    	mov    -0xdc(%rbp),%eax
  800421b775:	0c 80                	or     $0x80,%al
  800421b777:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
	procbased_ctls_or |= VMCS_PROC_BASED_VMEXEC_CTL_USEIOBMP;
  800421b77d:	8b 85 24 ff ff ff    	mov    -0xdc(%rbp),%eax
  800421b783:	0d 00 00 00 02       	or     $0x2000000,%eax
  800421b788:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
	/* CR3 accesses and invlpg don't need to cause VM Exits when EPT
	   enabled */
	procbased_ctls_or &= ~( VMCS_PROC_BASED_VMEXEC_CTL_CR3LOADEXIT |
  800421b78e:	8b 85 24 ff ff ff    	mov    -0xdc(%rbp),%eax
  800421b794:	25 ff 7d fe ff       	and    $0xfffe7dff,%eax
  800421b799:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
				VMCS_PROC_BASED_VMEXEC_CTL_CR3STOREXIT | 
				VMCS_PROC_BASED_VMEXEC_CTL_INVLPGEXIT );

	vmcs_write32( VMCS_32BIT_CONTROL_PROCESSOR_BASED_VMEXEC_CONTROLS, 
  800421b79f:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  800421b7a5:	8b 85 20 ff ff ff    	mov    -0xe0(%rbp),%eax
  800421b7ab:	21 d0                	and    %edx,%eax
  800421b7ad:	c7 45 f4 02 40 00 00 	movl   $0x4002,-0xc(%rbp)
  800421b7b4:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
  800421b7ba:	8b 95 7c ff ff ff    	mov    -0x84(%rbp),%edx
  800421b7c0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421b7c3:	48 89 d6             	mov    %rdx,%rsi
  800421b7c6:	89 c7                	mov    %eax,%edi
  800421b7c8:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b7cf:	00 00 00 
  800421b7d2:	ff d0                	callq  *%rax
		      procbased_ctls_or & procbased_ctls_and );

	// Set Proc based secondary controls.
	uint32_t procbased_ctls2_or, procbased_ctls2_and;
	vmx_read_capability_msr( IA32_VMX_PROCBASED_CTLS2, 
  800421b7d4:	48 8d 95 1c ff ff ff 	lea    -0xe4(%rbp),%rdx
  800421b7db:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800421b7e2:	48 89 c6             	mov    %rax,%rsi
  800421b7e5:	bf 8b 04 00 00       	mov    $0x48b,%edi
  800421b7ea:	48 b8 1f b6 21 04 80 	movabs $0x800421b61f,%rax
  800421b7f1:	00 00 00 
  800421b7f4:	ff d0                	callq  *%rax
				 &procbased_ctls2_and, &procbased_ctls2_or );
    
	// Enable EPT.
	procbased_ctls2_or |= VMCS_SECONDARY_VMEXEC_CTL_ENABLE_EPT;
  800421b7f6:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
  800421b7fc:	83 c8 02             	or     $0x2,%eax
  800421b7ff:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
	procbased_ctls2_or |= VMCS_SECONDARY_VMEXEC_CTL_UNRESTRICTED_GUEST;
  800421b805:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
  800421b80b:	0c 80                	or     $0x80,%al
  800421b80d:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
	vmcs_write32( VMCS_32BIT_CONTROL_SECONDARY_VMEXEC_CONTROLS, 
  800421b813:	8b 95 1c ff ff ff    	mov    -0xe4(%rbp),%edx
  800421b819:	8b 85 18 ff ff ff    	mov    -0xe8(%rbp),%eax
  800421b81f:	21 d0                	and    %edx,%eax
  800421b821:	c7 45 f0 1e 40 00 00 	movl   $0x401e,-0x10(%rbp)
  800421b828:	89 45 80             	mov    %eax,-0x80(%rbp)
  800421b82b:	8b 55 80             	mov    -0x80(%rbp),%edx
  800421b82e:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800421b831:	48 89 d6             	mov    %rdx,%rsi
  800421b834:	89 c7                	mov    %eax,%edi
  800421b836:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b83d:	00 00 00 
  800421b840:	ff d0                	callq  *%rax
		      procbased_ctls2_or & procbased_ctls2_and );

	// Set VM exit controls.
	uint32_t exit_ctls_or, exit_ctls_and;
	vmx_read_capability_msr( IA32_VMX_EXIT_CTLS, 
  800421b842:	48 8d 95 14 ff ff ff 	lea    -0xec(%rbp),%rdx
  800421b849:	48 8d 85 10 ff ff ff 	lea    -0xf0(%rbp),%rax
  800421b850:	48 89 c6             	mov    %rax,%rsi
  800421b853:	bf 83 04 00 00       	mov    $0x483,%edi
  800421b858:	48 b8 1f b6 21 04 80 	movabs $0x800421b61f,%rax
  800421b85f:	00 00 00 
  800421b862:	ff d0                	callq  *%rax
				 &exit_ctls_and, &exit_ctls_or );

	exit_ctls_or |= VMCS_VMEXIT_HOST_ADDR_SIZE;
  800421b864:	8b 85 14 ff ff ff    	mov    -0xec(%rbp),%eax
  800421b86a:	80 cc 02             	or     $0x2,%ah
  800421b86d:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
	exit_ctls_or |= VMCS_VMEXIT_GUEST_ACK_INTR_ON_EXIT;	
  800421b873:	8b 85 14 ff ff ff    	mov    -0xec(%rbp),%eax
  800421b879:	80 cc 80             	or     $0x80,%ah
  800421b87c:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
	vmcs_write32( VMCS_32BIT_CONTROL_VMEXIT_CONTROLS, 
  800421b882:	8b 95 14 ff ff ff    	mov    -0xec(%rbp),%edx
  800421b888:	8b 85 10 ff ff ff    	mov    -0xf0(%rbp),%eax
  800421b88e:	21 d0                	and    %edx,%eax
  800421b890:	c7 45 fc 0c 40 00 00 	movl   $0x400c,-0x4(%rbp)
  800421b897:	89 45 84             	mov    %eax,-0x7c(%rbp)
  800421b89a:	8b 55 84             	mov    -0x7c(%rbp),%edx
  800421b89d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421b8a0:	48 89 d6             	mov    %rdx,%rsi
  800421b8a3:	89 c7                	mov    %eax,%edi
  800421b8a5:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b8ac:	00 00 00 
  800421b8af:	ff d0                	callq  *%rax
		      exit_ctls_or & exit_ctls_and );

	vmcs_write64( VMCS_64BIT_CONTROL_VMEXIT_MSR_STORE_ADDR,
		      PADDR(e->env_vmxinfo.msr_guest_area));
  800421b8b1:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421b8b8:	48 8b 80 58 01 00 00 	mov    0x158(%rax),%rax
  800421b8bf:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800421b8c3:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421b8ca:	00 00 00 
  800421b8cd:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800421b8d1:	77 32                	ja     800421b905 <vmcs_ctls_init+0x27e>
  800421b8d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421b8d7:	48 89 c1             	mov    %rax,%rcx
  800421b8da:	48 ba 78 20 22 04 80 	movabs $0x8004222078,%rdx
  800421b8e1:	00 00 00 
  800421b8e4:	be 73 01 00 00       	mov    $0x173,%esi
  800421b8e9:	48 bf fd 1f 22 04 80 	movabs $0x8004221ffd,%rdi
  800421b8f0:	00 00 00 
  800421b8f3:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b8f8:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421b8ff:	00 00 00 
  800421b902:	41 ff d0             	callq  *%r8
  800421b905:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421b90c:	ff ff ff 
  800421b90f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421b913:	48 01 d0             	add    %rdx,%rax
  800421b916:	c7 45 e0 06 20 00 00 	movl   $0x2006,-0x20(%rbp)
  800421b91d:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421b924:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800421b92b:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421b92e:	48 89 d6             	mov    %rdx,%rsi
  800421b931:	89 c7                	mov    %eax,%edi
  800421b933:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b93a:	00 00 00 
  800421b93d:	ff d0                	callq  *%rax
	vmcs_write32( VMCS_32BIT_CONTROL_VMEXIT_MSR_STORE_COUNT,
		      e->env_vmxinfo.msr_count);
  800421b93f:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421b946:	8b 80 48 01 00 00    	mov    0x148(%rax),%eax
  800421b94c:	c7 45 f8 0e 40 00 00 	movl   $0x400e,-0x8(%rbp)
  800421b953:	89 85 78 ff ff ff    	mov    %eax,-0x88(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421b959:	8b 95 78 ff ff ff    	mov    -0x88(%rbp),%edx
  800421b95f:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421b962:	48 89 d6             	mov    %rdx,%rsi
  800421b965:	89 c7                	mov    %eax,%edi
  800421b967:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b96e:	00 00 00 
  800421b971:	ff d0                	callq  *%rax
	vmcs_write64( VMCS_64BIT_CONTROL_VMEXIT_MSR_LOAD_ADDR,
		      PADDR(e->env_vmxinfo.msr_host_area));
  800421b973:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421b97a:	48 8b 80 50 01 00 00 	mov    0x150(%rax),%rax
  800421b981:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800421b985:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421b98c:	00 00 00 
  800421b98f:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  800421b993:	77 32                	ja     800421b9c7 <vmcs_ctls_init+0x340>
  800421b995:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421b999:	48 89 c1             	mov    %rax,%rcx
  800421b99c:	48 ba 78 20 22 04 80 	movabs $0x8004222078,%rdx
  800421b9a3:	00 00 00 
  800421b9a6:	be 77 01 00 00       	mov    $0x177,%esi
  800421b9ab:	48 bf fd 1f 22 04 80 	movabs $0x8004221ffd,%rdi
  800421b9b2:	00 00 00 
  800421b9b5:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b9ba:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421b9c1:	00 00 00 
  800421b9c4:	41 ff d0             	callq  *%r8
  800421b9c7:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421b9ce:	ff ff ff 
  800421b9d1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421b9d5:	48 01 d0             	add    %rdx,%rax
  800421b9d8:	c7 45 d0 08 20 00 00 	movl   $0x2008,-0x30(%rbp)
  800421b9df:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421b9e6:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421b9ed:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800421b9f0:	48 89 d6             	mov    %rdx,%rsi
  800421b9f3:	89 c7                	mov    %eax,%edi
  800421b9f5:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421b9fc:	00 00 00 
  800421b9ff:	ff d0                	callq  *%rax
	vmcs_write32( VMCS_32BIT_CONTROL_VMEXIT_MSR_LOAD_COUNT,
		      e->env_vmxinfo.msr_count);
  800421ba01:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421ba08:	8b 80 48 01 00 00    	mov    0x148(%rax),%eax
  800421ba0e:	c7 45 e4 10 40 00 00 	movl   $0x4010,-0x1c(%rbp)
  800421ba15:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421ba1b:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  800421ba21:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421ba24:	48 89 d6             	mov    %rdx,%rsi
  800421ba27:	89 c7                	mov    %eax,%edi
  800421ba29:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421ba30:	00 00 00 
  800421ba33:	ff d0                	callq  *%rax

	// Set VM entry controls.
	uint32_t entry_ctls_or, entry_ctls_and;
	vmx_read_capability_msr( IA32_VMX_ENTRY_CTLS, 
  800421ba35:	48 8d 95 0c ff ff ff 	lea    -0xf4(%rbp),%rdx
  800421ba3c:	48 8d 85 08 ff ff ff 	lea    -0xf8(%rbp),%rax
  800421ba43:	48 89 c6             	mov    %rax,%rsi
  800421ba46:	bf 84 04 00 00       	mov    $0x484,%edi
  800421ba4b:	48 b8 1f b6 21 04 80 	movabs $0x800421b61f,%rax
  800421ba52:	00 00 00 
  800421ba55:	ff d0                	callq  *%rax
				 &entry_ctls_and, &entry_ctls_or );

	vmcs_write64( VMCS_64BIT_CONTROL_VMENTRY_MSR_LOAD_ADDR,
		      PADDR(e->env_vmxinfo.msr_guest_area));
  800421ba57:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421ba5e:	48 8b 80 58 01 00 00 	mov    0x158(%rax),%rax
  800421ba65:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  800421ba69:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421ba70:	00 00 00 
  800421ba73:	48 39 45 c8          	cmp    %rax,-0x38(%rbp)
  800421ba77:	77 32                	ja     800421baab <vmcs_ctls_init+0x424>
  800421ba79:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ba7d:	48 89 c1             	mov    %rax,%rcx
  800421ba80:	48 ba 78 20 22 04 80 	movabs $0x8004222078,%rdx
  800421ba87:	00 00 00 
  800421ba8a:	be 81 01 00 00       	mov    $0x181,%esi
  800421ba8f:	48 bf fd 1f 22 04 80 	movabs $0x8004221ffd,%rdi
  800421ba96:	00 00 00 
  800421ba99:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ba9e:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421baa5:	00 00 00 
  800421baa8:	41 ff d0             	callq  *%r8
  800421baab:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421bab2:	ff ff ff 
  800421bab5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421bab9:	48 01 d0             	add    %rdx,%rax
  800421babc:	c7 45 c0 0a 20 00 00 	movl   $0x200a,-0x40(%rbp)
  800421bac3:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421baca:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
  800421bad1:	8b 45 c0             	mov    -0x40(%rbp),%eax
  800421bad4:	48 89 d6             	mov    %rdx,%rsi
  800421bad7:	89 c7                	mov    %eax,%edi
  800421bad9:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421bae0:	00 00 00 
  800421bae3:	ff d0                	callq  *%rax
	vmcs_write32( VMCS_32BIT_CONTROL_VMENTRY_MSR_LOAD_COUNT,
		      e->env_vmxinfo.msr_count);
  800421bae5:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421baec:	8b 80 48 01 00 00    	mov    0x148(%rax),%eax
  800421baf2:	c7 45 bc 14 40 00 00 	movl   $0x4014,-0x44(%rbp)
  800421baf9:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421baff:	8b 95 48 ff ff ff    	mov    -0xb8(%rbp),%edx
  800421bb05:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800421bb08:	48 89 d6             	mov    %rdx,%rsi
  800421bb0b:	89 c7                	mov    %eax,%edi
  800421bb0d:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421bb14:	00 00 00 
  800421bb17:	ff d0                	callq  *%rax

	vmcs_write32( VMCS_32BIT_CONTROL_VMENTRY_CONTROLS, 
  800421bb19:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  800421bb1f:	8b 85 08 ff ff ff    	mov    -0xf8(%rbp),%eax
  800421bb25:	21 d0                	and    %edx,%eax
  800421bb27:	c7 45 ac 12 40 00 00 	movl   $0x4012,-0x54(%rbp)
  800421bb2e:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
  800421bb34:	8b 95 4c ff ff ff    	mov    -0xb4(%rbp),%edx
  800421bb3a:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800421bb3d:	48 89 d6             	mov    %rdx,%rsi
  800421bb40:	89 c7                	mov    %eax,%edi
  800421bb42:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421bb49:	00 00 00 
  800421bb4c:	ff d0                	callq  *%rax
		      entry_ctls_or & entry_ctls_and );
    
	uint64_t ept_ptr = e->env_cr3 | ( ( EPT_LEVELS - 1 ) << 3 );
  800421bb4e:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421bb55:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  800421bb5c:	48 83 c8 18          	or     $0x18,%rax
  800421bb60:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	vmcs_write64( VMCS_64BIT_CONTROL_EPTPTR, ept_ptr 
  800421bb64:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421bb68:	48 83 c8 1e          	or     $0x1e,%rax
  800421bb6c:	c7 45 a8 1a 20 00 00 	movl   $0x201a,-0x58(%rbp)
  800421bb73:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421bb7a:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  800421bb81:	8b 45 a8             	mov    -0x58(%rbp),%eax
  800421bb84:	48 89 d6             	mov    %rdx,%rsi
  800421bb87:	89 c7                	mov    %eax,%edi
  800421bb89:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421bb90:	00 00 00 
  800421bb93:	ff d0                	callq  *%rax
        	    	| VMX_EPT_DEFAULT_MT
        	    	| (VMX_EPT_DEFAULT_GAW << VMX_EPT_GAW_EPTP_SHIFT) );

	vmcs_write32( VMCS_32BIT_CONTROL_EXCEPTION_BITMAP, 
  800421bb95:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421bb9c:	8b 80 30 01 00 00    	mov    0x130(%rax),%eax
  800421bba2:	c7 45 d4 04 40 00 00 	movl   $0x4004,-0x2c(%rbp)
  800421bba9:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421bbaf:	8b 95 5c ff ff ff    	mov    -0xa4(%rbp),%edx
  800421bbb5:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421bbb8:	48 89 d6             	mov    %rdx,%rsi
  800421bbbb:	89 c7                	mov    %eax,%edi
  800421bbbd:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421bbc4:	00 00 00 
  800421bbc7:	ff d0                	callq  *%rax
		      e->env_vmxinfo.exception_bmap);
	vmcs_write64( VMCS_64BIT_CONTROL_IO_BITMAP_A,
		      PADDR(e->env_vmxinfo.io_bmap_a));
  800421bbc9:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421bbd0:	48 8b 80 38 01 00 00 	mov    0x138(%rax),%rax
  800421bbd7:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  800421bbdb:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421bbe2:	00 00 00 
  800421bbe5:	48 39 45 a0          	cmp    %rax,-0x60(%rbp)
  800421bbe9:	77 32                	ja     800421bc1d <vmcs_ctls_init+0x596>
  800421bbeb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421bbef:	48 89 c1             	mov    %rax,%rcx
  800421bbf2:	48 ba 78 20 22 04 80 	movabs $0x8004222078,%rdx
  800421bbf9:	00 00 00 
  800421bbfc:	be 90 01 00 00       	mov    $0x190,%esi
  800421bc01:	48 bf fd 1f 22 04 80 	movabs $0x8004221ffd,%rdi
  800421bc08:	00 00 00 
  800421bc0b:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bc10:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421bc17:	00 00 00 
  800421bc1a:	41 ff d0             	callq  *%r8
  800421bc1d:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421bc24:	ff ff ff 
  800421bc27:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421bc2b:	48 01 d0             	add    %rdx,%rax
  800421bc2e:	c7 45 c4 00 20 00 00 	movl   $0x2000,-0x3c(%rbp)
  800421bc35:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421bc3c:	48 8b 95 38 ff ff ff 	mov    -0xc8(%rbp),%rdx
  800421bc43:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421bc46:	48 89 d6             	mov    %rdx,%rsi
  800421bc49:	89 c7                	mov    %eax,%edi
  800421bc4b:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421bc52:	00 00 00 
  800421bc55:	ff d0                	callq  *%rax
	vmcs_write64( VMCS_64BIT_CONTROL_IO_BITMAP_B,
		      PADDR(e->env_vmxinfo.io_bmap_b));
  800421bc57:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421bc5e:	48 8b 80 40 01 00 00 	mov    0x140(%rax),%rax
  800421bc65:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  800421bc69:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421bc70:	00 00 00 
  800421bc73:	48 39 45 90          	cmp    %rax,-0x70(%rbp)
  800421bc77:	77 32                	ja     800421bcab <vmcs_ctls_init+0x624>
  800421bc79:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421bc7d:	48 89 c1             	mov    %rax,%rcx
  800421bc80:	48 ba 78 20 22 04 80 	movabs $0x8004222078,%rdx
  800421bc87:	00 00 00 
  800421bc8a:	be 92 01 00 00       	mov    $0x192,%esi
  800421bc8f:	48 bf fd 1f 22 04 80 	movabs $0x8004221ffd,%rdi
  800421bc96:	00 00 00 
  800421bc99:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bc9e:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421bca5:	00 00 00 
  800421bca8:	41 ff d0             	callq  *%r8
  800421bcab:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421bcb2:	ff ff ff 
  800421bcb5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421bcb9:	48 01 d0             	add    %rdx,%rax
  800421bcbc:	c7 45 9c 02 20 00 00 	movl   $0x2002,-0x64(%rbp)
  800421bcc3:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  800421bcca:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
  800421bcd1:	8b 45 9c             	mov    -0x64(%rbp),%eax
  800421bcd4:	48 89 d6             	mov    %rdx,%rsi
  800421bcd7:	89 c7                	mov    %eax,%edi
  800421bcd9:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421bce0:	00 00 00 
  800421bce3:	ff d0                	callq  *%rax

}
  800421bce5:	90                   	nop
  800421bce6:	c9                   	leaveq 
  800421bce7:	c3                   	retq   

000000800421bce8 <vmcs_dump_cpu>:

void vmcs_dump_cpu() {
  800421bce8:	55                   	push   %rbp
  800421bce9:	48 89 e5             	mov    %rsp,%rbp
  800421bcec:	53                   	push   %rbx
  800421bced:	48 83 ec 28          	sub    $0x28,%rsp
	uint64_t flags = vmcs_readl(VMCS_GUEST_RFLAGS);
  800421bcf1:	bf 20 68 00 00       	mov    $0x6820,%edi
  800421bcf6:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421bcfd:	00 00 00 
  800421bd00:	ff d0                	callq  *%rax
  800421bd02:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// TODO: print all the regs.
	cprintf( "vmx: --- Begin VCPU Dump ---\n");
  800421bd06:	48 bf 9c 20 22 04 80 	movabs $0x800422209c,%rdi
  800421bd0d:	00 00 00 
  800421bd10:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bd15:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421bd1c:	00 00 00 
  800421bd1f:	ff d2                	callq  *%rdx
  800421bd21:	c7 45 e4 1c 68 00 00 	movl   $0x681c,-0x1c(%rbp)
	return vmcs_readl(field);
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421bd28:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421bd2b:	89 c7                	mov    %eax,%edi
  800421bd2d:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421bd34:	00 00 00 
  800421bd37:	ff d0                	callq  *%rax
  800421bd39:	48 89 c3             	mov    %rax,%rbx
  800421bd3c:	c7 45 e0 1e 68 00 00 	movl   $0x681e,-0x20(%rbp)
  800421bd43:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421bd46:	89 c7                	mov    %eax,%edi
  800421bd48:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421bd4f:	00 00 00 
  800421bd52:	ff d0                	callq  *%rax
  800421bd54:	48 89 c6             	mov    %rax,%rsi
	cprintf( "vmx: RIP 0x%016llx RSP 0x%016llx RFLAGS 0x%016llx\n",
  800421bd57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421bd5b:	48 89 c1             	mov    %rax,%rcx
  800421bd5e:	48 89 da             	mov    %rbx,%rdx
  800421bd61:	48 bf c0 20 22 04 80 	movabs $0x80042220c0,%rdi
  800421bd68:	00 00 00 
  800421bd6b:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bd70:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421bd77:	00 00 00 
  800421bd7a:	41 ff d0             	callq  *%r8
  800421bd7d:	c7 45 dc 02 68 00 00 	movl   $0x6802,-0x24(%rbp)
  800421bd84:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421bd87:	89 c7                	mov    %eax,%edi
  800421bd89:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421bd90:	00 00 00 
  800421bd93:	ff d0                	callq  *%rax
  800421bd95:	48 89 c3             	mov    %rax,%rbx
  800421bd98:	c7 45 d8 00 68 00 00 	movl   $0x6800,-0x28(%rbp)
  800421bd9f:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421bda2:	89 c7                	mov    %eax,%edi
  800421bda4:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421bdab:	00 00 00 
  800421bdae:	ff d0                	callq  *%rax
		 vmcs_read64( VMCS_GUEST_RIP ) , vmcs_read64( VMCS_GUEST_RSP ), flags);
	cprintf( "vmx: CR0 0x%016llx CR3 0x%016llx\n",
  800421bdb0:	48 89 da             	mov    %rbx,%rdx
  800421bdb3:	48 89 c6             	mov    %rax,%rsi
  800421bdb6:	48 bf f8 20 22 04 80 	movabs $0x80042220f8,%rdi
  800421bdbd:	00 00 00 
  800421bdc0:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bdc5:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421bdcc:	00 00 00 
  800421bdcf:	ff d1                	callq  *%rcx
  800421bdd1:	c7 45 d4 04 68 00 00 	movl   $0x6804,-0x2c(%rbp)
  800421bdd8:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421bddb:	89 c7                	mov    %eax,%edi
  800421bddd:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421bde4:	00 00 00 
  800421bde7:	ff d0                	callq  *%rax
		 vmcs_read64( VMCS_GUEST_CR0 ), vmcs_read64( VMCS_GUEST_CR3 ) );
	cprintf( "vmx: CR4 0x%016llx \n",
  800421bde9:	48 89 c6             	mov    %rax,%rsi
  800421bdec:	48 bf 1a 21 22 04 80 	movabs $0x800422211a,%rdi
  800421bdf3:	00 00 00 
  800421bdf6:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bdfb:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421be02:	00 00 00 
  800421be05:	ff d2                	callq  *%rdx
		 vmcs_read64( VMCS_GUEST_CR4 ) );

	cprintf( "vmx: --- End VCPU Dump ---\n");
  800421be07:	48 bf 2f 21 22 04 80 	movabs $0x800422212f,%rdi
  800421be0e:	00 00 00 
  800421be11:	b8 00 00 00 00       	mov    $0x0,%eax
  800421be16:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421be1d:	00 00 00 
  800421be20:	ff d2                	callq  *%rdx

}
  800421be22:	90                   	nop
  800421be23:	48 83 c4 28          	add    $0x28,%rsp
  800421be27:	5b                   	pop    %rbx
  800421be28:	5d                   	pop    %rbp
  800421be29:	c3                   	retq   

000000800421be2a <vmx_dump_sel>:

static void vmx_dump_sel(char *name, uint32_t sel)
{
  800421be2a:	55                   	push   %rbp
  800421be2b:	48 89 e5             	mov    %rsp,%rbp
  800421be2e:	41 55                	push   %r13
  800421be30:	41 54                	push   %r12
  800421be32:	53                   	push   %rbx
  800421be33:	48 83 ec 28          	sub    $0x28,%rsp
  800421be37:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421be3b:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	cprintf("%s sel=0x%04x, attr=0x%05x, limit=0x%08x, base=0x%016lx\n",
  800421be3e:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421be41:	05 06 60 00 00       	add    $0x6006,%eax
  800421be46:	89 c7                	mov    %eax,%edi
  800421be48:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421be4f:	00 00 00 
  800421be52:	ff d0                	callq  *%rax
  800421be54:	49 89 c4             	mov    %rax,%r12
  800421be57:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421be5a:	05 00 40 00 00       	add    $0x4000,%eax
  800421be5f:	89 45 dc             	mov    %eax,-0x24(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421be62:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421be65:	89 c7                	mov    %eax,%edi
  800421be67:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421be6e:	00 00 00 
  800421be71:	ff d0                	callq  *%rax
  800421be73:	41 89 c5             	mov    %eax,%r13d
  800421be76:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421be79:	05 14 40 00 00       	add    $0x4014,%eax
  800421be7e:	89 45 d8             	mov    %eax,-0x28(%rbp)
  800421be81:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421be84:	89 c7                	mov    %eax,%edi
  800421be86:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421be8d:	00 00 00 
  800421be90:	ff d0                	callq  *%rax
  800421be92:	89 c3                	mov    %eax,%ebx
  800421be94:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421be97:	89 45 d4             	mov    %eax,-0x2c(%rbp)
	return value;
}

static __inline uint16_t vmcs_read16(uint32_t field)
{
	return vmcs_readl(field);
  800421be9a:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421be9d:	89 c7                	mov    %eax,%edi
  800421be9f:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421bea6:	00 00 00 
  800421bea9:	ff d0                	callq  *%rax
  800421beab:	0f b7 d0             	movzwl %ax,%edx
  800421beae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421beb2:	4d 89 e1             	mov    %r12,%r9
  800421beb5:	45 89 e8             	mov    %r13d,%r8d
  800421beb8:	89 d9                	mov    %ebx,%ecx
  800421beba:	48 89 c6             	mov    %rax,%rsi
  800421bebd:	48 bf 50 21 22 04 80 	movabs $0x8004222150,%rdi
  800421bec4:	00 00 00 
  800421bec7:	b8 00 00 00 00       	mov    $0x0,%eax
  800421becc:	49 ba 09 9d 20 04 80 	movabs $0x8004209d09,%r10
  800421bed3:	00 00 00 
  800421bed6:	41 ff d2             	callq  *%r10
			name, vmcs_read16(sel),
			vmcs_read32(sel + VMCS_32BIT_GUEST_ES_ACCESS_RIGHTS - VMCS_16BIT_GUEST_ES_SELECTOR ),
			vmcs_read32(sel + VMCS_32BIT_GUEST_ES_LIMIT - VMCS_16BIT_GUEST_ES_SELECTOR),
			vmcs_readl(sel + VMCS_GUEST_ES_BASE - VMCS_16BIT_GUEST_ES_SELECTOR));
}
  800421bed9:	90                   	nop
  800421beda:	48 83 c4 28          	add    $0x28,%rsp
  800421bede:	5b                   	pop    %rbx
  800421bedf:	41 5c                	pop    %r12
  800421bee1:	41 5d                	pop    %r13
  800421bee3:	5d                   	pop    %rbp
  800421bee4:	c3                   	retq   

000000800421bee5 <vmx_dump_dtsel>:

static void vmx_dump_dtsel(char *name, uint32_t limit)
{
  800421bee5:	55                   	push   %rbp
  800421bee6:	48 89 e5             	mov    %rsp,%rbp
  800421bee9:	53                   	push   %rbx
  800421beea:	48 83 ec 28          	sub    $0x28,%rsp
  800421beee:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421bef2:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	cprintf("%slimit=0x%08x, base=0x%016lx\n",
  800421bef5:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421bef8:	05 06 20 00 00       	add    $0x2006,%eax
  800421befd:	89 c7                	mov    %eax,%edi
  800421beff:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421bf06:	00 00 00 
  800421bf09:	ff d0                	callq  *%rax
  800421bf0b:	48 89 c3             	mov    %rax,%rbx
  800421bf0e:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421bf11:	89 45 ec             	mov    %eax,-0x14(%rbp)
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421bf14:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421bf17:	89 c7                	mov    %eax,%edi
  800421bf19:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421bf20:	00 00 00 
  800421bf23:	ff d0                	callq  *%rax
  800421bf25:	89 c2                	mov    %eax,%edx
  800421bf27:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421bf2b:	48 89 d9             	mov    %rbx,%rcx
  800421bf2e:	48 89 c6             	mov    %rax,%rsi
  800421bf31:	48 bf 90 21 22 04 80 	movabs $0x8004222190,%rdi
  800421bf38:	00 00 00 
  800421bf3b:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bf40:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421bf47:	00 00 00 
  800421bf4a:	41 ff d0             	callq  *%r8
			name, vmcs_read32(limit),
			vmcs_readl(limit + VMCS_GUEST_GDTR_BASE - VMCS_32BIT_GUEST_GDTR_LIMIT));
}
  800421bf4d:	90                   	nop
  800421bf4e:	48 83 c4 28          	add    $0x28,%rsp
  800421bf52:	5b                   	pop    %rbx
  800421bf53:	5d                   	pop    %rbp
  800421bf54:	c3                   	retq   

000000800421bf55 <vmcs_dump_cpu_1>:

void vmcs_dump_cpu_1()
{
  800421bf55:	55                   	push   %rbp
  800421bf56:	48 89 e5             	mov    %rsp,%rbp
  800421bf59:	41 57                	push   %r15
  800421bf5b:	41 56                	push   %r14
  800421bf5d:	41 55                	push   %r13
  800421bf5f:	41 54                	push   %r12
  800421bf61:	53                   	push   %rbx
  800421bf62:	48 81 ec 38 01 00 00 	sub    $0x138,%rsp
  800421bf69:	c7 45 c4 12 40 00 00 	movl   $0x4012,-0x3c(%rbp)
  800421bf70:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421bf73:	89 c7                	mov    %eax,%edi
  800421bf75:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421bf7c:	00 00 00 
  800421bf7f:	ff d0                	callq  *%rax
	uint32_t vmentry_ctl = vmcs_read32(VMCS_32BIT_CONTROL_VMENTRY_CONTROLS);
  800421bf81:	89 45 c8             	mov    %eax,-0x38(%rbp)
  800421bf84:	c7 45 bc 0c 40 00 00 	movl   $0x400c,-0x44(%rbp)
  800421bf8b:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800421bf8e:	89 c7                	mov    %eax,%edi
  800421bf90:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421bf97:	00 00 00 
  800421bf9a:	ff d0                	callq  *%rax
	uint32_t vmexit_ctl = vmcs_read32(VMCS_32BIT_CONTROL_VMEXIT_CONTROLS);
  800421bf9c:	89 45 c0             	mov    %eax,-0x40(%rbp)
  800421bf9f:	c7 45 b4 02 40 00 00 	movl   $0x4002,-0x4c(%rbp)
  800421bfa6:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800421bfa9:	89 c7                	mov    %eax,%edi
  800421bfab:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421bfb2:	00 00 00 
  800421bfb5:	ff d0                	callq  *%rax
	uint32_t cpu_based_exec_ctrl = vmcs_read32(VMCS_32BIT_CONTROL_PROCESSOR_BASED_VMEXEC_CONTROLS);
  800421bfb7:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800421bfba:	c7 45 9c 00 40 00 00 	movl   $0x4000,-0x64(%rbp)
  800421bfc1:	8b 45 9c             	mov    -0x64(%rbp),%eax
  800421bfc4:	89 c7                	mov    %eax,%edi
  800421bfc6:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421bfcd:	00 00 00 
  800421bfd0:	ff d0                	callq  *%rax
	uint32_t pin_based_exec_ctrl = vmcs_read32(VMCS_32BIT_CONTROL_PIN_BASED_EXEC_CONTROLS);
  800421bfd2:	89 45 b0             	mov    %eax,-0x50(%rbp)
	uint32_t secondary_exec_control = 0;
  800421bfd5:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%rbp)
	unsigned long cr4 = vmcs_readl(VMCS_GUEST_CR4);
  800421bfdc:	bf 04 68 00 00       	mov    $0x6804,%edi
  800421bfe1:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421bfe8:	00 00 00 
  800421bfeb:	ff d0                	callq  *%rax
  800421bfed:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  800421bff1:	c7 45 8c 06 28 00 00 	movl   $0x2806,-0x74(%rbp)
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421bff8:	8b 45 8c             	mov    -0x74(%rbp),%eax
  800421bffb:	89 c7                	mov    %eax,%edi
  800421bffd:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c004:	00 00 00 
  800421c007:	ff d0                	callq  *%rax
	uint64_t efer = vmcs_read64(VMCS_64BIT_GUEST_IA32_EFER);
  800421c009:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  800421c00d:	c7 45 88 1e 40 00 00 	movl   $0x401e,-0x78(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421c014:	8b 45 88             	mov    -0x78(%rbp),%eax
  800421c017:	89 c7                	mov    %eax,%edi
  800421c019:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c020:	00 00 00 
  800421c023:	ff d0                	callq  *%rax
	int i, n;

	secondary_exec_control = vmcs_read32(VMCS_32BIT_CONTROL_SECONDARY_VMEXEC_CONTROLS);
  800421c025:	89 45 ac             	mov    %eax,-0x54(%rbp)

	cprintf("\n*** Guest State ***\n");
  800421c028:	48 bf af 21 22 04 80 	movabs $0x80042221af,%rdi
  800421c02f:	00 00 00 
  800421c032:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c037:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421c03e:	00 00 00 
  800421c041:	ff d2                	callq  *%rdx
	cprintf("CR0: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\n",
  800421c043:	bf 00 60 00 00       	mov    $0x6000,%edi
  800421c048:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c04f:	00 00 00 
  800421c052:	ff d0                	callq  *%rax
  800421c054:	49 89 c4             	mov    %rax,%r12
  800421c057:	bf 04 60 00 00       	mov    $0x6004,%edi
  800421c05c:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c063:	00 00 00 
  800421c066:	ff d0                	callq  *%rax
  800421c068:	48 89 c3             	mov    %rax,%rbx
  800421c06b:	bf 00 68 00 00       	mov    $0x6800,%edi
  800421c070:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c077:	00 00 00 
  800421c07a:	ff d0                	callq  *%rax
  800421c07c:	4c 89 e1             	mov    %r12,%rcx
  800421c07f:	48 89 da             	mov    %rbx,%rdx
  800421c082:	48 89 c6             	mov    %rax,%rsi
  800421c085:	48 bf c8 21 22 04 80 	movabs $0x80042221c8,%rdi
  800421c08c:	00 00 00 
  800421c08f:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c094:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421c09b:	00 00 00 
  800421c09e:	41 ff d0             	callq  *%r8
			vmcs_readl(VMCS_GUEST_CR0), vmcs_readl(VMCS_CONTROL_CR0_READ_SHADOW),
			vmcs_readl(VMCS_CONTROL_CR0_GUEST_HOST_MASK));
	cprintf("CR4: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\n",
  800421c0a1:	bf 02 60 00 00       	mov    $0x6002,%edi
  800421c0a6:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c0ad:	00 00 00 
  800421c0b0:	ff d0                	callq  *%rax
  800421c0b2:	48 89 c3             	mov    %rax,%rbx
  800421c0b5:	bf 06 60 00 00       	mov    $0x6006,%edi
  800421c0ba:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c0c1:	00 00 00 
  800421c0c4:	ff d0                	callq  *%rax
  800421c0c6:	48 89 c2             	mov    %rax,%rdx
  800421c0c9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421c0cd:	48 89 d9             	mov    %rbx,%rcx
  800421c0d0:	48 89 c6             	mov    %rax,%rsi
  800421c0d3:	48 bf 00 22 22 04 80 	movabs $0x8004222200,%rdi
  800421c0da:	00 00 00 
  800421c0dd:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c0e2:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421c0e9:	00 00 00 
  800421c0ec:	41 ff d0             	callq  *%r8
			cr4, vmcs_readl(VMCS_CONTROL_CR4_READ_SHADOW), vmcs_readl(VMCS_CONTROL_CR4_GUEST_HOST_MASK));
	cprintf("CR3 = 0x%016lx\n", vmcs_readl(VMCS_GUEST_CR3));
  800421c0ef:	bf 02 68 00 00       	mov    $0x6802,%edi
  800421c0f4:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c0fb:	00 00 00 
  800421c0fe:	ff d0                	callq  *%rax
  800421c100:	48 89 c6             	mov    %rax,%rsi
  800421c103:	48 bf 37 22 22 04 80 	movabs $0x8004222237,%rdi
  800421c10a:	00 00 00 
  800421c10d:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c112:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421c119:	00 00 00 
  800421c11c:	ff d2                	callq  *%rdx
	cprintf("RSP = 0x%016lx  RIP = 0x%016lx\n",
  800421c11e:	bf 1e 68 00 00       	mov    $0x681e,%edi
  800421c123:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c12a:	00 00 00 
  800421c12d:	ff d0                	callq  *%rax
  800421c12f:	48 89 c3             	mov    %rax,%rbx
  800421c132:	bf 1c 68 00 00       	mov    $0x681c,%edi
  800421c137:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c13e:	00 00 00 
  800421c141:	ff d0                	callq  *%rax
  800421c143:	48 89 da             	mov    %rbx,%rdx
  800421c146:	48 89 c6             	mov    %rax,%rsi
  800421c149:	48 bf 48 22 22 04 80 	movabs $0x8004222248,%rdi
  800421c150:	00 00 00 
  800421c153:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c158:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421c15f:	00 00 00 
  800421c162:	ff d1                	callq  *%rcx
			vmcs_readl(VMCS_GUEST_RSP), vmcs_readl(VMCS_GUEST_RIP));
	cprintf("RFLAGS=0x%08lx         DR7 = 0x%016lx\n",
  800421c164:	bf 1a 68 00 00       	mov    $0x681a,%edi
  800421c169:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c170:	00 00 00 
  800421c173:	ff d0                	callq  *%rax
  800421c175:	48 89 c3             	mov    %rax,%rbx
  800421c178:	bf 20 68 00 00       	mov    $0x6820,%edi
  800421c17d:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c184:	00 00 00 
  800421c187:	ff d0                	callq  *%rax
  800421c189:	48 89 da             	mov    %rbx,%rdx
  800421c18c:	48 89 c6             	mov    %rax,%rsi
  800421c18f:	48 bf 68 22 22 04 80 	movabs $0x8004222268,%rdi
  800421c196:	00 00 00 
  800421c199:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c19e:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421c1a5:	00 00 00 
  800421c1a8:	ff d1                	callq  *%rcx
			vmcs_readl(VMCS_GUEST_RFLAGS), vmcs_readl(VMCS_GUEST_DR7));
	cprintf("Sysenter RSP=%016lx CS:RIP=%04x:%016lx\n",
  800421c1aa:	bf 26 68 00 00       	mov    $0x6826,%edi
  800421c1af:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c1b6:	00 00 00 
  800421c1b9:	ff d0                	callq  *%rax
  800421c1bb:	49 89 c4             	mov    %rax,%r12
  800421c1be:	c7 85 b8 fe ff ff 2a 	movl   $0x482a,-0x148(%rbp)
  800421c1c5:	48 00 00 
  800421c1c8:	8b 85 b8 fe ff ff    	mov    -0x148(%rbp),%eax
  800421c1ce:	89 c7                	mov    %eax,%edi
  800421c1d0:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c1d7:	00 00 00 
  800421c1da:	ff d0                	callq  *%rax
  800421c1dc:	89 c3                	mov    %eax,%ebx
  800421c1de:	bf 24 68 00 00       	mov    $0x6824,%edi
  800421c1e3:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c1ea:	00 00 00 
  800421c1ed:	ff d0                	callq  *%rax
  800421c1ef:	4c 89 e1             	mov    %r12,%rcx
  800421c1f2:	89 da                	mov    %ebx,%edx
  800421c1f4:	48 89 c6             	mov    %rax,%rsi
  800421c1f7:	48 bf 90 22 22 04 80 	movabs $0x8004222290,%rdi
  800421c1fe:	00 00 00 
  800421c201:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c206:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421c20d:	00 00 00 
  800421c210:	41 ff d0             	callq  *%r8
			vmcs_readl(VMCS_GUEST_IA32_SYSENTER_ESP_MSR),
			vmcs_read32(VMCS_32BIT_GUEST_IA32_SYSENTER_CS_MSR), vmcs_readl(VMCS_GUEST_IA32_SYSENTER_EIP_MSR));
	vmx_dump_sel("CS:  ", VMCS_16BIT_GUEST_CS_SELECTOR);
  800421c213:	be 02 08 00 00       	mov    $0x802,%esi
  800421c218:	48 bf b8 22 22 04 80 	movabs $0x80042222b8,%rdi
  800421c21f:	00 00 00 
  800421c222:	48 b8 2a be 21 04 80 	movabs $0x800421be2a,%rax
  800421c229:	00 00 00 
  800421c22c:	ff d0                	callq  *%rax
	vmx_dump_sel("DS:  ", VMCS_16BIT_GUEST_DS_SELECTOR);
  800421c22e:	be 06 08 00 00       	mov    $0x806,%esi
  800421c233:	48 bf be 22 22 04 80 	movabs $0x80042222be,%rdi
  800421c23a:	00 00 00 
  800421c23d:	48 b8 2a be 21 04 80 	movabs $0x800421be2a,%rax
  800421c244:	00 00 00 
  800421c247:	ff d0                	callq  *%rax
	vmx_dump_sel("SS:  ", VMCS_16BIT_GUEST_SS_SELECTOR);
  800421c249:	be 04 08 00 00       	mov    $0x804,%esi
  800421c24e:	48 bf c4 22 22 04 80 	movabs $0x80042222c4,%rdi
  800421c255:	00 00 00 
  800421c258:	48 b8 2a be 21 04 80 	movabs $0x800421be2a,%rax
  800421c25f:	00 00 00 
  800421c262:	ff d0                	callq  *%rax
	vmx_dump_sel("ES:  ", VMCS_16BIT_GUEST_ES_SELECTOR);
  800421c264:	be 00 08 00 00       	mov    $0x800,%esi
  800421c269:	48 bf ca 22 22 04 80 	movabs $0x80042222ca,%rdi
  800421c270:	00 00 00 
  800421c273:	48 b8 2a be 21 04 80 	movabs $0x800421be2a,%rax
  800421c27a:	00 00 00 
  800421c27d:	ff d0                	callq  *%rax
	vmx_dump_sel("FS:  ", VMCS_16BIT_GUEST_FS_SELECTOR);
  800421c27f:	be 08 08 00 00       	mov    $0x808,%esi
  800421c284:	48 bf d0 22 22 04 80 	movabs $0x80042222d0,%rdi
  800421c28b:	00 00 00 
  800421c28e:	48 b8 2a be 21 04 80 	movabs $0x800421be2a,%rax
  800421c295:	00 00 00 
  800421c298:	ff d0                	callq  *%rax
	vmx_dump_sel("GS:  ", VMCS_16BIT_GUEST_GS_SELECTOR);
  800421c29a:	be 0a 08 00 00       	mov    $0x80a,%esi
  800421c29f:	48 bf d6 22 22 04 80 	movabs $0x80042222d6,%rdi
  800421c2a6:	00 00 00 
  800421c2a9:	48 b8 2a be 21 04 80 	movabs $0x800421be2a,%rax
  800421c2b0:	00 00 00 
  800421c2b3:	ff d0                	callq  *%rax
	vmx_dump_dtsel("GDTR:", VMCS_32BIT_GUEST_GDTR_LIMIT);
  800421c2b5:	be 10 48 00 00       	mov    $0x4810,%esi
  800421c2ba:	48 bf dc 22 22 04 80 	movabs $0x80042222dc,%rdi
  800421c2c1:	00 00 00 
  800421c2c4:	48 b8 e5 be 21 04 80 	movabs $0x800421bee5,%rax
  800421c2cb:	00 00 00 
  800421c2ce:	ff d0                	callq  *%rax
	vmx_dump_sel("LDTR:", VMCS_16BIT_GUEST_LDTR_SELECTOR);                                                                                                                               
  800421c2d0:	be 0c 08 00 00       	mov    $0x80c,%esi
  800421c2d5:	48 bf e2 22 22 04 80 	movabs $0x80042222e2,%rdi
  800421c2dc:	00 00 00 
  800421c2df:	48 b8 2a be 21 04 80 	movabs $0x800421be2a,%rax
  800421c2e6:	00 00 00 
  800421c2e9:	ff d0                	callq  *%rax
	vmx_dump_dtsel("IDTR:", VMCS_32BIT_GUEST_IDTR_LIMIT);
  800421c2eb:	be 12 48 00 00       	mov    $0x4812,%esi
  800421c2f0:	48 bf e8 22 22 04 80 	movabs $0x80042222e8,%rdi
  800421c2f7:	00 00 00 
  800421c2fa:	48 b8 e5 be 21 04 80 	movabs $0x800421bee5,%rax
  800421c301:	00 00 00 
  800421c304:	ff d0                	callq  *%rax
	vmx_dump_sel("TR:  ", VMCS_16BIT_GUEST_TR_SELECTOR);
  800421c306:	be 0e 08 00 00       	mov    $0x80e,%esi
  800421c30b:	48 bf ee 22 22 04 80 	movabs $0x80042222ee,%rdi
  800421c312:	00 00 00 
  800421c315:	48 b8 2a be 21 04 80 	movabs $0x800421be2a,%rax
  800421c31c:	00 00 00 
  800421c31f:	ff d0                	callq  *%rax
	if ((vmexit_ctl & (0x0040000 | 0x0010000)) ||
  800421c321:	8b 45 c0             	mov    -0x40(%rbp),%eax
  800421c324:	25 00 00 05 00       	and    $0x50000,%eax
  800421c329:	85 c0                	test   %eax,%eax
  800421c32b:	75 0c                	jne    800421c339 <vmcs_dump_cpu_1+0x3e4>
			(vmentry_ctl & (0x00004000 | 0x00008000)))
  800421c32d:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421c330:	25 00 c0 00 00       	and    $0xc000,%eax
	vmx_dump_sel("GS:  ", VMCS_16BIT_GUEST_GS_SELECTOR);
	vmx_dump_dtsel("GDTR:", VMCS_32BIT_GUEST_GDTR_LIMIT);
	vmx_dump_sel("LDTR:", VMCS_16BIT_GUEST_LDTR_SELECTOR);                                                                                                                               
	vmx_dump_dtsel("IDTR:", VMCS_32BIT_GUEST_IDTR_LIMIT);
	vmx_dump_sel("TR:  ", VMCS_16BIT_GUEST_TR_SELECTOR);
	if ((vmexit_ctl & (0x0040000 | 0x0010000)) ||
  800421c335:	85 c0                	test   %eax,%eax
  800421c337:	74 3d                	je     800421c376 <vmcs_dump_cpu_1+0x421>
  800421c339:	c7 45 cc 04 28 00 00 	movl   $0x2804,-0x34(%rbp)
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421c340:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421c343:	89 c7                	mov    %eax,%edi
  800421c345:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c34c:	00 00 00 
  800421c34f:	ff d0                	callq  *%rax
  800421c351:	48 89 c2             	mov    %rax,%rdx
			(vmentry_ctl & (0x00004000 | 0x00008000)))
		cprintf("EFER =     0x%016llx  PAT = 0x%016llx\n",
  800421c354:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421c358:	48 89 c6             	mov    %rax,%rsi
  800421c35b:	48 bf f8 22 22 04 80 	movabs $0x80042222f8,%rdi
  800421c362:	00 00 00 
  800421c365:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c36a:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421c371:	00 00 00 
  800421c374:	ff d1                	callq  *%rcx
				efer, vmcs_read64(VMCS_64BIT_GUEST_IA32_PAT));
	cprintf("DebugCtl = 0x%016llx  DebugExceptions = 0x%016lx\n",
  800421c376:	bf 22 68 00 00       	mov    $0x6822,%edi
  800421c37b:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c382:	00 00 00 
  800421c385:	ff d0                	callq  *%rax
  800421c387:	48 89 c3             	mov    %rax,%rbx
  800421c38a:	c7 45 84 02 28 00 00 	movl   $0x2802,-0x7c(%rbp)
  800421c391:	8b 45 84             	mov    -0x7c(%rbp),%eax
  800421c394:	89 c7                	mov    %eax,%edi
  800421c396:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c39d:	00 00 00 
  800421c3a0:	ff d0                	callq  *%rax
  800421c3a2:	48 89 da             	mov    %rbx,%rdx
  800421c3a5:	48 89 c6             	mov    %rax,%rsi
  800421c3a8:	48 bf 20 23 22 04 80 	movabs $0x8004222320,%rdi
  800421c3af:	00 00 00 
  800421c3b2:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c3b7:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421c3be:	00 00 00 
  800421c3c1:	ff d1                	callq  *%rcx
			vmcs_read64(VMCS_64BIT_GUEST_IA32_DEBUGCTL),
			vmcs_readl(VMCS_GUEST_PENDING_DBG_EXCEPTIONS));
	if(vmentry_ctl & 0x000100000)
  800421c3c3:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421c3c6:	25 00 00 10 00       	and    $0x100000,%eax
  800421c3cb:	85 c0                	test   %eax,%eax
  800421c3cd:	74 36                	je     800421c405 <vmcs_dump_cpu_1+0x4b0>
  800421c3cf:	c7 45 80 12 28 00 00 	movl   $0x2812,-0x80(%rbp)
  800421c3d6:	8b 45 80             	mov    -0x80(%rbp),%eax
  800421c3d9:	89 c7                	mov    %eax,%edi
  800421c3db:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c3e2:	00 00 00 
  800421c3e5:	ff d0                	callq  *%rax
		cprintf("BndCfgS = 0x%016llx\n", vmcs_read64(0x00002812));
  800421c3e7:	48 89 c6             	mov    %rax,%rsi
  800421c3ea:	48 bf 52 23 22 04 80 	movabs $0x8004222352,%rdi
  800421c3f1:	00 00 00 
  800421c3f4:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c3f9:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421c400:	00 00 00 
  800421c403:	ff d2                	callq  *%rdx
  800421c405:	c7 85 74 ff ff ff 26 	movl   $0x4826,-0x8c(%rbp)
  800421c40c:	48 00 00 
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421c40f:	8b 85 74 ff ff ff    	mov    -0x8c(%rbp),%eax
  800421c415:	89 c7                	mov    %eax,%edi
  800421c417:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c41e:	00 00 00 
  800421c421:	ff d0                	callq  *%rax
  800421c423:	89 c3                	mov    %eax,%ebx
  800421c425:	c7 85 7c ff ff ff 24 	movl   $0x4824,-0x84(%rbp)
  800421c42c:	48 00 00 
  800421c42f:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
  800421c435:	89 c7                	mov    %eax,%edi
  800421c437:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c43e:	00 00 00 
  800421c441:	ff d0                	callq  *%rax
	cprintf("Interruptibility = %08x  ActivityState = %08x\n",
  800421c443:	89 da                	mov    %ebx,%edx
  800421c445:	89 c6                	mov    %eax,%esi
  800421c447:	48 bf 68 23 22 04 80 	movabs $0x8004222368,%rdi
  800421c44e:	00 00 00 
  800421c451:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c456:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421c45d:	00 00 00 
  800421c460:	ff d1                	callq  *%rcx
			vmcs_read32(VMCS_32BIT_GUEST_INTERRUPTIBILITY_STATE),
			vmcs_read32(VMCS_32BIT_GUEST_ACTIVITY_STATE));
	if (secondary_exec_control & 0x00000200)
  800421c462:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800421c465:	25 00 02 00 00       	and    $0x200,%eax
  800421c46a:	85 c0                	test   %eax,%eax
  800421c46c:	74 3e                	je     800421c4ac <vmcs_dump_cpu_1+0x557>
  800421c46e:	c7 85 78 ff ff ff 10 	movl   $0x810,-0x88(%rbp)
  800421c475:	08 00 00 
	return value;
}

static __inline uint16_t vmcs_read16(uint32_t field)
{
	return vmcs_readl(field);
  800421c478:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
  800421c47e:	89 c7                	mov    %eax,%edi
  800421c480:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c487:	00 00 00 
  800421c48a:	ff d0                	callq  *%rax
		cprintf("InterruptStatus = %04x\n",
  800421c48c:	0f b7 c0             	movzwl %ax,%eax
  800421c48f:	89 c6                	mov    %eax,%esi
  800421c491:	48 bf 97 23 22 04 80 	movabs $0x8004222397,%rdi
  800421c498:	00 00 00 
  800421c49b:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c4a0:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421c4a7:	00 00 00 
  800421c4aa:	ff d2                	callq  *%rdx
				vmcs_read16(VMCS_16BIT_GUEST_INTERRUPT_STATUS));

	cprintf("\n*** Host State ***\n");
  800421c4ac:	48 bf af 23 22 04 80 	movabs $0x80042223af,%rdi
  800421c4b3:	00 00 00 
  800421c4b6:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c4bb:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421c4c2:	00 00 00 
  800421c4c5:	ff d2                	callq  *%rdx
	cprintf("RIP = 0x%016lx  RSP = 0x%016lx\n",
  800421c4c7:	bf 14 6c 00 00       	mov    $0x6c14,%edi
  800421c4cc:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c4d3:	00 00 00 
  800421c4d6:	ff d0                	callq  *%rax
  800421c4d8:	48 89 c3             	mov    %rax,%rbx
  800421c4db:	bf 16 6c 00 00       	mov    $0x6c16,%edi
  800421c4e0:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c4e7:	00 00 00 
  800421c4ea:	ff d0                	callq  *%rax
  800421c4ec:	48 89 da             	mov    %rbx,%rdx
  800421c4ef:	48 89 c6             	mov    %rax,%rsi
  800421c4f2:	48 bf c8 23 22 04 80 	movabs $0x80042223c8,%rdi
  800421c4f9:	00 00 00 
  800421c4fc:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c501:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421c508:	00 00 00 
  800421c50b:	ff d1                	callq  *%rcx
  800421c50d:	c7 85 68 ff ff ff 0c 	movl   $0xc0c,-0x98(%rbp)
  800421c514:	0c 00 00 
  800421c517:	8b 85 68 ff ff ff    	mov    -0x98(%rbp),%eax
  800421c51d:	89 c7                	mov    %eax,%edi
  800421c51f:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c526:	00 00 00 
  800421c529:	ff d0                	callq  *%rax
			vmcs_readl(VMCS_HOST_RIP), vmcs_readl(VMCS_HOST_RSP));
	cprintf("CS=%04x SS=%04x DS=%04x ES=%04x FS=%04x GS=%04x TR=%04x\n",
  800421c52b:	44 0f b7 f0          	movzwl %ax,%r14d
  800421c52f:	c7 85 64 ff ff ff 0a 	movl   $0xc0a,-0x9c(%rbp)
  800421c536:	0c 00 00 
  800421c539:	8b 85 64 ff ff ff    	mov    -0x9c(%rbp),%eax
  800421c53f:	89 c7                	mov    %eax,%edi
  800421c541:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c548:	00 00 00 
  800421c54b:	ff d0                	callq  *%rax
  800421c54d:	44 0f b7 e8          	movzwl %ax,%r13d
  800421c551:	c7 85 60 ff ff ff 08 	movl   $0xc08,-0xa0(%rbp)
  800421c558:	0c 00 00 
  800421c55b:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
  800421c561:	89 c7                	mov    %eax,%edi
  800421c563:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c56a:	00 00 00 
  800421c56d:	ff d0                	callq  *%rax
  800421c56f:	0f b7 c0             	movzwl %ax,%eax
  800421c572:	89 85 ac fe ff ff    	mov    %eax,-0x154(%rbp)
  800421c578:	c7 85 5c ff ff ff 00 	movl   $0xc00,-0xa4(%rbp)
  800421c57f:	0c 00 00 
  800421c582:	8b 85 5c ff ff ff    	mov    -0xa4(%rbp),%eax
  800421c588:	89 c7                	mov    %eax,%edi
  800421c58a:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c591:	00 00 00 
  800421c594:	ff d0                	callq  *%rax
  800421c596:	44 0f b7 f8          	movzwl %ax,%r15d
  800421c59a:	c7 85 58 ff ff ff 06 	movl   $0xc06,-0xa8(%rbp)
  800421c5a1:	0c 00 00 
  800421c5a4:	8b 85 58 ff ff ff    	mov    -0xa8(%rbp),%eax
  800421c5aa:	89 c7                	mov    %eax,%edi
  800421c5ac:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c5b3:	00 00 00 
  800421c5b6:	ff d0                	callq  *%rax
  800421c5b8:	44 0f b7 e0          	movzwl %ax,%r12d
  800421c5bc:	c7 85 54 ff ff ff 04 	movl   $0xc04,-0xac(%rbp)
  800421c5c3:	0c 00 00 
  800421c5c6:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
  800421c5cc:	89 c7                	mov    %eax,%edi
  800421c5ce:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c5d5:	00 00 00 
  800421c5d8:	ff d0                	callq  *%rax
  800421c5da:	0f b7 d8             	movzwl %ax,%ebx
  800421c5dd:	c7 85 50 ff ff ff 02 	movl   $0xc02,-0xb0(%rbp)
  800421c5e4:	0c 00 00 
  800421c5e7:	8b 85 50 ff ff ff    	mov    -0xb0(%rbp),%eax
  800421c5ed:	89 c7                	mov    %eax,%edi
  800421c5ef:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c5f6:	00 00 00 
  800421c5f9:	ff d0                	callq  *%rax
  800421c5fb:	0f b7 c0             	movzwl %ax,%eax
  800421c5fe:	41 56                	push   %r14
  800421c600:	41 55                	push   %r13
  800421c602:	44 8b 8d ac fe ff ff 	mov    -0x154(%rbp),%r9d
  800421c609:	45 89 f8             	mov    %r15d,%r8d
  800421c60c:	44 89 e1             	mov    %r12d,%ecx
  800421c60f:	89 da                	mov    %ebx,%edx
  800421c611:	89 c6                	mov    %eax,%esi
  800421c613:	48 bf e8 23 22 04 80 	movabs $0x80042223e8,%rdi
  800421c61a:	00 00 00 
  800421c61d:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c622:	49 ba 09 9d 20 04 80 	movabs $0x8004209d09,%r10
  800421c629:	00 00 00 
  800421c62c:	41 ff d2             	callq  *%r10
  800421c62f:	48 83 c4 10          	add    $0x10,%rsp
			vmcs_read16(VMCS_16BIT_HOST_CS_SELECTOR), vmcs_read16(VMCS_16BIT_HOST_SS_SELECTOR),
			vmcs_read16(VMCS_16BIT_HOST_DS_SELECTOR), vmcs_read16(VMCS_16BIT_HOST_ES_SELECTOR),
			vmcs_read16(VMCS_16BIT_HOST_FS_SELECTOR), vmcs_read16(VMCS_16BIT_HOST_GS_SELECTOR),
			vmcs_read16(VMCS_16BIT_HOST_TR_SELECTOR));
	cprintf("FSBase=%016lx GSBase=%016lx TRBase=%016lx\n",
  800421c633:	bf 0a 6c 00 00       	mov    $0x6c0a,%edi
  800421c638:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c63f:	00 00 00 
  800421c642:	ff d0                	callq  *%rax
  800421c644:	49 89 c4             	mov    %rax,%r12
  800421c647:	bf 08 6c 00 00       	mov    $0x6c08,%edi
  800421c64c:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c653:	00 00 00 
  800421c656:	ff d0                	callq  *%rax
  800421c658:	48 89 c3             	mov    %rax,%rbx
  800421c65b:	bf 06 6c 00 00       	mov    $0x6c06,%edi
  800421c660:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c667:	00 00 00 
  800421c66a:	ff d0                	callq  *%rax
  800421c66c:	4c 89 e1             	mov    %r12,%rcx
  800421c66f:	48 89 da             	mov    %rbx,%rdx
  800421c672:	48 89 c6             	mov    %rax,%rsi
  800421c675:	48 bf 28 24 22 04 80 	movabs $0x8004222428,%rdi
  800421c67c:	00 00 00 
  800421c67f:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c684:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421c68b:	00 00 00 
  800421c68e:	41 ff d0             	callq  *%r8
			vmcs_readl(VMCS_HOST_FS_BASE), vmcs_readl(VMCS_HOST_GS_BASE),
			vmcs_readl(VMCS_HOST_TR_BASE));
	cprintf("GDTBase=%016lx IDTBase=%016lx\n",
  800421c691:	bf 0e 6c 00 00       	mov    $0x6c0e,%edi
  800421c696:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c69d:	00 00 00 
  800421c6a0:	ff d0                	callq  *%rax
  800421c6a2:	48 89 c3             	mov    %rax,%rbx
  800421c6a5:	bf 0c 6c 00 00       	mov    $0x6c0c,%edi
  800421c6aa:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c6b1:	00 00 00 
  800421c6b4:	ff d0                	callq  *%rax
  800421c6b6:	48 89 da             	mov    %rbx,%rdx
  800421c6b9:	48 89 c6             	mov    %rax,%rsi
  800421c6bc:	48 bf 58 24 22 04 80 	movabs $0x8004222458,%rdi
  800421c6c3:	00 00 00 
  800421c6c6:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c6cb:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421c6d2:	00 00 00 
  800421c6d5:	ff d1                	callq  *%rcx
			vmcs_readl(VMCS_HOST_GDTR_BASE), vmcs_readl(VMCS_HOST_IDTR_BASE));
	cprintf("CR0=%016lx CR3=%016lx CR4=%016lx\n",
  800421c6d7:	bf 04 6c 00 00       	mov    $0x6c04,%edi
  800421c6dc:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c6e3:	00 00 00 
  800421c6e6:	ff d0                	callq  *%rax
  800421c6e8:	49 89 c4             	mov    %rax,%r12
  800421c6eb:	bf 02 6c 00 00       	mov    $0x6c02,%edi
  800421c6f0:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c6f7:	00 00 00 
  800421c6fa:	ff d0                	callq  *%rax
  800421c6fc:	48 89 c3             	mov    %rax,%rbx
  800421c6ff:	bf 00 6c 00 00       	mov    $0x6c00,%edi
  800421c704:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c70b:	00 00 00 
  800421c70e:	ff d0                	callq  *%rax
  800421c710:	4c 89 e1             	mov    %r12,%rcx
  800421c713:	48 89 da             	mov    %rbx,%rdx
  800421c716:	48 89 c6             	mov    %rax,%rsi
  800421c719:	48 bf 78 24 22 04 80 	movabs $0x8004222478,%rdi
  800421c720:	00 00 00 
  800421c723:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c728:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421c72f:	00 00 00 
  800421c732:	41 ff d0             	callq  *%r8
			vmcs_readl(VMCS_HOST_CR0), vmcs_readl(VMCS_HOST_CR3),
			vmcs_readl(VMCS_HOST_CR4));
	cprintf("Sysenter RSP=%016lx CS:RIP=%04x:%016lx\n",
  800421c735:	bf 12 6c 00 00       	mov    $0x6c12,%edi
  800421c73a:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c741:	00 00 00 
  800421c744:	ff d0                	callq  *%rax
  800421c746:	49 89 c4             	mov    %rax,%r12
  800421c749:	c7 85 70 ff ff ff 00 	movl   $0x4c00,-0x90(%rbp)
  800421c750:	4c 00 00 
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421c753:	8b 85 70 ff ff ff    	mov    -0x90(%rbp),%eax
  800421c759:	89 c7                	mov    %eax,%edi
  800421c75b:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c762:	00 00 00 
  800421c765:	ff d0                	callq  *%rax
  800421c767:	89 c3                	mov    %eax,%ebx
  800421c769:	bf 10 6c 00 00       	mov    $0x6c10,%edi
  800421c76e:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c775:	00 00 00 
  800421c778:	ff d0                	callq  *%rax
  800421c77a:	4c 89 e1             	mov    %r12,%rcx
  800421c77d:	89 da                	mov    %ebx,%edx
  800421c77f:	48 89 c6             	mov    %rax,%rsi
  800421c782:	48 bf 90 22 22 04 80 	movabs $0x8004222290,%rdi
  800421c789:	00 00 00 
  800421c78c:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c791:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421c798:	00 00 00 
  800421c79b:	41 ff d0             	callq  *%r8
			vmcs_readl (VMCS_HOST_IA32_SYSENTER_ESP_MSR),
			vmcs_read32(VMCS_32BIT_HOST_IA32_SYSENTER_CS_MSR),
			vmcs_readl (VMCS_HOST_IA32_SYSENTER_EIP_MSR));
	if (vmexit_ctl & (0x00080000 | 0x00200000))
  800421c79e:	8b 45 c0             	mov    -0x40(%rbp),%eax
  800421c7a1:	25 00 00 28 00       	and    $0x280000,%eax
  800421c7a6:	85 c0                	test   %eax,%eax
  800421c7a8:	74 60                	je     800421c80a <vmcs_dump_cpu_1+0x8b5>
  800421c7aa:	c7 85 48 ff ff ff 00 	movl   $0x2c00,-0xb8(%rbp)
  800421c7b1:	2c 00 00 
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421c7b4:	8b 85 48 ff ff ff    	mov    -0xb8(%rbp),%eax
  800421c7ba:	89 c7                	mov    %eax,%edi
  800421c7bc:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c7c3:	00 00 00 
  800421c7c6:	ff d0                	callq  *%rax
  800421c7c8:	48 89 c3             	mov    %rax,%rbx
  800421c7cb:	c7 85 6c ff ff ff 02 	movl   $0x2c02,-0x94(%rbp)
  800421c7d2:	2c 00 00 
  800421c7d5:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
  800421c7db:	89 c7                	mov    %eax,%edi
  800421c7dd:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c7e4:	00 00 00 
  800421c7e7:	ff d0                	callq  *%rax
		cprintf("EFER = 0x%016llx  PAT = 0x%016llx\n",
  800421c7e9:	48 89 da             	mov    %rbx,%rdx
  800421c7ec:	48 89 c6             	mov    %rax,%rsi
  800421c7ef:	48 bf a0 24 22 04 80 	movabs $0x80042224a0,%rdi
  800421c7f6:	00 00 00 
  800421c7f9:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c7fe:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421c805:	00 00 00 
  800421c808:	ff d1                	callq  *%rcx
				vmcs_read64(VMCS_64BIT_HOST_IA32_EFER),
				vmcs_read64(VMCS_64BIT_HOST_IA32_PAT));

	cprintf("\n*** Control State ***\n");
  800421c80a:	48 bf c3 24 22 04 80 	movabs $0x80042224c3,%rdi
  800421c811:	00 00 00 
  800421c814:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c819:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421c820:	00 00 00 
  800421c823:	ff d2                	callq  *%rdx
	cprintf("PinBased=%08x CPUBased=%08x SecondaryExec=%08x\n",
  800421c825:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  800421c828:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800421c82b:	8b 45 b0             	mov    -0x50(%rbp),%eax
  800421c82e:	89 c6                	mov    %eax,%esi
  800421c830:	48 bf e0 24 22 04 80 	movabs $0x80042224e0,%rdi
  800421c837:	00 00 00 
  800421c83a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c83f:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421c846:	00 00 00 
  800421c849:	41 ff d0             	callq  *%r8
			pin_based_exec_ctrl, cpu_based_exec_ctrl, secondary_exec_control);
	cprintf("EntryControls=%08x ExitControls=%08x\n", vmentry_ctl, vmexit_ctl);
  800421c84c:	8b 55 c0             	mov    -0x40(%rbp),%edx
  800421c84f:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421c852:	89 c6                	mov    %eax,%esi
  800421c854:	48 bf 10 25 22 04 80 	movabs $0x8004222510,%rdi
  800421c85b:	00 00 00 
  800421c85e:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c863:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421c86a:	00 00 00 
  800421c86d:	ff d1                	callq  *%rcx
  800421c86f:	c7 85 40 ff ff ff 08 	movl   $0x4008,-0xc0(%rbp)
  800421c876:	40 00 00 
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421c879:	8b 85 40 ff ff ff    	mov    -0xc0(%rbp),%eax
  800421c87f:	89 c7                	mov    %eax,%edi
  800421c881:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c888:	00 00 00 
  800421c88b:	ff d0                	callq  *%rax
  800421c88d:	41 89 c4             	mov    %eax,%r12d
  800421c890:	c7 85 3c ff ff ff 06 	movl   $0x4006,-0xc4(%rbp)
  800421c897:	40 00 00 
  800421c89a:	8b 85 3c ff ff ff    	mov    -0xc4(%rbp),%eax
  800421c8a0:	89 c7                	mov    %eax,%edi
  800421c8a2:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c8a9:	00 00 00 
  800421c8ac:	ff d0                	callq  *%rax
  800421c8ae:	89 c3                	mov    %eax,%ebx
  800421c8b0:	c7 85 38 ff ff ff 04 	movl   $0x4004,-0xc8(%rbp)
  800421c8b7:	40 00 00 
  800421c8ba:	8b 85 38 ff ff ff    	mov    -0xc8(%rbp),%eax
  800421c8c0:	89 c7                	mov    %eax,%edi
  800421c8c2:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c8c9:	00 00 00 
  800421c8cc:	ff d0                	callq  *%rax
	cprintf("ExceptionBitmap=%08x PFECmask=%08x PFECmatch=%08x\n",
  800421c8ce:	44 89 e1             	mov    %r12d,%ecx
  800421c8d1:	89 da                	mov    %ebx,%edx
  800421c8d3:	89 c6                	mov    %eax,%esi
  800421c8d5:	48 bf 38 25 22 04 80 	movabs $0x8004222538,%rdi
  800421c8dc:	00 00 00 
  800421c8df:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c8e4:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421c8eb:	00 00 00 
  800421c8ee:	41 ff d0             	callq  *%r8
  800421c8f1:	c7 85 34 ff ff ff 1a 	movl   $0x401a,-0xcc(%rbp)
  800421c8f8:	40 00 00 
  800421c8fb:	8b 85 34 ff ff ff    	mov    -0xcc(%rbp),%eax
  800421c901:	89 c7                	mov    %eax,%edi
  800421c903:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c90a:	00 00 00 
  800421c90d:	ff d0                	callq  *%rax
  800421c90f:	41 89 c4             	mov    %eax,%r12d
  800421c912:	c7 85 30 ff ff ff 18 	movl   $0x4018,-0xd0(%rbp)
  800421c919:	40 00 00 
  800421c91c:	8b 85 30 ff ff ff    	mov    -0xd0(%rbp),%eax
  800421c922:	89 c7                	mov    %eax,%edi
  800421c924:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c92b:	00 00 00 
  800421c92e:	ff d0                	callq  *%rax
  800421c930:	89 c3                	mov    %eax,%ebx
  800421c932:	c7 85 2c ff ff ff 16 	movl   $0x4016,-0xd4(%rbp)
  800421c939:	40 00 00 
  800421c93c:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
  800421c942:	89 c7                	mov    %eax,%edi
  800421c944:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c94b:	00 00 00 
  800421c94e:	ff d0                	callq  *%rax
			vmcs_read32(VMCS_32BIT_CONTROL_EXCEPTION_BITMAP),
			vmcs_read32(VMCS_32BIT_CONTROL_PAGE_FAULT_ERR_CODE_MASK),
			vmcs_read32(VMCS_32BIT_CONTROL_PAGE_FAULT_ERR_CODE_MATCH));
	cprintf("VMEntry: intr_info=%08x errcode=%08x ilen=%08x\n",
  800421c950:	44 89 e1             	mov    %r12d,%ecx
  800421c953:	89 da                	mov    %ebx,%edx
  800421c955:	89 c6                	mov    %eax,%esi
  800421c957:	48 bf 70 25 22 04 80 	movabs $0x8004222570,%rdi
  800421c95e:	00 00 00 
  800421c961:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c966:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421c96d:	00 00 00 
  800421c970:	41 ff d0             	callq  *%r8
  800421c973:	c7 85 28 ff ff ff 0c 	movl   $0x440c,-0xd8(%rbp)
  800421c97a:	44 00 00 
  800421c97d:	8b 85 28 ff ff ff    	mov    -0xd8(%rbp),%eax
  800421c983:	89 c7                	mov    %eax,%edi
  800421c985:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c98c:	00 00 00 
  800421c98f:	ff d0                	callq  *%rax
  800421c991:	41 89 c4             	mov    %eax,%r12d
  800421c994:	c7 85 24 ff ff ff 06 	movl   $0x4406,-0xdc(%rbp)
  800421c99b:	44 00 00 
  800421c99e:	8b 85 24 ff ff ff    	mov    -0xdc(%rbp),%eax
  800421c9a4:	89 c7                	mov    %eax,%edi
  800421c9a6:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c9ad:	00 00 00 
  800421c9b0:	ff d0                	callq  *%rax
  800421c9b2:	89 c3                	mov    %eax,%ebx
  800421c9b4:	c7 85 20 ff ff ff 04 	movl   $0x4404,-0xe0(%rbp)
  800421c9bb:	44 00 00 
  800421c9be:	8b 85 20 ff ff ff    	mov    -0xe0(%rbp),%eax
  800421c9c4:	89 c7                	mov    %eax,%edi
  800421c9c6:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421c9cd:	00 00 00 
  800421c9d0:	ff d0                	callq  *%rax
			vmcs_read32(VMCS_32BIT_CONTROL_VMENTRY_INTERRUPTION_INFO),
			vmcs_read32(VMCS_32BIT_CONTROL_VMENTRY_EXCEPTION_ERR_CODE),
			vmcs_read32(VMCS_32BIT_CONTROL_VMENTRY_INSTRUCTION_LENGTH));
	cprintf("VMExit: intr_info=%08x errcode=%08x ilen=%08x\n",
  800421c9d2:	44 89 e1             	mov    %r12d,%ecx
  800421c9d5:	89 da                	mov    %ebx,%edx
  800421c9d7:	89 c6                	mov    %eax,%esi
  800421c9d9:	48 bf a0 25 22 04 80 	movabs $0x80042225a0,%rdi
  800421c9e0:	00 00 00 
  800421c9e3:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c9e8:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421c9ef:	00 00 00 
  800421c9f2:	41 ff d0             	callq  *%r8
			vmcs_read32(VMCS_32BIT_VMEXIT_INTERRUPTION_INFO),
			vmcs_read32(VMCS_32BIT_VMEXIT_INTERRUPTION_ERR_CODE),
			vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH));
	cprintf("        reason=%08x qualification=%016lx\n",
  800421c9f5:	bf 00 64 00 00       	mov    $0x6400,%edi
  800421c9fa:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421ca01:	00 00 00 
  800421ca04:	ff d0                	callq  *%rax
  800421ca06:	48 89 c3             	mov    %rax,%rbx
  800421ca09:	c7 85 4c ff ff ff 02 	movl   $0x4402,-0xb4(%rbp)
  800421ca10:	44 00 00 
  800421ca13:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
  800421ca19:	89 c7                	mov    %eax,%edi
  800421ca1b:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421ca22:	00 00 00 
  800421ca25:	ff d0                	callq  *%rax
  800421ca27:	48 89 da             	mov    %rbx,%rdx
  800421ca2a:	89 c6                	mov    %eax,%esi
  800421ca2c:	48 bf d0 25 22 04 80 	movabs $0x80042225d0,%rdi
  800421ca33:	00 00 00 
  800421ca36:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ca3b:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421ca42:	00 00 00 
  800421ca45:	ff d1                	callq  *%rcx
			vmcs_read32(VMCS_32BIT_VMEXIT_REASON), vmcs_readl(VMCS_VMEXIT_QUALIFICATION));
	if ((vmexit_ctl & (0x0040000 | 0x0010000)) ||
  800421ca47:	8b 45 c0             	mov    -0x40(%rbp),%eax
  800421ca4a:	25 00 00 05 00       	and    $0x50000,%eax
  800421ca4f:	85 c0                	test   %eax,%eax
  800421ca51:	75 0c                	jne    800421ca5f <vmcs_dump_cpu_1+0xb0a>
			(vmentry_ctl & (0x00004000 | 0x00008000)))
  800421ca53:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421ca56:	25 00 c0 00 00       	and    $0xc000,%eax
			vmcs_read32(VMCS_32BIT_VMEXIT_INTERRUPTION_INFO),
			vmcs_read32(VMCS_32BIT_VMEXIT_INTERRUPTION_ERR_CODE),
			vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH));
	cprintf("        reason=%08x qualification=%016lx\n",
			vmcs_read32(VMCS_32BIT_VMEXIT_REASON), vmcs_readl(VMCS_VMEXIT_QUALIFICATION));
	if ((vmexit_ctl & (0x0040000 | 0x0010000)) ||
  800421ca5b:	85 c0                	test   %eax,%eax
  800421ca5d:	74 43                	je     800421caa2 <vmcs_dump_cpu_1+0xb4d>
  800421ca5f:	c7 85 44 ff ff ff 04 	movl   $0x2804,-0xbc(%rbp)
  800421ca66:	28 00 00 
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421ca69:	8b 85 44 ff ff ff    	mov    -0xbc(%rbp),%eax
  800421ca6f:	89 c7                	mov    %eax,%edi
  800421ca71:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421ca78:	00 00 00 
  800421ca7b:	ff d0                	callq  *%rax
  800421ca7d:	48 89 c2             	mov    %rax,%rdx
			(vmentry_ctl & (0x00004000 | 0x00008000)))
		cprintf("EFER =     0x%016llx  PAT = 0x%016llx\n",
  800421ca80:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421ca84:	48 89 c6             	mov    %rax,%rsi
  800421ca87:	48 bf f8 22 22 04 80 	movabs $0x80042222f8,%rdi
  800421ca8e:	00 00 00 
  800421ca91:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ca96:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421ca9d:	00 00 00 
  800421caa0:	ff d1                	callq  *%rcx
				efer, vmcs_read64(VMCS_64BIT_GUEST_IA32_PAT));
	cprintf("DebugCtl = 0x%016llx  DebugExceptions = 0x%016lx\n",
  800421caa2:	bf 22 68 00 00       	mov    $0x6822,%edi
  800421caa7:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421caae:	00 00 00 
  800421cab1:	ff d0                	callq  *%rax
  800421cab3:	48 89 c3             	mov    %rax,%rbx
  800421cab6:	c7 85 1c ff ff ff 02 	movl   $0x2802,-0xe4(%rbp)
  800421cabd:	28 00 00 
  800421cac0:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
  800421cac6:	89 c7                	mov    %eax,%edi
  800421cac8:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cacf:	00 00 00 
  800421cad2:	ff d0                	callq  *%rax
  800421cad4:	48 89 da             	mov    %rbx,%rdx
  800421cad7:	48 89 c6             	mov    %rax,%rsi
  800421cada:	48 bf 20 23 22 04 80 	movabs $0x8004222320,%rdi
  800421cae1:	00 00 00 
  800421cae4:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cae9:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421caf0:	00 00 00 
  800421caf3:	ff d1                	callq  *%rcx
			vmcs_read64(VMCS_64BIT_GUEST_IA32_DEBUGCTL),
			vmcs_readl(VMCS_GUEST_PENDING_DBG_EXCEPTIONS));
	if(vmentry_ctl & 0x000100000)
  800421caf5:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421caf8:	25 00 00 10 00       	and    $0x100000,%eax
  800421cafd:	85 c0                	test   %eax,%eax
  800421caff:	74 3c                	je     800421cb3d <vmcs_dump_cpu_1+0xbe8>
  800421cb01:	c7 85 18 ff ff ff 12 	movl   $0x2812,-0xe8(%rbp)
  800421cb08:	28 00 00 
  800421cb0b:	8b 85 18 ff ff ff    	mov    -0xe8(%rbp),%eax
  800421cb11:	89 c7                	mov    %eax,%edi
  800421cb13:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cb1a:	00 00 00 
  800421cb1d:	ff d0                	callq  *%rax
		cprintf("BndCfgS = 0x%016llx\n", vmcs_read64(0x00002812));
  800421cb1f:	48 89 c6             	mov    %rax,%rsi
  800421cb22:	48 bf 52 23 22 04 80 	movabs $0x8004222352,%rdi
  800421cb29:	00 00 00 
  800421cb2c:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cb31:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421cb38:	00 00 00 
  800421cb3b:	ff d2                	callq  *%rdx
  800421cb3d:	c7 85 0c ff ff ff 26 	movl   $0x4826,-0xf4(%rbp)
  800421cb44:	48 00 00 
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421cb47:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  800421cb4d:	89 c7                	mov    %eax,%edi
  800421cb4f:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cb56:	00 00 00 
  800421cb59:	ff d0                	callq  *%rax
  800421cb5b:	89 c3                	mov    %eax,%ebx
  800421cb5d:	c7 85 14 ff ff ff 24 	movl   $0x4824,-0xec(%rbp)
  800421cb64:	48 00 00 
  800421cb67:	8b 85 14 ff ff ff    	mov    -0xec(%rbp),%eax
  800421cb6d:	89 c7                	mov    %eax,%edi
  800421cb6f:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cb76:	00 00 00 
  800421cb79:	ff d0                	callq  *%rax
	cprintf("Interruptibility = %08x  ActivityState = %08x\n",
  800421cb7b:	89 da                	mov    %ebx,%edx
  800421cb7d:	89 c6                	mov    %eax,%esi
  800421cb7f:	48 bf 68 23 22 04 80 	movabs $0x8004222368,%rdi
  800421cb86:	00 00 00 
  800421cb89:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cb8e:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421cb95:	00 00 00 
  800421cb98:	ff d1                	callq  *%rcx
			vmcs_read32(VMCS_32BIT_GUEST_INTERRUPTIBILITY_STATE),
			vmcs_read32(VMCS_32BIT_GUEST_ACTIVITY_STATE));
	if (secondary_exec_control & 0x00000200)
  800421cb9a:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800421cb9d:	25 00 02 00 00       	and    $0x200,%eax
  800421cba2:	85 c0                	test   %eax,%eax
  800421cba4:	74 3e                	je     800421cbe4 <vmcs_dump_cpu_1+0xc8f>
  800421cba6:	c7 85 10 ff ff ff 10 	movl   $0x810,-0xf0(%rbp)
  800421cbad:	08 00 00 
	return value;
}

static __inline uint16_t vmcs_read16(uint32_t field)
{
	return vmcs_readl(field);
  800421cbb0:	8b 85 10 ff ff ff    	mov    -0xf0(%rbp),%eax
  800421cbb6:	89 c7                	mov    %eax,%edi
  800421cbb8:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cbbf:	00 00 00 
  800421cbc2:	ff d0                	callq  *%rax
		cprintf("InterruptStatus = %04x\n",
  800421cbc4:	0f b7 c0             	movzwl %ax,%eax
  800421cbc7:	89 c6                	mov    %eax,%esi
  800421cbc9:	48 bf 97 23 22 04 80 	movabs $0x8004222397,%rdi
  800421cbd0:	00 00 00 
  800421cbd3:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cbd8:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421cbdf:	00 00 00 
  800421cbe2:	ff d2                	callq  *%rdx
				vmcs_read16(VMCS_16BIT_GUEST_INTERRUPT_STATUS));

	cprintf("\n*** Host State ***\n");
  800421cbe4:	48 bf af 23 22 04 80 	movabs $0x80042223af,%rdi
  800421cbeb:	00 00 00 
  800421cbee:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cbf3:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421cbfa:	00 00 00 
  800421cbfd:	ff d2                	callq  *%rdx
	cprintf("RIP = 0x%016lx  RSP = 0x%016lx\n",
  800421cbff:	bf 14 6c 00 00       	mov    $0x6c14,%edi
  800421cc04:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cc0b:	00 00 00 
  800421cc0e:	ff d0                	callq  *%rax
  800421cc10:	48 89 c3             	mov    %rax,%rbx
  800421cc13:	bf 16 6c 00 00       	mov    $0x6c16,%edi
  800421cc18:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cc1f:	00 00 00 
  800421cc22:	ff d0                	callq  *%rax
  800421cc24:	48 89 da             	mov    %rbx,%rdx
  800421cc27:	48 89 c6             	mov    %rax,%rsi
  800421cc2a:	48 bf c8 23 22 04 80 	movabs $0x80042223c8,%rdi
  800421cc31:	00 00 00 
  800421cc34:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cc39:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421cc40:	00 00 00 
  800421cc43:	ff d1                	callq  *%rcx
  800421cc45:	c7 85 00 ff ff ff 0c 	movl   $0xc0c,-0x100(%rbp)
  800421cc4c:	0c 00 00 
  800421cc4f:	8b 85 00 ff ff ff    	mov    -0x100(%rbp),%eax
  800421cc55:	89 c7                	mov    %eax,%edi
  800421cc57:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cc5e:	00 00 00 
  800421cc61:	ff d0                	callq  *%rax
			vmcs_readl(VMCS_HOST_RIP), vmcs_readl(VMCS_HOST_RSP));
	cprintf("CS=%04x SS=%04x DS=%04x ES=%04x FS=%04x GS=%04x TR=%04x\n",
  800421cc63:	44 0f b7 f0          	movzwl %ax,%r14d
  800421cc67:	c7 85 fc fe ff ff 0a 	movl   $0xc0a,-0x104(%rbp)
  800421cc6e:	0c 00 00 
  800421cc71:	8b 85 fc fe ff ff    	mov    -0x104(%rbp),%eax
  800421cc77:	89 c7                	mov    %eax,%edi
  800421cc79:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cc80:	00 00 00 
  800421cc83:	ff d0                	callq  *%rax
  800421cc85:	44 0f b7 e8          	movzwl %ax,%r13d
  800421cc89:	c7 85 f8 fe ff ff 08 	movl   $0xc08,-0x108(%rbp)
  800421cc90:	0c 00 00 
  800421cc93:	8b 85 f8 fe ff ff    	mov    -0x108(%rbp),%eax
  800421cc99:	89 c7                	mov    %eax,%edi
  800421cc9b:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cca2:	00 00 00 
  800421cca5:	ff d0                	callq  *%rax
  800421cca7:	0f b7 c0             	movzwl %ax,%eax
  800421ccaa:	89 85 ac fe ff ff    	mov    %eax,-0x154(%rbp)
  800421ccb0:	c7 85 f4 fe ff ff 00 	movl   $0xc00,-0x10c(%rbp)
  800421ccb7:	0c 00 00 
  800421ccba:	8b 85 f4 fe ff ff    	mov    -0x10c(%rbp),%eax
  800421ccc0:	89 c7                	mov    %eax,%edi
  800421ccc2:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421ccc9:	00 00 00 
  800421cccc:	ff d0                	callq  *%rax
  800421ccce:	44 0f b7 f8          	movzwl %ax,%r15d
  800421ccd2:	c7 85 f0 fe ff ff 06 	movl   $0xc06,-0x110(%rbp)
  800421ccd9:	0c 00 00 
  800421ccdc:	8b 85 f0 fe ff ff    	mov    -0x110(%rbp),%eax
  800421cce2:	89 c7                	mov    %eax,%edi
  800421cce4:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cceb:	00 00 00 
  800421ccee:	ff d0                	callq  *%rax
  800421ccf0:	44 0f b7 e0          	movzwl %ax,%r12d
  800421ccf4:	c7 85 ec fe ff ff 04 	movl   $0xc04,-0x114(%rbp)
  800421ccfb:	0c 00 00 
  800421ccfe:	8b 85 ec fe ff ff    	mov    -0x114(%rbp),%eax
  800421cd04:	89 c7                	mov    %eax,%edi
  800421cd06:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cd0d:	00 00 00 
  800421cd10:	ff d0                	callq  *%rax
  800421cd12:	0f b7 d8             	movzwl %ax,%ebx
  800421cd15:	c7 85 e8 fe ff ff 02 	movl   $0xc02,-0x118(%rbp)
  800421cd1c:	0c 00 00 
  800421cd1f:	8b 85 e8 fe ff ff    	mov    -0x118(%rbp),%eax
  800421cd25:	89 c7                	mov    %eax,%edi
  800421cd27:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cd2e:	00 00 00 
  800421cd31:	ff d0                	callq  *%rax
  800421cd33:	0f b7 c0             	movzwl %ax,%eax
  800421cd36:	41 56                	push   %r14
  800421cd38:	41 55                	push   %r13
  800421cd3a:	44 8b 8d ac fe ff ff 	mov    -0x154(%rbp),%r9d
  800421cd41:	45 89 f8             	mov    %r15d,%r8d
  800421cd44:	44 89 e1             	mov    %r12d,%ecx
  800421cd47:	89 da                	mov    %ebx,%edx
  800421cd49:	89 c6                	mov    %eax,%esi
  800421cd4b:	48 bf e8 23 22 04 80 	movabs $0x80042223e8,%rdi
  800421cd52:	00 00 00 
  800421cd55:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cd5a:	49 ba 09 9d 20 04 80 	movabs $0x8004209d09,%r10
  800421cd61:	00 00 00 
  800421cd64:	41 ff d2             	callq  *%r10
  800421cd67:	48 83 c4 10          	add    $0x10,%rsp
			vmcs_read16(VMCS_16BIT_HOST_CS_SELECTOR), vmcs_read16(VMCS_16BIT_HOST_SS_SELECTOR),
			vmcs_read16(VMCS_16BIT_HOST_DS_SELECTOR), vmcs_read16(VMCS_16BIT_HOST_ES_SELECTOR),
			vmcs_read16(VMCS_16BIT_HOST_FS_SELECTOR), vmcs_read16(VMCS_16BIT_HOST_GS_SELECTOR),
			vmcs_read16(VMCS_16BIT_HOST_TR_SELECTOR));
	cprintf("FSBase=%016lx GSBase=%016lx TRBase=%016lx\n",
  800421cd6b:	bf 0a 6c 00 00       	mov    $0x6c0a,%edi
  800421cd70:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cd77:	00 00 00 
  800421cd7a:	ff d0                	callq  *%rax
  800421cd7c:	49 89 c4             	mov    %rax,%r12
  800421cd7f:	bf 08 6c 00 00       	mov    $0x6c08,%edi
  800421cd84:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cd8b:	00 00 00 
  800421cd8e:	ff d0                	callq  *%rax
  800421cd90:	48 89 c3             	mov    %rax,%rbx
  800421cd93:	bf 06 6c 00 00       	mov    $0x6c06,%edi
  800421cd98:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cd9f:	00 00 00 
  800421cda2:	ff d0                	callq  *%rax
  800421cda4:	4c 89 e1             	mov    %r12,%rcx
  800421cda7:	48 89 da             	mov    %rbx,%rdx
  800421cdaa:	48 89 c6             	mov    %rax,%rsi
  800421cdad:	48 bf 28 24 22 04 80 	movabs $0x8004222428,%rdi
  800421cdb4:	00 00 00 
  800421cdb7:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cdbc:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421cdc3:	00 00 00 
  800421cdc6:	41 ff d0             	callq  *%r8
			vmcs_readl(VMCS_HOST_FS_BASE), vmcs_readl(VMCS_HOST_GS_BASE),
			vmcs_readl(VMCS_HOST_TR_BASE));
	cprintf("GDTBase=%016lx IDTBase=%016lx\n",
  800421cdc9:	bf 0e 6c 00 00       	mov    $0x6c0e,%edi
  800421cdce:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cdd5:	00 00 00 
  800421cdd8:	ff d0                	callq  *%rax
  800421cdda:	48 89 c3             	mov    %rax,%rbx
  800421cddd:	bf 0c 6c 00 00       	mov    $0x6c0c,%edi
  800421cde2:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cde9:	00 00 00 
  800421cdec:	ff d0                	callq  *%rax
  800421cdee:	48 89 da             	mov    %rbx,%rdx
  800421cdf1:	48 89 c6             	mov    %rax,%rsi
  800421cdf4:	48 bf 58 24 22 04 80 	movabs $0x8004222458,%rdi
  800421cdfb:	00 00 00 
  800421cdfe:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ce03:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421ce0a:	00 00 00 
  800421ce0d:	ff d1                	callq  *%rcx
			vmcs_readl(VMCS_HOST_GDTR_BASE), vmcs_readl(VMCS_HOST_IDTR_BASE));
	cprintf("CR0=%016lx CR3=%016lx CR4=%016lx\n",
  800421ce0f:	bf 04 6c 00 00       	mov    $0x6c04,%edi
  800421ce14:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421ce1b:	00 00 00 
  800421ce1e:	ff d0                	callq  *%rax
  800421ce20:	49 89 c4             	mov    %rax,%r12
  800421ce23:	bf 02 6c 00 00       	mov    $0x6c02,%edi
  800421ce28:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421ce2f:	00 00 00 
  800421ce32:	ff d0                	callq  *%rax
  800421ce34:	48 89 c3             	mov    %rax,%rbx
  800421ce37:	bf 00 6c 00 00       	mov    $0x6c00,%edi
  800421ce3c:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421ce43:	00 00 00 
  800421ce46:	ff d0                	callq  *%rax
  800421ce48:	4c 89 e1             	mov    %r12,%rcx
  800421ce4b:	48 89 da             	mov    %rbx,%rdx
  800421ce4e:	48 89 c6             	mov    %rax,%rsi
  800421ce51:	48 bf 78 24 22 04 80 	movabs $0x8004222478,%rdi
  800421ce58:	00 00 00 
  800421ce5b:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ce60:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421ce67:	00 00 00 
  800421ce6a:	41 ff d0             	callq  *%r8
			vmcs_readl(VMCS_HOST_CR0), vmcs_readl(VMCS_HOST_CR3),
			vmcs_readl(VMCS_HOST_CR4));
	cprintf("Sysenter RSP=%016lx CS:RIP=%04x:%016lx\n",
  800421ce6d:	bf 12 6c 00 00       	mov    $0x6c12,%edi
  800421ce72:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421ce79:	00 00 00 
  800421ce7c:	ff d0                	callq  *%rax
  800421ce7e:	49 89 c4             	mov    %rax,%r12
  800421ce81:	c7 85 08 ff ff ff 00 	movl   $0x4c00,-0xf8(%rbp)
  800421ce88:	4c 00 00 
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421ce8b:	8b 85 08 ff ff ff    	mov    -0xf8(%rbp),%eax
  800421ce91:	89 c7                	mov    %eax,%edi
  800421ce93:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421ce9a:	00 00 00 
  800421ce9d:	ff d0                	callq  *%rax
  800421ce9f:	89 c3                	mov    %eax,%ebx
  800421cea1:	bf 10 6c 00 00       	mov    $0x6c10,%edi
  800421cea6:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cead:	00 00 00 
  800421ceb0:	ff d0                	callq  *%rax
  800421ceb2:	4c 89 e1             	mov    %r12,%rcx
  800421ceb5:	89 da                	mov    %ebx,%edx
  800421ceb7:	48 89 c6             	mov    %rax,%rsi
  800421ceba:	48 bf 90 22 22 04 80 	movabs $0x8004222290,%rdi
  800421cec1:	00 00 00 
  800421cec4:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cec9:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421ced0:	00 00 00 
  800421ced3:	41 ff d0             	callq  *%r8
			vmcs_readl (VMCS_HOST_IA32_SYSENTER_ESP_MSR),
			vmcs_read32(VMCS_32BIT_HOST_IA32_SYSENTER_CS_MSR),
			vmcs_readl (VMCS_HOST_IA32_SYSENTER_EIP_MSR));
	if (vmexit_ctl & (0x00080000 | 0x00200000))
  800421ced6:	8b 45 c0             	mov    -0x40(%rbp),%eax
  800421ced9:	25 00 00 28 00       	and    $0x280000,%eax
  800421cede:	85 c0                	test   %eax,%eax
  800421cee0:	74 60                	je     800421cf42 <vmcs_dump_cpu_1+0xfed>
  800421cee2:	c7 85 e0 fe ff ff 00 	movl   $0x2c00,-0x120(%rbp)
  800421cee9:	2c 00 00 
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421ceec:	8b 85 e0 fe ff ff    	mov    -0x120(%rbp),%eax
  800421cef2:	89 c7                	mov    %eax,%edi
  800421cef4:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cefb:	00 00 00 
  800421cefe:	ff d0                	callq  *%rax
  800421cf00:	48 89 c3             	mov    %rax,%rbx
  800421cf03:	c7 85 04 ff ff ff 02 	movl   $0x2c02,-0xfc(%rbp)
  800421cf0a:	2c 00 00 
  800421cf0d:	8b 85 04 ff ff ff    	mov    -0xfc(%rbp),%eax
  800421cf13:	89 c7                	mov    %eax,%edi
  800421cf15:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cf1c:	00 00 00 
  800421cf1f:	ff d0                	callq  *%rax
		cprintf("EFER = 0x%016llx  PAT = 0x%016llx\n",
  800421cf21:	48 89 da             	mov    %rbx,%rdx
  800421cf24:	48 89 c6             	mov    %rax,%rsi
  800421cf27:	48 bf a0 24 22 04 80 	movabs $0x80042224a0,%rdi
  800421cf2e:	00 00 00 
  800421cf31:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cf36:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421cf3d:	00 00 00 
  800421cf40:	ff d1                	callq  *%rcx
				vmcs_read64(VMCS_64BIT_HOST_IA32_EFER),
				vmcs_read64(VMCS_64BIT_HOST_IA32_PAT));

	cprintf("\n*** Control State ***\n");
  800421cf42:	48 bf c3 24 22 04 80 	movabs $0x80042224c3,%rdi
  800421cf49:	00 00 00 
  800421cf4c:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cf51:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421cf58:	00 00 00 
  800421cf5b:	ff d2                	callq  *%rdx
	cprintf("PinBased=%08x CPUBased=%08x SecondaryExec=%08x\n",
  800421cf5d:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  800421cf60:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800421cf63:	8b 45 b0             	mov    -0x50(%rbp),%eax
  800421cf66:	89 c6                	mov    %eax,%esi
  800421cf68:	48 bf e0 24 22 04 80 	movabs $0x80042224e0,%rdi
  800421cf6f:	00 00 00 
  800421cf72:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cf77:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421cf7e:	00 00 00 
  800421cf81:	41 ff d0             	callq  *%r8
			pin_based_exec_ctrl, cpu_based_exec_ctrl, secondary_exec_control);
	cprintf("EntryControls=%08x ExitControls=%08x\n", vmentry_ctl, vmexit_ctl);
  800421cf84:	8b 55 c0             	mov    -0x40(%rbp),%edx
  800421cf87:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421cf8a:	89 c6                	mov    %eax,%esi
  800421cf8c:	48 bf 10 25 22 04 80 	movabs $0x8004222510,%rdi
  800421cf93:	00 00 00 
  800421cf96:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cf9b:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421cfa2:	00 00 00 
  800421cfa5:	ff d1                	callq  *%rcx
  800421cfa7:	c7 85 dc fe ff ff 08 	movl   $0x4008,-0x124(%rbp)
  800421cfae:	40 00 00 
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421cfb1:	8b 85 dc fe ff ff    	mov    -0x124(%rbp),%eax
  800421cfb7:	89 c7                	mov    %eax,%edi
  800421cfb9:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cfc0:	00 00 00 
  800421cfc3:	ff d0                	callq  *%rax
  800421cfc5:	41 89 c4             	mov    %eax,%r12d
  800421cfc8:	c7 85 d8 fe ff ff 06 	movl   $0x4006,-0x128(%rbp)
  800421cfcf:	40 00 00 
  800421cfd2:	8b 85 d8 fe ff ff    	mov    -0x128(%rbp),%eax
  800421cfd8:	89 c7                	mov    %eax,%edi
  800421cfda:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421cfe1:	00 00 00 
  800421cfe4:	ff d0                	callq  *%rax
  800421cfe6:	89 c3                	mov    %eax,%ebx
  800421cfe8:	c7 85 d4 fe ff ff 04 	movl   $0x4004,-0x12c(%rbp)
  800421cfef:	40 00 00 
  800421cff2:	8b 85 d4 fe ff ff    	mov    -0x12c(%rbp),%eax
  800421cff8:	89 c7                	mov    %eax,%edi
  800421cffa:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421d001:	00 00 00 
  800421d004:	ff d0                	callq  *%rax
	cprintf("ExceptionBitmap=%08x PFECmask=%08x PFECmatch=%08x\n",
  800421d006:	44 89 e1             	mov    %r12d,%ecx
  800421d009:	89 da                	mov    %ebx,%edx
  800421d00b:	89 c6                	mov    %eax,%esi
  800421d00d:	48 bf 38 25 22 04 80 	movabs $0x8004222538,%rdi
  800421d014:	00 00 00 
  800421d017:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d01c:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421d023:	00 00 00 
  800421d026:	41 ff d0             	callq  *%r8
  800421d029:	c7 85 d0 fe ff ff 1a 	movl   $0x401a,-0x130(%rbp)
  800421d030:	40 00 00 
  800421d033:	8b 85 d0 fe ff ff    	mov    -0x130(%rbp),%eax
  800421d039:	89 c7                	mov    %eax,%edi
  800421d03b:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421d042:	00 00 00 
  800421d045:	ff d0                	callq  *%rax
  800421d047:	41 89 c4             	mov    %eax,%r12d
  800421d04a:	c7 85 cc fe ff ff 18 	movl   $0x4018,-0x134(%rbp)
  800421d051:	40 00 00 
  800421d054:	8b 85 cc fe ff ff    	mov    -0x134(%rbp),%eax
  800421d05a:	89 c7                	mov    %eax,%edi
  800421d05c:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421d063:	00 00 00 
  800421d066:	ff d0                	callq  *%rax
  800421d068:	89 c3                	mov    %eax,%ebx
  800421d06a:	c7 85 c8 fe ff ff 16 	movl   $0x4016,-0x138(%rbp)
  800421d071:	40 00 00 
  800421d074:	8b 85 c8 fe ff ff    	mov    -0x138(%rbp),%eax
  800421d07a:	89 c7                	mov    %eax,%edi
  800421d07c:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421d083:	00 00 00 
  800421d086:	ff d0                	callq  *%rax
			vmcs_read32(VMCS_32BIT_CONTROL_EXCEPTION_BITMAP),
			vmcs_read32(VMCS_32BIT_CONTROL_PAGE_FAULT_ERR_CODE_MASK),
			vmcs_read32(VMCS_32BIT_CONTROL_PAGE_FAULT_ERR_CODE_MATCH));
	cprintf("VMEntry: intr_info=%08x errcode=%08x ilen=%08x\n",
  800421d088:	44 89 e1             	mov    %r12d,%ecx
  800421d08b:	89 da                	mov    %ebx,%edx
  800421d08d:	89 c6                	mov    %eax,%esi
  800421d08f:	48 bf 70 25 22 04 80 	movabs $0x8004222570,%rdi
  800421d096:	00 00 00 
  800421d099:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d09e:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421d0a5:	00 00 00 
  800421d0a8:	41 ff d0             	callq  *%r8
  800421d0ab:	c7 85 c4 fe ff ff 0c 	movl   $0x440c,-0x13c(%rbp)
  800421d0b2:	44 00 00 
  800421d0b5:	8b 85 c4 fe ff ff    	mov    -0x13c(%rbp),%eax
  800421d0bb:	89 c7                	mov    %eax,%edi
  800421d0bd:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421d0c4:	00 00 00 
  800421d0c7:	ff d0                	callq  *%rax
  800421d0c9:	41 89 c4             	mov    %eax,%r12d
  800421d0cc:	c7 85 c0 fe ff ff 06 	movl   $0x4406,-0x140(%rbp)
  800421d0d3:	44 00 00 
  800421d0d6:	8b 85 c0 fe ff ff    	mov    -0x140(%rbp),%eax
  800421d0dc:	89 c7                	mov    %eax,%edi
  800421d0de:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421d0e5:	00 00 00 
  800421d0e8:	ff d0                	callq  *%rax
  800421d0ea:	89 c3                	mov    %eax,%ebx
  800421d0ec:	c7 85 bc fe ff ff 04 	movl   $0x4404,-0x144(%rbp)
  800421d0f3:	44 00 00 
  800421d0f6:	8b 85 bc fe ff ff    	mov    -0x144(%rbp),%eax
  800421d0fc:	89 c7                	mov    %eax,%edi
  800421d0fe:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421d105:	00 00 00 
  800421d108:	ff d0                	callq  *%rax
			vmcs_read32(VMCS_32BIT_CONTROL_VMENTRY_INTERRUPTION_INFO),
			vmcs_read32(VMCS_32BIT_CONTROL_VMENTRY_EXCEPTION_ERR_CODE),
			vmcs_read32(VMCS_32BIT_CONTROL_VMENTRY_INSTRUCTION_LENGTH));
	cprintf("VMExit: intr_info=%08x errcode=%08x ilen=%08x\n",
  800421d10a:	44 89 e1             	mov    %r12d,%ecx
  800421d10d:	89 da                	mov    %ebx,%edx
  800421d10f:	89 c6                	mov    %eax,%esi
  800421d111:	48 bf a0 25 22 04 80 	movabs $0x80042225a0,%rdi
  800421d118:	00 00 00 
  800421d11b:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d120:	49 b8 09 9d 20 04 80 	movabs $0x8004209d09,%r8
  800421d127:	00 00 00 
  800421d12a:	41 ff d0             	callq  *%r8
			vmcs_read32(VMCS_32BIT_VMEXIT_INTERRUPTION_INFO),
			vmcs_read32(VMCS_32BIT_VMEXIT_INTERRUPTION_ERR_CODE),
			vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH));
	cprintf("        reason=%08x qualification=%016lx\n",
  800421d12d:	bf 00 64 00 00       	mov    $0x6400,%edi
  800421d132:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421d139:	00 00 00 
  800421d13c:	ff d0                	callq  *%rax
  800421d13e:	48 89 c3             	mov    %rax,%rbx
  800421d141:	c7 85 e4 fe ff ff 02 	movl   $0x4402,-0x11c(%rbp)
  800421d148:	44 00 00 
  800421d14b:	8b 85 e4 fe ff ff    	mov    -0x11c(%rbp),%eax
  800421d151:	89 c7                	mov    %eax,%edi
  800421d153:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421d15a:	00 00 00 
  800421d15d:	ff d0                	callq  *%rax
  800421d15f:	48 89 da             	mov    %rbx,%rdx
  800421d162:	89 c6                	mov    %eax,%esi
  800421d164:	48 bf d0 25 22 04 80 	movabs $0x80042225d0,%rdi
  800421d16b:	00 00 00 
  800421d16e:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d173:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421d17a:	00 00 00 
  800421d17d:	ff d1                	callq  *%rcx
			vmcs_read32(VMCS_32BIT_VMEXIT_REASON), vmcs_readl(VMCS_VMEXIT_QUALIFICATION));
}
  800421d17f:	90                   	nop
  800421d180:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  800421d184:	5b                   	pop    %rbx
  800421d185:	41 5c                	pop    %r12
  800421d187:	41 5d                	pop    %r13
  800421d189:	41 5e                	pop    %r14
  800421d18b:	41 5f                	pop    %r15
  800421d18d:	5d                   	pop    %rbp
  800421d18e:	c3                   	retq   

000000800421d18f <vmexit>:


void vmexit() {
  800421d18f:	55                   	push   %rbp
  800421d190:	48 89 e5             	mov    %rsp,%rbp
  800421d193:	41 54                	push   %r12
  800421d195:	53                   	push   %rbx
  800421d196:	48 83 ec 10          	sub    $0x10,%rsp
	int exit_reason = -1;
  800421d19a:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%rbp)
	bool exit_handled = false;
  800421d1a1:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  800421d1a5:	c7 45 e0 02 44 00 00 	movl   $0x4402,-0x20(%rbp)
  800421d1ac:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421d1af:	89 c7                	mov    %eax,%edi
  800421d1b1:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421d1b8:	00 00 00 
  800421d1bb:	ff d0                	callq  *%rax
	static uint32_t host_vector;
	
	// Get the reason for VMEXIT from the VMCS.
	exit_reason = vmcs_read32(VMCS_32BIT_VMEXIT_REASON);
  800421d1bd:	89 45 e8             	mov    %eax,-0x18(%rbp)
	cprintf( "---VMEXIT Reason: %x---\n", exit_reason ); 
  800421d1c0:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421d1c3:	89 c6                	mov    %eax,%esi
  800421d1c5:	48 bf fa 25 22 04 80 	movabs $0x80042225fa,%rdi
  800421d1cc:	00 00 00 
  800421d1cf:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d1d4:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421d1db:	00 00 00 
  800421d1de:	ff d2                	callq  *%rdx

	//print_trapframe(&curenv->env_tf);

	switch(exit_reason & EXIT_REASON_MASK) {
  800421d1e0:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421d1e3:	0f b7 c0             	movzwl %ax,%eax
  800421d1e6:	83 f8 30             	cmp    $0x30,%eax
  800421d1e9:	0f 87 03 05 00 00    	ja     800421d6f2 <vmexit+0x563>
  800421d1ef:	89 c0                	mov    %eax,%eax
  800421d1f1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421d1f8:	00 
  800421d1f9:	48 b8 60 26 22 04 80 	movabs $0x8004222660,%rax
  800421d200:	00 00 00 
  800421d203:	48 01 d0             	add    %rdx,%rax
  800421d206:	48 8b 00             	mov    (%rax),%rax
  800421d209:	ff e0                	jmpq   *%rax
  800421d20b:	c7 45 e4 04 44 00 00 	movl   $0x4404,-0x1c(%rbp)
  800421d212:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421d215:	89 c7                	mov    %eax,%edi
  800421d217:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421d21e:	00 00 00 
  800421d221:	ff d0                	callq  *%rax
  800421d223:	89 c2                	mov    %eax,%edx
    	case EXIT_REASON_EXTERNAL_INT:
    		host_vector = vmcs_read32(VMCS_32BIT_VMEXIT_INTERRUPTION_INFO);
  800421d225:	48 b8 c4 c5 6d 04 80 	movabs $0x80046dc5c4,%rax
  800421d22c:	00 00 00 
  800421d22f:	89 10                	mov    %edx,(%rax)
    		exit_handled = handle_interrupts(&curenv->env_tf, &curenv->env_vmxinfo, host_vector);
  800421d231:	48 b8 c4 c5 6d 04 80 	movabs $0x80046dc5c4,%rax
  800421d238:	00 00 00 
  800421d23b:	8b 18                	mov    (%rax),%ebx
  800421d23d:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d244:	00 00 00 
  800421d247:	ff d0                	callq  *%rax
  800421d249:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d250:	00 00 00 
  800421d253:	48 98                	cltq   
  800421d255:	48 c1 e0 03          	shl    $0x3,%rax
  800421d259:	48 89 c1             	mov    %rax,%rcx
  800421d25c:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d260:	48 01 c8             	add    %rcx,%rax
  800421d263:	48 01 d0             	add    %rdx,%rax
  800421d266:	48 83 c0 08          	add    $0x8,%rax
  800421d26a:	48 8b 00             	mov    (%rax),%rax
  800421d26d:	4c 8d a0 20 01 00 00 	lea    0x120(%rax),%r12
  800421d274:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d27b:	00 00 00 
  800421d27e:	ff d0                	callq  *%rax
  800421d280:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d287:	00 00 00 
  800421d28a:	48 98                	cltq   
  800421d28c:	48 c1 e0 03          	shl    $0x3,%rax
  800421d290:	48 89 c1             	mov    %rax,%rcx
  800421d293:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d297:	48 01 c8             	add    %rcx,%rax
  800421d29a:	48 01 d0             	add    %rdx,%rax
  800421d29d:	48 83 c0 08          	add    $0x8,%rax
  800421d2a1:	48 8b 00             	mov    (%rax),%rax
  800421d2a4:	89 da                	mov    %ebx,%edx
  800421d2a6:	4c 89 e6             	mov    %r12,%rsi
  800421d2a9:	48 89 c7             	mov    %rax,%rdi
  800421d2ac:	48 b8 ba e1 21 04 80 	movabs $0x800421e1ba,%rax
  800421d2b3:	00 00 00 
  800421d2b6:	ff d0                	callq  *%rax
  800421d2b8:	88 45 ef             	mov    %al,-0x11(%rbp)
    		break;
  800421d2bb:	e9 32 04 00 00       	jmpq   800421d6f2 <vmexit+0x563>
    	case EXIT_REASON_INTERRUPT_WINDOW:
    		exit_handled = handle_interrupt_window(&curenv->env_tf, &curenv->env_vmxinfo, host_vector);
  800421d2c0:	48 b8 c4 c5 6d 04 80 	movabs $0x80046dc5c4,%rax
  800421d2c7:	00 00 00 
  800421d2ca:	8b 18                	mov    (%rax),%ebx
  800421d2cc:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d2d3:	00 00 00 
  800421d2d6:	ff d0                	callq  *%rax
  800421d2d8:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d2df:	00 00 00 
  800421d2e2:	48 98                	cltq   
  800421d2e4:	48 c1 e0 03          	shl    $0x3,%rax
  800421d2e8:	48 89 c1             	mov    %rax,%rcx
  800421d2eb:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d2ef:	48 01 c8             	add    %rcx,%rax
  800421d2f2:	48 01 d0             	add    %rdx,%rax
  800421d2f5:	48 83 c0 08          	add    $0x8,%rax
  800421d2f9:	48 8b 00             	mov    (%rax),%rax
  800421d2fc:	4c 8d a0 20 01 00 00 	lea    0x120(%rax),%r12
  800421d303:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d30a:	00 00 00 
  800421d30d:	ff d0                	callq  *%rax
  800421d30f:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d316:	00 00 00 
  800421d319:	48 98                	cltq   
  800421d31b:	48 c1 e0 03          	shl    $0x3,%rax
  800421d31f:	48 89 c1             	mov    %rax,%rcx
  800421d322:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d326:	48 01 c8             	add    %rcx,%rax
  800421d329:	48 01 d0             	add    %rdx,%rax
  800421d32c:	48 83 c0 08          	add    $0x8,%rax
  800421d330:	48 8b 00             	mov    (%rax),%rax
  800421d333:	89 da                	mov    %ebx,%edx
  800421d335:	4c 89 e6             	mov    %r12,%rsi
  800421d338:	48 89 c7             	mov    %rax,%rdi
  800421d33b:	48 b8 39 e1 21 04 80 	movabs $0x800421e139,%rax
  800421d342:	00 00 00 
  800421d345:	ff d0                	callq  *%rax
  800421d347:	88 45 ef             	mov    %al,-0x11(%rbp)
    		break;
  800421d34a:	e9 a3 03 00 00       	jmpq   800421d6f2 <vmexit+0x563>
        case EXIT_REASON_RDMSR:
		exit_handled = handle_rdmsr(&curenv->env_tf, &curenv->env_vmxinfo);
  800421d34f:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d356:	00 00 00 
  800421d359:	ff d0                	callq  *%rax
  800421d35b:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d362:	00 00 00 
  800421d365:	48 98                	cltq   
  800421d367:	48 c1 e0 03          	shl    $0x3,%rax
  800421d36b:	48 89 c1             	mov    %rax,%rcx
  800421d36e:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d372:	48 01 c8             	add    %rcx,%rax
  800421d375:	48 01 d0             	add    %rdx,%rax
  800421d378:	48 83 c0 08          	add    $0x8,%rax
  800421d37c:	48 8b 00             	mov    (%rax),%rax
  800421d37f:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421d386:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d38d:	00 00 00 
  800421d390:	ff d0                	callq  *%rax
  800421d392:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d399:	00 00 00 
  800421d39c:	48 98                	cltq   
  800421d39e:	48 c1 e0 03          	shl    $0x3,%rax
  800421d3a2:	48 89 c1             	mov    %rax,%rcx
  800421d3a5:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d3a9:	48 01 c8             	add    %rcx,%rax
  800421d3ac:	48 01 d0             	add    %rdx,%rax
  800421d3af:	48 83 c0 08          	add    $0x8,%rax
  800421d3b3:	48 8b 00             	mov    (%rax),%rax
  800421d3b6:	48 89 de             	mov    %rbx,%rsi
  800421d3b9:	48 89 c7             	mov    %rax,%rdi
  800421d3bc:	48 b8 67 e2 21 04 80 	movabs $0x800421e267,%rax
  800421d3c3:	00 00 00 
  800421d3c6:	ff d0                	callq  *%rax
  800421d3c8:	88 45 ef             	mov    %al,-0x11(%rbp)
		break;
  800421d3cb:	e9 22 03 00 00       	jmpq   800421d6f2 <vmexit+0x563>
        case EXIT_REASON_WRMSR:
		exit_handled = handle_wrmsr(&curenv->env_tf, &curenv->env_vmxinfo);
  800421d3d0:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d3d7:	00 00 00 
  800421d3da:	ff d0                	callq  *%rax
  800421d3dc:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d3e3:	00 00 00 
  800421d3e6:	48 98                	cltq   
  800421d3e8:	48 c1 e0 03          	shl    $0x3,%rax
  800421d3ec:	48 89 c1             	mov    %rax,%rcx
  800421d3ef:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d3f3:	48 01 c8             	add    %rcx,%rax
  800421d3f6:	48 01 d0             	add    %rdx,%rax
  800421d3f9:	48 83 c0 08          	add    $0x8,%rax
  800421d3fd:	48 8b 00             	mov    (%rax),%rax
  800421d400:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421d407:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d40e:	00 00 00 
  800421d411:	ff d0                	callq  *%rax
  800421d413:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d41a:	00 00 00 
  800421d41d:	48 98                	cltq   
  800421d41f:	48 c1 e0 03          	shl    $0x3,%rax
  800421d423:	48 89 c1             	mov    %rax,%rcx
  800421d426:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d42a:	48 01 c8             	add    %rcx,%rax
  800421d42d:	48 01 d0             	add    %rdx,%rax
  800421d430:	48 83 c0 08          	add    $0x8,%rax
  800421d434:	48 8b 00             	mov    (%rax),%rax
  800421d437:	48 89 de             	mov    %rbx,%rsi
  800421d43a:	48 89 c7             	mov    %rax,%rdi
  800421d43d:	48 b8 76 e3 21 04 80 	movabs $0x800421e376,%rax
  800421d444:	00 00 00 
  800421d447:	ff d0                	callq  *%rax
  800421d449:	88 45 ef             	mov    %al,-0x11(%rbp)
		break;
  800421d44c:	e9 a1 02 00 00       	jmpq   800421d6f2 <vmexit+0x563>
        case EXIT_REASON_EPT_VIOLATION:
		exit_handled = handle_eptviolation(curenv->env_pml4e, &curenv->env_vmxinfo);
  800421d451:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d458:	00 00 00 
  800421d45b:	ff d0                	callq  *%rax
  800421d45d:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d464:	00 00 00 
  800421d467:	48 98                	cltq   
  800421d469:	48 c1 e0 03          	shl    $0x3,%rax
  800421d46d:	48 89 c1             	mov    %rax,%rcx
  800421d470:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d474:	48 01 c8             	add    %rcx,%rax
  800421d477:	48 01 d0             	add    %rdx,%rax
  800421d47a:	48 83 c0 08          	add    $0x8,%rax
  800421d47e:	48 8b 00             	mov    (%rax),%rax
  800421d481:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421d488:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d48f:	00 00 00 
  800421d492:	ff d0                	callq  *%rax
  800421d494:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d49b:	00 00 00 
  800421d49e:	48 98                	cltq   
  800421d4a0:	48 c1 e0 03          	shl    $0x3,%rax
  800421d4a4:	48 89 c1             	mov    %rax,%rcx
  800421d4a7:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d4ab:	48 01 c8             	add    %rcx,%rax
  800421d4ae:	48 01 d0             	add    %rdx,%rax
  800421d4b1:	48 83 c0 08          	add    $0x8,%rax
  800421d4b5:	48 8b 00             	mov    (%rax),%rax
  800421d4b8:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800421d4bf:	48 89 de             	mov    %rbx,%rsi
  800421d4c2:	48 89 c7             	mov    %rax,%rdi
  800421d4c5:	48 b8 e0 e4 21 04 80 	movabs $0x800421e4e0,%rax
  800421d4cc:	00 00 00 
  800421d4cf:	ff d0                	callq  *%rax
  800421d4d1:	88 45 ef             	mov    %al,-0x11(%rbp)
		break;
  800421d4d4:	e9 19 02 00 00       	jmpq   800421d6f2 <vmexit+0x563>
        case EXIT_REASON_IO_INSTRUCTION:
		exit_handled = handle_ioinstr(&curenv->env_tf, &curenv->env_vmxinfo);
  800421d4d9:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d4e0:	00 00 00 
  800421d4e3:	ff d0                	callq  *%rax
  800421d4e5:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d4ec:	00 00 00 
  800421d4ef:	48 98                	cltq   
  800421d4f1:	48 c1 e0 03          	shl    $0x3,%rax
  800421d4f5:	48 89 c1             	mov    %rax,%rcx
  800421d4f8:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d4fc:	48 01 c8             	add    %rcx,%rax
  800421d4ff:	48 01 d0             	add    %rdx,%rax
  800421d502:	48 83 c0 08          	add    $0x8,%rax
  800421d506:	48 8b 00             	mov    (%rax),%rax
  800421d509:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421d510:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d517:	00 00 00 
  800421d51a:	ff d0                	callq  *%rax
  800421d51c:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d523:	00 00 00 
  800421d526:	48 98                	cltq   
  800421d528:	48 c1 e0 03          	shl    $0x3,%rax
  800421d52c:	48 89 c1             	mov    %rax,%rcx
  800421d52f:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d533:	48 01 c8             	add    %rcx,%rax
  800421d536:	48 01 d0             	add    %rdx,%rax
  800421d539:	48 83 c0 08          	add    $0x8,%rax
  800421d53d:	48 8b 00             	mov    (%rax),%rax
  800421d540:	48 89 de             	mov    %rbx,%rsi
  800421d543:	48 89 c7             	mov    %rax,%rdi
  800421d546:	48 b8 d2 e6 21 04 80 	movabs $0x800421e6d2,%rax
  800421d54d:	00 00 00 
  800421d550:	ff d0                	callq  *%rax
  800421d552:	88 45 ef             	mov    %al,-0x11(%rbp)
		break;
  800421d555:	e9 98 01 00 00       	jmpq   800421d6f2 <vmexit+0x563>
        case EXIT_REASON_CPUID:
		exit_handled = handle_cpuid(&curenv->env_tf, &curenv->env_vmxinfo);
  800421d55a:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d561:	00 00 00 
  800421d564:	ff d0                	callq  *%rax
  800421d566:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d56d:	00 00 00 
  800421d570:	48 98                	cltq   
  800421d572:	48 c1 e0 03          	shl    $0x3,%rax
  800421d576:	48 89 c1             	mov    %rax,%rcx
  800421d579:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d57d:	48 01 c8             	add    %rcx,%rax
  800421d580:	48 01 d0             	add    %rdx,%rax
  800421d583:	48 83 c0 08          	add    $0x8,%rax
  800421d587:	48 8b 00             	mov    (%rax),%rax
  800421d58a:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421d591:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d598:	00 00 00 
  800421d59b:	ff d0                	callq  *%rax
  800421d59d:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d5a4:	00 00 00 
  800421d5a7:	48 98                	cltq   
  800421d5a9:	48 c1 e0 03          	shl    $0x3,%rax
  800421d5ad:	48 89 c1             	mov    %rax,%rcx
  800421d5b0:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d5b4:	48 01 c8             	add    %rcx,%rax
  800421d5b7:	48 01 d0             	add    %rdx,%rax
  800421d5ba:	48 83 c0 08          	add    $0x8,%rax
  800421d5be:	48 8b 00             	mov    (%rax),%rax
  800421d5c1:	48 89 de             	mov    %rbx,%rsi
  800421d5c4:	48 89 c7             	mov    %rax,%rdi
  800421d5c7:	48 b8 ac e8 21 04 80 	movabs $0x800421e8ac,%rax
  800421d5ce:	00 00 00 
  800421d5d1:	ff d0                	callq  *%rax
  800421d5d3:	88 45 ef             	mov    %al,-0x11(%rbp)
		break;
  800421d5d6:	e9 17 01 00 00       	jmpq   800421d6f2 <vmexit+0x563>
	case EXIT_REASON_VMCALL:
		exit_handled = handle_vmcall(&curenv->env_tf, &curenv->env_vmxinfo,
		curenv->env_pml4e);
  800421d5db:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d5e2:	00 00 00 
  800421d5e5:	ff d0                	callq  *%rax
  800421d5e7:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d5ee:	00 00 00 
  800421d5f1:	48 98                	cltq   
  800421d5f3:	48 c1 e0 03          	shl    $0x3,%rax
  800421d5f7:	48 89 c1             	mov    %rax,%rcx
  800421d5fa:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d5fe:	48 01 c8             	add    %rcx,%rax
  800421d601:	48 01 d0             	add    %rdx,%rax
  800421d604:	48 83 c0 08          	add    $0x8,%rax
  800421d608:	48 8b 00             	mov    (%rax),%rax
  800421d60b:	48 8b 98 e0 00 00 00 	mov    0xe0(%rax),%rbx
		break;
        case EXIT_REASON_CPUID:
		exit_handled = handle_cpuid(&curenv->env_tf, &curenv->env_vmxinfo);
		break;
	case EXIT_REASON_VMCALL:
		exit_handled = handle_vmcall(&curenv->env_tf, &curenv->env_vmxinfo,
  800421d612:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d619:	00 00 00 
  800421d61c:	ff d0                	callq  *%rax
  800421d61e:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d625:	00 00 00 
  800421d628:	48 98                	cltq   
  800421d62a:	48 c1 e0 03          	shl    $0x3,%rax
  800421d62e:	48 89 c1             	mov    %rax,%rcx
  800421d631:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d635:	48 01 c8             	add    %rcx,%rax
  800421d638:	48 01 d0             	add    %rdx,%rax
  800421d63b:	48 83 c0 08          	add    $0x8,%rax
  800421d63f:	48 8b 00             	mov    (%rax),%rax
  800421d642:	4c 8d a0 20 01 00 00 	lea    0x120(%rax),%r12
  800421d649:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d650:	00 00 00 
  800421d653:	ff d0                	callq  *%rax
  800421d655:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d65c:	00 00 00 
  800421d65f:	48 98                	cltq   
  800421d661:	48 c1 e0 03          	shl    $0x3,%rax
  800421d665:	48 89 c1             	mov    %rax,%rcx
  800421d668:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d66c:	48 01 c8             	add    %rcx,%rax
  800421d66f:	48 01 d0             	add    %rdx,%rax
  800421d672:	48 83 c0 08          	add    $0x8,%rax
  800421d676:	48 8b 00             	mov    (%rax),%rax
  800421d679:	48 89 da             	mov    %rbx,%rdx
  800421d67c:	4c 89 e6             	mov    %r12,%rsi
  800421d67f:	48 89 c7             	mov    %rax,%rdi
  800421d682:	48 b8 79 e9 21 04 80 	movabs $0x800421e979,%rax
  800421d689:	00 00 00 
  800421d68c:	ff d0                	callq  *%rax
  800421d68e:	88 45 ef             	mov    %al,-0x11(%rbp)
		curenv->env_pml4e);
		break;
  800421d691:	eb 5f                	jmp    800421d6f2 <vmexit+0x563>
	case EXIT_REASON_HLT:
		cprintf("\nHLT in guest, exiting guest.\n");
  800421d693:	48 bf 18 26 22 04 80 	movabs $0x8004222618,%rdi
  800421d69a:	00 00 00 
  800421d69d:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d6a2:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421d6a9:	00 00 00 
  800421d6ac:	ff d2                	callq  *%rdx
		env_destroy(curenv);
  800421d6ae:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d6b5:	00 00 00 
  800421d6b8:	ff d0                	callq  *%rax
  800421d6ba:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d6c1:	00 00 00 
  800421d6c4:	48 98                	cltq   
  800421d6c6:	48 c1 e0 03          	shl    $0x3,%rax
  800421d6ca:	48 89 c1             	mov    %rax,%rcx
  800421d6cd:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d6d1:	48 01 c8             	add    %rcx,%rax
  800421d6d4:	48 01 d0             	add    %rdx,%rax
  800421d6d7:	48 83 c0 08          	add    $0x8,%rax
  800421d6db:	48 8b 00             	mov    (%rax),%rax
  800421d6de:	48 89 c7             	mov    %rax,%rdi
  800421d6e1:	48 b8 9f 95 20 04 80 	movabs $0x800420959f,%rax
  800421d6e8:	00 00 00 
  800421d6eb:	ff d0                	callq  *%rax
		exit_handled = true;
  800421d6ed:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
		break;
  800421d6f1:	90                   	nop
	}
	if(!exit_handled) {
  800421d6f2:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800421d6f6:	83 f0 01             	xor    $0x1,%eax
  800421d6f9:	84 c0                	test   %al,%al
  800421d6fb:	74 6b                	je     800421d768 <vmexit+0x5d9>
		cprintf( "Unhandled VMEXIT, aborting guest.\n" );
  800421d6fd:	48 bf 38 26 22 04 80 	movabs $0x8004222638,%rdi
  800421d704:	00 00 00 
  800421d707:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d70c:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421d713:	00 00 00 
  800421d716:	ff d2                	callq  *%rdx
		vmcs_dump_cpu();
  800421d718:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d71d:	48 ba e8 bc 21 04 80 	movabs $0x800421bce8,%rdx
  800421d724:	00 00 00 
  800421d727:	ff d2                	callq  *%rdx
		env_destroy(curenv);
  800421d729:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d730:	00 00 00 
  800421d733:	ff d0                	callq  *%rax
  800421d735:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d73c:	00 00 00 
  800421d73f:	48 98                	cltq   
  800421d741:	48 c1 e0 03          	shl    $0x3,%rax
  800421d745:	48 89 c1             	mov    %rax,%rcx
  800421d748:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d74c:	48 01 c8             	add    %rcx,%rax
  800421d74f:	48 01 d0             	add    %rdx,%rax
  800421d752:	48 83 c0 08          	add    $0x8,%rax
  800421d756:	48 8b 00             	mov    (%rax),%rax
  800421d759:	48 89 c7             	mov    %rax,%rdi
  800421d75c:	48 b8 9f 95 20 04 80 	movabs $0x800420959f,%rax
  800421d763:	00 00 00 
  800421d766:	ff d0                	callq  *%rax
	}
	sched_yield();
  800421d768:	48 b8 16 da 20 04 80 	movabs $0x800420da16,%rax
  800421d76f:	00 00 00 
  800421d772:	ff d0                	callq  *%rax

000000800421d774 <asm_vmrun>:
}

void asm_vmrun(struct Trapframe *tf) {
  800421d774:	55                   	push   %rbp
  800421d775:	48 89 e5             	mov    %rsp,%rbp
  800421d778:	41 57                	push   %r15
  800421d77a:	41 56                	push   %r14
  800421d77c:	41 55                	push   %r13
  800421d77e:	41 54                	push   %r12
  800421d780:	53                   	push   %rbx
  800421d781:	48 83 ec 28          	sub    $0x28,%rsp
  800421d785:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
	// NOTE: Since we re-use Trapframe structure, tf.tf_err contains the value
	// of cr2 of the guest.
	//cprintf("asm_run %x\n",curenv->env_runs);
	tf->tf_ds = curenv->env_runs;
  800421d789:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d790:	00 00 00 
  800421d793:	ff d0                	callq  *%rax
  800421d795:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d79c:	00 00 00 
  800421d79f:	48 98                	cltq   
  800421d7a1:	48 c1 e0 03          	shl    $0x3,%rax
  800421d7a5:	48 89 c1             	mov    %rax,%rcx
  800421d7a8:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d7ac:	48 01 c8             	add    %rcx,%rax
  800421d7af:	48 01 d0             	add    %rdx,%rax
  800421d7b2:	48 83 c0 08          	add    $0x8,%rax
  800421d7b6:	48 8b 00             	mov    (%rax),%rax
  800421d7b9:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  800421d7bf:	89 c2                	mov    %eax,%edx
  800421d7c1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421d7c5:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
	tf->tf_es = 0;
  800421d7cc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421d7d0:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)
	unlock_kernel();
  800421d7d6:	48 b8 5c a1 21 04 80 	movabs $0x800421a15c,%rax
  800421d7dd:	00 00 00 
  800421d7e0:	ff d0                	callq  *%rax
	//vmcs_dump_cpu();
	asm(
  800421d7e2:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  800421d7e6:	ba 14 6c 00 00       	mov    $0x6c14,%edx
  800421d7eb:	52                   	push   %rdx
  800421d7ec:	55                   	push   %rbp
  800421d7ed:	51                   	push   %rcx
  800421d7ee:	51                   	push   %rcx
  800421d7ef:	0f 79 d4             	vmwrite %rsp,%rdx
  800421d7f2:	48 8b 81 90 00 00 00 	mov    0x90(%rcx),%rax
  800421d7f9:	0f 20 d2             	mov    %cr2,%rdx
  800421d7fc:	66 39 c2             	cmp    %ax,%dx
  800421d7ff:	74 03                	je     800421d804 <asm_vmrun+0x90>
  800421d801:	0f 22 d0             	mov    %rax,%cr2
  800421d804:	48 8b 81 80 00 00 00 	mov    0x80(%rcx),%rax
  800421d80b:	48 c7 c2 01 00 00 00 	mov    $0x1,%rdx
  800421d812:	48 39 d0             	cmp    %rdx,%rax
  800421d815:	75 54                	jne    800421d86b <asm_vmrun+0xf7>
  800421d817:	48 89 cc             	mov    %rcx,%rsp
  800421d81a:	4c 8b 3c 24          	mov    (%rsp),%r15
  800421d81e:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  800421d823:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  800421d828:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  800421d82d:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  800421d832:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  800421d837:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  800421d83c:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  800421d841:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  800421d846:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  800421d84b:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  800421d850:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  800421d855:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800421d85a:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  800421d85f:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800421d864:	48 83 c4 78          	add    $0x78,%rsp
  800421d868:	0f 01 c2             	vmlaunch 
  800421d86b:	48 89 cc             	mov    %rcx,%rsp
  800421d86e:	4c 8b 3c 24          	mov    (%rsp),%r15
  800421d872:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  800421d877:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  800421d87c:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  800421d881:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  800421d886:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  800421d88b:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  800421d890:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  800421d895:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  800421d89a:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  800421d89f:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  800421d8a4:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  800421d8a9:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800421d8ae:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  800421d8b3:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800421d8b8:	48 83 c4 78          	add    $0x78,%rsp
  800421d8bc:	0f 01 c3             	vmresume 
  800421d8bf:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  800421d8c4:	59                   	pop    %rcx
  800421d8c5:	48 89 41 70          	mov    %rax,0x70(%rcx)
  800421d8c9:	48 89 59 68          	mov    %rbx,0x68(%rcx)
  800421d8cd:	48 89 51 58          	mov    %rdx,0x58(%rcx)
  800421d8d1:	48 89 69 50          	mov    %rbp,0x50(%rcx)
  800421d8d5:	48 89 79 48          	mov    %rdi,0x48(%rcx)
  800421d8d9:	48 89 71 40          	mov    %rsi,0x40(%rcx)
  800421d8dd:	4c 89 41 38          	mov    %r8,0x38(%rcx)
  800421d8e1:	4c 89 49 30          	mov    %r9,0x30(%rcx)
  800421d8e5:	4c 89 51 28          	mov    %r10,0x28(%rcx)
  800421d8e9:	4c 89 59 20          	mov    %r11,0x20(%rcx)
  800421d8ed:	4c 89 61 18          	mov    %r12,0x18(%rcx)
  800421d8f1:	4c 89 69 10          	mov    %r13,0x10(%rcx)
  800421d8f5:	4c 89 71 08          	mov    %r14,0x8(%rcx)
  800421d8f9:	4c 89 39             	mov    %r15,(%rcx)
  800421d8fc:	0f 20 d0             	mov    %cr2,%rax
  800421d8ff:	48 89 81 90 00 00 00 	mov    %rax,0x90(%rcx)
  800421d906:	58                   	pop    %rax
  800421d907:	48 89 41 60          	mov    %rax,0x60(%rcx)
  800421d90b:	5d                   	pop    %rbp
  800421d90c:	5a                   	pop    %rdx
  800421d90d:	0f 96 41 78          	setbe  0x78(%rcx)
		  [wordsize]"i"(sizeof(uint64_t)) 
                : "cc", "memory"
		  , "rax", "rbx", "rdi", "rsi"
		  , "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
	);
	lock_kernel();
  800421d911:	48 b8 3f a1 21 04 80 	movabs $0x800421a13f,%rax
  800421d918:	00 00 00 
  800421d91b:	ff d0                	callq  *%rax
	if(tf->tf_es) {
  800421d91d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421d921:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800421d925:	66 85 c0             	test   %ax,%ax
  800421d928:	74 20                	je     800421d94a <asm_vmrun+0x1d6>
		cprintf("Error during VMLAUNCH/VMRESUME\n");
  800421d92a:	48 bf e8 27 22 04 80 	movabs $0x80042227e8,%rdi
  800421d931:	00 00 00 
  800421d934:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d939:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421d940:	00 00 00 
  800421d943:	ff d2                	callq  *%rdx
	} else {
		curenv->env_tf.tf_rsp = vmcs_read64(VMCS_GUEST_RSP);
		curenv->env_tf.tf_rip = vmcs_read64(VMCS_GUEST_RIP);
		vmexit();
	}
}
  800421d945:	e9 af 00 00 00       	jmpq   800421d9f9 <asm_vmrun+0x285>
	);
	lock_kernel();
	if(tf->tf_es) {
		cprintf("Error during VMLAUNCH/VMRESUME\n");
	} else {
		curenv->env_tf.tf_rsp = vmcs_read64(VMCS_GUEST_RSP);
  800421d94a:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d951:	00 00 00 
  800421d954:	ff d0                	callq  *%rax
  800421d956:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d95d:	00 00 00 
  800421d960:	48 98                	cltq   
  800421d962:	48 c1 e0 03          	shl    $0x3,%rax
  800421d966:	48 89 c1             	mov    %rax,%rcx
  800421d969:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d96d:	48 01 c8             	add    %rcx,%rax
  800421d970:	48 01 d0             	add    %rdx,%rax
  800421d973:	48 83 c0 08          	add    $0x8,%rax
  800421d977:	48 8b 18             	mov    (%rax),%rbx
  800421d97a:	c7 45 cc 1c 68 00 00 	movl   $0x681c,-0x34(%rbp)
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421d981:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421d984:	89 c7                	mov    %eax,%edi
  800421d986:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421d98d:	00 00 00 
  800421d990:	ff d0                	callq  *%rax
  800421d992:	48 89 83 b0 00 00 00 	mov    %rax,0xb0(%rbx)
		curenv->env_tf.tf_rip = vmcs_read64(VMCS_GUEST_RIP);
  800421d999:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421d9a0:	00 00 00 
  800421d9a3:	ff d0                	callq  *%rax
  800421d9a5:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421d9ac:	00 00 00 
  800421d9af:	48 98                	cltq   
  800421d9b1:	48 c1 e0 03          	shl    $0x3,%rax
  800421d9b5:	48 89 c1             	mov    %rax,%rcx
  800421d9b8:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d9bc:	48 01 c8             	add    %rcx,%rax
  800421d9bf:	48 01 d0             	add    %rdx,%rax
  800421d9c2:	48 83 c0 08          	add    $0x8,%rax
  800421d9c6:	48 8b 18             	mov    (%rax),%rbx
  800421d9c9:	c7 45 c8 1e 68 00 00 	movl   $0x681e,-0x38(%rbp)
  800421d9d0:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421d9d3:	89 c7                	mov    %eax,%edi
  800421d9d5:	48 b8 d5 9f 21 04 80 	movabs $0x8004219fd5,%rax
  800421d9dc:	00 00 00 
  800421d9df:	ff d0                	callq  *%rax
  800421d9e1:	48 89 83 98 00 00 00 	mov    %rax,0x98(%rbx)
		vmexit();
  800421d9e8:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d9ed:	48 ba 8f d1 21 04 80 	movabs $0x800421d18f,%rdx
  800421d9f4:	00 00 00 
  800421d9f7:	ff d2                	callq  *%rdx
	}
}
  800421d9f9:	90                   	nop
  800421d9fa:	48 83 c4 28          	add    $0x28,%rsp
  800421d9fe:	5b                   	pop    %rbx
  800421d9ff:	41 5c                	pop    %r12
  800421da01:	41 5d                	pop    %r13
  800421da03:	41 5e                	pop    %r14
  800421da05:	41 5f                	pop    %r15
  800421da07:	5d                   	pop    %rbp
  800421da08:	c3                   	retq   

000000800421da09 <msr_setup>:

void
msr_setup(struct VmxGuestInfo *ginfo) {
  800421da09:	55                   	push   %rbp
  800421da0a:	48 89 e5             	mov    %rsp,%rbp
  800421da0d:	48 83 ec 40          	sub    $0x40,%rsp
  800421da11:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	struct vmx_msr_entry *entry;
	uint32_t idx[] = { EFER_MSR };
  800421da15:	c7 45 d0 80 00 00 c0 	movl   $0xc0000080,-0x30(%rbp)
	int i, count = sizeof(idx) / sizeof(idx[0]);
  800421da1c:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%rbp)

	assert(count <= MAX_MSR_COUNT);
  800421da23:	81 7d f8 80 00 00 00 	cmpl   $0x80,-0x8(%rbp)
  800421da2a:	7e 35                	jle    800421da61 <msr_setup+0x58>
  800421da2c:	48 b9 08 28 22 04 80 	movabs $0x8004222808,%rcx
  800421da33:	00 00 00 
  800421da36:	48 ba e8 1f 22 04 80 	movabs $0x8004221fe8,%rdx
  800421da3d:	00 00 00 
  800421da40:	be 1a 03 00 00       	mov    $0x31a,%esi
  800421da45:	48 bf fd 1f 22 04 80 	movabs $0x8004221ffd,%rdi
  800421da4c:	00 00 00 
  800421da4f:	b8 00 00 00 00       	mov    $0x0,%eax
  800421da54:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421da5b:	00 00 00 
  800421da5e:	41 ff d0             	callq  *%r8
	ginfo->msr_count = count;
  800421da61:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421da65:	8b 55 f8             	mov    -0x8(%rbp),%edx
  800421da68:	89 50 28             	mov    %edx,0x28(%rax)
    
	for(i=0; i<count; ++i) {
  800421da6b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421da72:	e9 94 00 00 00       	jmpq   800421db0b <msr_setup+0x102>
		entry = ((struct vmx_msr_entry *)ginfo->msr_host_area) + i;
  800421da77:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421da7b:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421da7f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800421da82:	48 63 d2             	movslq %edx,%rdx
  800421da85:	48 c1 e2 04          	shl    $0x4,%rdx
  800421da89:	48 01 d0             	add    %rdx,%rax
  800421da8c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		entry->msr_index = idx[i];
  800421da90:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421da93:	48 98                	cltq   
  800421da95:	8b 54 85 d0          	mov    -0x30(%rbp,%rax,4),%edx
  800421da99:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421da9d:	89 10                	mov    %edx,(%rax)
		entry->msr_value = read_msr(idx[i]);
  800421da9f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421daa2:	48 98                	cltq   
  800421daa4:	8b 44 85 d0          	mov    -0x30(%rbp,%rax,4),%eax
  800421daa8:	89 45 ec             	mov    %eax,-0x14(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421daab:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421daae:	89 c1                	mov    %eax,%ecx
  800421dab0:	0f 32                	rdmsr  
  800421dab2:	89 55 e8             	mov    %edx,-0x18(%rbp)
  800421dab5:	89 45 e4             	mov    %eax,-0x1c(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421dab8:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  800421dabf:	00 
	ret = edx;
  800421dac0:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421dac3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	ret = ret << 32;
  800421dac7:	48 c1 65 d8 20       	shlq   $0x20,-0x28(%rbp)
	ret |= eax;
  800421dacc:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421dacf:	48 09 45 d8          	or     %rax,-0x28(%rbp)

	return ret;
  800421dad3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421dad7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421dadb:	48 89 50 08          	mov    %rdx,0x8(%rax)
        
		entry = ((struct vmx_msr_entry *)ginfo->msr_guest_area) + i;
  800421dadf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421dae3:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421dae7:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800421daea:	48 63 d2             	movslq %edx,%rdx
  800421daed:	48 c1 e2 04          	shl    $0x4,%rdx
  800421daf1:	48 01 d0             	add    %rdx,%rax
  800421daf4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		entry->msr_index = idx[i];
  800421daf8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421dafb:	48 98                	cltq   
  800421dafd:	8b 54 85 d0          	mov    -0x30(%rbp,%rax,4),%edx
  800421db01:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421db05:	89 10                	mov    %edx,(%rax)
	int i, count = sizeof(idx) / sizeof(idx[0]);

	assert(count <= MAX_MSR_COUNT);
	ginfo->msr_count = count;
    
	for(i=0; i<count; ++i) {
  800421db07:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421db0b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421db0e:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  800421db11:	0f 8c 60 ff ff ff    	jl     800421da77 <msr_setup+0x6e>
		entry->msr_value = read_msr(idx[i]);
        
		entry = ((struct vmx_msr_entry *)ginfo->msr_guest_area) + i;
		entry->msr_index = idx[i];
	}
}
  800421db17:	90                   	nop
  800421db18:	c9                   	leaveq 
  800421db19:	c3                   	retq   

000000800421db1a <bitmap_setup>:

void
bitmap_setup(struct VmxGuestInfo *ginfo) {
  800421db1a:	55                   	push   %rbp
  800421db1b:	48 89 e5             	mov    %rsp,%rbp
  800421db1e:	48 83 ec 30          	sub    $0x30,%rsp
  800421db22:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)

	unsigned int io_ports[] = { IO_RTC, IO_RTC+1 };
  800421db26:	c7 45 e0 70 00 00 00 	movl   $0x70,-0x20(%rbp)
  800421db2d:	c7 45 e4 71 00 00 00 	movl   $0x71,-0x1c(%rbp)

	int i, count = sizeof(io_ports) / sizeof(io_ports[0]);
  800421db34:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%rbp)
    
	for(i=0; i<count; ++i) {
  800421db3b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421db42:	e9 07 01 00 00       	jmpq   800421dc4e <bitmap_setup+0x134>
		int idx = io_ports[i] / (sizeof(uint64_t) * 8);
  800421db47:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421db4a:	48 98                	cltq   
  800421db4c:	8b 44 85 e0          	mov    -0x20(%rbp,%rax,4),%eax
  800421db50:	c1 e8 06             	shr    $0x6,%eax
  800421db53:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if(io_ports[i] < 0x7FFF) {
  800421db56:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421db59:	48 98                	cltq   
  800421db5b:	8b 44 85 e0          	mov    -0x20(%rbp,%rax,4),%eax
  800421db5f:	3d fe 7f 00 00       	cmp    $0x7ffe,%eax
  800421db64:	77 51                	ja     800421dbb7 <bitmap_setup+0x9d>
			ginfo->io_bmap_a[idx] |= ((0x1uL << (io_ports[i] & 0x3F)));
  800421db66:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421db6a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421db6e:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421db71:	48 63 d2             	movslq %edx,%rdx
  800421db74:	48 c1 e2 03          	shl    $0x3,%rdx
  800421db78:	48 01 c2             	add    %rax,%rdx
  800421db7b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421db7f:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421db83:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  800421db86:	48 63 c9             	movslq %ecx,%rcx
  800421db89:	48 c1 e1 03          	shl    $0x3,%rcx
  800421db8d:	48 01 c8             	add    %rcx,%rax
  800421db90:	48 8b 30             	mov    (%rax),%rsi
  800421db93:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421db96:	48 98                	cltq   
  800421db98:	8b 44 85 e0          	mov    -0x20(%rbp,%rax,4),%eax
  800421db9c:	83 e0 3f             	and    $0x3f,%eax
  800421db9f:	bf 01 00 00 00       	mov    $0x1,%edi
  800421dba4:	89 c1                	mov    %eax,%ecx
  800421dba6:	48 d3 e7             	shl    %cl,%rdi
  800421dba9:	48 89 f8             	mov    %rdi,%rax
  800421dbac:	48 09 f0             	or     %rsi,%rax
  800421dbaf:	48 89 02             	mov    %rax,(%rdx)
  800421dbb2:	e9 93 00 00 00       	jmpq   800421dc4a <bitmap_setup+0x130>
		} else if (io_ports[i] < 0xFFFF) {
  800421dbb7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421dbba:	48 98                	cltq   
  800421dbbc:	8b 44 85 e0          	mov    -0x20(%rbp,%rax,4),%eax
  800421dbc0:	3d fe ff 00 00       	cmp    $0xfffe,%eax
  800421dbc5:	77 4e                	ja     800421dc15 <bitmap_setup+0xfb>
			ginfo->io_bmap_b[idx] |= ((0x1uL << (io_ports[i] & 0x3F)));
  800421dbc7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421dbcb:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421dbcf:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421dbd2:	48 63 d2             	movslq %edx,%rdx
  800421dbd5:	48 c1 e2 03          	shl    $0x3,%rdx
  800421dbd9:	48 01 c2             	add    %rax,%rdx
  800421dbdc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421dbe0:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421dbe4:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  800421dbe7:	48 63 c9             	movslq %ecx,%rcx
  800421dbea:	48 c1 e1 03          	shl    $0x3,%rcx
  800421dbee:	48 01 c8             	add    %rcx,%rax
  800421dbf1:	48 8b 30             	mov    (%rax),%rsi
  800421dbf4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421dbf7:	48 98                	cltq   
  800421dbf9:	8b 44 85 e0          	mov    -0x20(%rbp,%rax,4),%eax
  800421dbfd:	83 e0 3f             	and    $0x3f,%eax
  800421dc00:	bf 01 00 00 00       	mov    $0x1,%edi
  800421dc05:	89 c1                	mov    %eax,%ecx
  800421dc07:	48 d3 e7             	shl    %cl,%rdi
  800421dc0a:	48 89 f8             	mov    %rdi,%rax
  800421dc0d:	48 09 f0             	or     %rsi,%rax
  800421dc10:	48 89 02             	mov    %rax,(%rdx)
  800421dc13:	eb 35                	jmp    800421dc4a <bitmap_setup+0x130>
		} else {
			assert(false);
  800421dc15:	48 b9 e2 1f 22 04 80 	movabs $0x8004221fe2,%rcx
  800421dc1c:	00 00 00 
  800421dc1f:	48 ba e8 1f 22 04 80 	movabs $0x8004221fe8,%rdx
  800421dc26:	00 00 00 
  800421dc29:	be 35 03 00 00       	mov    $0x335,%esi
  800421dc2e:	48 bf fd 1f 22 04 80 	movabs $0x8004221ffd,%rdi
  800421dc35:	00 00 00 
  800421dc38:	b8 00 00 00 00       	mov    $0x0,%eax
  800421dc3d:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421dc44:	00 00 00 
  800421dc47:	41 ff d0             	callq  *%r8

	unsigned int io_ports[] = { IO_RTC, IO_RTC+1 };

	int i, count = sizeof(io_ports) / sizeof(io_ports[0]);
    
	for(i=0; i<count; ++i) {
  800421dc4a:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421dc4e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421dc51:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  800421dc54:	0f 8c ed fe ff ff    	jl     800421db47 <bitmap_setup+0x2d>
			ginfo->io_bmap_b[idx] |= ((0x1uL << (io_ports[i] & 0x3F)));
		} else {
			assert(false);
		}
	}
}
  800421dc5a:	90                   	nop
  800421dc5b:	c9                   	leaveq 
  800421dc5c:	c3                   	retq   

000000800421dc5d <vmx_vmrun>:

/* 
 * Processor must be in VMX root operation before executing this function.
 */
int vmx_vmrun( struct Env *e ) {
  800421dc5d:	55                   	push   %rbp
  800421dc5e:	48 89 e5             	mov    %rsp,%rbp
  800421dc61:	48 83 ec 70          	sub    $0x70,%rsp
  800421dc65:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
	if ( e->env_type != ENV_TYPE_GUEST ) {
  800421dc69:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421dc6d:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800421dc73:	83 f8 03             	cmp    $0x3,%eax
  800421dc76:	74 0a                	je     800421dc82 <vmx_vmrun+0x25>
		return -E_INVAL;
  800421dc78:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800421dc7d:	e9 9a 02 00 00       	jmpq   800421df1c <vmx_vmrun+0x2bf>
	}
	uint8_t error;
	if( e->env_runs == 1 ) {
  800421dc82:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421dc86:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  800421dc8c:	83 f8 01             	cmp    $0x1,%eax
  800421dc8f:	0f 85 2f 01 00 00    	jne    800421ddc4 <vmx_vmrun+0x167>
		physaddr_t vmcs_phy_addr = PADDR(e->env_vmxinfo.vmcs);
  800421dc95:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421dc99:	48 8b 80 28 01 00 00 	mov    0x128(%rax),%rax
  800421dca0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421dca4:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421dcab:	00 00 00 
  800421dcae:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421dcb2:	77 32                	ja     800421dce6 <vmx_vmrun+0x89>
  800421dcb4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421dcb8:	48 89 c1             	mov    %rax,%rcx
  800421dcbb:	48 ba 78 20 22 04 80 	movabs $0x8004222078,%rdx
  800421dcc2:	00 00 00 
  800421dcc5:	be 43 03 00 00       	mov    $0x343,%esi
  800421dcca:	48 bf fd 1f 22 04 80 	movabs $0x8004221ffd,%rdi
  800421dcd1:	00 00 00 
  800421dcd4:	b8 00 00 00 00       	mov    $0x0,%eax
  800421dcd9:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421dce0:	00 00 00 
  800421dce3:	41 ff d0             	callq  *%r8
  800421dce6:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421dced:	ff ff ff 
  800421dcf0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421dcf4:	48 01 d0             	add    %rdx,%rax
  800421dcf7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800421dcfb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421dcff:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
}

static __inline uint8_t
vmclear( physaddr_t vmcs_region ) {
	uint8_t error = 0;
  800421dd03:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)

    __asm __volatile("clc; vmclear %1; setna %0"
  800421dd07:	f8                   	clc    
  800421dd08:	66 0f c7 75 a8       	vmclear -0x58(%rbp)
  800421dd0d:	0f 96 c0             	setbe  %al
  800421dd10:	88 45 d7             	mov    %al,-0x29(%rbp)
            : "=q"( error ) : "m" ( vmcs_region ) : "cc");
    return error;
  800421dd13:	0f b6 45 d7          	movzbl -0x29(%rbp),%eax

		// Call VMCLEAR on the VMCS region.
		error = vmclear(vmcs_phy_addr);
  800421dd17:	88 45 ee             	mov    %al,-0x12(%rbp)
		// Check if VMCLEAR succeeded. ( RFLAGS.CF = 0 and RFLAGS.ZF = 0 )
		if ( error )
  800421dd1a:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  800421dd1e:	74 0a                	je     800421dd2a <vmx_vmrun+0xcd>
			return -E_VMCS_INIT; 
  800421dd20:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
  800421dd25:	e9 f2 01 00 00       	jmpq   800421df1c <vmx_vmrun+0x2bf>
  800421dd2a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421dd2e:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
}

static __inline uint8_t
vmptrld( physaddr_t vmcs_region ) {
	uint8_t error = 0;
  800421dd32:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    __asm __volatile("clc; vmptrld %1; setna %0"
  800421dd36:	f8                   	clc    
  800421dd37:	0f c7 75 b0          	vmptrld -0x50(%rbp)
  800421dd3b:	0f 96 c0             	setbe  %al
  800421dd3e:	88 45 ef             	mov    %al,-0x11(%rbp)
            : "=q"( error ) : "m" ( vmcs_region ) : "cc");
    return error;
  800421dd41:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax

		// Make this VMCS working VMCS.
		error = vmptrld(vmcs_phy_addr);
  800421dd45:	88 45 ee             	mov    %al,-0x12(%rbp)
		if ( error )
  800421dd48:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  800421dd4c:	74 0a                	je     800421dd58 <vmx_vmrun+0xfb>
			return -E_VMCS_INIT; 
  800421dd4e:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
  800421dd53:	e9 c4 01 00 00       	jmpq   800421df1c <vmx_vmrun+0x2bf>

		vmcs_host_init();
  800421dd58:	b8 00 00 00 00       	mov    $0x0,%eax
  800421dd5d:	48 ba 41 aa 21 04 80 	movabs $0x800421aa41,%rdx
  800421dd64:	00 00 00 
  800421dd67:	ff d2                	callq  *%rdx
		vmcs_guest_init();
  800421dd69:	b8 00 00 00 00       	mov    $0x0,%eax
  800421dd6e:	48 ba 10 ae 21 04 80 	movabs $0x800421ae10,%rdx
  800421dd75:	00 00 00 
  800421dd78:	ff d2                	callq  *%rdx
		// Setup IO and exception bitmaps.
		bitmap_setup(&e->env_vmxinfo);
  800421dd7a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421dd7e:	48 05 20 01 00 00    	add    $0x120,%rax
  800421dd84:	48 89 c7             	mov    %rax,%rdi
  800421dd87:	48 b8 1a db 21 04 80 	movabs $0x800421db1a,%rax
  800421dd8e:	00 00 00 
  800421dd91:	ff d0                	callq  *%rax
		// Setup the msr load/store area
		msr_setup(&e->env_vmxinfo);
  800421dd93:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421dd97:	48 05 20 01 00 00    	add    $0x120,%rax
  800421dd9d:	48 89 c7             	mov    %rax,%rdi
  800421dda0:	48 b8 09 da 21 04 80 	movabs $0x800421da09,%rax
  800421dda7:	00 00 00 
  800421ddaa:	ff d0                	callq  *%rax
		vmcs_ctls_init(e);
  800421ddac:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421ddb0:	48 89 c7             	mov    %rax,%rdi
  800421ddb3:	48 b8 87 b6 21 04 80 	movabs $0x800421b687,%rax
  800421ddba:	00 00 00 
  800421ddbd:	ff d0                	callq  *%rax
  800421ddbf:	e9 8c 00 00 00       	jmpq   800421de50 <vmx_vmrun+0x1f3>

		/* ept_alloc_static(e->env_pml4e, &e->env_vmxinfo); */

	} else {
		// Make this VMCS working VMCS.
		error = vmptrld(PADDR(e->env_vmxinfo.vmcs));
  800421ddc4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421ddc8:	48 8b 80 28 01 00 00 	mov    0x128(%rax),%rax
  800421ddcf:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800421ddd3:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421ddda:	00 00 00 
  800421dddd:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  800421dde1:	77 32                	ja     800421de15 <vmx_vmrun+0x1b8>
  800421dde3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421dde7:	48 89 c1             	mov    %rax,%rcx
  800421ddea:	48 ba 78 20 22 04 80 	movabs $0x8004222078,%rdx
  800421ddf1:	00 00 00 
  800421ddf4:	be 5c 03 00 00       	mov    $0x35c,%esi
  800421ddf9:	48 bf fd 1f 22 04 80 	movabs $0x8004221ffd,%rdi
  800421de00:	00 00 00 
  800421de03:	b8 00 00 00 00       	mov    $0x0,%eax
  800421de08:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421de0f:	00 00 00 
  800421de12:	41 ff d0             	callq  *%r8
  800421de15:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421de1c:	ff ff ff 
  800421de1f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421de23:	48 01 d0             	add    %rdx,%rax
  800421de26:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    return error;
}

static __inline uint8_t
vmptrld( physaddr_t vmcs_region ) {
	uint8_t error = 0;
  800421de2a:	c6 45 ed 00          	movb   $0x0,-0x13(%rbp)

    __asm __volatile("clc; vmptrld %1; setna %0"
  800421de2e:	f8                   	clc    
  800421de2f:	0f c7 75 b8          	vmptrld -0x48(%rbp)
  800421de33:	0f 96 c0             	setbe  %al
  800421de36:	88 45 ed             	mov    %al,-0x13(%rbp)
            : "=q"( error ) : "m" ( vmcs_region ) : "cc");
    return error;
  800421de39:	0f b6 45 ed          	movzbl -0x13(%rbp),%eax
  800421de3d:	88 45 ee             	mov    %al,-0x12(%rbp)
		if ( error ) {
  800421de40:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  800421de44:	74 0a                	je     800421de50 <vmx_vmrun+0x1f3>
			return -E_VMCS_INIT; 
  800421de46:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
  800421de4b:	e9 cc 00 00 00       	jmpq   800421df1c <vmx_vmrun+0x2bf>
		}
	}

	vmcs_write64( VMCS_GUEST_RSP, curenv->env_tf.tf_rsp  );
  800421de50:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421de57:	00 00 00 
  800421de5a:	ff d0                	callq  *%rax
  800421de5c:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421de63:	00 00 00 
  800421de66:	48 98                	cltq   
  800421de68:	48 c1 e0 03          	shl    $0x3,%rax
  800421de6c:	48 89 c1             	mov    %rax,%rcx
  800421de6f:	48 c1 e1 04          	shl    $0x4,%rcx
  800421de73:	48 01 c8             	add    %rcx,%rax
  800421de76:	48 01 d0             	add    %rdx,%rax
  800421de79:	48 83 c0 08          	add    $0x8,%rax
  800421de7d:	48 8b 00             	mov    (%rax),%rax
  800421de80:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800421de87:	c7 45 d8 1c 68 00 00 	movl   $0x681c,-0x28(%rbp)
  800421de8e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421de92:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421de96:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421de99:	48 89 d6             	mov    %rdx,%rsi
  800421de9c:	89 c7                	mov    %eax,%edi
  800421de9e:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421dea5:	00 00 00 
  800421dea8:	ff d0                	callq  *%rax
	vmcs_write64( VMCS_GUEST_RIP, curenv->env_tf.tf_rip );
  800421deaa:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421deb1:	00 00 00 
  800421deb4:	ff d0                	callq  *%rax
  800421deb6:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421debd:	00 00 00 
  800421dec0:	48 98                	cltq   
  800421dec2:	48 c1 e0 03          	shl    $0x3,%rax
  800421dec6:	48 89 c1             	mov    %rax,%rcx
  800421dec9:	48 c1 e1 04          	shl    $0x4,%rcx
  800421decd:	48 01 c8             	add    %rcx,%rax
  800421ded0:	48 01 d0             	add    %rdx,%rax
  800421ded3:	48 83 c0 08          	add    $0x8,%rax
  800421ded7:	48 8b 00             	mov    (%rax),%rax
  800421deda:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800421dee1:	c7 45 dc 1e 68 00 00 	movl   $0x681e,-0x24(%rbp)
  800421dee8:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  800421deec:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421def0:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421def3:	48 89 d6             	mov    %rdx,%rsi
  800421def6:	89 c7                	mov    %eax,%edi
  800421def8:	48 b8 af 9f 21 04 80 	movabs $0x8004219faf,%rax
  800421deff:	00 00 00 
  800421df02:	ff d0                	callq  *%rax
	asm_vmrun( &e->env_tf );    
  800421df04:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421df08:	48 89 c7             	mov    %rax,%rdi
  800421df0b:	48 b8 74 d7 21 04 80 	movabs $0x800421d774,%rax
  800421df12:	00 00 00 
  800421df15:	ff d0                	callq  *%rax
	return 0;
  800421df17:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421df1c:	c9                   	leaveq 
  800421df1d:	c3                   	retq   

000000800421df1e <vmcs_writel>:
#define IA32_VMX_EPT_VPID_CAP 0x48C
#define IA32_FEATURE_CONTROL 0x03A

#define BIT( val, x ) ( ( val >> x ) & 0x1 )

static __inline uint8_t vmcs_writel( uint32_t field, uint64_t value) {
  800421df1e:	55                   	push   %rbp
  800421df1f:	48 89 e5             	mov    %rsp,%rbp
  800421df22:	48 83 ec 20          	sub    $0x20,%rsp
  800421df26:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800421df29:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint8_t error;

	__asm __volatile ( "clc; vmwrite %%rax, %%rdx; setna %0"
  800421df2d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421df31:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421df34:	f8                   	clc    
  800421df35:	0f 79 d0             	vmwrite %rax,%rdx
  800421df38:	0f 96 c0             	setbe  %al
  800421df3b:	88 45 ff             	mov    %al,-0x1(%rbp)
		       : "=q"( error ) : "a"( value ), "d"( field ) : "cc");
    return error;
  800421df3e:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  800421df42:	c9                   	leaveq 
  800421df43:	c3                   	retq   

000000800421df44 <vmcs_readl>:
static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
}

static __inline uint64_t vmcs_readl(uint32_t field)
{
  800421df44:	55                   	push   %rbp
  800421df45:	48 89 e5             	mov    %rsp,%rbp
  800421df48:	48 83 ec 18          	sub    $0x18,%rsp
  800421df4c:	89 7d ec             	mov    %edi,-0x14(%rbp)
	uint64_t value;

	__asm __volatile ( "vmread %%rdx, %%rax;"
  800421df4f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421df52:	89 c2                	mov    %eax,%edx
  800421df54:	0f 78 d0             	vmread %rdx,%rax
  800421df57:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		      : "=a"(value) : "d"(field) : "cc");
	return value;
  800421df5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421df5f:	c9                   	leaveq 
  800421df60:	c3                   	retq   

000000800421df61 <cpuid>:

#define read_rip(var) __asm __volatile("leaq (%%rip), %0" : "=r" (var)::"cc","memory")

static __inline void
cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)
{
  800421df61:	55                   	push   %rbp
  800421df62:	48 89 e5             	mov    %rsp,%rbp
  800421df65:	53                   	push   %rbx
  800421df66:	48 83 ec 38          	sub    $0x38,%rsp
  800421df6a:	89 7d e4             	mov    %edi,-0x1c(%rbp)
  800421df6d:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  800421df71:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800421df75:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  800421df79:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
	uint32_t eax, ebx, ecx, edx;
	asm volatile("cpuid" 
  800421df7d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421df80:	0f a2                	cpuid  
  800421df82:	89 de                	mov    %ebx,%esi
  800421df84:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800421df87:	89 75 f0             	mov    %esi,-0x10(%rbp)
  800421df8a:	89 4d ec             	mov    %ecx,-0x14(%rbp)
  800421df8d:	89 55 e8             	mov    %edx,-0x18(%rbp)
			 : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
			 : "a" (info));
	if (eaxp)
  800421df90:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421df95:	74 09                	je     800421dfa0 <cpuid+0x3f>
		*eaxp = eax;
  800421df97:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421df9b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421df9e:	89 10                	mov    %edx,(%rax)
	if (ebxp)
  800421dfa0:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800421dfa5:	74 09                	je     800421dfb0 <cpuid+0x4f>
		*ebxp = ebx;
  800421dfa7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421dfab:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800421dfae:	89 10                	mov    %edx,(%rax)
	if (ecxp)
  800421dfb0:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800421dfb5:	74 09                	je     800421dfc0 <cpuid+0x5f>
		*ecxp = ecx;
  800421dfb7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421dfbb:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421dfbe:	89 10                	mov    %edx,(%rax)
	if (edxp)
  800421dfc0:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800421dfc5:	74 09                	je     800421dfd0 <cpuid+0x6f>
		*edxp = edx;
  800421dfc7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421dfcb:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800421dfce:	89 10                	mov    %edx,(%rax)
}
  800421dfd0:	90                   	nop
  800421dfd1:	48 83 c4 38          	add    $0x38,%rsp
  800421dfd5:	5b                   	pop    %rbx
  800421dfd6:	5d                   	pop    %rbp
  800421dfd7:	c3                   	retq   

000000800421dfd8 <page2ppn>:
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);


static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  800421dfd8:	55                   	push   %rbp
  800421dfd9:	48 89 e5             	mov    %rsp,%rbp
  800421dfdc:	48 83 ec 08          	sub    $0x8,%rsp
  800421dfe0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  800421dfe4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421dfe8:	48 b8 00 c6 6d 04 80 	movabs $0x80046dc600,%rax
  800421dfef:	00 00 00 
  800421dff2:	48 8b 00             	mov    (%rax),%rax
  800421dff5:	48 29 c2             	sub    %rax,%rdx
  800421dff8:	48 89 d0             	mov    %rdx,%rax
  800421dffb:	48 c1 f8 04          	sar    $0x4,%rax
}
  800421dfff:	c9                   	leaveq 
  800421e000:	c3                   	retq   

000000800421e001 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  800421e001:	55                   	push   %rbp
  800421e002:	48 89 e5             	mov    %rsp,%rbp
  800421e005:	48 83 ec 08          	sub    $0x8,%rsp
  800421e009:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  800421e00d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421e011:	48 89 c7             	mov    %rax,%rdi
  800421e014:	48 b8 d8 df 21 04 80 	movabs $0x800421dfd8,%rax
  800421e01b:	00 00 00 
  800421e01e:	ff d0                	callq  *%rax
  800421e020:	48 c1 e0 0c          	shl    $0xc,%rax
}
  800421e024:	c9                   	leaveq 
  800421e025:	c3                   	retq   

000000800421e026 <page2kva>:
	return &pages[PPN(pa)];
}

static inline void*
page2kva(struct PageInfo *pp)
{
  800421e026:	55                   	push   %rbp
  800421e027:	48 89 e5             	mov    %rsp,%rbp
  800421e02a:	48 83 ec 20          	sub    $0x20,%rsp
  800421e02e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  800421e032:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421e036:	48 89 c7             	mov    %rax,%rdi
  800421e039:	48 b8 01 e0 21 04 80 	movabs $0x800421e001,%rax
  800421e040:	00 00 00 
  800421e043:	ff d0                	callq  *%rax
  800421e045:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421e049:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421e04d:	48 c1 e8 0c          	shr    $0xc,%rax
  800421e051:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800421e054:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421e057:	48 b8 f8 c5 6d 04 80 	movabs $0x80046dc5f8,%rax
  800421e05e:	00 00 00 
  800421e061:	48 8b 00             	mov    (%rax),%rax
  800421e064:	48 39 c2             	cmp    %rax,%rdx
  800421e067:	72 32                	jb     800421e09b <page2kva+0x75>
  800421e069:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421e06d:	48 89 c1             	mov    %rax,%rcx
  800421e070:	48 ba 20 28 22 04 80 	movabs $0x8004222820,%rdx
  800421e077:	00 00 00 
  800421e07a:	be 61 00 00 00       	mov    $0x61,%esi
  800421e07f:	48 bf 43 28 22 04 80 	movabs $0x8004222843,%rdi
  800421e086:	00 00 00 
  800421e089:	b8 00 00 00 00       	mov    $0x0,%eax
  800421e08e:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421e095:	00 00 00 
  800421e098:	41 ff d0             	callq  *%r8
  800421e09b:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421e0a2:	00 00 00 
  800421e0a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421e0a9:	48 01 d0             	add    %rdx,%rax
}
  800421e0ac:	c9                   	leaveq 
  800421e0ad:	c3                   	retq   

000000800421e0ae <vmx_get_vmdisk_number>:
#include <kern/trap.h>


static int vmdisk_number = 0;	//this number assign to the vm
int 
vmx_get_vmdisk_number() {
  800421e0ae:	55                   	push   %rbp
  800421e0af:	48 89 e5             	mov    %rsp,%rbp
	return vmdisk_number;
  800421e0b2:	48 b8 c8 c5 6d 04 80 	movabs $0x80046dc5c8,%rax
  800421e0b9:	00 00 00 
  800421e0bc:	8b 00                	mov    (%rax),%eax
}
  800421e0be:	5d                   	pop    %rbp
  800421e0bf:	c3                   	retq   

000000800421e0c0 <vmx_incr_vmdisk_number>:

void
vmx_incr_vmdisk_number() {
  800421e0c0:	55                   	push   %rbp
  800421e0c1:	48 89 e5             	mov    %rsp,%rbp
	vmdisk_number++;
  800421e0c4:	48 b8 c8 c5 6d 04 80 	movabs $0x80046dc5c8,%rax
  800421e0cb:	00 00 00 
  800421e0ce:	8b 00                	mov    (%rax),%eax
  800421e0d0:	8d 50 01             	lea    0x1(%rax),%edx
  800421e0d3:	48 b8 c8 c5 6d 04 80 	movabs $0x80046dc5c8,%rax
  800421e0da:	00 00 00 
  800421e0dd:	89 10                	mov    %edx,(%rax)
}
  800421e0df:	90                   	nop
  800421e0e0:	5d                   	pop    %rbp
  800421e0e1:	c3                   	retq   

000000800421e0e2 <find_msr_in_region>:
bool
find_msr_in_region(uint32_t msr_idx, uintptr_t *area, int area_sz, struct vmx_msr_entry **msr_entry) {
  800421e0e2:	55                   	push   %rbp
  800421e0e3:	48 89 e5             	mov    %rsp,%rbp
  800421e0e6:	48 83 ec 28          	sub    $0x28,%rsp
  800421e0ea:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800421e0ed:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421e0f1:	89 55 e8             	mov    %edx,-0x18(%rbp)
  800421e0f4:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
	struct vmx_msr_entry *entry = (struct vmx_msr_entry *)area;
  800421e0f8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421e0fc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	int i;
	for(i=0; i<area_sz; ++i) {
  800421e100:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421e107:	eb 21                	jmp    800421e12a <find_msr_in_region+0x48>
		if(entry->msr_index == msr_idx) {
  800421e109:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421e10d:	8b 00                	mov    (%rax),%eax
  800421e10f:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800421e112:	75 12                	jne    800421e126 <find_msr_in_region+0x44>
			*msr_entry = entry;
  800421e114:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e118:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421e11c:	48 89 10             	mov    %rdx,(%rax)
			return true;
  800421e11f:	b8 01 00 00 00       	mov    $0x1,%eax
  800421e124:	eb 11                	jmp    800421e137 <find_msr_in_region+0x55>
}
bool
find_msr_in_region(uint32_t msr_idx, uintptr_t *area, int area_sz, struct vmx_msr_entry **msr_entry) {
	struct vmx_msr_entry *entry = (struct vmx_msr_entry *)area;
	int i;
	for(i=0; i<area_sz; ++i) {
  800421e126:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421e12a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421e12d:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  800421e130:	7c d7                	jl     800421e109 <find_msr_in_region+0x27>
		if(entry->msr_index == msr_idx) {
			*msr_entry = entry;
			return true;
		}
	}
	return false;
  800421e132:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421e137:	c9                   	leaveq 
  800421e138:	c3                   	retq   

000000800421e139 <handle_interrupt_window>:


bool
handle_interrupt_window(struct Trapframe *tf, struct VmxGuestInfo *ginfo, uint32_t host_vector) {
  800421e139:	55                   	push   %rbp
  800421e13a:	48 89 e5             	mov    %rsp,%rbp
  800421e13d:	48 83 ec 38          	sub    $0x38,%rsp
  800421e141:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421e145:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421e149:	89 55 cc             	mov    %edx,-0x34(%rbp)
  800421e14c:	c7 45 f8 02 40 00 00 	movl   $0x4002,-0x8(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421e153:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421e156:	89 c7                	mov    %eax,%edi
  800421e158:	48 b8 44 df 21 04 80 	movabs $0x800421df44,%rax
  800421e15f:	00 00 00 
  800421e162:	ff d0                	callq  *%rax
	uint64_t rflags;
	uint32_t procbased_ctls_or;
	
	procbased_ctls_or = vmcs_read32( VMCS_32BIT_CONTROL_PROCESSOR_BASED_VMEXEC_CONTROLS );
  800421e164:	89 45 fc             	mov    %eax,-0x4(%rbp)
            
        //disable the interrupt window exiting
        procbased_ctls_or &= ~(VMCS_PROC_BASED_VMEXEC_CTL_INTRWINEXIT); 
  800421e167:	83 65 fc fb          	andl   $0xfffffffb,-0x4(%rbp)
  800421e16b:	c7 45 f4 02 40 00 00 	movl   $0x4002,-0xc(%rbp)
  800421e172:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421e175:	89 45 e8             	mov    %eax,-0x18(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421e178:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800421e17b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421e17e:	48 89 d6             	mov    %rdx,%rsi
  800421e181:	89 c7                	mov    %eax,%edi
  800421e183:	48 b8 1e df 21 04 80 	movabs $0x800421df1e,%rax
  800421e18a:	00 00 00 
  800421e18d:	ff d0                	callq  *%rax
  800421e18f:	c7 45 f0 16 40 00 00 	movl   $0x4016,-0x10(%rbp)
  800421e196:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421e199:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800421e19c:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421e19f:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800421e1a2:	48 89 d6             	mov    %rdx,%rsi
  800421e1a5:	89 c7                	mov    %eax,%edi
  800421e1a7:	48 b8 1e df 21 04 80 	movabs $0x800421df1e,%rax
  800421e1ae:	00 00 00 
  800421e1b1:	ff d0                	callq  *%rax
        
        vmcs_write32( VMCS_32BIT_CONTROL_PROCESSOR_BASED_VMEXEC_CONTROLS, 
		      procbased_ctls_or);
        //write back the host_vector, which can insert a virtual interrupt            
	vmcs_write32( VMCS_32BIT_CONTROL_VMENTRY_INTERRUPTION_INFO , host_vector);
	return true;
  800421e1b3:	b8 01 00 00 00       	mov    $0x1,%eax
}
  800421e1b8:	c9                   	leaveq 
  800421e1b9:	c3                   	retq   

000000800421e1ba <handle_interrupts>:
bool
handle_interrupts(struct Trapframe *tf, struct VmxGuestInfo *ginfo, uint32_t host_vector) {
  800421e1ba:	55                   	push   %rbp
  800421e1bb:	48 89 e5             	mov    %rsp,%rbp
  800421e1be:	48 83 ec 48          	sub    $0x48,%rsp
  800421e1c2:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421e1c6:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421e1ca:	89 55 bc             	mov    %edx,-0x44(%rbp)
  800421e1cd:	c7 45 e0 20 68 00 00 	movl   $0x6820,-0x20(%rbp)
	return vmcs_readl(field);
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421e1d4:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421e1d7:	89 c7                	mov    %eax,%edi
  800421e1d9:	48 b8 44 df 21 04 80 	movabs $0x800421df44,%rax
  800421e1e0:	00 00 00 
  800421e1e3:	ff d0                	callq  *%rax
	uint64_t rflags;
	uint32_t procbased_ctls_or;
	rflags = vmcs_read64(VMCS_GUEST_RFLAGS);
  800421e1e5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	
	if ( !(rflags & (0x1 << 9)) ) {	//we have to wait the interrupt window open
  800421e1e9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421e1ed:	25 00 02 00 00       	and    $0x200,%eax
  800421e1f2:	48 85 c0             	test   %rax,%rax
  800421e1f5:	75 45                	jne    800421e23c <handle_interrupts+0x82>
  800421e1f7:	c7 45 e4 02 40 00 00 	movl   $0x4002,-0x1c(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421e1fe:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421e201:	89 c7                	mov    %eax,%edi
  800421e203:	48 b8 44 df 21 04 80 	movabs $0x800421df44,%rax
  800421e20a:	00 00 00 
  800421e20d:	ff d0                	callq  *%rax
		//get the interrupt info
		
		procbased_ctls_or = vmcs_read32( VMCS_32BIT_CONTROL_PROCESSOR_BASED_VMEXEC_CONTROLS);
  800421e20f:	89 45 e8             	mov    %eax,-0x18(%rbp)
            
		//disable the interrupt window exiting
		procbased_ctls_or |= VMCS_PROC_BASED_VMEXEC_CTL_INTRWINEXIT; 
  800421e212:	83 4d e8 04          	orl    $0x4,-0x18(%rbp)
  800421e216:	c7 45 fc 02 40 00 00 	movl   $0x4002,-0x4(%rbp)
  800421e21d:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421e220:	89 45 dc             	mov    %eax,-0x24(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421e223:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800421e226:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421e229:	48 89 d6             	mov    %rdx,%rsi
  800421e22c:	89 c7                	mov    %eax,%edi
  800421e22e:	48 b8 1e df 21 04 80 	movabs $0x800421df1e,%rax
  800421e235:	00 00 00 
  800421e238:	ff d0                	callq  *%rax
  800421e23a:	eb 24                	jmp    800421e260 <handle_interrupts+0xa6>
  800421e23c:	c7 45 ec 16 40 00 00 	movl   $0x4016,-0x14(%rbp)
  800421e243:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800421e246:	89 45 d8             	mov    %eax,-0x28(%rbp)
  800421e249:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800421e24c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421e24f:	48 89 d6             	mov    %rdx,%rsi
  800421e252:	89 c7                	mov    %eax,%edi
  800421e254:	48 b8 1e df 21 04 80 	movabs $0x800421df1e,%rax
  800421e25b:	00 00 00 
  800421e25e:	ff d0                	callq  *%rax
		vmcs_write32( VMCS_32BIT_CONTROL_VMENTRY_INTERRUPTION_INFO , host_vector);
	}
	
	
	
	return true;
  800421e260:	b8 01 00 00 00       	mov    $0x1,%eax
}
  800421e265:	c9                   	leaveq 
  800421e266:	c3                   	retq   

000000800421e267 <handle_rdmsr>:

bool
handle_rdmsr(struct Trapframe *tf, struct VmxGuestInfo *ginfo) {
  800421e267:	55                   	push   %rbp
  800421e268:	48 89 e5             	mov    %rsp,%rbp
  800421e26b:	48 83 ec 40          	sub    $0x40,%rsp
  800421e26f:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421e273:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    uint64_t msr = tf->tf_regs.reg_rcx;
  800421e277:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421e27b:	48 8b 40 60          	mov    0x60(%rax),%rax
  800421e27f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	msr = EFER_MSR;
  800421e283:	b8 80 00 00 c0       	mov    $0xc0000080,%eax
  800421e288:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if(msr == EFER_MSR) {
  800421e28c:	b8 80 00 00 c0       	mov    $0xc0000080,%eax
  800421e291:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421e295:	0f 85 d4 00 00 00    	jne    800421e36f <handle_rdmsr+0x108>
		// TODO: setup msr_bitmap to ignore EFER_MSR
		uint64_t val;
		struct vmx_msr_entry *entry;
		bool r = find_msr_in_region(msr, ginfo->msr_guest_area, ginfo->msr_count, &entry);
  800421e29b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421e29f:	8b 50 28             	mov    0x28(%rax),%edx
  800421e2a2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421e2a6:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421e2aa:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800421e2ae:	89 cf                	mov    %ecx,%edi
  800421e2b0:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800421e2b4:	48 89 c6             	mov    %rax,%rsi
  800421e2b7:	48 b8 e2 e0 21 04 80 	movabs $0x800421e0e2,%rax
  800421e2be:	00 00 00 
  800421e2c1:	ff d0                	callq  *%rax
  800421e2c3:	88 45 f7             	mov    %al,-0x9(%rbp)
		assert(r);
  800421e2c6:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  800421e2ca:	83 f0 01             	xor    $0x1,%eax
  800421e2cd:	84 c0                	test   %al,%al
  800421e2cf:	74 35                	je     800421e306 <handle_rdmsr+0x9f>
  800421e2d1:	48 b9 51 28 22 04 80 	movabs $0x8004222851,%rcx
  800421e2d8:	00 00 00 
  800421e2db:	48 ba 53 28 22 04 80 	movabs $0x8004222853,%rdx
  800421e2e2:	00 00 00 
  800421e2e5:	be 60 00 00 00       	mov    $0x60,%esi
  800421e2ea:	48 bf 68 28 22 04 80 	movabs $0x8004222868,%rdi
  800421e2f1:	00 00 00 
  800421e2f4:	b8 00 00 00 00       	mov    $0x0,%eax
  800421e2f9:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421e300:	00 00 00 
  800421e303:	41 ff d0             	callq  *%r8
		val = entry->msr_value;
  800421e306:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e30a:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421e30e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		tf->tf_regs.reg_rdx = val << 32;
  800421e312:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421e316:	48 c1 e0 20          	shl    $0x20,%rax
  800421e31a:	48 89 c2             	mov    %rax,%rdx
  800421e31d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421e321:	48 89 50 58          	mov    %rdx,0x58(%rax)
		tf->tf_regs.reg_rax = val & 0xFFFFFFFF;
  800421e325:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421e329:	89 c2                	mov    %eax,%edx
  800421e32b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421e32f:	48 89 50 70          	mov    %rdx,0x70(%rax)
  800421e333:	c7 45 e4 0c 44 00 00 	movl   $0x440c,-0x1c(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421e33a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421e33d:	89 c7                	mov    %eax,%edi
  800421e33f:	48 b8 44 df 21 04 80 	movabs $0x800421df44,%rax
  800421e346:	00 00 00 
  800421e349:	ff d0                	callq  *%rax
  800421e34b:	89 c2                	mov    %eax,%edx

		tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH);
  800421e34d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421e351:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800421e358:	89 d2                	mov    %edx,%edx
  800421e35a:	48 01 c2             	add    %rax,%rdx
  800421e35d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421e361:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		return true;
  800421e368:	b8 01 00 00 00       	mov    $0x1,%eax
  800421e36d:	eb 05                	jmp    800421e374 <handle_rdmsr+0x10d>
	}
	return false;
  800421e36f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421e374:	c9                   	leaveq 
  800421e375:	c3                   	retq   

000000800421e376 <handle_wrmsr>:

bool 
handle_wrmsr(struct Trapframe *tf, struct VmxGuestInfo *ginfo) {
  800421e376:	55                   	push   %rbp
  800421e377:	48 89 e5             	mov    %rsp,%rbp
  800421e37a:	48 83 ec 50          	sub    $0x50,%rsp
  800421e37e:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800421e382:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
	uint64_t msr = tf->tf_regs.reg_rcx;
  800421e386:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421e38a:	48 8b 40 60          	mov    0x60(%rax),%rax
  800421e38e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(msr == EFER_MSR) {
  800421e392:	b8 80 00 00 c0       	mov    $0xc0000080,%eax
  800421e397:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421e39b:	0f 85 38 01 00 00    	jne    800421e4d9 <handle_wrmsr+0x163>

		uint64_t cur_val, new_val;
		struct vmx_msr_entry *entry;
		bool r = 
			find_msr_in_region(msr, ginfo->msr_guest_area, ginfo->msr_count, &entry);
  800421e3a1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421e3a5:	8b 50 28             	mov    0x28(%rax),%edx
  800421e3a8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421e3ac:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421e3b0:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800421e3b4:	89 cf                	mov    %ecx,%edi
	uint64_t msr = tf->tf_regs.reg_rcx;
	if(msr == EFER_MSR) {

		uint64_t cur_val, new_val;
		struct vmx_msr_entry *entry;
		bool r = 
  800421e3b6:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  800421e3ba:	48 89 c6             	mov    %rax,%rsi
  800421e3bd:	48 b8 e2 e0 21 04 80 	movabs $0x800421e0e2,%rax
  800421e3c4:	00 00 00 
  800421e3c7:	ff d0                	callq  *%rax
  800421e3c9:	88 45 f7             	mov    %al,-0x9(%rbp)
			find_msr_in_region(msr, ginfo->msr_guest_area, ginfo->msr_count, &entry);
		assert(r);
  800421e3cc:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  800421e3d0:	83 f0 01             	xor    $0x1,%eax
  800421e3d3:	84 c0                	test   %al,%al
  800421e3d5:	74 35                	je     800421e40c <handle_wrmsr+0x96>
  800421e3d7:	48 b9 51 28 22 04 80 	movabs $0x8004222851,%rcx
  800421e3de:	00 00 00 
  800421e3e1:	48 ba 53 28 22 04 80 	movabs $0x8004222853,%rdx
  800421e3e8:	00 00 00 
  800421e3eb:	be 75 00 00 00       	mov    $0x75,%esi
  800421e3f0:	48 bf 68 28 22 04 80 	movabs $0x8004222868,%rdi
  800421e3f7:	00 00 00 
  800421e3fa:	b8 00 00 00 00       	mov    $0x0,%eax
  800421e3ff:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421e406:	00 00 00 
  800421e409:	41 ff d0             	callq  *%r8
		cur_val = entry->msr_value;
  800421e40c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421e410:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421e414:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		new_val = (tf->tf_regs.reg_rdx << 32)|tf->tf_regs.reg_rax;
  800421e418:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421e41c:	48 8b 40 58          	mov    0x58(%rax),%rax
  800421e420:	48 c1 e0 20          	shl    $0x20,%rax
  800421e424:	48 89 c2             	mov    %rax,%rdx
  800421e427:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421e42b:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421e42f:	48 09 d0             	or     %rdx,%rax
  800421e432:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		if(BIT(cur_val, EFER_LME) == 0 && BIT(new_val, EFER_LME) == 1) {
  800421e436:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421e43a:	25 00 01 00 00       	and    $0x100,%eax
  800421e43f:	48 85 c0             	test   %rax,%rax
  800421e442:	75 4d                	jne    800421e491 <handle_wrmsr+0x11b>
  800421e444:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421e448:	25 00 01 00 00       	and    $0x100,%eax
  800421e44d:	48 85 c0             	test   %rax,%rax
  800421e450:	74 3f                	je     800421e491 <handle_wrmsr+0x11b>
  800421e452:	c7 45 d4 12 40 00 00 	movl   $0x4012,-0x2c(%rbp)
  800421e459:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421e45c:	89 c7                	mov    %eax,%edi
  800421e45e:	48 b8 44 df 21 04 80 	movabs $0x800421df44,%rax
  800421e465:	00 00 00 
  800421e468:	ff d0                	callq  *%rax
			// Long mode enable.
			uint32_t entry_ctls = vmcs_read32( VMCS_32BIT_CONTROL_VMENTRY_CONTROLS );
  800421e46a:	89 45 d8             	mov    %eax,-0x28(%rbp)
  800421e46d:	c7 45 d0 12 40 00 00 	movl   $0x4012,-0x30(%rbp)
  800421e474:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421e477:	89 45 cc             	mov    %eax,-0x34(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421e47a:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800421e47d:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800421e480:	48 89 d6             	mov    %rdx,%rsi
  800421e483:	89 c7                	mov    %eax,%edi
  800421e485:	48 b8 1e df 21 04 80 	movabs $0x800421df1e,%rax
  800421e48c:	00 00 00 
  800421e48f:	ff d0                	callq  *%rax
			vmcs_write32( VMCS_32BIT_CONTROL_VMENTRY_CONTROLS, 
				      entry_ctls );

		}

		entry->msr_value = new_val;
  800421e491:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421e495:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421e499:	48 89 50 08          	mov    %rdx,0x8(%rax)
  800421e49d:	c7 45 dc 0c 44 00 00 	movl   $0x440c,-0x24(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421e4a4:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421e4a7:	89 c7                	mov    %eax,%edi
  800421e4a9:	48 b8 44 df 21 04 80 	movabs $0x800421df44,%rax
  800421e4b0:	00 00 00 
  800421e4b3:	ff d0                	callq  *%rax
  800421e4b5:	89 c2                	mov    %eax,%edx
		tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH);
  800421e4b7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421e4bb:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800421e4c2:	89 d2                	mov    %edx,%edx
  800421e4c4:	48 01 c2             	add    %rax,%rdx
  800421e4c7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421e4cb:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		return true;
  800421e4d2:	b8 01 00 00 00       	mov    $0x1,%eax
  800421e4d7:	eb 05                	jmp    800421e4de <handle_wrmsr+0x168>
	}

	return false;
  800421e4d9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421e4de:	c9                   	leaveq 
  800421e4df:	c3                   	retq   

000000800421e4e0 <handle_eptviolation>:

bool
handle_eptviolation(uint64_t *eptrt, struct VmxGuestInfo *ginfo) {
  800421e4e0:	55                   	push   %rbp
  800421e4e1:	48 89 e5             	mov    %rsp,%rbp
  800421e4e4:	53                   	push   %rbx
  800421e4e5:	48 83 ec 48          	sub    $0x48,%rsp
  800421e4e9:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800421e4ed:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800421e4f1:	c7 45 cc 00 24 00 00 	movl   $0x2400,-0x34(%rbp)
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421e4f8:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421e4fb:	89 c7                	mov    %eax,%edi
  800421e4fd:	48 b8 44 df 21 04 80 	movabs $0x800421df44,%rax
  800421e504:	00 00 00 
  800421e507:	ff d0                	callq  *%rax
	uint64_t gpa = vmcs_read64(VMCS_64BIT_GUEST_PHYSICAL_ADDR);
  800421e509:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	int r;

	if(gpa < 0xA0000 || (gpa >= 0x100000 && gpa < ginfo->phys_sz)) 
  800421e50d:	48 81 7d e8 ff ff 09 	cmpq   $0x9ffff,-0x18(%rbp)
  800421e514:	00 
  800421e515:	76 1f                	jbe    800421e536 <handle_eptviolation+0x56>
  800421e517:	48 81 7d e8 ff ff 0f 	cmpq   $0xfffff,-0x18(%rbp)
  800421e51e:	00 
  800421e51f:	0f 86 f9 00 00 00    	jbe    800421e61e <handle_eptviolation+0x13e>
  800421e525:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421e529:	48 8b 00             	mov    (%rax),%rax
  800421e52c:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800421e530:	0f 86 e8 00 00 00    	jbe    800421e61e <handle_eptviolation+0x13e>

	{
		// Allocate a new page to the guest.
		struct PageInfo *p = page_alloc(0);
  800421e536:	bf 00 00 00 00       	mov    $0x0,%edi
  800421e53b:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  800421e542:	00 00 00 
  800421e545:	ff d0                	callq  *%rax
  800421e547:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		if(!p) {
  800421e54b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421e550:	75 25                	jne    800421e577 <handle_eptviolation+0x97>
			cprintf("vmm: handle_eptviolation: Failed to allocate a page for guest---out of memory.\n");
  800421e552:	48 bf 78 28 22 04 80 	movabs $0x8004222878,%rdi
  800421e559:	00 00 00 
  800421e55c:	b8 00 00 00 00       	mov    $0x0,%eax
  800421e561:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421e568:	00 00 00 
  800421e56b:	ff d2                	callq  *%rdx
			return false;
  800421e56d:	b8 00 00 00 00       	mov    $0x0,%eax
  800421e572:	e9 54 01 00 00       	jmpq   800421e6cb <handle_eptviolation+0x1eb>
		}
		p->pp_ref += 1;
  800421e577:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e57b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800421e57f:	8d 50 01             	lea    0x1(%rax),%edx
  800421e582:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e586:	66 89 50 08          	mov    %dx,0x8(%rax)
		r = ept_map_hva2gpa(eptrt, 
				    page2kva(p), (void *)ROUNDDOWN(gpa, PGSIZE), __EPTE_FULL, 0);
  800421e58a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421e58e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800421e592:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421e596:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
		if(!p) {
			cprintf("vmm: handle_eptviolation: Failed to allocate a page for guest---out of memory.\n");
			return false;
		}
		p->pp_ref += 1;
		r = ept_map_hva2gpa(eptrt, 
  800421e59c:	48 89 c3             	mov    %rax,%rbx
  800421e59f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e5a3:	48 89 c7             	mov    %rax,%rdi
  800421e5a6:	48 b8 26 e0 21 04 80 	movabs $0x800421e026,%rax
  800421e5ad:	00 00 00 
  800421e5b0:	ff d0                	callq  *%rax
  800421e5b2:	48 89 c6             	mov    %rax,%rsi
  800421e5b5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421e5b9:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800421e5bf:	b9 07 00 00 00       	mov    $0x7,%ecx
  800421e5c4:	48 89 da             	mov    %rbx,%rdx
  800421e5c7:	48 89 c7             	mov    %rax,%rdi
  800421e5ca:	48 b8 9c 9d 21 04 80 	movabs $0x8004219d9c,%rax
  800421e5d1:	00 00 00 
  800421e5d4:	ff d0                	callq  *%rax
  800421e5d6:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				    page2kva(p), (void *)ROUNDDOWN(gpa, PGSIZE), __EPTE_FULL, 0);
		assert(r >= 0);
  800421e5d9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421e5dd:	79 35                	jns    800421e614 <handle_eptviolation+0x134>
  800421e5df:	48 b9 c8 28 22 04 80 	movabs $0x80042228c8,%rcx
  800421e5e6:	00 00 00 
  800421e5e9:	48 ba 53 28 22 04 80 	movabs $0x8004222853,%rdx
  800421e5f0:	00 00 00 
  800421e5f3:	be 9b 00 00 00       	mov    $0x9b,%esi
  800421e5f8:	48 bf 68 28 22 04 80 	movabs $0x8004222868,%rdi
  800421e5ff:	00 00 00 
  800421e602:	b8 00 00 00 00       	mov    $0x0,%eax
  800421e607:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421e60e:	00 00 00 
  800421e611:	41 ff d0             	callq  *%r8

		//cprintf("EPT violation for gpa:%x mapped KVA:%x\n", gpa, page2kva(p));
		return true;
  800421e614:	b8 01 00 00 00       	mov    $0x1,%eax
  800421e619:	e9 ad 00 00 00       	jmpq   800421e6cb <handle_eptviolation+0x1eb>
	} else if (gpa >= CGA_BUF && gpa < CGA_BUF + PGSIZE) {
  800421e61e:	48 81 7d e8 ff 7f 0b 	cmpq   $0xb7fff,-0x18(%rbp)
  800421e625:	00 
  800421e626:	76 7c                	jbe    800421e6a4 <handle_eptviolation+0x1c4>
  800421e628:	48 81 7d e8 ff 8f 0b 	cmpq   $0xb8fff,-0x18(%rbp)
  800421e62f:	00 
  800421e630:	77 72                	ja     800421e6a4 <handle_eptviolation+0x1c4>
		// FIXME: This give direct access to VGA MMIO region.
		r = ept_map_hva2gpa(eptrt, 
  800421e632:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421e636:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800421e63c:	b9 07 00 00 00       	mov    $0x7,%ecx
  800421e641:	ba 00 80 0b 00       	mov    $0xb8000,%edx
  800421e646:	48 be 00 80 0b 04 80 	movabs $0x80040b8000,%rsi
  800421e64d:	00 00 00 
  800421e650:	48 89 c7             	mov    %rax,%rdi
  800421e653:	48 b8 9c 9d 21 04 80 	movabs $0x8004219d9c,%rax
  800421e65a:	00 00 00 
  800421e65d:	ff d0                	callq  *%rax
  800421e65f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				    (void *)(KERNBASE + CGA_BUF), (void *)CGA_BUF, __EPTE_FULL, 0);
		assert(r >= 0);
  800421e662:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421e666:	79 35                	jns    800421e69d <handle_eptviolation+0x1bd>
  800421e668:	48 b9 c8 28 22 04 80 	movabs $0x80042228c8,%rcx
  800421e66f:	00 00 00 
  800421e672:	48 ba 53 28 22 04 80 	movabs $0x8004222853,%rdx
  800421e679:	00 00 00 
  800421e67c:	be a3 00 00 00       	mov    $0xa3,%esi
  800421e681:	48 bf 68 28 22 04 80 	movabs $0x8004222868,%rdi
  800421e688:	00 00 00 
  800421e68b:	b8 00 00 00 00       	mov    $0x0,%eax
  800421e690:	49 b8 f3 04 20 04 80 	movabs $0x80042004f3,%r8
  800421e697:	00 00 00 
  800421e69a:	41 ff d0             	callq  *%r8
		return true;
  800421e69d:	b8 01 00 00 00       	mov    $0x1,%eax
  800421e6a2:	eb 27                	jmp    800421e6cb <handle_eptviolation+0x1eb>
	}
	cprintf("vmm: handle_eptviolation: Case 2, gpa %x\n", gpa);
  800421e6a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421e6a8:	48 89 c6             	mov    %rax,%rsi
  800421e6ab:	48 bf d0 28 22 04 80 	movabs $0x80042228d0,%rdi
  800421e6b2:	00 00 00 
  800421e6b5:	b8 00 00 00 00       	mov    $0x0,%eax
  800421e6ba:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421e6c1:	00 00 00 
  800421e6c4:	ff d2                	callq  *%rdx
	return false;
  800421e6c6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421e6cb:	48 83 c4 48          	add    $0x48,%rsp
  800421e6cf:	5b                   	pop    %rbx
  800421e6d0:	5d                   	pop    %rbp
  800421e6d1:	c3                   	retq   

000000800421e6d2 <handle_ioinstr>:

bool
handle_ioinstr(struct Trapframe *tf, struct VmxGuestInfo *ginfo) {
  800421e6d2:	55                   	push   %rbp
  800421e6d3:	48 89 e5             	mov    %rsp,%rbp
  800421e6d6:	48 83 ec 30          	sub    $0x30,%rsp
  800421e6da:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421e6de:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421e6e2:	c7 45 e4 00 64 00 00 	movl   $0x6400,-0x1c(%rbp)
  800421e6e9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421e6ec:	89 c7                	mov    %eax,%edi
  800421e6ee:	48 b8 44 df 21 04 80 	movabs $0x800421df44,%rax
  800421e6f5:	00 00 00 
  800421e6f8:	ff d0                	callq  *%rax
	static int port_iortc;
	
	uint64_t qualification = vmcs_read64(VMCS_VMEXIT_QUALIFICATION);
  800421e6fa:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	int port_number = (qualification >> 16) & 0xFFFF;
  800421e6fe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421e702:	48 c1 e8 10          	shr    $0x10,%rax
  800421e706:	25 ff ff 00 00       	and    $0xffff,%eax
  800421e70b:	89 45 ec             	mov    %eax,-0x14(%rbp)
	bool is_in = BIT(qualification, 3);
  800421e70e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421e712:	48 c1 e8 03          	shr    $0x3,%rax
  800421e716:	83 e0 01             	and    $0x1,%eax
  800421e719:	48 85 c0             	test   %rax,%rax
  800421e71c:	0f 95 c0             	setne  %al
  800421e71f:	88 45 eb             	mov    %al,-0x15(%rbp)
	bool handled = false;
  800421e722:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
	
	// handle reading physical memory from the CMOS.
	if(port_number == IO_RTC) {
  800421e726:	83 7d ec 70          	cmpl   $0x70,-0x14(%rbp)
  800421e72a:	75 2e                	jne    800421e75a <handle_ioinstr+0x88>
		if(!is_in) {
  800421e72c:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  800421e730:	83 f0 01             	xor    $0x1,%eax
  800421e733:	84 c0                	test   %al,%al
  800421e735:	0f 84 fa 00 00 00    	je     800421e835 <handle_ioinstr+0x163>
			port_iortc = tf->tf_regs.reg_rax;
  800421e73b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e73f:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421e743:	89 c2                	mov    %eax,%edx
  800421e745:	48 b8 cc c5 6d 04 80 	movabs $0x80046dc5cc,%rax
  800421e74c:	00 00 00 
  800421e74f:	89 10                	mov    %edx,(%rax)
			handled = true;
  800421e751:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  800421e755:	e9 db 00 00 00       	jmpq   800421e835 <handle_ioinstr+0x163>
		}
	} else if (port_number == IO_RTC + 1) {
  800421e75a:	83 7d ec 71          	cmpl   $0x71,-0x14(%rbp)
  800421e75e:	0f 85 d1 00 00 00    	jne    800421e835 <handle_ioinstr+0x163>
		if(is_in) {
  800421e764:	80 7d eb 00          	cmpb   $0x0,-0x15(%rbp)
  800421e768:	0f 84 c7 00 00 00    	je     800421e835 <handle_ioinstr+0x163>
			if(port_iortc == NVRAM_BASELO) {
  800421e76e:	48 b8 cc c5 6d 04 80 	movabs $0x80046dc5cc,%rax
  800421e775:	00 00 00 
  800421e778:	8b 00                	mov    (%rax),%eax
  800421e77a:	83 f8 15             	cmp    $0x15,%eax
  800421e77d:	75 15                	jne    800421e794 <handle_ioinstr+0xc2>
				tf->tf_regs.reg_rax = 640 & 0xFF;
  800421e77f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e783:	48 c7 40 70 80 00 00 	movq   $0x80,0x70(%rax)
  800421e78a:	00 
				handled = true;
  800421e78b:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  800421e78f:	e9 a1 00 00 00       	jmpq   800421e835 <handle_ioinstr+0x163>
			} else if (port_iortc == NVRAM_BASEHI) {
  800421e794:	48 b8 cc c5 6d 04 80 	movabs $0x80046dc5cc,%rax
  800421e79b:	00 00 00 
  800421e79e:	8b 00                	mov    (%rax),%eax
  800421e7a0:	83 f8 16             	cmp    $0x16,%eax
  800421e7a3:	75 12                	jne    800421e7b7 <handle_ioinstr+0xe5>
				tf->tf_regs.reg_rax = (640 >> 8) & 0xFF;
  800421e7a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e7a9:	48 c7 40 70 02 00 00 	movq   $0x2,0x70(%rax)
  800421e7b0:	00 
				handled = true;
  800421e7b1:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  800421e7b5:	eb 7e                	jmp    800421e835 <handle_ioinstr+0x163>
			} else if (port_iortc == NVRAM_EXTLO) {
  800421e7b7:	48 b8 cc c5 6d 04 80 	movabs $0x80046dc5cc,%rax
  800421e7be:	00 00 00 
  800421e7c1:	8b 00                	mov    (%rax),%eax
  800421e7c3:	83 f8 17             	cmp    $0x17,%eax
  800421e7c6:	75 2a                	jne    800421e7f2 <handle_ioinstr+0x120>
				tf->tf_regs.reg_rax = ((ginfo->phys_sz / 1024) - 1024) & 0xFF;
  800421e7c8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421e7cc:	48 8b 00             	mov    (%rax),%rax
  800421e7cf:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  800421e7d6:	48 85 c0             	test   %rax,%rax
  800421e7d9:	48 0f 48 c2          	cmovs  %rdx,%rax
  800421e7dd:	48 c1 f8 0a          	sar    $0xa,%rax
  800421e7e1:	0f b6 d0             	movzbl %al,%edx
  800421e7e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e7e8:	48 89 50 70          	mov    %rdx,0x70(%rax)
				handled = true;
  800421e7ec:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  800421e7f0:	eb 43                	jmp    800421e835 <handle_ioinstr+0x163>
			} else if (port_iortc == NVRAM_EXTHI) {
  800421e7f2:	48 b8 cc c5 6d 04 80 	movabs $0x80046dc5cc,%rax
  800421e7f9:	00 00 00 
  800421e7fc:	8b 00                	mov    (%rax),%eax
  800421e7fe:	83 f8 18             	cmp    $0x18,%eax
  800421e801:	75 32                	jne    800421e835 <handle_ioinstr+0x163>
				tf->tf_regs.reg_rax = (((ginfo->phys_sz / 1024) - 1024) >> 8) & 0xFF;
  800421e803:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421e807:	48 8b 00             	mov    (%rax),%rax
  800421e80a:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  800421e811:	48 85 c0             	test   %rax,%rax
  800421e814:	48 0f 48 c2          	cmovs  %rdx,%rax
  800421e818:	48 c1 f8 0a          	sar    $0xa,%rax
  800421e81c:	48 2d 00 04 00 00    	sub    $0x400,%rax
  800421e822:	48 c1 f8 08          	sar    $0x8,%rax
  800421e826:	0f b6 d0             	movzbl %al,%edx
  800421e829:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e82d:	48 89 50 70          	mov    %rdx,0x70(%rax)
				handled = true;
  800421e831:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
			}
		}
		
	} 

	if(handled) {
  800421e835:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800421e839:	74 3c                	je     800421e877 <handle_ioinstr+0x1a5>
  800421e83b:	c7 45 f8 0c 44 00 00 	movl   $0x440c,-0x8(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421e842:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421e845:	89 c7                	mov    %eax,%edi
  800421e847:	48 b8 44 df 21 04 80 	movabs $0x800421df44,%rax
  800421e84e:	00 00 00 
  800421e851:	ff d0                	callq  *%rax
  800421e853:	89 c2                	mov    %eax,%edx
		tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH);
  800421e855:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e859:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800421e860:	89 d2                	mov    %edx,%edx
  800421e862:	48 01 c2             	add    %rax,%rdx
  800421e865:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e869:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		return true;
  800421e870:	b8 01 00 00 00       	mov    $0x1,%eax
  800421e875:	eb 33                	jmp    800421e8aa <handle_ioinstr+0x1d8>
	} else {
		cprintf("%x %x\n", qualification, port_iortc);
  800421e877:	48 b8 cc c5 6d 04 80 	movabs $0x80046dc5cc,%rax
  800421e87e:	00 00 00 
  800421e881:	8b 10                	mov    (%rax),%edx
  800421e883:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421e887:	48 89 c6             	mov    %rax,%rsi
  800421e88a:	48 bf fa 28 22 04 80 	movabs $0x80042228fa,%rdi
  800421e891:	00 00 00 
  800421e894:	b8 00 00 00 00       	mov    $0x0,%eax
  800421e899:	48 b9 09 9d 20 04 80 	movabs $0x8004209d09,%rcx
  800421e8a0:	00 00 00 
  800421e8a3:	ff d1                	callq  *%rcx
		return false;    
  800421e8a5:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
  800421e8aa:	c9                   	leaveq 
  800421e8ab:	c3                   	retq   

000000800421e8ac <handle_cpuid>:
// Finally, you need to increment the program counter in the trap frame.
// 
// Hint: The TA's solution does not hard-code the length of the cpuid instruction.
bool
handle_cpuid(struct Trapframe *tf, struct VmxGuestInfo *ginfo)
{
  800421e8ac:	55                   	push   %rbp
  800421e8ad:	48 89 e5             	mov    %rsp,%rbp
  800421e8b0:	48 83 ec 30          	sub    $0x30,%rsp
  800421e8b4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421e8b8:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint32_t eax, ebx, ecx, edx;	
	
	cpuid(tf->tf_regs.reg_rax, &eax, &ebx, &ecx, &edx);
  800421e8bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e8c0:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421e8c4:	89 c7                	mov    %eax,%edi
  800421e8c6:	48 8d 75 ec          	lea    -0x14(%rbp),%rsi
  800421e8ca:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800421e8ce:	48 8d 55 f4          	lea    -0xc(%rbp),%rdx
  800421e8d2:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  800421e8d6:	49 89 f0             	mov    %rsi,%r8
  800421e8d9:	48 89 c6             	mov    %rax,%rsi
  800421e8dc:	48 b8 61 df 21 04 80 	movabs $0x800421df61,%rax
  800421e8e3:	00 00 00 
  800421e8e6:	ff d0                	callq  *%rax

	if (tf->tf_regs.reg_rax == 0x1){
  800421e8e8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e8ec:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421e8f0:	48 83 f8 01          	cmp    $0x1,%rax
  800421e8f4:	75 13                	jne    800421e909 <handle_cpuid+0x5d>
		if (ecx & 0x20)
  800421e8f6:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800421e8f9:	83 e0 20             	and    $0x20,%eax
  800421e8fc:	85 c0                	test   %eax,%eax
  800421e8fe:	74 09                	je     800421e909 <handle_cpuid+0x5d>
			ecx -= 0x20; 
  800421e900:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800421e903:	83 e8 20             	sub    $0x20,%eax
  800421e906:	89 45 f0             	mov    %eax,-0x10(%rbp)
	}

	tf->tf_regs.reg_rax = eax;
  800421e909:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421e90c:	89 c2                	mov    %eax,%edx
  800421e90e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e912:	48 89 50 70          	mov    %rdx,0x70(%rax)
	tf->tf_regs.reg_rbx = ebx;
  800421e916:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421e919:	89 c2                	mov    %eax,%edx
  800421e91b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e91f:	48 89 50 68          	mov    %rdx,0x68(%rax)
	tf->tf_regs.reg_rcx = ecx;
  800421e923:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800421e926:	89 c2                	mov    %eax,%edx
  800421e928:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e92c:	48 89 50 60          	mov    %rdx,0x60(%rax)
	tf->tf_regs.reg_rdx = edx;
  800421e930:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421e933:	89 c2                	mov    %eax,%edx
  800421e935:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e939:	48 89 50 58          	mov    %rdx,0x58(%rax)
  800421e93d:	c7 45 fc 0c 44 00 00 	movl   $0x440c,-0x4(%rbp)
  800421e944:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421e947:	89 c7                	mov    %eax,%edi
  800421e949:	48 b8 44 df 21 04 80 	movabs $0x800421df44,%rax
  800421e950:	00 00 00 
  800421e953:	ff d0                	callq  *%rax
  800421e955:	89 c2                	mov    %eax,%edx

	tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH);
  800421e957:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e95b:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800421e962:	89 d2                	mov    %edx,%edx
  800421e964:	48 01 c2             	add    %rax,%rdx
  800421e967:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e96b:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	return true;
  800421e972:	b8 01 00 00 00       	mov    $0x1,%eax
}
  800421e977:	c9                   	leaveq 
  800421e978:	c3                   	retq   

000000800421e979 <handle_vmcall>:
// 
// Hint: The TA's solution does not hard-code the length of the cpuid instruction.//

bool
handle_vmcall(struct Trapframe *tf, struct VmxGuestInfo *gInfo, uint64_t *eptrt)
{
  800421e979:	55                   	push   %rbp
  800421e97a:	48 89 e5             	mov    %rsp,%rbp
  800421e97d:	48 83 ec 70          	sub    $0x70,%rsp
  800421e981:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800421e985:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800421e989:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
	bool handled = false;
  800421e98d:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
	int perm, r, i;
	void *gpa_pg, *hva_pg;
	envid_t to_env;
	uint32_t val;
	// phys address of the multiboot map in the guest.
	uint64_t multiboot_map_addr = 0x6000;
  800421e991:	48 c7 45 e8 00 60 00 	movq   $0x6000,-0x18(%rbp)
  800421e998:	00 
	struct PageInfo *p;

	switch(tf->tf_regs.reg_rax) {
  800421e999:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421e99d:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421e9a1:	48 83 f8 06          	cmp    $0x6,%rax
  800421e9a5:	0f 87 b6 03 00 00    	ja     800421ed61 <handle_vmcall+0x3e8>
  800421e9ab:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421e9b2:	00 
  800421e9b3:	48 b8 60 29 22 04 80 	movabs $0x8004222960,%rax
  800421e9ba:	00 00 00 
  800421e9bd:	48 01 d0             	add    %rdx,%rax
  800421e9c0:	48 8b 00             	mov    (%rax),%rax
  800421e9c3:	ff e0                	jmpq   *%rax
		// Copy the mbinfo and memory_map_t (segment descriptions) into the guest page, and return
		//   a pointer to this region in rbx (as a guest physical address).
		/* Your code here */

		// check mapping exist
		ept_gpa2hva((void *)eptrt, (void *)multiboot_map_addr, &hva_pg);
  800421e9c5:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421e9c9:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  800421e9cd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421e9d1:	48 89 ce             	mov    %rcx,%rsi
  800421e9d4:	48 89 c7             	mov    %rax,%rdi
  800421e9d7:	48 b8 cc 99 21 04 80 	movabs $0x80042199cc,%rax
  800421e9de:	00 00 00 
  800421e9e1:	ff d0                	callq  *%rax
		if (hva_pg == NULL){
  800421e9e3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421e9e7:	48 85 c0             	test   %rax,%rax
  800421e9ea:	75 52                	jne    800421ea3e <handle_vmcall+0xc5>
			p = page_alloc(ALLOC_ZERO);
  800421e9ec:	bf 01 00 00 00       	mov    $0x1,%edi
  800421e9f1:	48 b8 fc 2e 20 04 80 	movabs $0x8004202efc,%rax
  800421e9f8:	00 00 00 
  800421e9fb:	ff d0                	callq  *%rax
  800421e9fd:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
			hva_pg = page2kva(p);
  800421ea01:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421ea05:	48 89 c7             	mov    %rax,%rdi
  800421ea08:	48 b8 26 e0 21 04 80 	movabs $0x800421e026,%rax
  800421ea0f:	00 00 00 
  800421ea12:	ff d0                	callq  *%rax
  800421ea14:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			ept_map_hva2gpa((void *)eptrt, hva_pg, (void *)multiboot_map_addr, __EPTE_FULL, 0);
  800421ea18:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421ea1c:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  800421ea20:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421ea24:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800421ea2a:	b9 07 00 00 00       	mov    $0x7,%ecx
  800421ea2f:	48 89 c7             	mov    %rax,%rdi
  800421ea32:	48 b8 9c 9d 21 04 80 	movabs $0x8004219d9c,%rax
  800421ea39:	00 00 00 
  800421ea3c:	ff d0                	callq  *%rax
		}
		
		mbinfo = (struct multiboot_info *)hva_pg;
  800421ea3e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421ea42:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		mbinfo->flags = MB_FLAG_MMAP;
  800421ea46:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421ea4a:	c7 00 40 00 00 00    	movl   $0x40,(%rax)
		mbinfo->mmap_addr = (uint64_t)(multiboot_map_addr + sizeof(struct multiboot_info));
  800421ea50:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421ea54:	8d 50 34             	lea    0x34(%rax),%edx
  800421ea57:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421ea5b:	89 50 30             	mov    %edx,0x30(%rax)
		mbinfo->mmap_length = 3 * sizeof(memory_map_t);
  800421ea5e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421ea62:	c7 40 2c 48 00 00 00 	movl   $0x48,0x2c(%rax)

		mmap = (memory_map_t *)(hva_pg + sizeof(struct multiboot_info));
  800421ea69:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421ea6d:	48 83 c0 34          	add    $0x34,%rax
  800421ea71:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		mmap->size = 20;
  800421ea75:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ea79:	c7 00 14 00 00 00    	movl   $0x14,(%rax)
		mmap->base_addr_low = 0;
  800421ea7f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ea83:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
		mmap->base_addr_high = 0;
  800421ea8a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ea8e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
		mmap->length_low = 0xA0000;
  800421ea95:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ea99:	c7 40 0c 00 00 0a 00 	movl   $0xa0000,0xc(%rax)
		mmap->length_high = 0;	
  800421eaa0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421eaa4:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
		mmap->type = MB_TYPE_USABLE;
  800421eaab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421eaaf:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%rax)

		mmap+=1;
  800421eab6:	48 83 45 c8 18       	addq   $0x18,-0x38(%rbp)
		mmap->size = 20;
  800421eabb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421eabf:	c7 00 14 00 00 00    	movl   $0x14,(%rax)
		mmap->base_addr_low = 0xA0000;
  800421eac5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421eac9:	c7 40 04 00 00 0a 00 	movl   $0xa0000,0x4(%rax)
		mmap->base_addr_high = 0;
  800421ead0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ead4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
		mmap->length_low = 0x60000;;
  800421eadb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421eadf:	c7 40 0c 00 00 06 00 	movl   $0x60000,0xc(%rax)
		mmap->length_high = 0;
  800421eae6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421eaea:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
		mmap->type = MB_TYPE_RESERVED;
  800421eaf1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421eaf5:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)

		mmap+=1;
  800421eafc:	48 83 45 c8 18       	addq   $0x18,-0x38(%rbp)
		mmap->size = 20; 
  800421eb01:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421eb05:	c7 00 14 00 00 00    	movl   $0x14,(%rax)
		mmap->base_addr_low = 0x100000;
  800421eb0b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421eb0f:	c7 40 04 00 00 10 00 	movl   $0x100000,0x4(%rax)
		mmap->base_addr_high = 0;
  800421eb16:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421eb1a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
		mmap->length_low = gInfo->phys_sz - 0x100000;
  800421eb21:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421eb25:	48 8b 00             	mov    (%rax),%rax
  800421eb28:	8d 90 00 00 f0 ff    	lea    -0x100000(%rax),%edx
  800421eb2e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421eb32:	89 50 0c             	mov    %edx,0xc(%rax)
		mmap->length_high = 0;
  800421eb35:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421eb39:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
		mmap->type = MB_TYPE_USABLE;	
  800421eb40:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421eb44:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%rax)

		tf->tf_regs.reg_rbx = multiboot_map_addr;		
  800421eb4b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421eb4f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421eb53:	48 89 50 68          	mov    %rdx,0x68(%rax)
		handled = true;
  800421eb57:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
		break;
  800421eb5b:	e9 01 02 00 00       	jmpq   800421ed61 <handle_vmcall+0x3e8>
		//  do this translation.
		//
		// The input should be a guest physical address; you will need to convert
		//  this to a host virtual address for the IPC to work properly.
		/* Your code here */
		ept_gpa2hva(eptrt, (void *)tf->tf_regs.reg_rdx, &hva_pg);
  800421eb60:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421eb64:	48 8b 40 58          	mov    0x58(%rax),%rax
  800421eb68:	48 89 c1             	mov    %rax,%rcx
  800421eb6b:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  800421eb6f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421eb73:	48 89 ce             	mov    %rcx,%rsi
  800421eb76:	48 89 c7             	mov    %rax,%rdi
  800421eb79:	48 b8 cc 99 21 04 80 	movabs $0x80042199cc,%rax
  800421eb80:	00 00 00 
  800421eb83:	ff d0                	callq  *%rax
		
		for (i = 0; i < NENV; i++) {
  800421eb85:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  800421eb8c:	eb 5c                	jmp    800421ebea <handle_vmcall+0x271>
			if (envs[i].env_type == tf->tf_regs.reg_rbx){
  800421eb8e:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  800421eb95:	00 00 00 
  800421eb98:	48 8b 10             	mov    (%rax),%rdx
  800421eb9b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421eb9e:	48 98                	cltq   
  800421eba0:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800421eba7:	48 01 d0             	add    %rdx,%rax
  800421ebaa:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800421ebb0:	89 c2                	mov    %eax,%edx
  800421ebb2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421ebb6:	48 8b 40 68          	mov    0x68(%rax),%rax
  800421ebba:	48 39 c2             	cmp    %rax,%rdx
  800421ebbd:	75 27                	jne    800421ebe6 <handle_vmcall+0x26d>
				to_env =  envs[i].env_id;
  800421ebbf:	48 b8 58 d2 4d 04 80 	movabs $0x80044dd258,%rax
  800421ebc6:	00 00 00 
  800421ebc9:	48 8b 10             	mov    (%rax),%rdx
  800421ebcc:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421ebcf:	48 98                	cltq   
  800421ebd1:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800421ebd8:	48 01 d0             	add    %rdx,%rax
  800421ebdb:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800421ebe1:	89 45 f4             	mov    %eax,-0xc(%rbp)
				break;
  800421ebe4:	eb 0d                	jmp    800421ebf3 <handle_vmcall+0x27a>
		// The input should be a guest physical address; you will need to convert
		//  this to a host virtual address for the IPC to work properly.
		/* Your code here */
		ept_gpa2hva(eptrt, (void *)tf->tf_regs.reg_rdx, &hva_pg);
		
		for (i = 0; i < NENV; i++) {
  800421ebe6:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  800421ebea:	81 7d f8 ff 03 00 00 	cmpl   $0x3ff,-0x8(%rbp)
  800421ebf1:	7e 9b                	jle    800421eb8e <handle_vmcall+0x215>
				to_env =  envs[i].env_id;
				break;
			}
		}
		
		tf->tf_regs.reg_rax = syscall(SYS_ipc_try_send,
  800421ebf3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421ebf7:	48 89 c1             	mov    %rax,%rcx
  800421ebfa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421ebfe:	48 8b 50 60          	mov    0x60(%rax),%rdx
  800421ec02:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421ec05:	48 98                	cltq   
  800421ec07:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800421ec0d:	41 b8 07 00 00 00    	mov    $0x7,%r8d
  800421ec13:	48 89 c6             	mov    %rax,%rsi
  800421ec16:	bf 0c 00 00 00       	mov    $0xc,%edi
  800421ec1b:	48 b8 f3 f1 20 04 80 	movabs $0x800420f1f3,%rax
  800421ec22:	00 00 00 
  800421ec25:	ff d0                	callq  *%rax
  800421ec27:	48 89 c2             	mov    %rax,%rdx
  800421ec2a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421ec2e:	48 89 50 70          	mov    %rdx,0x70(%rax)
						to_env,
						tf->tf_regs.reg_rcx, 
						(uint64_t)hva_pg,
						PTE_P | PTE_W | PTE_U,
						0);	
		handled = true;
  800421ec32:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
		break;
  800421ec36:	e9 26 01 00 00       	jmpq   800421ed61 <handle_vmcall+0x3e8>
  800421ec3b:	c7 45 c4 0c 44 00 00 	movl   $0x440c,-0x3c(%rbp)
  800421ec42:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421ec45:	89 c7                	mov    %eax,%edi
  800421ec47:	48 b8 44 df 21 04 80 	movabs $0x800421df44,%rax
  800421ec4e:	00 00 00 
  800421ec51:	ff d0                	callq  *%rax
  800421ec53:	89 c2                	mov    %eax,%edx
	case VMX_VMCALL_IPCRECV:
		// Issue the sys_ipc_recv call for the guest.
		// NB: because recv can call schedule, clobbering the VMCS, 
		// you should go ahead and increment rip before this call.
		/* Your code here */
		tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH); 
  800421ec55:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421ec59:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800421ec60:	89 d2                	mov    %edx,%edx
  800421ec62:	48 01 c2             	add    %rax,%rdx
  800421ec65:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421ec69:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
			(uint64_t)hva_pg,
			0, 0, 0, 0);	
		*/
		
		tf->tf_regs.reg_rax = syscall(SYS_ipc_recv,
			(uint64_t)tf->tf_regs.reg_rbx,
  800421ec70:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421ec74:	48 8b 40 68          	mov    0x68(%rax),%rax
		tf->tf_regs.reg_rax = syscall(SYS_ipc_recv,
			(uint64_t)hva_pg,
			0, 0, 0, 0);	
		*/
		
		tf->tf_regs.reg_rax = syscall(SYS_ipc_recv,
  800421ec78:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800421ec7e:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800421ec84:	b9 00 00 00 00       	mov    $0x0,%ecx
  800421ec89:	ba 00 00 00 00       	mov    $0x0,%edx
  800421ec8e:	48 89 c6             	mov    %rax,%rsi
  800421ec91:	bf 0d 00 00 00       	mov    $0xd,%edi
  800421ec96:	48 b8 f3 f1 20 04 80 	movabs $0x800420f1f3,%rax
  800421ec9d:	00 00 00 
  800421eca0:	ff d0                	callq  *%rax
  800421eca2:	48 89 c2             	mov    %rax,%rdx
  800421eca5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421eca9:	48 89 50 70          	mov    %rdx,0x70(%rax)
			(uint64_t)tf->tf_regs.reg_rbx,
			0, 0, 0, 0);	
		handled = true;
  800421ecad:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
		return handled;
  800421ecb1:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  800421ecb5:	e9 e6 00 00 00       	jmpq   800421eda0 <handle_vmcall+0x427>
	case VMX_VMCALL_LAPICEOI:
		lapic_eoi();
  800421ecba:	48 b8 02 7f 21 04 80 	movabs $0x8004217f02,%rax
  800421ecc1:	00 00 00 
  800421ecc4:	ff d0                	callq  *%rax
		handled = true;
  800421ecc6:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
		break;
  800421ecca:	e9 92 00 00 00       	jmpq   800421ed61 <handle_vmcall+0x3e8>
	case VMX_VMCALL_BACKTOHOST:
		cprintf("Now back to the host, VM halt in the background, run vmmanager to resume the VM.\n");
  800421eccf:	48 bf 08 29 22 04 80 	movabs $0x8004222908,%rdi
  800421ecd6:	00 00 00 
  800421ecd9:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ecde:	48 ba 09 9d 20 04 80 	movabs $0x8004209d09,%rdx
  800421ece5:	00 00 00 
  800421ece8:	ff d2                	callq  *%rdx
		curenv->env_status = ENV_NOT_RUNNABLE;	//mark the guest not runable
  800421ecea:	48 b8 cd 7e 21 04 80 	movabs $0x8004217ecd,%rax
  800421ecf1:	00 00 00 
  800421ecf4:	ff d0                	callq  *%rax
  800421ecf6:	48 ba 20 e0 6d 04 80 	movabs $0x80046de020,%rdx
  800421ecfd:	00 00 00 
  800421ed00:	48 98                	cltq   
  800421ed02:	48 c1 e0 03          	shl    $0x3,%rax
  800421ed06:	48 89 c1             	mov    %rax,%rcx
  800421ed09:	48 c1 e1 04          	shl    $0x4,%rcx
  800421ed0d:	48 01 c8             	add    %rcx,%rax
  800421ed10:	48 01 d0             	add    %rdx,%rax
  800421ed13:	48 83 c0 08          	add    $0x8,%rax
  800421ed17:	48 8b 00             	mov    (%rax),%rax
  800421ed1a:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800421ed21:	00 00 00 
		ENV_CREATE(user_sh, ENV_TYPE_USER);	//create a new host shell
  800421ed24:	be 00 00 00 00       	mov    $0x0,%esi
  800421ed29:	48 bf d0 e0 4b 04 80 	movabs $0x80044be0d0,%rdi
  800421ed30:	00 00 00 
  800421ed33:	48 b8 65 90 20 04 80 	movabs $0x8004209065,%rax
  800421ed3a:	00 00 00 
  800421ed3d:	ff d0                	callq  *%rax
		handled = true;
  800421ed3f:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
		break;	
  800421ed43:	eb 1c                	jmp    800421ed61 <handle_vmcall+0x3e8>
	case VMX_VMCALL_GETDISKIMGNUM:	//alloc a number to guest
		tf->tf_regs.reg_rax = vmdisk_number;
  800421ed45:	48 b8 c8 c5 6d 04 80 	movabs $0x80046dc5c8,%rax
  800421ed4c:	00 00 00 
  800421ed4f:	8b 00                	mov    (%rax),%eax
  800421ed51:	48 63 d0             	movslq %eax,%rdx
  800421ed54:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421ed58:	48 89 50 70          	mov    %rdx,0x70(%rax)
		handled = true;
  800421ed5c:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
		break;
  800421ed60:	90                   	nop
         
	}
	if(handled) {
  800421ed61:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800421ed65:	74 35                	je     800421ed9c <handle_vmcall+0x423>
  800421ed67:	c7 45 e4 0c 44 00 00 	movl   $0x440c,-0x1c(%rbp)
  800421ed6e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421ed71:	89 c7                	mov    %eax,%edi
  800421ed73:	48 b8 44 df 21 04 80 	movabs $0x800421df44,%rax
  800421ed7a:	00 00 00 
  800421ed7d:	ff d0                	callq  *%rax
  800421ed7f:	89 c2                	mov    %eax,%edx
		/* Advance the program counter by the length of the vmcall instruction. 
		 * 
		 * Hint: The TA solution does not hard-code the length of the vmcall instruction.
		 */
		/* Your code here */
		tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH);
  800421ed81:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421ed85:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800421ed8c:	89 d2                	mov    %edx,%edx
  800421ed8e:	48 01 c2             	add    %rax,%rdx
  800421ed91:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421ed95:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	}
	return handled;
  800421ed9c:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  800421eda0:	c9                   	leaveq 
  800421eda1:	c3                   	retq   
