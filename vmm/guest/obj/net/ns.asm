
vmm/guest/obj/net/ns:     file format elf64-x86-64


Disassembly of section .text:

0000000000800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	movabs $USTACKTOP, %rax
  800020:	48 b8 00 e0 7f ef 00 	movabs $0xef7fe000,%rax
  800027:	00 00 00 
	cmpq %rax,%rsp
  80002a:	48 39 c4             	cmp    %rax,%rsp
	jne args_exist
  80002d:	75 04                	jne    800033 <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushq $0
  80002f:	6a 00                	pushq  $0x0
	pushq $0
  800031:	6a 00                	pushq  $0x0

0000000000800033 <args_exist>:

args_exist:
	movq 8(%rsp), %rsi
  800033:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
	movq (%rsp), %rdi
  800038:	48 8b 3c 24          	mov    (%rsp),%rdi
	call libmain
  80003c:	e8 0f 10 00 00       	callq  801050 <libmain>
1:	jmp 1b
  800041:	eb fe                	jmp    800041 <args_exist+0xe>

0000000000800043 <next_i>:
static envid_t timer_envid;
static envid_t input_envid;
static envid_t output_envid;

static bool buse[QUEUE_SIZE];
static int next_i(int i) { return (i+1) % QUEUE_SIZE; }
  800043:	55                   	push   %rbp
  800044:	48 89 e5             	mov    %rsp,%rbp
  800047:	48 83 ec 08          	sub    $0x8,%rsp
  80004b:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80004e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800051:	8d 48 01             	lea    0x1(%rax),%ecx
  800054:	ba 67 66 66 66       	mov    $0x66666667,%edx
  800059:	89 c8                	mov    %ecx,%eax
  80005b:	f7 ea                	imul   %edx
  80005d:	c1 fa 03             	sar    $0x3,%edx
  800060:	89 c8                	mov    %ecx,%eax
  800062:	c1 f8 1f             	sar    $0x1f,%eax
  800065:	29 c2                	sub    %eax,%edx
  800067:	89 d0                	mov    %edx,%eax
  800069:	c1 e0 02             	shl    $0x2,%eax
  80006c:	01 d0                	add    %edx,%eax
  80006e:	c1 e0 02             	shl    $0x2,%eax
  800071:	29 c1                	sub    %eax,%ecx
  800073:	89 ca                	mov    %ecx,%edx
  800075:	89 d0                	mov    %edx,%eax
  800077:	c9                   	leaveq 
  800078:	c3                   	retq   

0000000000800079 <prev_i>:
static int prev_i(int i) { return (i ? i-1 : QUEUE_SIZE-1); }
  800079:	55                   	push   %rbp
  80007a:	48 89 e5             	mov    %rsp,%rbp
  80007d:	48 83 ec 08          	sub    $0x8,%rsp
  800081:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800084:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800088:	74 08                	je     800092 <prev_i+0x19>
  80008a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80008d:	83 e8 01             	sub    $0x1,%eax
  800090:	eb 05                	jmp    800097 <prev_i+0x1e>
  800092:	b8 13 00 00 00       	mov    $0x13,%eax
  800097:	c9                   	leaveq 
  800098:	c3                   	retq   

0000000000800099 <get_buffer>:

static void *
get_buffer(void) {
  800099:	55                   	push   %rbp
  80009a:	48 89 e5             	mov    %rsp,%rbp
  80009d:	48 83 ec 10          	sub    $0x10,%rsp
    void *va;

    int64_t i;
    for (i = 0; i < QUEUE_SIZE; i++)
  8000a1:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8000a8:	00 
  8000a9:	eb 20                	jmp    8000cb <get_buffer+0x32>
        if (!buse[i]) break;
  8000ab:	48 ba 70 90 82 00 00 	movabs $0x829070,%rdx
  8000b2:	00 00 00 
  8000b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8000b9:	48 01 d0             	add    %rdx,%rax
  8000bc:	0f b6 00             	movzbl (%rax),%eax
  8000bf:	83 f0 01             	xor    $0x1,%eax
  8000c2:	84 c0                	test   %al,%al
  8000c4:	75 0e                	jne    8000d4 <get_buffer+0x3b>
static void *
get_buffer(void) {
    void *va;

    int64_t i;
    for (i = 0; i < QUEUE_SIZE; i++)
  8000c6:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8000cb:	48 83 7d f8 13       	cmpq   $0x13,-0x8(%rbp)
  8000d0:	7e d9                	jle    8000ab <get_buffer+0x12>
  8000d2:	eb 01                	jmp    8000d5 <get_buffer+0x3c>
        if (!buse[i]) break;
  8000d4:	90                   	nop

    if (i == QUEUE_SIZE) {
  8000d5:	48 83 7d f8 14       	cmpq   $0x14,-0x8(%rbp)
  8000da:	75 2a                	jne    800106 <get_buffer+0x6d>
        panic("NS: buffer overflow");
  8000dc:	48 ba c0 0c 82 00 00 	movabs $0x820cc0,%rdx
  8000e3:	00 00 00 
  8000e6:	be 40 00 00 00       	mov    $0x40,%esi
  8000eb:	48 bf d4 0c 82 00 00 	movabs $0x820cd4,%rdi
  8000f2:	00 00 00 
  8000f5:	b8 00 00 00 00       	mov    $0x0,%eax
  8000fa:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  800101:	00 00 00 
  800104:	ff d1                	callq  *%rcx
        return 0;
    }

    va = (void *)(REQVA + i * PGSIZE);
  800106:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80010a:	48 05 eb ff 00 00    	add    $0xffeb,%rax
  800110:	48 c1 e0 0c          	shl    $0xc,%rax
  800114:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    buse[i] = 1;
  800118:	48 ba 70 90 82 00 00 	movabs $0x829070,%rdx
  80011f:	00 00 00 
  800122:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800126:	48 01 d0             	add    %rdx,%rax
  800129:	c6 00 01             	movb   $0x1,(%rax)

    return va;
  80012c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800130:	c9                   	leaveq 
  800131:	c3                   	retq   

0000000000800132 <put_buffer>:

static void
put_buffer(void *va) {
  800132:	55                   	push   %rbp
  800133:	48 89 e5             	mov    %rsp,%rbp
  800136:	48 83 ec 18          	sub    $0x18,%rsp
  80013a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    int64_t i = ((uint64_t)va - REQVA) / PGSIZE;
  80013e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800142:	48 2d 00 b0 fe 0f    	sub    $0xffeb000,%rax
  800148:	48 c1 e8 0c          	shr    $0xc,%rax
  80014c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    buse[i] = 0;
  800150:	48 ba 70 90 82 00 00 	movabs $0x829070,%rdx
  800157:	00 00 00 
  80015a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80015e:	48 01 d0             	add    %rdx,%rax
  800161:	c6 00 00             	movb   $0x0,(%rax)
}
  800164:	90                   	nop
  800165:	c9                   	leaveq 
  800166:	c3                   	retq   

0000000000800167 <lwip_init>:

    static void
lwip_init(struct netif *nif, void *if_state,
        uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
  800167:	55                   	push   %rbp
  800168:	48 89 e5             	mov    %rsp,%rbp
  80016b:	48 83 ec 50          	sub    $0x50,%rsp
  80016f:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800173:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800177:	89 55 bc             	mov    %edx,-0x44(%rbp)
  80017a:	89 4d b8             	mov    %ecx,-0x48(%rbp)
  80017d:	44 89 45 b4          	mov    %r8d,-0x4c(%rbp)
    struct ip_addr ipaddr, netmask, gateway;
    ipaddr.addr  = init_addr;
  800181:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800184:	89 45 f0             	mov    %eax,-0x10(%rbp)
    netmask.addr = init_mask;
  800187:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80018a:	89 45 e0             	mov    %eax,-0x20(%rbp)
    gateway.addr = init_gw;
  80018d:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800190:	89 45 d0             	mov    %eax,-0x30(%rbp)

    if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  800193:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  800197:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80019b:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  80019f:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8001a3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8001a7:	48 83 ec 08          	sub    $0x8,%rsp
  8001ab:	49 ba 3a 0f 81 00 00 	movabs $0x810f3a,%r10
  8001b2:	00 00 00 
  8001b5:	41 52                	push   %r10
  8001b7:	49 b9 07 9b 81 00 00 	movabs $0x819b07,%r9
  8001be:	00 00 00 
  8001c1:	49 89 f8             	mov    %rdi,%r8
  8001c4:	48 89 c7             	mov    %rax,%rdi
  8001c7:	48 b8 00 d0 80 00 00 	movabs $0x80d000,%rax
  8001ce:	00 00 00 
  8001d1:	ff d0                	callq  *%rax
  8001d3:	48 83 c4 10          	add    $0x10,%rsp
  8001d7:	48 85 c0             	test   %rax,%rax
  8001da:	75 2a                	jne    800206 <lwip_init+0x9f>
                if_state,
                jif_init,
                ip_input))
        panic("lwip_init: error in netif_add\n");
  8001dc:	48 ba e0 0c 82 00 00 	movabs $0x820ce0,%rdx
  8001e3:	00 00 00 
  8001e6:	be 5d 00 00 00       	mov    $0x5d,%esi
  8001eb:	48 bf d4 0c 82 00 00 	movabs $0x820cd4,%rdi
  8001f2:	00 00 00 
  8001f5:	b8 00 00 00 00       	mov    $0x0,%eax
  8001fa:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  800201:	00 00 00 
  800204:	ff d1                	callq  *%rcx

    netif_set_default(nif);
  800206:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80020a:	48 89 c7             	mov    %rax,%rdi
  80020d:	48 b8 07 d4 80 00 00 	movabs $0x80d407,%rax
  800214:	00 00 00 
  800217:	ff d0                	callq  *%rax
    netif_set_up(nif);
  800219:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80021d:	48 89 c7             	mov    %rax,%rdi
  800220:	48 b8 27 d4 80 00 00 	movabs $0x80d427,%rax
  800227:	00 00 00 
  80022a:	ff d0                	callq  *%rax
}
  80022c:	90                   	nop
  80022d:	c9                   	leaveq 
  80022e:	c3                   	retq   

000000000080022f <net_timer>:

    static void __attribute__((noreturn))
net_timer(uint64_t arg)
{
  80022f:	55                   	push   %rbp
  800230:	48 89 e5             	mov    %rsp,%rbp
  800233:	48 83 ec 20          	sub    $0x20,%rsp
  800237:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct timer_thread *t = (struct timer_thread *) arg;
  80023b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80023f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    for (;;) {
        uint32_t cur = sys_time_msec();
  800243:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  80024a:	00 00 00 
  80024d:	ff d0                	callq  *%rax
  80024f:	89 45 f4             	mov    %eax,-0xc(%rbp)

        lwip_core_lock();
  800252:	48 b8 5e 8c 81 00 00 	movabs $0x818c5e,%rax
  800259:	00 00 00 
  80025c:	ff d0                	callq  *%rax
        t->func();
  80025e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800262:	48 8b 40 08          	mov    0x8(%rax),%rax
  800266:	ff d0                	callq  *%rax
        lwip_core_unlock();
  800268:	48 b8 65 8c 81 00 00 	movabs $0x818c65,%rax
  80026f:	00 00 00 
  800272:	ff d0                	callq  *%rax

        thread_wait(0, 0, cur + t->msec);
  800274:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800278:	8b 10                	mov    (%rax),%edx
  80027a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80027d:	01 d0                	add    %edx,%eax
  80027f:	89 c2                	mov    %eax,%edx
  800281:	be 00 00 00 00       	mov    $0x0,%esi
  800286:	bf 00 00 00 00       	mov    $0x0,%edi
  80028b:	48 b8 df 8d 81 00 00 	movabs $0x818ddf,%rax
  800292:	00 00 00 
  800295:	ff d0                	callq  *%rax
    }
  800297:	eb aa                	jmp    800243 <net_timer+0x14>

0000000000800299 <start_timer>:
}

    static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800299:	55                   	push   %rbp
  80029a:	48 89 e5             	mov    %rsp,%rbp
  80029d:	48 83 ec 30          	sub    $0x30,%rsp
  8002a1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8002a5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8002a9:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8002ad:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
    t->msec = msec;
  8002b0:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8002b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002b7:	89 10                	mov    %edx,(%rax)
    t->func = func;
  8002b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002bd:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8002c1:	48 89 50 08          	mov    %rdx,0x8(%rax)
    t->name = name;
  8002c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002c9:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8002cd:	48 89 50 10          	mov    %rdx,0x10(%rax)
    int r = thread_create(0, name, &net_timer, (uint64_t)t);
  8002d1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8002d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8002d9:	48 89 d1             	mov    %rdx,%rcx
  8002dc:	48 ba 2f 02 80 00 00 	movabs $0x80022f,%rdx
  8002e3:	00 00 00 
  8002e6:	48 89 c6             	mov    %rax,%rsi
  8002e9:	bf 00 00 00 00       	mov    $0x0,%edi
  8002ee:	48 b8 5a 90 81 00 00 	movabs $0x81905a,%rax
  8002f5:	00 00 00 
  8002f8:	ff d0                	callq  *%rax
  8002fa:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (r < 0)
  8002fd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800301:	79 3f                	jns    800342 <start_timer+0xa9>
        panic("cannot create timer thread: %s", e2s(r));
  800303:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800306:	89 c7                	mov    %eax,%edi
  800308:	48 b8 f6 96 81 00 00 	movabs $0x8196f6,%rax
  80030f:	00 00 00 
  800312:	ff d0                	callq  *%rax
  800314:	48 89 c1             	mov    %rax,%rcx
  800317:	48 ba 00 0d 82 00 00 	movabs $0x820d00,%rdx
  80031e:	00 00 00 
  800321:	be 7b 00 00 00       	mov    $0x7b,%esi
  800326:	48 bf d4 0c 82 00 00 	movabs $0x820cd4,%rdi
  80032d:	00 00 00 
  800330:	b8 00 00 00 00       	mov    $0x0,%eax
  800335:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  80033c:	00 00 00 
  80033f:	41 ff d0             	callq  *%r8
}
  800342:	90                   	nop
  800343:	c9                   	leaveq 
  800344:	c3                   	retq   

0000000000800345 <tcpip_init_done>:

    static void
tcpip_init_done(void *arg)
{
  800345:	55                   	push   %rbp
  800346:	48 89 e5             	mov    %rsp,%rbp
  800349:	48 83 ec 20          	sub    $0x20,%rsp
  80034d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    uint32_t *done = arg;
  800351:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800355:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    *done = 1;
  800359:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80035d:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    thread_wakeup(done);
  800363:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800367:	48 89 c7             	mov    %rax,%rdi
  80036a:	48 b8 8b 8d 81 00 00 	movabs $0x818d8b,%rax
  800371:	00 00 00 
  800374:	ff d0                	callq  *%rax
}
  800376:	90                   	nop
  800377:	c9                   	leaveq 
  800378:	c3                   	retq   

0000000000800379 <serve_init>:

    void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  800379:	55                   	push   %rbp
  80037a:	48 89 e5             	mov    %rsp,%rbp
  80037d:	48 83 ec 20          	sub    $0x20,%rsp
  800381:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800384:	89 75 e8             	mov    %esi,-0x18(%rbp)
  800387:	89 55 e4             	mov    %edx,-0x1c(%rbp)
    int r;
    lwip_core_lock();
  80038a:	48 b8 5e 8c 81 00 00 	movabs $0x818c5e,%rax
  800391:	00 00 00 
  800394:	ff d0                	callq  *%rax

    uint32_t done = 0;
  800396:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    tcpip_init(&tcpip_init_done, &done);
  80039d:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8003a1:	48 89 c6             	mov    %rax,%rsi
  8003a4:	48 bf 45 03 80 00 00 	movabs $0x800345,%rdi
  8003ab:	00 00 00 
  8003ae:	48 b8 69 8d 80 00 00 	movabs $0x808d69,%rax
  8003b5:	00 00 00 
  8003b8:	ff d0                	callq  *%rax
    lwip_core_unlock();
  8003ba:	48 b8 65 8c 81 00 00 	movabs $0x818c65,%rax
  8003c1:	00 00 00 
  8003c4:	ff d0                	callq  *%rax
    thread_wait(&done, 0, (uint32_t)~0);
  8003c6:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8003ca:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8003cf:	be 00 00 00 00       	mov    $0x0,%esi
  8003d4:	48 89 c7             	mov    %rax,%rdi
  8003d7:	48 b8 df 8d 81 00 00 	movabs $0x818ddf,%rax
  8003de:	00 00 00 
  8003e1:	ff d0                	callq  *%rax
    lwip_core_lock();
  8003e3:	48 b8 5e 8c 81 00 00 	movabs $0x818c5e,%rax
  8003ea:	00 00 00 
  8003ed:	ff d0                	callq  *%rax

    lwip_init(&nif, &output_envid, ipaddr, netmask, gw);
  8003ef:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8003f2:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8003f5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8003f8:	41 89 c8             	mov    %ecx,%r8d
  8003fb:	89 d1                	mov    %edx,%ecx
  8003fd:	89 c2                	mov    %eax,%edx
  8003ff:	48 be 60 90 82 00 00 	movabs $0x829060,%rsi
  800406:	00 00 00 
  800409:	48 bf 20 75 b5 00 00 	movabs $0xb57520,%rdi
  800410:	00 00 00 
  800413:	48 b8 67 01 80 00 00 	movabs $0x800167,%rax
  80041a:	00 00 00 
  80041d:	ff d0                	callq  *%rax

    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  80041f:	b9 88 13 00 00       	mov    $0x1388,%ecx
  800424:	48 ba 1f 0d 82 00 00 	movabs $0x820d1f,%rdx
  80042b:	00 00 00 
  80042e:	48 be 1a 5c 81 00 00 	movabs $0x815c1a,%rsi
  800435:	00 00 00 
  800438:	48 bf 00 90 82 00 00 	movabs $0x829000,%rdi
  80043f:	00 00 00 
  800442:	48 b8 99 02 80 00 00 	movabs $0x800299,%rax
  800449:	00 00 00 
  80044c:	ff d0                	callq  *%rax
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  80044e:	b9 fa 00 00 00       	mov    $0xfa,%ecx
  800453:	48 ba 29 0d 82 00 00 	movabs $0x820d29,%rdx
  80045a:	00 00 00 
  80045d:	48 be b9 03 81 00 00 	movabs $0x8103b9,%rsi
  800464:	00 00 00 
  800467:	48 bf 20 90 82 00 00 	movabs $0x829020,%rdi
  80046e:	00 00 00 
  800471:	48 b8 99 02 80 00 00 	movabs $0x800299,%rax
  800478:	00 00 00 
  80047b:	ff d0                	callq  *%rax
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  80047d:	b9 f4 01 00 00       	mov    $0x1f4,%ecx
  800482:	48 ba 35 0d 82 00 00 	movabs $0x820d35,%rdx
  800489:	00 00 00 
  80048c:	48 be 7a fb 80 00 00 	movabs $0x80fb7a,%rsi
  800493:	00 00 00 
  800496:	48 bf 40 90 82 00 00 	movabs $0x829040,%rdi
  80049d:	00 00 00 
  8004a0:	48 b8 99 02 80 00 00 	movabs $0x800299,%rax
  8004a7:	00 00 00 
  8004aa:	ff d0                	callq  *%rax

    struct in_addr ia = {ipaddr};
  8004ac:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004af:	89 45 f0             	mov    %eax,-0x10(%rbp)
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004b2:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004b5:	89 c7                	mov    %eax,%edi
  8004b7:	48 b8 e6 2f 81 00 00 	movabs $0x812fe6,%rax
  8004be:	00 00 00 
  8004c1:	ff d0                	callq  *%rax
  8004c3:	49 89 c1             	mov    %rax,%r9
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004c6:	48 b8 20 75 b5 00 00 	movabs $0xb57520,%rax
  8004cd:	00 00 00 
  8004d0:	0f b6 40 46          	movzbl 0x46(%rax),%eax
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004d4:	0f b6 f0             	movzbl %al,%esi
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004d7:	48 b8 20 75 b5 00 00 	movabs $0xb57520,%rax
  8004de:	00 00 00 
  8004e1:	0f b6 40 45          	movzbl 0x45(%rax),%eax
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004e5:	44 0f b6 c0          	movzbl %al,%r8d
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004e9:	48 b8 20 75 b5 00 00 	movabs $0xb57520,%rax
  8004f0:	00 00 00 
  8004f3:	0f b6 40 44          	movzbl 0x44(%rax),%eax
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004f7:	0f b6 f8             	movzbl %al,%edi
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  8004fa:	48 b8 20 75 b5 00 00 	movabs $0xb57520,%rax
  800501:	00 00 00 
  800504:	0f b6 40 43          	movzbl 0x43(%rax),%eax
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800508:	0f b6 c8             	movzbl %al,%ecx
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  80050b:	48 b8 20 75 b5 00 00 	movabs $0xb57520,%rax
  800512:	00 00 00 
  800515:	0f b6 40 42          	movzbl 0x42(%rax),%eax
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800519:	0f b6 d0             	movzbl %al,%edx
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  80051c:	48 b8 20 75 b5 00 00 	movabs $0xb57520,%rax
  800523:	00 00 00 
  800526:	0f b6 40 41          	movzbl 0x41(%rax),%eax
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  80052a:	0f b6 c0             	movzbl %al,%eax
  80052d:	41 51                	push   %r9
  80052f:	56                   	push   %rsi
  800530:	45 89 c1             	mov    %r8d,%r9d
  800533:	41 89 f8             	mov    %edi,%r8d
  800536:	89 c6                	mov    %eax,%esi
  800538:	48 bf 48 0d 82 00 00 	movabs $0x820d48,%rdi
  80053f:	00 00 00 
  800542:	b8 00 00 00 00       	mov    $0x0,%eax
  800547:	49 ba 32 13 80 00 00 	movabs $0x801332,%r10
  80054e:	00 00 00 
  800551:	41 ff d2             	callq  *%r10
  800554:	48 83 c4 10          	add    $0x10,%rsp
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
            inet_ntoa(ia));

    lwip_core_unlock();
  800558:	48 b8 65 8c 81 00 00 	movabs $0x818c65,%rax
  80055f:	00 00 00 
  800562:	ff d0                	callq  *%rax

    cprintf("NS: TCP/IP initialized.\n");
  800564:	48 bf 81 0d 82 00 00 	movabs $0x820d81,%rdi
  80056b:	00 00 00 
  80056e:	b8 00 00 00 00       	mov    $0x0,%eax
  800573:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  80057a:	00 00 00 
  80057d:	ff d2                	callq  *%rdx
}
  80057f:	90                   	nop
  800580:	c9                   	leaveq 
  800581:	c3                   	retq   

0000000000800582 <process_timer>:

static void
process_timer(envid_t envid) {
  800582:	55                   	push   %rbp
  800583:	48 89 e5             	mov    %rsp,%rbp
  800586:	48 83 ec 20          	sub    $0x20,%rsp
  80058a:	89 7d ec             	mov    %edi,-0x14(%rbp)
    uint32_t start, now, to;

    if (envid != timer_envid) {
  80058d:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800594:	00 00 00 
  800597:	8b 00                	mov    (%rax),%eax
  800599:	39 45 ec             	cmp    %eax,-0x14(%rbp)
  80059c:	74 22                	je     8005c0 <process_timer+0x3e>
        cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  80059e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8005a1:	89 c6                	mov    %eax,%esi
  8005a3:	48 bf a0 0d 82 00 00 	movabs $0x820da0,%rdi
  8005aa:	00 00 00 
  8005ad:	b8 00 00 00 00       	mov    $0x0,%eax
  8005b2:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8005b9:	00 00 00 
  8005bc:	ff d2                	callq  *%rdx
        return;
  8005be:	eb 56                	jmp    800616 <process_timer+0x94>
    }

    start = sys_time_msec();
  8005c0:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  8005c7:	00 00 00 
  8005ca:	ff d0                	callq  *%rax
  8005cc:	89 45 fc             	mov    %eax,-0x4(%rbp)
    thread_yield();
  8005cf:	48 b8 e1 92 81 00 00 	movabs $0x8192e1,%rax
  8005d6:	00 00 00 
  8005d9:	ff d0                	callq  *%rax
    now = sys_time_msec();
  8005db:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  8005e2:	00 00 00 
  8005e5:	ff d0                	callq  *%rax
  8005e7:	89 45 f8             	mov    %eax,-0x8(%rbp)

    to = TIMER_INTERVAL - (now - start);
  8005ea:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8005ed:	2b 45 f8             	sub    -0x8(%rbp),%eax
  8005f0:	05 fa 00 00 00       	add    $0xfa,%eax
  8005f5:	89 45 f4             	mov    %eax,-0xc(%rbp)
    ipc_send(envid, to, 0, 0);
  8005f8:	8b 75 f4             	mov    -0xc(%rbp),%esi
  8005fb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8005fe:	b9 00 00 00 00       	mov    $0x0,%ecx
  800603:	ba 00 00 00 00       	mov    $0x0,%edx
  800608:	89 c7                	mov    %eax,%edi
  80060a:	48 b8 cd 32 80 00 00 	movabs $0x8032cd,%rax
  800611:	00 00 00 
  800614:	ff d0                	callq  *%rax
}
  800616:	c9                   	leaveq 
  800617:	c3                   	retq   

0000000000800618 <serve_thread>:
    uint32_t whom;
    union Nsipc *req;
};

static void
serve_thread(uint64_t a) {
  800618:	55                   	push   %rbp
  800619:	48 89 e5             	mov    %rsp,%rbp
  80061c:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  800623:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
    struct st_args *args = (struct st_args *)a;
  80062a:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800631:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    union Nsipc *req = args->req;
  800635:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800639:	48 8b 40 08          	mov    0x8(%rax),%rax
  80063d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    int r;

    switch (args->reqno) {
  800641:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800645:	8b 00                	mov    (%rax),%eax
  800647:	83 f8 0a             	cmp    $0xa,%eax
  80064a:	0f 87 d8 01 00 00    	ja     800828 <serve_thread+0x210>
  800650:	89 c0                	mov    %eax,%eax
  800652:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800659:	00 
  80065a:	48 b8 18 0e 82 00 00 	movabs $0x820e18,%rax
  800661:	00 00 00 
  800664:	48 01 d0             	add    %rdx,%rax
  800667:	48 8b 00             	mov    (%rax),%rax
  80066a:	ff e0                	jmpq   *%rax
        case NSREQ_ACCEPT:
            {
                struct Nsret_accept ret;
                r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  80066c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800670:	8b 00                	mov    (%rax),%eax
  800672:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800676:	48 83 c2 10          	add    $0x10,%rdx
  80067a:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80067e:	48 89 ce             	mov    %rcx,%rsi
  800681:	89 c7                	mov    %eax,%edi
  800683:	48 b8 69 5f 80 00 00 	movabs $0x805f69,%rax
  80068a:	00 00 00 
  80068d:	ff d0                	callq  *%rax
  80068f:	89 45 fc             	mov    %eax,-0x4(%rbp)
                        &ret.ret_addrlen);
                memmove(req, &ret, sizeof ret);
  800692:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800696:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80069a:	ba 14 00 00 00       	mov    $0x14,%edx
  80069f:	48 89 ce             	mov    %rcx,%rsi
  8006a2:	48 89 c7             	mov    %rax,%rdi
  8006a5:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  8006ac:	00 00 00 
  8006af:	ff d0                	callq  *%rax
                break;
  8006b1:	90                   	nop
  8006b2:	e9 a5 01 00 00       	jmpq   80085c <serve_thread+0x244>
            }
        case NSREQ_BIND:
            r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  8006b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006bb:	8b 50 14             	mov    0x14(%rax),%edx
  8006be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006c2:	48 8d 48 04          	lea    0x4(%rax),%rcx
  8006c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006ca:	8b 00                	mov    (%rax),%eax
  8006cc:	48 89 ce             	mov    %rcx,%rsi
  8006cf:	89 c7                	mov    %eax,%edi
  8006d1:	48 b8 96 62 80 00 00 	movabs $0x806296,%rax
  8006d8:	00 00 00 
  8006db:	ff d0                	callq  *%rax
  8006dd:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->bind.req_namelen);
            break;
  8006e0:	e9 77 01 00 00       	jmpq   80085c <serve_thread+0x244>
        case NSREQ_SHUTDOWN:
            r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  8006e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006e9:	8b 50 04             	mov    0x4(%rax),%edx
  8006ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006f0:	8b 00                	mov    (%rax),%eax
  8006f2:	89 d6                	mov    %edx,%esi
  8006f4:	89 c7                	mov    %eax,%edi
  8006f6:	48 b8 07 7a 80 00 00 	movabs $0x807a07,%rax
  8006fd:	00 00 00 
  800700:	ff d0                	callq  *%rax
  800702:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  800705:	e9 52 01 00 00       	jmpq   80085c <serve_thread+0x244>
        case NSREQ_CLOSE:
            r = lwip_close(req->close.req_s);
  80070a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80070e:	8b 00                	mov    (%rax),%eax
  800710:	89 c7                	mov    %eax,%edi
  800712:	48 b8 cb 63 80 00 00 	movabs $0x8063cb,%rax
  800719:	00 00 00 
  80071c:	ff d0                	callq  *%rax
  80071e:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  800721:	e9 36 01 00 00       	jmpq   80085c <serve_thread+0x244>
        case NSREQ_CONNECT:
            r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  800726:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80072a:	8b 50 14             	mov    0x14(%rax),%edx
  80072d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800731:	48 8d 48 04          	lea    0x4(%rax),%rcx
  800735:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800739:	8b 00                	mov    (%rax),%eax
  80073b:	48 89 ce             	mov    %rcx,%rsi
  80073e:	89 c7                	mov    %eax,%edi
  800740:	48 b8 b0 64 80 00 00 	movabs $0x8064b0,%rax
  800747:	00 00 00 
  80074a:	ff d0                	callq  *%rax
  80074c:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->connect.req_namelen);
            break;
  80074f:	e9 08 01 00 00       	jmpq   80085c <serve_thread+0x244>
        case NSREQ_LISTEN:
            r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  800754:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800758:	8b 50 04             	mov    0x4(%rax),%edx
  80075b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80075f:	8b 00                	mov    (%rax),%eax
  800761:	89 d6                	mov    %edx,%esi
  800763:	89 c7                	mov    %eax,%edi
  800765:	48 b8 0c 66 80 00 00 	movabs $0x80660c,%rax
  80076c:	00 00 00 
  80076f:	ff d0                	callq  *%rax
  800771:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  800774:	e9 e3 00 00 00       	jmpq   80085c <serve_thread+0x244>
        case NSREQ_RECV:
            // Note that we read the request fields before we
            // overwrite it with the response data.
            r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  800779:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80077d:	8b 48 08             	mov    0x8(%rax),%ecx
  800780:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800784:	8b 50 04             	mov    0x4(%rax),%edx
  800787:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  80078b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80078f:	8b 00                	mov    (%rax),%eax
  800791:	89 c7                	mov    %eax,%edi
  800793:	48 b8 0a 6b 80 00 00 	movabs $0x806b0a,%rax
  80079a:	00 00 00 
  80079d:	ff d0                	callq  *%rax
  80079f:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->recv.req_len, req->recv.req_flags);
            break;
  8007a2:	e9 b5 00 00 00       	jmpq   80085c <serve_thread+0x244>
        case NSREQ_SEND:
            r = lwip_send(req->send.req_s, &req->send.req_buf,
  8007a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007ab:	8b 48 08             	mov    0x8(%rax),%ecx
  8007ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007b2:	8b 50 04             	mov    0x4(%rax),%edx
  8007b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007b9:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  8007bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007c1:	8b 00                	mov    (%rax),%eax
  8007c3:	89 c7                	mov    %eax,%edi
  8007c5:	48 b8 48 6b 80 00 00 	movabs $0x806b48,%rax
  8007cc:	00 00 00 
  8007cf:	ff d0                	callq  *%rax
  8007d1:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->send.req_size, req->send.req_flags);
            break;
  8007d4:	e9 83 00 00 00       	jmpq   80085c <serve_thread+0x244>
        case NSREQ_SOCKET:
            r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  8007d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007dd:	8b 50 08             	mov    0x8(%rax),%edx
  8007e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007e4:	8b 48 04             	mov    0x4(%rax),%ecx
  8007e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007eb:	8b 00                	mov    (%rax),%eax
  8007ed:	89 ce                	mov    %ecx,%esi
  8007ef:	89 c7                	mov    %eax,%edi
  8007f1:	48 b8 68 6e 80 00 00 	movabs $0x806e68,%rax
  8007f8:	00 00 00 
  8007fb:	ff d0                	callq  *%rax
  8007fd:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->socket.req_protocol);
            break;
  800800:	eb 5a                	jmp    80085c <serve_thread+0x244>
        case NSREQ_INPUT:
            jif_input(&nif, (void *)&req->pkt);
  800802:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800806:	48 89 c6             	mov    %rax,%rsi
  800809:	48 bf 20 75 b5 00 00 	movabs $0xb57520,%rdi
  800810:	00 00 00 
  800813:	48 b8 0a 9a 81 00 00 	movabs $0x819a0a,%rax
  80081a:	00 00 00 
  80081d:	ff d0                	callq  *%rax
            r = 0;
  80081f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
            break;
  800826:	eb 34                	jmp    80085c <serve_thread+0x244>
        default:
            cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  800828:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80082c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800830:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800834:	8b 40 04             	mov    0x4(%rax),%eax
  800837:	89 c6                	mov    %eax,%esi
  800839:	48 bf e0 0d 82 00 00 	movabs $0x820de0,%rdi
  800840:	00 00 00 
  800843:	b8 00 00 00 00       	mov    $0x0,%eax
  800848:	48 b9 32 13 80 00 00 	movabs $0x801332,%rcx
  80084f:	00 00 00 
  800852:	ff d1                	callq  *%rcx
            r = -E_INVAL;
  800854:	c7 45 fc fd ff ff ff 	movl   $0xfffffffd,-0x4(%rbp)
            break;
  80085b:	90                   	nop
    }

    if (r == -1) {
  80085c:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800860:	75 49                	jne    8008ab <serve_thread+0x293>
        char buf[100];
        snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800862:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800866:	8b 10                	mov    (%rax),%edx
  800868:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
  80086f:	89 d1                	mov    %edx,%ecx
  800871:	48 ba 03 0e 82 00 00 	movabs $0x820e03,%rdx
  800878:	00 00 00 
  80087b:	be 64 00 00 00       	mov    $0x64,%esi
  800880:	48 89 c7             	mov    %rax,%rdi
  800883:	b8 00 00 00 00       	mov    $0x0,%eax
  800888:	49 b8 75 1d 80 00 00 	movabs $0x801d75,%r8
  80088f:	00 00 00 
  800892:	41 ff d0             	callq  *%r8
        perror(buf);
  800895:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
  80089c:	48 89 c7             	mov    %rax,%rdi
  80089f:	48 b8 a2 96 81 00 00 	movabs $0x8196a2,%rax
  8008a6:	00 00 00 
  8008a9:	ff d0                	callq  *%rax
    }

    if (args->reqno != NSREQ_INPUT)
  8008ab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008af:	8b 00                	mov    (%rax),%eax
  8008b1:	83 f8 0a             	cmp    $0xa,%eax
  8008b4:	74 24                	je     8008da <serve_thread+0x2c2>
        ipc_send(args->whom, r, 0, 0);
  8008b6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8008b9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8008bd:	8b 52 04             	mov    0x4(%rdx),%edx
  8008c0:	89 d7                	mov    %edx,%edi
  8008c2:	b9 00 00 00 00       	mov    $0x0,%ecx
  8008c7:	ba 00 00 00 00       	mov    $0x0,%edx
  8008cc:	89 c6                	mov    %eax,%esi
  8008ce:	48 b8 cd 32 80 00 00 	movabs $0x8032cd,%rax
  8008d5:	00 00 00 
  8008d8:	ff d0                	callq  *%rax

    put_buffer(args->req);
  8008da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008de:	48 8b 40 08          	mov    0x8(%rax),%rax
  8008e2:	48 89 c7             	mov    %rax,%rdi
  8008e5:	48 b8 32 01 80 00 00 	movabs $0x800132,%rax
  8008ec:	00 00 00 
  8008ef:	ff d0                	callq  *%rax
    sys_page_unmap(0, (void*) args->req);
  8008f1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008f5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8008f9:	48 89 c6             	mov    %rax,%rsi
  8008fc:	bf 00 00 00 00       	mov    $0x0,%edi
  800901:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  800908:	00 00 00 
  80090b:	ff d0                	callq  *%rax
    free(args);
  80090d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800911:	48 89 c7             	mov    %rax,%rdi
  800914:	48 b8 9a 51 80 00 00 	movabs $0x80519a,%rax
  80091b:	00 00 00 
  80091e:	ff d0                	callq  *%rax
}
  800920:	90                   	nop
  800921:	c9                   	leaveq 
  800922:	c3                   	retq   

0000000000800923 <serve>:

void
serve(void) {
  800923:	55                   	push   %rbp
  800924:	48 89 e5             	mov    %rsp,%rbp
  800927:	48 83 ec 30          	sub    $0x30,%rsp

    while (1) {
        // ipc_recv will block the entire process, so we flush
        // all pending work from other threads.  We limit the
        // number of yields in case there's a rogue thread.
        for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80092b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800932:	eb 10                	jmp    800944 <serve+0x21>
            thread_yield();
  800934:	48 b8 e1 92 81 00 00 	movabs $0x8192e1,%rax
  80093b:	00 00 00 
  80093e:	ff d0                	callq  *%rax

    while (1) {
        // ipc_recv will block the entire process, so we flush
        // all pending work from other threads.  We limit the
        // number of yields in case there's a rogue thread.
        for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800940:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800944:	48 b8 c1 8e 81 00 00 	movabs $0x818ec1,%rax
  80094b:	00 00 00 
  80094e:	ff d0                	callq  *%rax
  800950:	85 c0                	test   %eax,%eax
  800952:	74 06                	je     80095a <serve+0x37>
  800954:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  800958:	7e da                	jle    800934 <serve+0x11>
            thread_yield();

        perm = 0;
  80095a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
        va = get_buffer();
  800961:	48 b8 99 00 80 00 00 	movabs $0x800099,%rax
  800968:	00 00 00 
  80096b:	ff d0                	callq  *%rax
  80096d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800971:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  800975:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800979:	48 8d 45 dc          	lea    -0x24(%rbp),%rax
  80097d:	48 89 ce             	mov    %rcx,%rsi
  800980:	48 89 c7             	mov    %rax,%rdi
  800983:	48 b8 0c 32 80 00 00 	movabs $0x80320c,%rax
  80098a:	00 00 00 
  80098d:	ff d0                	callq  *%rax
  80098f:	89 45 ec             	mov    %eax,-0x14(%rbp)
        if (debug) {
            cprintf("ns req %d from %08x\n", reqno, whom);
        }

        // first take care of requests that do not contain an argument page
        if (reqno == NSREQ_TIMER) {
  800992:	83 7d ec 0c          	cmpl   $0xc,-0x14(%rbp)
  800996:	75 29                	jne    8009c1 <serve+0x9e>
            process_timer(whom);
  800998:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80099b:	89 c7                	mov    %eax,%edi
  80099d:	48 b8 82 05 80 00 00 	movabs $0x800582,%rax
  8009a4:	00 00 00 
  8009a7:	ff d0                	callq  *%rax
            put_buffer(va);
  8009a9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8009ad:	48 89 c7             	mov    %rax,%rdi
  8009b0:	48 b8 32 01 80 00 00 	movabs $0x800132,%rax
  8009b7:	00 00 00 
  8009ba:	ff d0                	callq  *%rax
            continue;
  8009bc:	e9 cc 00 00 00       	jmpq   800a8d <serve+0x16a>
        }

        // All remaining requests must contain an argument page
        if (!(perm & PTE_P)) {
  8009c1:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8009c4:	83 e0 01             	and    $0x1,%eax
  8009c7:	85 c0                	test   %eax,%eax
  8009c9:	75 25                	jne    8009f0 <serve+0xcd>
            cprintf("Invalid request from %08x: no argument page\n", whom);
  8009cb:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8009ce:	89 c6                	mov    %eax,%esi
  8009d0:	48 bf 70 0e 82 00 00 	movabs $0x820e70,%rdi
  8009d7:	00 00 00 
  8009da:	b8 00 00 00 00       	mov    $0x0,%eax
  8009df:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8009e6:	00 00 00 
  8009e9:	ff d2                	callq  *%rdx
            continue; // just leave it hanging...
  8009eb:	e9 9d 00 00 00       	jmpq   800a8d <serve+0x16a>
        }

        // Since some lwIP socket calls will block, create a thread and
        // process the rest of the request in the thread.
        struct st_args *args = malloc(sizeof(struct st_args));
  8009f0:	bf 10 00 00 00       	mov    $0x10,%edi
  8009f5:	48 b8 29 4e 80 00 00 	movabs $0x804e29,%rax
  8009fc:	00 00 00 
  8009ff:	ff d0                	callq  *%rax
  800a01:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        if (!args)
  800a05:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800a0a:	75 2a                	jne    800a36 <serve+0x113>
            panic("could not allocate thread args structure");
  800a0c:	48 ba a0 0e 82 00 00 	movabs $0x820ea0,%rdx
  800a13:	00 00 00 
  800a16:	be 27 01 00 00       	mov    $0x127,%esi
  800a1b:	48 bf d4 0c 82 00 00 	movabs $0x820cd4,%rdi
  800a22:	00 00 00 
  800a25:	b8 00 00 00 00       	mov    $0x0,%eax
  800a2a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  800a31:	00 00 00 
  800a34:	ff d1                	callq  *%rcx

        args->reqno = reqno;
  800a36:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a3a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800a3d:	89 10                	mov    %edx,(%rax)
        args->whom = whom;
  800a3f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800a42:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a46:	89 50 04             	mov    %edx,0x4(%rax)
        args->req = va;
  800a49:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a4d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800a51:	48 89 50 08          	mov    %rdx,0x8(%rax)

        thread_create(0, "serve_thread", serve_thread, (uint64_t)args);
  800a55:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a59:	48 89 c1             	mov    %rax,%rcx
  800a5c:	48 ba 18 06 80 00 00 	movabs $0x800618,%rdx
  800a63:	00 00 00 
  800a66:	48 be c9 0e 82 00 00 	movabs $0x820ec9,%rsi
  800a6d:	00 00 00 
  800a70:	bf 00 00 00 00       	mov    $0x0,%edi
  800a75:	48 b8 5a 90 81 00 00 	movabs $0x81905a,%rax
  800a7c:	00 00 00 
  800a7f:	ff d0                	callq  *%rax
        thread_yield(); // let the thread created run
  800a81:	48 b8 e1 92 81 00 00 	movabs $0x8192e1,%rax
  800a88:	00 00 00 
  800a8b:	ff d0                	callq  *%rax
    }
  800a8d:	e9 99 fe ff ff       	jmpq   80092b <serve+0x8>

0000000000800a92 <tmain>:
}

static void
tmain(uint64_t arg) {
  800a92:	55                   	push   %rbp
  800a93:	48 89 e5             	mov    %rsp,%rbp
  800a96:	41 54                	push   %r12
  800a98:	53                   	push   %rbx
  800a99:	48 83 ec 10          	sub    $0x10,%rsp
  800a9d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    serve_init(inet_addr(IP),
  800aa1:	48 bf d6 0e 82 00 00 	movabs $0x820ed6,%rdi
  800aa8:	00 00 00 
  800aab:	48 b8 c8 2c 81 00 00 	movabs $0x812cc8,%rax
  800ab2:	00 00 00 
  800ab5:	ff d0                	callq  *%rax
  800ab7:	41 89 c4             	mov    %eax,%r12d
  800aba:	48 bf df 0e 82 00 00 	movabs $0x820edf,%rdi
  800ac1:	00 00 00 
  800ac4:	48 b8 c8 2c 81 00 00 	movabs $0x812cc8,%rax
  800acb:	00 00 00 
  800ace:	ff d0                	callq  *%rax
  800ad0:	89 c3                	mov    %eax,%ebx
  800ad2:	48 bf ed 0e 82 00 00 	movabs $0x820eed,%rdi
  800ad9:	00 00 00 
  800adc:	48 b8 c8 2c 81 00 00 	movabs $0x812cc8,%rax
  800ae3:	00 00 00 
  800ae6:	ff d0                	callq  *%rax
  800ae8:	44 89 e2             	mov    %r12d,%edx
  800aeb:	89 de                	mov    %ebx,%esi
  800aed:	89 c7                	mov    %eax,%edi
  800aef:	48 b8 79 03 80 00 00 	movabs $0x800379,%rax
  800af6:	00 00 00 
  800af9:	ff d0                	callq  *%rax
            inet_addr(MASK),
            inet_addr(DEFAULT));
    serve();
  800afb:	48 b8 23 09 80 00 00 	movabs $0x800923,%rax
  800b02:	00 00 00 
  800b05:	ff d0                	callq  *%rax
}
  800b07:	90                   	nop
  800b08:	48 83 c4 10          	add    $0x10,%rsp
  800b0c:	5b                   	pop    %rbx
  800b0d:	41 5c                	pop    %r12
  800b0f:	5d                   	pop    %rbp
  800b10:	c3                   	retq   

0000000000800b11 <umain>:

    void
umain(int argc, char **argv)
{
  800b11:	55                   	push   %rbp
  800b12:	48 89 e5             	mov    %rsp,%rbp
  800b15:	48 83 ec 20          	sub    $0x20,%rsp
  800b19:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800b1c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    envid_t ns_envid = sys_getenvid();
  800b20:	48 b8 7f 27 80 00 00 	movabs $0x80277f,%rax
  800b27:	00 00 00 
  800b2a:	ff d0                	callq  *%rax
  800b2c:	89 45 fc             	mov    %eax,-0x4(%rbp)

    binaryname = "ns";
  800b2f:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800b36:	00 00 00 
  800b39:	48 be f7 0e 82 00 00 	movabs $0x820ef7,%rsi
  800b40:	00 00 00 
  800b43:	48 89 30             	mov    %rsi,(%rax)

    // fork off the timer thread which will send us periodic messages
    timer_envid = fork();
  800b46:	48 b8 95 2f 80 00 00 	movabs $0x802f95,%rax
  800b4d:	00 00 00 
  800b50:	ff d0                	callq  *%rax
  800b52:	89 c2                	mov    %eax,%edx
  800b54:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800b5b:	00 00 00 
  800b5e:	89 10                	mov    %edx,(%rax)
    if (timer_envid < 0)
  800b60:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800b67:	00 00 00 
  800b6a:	8b 00                	mov    (%rax),%eax
  800b6c:	85 c0                	test   %eax,%eax
  800b6e:	79 2a                	jns    800b9a <umain+0x89>
        panic("error forking");
  800b70:	48 ba fa 0e 82 00 00 	movabs $0x820efa,%rdx
  800b77:	00 00 00 
  800b7a:	be 44 01 00 00       	mov    $0x144,%esi
  800b7f:	48 bf d4 0c 82 00 00 	movabs $0x820cd4,%rdi
  800b86:	00 00 00 
  800b89:	b8 00 00 00 00       	mov    $0x0,%eax
  800b8e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  800b95:	00 00 00 
  800b98:	ff d1                	callq  *%rcx
    else if (timer_envid == 0) {
  800b9a:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800ba1:	00 00 00 
  800ba4:	8b 00                	mov    (%rax),%eax
  800ba6:	85 c0                	test   %eax,%eax
  800ba8:	75 1b                	jne    800bc5 <umain+0xb4>
        timer(ns_envid, TIMER_INTERVAL);
  800baa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800bad:	be fa 00 00 00       	mov    $0xfa,%esi
  800bb2:	89 c7                	mov    %eax,%edi
  800bb4:	48 b8 fa 0c 80 00 00 	movabs $0x800cfa,%rax
  800bbb:	00 00 00 
  800bbe:	ff d0                	callq  *%rax
        return;
  800bc0:	e9 33 01 00 00       	jmpq   800cf8 <umain+0x1e7>
    }

    // fork off the input thread which will poll the NIC driver for input
    // packets
    input_envid = fork();
  800bc5:	48 b8 95 2f 80 00 00 	movabs $0x802f95,%rax
  800bcc:	00 00 00 
  800bcf:	ff d0                	callq  *%rax
  800bd1:	89 c2                	mov    %eax,%edx
  800bd3:	48 b8 5c 90 82 00 00 	movabs $0x82905c,%rax
  800bda:	00 00 00 
  800bdd:	89 10                	mov    %edx,(%rax)
    if (input_envid < 0)
  800bdf:	48 b8 5c 90 82 00 00 	movabs $0x82905c,%rax
  800be6:	00 00 00 
  800be9:	8b 00                	mov    (%rax),%eax
  800beb:	85 c0                	test   %eax,%eax
  800bed:	79 2a                	jns    800c19 <umain+0x108>
        panic("error forking");
  800bef:	48 ba fa 0e 82 00 00 	movabs $0x820efa,%rdx
  800bf6:	00 00 00 
  800bf9:	be 4e 01 00 00       	mov    $0x14e,%esi
  800bfe:	48 bf d4 0c 82 00 00 	movabs $0x820cd4,%rdi
  800c05:	00 00 00 
  800c08:	b8 00 00 00 00       	mov    $0x0,%eax
  800c0d:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  800c14:	00 00 00 
  800c17:	ff d1                	callq  *%rcx
    else if (input_envid == 0) {
  800c19:	48 b8 5c 90 82 00 00 	movabs $0x82905c,%rax
  800c20:	00 00 00 
  800c23:	8b 00                	mov    (%rax),%eax
  800c25:	85 c0                	test   %eax,%eax
  800c27:	75 16                	jne    800c3f <umain+0x12e>
        input(ns_envid);
  800c29:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800c2c:	89 c7                	mov    %eax,%edi
  800c2e:	48 b8 1d 0e 80 00 00 	movabs $0x800e1d,%rax
  800c35:	00 00 00 
  800c38:	ff d0                	callq  *%rax
        return;
  800c3a:	e9 b9 00 00 00       	jmpq   800cf8 <umain+0x1e7>
    }

    // fork off the output thread that will send the packets to the NIC
    // driver
    output_envid = fork();
  800c3f:	48 b8 95 2f 80 00 00 	movabs $0x802f95,%rax
  800c46:	00 00 00 
  800c49:	ff d0                	callq  *%rax
  800c4b:	89 c2                	mov    %eax,%edx
  800c4d:	48 b8 60 90 82 00 00 	movabs $0x829060,%rax
  800c54:	00 00 00 
  800c57:	89 10                	mov    %edx,(%rax)
    if (output_envid < 0)
  800c59:	48 b8 60 90 82 00 00 	movabs $0x829060,%rax
  800c60:	00 00 00 
  800c63:	8b 00                	mov    (%rax),%eax
  800c65:	85 c0                	test   %eax,%eax
  800c67:	79 2a                	jns    800c93 <umain+0x182>
        panic("error forking");
  800c69:	48 ba fa 0e 82 00 00 	movabs $0x820efa,%rdx
  800c70:	00 00 00 
  800c73:	be 58 01 00 00       	mov    $0x158,%esi
  800c78:	48 bf d4 0c 82 00 00 	movabs $0x820cd4,%rdi
  800c7f:	00 00 00 
  800c82:	b8 00 00 00 00       	mov    $0x0,%eax
  800c87:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  800c8e:	00 00 00 
  800c91:	ff d1                	callq  *%rcx
    else if (output_envid == 0) {
  800c93:	48 b8 60 90 82 00 00 	movabs $0x829060,%rax
  800c9a:	00 00 00 
  800c9d:	8b 00                	mov    (%rax),%eax
  800c9f:	85 c0                	test   %eax,%eax
  800ca1:	75 13                	jne    800cb6 <umain+0x1a5>
        output(ns_envid);
  800ca3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800ca6:	89 c7                	mov    %eax,%edi
  800ca8:	48 b8 3b 0f 80 00 00 	movabs $0x800f3b,%rax
  800caf:	00 00 00 
  800cb2:	ff d0                	callq  *%rax
        return;
  800cb4:	eb 42                	jmp    800cf8 <umain+0x1e7>
    }

    // lwIP requires a user threading library; start the library and jump
    // into a thread to continue initialization.
    thread_init();
  800cb6:	48 b8 49 8d 81 00 00 	movabs $0x818d49,%rax
  800cbd:	00 00 00 
  800cc0:	ff d0                	callq  *%rax
    thread_create(0, "main", tmain, 0);
  800cc2:	b9 00 00 00 00       	mov    $0x0,%ecx
  800cc7:	48 ba 92 0a 80 00 00 	movabs $0x800a92,%rdx
  800cce:	00 00 00 
  800cd1:	48 be 08 0f 82 00 00 	movabs $0x820f08,%rsi
  800cd8:	00 00 00 
  800cdb:	bf 00 00 00 00       	mov    $0x0,%edi
  800ce0:	48 b8 5a 90 81 00 00 	movabs $0x81905a,%rax
  800ce7:	00 00 00 
  800cea:	ff d0                	callq  *%rax
    thread_yield();
  800cec:	48 b8 e1 92 81 00 00 	movabs $0x8192e1,%rax
  800cf3:	00 00 00 
  800cf6:	ff d0                	callq  *%rax
    // never coming here!
}
  800cf8:	c9                   	leaveq 
  800cf9:	c3                   	retq   

0000000000800cfa <timer>:

#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800cfa:	55                   	push   %rbp
  800cfb:	48 89 e5             	mov    %rsp,%rbp
  800cfe:	48 83 ec 20          	sub    $0x20,%rsp
  800d02:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800d05:	89 75 e8             	mov    %esi,-0x18(%rbp)
    int r;
    uint32_t stop = sys_time_msec() + initial_to;
  800d08:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  800d0f:	00 00 00 
  800d12:	ff d0                	callq  *%rax
  800d14:	89 c2                	mov    %eax,%edx
  800d16:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800d19:	01 d0                	add    %edx,%eax
  800d1b:	89 45 fc             	mov    %eax,-0x4(%rbp)

    binaryname = "ns_timer";
  800d1e:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800d25:	00 00 00 
  800d28:	48 b9 10 0f 82 00 00 	movabs $0x820f10,%rcx
  800d2f:	00 00 00 
  800d32:	48 89 08             	mov    %rcx,(%rax)

    while (1) {
        while((r = sys_time_msec()) < stop && r >= 0) {
  800d35:	eb 0c                	jmp    800d43 <timer+0x49>
            sys_yield();
  800d37:	48 b8 bb 27 80 00 00 	movabs $0x8027bb,%rax
  800d3e:	00 00 00 
  800d41:	ff d0                	callq  *%rax
    uint32_t stop = sys_time_msec() + initial_to;

    binaryname = "ns_timer";

    while (1) {
        while((r = sys_time_msec()) < stop && r >= 0) {
  800d43:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  800d4a:	00 00 00 
  800d4d:	ff d0                	callq  *%rax
  800d4f:	89 45 f8             	mov    %eax,-0x8(%rbp)
  800d52:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800d55:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800d58:	73 06                	jae    800d60 <timer+0x66>
  800d5a:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800d5e:	79 d7                	jns    800d37 <timer+0x3d>
            sys_yield();
        }
        if (r < 0)
  800d60:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800d64:	79 30                	jns    800d96 <timer+0x9c>
            panic("sys_time_msec: %e", r);
  800d66:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800d69:	89 c1                	mov    %eax,%ecx
  800d6b:	48 ba 19 0f 82 00 00 	movabs $0x820f19,%rdx
  800d72:	00 00 00 
  800d75:	be 10 00 00 00       	mov    $0x10,%esi
  800d7a:	48 bf 2b 0f 82 00 00 	movabs $0x820f2b,%rdi
  800d81:	00 00 00 
  800d84:	b8 00 00 00 00       	mov    $0x0,%eax
  800d89:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  800d90:	00 00 00 
  800d93:	41 ff d0             	callq  *%r8

        ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  800d96:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800d99:	b9 00 00 00 00       	mov    $0x0,%ecx
  800d9e:	ba 00 00 00 00       	mov    $0x0,%edx
  800da3:	be 0c 00 00 00       	mov    $0xc,%esi
  800da8:	89 c7                	mov    %eax,%edi
  800daa:	48 b8 cd 32 80 00 00 	movabs $0x8032cd,%rax
  800db1:	00 00 00 
  800db4:	ff d0                	callq  *%rax

        while (1) {
            uint32_t to, whom;
            to = ipc_recv((int32_t *) &whom, 0, 0);
  800db6:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  800dba:	ba 00 00 00 00       	mov    $0x0,%edx
  800dbf:	be 00 00 00 00       	mov    $0x0,%esi
  800dc4:	48 89 c7             	mov    %rax,%rdi
  800dc7:	48 b8 0c 32 80 00 00 	movabs $0x80320c,%rax
  800dce:	00 00 00 
  800dd1:	ff d0                	callq  *%rax
  800dd3:	89 45 f4             	mov    %eax,-0xc(%rbp)

            if (whom != ns_envid) {
  800dd6:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800dd9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800ddc:	39 c2                	cmp    %eax,%edx
  800dde:	74 22                	je     800e02 <timer+0x108>
                cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  800de0:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800de3:	89 c6                	mov    %eax,%esi
  800de5:	48 bf 38 0f 82 00 00 	movabs $0x820f38,%rdi
  800dec:	00 00 00 
  800def:	b8 00 00 00 00       	mov    $0x0,%eax
  800df4:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  800dfb:	00 00 00 
  800dfe:	ff d2                	callq  *%rdx
                continue;
            }

            stop = sys_time_msec() + to;
            break;
        }
  800e00:	eb b4                	jmp    800db6 <timer+0xbc>
            if (whom != ns_envid) {
                cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
                continue;
            }

            stop = sys_time_msec() + to;
  800e02:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  800e09:	00 00 00 
  800e0c:	ff d0                	callq  *%rax
  800e0e:	89 c2                	mov    %eax,%edx
  800e10:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800e13:	01 d0                	add    %edx,%eax
  800e15:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
        }
    }
  800e18:	e9 18 ff ff ff       	jmpq   800d35 <timer+0x3b>

0000000000800e1d <input>:

extern union Nsipc nsipcbuf;

    void
input(envid_t ns_envid)
{
  800e1d:	55                   	push   %rbp
  800e1e:	48 89 e5             	mov    %rsp,%rbp
  800e21:	48 83 ec 20          	sub    $0x20,%rsp
  800e25:	89 7d ec             	mov    %edi,-0x14(%rbp)
    binaryname = "ns_input";
  800e28:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800e2f:	00 00 00 
  800e32:	48 b9 73 0f 82 00 00 	movabs $0x820f73,%rcx
  800e39:	00 00 00 
  800e3c:	48 89 08             	mov    %rcx,(%rax)

    while (1) {
        int r;
        if ((r = sys_page_alloc(0, &nsipcbuf, PTE_P|PTE_U|PTE_W)) < 0)
  800e3f:	ba 07 00 00 00       	mov    $0x7,%edx
  800e44:	48 be 00 a0 b5 00 00 	movabs $0xb5a000,%rsi
  800e4b:	00 00 00 
  800e4e:	bf 00 00 00 00       	mov    $0x0,%edi
  800e53:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  800e5a:	00 00 00 
  800e5d:	ff d0                	callq  *%rax
  800e5f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800e62:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800e66:	79 30                	jns    800e98 <input+0x7b>
            panic("sys_page_alloc: %e", r);
  800e68:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800e6b:	89 c1                	mov    %eax,%ecx
  800e6d:	48 ba 7c 0f 82 00 00 	movabs $0x820f7c,%rdx
  800e74:	00 00 00 
  800e77:	be 0e 00 00 00       	mov    $0xe,%esi
  800e7c:	48 bf 8f 0f 82 00 00 	movabs $0x820f8f,%rdi
  800e83:	00 00 00 
  800e86:	b8 00 00 00 00       	mov    $0x0,%eax
  800e8b:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  800e92:	00 00 00 
  800e95:	41 ff d0             	callq  *%r8
        r = sys_net_receive(nsipcbuf.pkt.jp_data, 1518);
  800e98:	be ee 05 00 00       	mov    $0x5ee,%esi
  800e9d:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  800ea4:	00 00 00 
  800ea7:	48 b8 fe 2a 80 00 00 	movabs $0x802afe,%rax
  800eae:	00 00 00 
  800eb1:	ff d0                	callq  *%rax
  800eb3:	89 45 fc             	mov    %eax,-0x4(%rbp)
        if (r == 0) {
  800eb6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800eba:	75 11                	jne    800ecd <input+0xb0>
            sys_yield();
  800ebc:	48 b8 bb 27 80 00 00 	movabs $0x8027bb,%rax
  800ec3:	00 00 00 
  800ec6:	ff d0                	callq  *%rax
  800ec8:	e9 72 ff ff ff       	jmpq   800e3f <input+0x22>
        } else if (r < 0) {
  800ecd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800ed1:	79 25                	jns    800ef8 <input+0xdb>
            cprintf("Failed to receive packet: %e\n", r);
  800ed3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800ed6:	89 c6                	mov    %eax,%esi
  800ed8:	48 bf 9b 0f 82 00 00 	movabs $0x820f9b,%rdi
  800edf:	00 00 00 
  800ee2:	b8 00 00 00 00       	mov    $0x0,%eax
  800ee7:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  800eee:	00 00 00 
  800ef1:	ff d2                	callq  *%rdx
  800ef3:	e9 47 ff ff ff       	jmpq   800e3f <input+0x22>
        } else if (r > 0) {
  800ef8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800efc:	0f 8e 3d ff ff ff    	jle    800e3f <input+0x22>
            nsipcbuf.pkt.jp_len = r;
  800f02:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  800f09:	00 00 00 
  800f0c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800f0f:	89 10                	mov    %edx,(%rax)
            ipc_send(ns_envid, NSREQ_INPUT, &nsipcbuf, PTE_U|PTE_P);
  800f11:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800f14:	b9 05 00 00 00       	mov    $0x5,%ecx
  800f19:	48 ba 00 a0 b5 00 00 	movabs $0xb5a000,%rdx
  800f20:	00 00 00 
  800f23:	be 0a 00 00 00       	mov    $0xa,%esi
  800f28:	89 c7                	mov    %eax,%edi
  800f2a:	48 b8 cd 32 80 00 00 	movabs $0x8032cd,%rax
  800f31:	00 00 00 
  800f34:	ff d0                	callq  *%rax
        }
    }
  800f36:	e9 04 ff ff ff       	jmpq   800e3f <input+0x22>

0000000000800f3b <output>:

extern union Nsipc nsipcbuf;

    void
output(envid_t ns_envid)
{
  800f3b:	55                   	push   %rbp
  800f3c:	48 89 e5             	mov    %rsp,%rbp
  800f3f:	48 83 ec 20          	sub    $0x20,%rsp
  800f43:	89 7d ec             	mov    %edi,-0x14(%rbp)
    binaryname = "ns_output";
  800f46:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800f4d:	00 00 00 
  800f50:	48 b9 c0 0f 82 00 00 	movabs $0x820fc0,%rcx
  800f57:	00 00 00 
  800f5a:	48 89 08             	mov    %rcx,(%rax)

    int r;

    while (1) {
        int32_t req, whom;
        req = ipc_recv(&whom, &nsipcbuf, NULL);
  800f5d:	48 8d 45 f4          	lea    -0xc(%rbp),%rax
  800f61:	ba 00 00 00 00       	mov    $0x0,%edx
  800f66:	48 be 00 a0 b5 00 00 	movabs $0xb5a000,%rsi
  800f6d:	00 00 00 
  800f70:	48 89 c7             	mov    %rax,%rdi
  800f73:	48 b8 0c 32 80 00 00 	movabs $0x80320c,%rax
  800f7a:	00 00 00 
  800f7d:	ff d0                	callq  *%rax
  800f7f:	89 45 fc             	mov    %eax,-0x4(%rbp)
        assert(whom == ns_envid);
  800f82:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800f85:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800f88:	74 35                	je     800fbf <output+0x84>
  800f8a:	48 b9 ca 0f 82 00 00 	movabs $0x820fca,%rcx
  800f91:	00 00 00 
  800f94:	48 ba db 0f 82 00 00 	movabs $0x820fdb,%rdx
  800f9b:	00 00 00 
  800f9e:	be 11 00 00 00       	mov    $0x11,%esi
  800fa3:	48 bf f0 0f 82 00 00 	movabs $0x820ff0,%rdi
  800faa:	00 00 00 
  800fad:	b8 00 00 00 00       	mov    $0x0,%eax
  800fb2:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  800fb9:	00 00 00 
  800fbc:	41 ff d0             	callq  *%r8
        assert(req == NSREQ_OUTPUT);
  800fbf:	83 7d fc 0b          	cmpl   $0xb,-0x4(%rbp)
  800fc3:	74 35                	je     800ffa <output+0xbf>
  800fc5:	48 b9 fd 0f 82 00 00 	movabs $0x820ffd,%rcx
  800fcc:	00 00 00 
  800fcf:	48 ba db 0f 82 00 00 	movabs $0x820fdb,%rdx
  800fd6:	00 00 00 
  800fd9:	be 12 00 00 00       	mov    $0x12,%esi
  800fde:	48 bf f0 0f 82 00 00 	movabs $0x820ff0,%rdi
  800fe5:	00 00 00 
  800fe8:	b8 00 00 00 00       	mov    $0x0,%eax
  800fed:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  800ff4:	00 00 00 
  800ff7:	41 ff d0             	callq  *%r8
        if ((r = sys_net_transmit(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len)) < 0)
  800ffa:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  801001:	00 00 00 
  801004:	8b 00                	mov    (%rax),%eax
  801006:	89 c6                	mov    %eax,%esi
  801008:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  80100f:	00 00 00 
  801012:	48 b8 b4 2a 80 00 00 	movabs $0x802ab4,%rax
  801019:	00 00 00 
  80101c:	ff d0                	callq  *%rax
  80101e:	89 45 f8             	mov    %eax,-0x8(%rbp)
  801021:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  801025:	0f 89 32 ff ff ff    	jns    800f5d <output+0x22>
            cprintf("Failed to transmit packet: %e\n", r);
  80102b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80102e:	89 c6                	mov    %eax,%esi
  801030:	48 bf 18 10 82 00 00 	movabs $0x821018,%rdi
  801037:	00 00 00 
  80103a:	b8 00 00 00 00       	mov    $0x0,%eax
  80103f:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  801046:	00 00 00 
  801049:	ff d2                	callq  *%rdx
    }
  80104b:	e9 0d ff ff ff       	jmpq   800f5d <output+0x22>

0000000000801050 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  801050:	55                   	push   %rbp
  801051:	48 89 e5             	mov    %rsp,%rbp
  801054:	48 83 ec 10          	sub    $0x10,%rsp
  801058:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80105b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// set thisenv to point at our Env structure in envs[].

	thisenv = &envs[ENVX(sys_getenvid())];
  80105f:	48 b8 7f 27 80 00 00 	movabs $0x80277f,%rax
  801066:	00 00 00 
  801069:	ff d0                	callq  *%rax
  80106b:	25 ff 03 00 00       	and    $0x3ff,%eax
  801070:	48 98                	cltq   
  801072:	48 69 d0 68 01 00 00 	imul   $0x168,%rax,%rdx
  801079:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  801080:	00 00 00 
  801083:	48 01 c2             	add    %rax,%rdx
  801086:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  80108d:	00 00 00 
  801090:	48 89 10             	mov    %rdx,(%rax)


	// save the name of the program so that panic() can use it
	if (argc > 0)
  801093:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  801097:	7e 14                	jle    8010ad <libmain+0x5d>
		binaryname = argv[0];
  801099:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80109d:	48 8b 10             	mov    (%rax),%rdx
  8010a0:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  8010a7:	00 00 00 
  8010aa:	48 89 10             	mov    %rdx,(%rax)

	// call user main routine
	umain(argc, argv);
  8010ad:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8010b1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8010b4:	48 89 d6             	mov    %rdx,%rsi
  8010b7:	89 c7                	mov    %eax,%edi
  8010b9:	48 b8 11 0b 80 00 00 	movabs $0x800b11,%rax
  8010c0:	00 00 00 
  8010c3:	ff d0                	callq  *%rax

	// exit gracefully
	exit();
  8010c5:	48 b8 d4 10 80 00 00 	movabs $0x8010d4,%rax
  8010cc:	00 00 00 
  8010cf:	ff d0                	callq  *%rax
}
  8010d1:	90                   	nop
  8010d2:	c9                   	leaveq 
  8010d3:	c3                   	retq   

00000000008010d4 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  8010d4:	55                   	push   %rbp
  8010d5:	48 89 e5             	mov    %rsp,%rbp

	close_all();
  8010d8:	48 b8 8d 38 80 00 00 	movabs $0x80388d,%rax
  8010df:	00 00 00 
  8010e2:	ff d0                	callq  *%rax

	sys_env_destroy(0);
  8010e4:	bf 00 00 00 00       	mov    $0x0,%edi
  8010e9:	48 b8 39 27 80 00 00 	movabs $0x802739,%rax
  8010f0:	00 00 00 
  8010f3:	ff d0                	callq  *%rax
}
  8010f5:	90                   	nop
  8010f6:	5d                   	pop    %rbp
  8010f7:	c3                   	retq   

00000000008010f8 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  8010f8:	55                   	push   %rbp
  8010f9:	48 89 e5             	mov    %rsp,%rbp
  8010fc:	53                   	push   %rbx
  8010fd:	48 81 ec f8 00 00 00 	sub    $0xf8,%rsp
  801104:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  80110b:	89 b5 14 ff ff ff    	mov    %esi,-0xec(%rbp)
  801111:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  801118:	48 89 8d 58 ff ff ff 	mov    %rcx,-0xa8(%rbp)
  80111f:	4c 89 85 60 ff ff ff 	mov    %r8,-0xa0(%rbp)
  801126:	4c 89 8d 68 ff ff ff 	mov    %r9,-0x98(%rbp)
  80112d:	84 c0                	test   %al,%al
  80112f:	74 23                	je     801154 <_panic+0x5c>
  801131:	0f 29 85 70 ff ff ff 	movaps %xmm0,-0x90(%rbp)
  801138:	0f 29 4d 80          	movaps %xmm1,-0x80(%rbp)
  80113c:	0f 29 55 90          	movaps %xmm2,-0x70(%rbp)
  801140:	0f 29 5d a0          	movaps %xmm3,-0x60(%rbp)
  801144:	0f 29 65 b0          	movaps %xmm4,-0x50(%rbp)
  801148:	0f 29 6d c0          	movaps %xmm5,-0x40(%rbp)
  80114c:	0f 29 75 d0          	movaps %xmm6,-0x30(%rbp)
  801150:	0f 29 7d e0          	movaps %xmm7,-0x20(%rbp)
	va_list ap;

	va_start(ap, fmt);
  801154:	c7 85 28 ff ff ff 18 	movl   $0x18,-0xd8(%rbp)
  80115b:	00 00 00 
  80115e:	c7 85 2c ff ff ff 30 	movl   $0x30,-0xd4(%rbp)
  801165:	00 00 00 
  801168:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80116c:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  801173:	48 8d 85 40 ff ff ff 	lea    -0xc0(%rbp),%rax
  80117a:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  801181:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  801188:	00 00 00 
  80118b:	48 8b 18             	mov    (%rax),%rbx
  80118e:	48 b8 7f 27 80 00 00 	movabs $0x80277f,%rax
  801195:	00 00 00 
  801198:	ff d0                	callq  *%rax
  80119a:	89 c6                	mov    %eax,%esi
  80119c:	8b 95 14 ff ff ff    	mov    -0xec(%rbp),%edx
  8011a2:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8011a9:	41 89 d0             	mov    %edx,%r8d
  8011ac:	48 89 c1             	mov    %rax,%rcx
  8011af:	48 89 da             	mov    %rbx,%rdx
  8011b2:	48 bf 48 10 82 00 00 	movabs $0x821048,%rdi
  8011b9:	00 00 00 
  8011bc:	b8 00 00 00 00       	mov    $0x0,%eax
  8011c1:	49 b9 32 13 80 00 00 	movabs $0x801332,%r9
  8011c8:	00 00 00 
  8011cb:	41 ff d1             	callq  *%r9
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  8011ce:	48 8d 95 28 ff ff ff 	lea    -0xd8(%rbp),%rdx
  8011d5:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8011dc:	48 89 d6             	mov    %rdx,%rsi
  8011df:	48 89 c7             	mov    %rax,%rdi
  8011e2:	48 b8 86 12 80 00 00 	movabs $0x801286,%rax
  8011e9:	00 00 00 
  8011ec:	ff d0                	callq  *%rax
	cprintf("\n");
  8011ee:	48 bf 6b 10 82 00 00 	movabs $0x82106b,%rdi
  8011f5:	00 00 00 
  8011f8:	b8 00 00 00 00       	mov    $0x0,%eax
  8011fd:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  801204:	00 00 00 
  801207:	ff d2                	callq  *%rdx

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  801209:	cc                   	int3   
  80120a:	eb fd                	jmp    801209 <_panic+0x111>

000000000080120c <putch>:
};


    static void
putch(int ch, struct printbuf *b)
{
  80120c:	55                   	push   %rbp
  80120d:	48 89 e5             	mov    %rsp,%rbp
  801210:	48 83 ec 10          	sub    $0x10,%rsp
  801214:	89 7d fc             	mov    %edi,-0x4(%rbp)
  801217:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    b->buf[b->idx++] = ch;
  80121b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80121f:	8b 00                	mov    (%rax),%eax
  801221:	8d 48 01             	lea    0x1(%rax),%ecx
  801224:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801228:	89 0a                	mov    %ecx,(%rdx)
  80122a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80122d:	89 d1                	mov    %edx,%ecx
  80122f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801233:	48 98                	cltq   
  801235:	88 4c 02 08          	mov    %cl,0x8(%rdx,%rax,1)
    if (b->idx == 256-1) {
  801239:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80123d:	8b 00                	mov    (%rax),%eax
  80123f:	3d ff 00 00 00       	cmp    $0xff,%eax
  801244:	75 2c                	jne    801272 <putch+0x66>
        sys_cputs(b->buf, b->idx);
  801246:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80124a:	8b 00                	mov    (%rax),%eax
  80124c:	48 98                	cltq   
  80124e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801252:	48 83 c2 08          	add    $0x8,%rdx
  801256:	48 89 c6             	mov    %rax,%rsi
  801259:	48 89 d7             	mov    %rdx,%rdi
  80125c:	48 b8 b0 26 80 00 00 	movabs $0x8026b0,%rax
  801263:	00 00 00 
  801266:	ff d0                	callq  *%rax
        b->idx = 0;
  801268:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80126c:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
    }
    b->cnt++;
  801272:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801276:	8b 40 04             	mov    0x4(%rax),%eax
  801279:	8d 50 01             	lea    0x1(%rax),%edx
  80127c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801280:	89 50 04             	mov    %edx,0x4(%rax)
}
  801283:	90                   	nop
  801284:	c9                   	leaveq 
  801285:	c3                   	retq   

0000000000801286 <vcprintf>:

    int
vcprintf(const char *fmt, va_list ap)
{
  801286:	55                   	push   %rbp
  801287:	48 89 e5             	mov    %rsp,%rbp
  80128a:	48 81 ec 40 01 00 00 	sub    $0x140,%rsp
  801291:	48 89 bd c8 fe ff ff 	mov    %rdi,-0x138(%rbp)
  801298:	48 89 b5 c0 fe ff ff 	mov    %rsi,-0x140(%rbp)
    struct printbuf b;
    va_list aq;
    va_copy(aq,ap);
  80129f:	48 8d 85 d8 fe ff ff 	lea    -0x128(%rbp),%rax
  8012a6:	48 8b 95 c0 fe ff ff 	mov    -0x140(%rbp),%rdx
  8012ad:	48 8b 0a             	mov    (%rdx),%rcx
  8012b0:	48 89 08             	mov    %rcx,(%rax)
  8012b3:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8012b7:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8012bb:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8012bf:	48 89 50 10          	mov    %rdx,0x10(%rax)
    b.idx = 0;
  8012c3:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%rbp)
  8012ca:	00 00 00 
    b.cnt = 0;
  8012cd:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%rbp)
  8012d4:	00 00 00 
    vprintfmt((void*)putch, &b, fmt, aq);
  8012d7:	48 8d 8d d8 fe ff ff 	lea    -0x128(%rbp),%rcx
  8012de:	48 8b 95 c8 fe ff ff 	mov    -0x138(%rbp),%rdx
  8012e5:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  8012ec:	48 89 c6             	mov    %rax,%rsi
  8012ef:	48 bf 0c 12 80 00 00 	movabs $0x80120c,%rdi
  8012f6:	00 00 00 
  8012f9:	48 b8 d0 16 80 00 00 	movabs $0x8016d0,%rax
  801300:	00 00 00 
  801303:	ff d0                	callq  *%rax
    sys_cputs(b.buf, b.idx);
  801305:	8b 85 f0 fe ff ff    	mov    -0x110(%rbp),%eax
  80130b:	48 98                	cltq   
  80130d:	48 8d 95 f0 fe ff ff 	lea    -0x110(%rbp),%rdx
  801314:	48 83 c2 08          	add    $0x8,%rdx
  801318:	48 89 c6             	mov    %rax,%rsi
  80131b:	48 89 d7             	mov    %rdx,%rdi
  80131e:	48 b8 b0 26 80 00 00 	movabs $0x8026b0,%rax
  801325:	00 00 00 
  801328:	ff d0                	callq  *%rax
    va_end(aq);

    return b.cnt;
  80132a:	8b 85 f4 fe ff ff    	mov    -0x10c(%rbp),%eax
}
  801330:	c9                   	leaveq 
  801331:	c3                   	retq   

0000000000801332 <cprintf>:

    int
cprintf(const char *fmt, ...)
{
  801332:	55                   	push   %rbp
  801333:	48 89 e5             	mov    %rsp,%rbp
  801336:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  80133d:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  801344:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  80134b:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  801352:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801359:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801360:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801367:	84 c0                	test   %al,%al
  801369:	74 20                	je     80138b <cprintf+0x59>
  80136b:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80136f:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801373:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801377:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80137b:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80137f:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801383:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801387:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
    va_list ap;
    int cnt;
    va_list aq;
    va_start(ap, fmt);
  80138b:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  801392:	00 00 00 
  801395:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  80139c:	00 00 00 
  80139f:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8013a3:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8013aa:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8013b1:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    va_copy(aq,ap);
  8013b8:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  8013bf:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8013c6:	48 8b 0a             	mov    (%rdx),%rcx
  8013c9:	48 89 08             	mov    %rcx,(%rax)
  8013cc:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8013d0:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8013d4:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8013d8:	48 89 50 10          	mov    %rdx,0x10(%rax)
    cnt = vcprintf(fmt, aq);
  8013dc:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  8013e3:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8013ea:	48 89 d6             	mov    %rdx,%rsi
  8013ed:	48 89 c7             	mov    %rax,%rdi
  8013f0:	48 b8 86 12 80 00 00 	movabs $0x801286,%rax
  8013f7:	00 00 00 
  8013fa:	ff d0                	callq  *%rax
  8013fc:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
    va_end(aq);

    return cnt;
  801402:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  801408:	c9                   	leaveq 
  801409:	c3                   	retq   

000000000080140a <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80140a:	55                   	push   %rbp
  80140b:	48 89 e5             	mov    %rsp,%rbp
  80140e:	48 83 ec 30          	sub    $0x30,%rsp
  801412:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  801416:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80141a:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80141e:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
  801421:	44 89 45 e0          	mov    %r8d,-0x20(%rbp)
  801425:	44 89 4d dc          	mov    %r9d,-0x24(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  801429:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80142c:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  801430:	77 54                	ja     801486 <printnum+0x7c>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  801432:	8b 45 e0             	mov    -0x20(%rbp),%eax
  801435:	8d 78 ff             	lea    -0x1(%rax),%edi
  801438:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  80143b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80143f:	ba 00 00 00 00       	mov    $0x0,%edx
  801444:	48 f7 f6             	div    %rsi
  801447:	49 89 c2             	mov    %rax,%r10
  80144a:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  80144d:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  801450:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  801454:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801458:	41 89 c9             	mov    %ecx,%r9d
  80145b:	41 89 f8             	mov    %edi,%r8d
  80145e:	89 d1                	mov    %edx,%ecx
  801460:	4c 89 d2             	mov    %r10,%rdx
  801463:	48 89 c7             	mov    %rax,%rdi
  801466:	48 b8 0a 14 80 00 00 	movabs $0x80140a,%rax
  80146d:	00 00 00 
  801470:	ff d0                	callq  *%rax
  801472:	eb 1c                	jmp    801490 <printnum+0x86>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  801474:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  801478:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80147b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80147f:	48 89 ce             	mov    %rcx,%rsi
  801482:	89 d7                	mov    %edx,%edi
  801484:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  801486:	83 6d e0 01          	subl   $0x1,-0x20(%rbp)
  80148a:	83 7d e0 00          	cmpl   $0x0,-0x20(%rbp)
  80148e:	7f e4                	jg     801474 <printnum+0x6a>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  801490:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  801493:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801497:	ba 00 00 00 00       	mov    $0x0,%edx
  80149c:	48 f7 f1             	div    %rcx
  80149f:	48 b8 70 12 82 00 00 	movabs $0x821270,%rax
  8014a6:	00 00 00 
  8014a9:	0f b6 04 10          	movzbl (%rax,%rdx,1),%eax
  8014ad:	0f be d0             	movsbl %al,%edx
  8014b0:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8014b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8014b8:	48 89 ce             	mov    %rcx,%rsi
  8014bb:	89 d7                	mov    %edx,%edi
  8014bd:	ff d0                	callq  *%rax
}
  8014bf:	90                   	nop
  8014c0:	c9                   	leaveq 
  8014c1:	c3                   	retq   

00000000008014c2 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  8014c2:	55                   	push   %rbp
  8014c3:	48 89 e5             	mov    %rsp,%rbp
  8014c6:	48 83 ec 20          	sub    $0x20,%rsp
  8014ca:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8014ce:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  8014d1:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  8014d5:	7e 4f                	jle    801526 <getuint+0x64>
		x= va_arg(*ap, unsigned long long);
  8014d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014db:	8b 00                	mov    (%rax),%eax
  8014dd:	83 f8 30             	cmp    $0x30,%eax
  8014e0:	73 24                	jae    801506 <getuint+0x44>
  8014e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014e6:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8014ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014ee:	8b 00                	mov    (%rax),%eax
  8014f0:	89 c0                	mov    %eax,%eax
  8014f2:	48 01 d0             	add    %rdx,%rax
  8014f5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8014f9:	8b 12                	mov    (%rdx),%edx
  8014fb:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8014fe:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801502:	89 0a                	mov    %ecx,(%rdx)
  801504:	eb 14                	jmp    80151a <getuint+0x58>
  801506:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80150a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80150e:	48 8d 48 08          	lea    0x8(%rax),%rcx
  801512:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801516:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  80151a:	48 8b 00             	mov    (%rax),%rax
  80151d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  801521:	e9 9d 00 00 00       	jmpq   8015c3 <getuint+0x101>
	else if (lflag)
  801526:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80152a:	74 4c                	je     801578 <getuint+0xb6>
		x= va_arg(*ap, unsigned long);
  80152c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801530:	8b 00                	mov    (%rax),%eax
  801532:	83 f8 30             	cmp    $0x30,%eax
  801535:	73 24                	jae    80155b <getuint+0x99>
  801537:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80153b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80153f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801543:	8b 00                	mov    (%rax),%eax
  801545:	89 c0                	mov    %eax,%eax
  801547:	48 01 d0             	add    %rdx,%rax
  80154a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80154e:	8b 12                	mov    (%rdx),%edx
  801550:	8d 4a 08             	lea    0x8(%rdx),%ecx
  801553:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801557:	89 0a                	mov    %ecx,(%rdx)
  801559:	eb 14                	jmp    80156f <getuint+0xad>
  80155b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80155f:	48 8b 40 08          	mov    0x8(%rax),%rax
  801563:	48 8d 48 08          	lea    0x8(%rax),%rcx
  801567:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80156b:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  80156f:	48 8b 00             	mov    (%rax),%rax
  801572:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  801576:	eb 4b                	jmp    8015c3 <getuint+0x101>
	else
		x= va_arg(*ap, unsigned int);
  801578:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80157c:	8b 00                	mov    (%rax),%eax
  80157e:	83 f8 30             	cmp    $0x30,%eax
  801581:	73 24                	jae    8015a7 <getuint+0xe5>
  801583:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801587:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80158b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80158f:	8b 00                	mov    (%rax),%eax
  801591:	89 c0                	mov    %eax,%eax
  801593:	48 01 d0             	add    %rdx,%rax
  801596:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80159a:	8b 12                	mov    (%rdx),%edx
  80159c:	8d 4a 08             	lea    0x8(%rdx),%ecx
  80159f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8015a3:	89 0a                	mov    %ecx,(%rdx)
  8015a5:	eb 14                	jmp    8015bb <getuint+0xf9>
  8015a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015ab:	48 8b 40 08          	mov    0x8(%rax),%rax
  8015af:	48 8d 48 08          	lea    0x8(%rax),%rcx
  8015b3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8015b7:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8015bb:	8b 00                	mov    (%rax),%eax
  8015bd:	89 c0                	mov    %eax,%eax
  8015bf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  8015c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8015c7:	c9                   	leaveq 
  8015c8:	c3                   	retq   

00000000008015c9 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  8015c9:	55                   	push   %rbp
  8015ca:	48 89 e5             	mov    %rsp,%rbp
  8015cd:	48 83 ec 20          	sub    $0x20,%rsp
  8015d1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8015d5:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  8015d8:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  8015dc:	7e 4f                	jle    80162d <getint+0x64>
		x=va_arg(*ap, long long);
  8015de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015e2:	8b 00                	mov    (%rax),%eax
  8015e4:	83 f8 30             	cmp    $0x30,%eax
  8015e7:	73 24                	jae    80160d <getint+0x44>
  8015e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015ed:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8015f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015f5:	8b 00                	mov    (%rax),%eax
  8015f7:	89 c0                	mov    %eax,%eax
  8015f9:	48 01 d0             	add    %rdx,%rax
  8015fc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801600:	8b 12                	mov    (%rdx),%edx
  801602:	8d 4a 08             	lea    0x8(%rdx),%ecx
  801605:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801609:	89 0a                	mov    %ecx,(%rdx)
  80160b:	eb 14                	jmp    801621 <getint+0x58>
  80160d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801611:	48 8b 40 08          	mov    0x8(%rax),%rax
  801615:	48 8d 48 08          	lea    0x8(%rax),%rcx
  801619:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80161d:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  801621:	48 8b 00             	mov    (%rax),%rax
  801624:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  801628:	e9 9d 00 00 00       	jmpq   8016ca <getint+0x101>
	else if (lflag)
  80162d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  801631:	74 4c                	je     80167f <getint+0xb6>
		x=va_arg(*ap, long);
  801633:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801637:	8b 00                	mov    (%rax),%eax
  801639:	83 f8 30             	cmp    $0x30,%eax
  80163c:	73 24                	jae    801662 <getint+0x99>
  80163e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801642:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801646:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80164a:	8b 00                	mov    (%rax),%eax
  80164c:	89 c0                	mov    %eax,%eax
  80164e:	48 01 d0             	add    %rdx,%rax
  801651:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801655:	8b 12                	mov    (%rdx),%edx
  801657:	8d 4a 08             	lea    0x8(%rdx),%ecx
  80165a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80165e:	89 0a                	mov    %ecx,(%rdx)
  801660:	eb 14                	jmp    801676 <getint+0xad>
  801662:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801666:	48 8b 40 08          	mov    0x8(%rax),%rax
  80166a:	48 8d 48 08          	lea    0x8(%rax),%rcx
  80166e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801672:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  801676:	48 8b 00             	mov    (%rax),%rax
  801679:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80167d:	eb 4b                	jmp    8016ca <getint+0x101>
	else
		x=va_arg(*ap, int);
  80167f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801683:	8b 00                	mov    (%rax),%eax
  801685:	83 f8 30             	cmp    $0x30,%eax
  801688:	73 24                	jae    8016ae <getint+0xe5>
  80168a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80168e:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801692:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801696:	8b 00                	mov    (%rax),%eax
  801698:	89 c0                	mov    %eax,%eax
  80169a:	48 01 d0             	add    %rdx,%rax
  80169d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8016a1:	8b 12                	mov    (%rdx),%edx
  8016a3:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8016a6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8016aa:	89 0a                	mov    %ecx,(%rdx)
  8016ac:	eb 14                	jmp    8016c2 <getint+0xf9>
  8016ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8016b2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8016b6:	48 8d 48 08          	lea    0x8(%rax),%rcx
  8016ba:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8016be:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8016c2:	8b 00                	mov    (%rax),%eax
  8016c4:	48 98                	cltq   
  8016c6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  8016ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8016ce:	c9                   	leaveq 
  8016cf:	c3                   	retq   

00000000008016d0 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  8016d0:	55                   	push   %rbp
  8016d1:	48 89 e5             	mov    %rsp,%rbp
  8016d4:	41 54                	push   %r12
  8016d6:	53                   	push   %rbx
  8016d7:	48 83 ec 60          	sub    $0x60,%rsp
  8016db:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8016df:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8016e3:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  8016e7:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  8016eb:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8016ef:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8016f3:	48 8b 0a             	mov    (%rdx),%rcx
  8016f6:	48 89 08             	mov    %rcx,(%rax)
  8016f9:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8016fd:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801701:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801705:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  801709:	eb 17                	jmp    801722 <vprintfmt+0x52>
			if (ch == '\0')
  80170b:	85 db                	test   %ebx,%ebx
  80170d:	0f 84 b9 04 00 00    	je     801bcc <vprintfmt+0x4fc>
				return;
			putch(ch, putdat);
  801713:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801717:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80171b:	48 89 d6             	mov    %rdx,%rsi
  80171e:	89 df                	mov    %ebx,%edi
  801720:	ff d0                	callq  *%rax
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  801722:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  801726:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80172a:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  80172e:	0f b6 00             	movzbl (%rax),%eax
  801731:	0f b6 d8             	movzbl %al,%ebx
  801734:	83 fb 25             	cmp    $0x25,%ebx
  801737:	75 d2                	jne    80170b <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  801739:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  80173d:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  801744:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  80174b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  801752:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  801759:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80175d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801761:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  801765:	0f b6 00             	movzbl (%rax),%eax
  801768:	0f b6 d8             	movzbl %al,%ebx
  80176b:	8d 43 dd             	lea    -0x23(%rbx),%eax
  80176e:	83 f8 55             	cmp    $0x55,%eax
  801771:	0f 87 22 04 00 00    	ja     801b99 <vprintfmt+0x4c9>
  801777:	89 c0                	mov    %eax,%eax
  801779:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  801780:	00 
  801781:	48 b8 98 12 82 00 00 	movabs $0x821298,%rax
  801788:	00 00 00 
  80178b:	48 01 d0             	add    %rdx,%rax
  80178e:	48 8b 00             	mov    (%rax),%rax
  801791:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  801793:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  801797:	eb c0                	jmp    801759 <vprintfmt+0x89>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  801799:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  80179d:	eb ba                	jmp    801759 <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  80179f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  8017a6:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8017a9:	89 d0                	mov    %edx,%eax
  8017ab:	c1 e0 02             	shl    $0x2,%eax
  8017ae:	01 d0                	add    %edx,%eax
  8017b0:	01 c0                	add    %eax,%eax
  8017b2:	01 d8                	add    %ebx,%eax
  8017b4:	83 e8 30             	sub    $0x30,%eax
  8017b7:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  8017ba:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8017be:	0f b6 00             	movzbl (%rax),%eax
  8017c1:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  8017c4:	83 fb 2f             	cmp    $0x2f,%ebx
  8017c7:	7e 60                	jle    801829 <vprintfmt+0x159>
  8017c9:	83 fb 39             	cmp    $0x39,%ebx
  8017cc:	7f 5b                	jg     801829 <vprintfmt+0x159>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  8017ce:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  8017d3:	eb d1                	jmp    8017a6 <vprintfmt+0xd6>
			goto process_precision;

		case '*':
			precision = va_arg(aq, int);
  8017d5:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8017d8:	83 f8 30             	cmp    $0x30,%eax
  8017db:	73 17                	jae    8017f4 <vprintfmt+0x124>
  8017dd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8017e1:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8017e4:	89 d2                	mov    %edx,%edx
  8017e6:	48 01 d0             	add    %rdx,%rax
  8017e9:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8017ec:	83 c2 08             	add    $0x8,%edx
  8017ef:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8017f2:	eb 0c                	jmp    801800 <vprintfmt+0x130>
  8017f4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8017f8:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8017fc:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  801800:	8b 00                	mov    (%rax),%eax
  801802:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  801805:	eb 23                	jmp    80182a <vprintfmt+0x15a>

		case '.':
			if (width < 0)
  801807:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80180b:	0f 89 48 ff ff ff    	jns    801759 <vprintfmt+0x89>
				width = 0;
  801811:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  801818:	e9 3c ff ff ff       	jmpq   801759 <vprintfmt+0x89>

		case '#':
			altflag = 1;
  80181d:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  801824:	e9 30 ff ff ff       	jmpq   801759 <vprintfmt+0x89>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
  801829:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
  80182a:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80182e:	0f 89 25 ff ff ff    	jns    801759 <vprintfmt+0x89>
				width = precision, precision = -1;
  801834:	8b 45 d8             	mov    -0x28(%rbp),%eax
  801837:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80183a:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  801841:	e9 13 ff ff ff       	jmpq   801759 <vprintfmt+0x89>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  801846:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  80184a:	e9 0a ff ff ff       	jmpq   801759 <vprintfmt+0x89>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  80184f:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801852:	83 f8 30             	cmp    $0x30,%eax
  801855:	73 17                	jae    80186e <vprintfmt+0x19e>
  801857:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80185b:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80185e:	89 d2                	mov    %edx,%edx
  801860:	48 01 d0             	add    %rdx,%rax
  801863:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801866:	83 c2 08             	add    $0x8,%edx
  801869:	89 55 b8             	mov    %edx,-0x48(%rbp)
  80186c:	eb 0c                	jmp    80187a <vprintfmt+0x1aa>
  80186e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  801872:	48 8d 50 08          	lea    0x8(%rax),%rdx
  801876:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  80187a:	8b 10                	mov    (%rax),%edx
  80187c:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  801880:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801884:	48 89 ce             	mov    %rcx,%rsi
  801887:	89 d7                	mov    %edx,%edi
  801889:	ff d0                	callq  *%rax
			break;
  80188b:	e9 37 03 00 00       	jmpq   801bc7 <vprintfmt+0x4f7>

			// error message
		case 'e':
			err = va_arg(aq, int);
  801890:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801893:	83 f8 30             	cmp    $0x30,%eax
  801896:	73 17                	jae    8018af <vprintfmt+0x1df>
  801898:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80189c:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80189f:	89 d2                	mov    %edx,%edx
  8018a1:	48 01 d0             	add    %rdx,%rax
  8018a4:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8018a7:	83 c2 08             	add    $0x8,%edx
  8018aa:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8018ad:	eb 0c                	jmp    8018bb <vprintfmt+0x1eb>
  8018af:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8018b3:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8018b7:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8018bb:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  8018bd:	85 db                	test   %ebx,%ebx
  8018bf:	79 02                	jns    8018c3 <vprintfmt+0x1f3>
				err = -err;
  8018c1:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  8018c3:	83 fb 15             	cmp    $0x15,%ebx
  8018c6:	7f 16                	jg     8018de <vprintfmt+0x20e>
  8018c8:	48 b8 c0 11 82 00 00 	movabs $0x8211c0,%rax
  8018cf:	00 00 00 
  8018d2:	48 63 d3             	movslq %ebx,%rdx
  8018d5:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  8018d9:	4d 85 e4             	test   %r12,%r12
  8018dc:	75 2e                	jne    80190c <vprintfmt+0x23c>
				printfmt(putch, putdat, "error %d", err);
  8018de:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  8018e2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8018e6:	89 d9                	mov    %ebx,%ecx
  8018e8:	48 ba 81 12 82 00 00 	movabs $0x821281,%rdx
  8018ef:	00 00 00 
  8018f2:	48 89 c7             	mov    %rax,%rdi
  8018f5:	b8 00 00 00 00       	mov    $0x0,%eax
  8018fa:	49 b8 d6 1b 80 00 00 	movabs $0x801bd6,%r8
  801901:	00 00 00 
  801904:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  801907:	e9 bb 02 00 00       	jmpq   801bc7 <vprintfmt+0x4f7>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  80190c:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  801910:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801914:	4c 89 e1             	mov    %r12,%rcx
  801917:	48 ba 8a 12 82 00 00 	movabs $0x82128a,%rdx
  80191e:	00 00 00 
  801921:	48 89 c7             	mov    %rax,%rdi
  801924:	b8 00 00 00 00       	mov    $0x0,%eax
  801929:	49 b8 d6 1b 80 00 00 	movabs $0x801bd6,%r8
  801930:	00 00 00 
  801933:	41 ff d0             	callq  *%r8
			break;
  801936:	e9 8c 02 00 00       	jmpq   801bc7 <vprintfmt+0x4f7>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  80193b:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80193e:	83 f8 30             	cmp    $0x30,%eax
  801941:	73 17                	jae    80195a <vprintfmt+0x28a>
  801943:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  801947:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80194a:	89 d2                	mov    %edx,%edx
  80194c:	48 01 d0             	add    %rdx,%rax
  80194f:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801952:	83 c2 08             	add    $0x8,%edx
  801955:	89 55 b8             	mov    %edx,-0x48(%rbp)
  801958:	eb 0c                	jmp    801966 <vprintfmt+0x296>
  80195a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80195e:	48 8d 50 08          	lea    0x8(%rax),%rdx
  801962:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  801966:	4c 8b 20             	mov    (%rax),%r12
  801969:	4d 85 e4             	test   %r12,%r12
  80196c:	75 0a                	jne    801978 <vprintfmt+0x2a8>
				p = "(null)";
  80196e:	49 bc 8d 12 82 00 00 	movabs $0x82128d,%r12
  801975:	00 00 00 
			if (width > 0 && padc != '-')
  801978:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80197c:	7e 78                	jle    8019f6 <vprintfmt+0x326>
  80197e:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  801982:	74 72                	je     8019f6 <vprintfmt+0x326>
				for (width -= strnlen(p, precision); width > 0; width--)
  801984:	8b 45 d8             	mov    -0x28(%rbp),%eax
  801987:	48 98                	cltq   
  801989:	48 89 c6             	mov    %rax,%rsi
  80198c:	4c 89 e7             	mov    %r12,%rdi
  80198f:	48 b8 84 1e 80 00 00 	movabs $0x801e84,%rax
  801996:	00 00 00 
  801999:	ff d0                	callq  *%rax
  80199b:	29 45 dc             	sub    %eax,-0x24(%rbp)
  80199e:	eb 17                	jmp    8019b7 <vprintfmt+0x2e7>
					putch(padc, putdat);
  8019a0:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  8019a4:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8019a8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8019ac:	48 89 ce             	mov    %rcx,%rsi
  8019af:	89 d7                	mov    %edx,%edi
  8019b1:	ff d0                	callq  *%rax
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  8019b3:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  8019b7:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8019bb:	7f e3                	jg     8019a0 <vprintfmt+0x2d0>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  8019bd:	eb 37                	jmp    8019f6 <vprintfmt+0x326>
				if (altflag && (ch < ' ' || ch > '~'))
  8019bf:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  8019c3:	74 1e                	je     8019e3 <vprintfmt+0x313>
  8019c5:	83 fb 1f             	cmp    $0x1f,%ebx
  8019c8:	7e 05                	jle    8019cf <vprintfmt+0x2ff>
  8019ca:	83 fb 7e             	cmp    $0x7e,%ebx
  8019cd:	7e 14                	jle    8019e3 <vprintfmt+0x313>
					putch('?', putdat);
  8019cf:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8019d3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8019d7:	48 89 d6             	mov    %rdx,%rsi
  8019da:	bf 3f 00 00 00       	mov    $0x3f,%edi
  8019df:	ff d0                	callq  *%rax
  8019e1:	eb 0f                	jmp    8019f2 <vprintfmt+0x322>
				else
					putch(ch, putdat);
  8019e3:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8019e7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8019eb:	48 89 d6             	mov    %rdx,%rsi
  8019ee:	89 df                	mov    %ebx,%edi
  8019f0:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  8019f2:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  8019f6:	4c 89 e0             	mov    %r12,%rax
  8019f9:	4c 8d 60 01          	lea    0x1(%rax),%r12
  8019fd:	0f b6 00             	movzbl (%rax),%eax
  801a00:	0f be d8             	movsbl %al,%ebx
  801a03:	85 db                	test   %ebx,%ebx
  801a05:	74 28                	je     801a2f <vprintfmt+0x35f>
  801a07:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  801a0b:	78 b2                	js     8019bf <vprintfmt+0x2ef>
  801a0d:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  801a11:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  801a15:	79 a8                	jns    8019bf <vprintfmt+0x2ef>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  801a17:	eb 16                	jmp    801a2f <vprintfmt+0x35f>
				putch(' ', putdat);
  801a19:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801a1d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801a21:	48 89 d6             	mov    %rdx,%rsi
  801a24:	bf 20 00 00 00       	mov    $0x20,%edi
  801a29:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  801a2b:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  801a2f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  801a33:	7f e4                	jg     801a19 <vprintfmt+0x349>
				putch(' ', putdat);
			break;
  801a35:	e9 8d 01 00 00       	jmpq   801bc7 <vprintfmt+0x4f7>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  801a3a:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801a3e:	be 03 00 00 00       	mov    $0x3,%esi
  801a43:	48 89 c7             	mov    %rax,%rdi
  801a46:	48 b8 c9 15 80 00 00 	movabs $0x8015c9,%rax
  801a4d:	00 00 00 
  801a50:	ff d0                	callq  *%rax
  801a52:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  801a56:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801a5a:	48 85 c0             	test   %rax,%rax
  801a5d:	79 1d                	jns    801a7c <vprintfmt+0x3ac>
				putch('-', putdat);
  801a5f:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801a63:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801a67:	48 89 d6             	mov    %rdx,%rsi
  801a6a:	bf 2d 00 00 00       	mov    $0x2d,%edi
  801a6f:	ff d0                	callq  *%rax
				num = -(long long) num;
  801a71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801a75:	48 f7 d8             	neg    %rax
  801a78:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  801a7c:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  801a83:	e9 d2 00 00 00       	jmpq   801b5a <vprintfmt+0x48a>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  801a88:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801a8c:	be 03 00 00 00       	mov    $0x3,%esi
  801a91:	48 89 c7             	mov    %rax,%rdi
  801a94:	48 b8 c2 14 80 00 00 	movabs $0x8014c2,%rax
  801a9b:	00 00 00 
  801a9e:	ff d0                	callq  *%rax
  801aa0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  801aa4:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  801aab:	e9 aa 00 00 00       	jmpq   801b5a <vprintfmt+0x48a>

			// (unsigned) octal
		case 'o':

			num = getuint(&aq, 3);
  801ab0:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801ab4:	be 03 00 00 00       	mov    $0x3,%esi
  801ab9:	48 89 c7             	mov    %rax,%rdi
  801abc:	48 b8 c2 14 80 00 00 	movabs $0x8014c2,%rax
  801ac3:	00 00 00 
  801ac6:	ff d0                	callq  *%rax
  801ac8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 8;
  801acc:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
			goto number;
  801ad3:	e9 82 00 00 00       	jmpq   801b5a <vprintfmt+0x48a>


			// pointer
		case 'p':
			putch('0', putdat);
  801ad8:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801adc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801ae0:	48 89 d6             	mov    %rdx,%rsi
  801ae3:	bf 30 00 00 00       	mov    $0x30,%edi
  801ae8:	ff d0                	callq  *%rax
			putch('x', putdat);
  801aea:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801aee:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801af2:	48 89 d6             	mov    %rdx,%rsi
  801af5:	bf 78 00 00 00       	mov    $0x78,%edi
  801afa:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  801afc:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801aff:	83 f8 30             	cmp    $0x30,%eax
  801b02:	73 17                	jae    801b1b <vprintfmt+0x44b>
  801b04:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  801b08:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801b0b:	89 d2                	mov    %edx,%edx
  801b0d:	48 01 d0             	add    %rdx,%rax
  801b10:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801b13:	83 c2 08             	add    $0x8,%edx
  801b16:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  801b19:	eb 0c                	jmp    801b27 <vprintfmt+0x457>
				(uintptr_t) va_arg(aq, void *);
  801b1b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  801b1f:	48 8d 50 08          	lea    0x8(%rax),%rdx
  801b23:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  801b27:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  801b2a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  801b2e:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  801b35:	eb 23                	jmp    801b5a <vprintfmt+0x48a>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  801b37:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801b3b:	be 03 00 00 00       	mov    $0x3,%esi
  801b40:	48 89 c7             	mov    %rax,%rdi
  801b43:	48 b8 c2 14 80 00 00 	movabs $0x8014c2,%rax
  801b4a:	00 00 00 
  801b4d:	ff d0                	callq  *%rax
  801b4f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  801b53:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  801b5a:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  801b5f:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  801b62:	8b 7d dc             	mov    -0x24(%rbp),%edi
  801b65:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801b69:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  801b6d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801b71:	45 89 c1             	mov    %r8d,%r9d
  801b74:	41 89 f8             	mov    %edi,%r8d
  801b77:	48 89 c7             	mov    %rax,%rdi
  801b7a:	48 b8 0a 14 80 00 00 	movabs $0x80140a,%rax
  801b81:	00 00 00 
  801b84:	ff d0                	callq  *%rax
			break;
  801b86:	eb 3f                	jmp    801bc7 <vprintfmt+0x4f7>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  801b88:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801b8c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801b90:	48 89 d6             	mov    %rdx,%rsi
  801b93:	89 df                	mov    %ebx,%edi
  801b95:	ff d0                	callq  *%rax
			break;
  801b97:	eb 2e                	jmp    801bc7 <vprintfmt+0x4f7>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  801b99:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801b9d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801ba1:	48 89 d6             	mov    %rdx,%rsi
  801ba4:	bf 25 00 00 00       	mov    $0x25,%edi
  801ba9:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  801bab:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  801bb0:	eb 05                	jmp    801bb7 <vprintfmt+0x4e7>
  801bb2:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  801bb7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  801bbb:	48 83 e8 01          	sub    $0x1,%rax
  801bbf:	0f b6 00             	movzbl (%rax),%eax
  801bc2:	3c 25                	cmp    $0x25,%al
  801bc4:	75 ec                	jne    801bb2 <vprintfmt+0x4e2>
				/* do nothing */;
			break;
  801bc6:	90                   	nop
		}
	}
  801bc7:	e9 3d fb ff ff       	jmpq   801709 <vprintfmt+0x39>
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
  801bcc:	90                   	nop
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  801bcd:	48 83 c4 60          	add    $0x60,%rsp
  801bd1:	5b                   	pop    %rbx
  801bd2:	41 5c                	pop    %r12
  801bd4:	5d                   	pop    %rbp
  801bd5:	c3                   	retq   

0000000000801bd6 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  801bd6:	55                   	push   %rbp
  801bd7:	48 89 e5             	mov    %rsp,%rbp
  801bda:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  801be1:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  801be8:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  801bef:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
  801bf6:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801bfd:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801c04:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801c0b:	84 c0                	test   %al,%al
  801c0d:	74 20                	je     801c2f <printfmt+0x59>
  801c0f:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  801c13:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801c17:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801c1b:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  801c1f:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  801c23:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801c27:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801c2b:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;

	va_start(ap, fmt);
  801c2f:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  801c36:	00 00 00 
  801c39:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  801c40:	00 00 00 
  801c43:	48 8d 45 10          	lea    0x10(%rbp),%rax
  801c47:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  801c4e:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  801c55:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  801c5c:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  801c63:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  801c6a:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  801c71:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  801c78:	48 89 c7             	mov    %rax,%rdi
  801c7b:	48 b8 d0 16 80 00 00 	movabs $0x8016d0,%rax
  801c82:	00 00 00 
  801c85:	ff d0                	callq  *%rax
	va_end(ap);
}
  801c87:	90                   	nop
  801c88:	c9                   	leaveq 
  801c89:	c3                   	retq   

0000000000801c8a <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  801c8a:	55                   	push   %rbp
  801c8b:	48 89 e5             	mov    %rsp,%rbp
  801c8e:	48 83 ec 10          	sub    $0x10,%rsp
  801c92:	89 7d fc             	mov    %edi,-0x4(%rbp)
  801c95:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  801c99:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801c9d:	8b 40 10             	mov    0x10(%rax),%eax
  801ca0:	8d 50 01             	lea    0x1(%rax),%edx
  801ca3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801ca7:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  801caa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801cae:	48 8b 10             	mov    (%rax),%rdx
  801cb1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801cb5:	48 8b 40 08          	mov    0x8(%rax),%rax
  801cb9:	48 39 c2             	cmp    %rax,%rdx
  801cbc:	73 17                	jae    801cd5 <sprintputch+0x4b>
		*b->buf++ = ch;
  801cbe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801cc2:	48 8b 00             	mov    (%rax),%rax
  801cc5:	48 8d 48 01          	lea    0x1(%rax),%rcx
  801cc9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801ccd:	48 89 0a             	mov    %rcx,(%rdx)
  801cd0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  801cd3:	88 10                	mov    %dl,(%rax)
}
  801cd5:	90                   	nop
  801cd6:	c9                   	leaveq 
  801cd7:	c3                   	retq   

0000000000801cd8 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  801cd8:	55                   	push   %rbp
  801cd9:	48 89 e5             	mov    %rsp,%rbp
  801cdc:	48 83 ec 50          	sub    $0x50,%rsp
  801ce0:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  801ce4:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  801ce7:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  801ceb:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  801cef:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  801cf3:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  801cf7:	48 8b 0a             	mov    (%rdx),%rcx
  801cfa:	48 89 08             	mov    %rcx,(%rax)
  801cfd:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801d01:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801d05:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801d09:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  801d0d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  801d11:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  801d15:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  801d18:	48 98                	cltq   
  801d1a:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  801d1e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  801d22:	48 01 d0             	add    %rdx,%rax
  801d25:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  801d29:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  801d30:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  801d35:	74 06                	je     801d3d <vsnprintf+0x65>
  801d37:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  801d3b:	7f 07                	jg     801d44 <vsnprintf+0x6c>
		return -E_INVAL;
  801d3d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  801d42:	eb 2f                	jmp    801d73 <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  801d44:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  801d48:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  801d4c:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  801d50:	48 89 c6             	mov    %rax,%rsi
  801d53:	48 bf 8a 1c 80 00 00 	movabs $0x801c8a,%rdi
  801d5a:	00 00 00 
  801d5d:	48 b8 d0 16 80 00 00 	movabs $0x8016d0,%rax
  801d64:	00 00 00 
  801d67:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  801d69:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  801d6d:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  801d70:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  801d73:	c9                   	leaveq 
  801d74:	c3                   	retq   

0000000000801d75 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  801d75:	55                   	push   %rbp
  801d76:	48 89 e5             	mov    %rsp,%rbp
  801d79:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  801d80:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  801d87:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  801d8d:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
  801d94:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801d9b:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801da2:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801da9:	84 c0                	test   %al,%al
  801dab:	74 20                	je     801dcd <snprintf+0x58>
  801dad:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  801db1:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801db5:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801db9:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  801dbd:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  801dc1:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801dc5:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801dc9:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  801dcd:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  801dd4:	00 00 00 
  801dd7:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  801dde:	00 00 00 
  801de1:	48 8d 45 10          	lea    0x10(%rbp),%rax
  801de5:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  801dec:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  801df3:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  801dfa:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  801e01:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  801e08:	48 8b 0a             	mov    (%rdx),%rcx
  801e0b:	48 89 08             	mov    %rcx,(%rax)
  801e0e:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801e12:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801e16:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801e1a:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  801e1e:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  801e25:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  801e2c:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  801e32:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  801e39:	48 89 c7             	mov    %rax,%rdi
  801e3c:	48 b8 d8 1c 80 00 00 	movabs $0x801cd8,%rax
  801e43:	00 00 00 
  801e46:	ff d0                	callq  *%rax
  801e48:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  801e4e:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  801e54:	c9                   	leaveq 
  801e55:	c3                   	retq   

0000000000801e56 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  801e56:	55                   	push   %rbp
  801e57:	48 89 e5             	mov    %rsp,%rbp
  801e5a:	48 83 ec 18          	sub    $0x18,%rsp
  801e5e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  801e62:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  801e69:	eb 09                	jmp    801e74 <strlen+0x1e>
		n++;
  801e6b:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  801e6f:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801e74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801e78:	0f b6 00             	movzbl (%rax),%eax
  801e7b:	84 c0                	test   %al,%al
  801e7d:	75 ec                	jne    801e6b <strlen+0x15>
		n++;
	return n;
  801e7f:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  801e82:	c9                   	leaveq 
  801e83:	c3                   	retq   

0000000000801e84 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  801e84:	55                   	push   %rbp
  801e85:	48 89 e5             	mov    %rsp,%rbp
  801e88:	48 83 ec 20          	sub    $0x20,%rsp
  801e8c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801e90:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  801e94:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  801e9b:	eb 0e                	jmp    801eab <strnlen+0x27>
		n++;
  801e9d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  801ea1:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801ea6:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  801eab:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  801eb0:	74 0b                	je     801ebd <strnlen+0x39>
  801eb2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801eb6:	0f b6 00             	movzbl (%rax),%eax
  801eb9:	84 c0                	test   %al,%al
  801ebb:	75 e0                	jne    801e9d <strnlen+0x19>
		n++;
	return n;
  801ebd:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  801ec0:	c9                   	leaveq 
  801ec1:	c3                   	retq   

0000000000801ec2 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  801ec2:	55                   	push   %rbp
  801ec3:	48 89 e5             	mov    %rsp,%rbp
  801ec6:	48 83 ec 20          	sub    $0x20,%rsp
  801eca:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801ece:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  801ed2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801ed6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  801eda:	90                   	nop
  801edb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801edf:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801ee3:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  801ee7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  801eeb:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  801eef:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  801ef3:	0f b6 12             	movzbl (%rdx),%edx
  801ef6:	88 10                	mov    %dl,(%rax)
  801ef8:	0f b6 00             	movzbl (%rax),%eax
  801efb:	84 c0                	test   %al,%al
  801efd:	75 dc                	jne    801edb <strcpy+0x19>
		/* do nothing */;
	return ret;
  801eff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  801f03:	c9                   	leaveq 
  801f04:	c3                   	retq   

0000000000801f05 <strcat>:

char *
strcat(char *dst, const char *src)
{
  801f05:	55                   	push   %rbp
  801f06:	48 89 e5             	mov    %rsp,%rbp
  801f09:	48 83 ec 20          	sub    $0x20,%rsp
  801f0d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801f11:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  801f15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f19:	48 89 c7             	mov    %rax,%rdi
  801f1c:	48 b8 56 1e 80 00 00 	movabs $0x801e56,%rax
  801f23:	00 00 00 
  801f26:	ff d0                	callq  *%rax
  801f28:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  801f2b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  801f2e:	48 63 d0             	movslq %eax,%rdx
  801f31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f35:	48 01 c2             	add    %rax,%rdx
  801f38:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801f3c:	48 89 c6             	mov    %rax,%rsi
  801f3f:	48 89 d7             	mov    %rdx,%rdi
  801f42:	48 b8 c2 1e 80 00 00 	movabs $0x801ec2,%rax
  801f49:	00 00 00 
  801f4c:	ff d0                	callq  *%rax
	return dst;
  801f4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  801f52:	c9                   	leaveq 
  801f53:	c3                   	retq   

0000000000801f54 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  801f54:	55                   	push   %rbp
  801f55:	48 89 e5             	mov    %rsp,%rbp
  801f58:	48 83 ec 28          	sub    $0x28,%rsp
  801f5c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801f60:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  801f64:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  801f68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f6c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  801f70:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  801f77:	00 
  801f78:	eb 2a                	jmp    801fa4 <strncpy+0x50>
		*dst++ = *src;
  801f7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f7e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801f82:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  801f86:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  801f8a:	0f b6 12             	movzbl (%rdx),%edx
  801f8d:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  801f8f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801f93:	0f b6 00             	movzbl (%rax),%eax
  801f96:	84 c0                	test   %al,%al
  801f98:	74 05                	je     801f9f <strncpy+0x4b>
			src++;
  801f9a:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  801f9f:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  801fa4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801fa8:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  801fac:	72 cc                	jb     801f7a <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  801fae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  801fb2:	c9                   	leaveq 
  801fb3:	c3                   	retq   

0000000000801fb4 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  801fb4:	55                   	push   %rbp
  801fb5:	48 89 e5             	mov    %rsp,%rbp
  801fb8:	48 83 ec 28          	sub    $0x28,%rsp
  801fbc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801fc0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  801fc4:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  801fc8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801fcc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  801fd0:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  801fd5:	74 3d                	je     802014 <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  801fd7:	eb 1d                	jmp    801ff6 <strlcpy+0x42>
			*dst++ = *src++;
  801fd9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801fdd:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801fe1:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  801fe5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  801fe9:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  801fed:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  801ff1:	0f b6 12             	movzbl (%rdx),%edx
  801ff4:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  801ff6:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  801ffb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  802000:	74 0b                	je     80200d <strlcpy+0x59>
  802002:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802006:	0f b6 00             	movzbl (%rax),%eax
  802009:	84 c0                	test   %al,%al
  80200b:	75 cc                	jne    801fd9 <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  80200d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802011:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  802014:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  802018:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80201c:	48 29 c2             	sub    %rax,%rdx
  80201f:	48 89 d0             	mov    %rdx,%rax
}
  802022:	c9                   	leaveq 
  802023:	c3                   	retq   

0000000000802024 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  802024:	55                   	push   %rbp
  802025:	48 89 e5             	mov    %rsp,%rbp
  802028:	48 83 ec 10          	sub    $0x10,%rsp
  80202c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802030:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  802034:	eb 0a                	jmp    802040 <strcmp+0x1c>
		p++, q++;
  802036:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80203b:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  802040:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802044:	0f b6 00             	movzbl (%rax),%eax
  802047:	84 c0                	test   %al,%al
  802049:	74 12                	je     80205d <strcmp+0x39>
  80204b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80204f:	0f b6 10             	movzbl (%rax),%edx
  802052:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802056:	0f b6 00             	movzbl (%rax),%eax
  802059:	38 c2                	cmp    %al,%dl
  80205b:	74 d9                	je     802036 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80205d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802061:	0f b6 00             	movzbl (%rax),%eax
  802064:	0f b6 d0             	movzbl %al,%edx
  802067:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80206b:	0f b6 00             	movzbl (%rax),%eax
  80206e:	0f b6 c0             	movzbl %al,%eax
  802071:	29 c2                	sub    %eax,%edx
  802073:	89 d0                	mov    %edx,%eax
}
  802075:	c9                   	leaveq 
  802076:	c3                   	retq   

0000000000802077 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  802077:	55                   	push   %rbp
  802078:	48 89 e5             	mov    %rsp,%rbp
  80207b:	48 83 ec 18          	sub    $0x18,%rsp
  80207f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802083:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802087:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  80208b:	eb 0f                	jmp    80209c <strncmp+0x25>
		n--, p++, q++;
  80208d:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  802092:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  802097:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  80209c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8020a1:	74 1d                	je     8020c0 <strncmp+0x49>
  8020a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020a7:	0f b6 00             	movzbl (%rax),%eax
  8020aa:	84 c0                	test   %al,%al
  8020ac:	74 12                	je     8020c0 <strncmp+0x49>
  8020ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020b2:	0f b6 10             	movzbl (%rax),%edx
  8020b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8020b9:	0f b6 00             	movzbl (%rax),%eax
  8020bc:	38 c2                	cmp    %al,%dl
  8020be:	74 cd                	je     80208d <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  8020c0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8020c5:	75 07                	jne    8020ce <strncmp+0x57>
		return 0;
  8020c7:	b8 00 00 00 00       	mov    $0x0,%eax
  8020cc:	eb 18                	jmp    8020e6 <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  8020ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020d2:	0f b6 00             	movzbl (%rax),%eax
  8020d5:	0f b6 d0             	movzbl %al,%edx
  8020d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8020dc:	0f b6 00             	movzbl (%rax),%eax
  8020df:	0f b6 c0             	movzbl %al,%eax
  8020e2:	29 c2                	sub    %eax,%edx
  8020e4:	89 d0                	mov    %edx,%eax
}
  8020e6:	c9                   	leaveq 
  8020e7:	c3                   	retq   

00000000008020e8 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  8020e8:	55                   	push   %rbp
  8020e9:	48 89 e5             	mov    %rsp,%rbp
  8020ec:	48 83 ec 10          	sub    $0x10,%rsp
  8020f0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8020f4:	89 f0                	mov    %esi,%eax
  8020f6:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  8020f9:	eb 17                	jmp    802112 <strchr+0x2a>
		if (*s == c)
  8020fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020ff:	0f b6 00             	movzbl (%rax),%eax
  802102:	3a 45 f4             	cmp    -0xc(%rbp),%al
  802105:	75 06                	jne    80210d <strchr+0x25>
			return (char *) s;
  802107:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80210b:	eb 15                	jmp    802122 <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80210d:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  802112:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802116:	0f b6 00             	movzbl (%rax),%eax
  802119:	84 c0                	test   %al,%al
  80211b:	75 de                	jne    8020fb <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  80211d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802122:	c9                   	leaveq 
  802123:	c3                   	retq   

0000000000802124 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  802124:	55                   	push   %rbp
  802125:	48 89 e5             	mov    %rsp,%rbp
  802128:	48 83 ec 10          	sub    $0x10,%rsp
  80212c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802130:	89 f0                	mov    %esi,%eax
  802132:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  802135:	eb 11                	jmp    802148 <strfind+0x24>
		if (*s == c)
  802137:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80213b:	0f b6 00             	movzbl (%rax),%eax
  80213e:	3a 45 f4             	cmp    -0xc(%rbp),%al
  802141:	74 12                	je     802155 <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  802143:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  802148:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80214c:	0f b6 00             	movzbl (%rax),%eax
  80214f:	84 c0                	test   %al,%al
  802151:	75 e4                	jne    802137 <strfind+0x13>
  802153:	eb 01                	jmp    802156 <strfind+0x32>
		if (*s == c)
			break;
  802155:	90                   	nop
	return (char *) s;
  802156:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80215a:	c9                   	leaveq 
  80215b:	c3                   	retq   

000000000080215c <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80215c:	55                   	push   %rbp
  80215d:	48 89 e5             	mov    %rsp,%rbp
  802160:	48 83 ec 18          	sub    $0x18,%rsp
  802164:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802168:	89 75 f4             	mov    %esi,-0xc(%rbp)
  80216b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  80216f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  802174:	75 06                	jne    80217c <memset+0x20>
		return v;
  802176:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80217a:	eb 69                	jmp    8021e5 <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  80217c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802180:	83 e0 03             	and    $0x3,%eax
  802183:	48 85 c0             	test   %rax,%rax
  802186:	75 48                	jne    8021d0 <memset+0x74>
  802188:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80218c:	83 e0 03             	and    $0x3,%eax
  80218f:	48 85 c0             	test   %rax,%rax
  802192:	75 3c                	jne    8021d0 <memset+0x74>
		c &= 0xFF;
  802194:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80219b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80219e:	c1 e0 18             	shl    $0x18,%eax
  8021a1:	89 c2                	mov    %eax,%edx
  8021a3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8021a6:	c1 e0 10             	shl    $0x10,%eax
  8021a9:	09 c2                	or     %eax,%edx
  8021ab:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8021ae:	c1 e0 08             	shl    $0x8,%eax
  8021b1:	09 d0                	or     %edx,%eax
  8021b3:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  8021b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8021ba:	48 c1 e8 02          	shr    $0x2,%rax
  8021be:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  8021c1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8021c5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8021c8:	48 89 d7             	mov    %rdx,%rdi
  8021cb:	fc                   	cld    
  8021cc:	f3 ab                	rep stos %eax,%es:(%rdi)
  8021ce:	eb 11                	jmp    8021e1 <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  8021d0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8021d4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8021d7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8021db:	48 89 d7             	mov    %rdx,%rdi
  8021de:	fc                   	cld    
  8021df:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  8021e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8021e5:	c9                   	leaveq 
  8021e6:	c3                   	retq   

00000000008021e7 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  8021e7:	55                   	push   %rbp
  8021e8:	48 89 e5             	mov    %rsp,%rbp
  8021eb:	48 83 ec 28          	sub    $0x28,%rsp
  8021ef:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8021f3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8021f7:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  8021fb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8021ff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  802203:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802207:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  80220b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80220f:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  802213:	0f 83 88 00 00 00    	jae    8022a1 <memmove+0xba>
  802219:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80221d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802221:	48 01 d0             	add    %rdx,%rax
  802224:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  802228:	76 77                	jbe    8022a1 <memmove+0xba>
		s += n;
  80222a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80222e:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  802232:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802236:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  80223a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80223e:	83 e0 03             	and    $0x3,%eax
  802241:	48 85 c0             	test   %rax,%rax
  802244:	75 3b                	jne    802281 <memmove+0x9a>
  802246:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80224a:	83 e0 03             	and    $0x3,%eax
  80224d:	48 85 c0             	test   %rax,%rax
  802250:	75 2f                	jne    802281 <memmove+0x9a>
  802252:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802256:	83 e0 03             	and    $0x3,%eax
  802259:	48 85 c0             	test   %rax,%rax
  80225c:	75 23                	jne    802281 <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80225e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802262:	48 83 e8 04          	sub    $0x4,%rax
  802266:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80226a:	48 83 ea 04          	sub    $0x4,%rdx
  80226e:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  802272:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  802276:	48 89 c7             	mov    %rax,%rdi
  802279:	48 89 d6             	mov    %rdx,%rsi
  80227c:	fd                   	std    
  80227d:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  80227f:	eb 1d                	jmp    80229e <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  802281:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802285:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  802289:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80228d:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  802291:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802295:	48 89 d7             	mov    %rdx,%rdi
  802298:	48 89 c1             	mov    %rax,%rcx
  80229b:	fd                   	std    
  80229c:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80229e:	fc                   	cld    
  80229f:	eb 57                	jmp    8022f8 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  8022a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8022a5:	83 e0 03             	and    $0x3,%eax
  8022a8:	48 85 c0             	test   %rax,%rax
  8022ab:	75 36                	jne    8022e3 <memmove+0xfc>
  8022ad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8022b1:	83 e0 03             	and    $0x3,%eax
  8022b4:	48 85 c0             	test   %rax,%rax
  8022b7:	75 2a                	jne    8022e3 <memmove+0xfc>
  8022b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022bd:	83 e0 03             	and    $0x3,%eax
  8022c0:	48 85 c0             	test   %rax,%rax
  8022c3:	75 1e                	jne    8022e3 <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  8022c5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022c9:	48 c1 e8 02          	shr    $0x2,%rax
  8022cd:	48 89 c1             	mov    %rax,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  8022d0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8022d4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8022d8:	48 89 c7             	mov    %rax,%rdi
  8022db:	48 89 d6             	mov    %rdx,%rsi
  8022de:	fc                   	cld    
  8022df:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  8022e1:	eb 15                	jmp    8022f8 <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  8022e3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8022e7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8022eb:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8022ef:	48 89 c7             	mov    %rax,%rdi
  8022f2:	48 89 d6             	mov    %rdx,%rsi
  8022f5:	fc                   	cld    
  8022f6:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  8022f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8022fc:	c9                   	leaveq 
  8022fd:	c3                   	retq   

00000000008022fe <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  8022fe:	55                   	push   %rbp
  8022ff:	48 89 e5             	mov    %rsp,%rbp
  802302:	48 83 ec 18          	sub    $0x18,%rsp
  802306:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80230a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80230e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  802312:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  802316:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80231a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80231e:	48 89 ce             	mov    %rcx,%rsi
  802321:	48 89 c7             	mov    %rax,%rdi
  802324:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  80232b:	00 00 00 
  80232e:	ff d0                	callq  *%rax
}
  802330:	c9                   	leaveq 
  802331:	c3                   	retq   

0000000000802332 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  802332:	55                   	push   %rbp
  802333:	48 89 e5             	mov    %rsp,%rbp
  802336:	48 83 ec 28          	sub    $0x28,%rsp
  80233a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80233e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  802342:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  802346:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80234a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  80234e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802352:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  802356:	eb 36                	jmp    80238e <memcmp+0x5c>
		if (*s1 != *s2)
  802358:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80235c:	0f b6 10             	movzbl (%rax),%edx
  80235f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802363:	0f b6 00             	movzbl (%rax),%eax
  802366:	38 c2                	cmp    %al,%dl
  802368:	74 1a                	je     802384 <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  80236a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80236e:	0f b6 00             	movzbl (%rax),%eax
  802371:	0f b6 d0             	movzbl %al,%edx
  802374:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802378:	0f b6 00             	movzbl (%rax),%eax
  80237b:	0f b6 c0             	movzbl %al,%eax
  80237e:	29 c2                	sub    %eax,%edx
  802380:	89 d0                	mov    %edx,%eax
  802382:	eb 20                	jmp    8023a4 <memcmp+0x72>
		s1++, s2++;
  802384:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  802389:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80238e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802392:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  802396:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80239a:	48 85 c0             	test   %rax,%rax
  80239d:	75 b9                	jne    802358 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  80239f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8023a4:	c9                   	leaveq 
  8023a5:	c3                   	retq   

00000000008023a6 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  8023a6:	55                   	push   %rbp
  8023a7:	48 89 e5             	mov    %rsp,%rbp
  8023aa:	48 83 ec 28          	sub    $0x28,%rsp
  8023ae:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8023b2:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  8023b5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  8023b9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8023bd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8023c1:	48 01 d0             	add    %rdx,%rax
  8023c4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  8023c8:	eb 19                	jmp    8023e3 <memfind+0x3d>
		if (*(const unsigned char *) s == (unsigned char) c)
  8023ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8023ce:	0f b6 00             	movzbl (%rax),%eax
  8023d1:	0f b6 d0             	movzbl %al,%edx
  8023d4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8023d7:	0f b6 c0             	movzbl %al,%eax
  8023da:	39 c2                	cmp    %eax,%edx
  8023dc:	74 11                	je     8023ef <memfind+0x49>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  8023de:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8023e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8023e7:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8023eb:	72 dd                	jb     8023ca <memfind+0x24>
  8023ed:	eb 01                	jmp    8023f0 <memfind+0x4a>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
  8023ef:	90                   	nop
	return (void *) s;
  8023f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8023f4:	c9                   	leaveq 
  8023f5:	c3                   	retq   

00000000008023f6 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  8023f6:	55                   	push   %rbp
  8023f7:	48 89 e5             	mov    %rsp,%rbp
  8023fa:	48 83 ec 38          	sub    $0x38,%rsp
  8023fe:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  802402:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  802406:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  802409:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  802410:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  802417:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  802418:	eb 05                	jmp    80241f <strtol+0x29>
		s++;
  80241a:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80241f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802423:	0f b6 00             	movzbl (%rax),%eax
  802426:	3c 20                	cmp    $0x20,%al
  802428:	74 f0                	je     80241a <strtol+0x24>
  80242a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80242e:	0f b6 00             	movzbl (%rax),%eax
  802431:	3c 09                	cmp    $0x9,%al
  802433:	74 e5                	je     80241a <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  802435:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802439:	0f b6 00             	movzbl (%rax),%eax
  80243c:	3c 2b                	cmp    $0x2b,%al
  80243e:	75 07                	jne    802447 <strtol+0x51>
		s++;
  802440:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  802445:	eb 17                	jmp    80245e <strtol+0x68>
	else if (*s == '-')
  802447:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80244b:	0f b6 00             	movzbl (%rax),%eax
  80244e:	3c 2d                	cmp    $0x2d,%al
  802450:	75 0c                	jne    80245e <strtol+0x68>
		s++, neg = 1;
  802452:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  802457:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80245e:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  802462:	74 06                	je     80246a <strtol+0x74>
  802464:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  802468:	75 28                	jne    802492 <strtol+0x9c>
  80246a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80246e:	0f b6 00             	movzbl (%rax),%eax
  802471:	3c 30                	cmp    $0x30,%al
  802473:	75 1d                	jne    802492 <strtol+0x9c>
  802475:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802479:	48 83 c0 01          	add    $0x1,%rax
  80247d:	0f b6 00             	movzbl (%rax),%eax
  802480:	3c 78                	cmp    $0x78,%al
  802482:	75 0e                	jne    802492 <strtol+0x9c>
		s += 2, base = 16;
  802484:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  802489:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  802490:	eb 2c                	jmp    8024be <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  802492:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  802496:	75 19                	jne    8024b1 <strtol+0xbb>
  802498:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80249c:	0f b6 00             	movzbl (%rax),%eax
  80249f:	3c 30                	cmp    $0x30,%al
  8024a1:	75 0e                	jne    8024b1 <strtol+0xbb>
		s++, base = 8;
  8024a3:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8024a8:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  8024af:	eb 0d                	jmp    8024be <strtol+0xc8>
	else if (base == 0)
  8024b1:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8024b5:	75 07                	jne    8024be <strtol+0xc8>
		base = 10;
  8024b7:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  8024be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024c2:	0f b6 00             	movzbl (%rax),%eax
  8024c5:	3c 2f                	cmp    $0x2f,%al
  8024c7:	7e 1d                	jle    8024e6 <strtol+0xf0>
  8024c9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024cd:	0f b6 00             	movzbl (%rax),%eax
  8024d0:	3c 39                	cmp    $0x39,%al
  8024d2:	7f 12                	jg     8024e6 <strtol+0xf0>
			dig = *s - '0';
  8024d4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024d8:	0f b6 00             	movzbl (%rax),%eax
  8024db:	0f be c0             	movsbl %al,%eax
  8024de:	83 e8 30             	sub    $0x30,%eax
  8024e1:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8024e4:	eb 4e                	jmp    802534 <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  8024e6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024ea:	0f b6 00             	movzbl (%rax),%eax
  8024ed:	3c 60                	cmp    $0x60,%al
  8024ef:	7e 1d                	jle    80250e <strtol+0x118>
  8024f1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024f5:	0f b6 00             	movzbl (%rax),%eax
  8024f8:	3c 7a                	cmp    $0x7a,%al
  8024fa:	7f 12                	jg     80250e <strtol+0x118>
			dig = *s - 'a' + 10;
  8024fc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802500:	0f b6 00             	movzbl (%rax),%eax
  802503:	0f be c0             	movsbl %al,%eax
  802506:	83 e8 57             	sub    $0x57,%eax
  802509:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80250c:	eb 26                	jmp    802534 <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  80250e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802512:	0f b6 00             	movzbl (%rax),%eax
  802515:	3c 40                	cmp    $0x40,%al
  802517:	7e 47                	jle    802560 <strtol+0x16a>
  802519:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80251d:	0f b6 00             	movzbl (%rax),%eax
  802520:	3c 5a                	cmp    $0x5a,%al
  802522:	7f 3c                	jg     802560 <strtol+0x16a>
			dig = *s - 'A' + 10;
  802524:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802528:	0f b6 00             	movzbl (%rax),%eax
  80252b:	0f be c0             	movsbl %al,%eax
  80252e:	83 e8 37             	sub    $0x37,%eax
  802531:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  802534:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802537:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  80253a:	7d 23                	jge    80255f <strtol+0x169>
			break;
		s++, val = (val * base) + dig;
  80253c:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  802541:	8b 45 cc             	mov    -0x34(%rbp),%eax
  802544:	48 98                	cltq   
  802546:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  80254b:	48 89 c2             	mov    %rax,%rdx
  80254e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802551:	48 98                	cltq   
  802553:	48 01 d0             	add    %rdx,%rax
  802556:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  80255a:	e9 5f ff ff ff       	jmpq   8024be <strtol+0xc8>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
  80255f:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
  802560:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  802565:	74 0b                	je     802572 <strtol+0x17c>
		*endptr = (char *) s;
  802567:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80256b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80256f:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  802572:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  802576:	74 09                	je     802581 <strtol+0x18b>
  802578:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80257c:	48 f7 d8             	neg    %rax
  80257f:	eb 04                	jmp    802585 <strtol+0x18f>
  802581:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  802585:	c9                   	leaveq 
  802586:	c3                   	retq   

0000000000802587 <strstr>:

char * strstr(const char *in, const char *str)
{
  802587:	55                   	push   %rbp
  802588:	48 89 e5             	mov    %rsp,%rbp
  80258b:	48 83 ec 30          	sub    $0x30,%rsp
  80258f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  802593:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  802597:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80259b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80259f:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8025a3:	0f b6 00             	movzbl (%rax),%eax
  8025a6:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  8025a9:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  8025ad:	75 06                	jne    8025b5 <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  8025af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8025b3:	eb 6b                	jmp    802620 <strstr+0x99>

	len = strlen(str);
  8025b5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8025b9:	48 89 c7             	mov    %rax,%rdi
  8025bc:	48 b8 56 1e 80 00 00 	movabs $0x801e56,%rax
  8025c3:	00 00 00 
  8025c6:	ff d0                	callq  *%rax
  8025c8:	48 98                	cltq   
  8025ca:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  8025ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8025d2:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8025d6:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8025da:	0f b6 00             	movzbl (%rax),%eax
  8025dd:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  8025e0:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  8025e4:	75 07                	jne    8025ed <strstr+0x66>
				return (char *) 0;
  8025e6:	b8 00 00 00 00       	mov    $0x0,%eax
  8025eb:	eb 33                	jmp    802620 <strstr+0x99>
		} while (sc != c);
  8025ed:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8025f1:	3a 45 ff             	cmp    -0x1(%rbp),%al
  8025f4:	75 d8                	jne    8025ce <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  8025f6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8025fa:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8025fe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802602:	48 89 ce             	mov    %rcx,%rsi
  802605:	48 89 c7             	mov    %rax,%rdi
  802608:	48 b8 77 20 80 00 00 	movabs $0x802077,%rax
  80260f:	00 00 00 
  802612:	ff d0                	callq  *%rax
  802614:	85 c0                	test   %eax,%eax
  802616:	75 b6                	jne    8025ce <strstr+0x47>

	return (char *) (in - 1);
  802618:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80261c:	48 83 e8 01          	sub    $0x1,%rax
}
  802620:	c9                   	leaveq 
  802621:	c3                   	retq   

0000000000802622 <syscall>:
#include <inc/syscall.h>
#include <inc/lib.h>

static inline int64_t
syscall(int num, int check, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  802622:	55                   	push   %rbp
  802623:	48 89 e5             	mov    %rsp,%rbp
  802626:	53                   	push   %rbx
  802627:	48 83 ec 48          	sub    $0x48,%rsp
  80262b:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80262e:	89 75 d8             	mov    %esi,-0x28(%rbp)
  802631:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  802635:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  802639:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
  80263d:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  802641:	8b 45 dc             	mov    -0x24(%rbp),%eax
  802644:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  802648:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80264c:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
  802650:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  802654:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  802658:	4c 89 c3             	mov    %r8,%rbx
  80265b:	cd 30                	int    $0x30
  80265d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  802661:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  802665:	74 3e                	je     8026a5 <syscall+0x83>
  802667:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80266c:	7e 37                	jle    8026a5 <syscall+0x83>
		panic("syscall %d returned %d (> 0)", num, ret);
  80266e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  802672:	8b 45 dc             	mov    -0x24(%rbp),%eax
  802675:	49 89 d0             	mov    %rdx,%r8
  802678:	89 c1                	mov    %eax,%ecx
  80267a:	48 ba 48 15 82 00 00 	movabs $0x821548,%rdx
  802681:	00 00 00 
  802684:	be 24 00 00 00       	mov    $0x24,%esi
  802689:	48 bf 65 15 82 00 00 	movabs $0x821565,%rdi
  802690:	00 00 00 
  802693:	b8 00 00 00 00       	mov    $0x0,%eax
  802698:	49 b9 f8 10 80 00 00 	movabs $0x8010f8,%r9
  80269f:	00 00 00 
  8026a2:	41 ff d1             	callq  *%r9

	return ret;
  8026a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8026a9:	48 83 c4 48          	add    $0x48,%rsp
  8026ad:	5b                   	pop    %rbx
  8026ae:	5d                   	pop    %rbp
  8026af:	c3                   	retq   

00000000008026b0 <sys_cputs>:

void
sys_cputs(const char *s, size_t len)
{
  8026b0:	55                   	push   %rbp
  8026b1:	48 89 e5             	mov    %rsp,%rbp
  8026b4:	48 83 ec 10          	sub    $0x10,%rsp
  8026b8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8026bc:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	syscall(SYS_cputs, 0, (uint64_t)s, len, 0, 0, 0);
  8026c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8026c4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8026c8:	48 83 ec 08          	sub    $0x8,%rsp
  8026cc:	6a 00                	pushq  $0x0
  8026ce:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8026d4:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8026da:	48 89 d1             	mov    %rdx,%rcx
  8026dd:	48 89 c2             	mov    %rax,%rdx
  8026e0:	be 00 00 00 00       	mov    $0x0,%esi
  8026e5:	bf 00 00 00 00       	mov    $0x0,%edi
  8026ea:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  8026f1:	00 00 00 
  8026f4:	ff d0                	callq  *%rax
  8026f6:	48 83 c4 10          	add    $0x10,%rsp
}
  8026fa:	90                   	nop
  8026fb:	c9                   	leaveq 
  8026fc:	c3                   	retq   

00000000008026fd <sys_cgetc>:

int
sys_cgetc(void)
{
  8026fd:	55                   	push   %rbp
  8026fe:	48 89 e5             	mov    %rsp,%rbp
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
  802701:	48 83 ec 08          	sub    $0x8,%rsp
  802705:	6a 00                	pushq  $0x0
  802707:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80270d:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802713:	b9 00 00 00 00       	mov    $0x0,%ecx
  802718:	ba 00 00 00 00       	mov    $0x0,%edx
  80271d:	be 00 00 00 00       	mov    $0x0,%esi
  802722:	bf 01 00 00 00       	mov    $0x1,%edi
  802727:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  80272e:	00 00 00 
  802731:	ff d0                	callq  *%rax
  802733:	48 83 c4 10          	add    $0x10,%rsp
}
  802737:	c9                   	leaveq 
  802738:	c3                   	retq   

0000000000802739 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  802739:	55                   	push   %rbp
  80273a:	48 89 e5             	mov    %rsp,%rbp
  80273d:	48 83 ec 10          	sub    $0x10,%rsp
  802741:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
  802744:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802747:	48 98                	cltq   
  802749:	48 83 ec 08          	sub    $0x8,%rsp
  80274d:	6a 00                	pushq  $0x0
  80274f:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802755:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80275b:	b9 00 00 00 00       	mov    $0x0,%ecx
  802760:	48 89 c2             	mov    %rax,%rdx
  802763:	be 01 00 00 00       	mov    $0x1,%esi
  802768:	bf 03 00 00 00       	mov    $0x3,%edi
  80276d:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802774:	00 00 00 
  802777:	ff d0                	callq  *%rax
  802779:	48 83 c4 10          	add    $0x10,%rsp
}
  80277d:	c9                   	leaveq 
  80277e:	c3                   	retq   

000000000080277f <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80277f:	55                   	push   %rbp
  802780:	48 89 e5             	mov    %rsp,%rbp
	return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
  802783:	48 83 ec 08          	sub    $0x8,%rsp
  802787:	6a 00                	pushq  $0x0
  802789:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80278f:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802795:	b9 00 00 00 00       	mov    $0x0,%ecx
  80279a:	ba 00 00 00 00       	mov    $0x0,%edx
  80279f:	be 00 00 00 00       	mov    $0x0,%esi
  8027a4:	bf 02 00 00 00       	mov    $0x2,%edi
  8027a9:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  8027b0:	00 00 00 
  8027b3:	ff d0                	callq  *%rax
  8027b5:	48 83 c4 10          	add    $0x10,%rsp
}
  8027b9:	c9                   	leaveq 
  8027ba:	c3                   	retq   

00000000008027bb <sys_yield>:


void
sys_yield(void)
{
  8027bb:	55                   	push   %rbp
  8027bc:	48 89 e5             	mov    %rsp,%rbp
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
  8027bf:	48 83 ec 08          	sub    $0x8,%rsp
  8027c3:	6a 00                	pushq  $0x0
  8027c5:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8027cb:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8027d1:	b9 00 00 00 00       	mov    $0x0,%ecx
  8027d6:	ba 00 00 00 00       	mov    $0x0,%edx
  8027db:	be 00 00 00 00       	mov    $0x0,%esi
  8027e0:	bf 0b 00 00 00       	mov    $0xb,%edi
  8027e5:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  8027ec:	00 00 00 
  8027ef:	ff d0                	callq  *%rax
  8027f1:	48 83 c4 10          	add    $0x10,%rsp
}
  8027f5:	90                   	nop
  8027f6:	c9                   	leaveq 
  8027f7:	c3                   	retq   

00000000008027f8 <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  8027f8:	55                   	push   %rbp
  8027f9:	48 89 e5             	mov    %rsp,%rbp
  8027fc:	48 83 ec 10          	sub    $0x10,%rsp
  802800:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802803:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802807:	89 55 f8             	mov    %edx,-0x8(%rbp)
	return syscall(SYS_page_alloc, 1, envid, (uint64_t) va, perm, 0, 0);
  80280a:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80280d:	48 63 c8             	movslq %eax,%rcx
  802810:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802814:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802817:	48 98                	cltq   
  802819:	48 83 ec 08          	sub    $0x8,%rsp
  80281d:	6a 00                	pushq  $0x0
  80281f:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802825:	49 89 c8             	mov    %rcx,%r8
  802828:	48 89 d1             	mov    %rdx,%rcx
  80282b:	48 89 c2             	mov    %rax,%rdx
  80282e:	be 01 00 00 00       	mov    $0x1,%esi
  802833:	bf 04 00 00 00       	mov    $0x4,%edi
  802838:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  80283f:	00 00 00 
  802842:	ff d0                	callq  *%rax
  802844:	48 83 c4 10          	add    $0x10,%rsp
}
  802848:	c9                   	leaveq 
  802849:	c3                   	retq   

000000000080284a <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80284a:	55                   	push   %rbp
  80284b:	48 89 e5             	mov    %rsp,%rbp
  80284e:	48 83 ec 20          	sub    $0x20,%rsp
  802852:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802855:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802859:	89 55 f8             	mov    %edx,-0x8(%rbp)
  80285c:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  802860:	44 89 45 e4          	mov    %r8d,-0x1c(%rbp)
	return syscall(SYS_page_map, 1, srcenv, (uint64_t) srcva, dstenv, (uint64_t) dstva, perm);
  802864:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  802867:	48 63 c8             	movslq %eax,%rcx
  80286a:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  80286e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802871:	48 63 f0             	movslq %eax,%rsi
  802874:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802878:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80287b:	48 98                	cltq   
  80287d:	48 83 ec 08          	sub    $0x8,%rsp
  802881:	51                   	push   %rcx
  802882:	49 89 f9             	mov    %rdi,%r9
  802885:	49 89 f0             	mov    %rsi,%r8
  802888:	48 89 d1             	mov    %rdx,%rcx
  80288b:	48 89 c2             	mov    %rax,%rdx
  80288e:	be 01 00 00 00       	mov    $0x1,%esi
  802893:	bf 05 00 00 00       	mov    $0x5,%edi
  802898:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  80289f:	00 00 00 
  8028a2:	ff d0                	callq  *%rax
  8028a4:	48 83 c4 10          	add    $0x10,%rsp
}
  8028a8:	c9                   	leaveq 
  8028a9:	c3                   	retq   

00000000008028aa <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  8028aa:	55                   	push   %rbp
  8028ab:	48 89 e5             	mov    %rsp,%rbp
  8028ae:	48 83 ec 10          	sub    $0x10,%rsp
  8028b2:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8028b5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_page_unmap, 1, envid, (uint64_t) va, 0, 0, 0);
  8028b9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8028bd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8028c0:	48 98                	cltq   
  8028c2:	48 83 ec 08          	sub    $0x8,%rsp
  8028c6:	6a 00                	pushq  $0x0
  8028c8:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8028ce:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8028d4:	48 89 d1             	mov    %rdx,%rcx
  8028d7:	48 89 c2             	mov    %rax,%rdx
  8028da:	be 01 00 00 00       	mov    $0x1,%esi
  8028df:	bf 06 00 00 00       	mov    $0x6,%edi
  8028e4:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  8028eb:	00 00 00 
  8028ee:	ff d0                	callq  *%rax
  8028f0:	48 83 c4 10          	add    $0x10,%rsp
}
  8028f4:	c9                   	leaveq 
  8028f5:	c3                   	retq   

00000000008028f6 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  8028f6:	55                   	push   %rbp
  8028f7:	48 89 e5             	mov    %rsp,%rbp
  8028fa:	48 83 ec 10          	sub    $0x10,%rsp
  8028fe:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802901:	89 75 f8             	mov    %esi,-0x8(%rbp)
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
  802904:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802907:	48 63 d0             	movslq %eax,%rdx
  80290a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80290d:	48 98                	cltq   
  80290f:	48 83 ec 08          	sub    $0x8,%rsp
  802913:	6a 00                	pushq  $0x0
  802915:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80291b:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802921:	48 89 d1             	mov    %rdx,%rcx
  802924:	48 89 c2             	mov    %rax,%rdx
  802927:	be 01 00 00 00       	mov    $0x1,%esi
  80292c:	bf 08 00 00 00       	mov    $0x8,%edi
  802931:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802938:	00 00 00 
  80293b:	ff d0                	callq  *%rax
  80293d:	48 83 c4 10          	add    $0x10,%rsp
}
  802941:	c9                   	leaveq 
  802942:	c3                   	retq   

0000000000802943 <sys_env_set_trapframe>:


int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  802943:	55                   	push   %rbp
  802944:	48 89 e5             	mov    %rsp,%rbp
  802947:	48 83 ec 10          	sub    $0x10,%rsp
  80294b:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80294e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_env_set_trapframe, 1, envid, (uint64_t) tf, 0, 0, 0);
  802952:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802956:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802959:	48 98                	cltq   
  80295b:	48 83 ec 08          	sub    $0x8,%rsp
  80295f:	6a 00                	pushq  $0x0
  802961:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802967:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80296d:	48 89 d1             	mov    %rdx,%rcx
  802970:	48 89 c2             	mov    %rax,%rdx
  802973:	be 01 00 00 00       	mov    $0x1,%esi
  802978:	bf 09 00 00 00       	mov    $0x9,%edi
  80297d:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802984:	00 00 00 
  802987:	ff d0                	callq  *%rax
  802989:	48 83 c4 10          	add    $0x10,%rsp
}
  80298d:	c9                   	leaveq 
  80298e:	c3                   	retq   

000000000080298f <sys_env_set_pgfault_upcall>:


int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80298f:	55                   	push   %rbp
  802990:	48 89 e5             	mov    %rsp,%rbp
  802993:	48 83 ec 10          	sub    $0x10,%rsp
  802997:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80299a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint64_t) upcall, 0, 0, 0);
  80299e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8029a2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8029a5:	48 98                	cltq   
  8029a7:	48 83 ec 08          	sub    $0x8,%rsp
  8029ab:	6a 00                	pushq  $0x0
  8029ad:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8029b3:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8029b9:	48 89 d1             	mov    %rdx,%rcx
  8029bc:	48 89 c2             	mov    %rax,%rdx
  8029bf:	be 01 00 00 00       	mov    $0x1,%esi
  8029c4:	bf 0a 00 00 00       	mov    $0xa,%edi
  8029c9:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  8029d0:	00 00 00 
  8029d3:	ff d0                	callq  *%rax
  8029d5:	48 83 c4 10          	add    $0x10,%rsp
}
  8029d9:	c9                   	leaveq 
  8029da:	c3                   	retq   

00000000008029db <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint64_t value, void *srcva, int perm)
{
  8029db:	55                   	push   %rbp
  8029dc:	48 89 e5             	mov    %rsp,%rbp
  8029df:	48 83 ec 20          	sub    $0x20,%rsp
  8029e3:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8029e6:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8029ea:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8029ee:	89 4d f8             	mov    %ecx,-0x8(%rbp)
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint64_t) srcva, perm, 0);
  8029f1:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8029f4:	48 63 f0             	movslq %eax,%rsi
  8029f7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8029fb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8029fe:	48 98                	cltq   
  802a00:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802a04:	48 83 ec 08          	sub    $0x8,%rsp
  802a08:	6a 00                	pushq  $0x0
  802a0a:	49 89 f1             	mov    %rsi,%r9
  802a0d:	49 89 c8             	mov    %rcx,%r8
  802a10:	48 89 d1             	mov    %rdx,%rcx
  802a13:	48 89 c2             	mov    %rax,%rdx
  802a16:	be 00 00 00 00       	mov    $0x0,%esi
  802a1b:	bf 0c 00 00 00       	mov    $0xc,%edi
  802a20:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802a27:	00 00 00 
  802a2a:	ff d0                	callq  *%rax
  802a2c:	48 83 c4 10          	add    $0x10,%rsp
}
  802a30:	c9                   	leaveq 
  802a31:	c3                   	retq   

0000000000802a32 <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  802a32:	55                   	push   %rbp
  802a33:	48 89 e5             	mov    %rsp,%rbp
  802a36:	48 83 ec 10          	sub    $0x10,%rsp
  802a3a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return syscall(SYS_ipc_recv, 1, (uint64_t)dstva, 0, 0, 0, 0);
  802a3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802a42:	48 83 ec 08          	sub    $0x8,%rsp
  802a46:	6a 00                	pushq  $0x0
  802a48:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802a4e:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802a54:	b9 00 00 00 00       	mov    $0x0,%ecx
  802a59:	48 89 c2             	mov    %rax,%rdx
  802a5c:	be 01 00 00 00       	mov    $0x1,%esi
  802a61:	bf 0d 00 00 00       	mov    $0xd,%edi
  802a66:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802a6d:	00 00 00 
  802a70:	ff d0                	callq  *%rax
  802a72:	48 83 c4 10          	add    $0x10,%rsp
}
  802a76:	c9                   	leaveq 
  802a77:	c3                   	retq   

0000000000802a78 <sys_time_msec>:


unsigned int
sys_time_msec(void)
{
  802a78:	55                   	push   %rbp
  802a79:	48 89 e5             	mov    %rsp,%rbp
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
  802a7c:	48 83 ec 08          	sub    $0x8,%rsp
  802a80:	6a 00                	pushq  $0x0
  802a82:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802a88:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802a8e:	b9 00 00 00 00       	mov    $0x0,%ecx
  802a93:	ba 00 00 00 00       	mov    $0x0,%edx
  802a98:	be 00 00 00 00       	mov    $0x0,%esi
  802a9d:	bf 0e 00 00 00       	mov    $0xe,%edi
  802aa2:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802aa9:	00 00 00 
  802aac:	ff d0                	callq  *%rax
  802aae:	48 83 c4 10          	add    $0x10,%rsp
}
  802ab2:	c9                   	leaveq 
  802ab3:	c3                   	retq   

0000000000802ab4 <sys_net_transmit>:


int
sys_net_transmit(const char *data, unsigned int len)
{
  802ab4:	55                   	push   %rbp
  802ab5:	48 89 e5             	mov    %rsp,%rbp
  802ab8:	48 83 ec 10          	sub    $0x10,%rsp
  802abc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802ac0:	89 75 f4             	mov    %esi,-0xc(%rbp)
	return syscall(SYS_net_transmit, 0, (uint64_t)data, len, 0, 0, 0);
  802ac3:	8b 55 f4             	mov    -0xc(%rbp),%edx
  802ac6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802aca:	48 83 ec 08          	sub    $0x8,%rsp
  802ace:	6a 00                	pushq  $0x0
  802ad0:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802ad6:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802adc:	48 89 d1             	mov    %rdx,%rcx
  802adf:	48 89 c2             	mov    %rax,%rdx
  802ae2:	be 00 00 00 00       	mov    $0x0,%esi
  802ae7:	bf 0f 00 00 00       	mov    $0xf,%edi
  802aec:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802af3:	00 00 00 
  802af6:	ff d0                	callq  *%rax
  802af8:	48 83 c4 10          	add    $0x10,%rsp
}
  802afc:	c9                   	leaveq 
  802afd:	c3                   	retq   

0000000000802afe <sys_net_receive>:

int
sys_net_receive(char *buf, unsigned int len)
{
  802afe:	55                   	push   %rbp
  802aff:	48 89 e5             	mov    %rsp,%rbp
  802b02:	48 83 ec 10          	sub    $0x10,%rsp
  802b06:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802b0a:	89 75 f4             	mov    %esi,-0xc(%rbp)
	return syscall(SYS_net_receive, 0, (uint64_t)buf, len, 0, 0, 0);
  802b0d:	8b 55 f4             	mov    -0xc(%rbp),%edx
  802b10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802b14:	48 83 ec 08          	sub    $0x8,%rsp
  802b18:	6a 00                	pushq  $0x0
  802b1a:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802b20:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802b26:	48 89 d1             	mov    %rdx,%rcx
  802b29:	48 89 c2             	mov    %rax,%rdx
  802b2c:	be 00 00 00 00       	mov    $0x0,%esi
  802b31:	bf 10 00 00 00       	mov    $0x10,%edi
  802b36:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802b3d:	00 00 00 
  802b40:	ff d0                	callq  *%rax
  802b42:	48 83 c4 10          	add    $0x10,%rsp
}
  802b46:	c9                   	leaveq 
  802b47:	c3                   	retq   

0000000000802b48 <sys_ept_map>:



int
sys_ept_map(envid_t srcenvid, void *srcva, envid_t guest, void* guest_pa, int perm) 
{
  802b48:	55                   	push   %rbp
  802b49:	48 89 e5             	mov    %rsp,%rbp
  802b4c:	48 83 ec 20          	sub    $0x20,%rsp
  802b50:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802b53:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802b57:	89 55 f8             	mov    %edx,-0x8(%rbp)
  802b5a:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  802b5e:	44 89 45 e4          	mov    %r8d,-0x1c(%rbp)
	return syscall(SYS_ept_map, 0, srcenvid, 
  802b62:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  802b65:	48 63 c8             	movslq %eax,%rcx
  802b68:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  802b6c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802b6f:	48 63 f0             	movslq %eax,%rsi
  802b72:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802b76:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802b79:	48 98                	cltq   
  802b7b:	48 83 ec 08          	sub    $0x8,%rsp
  802b7f:	51                   	push   %rcx
  802b80:	49 89 f9             	mov    %rdi,%r9
  802b83:	49 89 f0             	mov    %rsi,%r8
  802b86:	48 89 d1             	mov    %rdx,%rcx
  802b89:	48 89 c2             	mov    %rax,%rdx
  802b8c:	be 00 00 00 00       	mov    $0x0,%esi
  802b91:	bf 11 00 00 00       	mov    $0x11,%edi
  802b96:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802b9d:	00 00 00 
  802ba0:	ff d0                	callq  *%rax
  802ba2:	48 83 c4 10          	add    $0x10,%rsp
		       (uint64_t)srcva, guest, (uint64_t)guest_pa, perm);
}
  802ba6:	c9                   	leaveq 
  802ba7:	c3                   	retq   

0000000000802ba8 <sys_env_mkguest>:

envid_t
sys_env_mkguest(uint64_t gphysz, uint64_t gRIP) {
  802ba8:	55                   	push   %rbp
  802ba9:	48 89 e5             	mov    %rsp,%rbp
  802bac:	48 83 ec 10          	sub    $0x10,%rsp
  802bb0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802bb4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return (envid_t) syscall(SYS_env_mkguest, 0, gphysz, gRIP, 0, 0, 0);
  802bb8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802bbc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802bc0:	48 83 ec 08          	sub    $0x8,%rsp
  802bc4:	6a 00                	pushq  $0x0
  802bc6:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802bcc:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802bd2:	48 89 d1             	mov    %rdx,%rcx
  802bd5:	48 89 c2             	mov    %rax,%rdx
  802bd8:	be 00 00 00 00       	mov    $0x0,%esi
  802bdd:	bf 12 00 00 00       	mov    $0x12,%edi
  802be2:	48 b8 22 26 80 00 00 	movabs $0x802622,%rax
  802be9:	00 00 00 
  802bec:	ff d0                	callq  *%rax
  802bee:	48 83 c4 10          	add    $0x10,%rsp
}
  802bf2:	c9                   	leaveq 
  802bf3:	c3                   	retq   

0000000000802bf4 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  802bf4:	55                   	push   %rbp
  802bf5:	48 89 e5             	mov    %rsp,%rbp
  802bf8:	48 83 ec 30          	sub    $0x30,%rsp
  802bfc:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	void *addr = (void *) utf->utf_fault_va;
  802c00:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802c04:	48 8b 00             	mov    (%rax),%rax
  802c07:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	uint32_t err = utf->utf_err;
  802c0b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802c0f:	48 8b 40 08          	mov    0x8(%rax),%rax
  802c13:	89 45 fc             	mov    %eax,-0x4(%rbp)


	if (debug)
		cprintf("fault %08x %08x %d from %08x\n", addr, &uvpt[PGNUM(addr)], err & 7, (&addr)[4]);

	if (!(err & FEC_WR))
  802c16:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802c19:	83 e0 02             	and    $0x2,%eax
  802c1c:	85 c0                	test   %eax,%eax
  802c1e:	75 40                	jne    802c60 <pgfault+0x6c>
		panic("read fault at %x, rip %x", addr, utf->utf_rip);
  802c20:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802c24:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  802c2b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802c2f:	49 89 d0             	mov    %rdx,%r8
  802c32:	48 89 c1             	mov    %rax,%rcx
  802c35:	48 ba 78 15 82 00 00 	movabs $0x821578,%rdx
  802c3c:	00 00 00 
  802c3f:	be 1f 00 00 00       	mov    $0x1f,%esi
  802c44:	48 bf 91 15 82 00 00 	movabs $0x821591,%rdi
  802c4b:	00 00 00 
  802c4e:	b8 00 00 00 00       	mov    $0x0,%eax
  802c53:	49 b9 f8 10 80 00 00 	movabs $0x8010f8,%r9
  802c5a:	00 00 00 
  802c5d:	41 ff d1             	callq  *%r9
	if ((uvpt[PGNUM(addr)] & (PTE_P|PTE_U|PTE_W|PTE_COW)) != (PTE_P|PTE_U|PTE_COW))
  802c60:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802c64:	48 c1 e8 0c          	shr    $0xc,%rax
  802c68:	48 89 c2             	mov    %rax,%rdx
  802c6b:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802c72:	01 00 00 
  802c75:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802c79:	25 07 08 00 00       	and    $0x807,%eax
  802c7e:	48 3d 05 08 00 00    	cmp    $0x805,%rax
  802c84:	74 4e                	je     802cd4 <pgfault+0xe0>
		panic("fault at %x with pte %x, not copy-on-write",
  802c86:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802c8a:	48 c1 e8 0c          	shr    $0xc,%rax
  802c8e:	48 89 c2             	mov    %rax,%rdx
  802c91:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802c98:	01 00 00 
  802c9b:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  802c9f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802ca3:	49 89 d0             	mov    %rdx,%r8
  802ca6:	48 89 c1             	mov    %rax,%rcx
  802ca9:	48 ba a0 15 82 00 00 	movabs $0x8215a0,%rdx
  802cb0:	00 00 00 
  802cb3:	be 22 00 00 00       	mov    $0x22,%esi
  802cb8:	48 bf 91 15 82 00 00 	movabs $0x821591,%rdi
  802cbf:	00 00 00 
  802cc2:	b8 00 00 00 00       	mov    $0x0,%eax
  802cc7:	49 b9 f8 10 80 00 00 	movabs $0x8010f8,%r9
  802cce:	00 00 00 
  802cd1:	41 ff d1             	callq  *%r9
		      addr, uvpt[PGNUM(addr)]);



	// copy page
	if ((r = sys_page_alloc(0, (void*) PFTEMP, PTE_P|PTE_U|PTE_W)) < 0)
  802cd4:	ba 07 00 00 00       	mov    $0x7,%edx
  802cd9:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802cde:	bf 00 00 00 00       	mov    $0x0,%edi
  802ce3:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  802cea:	00 00 00 
  802ced:	ff d0                	callq  *%rax
  802cef:	89 45 f8             	mov    %eax,-0x8(%rbp)
  802cf2:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  802cf6:	79 30                	jns    802d28 <pgfault+0x134>
		panic("sys_page_alloc: %e", r);
  802cf8:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802cfb:	89 c1                	mov    %eax,%ecx
  802cfd:	48 ba cb 15 82 00 00 	movabs $0x8215cb,%rdx
  802d04:	00 00 00 
  802d07:	be 28 00 00 00       	mov    $0x28,%esi
  802d0c:	48 bf 91 15 82 00 00 	movabs $0x821591,%rdi
  802d13:	00 00 00 
  802d16:	b8 00 00 00 00       	mov    $0x0,%eax
  802d1b:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  802d22:	00 00 00 
  802d25:	41 ff d0             	callq  *%r8
	memmove((void*) PFTEMP, ROUNDDOWN(addr, PGSIZE), PGSIZE);
  802d28:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802d2c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  802d30:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802d34:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  802d3a:	ba 00 10 00 00       	mov    $0x1000,%edx
  802d3f:	48 89 c6             	mov    %rax,%rsi
  802d42:	bf 00 f0 5f 00       	mov    $0x5ff000,%edi
  802d47:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  802d4e:	00 00 00 
  802d51:	ff d0                	callq  *%rax

	// remap over faulting page
	if ((r = sys_page_map(0, (void*) PFTEMP, 0, ROUNDDOWN(addr, PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
  802d53:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802d57:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  802d5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802d5f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  802d65:	41 b8 07 00 00 00    	mov    $0x7,%r8d
  802d6b:	48 89 c1             	mov    %rax,%rcx
  802d6e:	ba 00 00 00 00       	mov    $0x0,%edx
  802d73:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802d78:	bf 00 00 00 00       	mov    $0x0,%edi
  802d7d:	48 b8 4a 28 80 00 00 	movabs $0x80284a,%rax
  802d84:	00 00 00 
  802d87:	ff d0                	callq  *%rax
  802d89:	89 45 f8             	mov    %eax,-0x8(%rbp)
  802d8c:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  802d90:	79 30                	jns    802dc2 <pgfault+0x1ce>
		panic("sys_page_map: %e", r);
  802d92:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802d95:	89 c1                	mov    %eax,%ecx
  802d97:	48 ba de 15 82 00 00 	movabs $0x8215de,%rdx
  802d9e:	00 00 00 
  802da1:	be 2d 00 00 00       	mov    $0x2d,%esi
  802da6:	48 bf 91 15 82 00 00 	movabs $0x821591,%rdi
  802dad:	00 00 00 
  802db0:	b8 00 00 00 00       	mov    $0x0,%eax
  802db5:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  802dbc:	00 00 00 
  802dbf:	41 ff d0             	callq  *%r8

	// unmap our work space
	if ((r = sys_page_unmap(0, (void*) PFTEMP)) < 0)
  802dc2:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802dc7:	bf 00 00 00 00       	mov    $0x0,%edi
  802dcc:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  802dd3:	00 00 00 
  802dd6:	ff d0                	callq  *%rax
  802dd8:	89 45 f8             	mov    %eax,-0x8(%rbp)
  802ddb:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  802ddf:	79 30                	jns    802e11 <pgfault+0x21d>
		panic("sys_page_unmap: %e", r);
  802de1:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802de4:	89 c1                	mov    %eax,%ecx
  802de6:	48 ba ef 15 82 00 00 	movabs $0x8215ef,%rdx
  802ded:	00 00 00 
  802df0:	be 31 00 00 00       	mov    $0x31,%esi
  802df5:	48 bf 91 15 82 00 00 	movabs $0x821591,%rdi
  802dfc:	00 00 00 
  802dff:	b8 00 00 00 00       	mov    $0x0,%eax
  802e04:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  802e0b:	00 00 00 
  802e0e:	41 ff d0             	callq  *%r8

}
  802e11:	90                   	nop
  802e12:	c9                   	leaveq 
  802e13:	c3                   	retq   

0000000000802e14 <duppage>:
// Returns: 0 on success, < 0 on error.
// It is also OK to panic on error.
//
static int
duppage(envid_t envid, unsigned pn)
{
  802e14:	55                   	push   %rbp
  802e15:	48 89 e5             	mov    %rsp,%rbp
  802e18:	48 83 ec 30          	sub    $0x30,%rsp
  802e1c:	89 7d dc             	mov    %edi,-0x24(%rbp)
  802e1f:	89 75 d8             	mov    %esi,-0x28(%rbp)


	void *addr;
	pte_t pte;

	addr = (void*) (uint64_t)(pn << PGSHIFT);
  802e22:	8b 45 d8             	mov    -0x28(%rbp),%eax
  802e25:	c1 e0 0c             	shl    $0xc,%eax
  802e28:	89 c0                	mov    %eax,%eax
  802e2a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	pte = uvpt[pn];
  802e2e:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802e35:	01 00 00 
  802e38:	8b 55 d8             	mov    -0x28(%rbp),%edx
  802e3b:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802e3f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	

	// if the page is just read-only or is library-shared, map it directly.
	if (!(pte & (PTE_W|PTE_COW)) || (pte & PTE_SHARE)) {
  802e43:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802e47:	25 02 08 00 00       	and    $0x802,%eax
  802e4c:	48 85 c0             	test   %rax,%rax
  802e4f:	74 0e                	je     802e5f <duppage+0x4b>
  802e51:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802e55:	25 00 04 00 00       	and    $0x400,%eax
  802e5a:	48 85 c0             	test   %rax,%rax
  802e5d:	74 70                	je     802ecf <duppage+0xbb>
		if ((r = sys_page_map(0, addr, envid, addr, pte & PTE_SYSCALL)) < 0)
  802e5f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802e63:	25 07 0e 00 00       	and    $0xe07,%eax
  802e68:	89 c6                	mov    %eax,%esi
  802e6a:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  802e6e:	8b 55 dc             	mov    -0x24(%rbp),%edx
  802e71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802e75:	41 89 f0             	mov    %esi,%r8d
  802e78:	48 89 c6             	mov    %rax,%rsi
  802e7b:	bf 00 00 00 00       	mov    $0x0,%edi
  802e80:	48 b8 4a 28 80 00 00 	movabs $0x80284a,%rax
  802e87:	00 00 00 
  802e8a:	ff d0                	callq  *%rax
  802e8c:	89 45 ec             	mov    %eax,-0x14(%rbp)
  802e8f:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  802e93:	79 30                	jns    802ec5 <duppage+0xb1>
			panic("sys_page_map: %e", r);
  802e95:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802e98:	89 c1                	mov    %eax,%ecx
  802e9a:	48 ba de 15 82 00 00 	movabs $0x8215de,%rdx
  802ea1:	00 00 00 
  802ea4:	be 50 00 00 00       	mov    $0x50,%esi
  802ea9:	48 bf 91 15 82 00 00 	movabs $0x821591,%rdi
  802eb0:	00 00 00 
  802eb3:	b8 00 00 00 00       	mov    $0x0,%eax
  802eb8:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  802ebf:	00 00 00 
  802ec2:	41 ff d0             	callq  *%r8
		return 0;
  802ec5:	b8 00 00 00 00       	mov    $0x0,%eax
  802eca:	e9 c4 00 00 00       	jmpq   802f93 <duppage+0x17f>
	// Even if we think the page is already copy-on-write in our
	// address space, we need to mark it copy-on-write again after
	// the first sys_page_map, just in case a page fault has caused
	// us to copy the page in the interim.

	if ((r = sys_page_map(0, addr, envid, addr, PTE_P|PTE_U|PTE_COW)) < 0)
  802ecf:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  802ed3:	8b 55 dc             	mov    -0x24(%rbp),%edx
  802ed6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802eda:	41 b8 05 08 00 00    	mov    $0x805,%r8d
  802ee0:	48 89 c6             	mov    %rax,%rsi
  802ee3:	bf 00 00 00 00       	mov    $0x0,%edi
  802ee8:	48 b8 4a 28 80 00 00 	movabs $0x80284a,%rax
  802eef:	00 00 00 
  802ef2:	ff d0                	callq  *%rax
  802ef4:	89 45 ec             	mov    %eax,-0x14(%rbp)
  802ef7:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  802efb:	79 30                	jns    802f2d <duppage+0x119>
		panic("sys_page_map: %e", r);
  802efd:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802f00:	89 c1                	mov    %eax,%ecx
  802f02:	48 ba de 15 82 00 00 	movabs $0x8215de,%rdx
  802f09:	00 00 00 
  802f0c:	be 64 00 00 00       	mov    $0x64,%esi
  802f11:	48 bf 91 15 82 00 00 	movabs $0x821591,%rdi
  802f18:	00 00 00 
  802f1b:	b8 00 00 00 00       	mov    $0x0,%eax
  802f20:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  802f27:	00 00 00 
  802f2a:	41 ff d0             	callq  *%r8
	if ((r = sys_page_map(0, addr, 0, addr, PTE_P|PTE_U|PTE_COW)) < 0)
  802f2d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  802f31:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802f35:	41 b8 05 08 00 00    	mov    $0x805,%r8d
  802f3b:	48 89 d1             	mov    %rdx,%rcx
  802f3e:	ba 00 00 00 00       	mov    $0x0,%edx
  802f43:	48 89 c6             	mov    %rax,%rsi
  802f46:	bf 00 00 00 00       	mov    $0x0,%edi
  802f4b:	48 b8 4a 28 80 00 00 	movabs $0x80284a,%rax
  802f52:	00 00 00 
  802f55:	ff d0                	callq  *%rax
  802f57:	89 45 ec             	mov    %eax,-0x14(%rbp)
  802f5a:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  802f5e:	79 30                	jns    802f90 <duppage+0x17c>
		panic("sys_page_map: %e", r);
  802f60:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802f63:	89 c1                	mov    %eax,%ecx
  802f65:	48 ba de 15 82 00 00 	movabs $0x8215de,%rdx
  802f6c:	00 00 00 
  802f6f:	be 66 00 00 00       	mov    $0x66,%esi
  802f74:	48 bf 91 15 82 00 00 	movabs $0x821591,%rdi
  802f7b:	00 00 00 
  802f7e:	b8 00 00 00 00       	mov    $0x0,%eax
  802f83:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  802f8a:	00 00 00 
  802f8d:	41 ff d0             	callq  *%r8
	return r;
  802f90:	8b 45 ec             	mov    -0x14(%rbp),%eax

}
  802f93:	c9                   	leaveq 
  802f94:	c3                   	retq   

0000000000802f95 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  802f95:	55                   	push   %rbp
  802f96:	48 89 e5             	mov    %rsp,%rbp
  802f99:	48 83 ec 20          	sub    $0x20,%rsp

	envid_t envid;
	int pn, end_pn, r;

	set_pgfault_handler(pgfault);
  802f9d:	48 bf f4 2b 80 00 00 	movabs $0x802bf4,%rdi
  802fa4:	00 00 00 
  802fa7:	48 b8 77 5b 80 00 00 	movabs $0x805b77,%rax
  802fae:	00 00 00 
  802fb1:	ff d0                	callq  *%rax
// This must be inlined.  Exercise for reader: why?
static __inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	__asm __volatile("int %2"
  802fb3:	b8 07 00 00 00       	mov    $0x7,%eax
  802fb8:	cd 30                	int    $0x30
  802fba:	89 45 ec             	mov    %eax,-0x14(%rbp)
		: "=a" (ret)
		: "a" (SYS_exofork),
		  "i" (T_SYSCALL)
	);
	return ret;
  802fbd:	8b 45 ec             	mov    -0x14(%rbp),%eax

	// Create a child.
	envid = sys_exofork();
  802fc0:	89 45 f8             	mov    %eax,-0x8(%rbp)
	if (envid < 0)
  802fc3:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  802fc7:	79 08                	jns    802fd1 <fork+0x3c>
		return envid;
  802fc9:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802fcc:	e9 0b 02 00 00       	jmpq   8031dc <fork+0x247>
	if (envid == 0) {
  802fd1:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  802fd5:	75 3e                	jne    803015 <fork+0x80>
		thisenv = &envs[ENVX(sys_getenvid())];
  802fd7:	48 b8 7f 27 80 00 00 	movabs $0x80277f,%rax
  802fde:	00 00 00 
  802fe1:	ff d0                	callq  *%rax
  802fe3:	25 ff 03 00 00       	and    $0x3ff,%eax
  802fe8:	48 98                	cltq   
  802fea:	48 69 d0 68 01 00 00 	imul   $0x168,%rax,%rdx
  802ff1:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  802ff8:	00 00 00 
  802ffb:	48 01 c2             	add    %rax,%rdx
  802ffe:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803005:	00 00 00 
  803008:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  80300b:	b8 00 00 00 00       	mov    $0x0,%eax
  803010:	e9 c7 01 00 00       	jmpq   8031dc <fork+0x247>
	}

	// Copy the address space.
	for (pn = 0; pn < PGNUM(UTOP); ) {
  803015:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80301c:	e9 a6 00 00 00       	jmpq   8030c7 <fork+0x132>
		if (!(uvpde[pn >> 18] & PTE_P && uvpd[pn >> 9] & PTE_P)) {
  803021:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803024:	c1 f8 12             	sar    $0x12,%eax
  803027:	89 c2                	mov    %eax,%edx
  803029:	48 b8 00 00 40 80 00 	movabs $0x10080400000,%rax
  803030:	01 00 00 
  803033:	48 63 d2             	movslq %edx,%rdx
  803036:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80303a:	83 e0 01             	and    $0x1,%eax
  80303d:	48 85 c0             	test   %rax,%rax
  803040:	74 21                	je     803063 <fork+0xce>
  803042:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803045:	c1 f8 09             	sar    $0x9,%eax
  803048:	89 c2                	mov    %eax,%edx
  80304a:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  803051:	01 00 00 
  803054:	48 63 d2             	movslq %edx,%rdx
  803057:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80305b:	83 e0 01             	and    $0x1,%eax
  80305e:	48 85 c0             	test   %rax,%rax
  803061:	75 09                	jne    80306c <fork+0xd7>
			pn += NPTENTRIES;
  803063:	81 45 fc 00 02 00 00 	addl   $0x200,-0x4(%rbp)
			continue;
  80306a:	eb 5b                	jmp    8030c7 <fork+0x132>
		}
		for (end_pn = pn + NPTENTRIES; pn < end_pn; pn++) {
  80306c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80306f:	05 00 02 00 00       	add    $0x200,%eax
  803074:	89 45 f4             	mov    %eax,-0xc(%rbp)
  803077:	eb 46                	jmp    8030bf <fork+0x12a>
			if ((uvpt[pn] & (PTE_P|PTE_U)) != (PTE_P|PTE_U))
  803079:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803080:	01 00 00 
  803083:	8b 55 fc             	mov    -0x4(%rbp),%edx
  803086:	48 63 d2             	movslq %edx,%rdx
  803089:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80308d:	83 e0 05             	and    $0x5,%eax
  803090:	48 83 f8 05          	cmp    $0x5,%rax
  803094:	75 21                	jne    8030b7 <fork+0x122>
				continue;
			if (pn == PPN(UXSTACKTOP - 1))
  803096:	81 7d fc ff f7 0e 00 	cmpl   $0xef7ff,-0x4(%rbp)
  80309d:	74 1b                	je     8030ba <fork+0x125>
				continue;
			duppage(envid, pn);
  80309f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8030a2:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8030a5:	89 d6                	mov    %edx,%esi
  8030a7:	89 c7                	mov    %eax,%edi
  8030a9:	48 b8 14 2e 80 00 00 	movabs $0x802e14,%rax
  8030b0:	00 00 00 
  8030b3:	ff d0                	callq  *%rax
  8030b5:	eb 04                	jmp    8030bb <fork+0x126>
			pn += NPTENTRIES;
			continue;
		}
		for (end_pn = pn + NPTENTRIES; pn < end_pn; pn++) {
			if ((uvpt[pn] & (PTE_P|PTE_U)) != (PTE_P|PTE_U))
				continue;
  8030b7:	90                   	nop
  8030b8:	eb 01                	jmp    8030bb <fork+0x126>
			if (pn == PPN(UXSTACKTOP - 1))
				continue;
  8030ba:	90                   	nop
	for (pn = 0; pn < PGNUM(UTOP); ) {
		if (!(uvpde[pn >> 18] & PTE_P && uvpd[pn >> 9] & PTE_P)) {
			pn += NPTENTRIES;
			continue;
		}
		for (end_pn = pn + NPTENTRIES; pn < end_pn; pn++) {
  8030bb:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8030bf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8030c2:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8030c5:	7c b2                	jl     803079 <fork+0xe4>
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}

	// Copy the address space.
	for (pn = 0; pn < PGNUM(UTOP); ) {
  8030c7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8030ca:	3d ff 07 00 08       	cmp    $0x80007ff,%eax
  8030cf:	0f 86 4c ff ff ff    	jbe    803021 <fork+0x8c>
			duppage(envid, pn);
		}
	}

	// The child needs to start out with a valid exception stack.
	if ((r = sys_page_alloc(envid, (void*) (UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
  8030d5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8030d8:	ba 07 00 00 00       	mov    $0x7,%edx
  8030dd:	be 00 f0 7f ef       	mov    $0xef7ff000,%esi
  8030e2:	89 c7                	mov    %eax,%edi
  8030e4:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  8030eb:	00 00 00 
  8030ee:	ff d0                	callq  *%rax
  8030f0:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8030f3:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8030f7:	79 30                	jns    803129 <fork+0x194>
		panic("allocating exception stack: %e", r);
  8030f9:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8030fc:	89 c1                	mov    %eax,%ecx
  8030fe:	48 ba 08 16 82 00 00 	movabs $0x821608,%rdx
  803105:	00 00 00 
  803108:	be 9e 00 00 00       	mov    $0x9e,%esi
  80310d:	48 bf 91 15 82 00 00 	movabs $0x821591,%rdi
  803114:	00 00 00 
  803117:	b8 00 00 00 00       	mov    $0x0,%eax
  80311c:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  803123:	00 00 00 
  803126:	41 ff d0             	callq  *%r8

	// Copy the user-mode exception entrypoint.
	if ((r = sys_env_set_pgfault_upcall(envid, thisenv->env_pgfault_upcall)) < 0)
  803129:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803130:	00 00 00 
  803133:	48 8b 00             	mov    (%rax),%rax
  803136:	48 8b 90 f0 00 00 00 	mov    0xf0(%rax),%rdx
  80313d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803140:	48 89 d6             	mov    %rdx,%rsi
  803143:	89 c7                	mov    %eax,%edi
  803145:	48 b8 8f 29 80 00 00 	movabs $0x80298f,%rax
  80314c:	00 00 00 
  80314f:	ff d0                	callq  *%rax
  803151:	89 45 f0             	mov    %eax,-0x10(%rbp)
  803154:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  803158:	79 30                	jns    80318a <fork+0x1f5>
		panic("sys_env_set_pgfault_upcall: %e", r);
  80315a:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80315d:	89 c1                	mov    %eax,%ecx
  80315f:	48 ba 28 16 82 00 00 	movabs $0x821628,%rdx
  803166:	00 00 00 
  803169:	be a2 00 00 00       	mov    $0xa2,%esi
  80316e:	48 bf 91 15 82 00 00 	movabs $0x821591,%rdi
  803175:	00 00 00 
  803178:	b8 00 00 00 00       	mov    $0x0,%eax
  80317d:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  803184:	00 00 00 
  803187:	41 ff d0             	callq  *%r8


	// Okay, the child is ready for life on its own.
	if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) < 0)
  80318a:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80318d:	be 02 00 00 00       	mov    $0x2,%esi
  803192:	89 c7                	mov    %eax,%edi
  803194:	48 b8 f6 28 80 00 00 	movabs $0x8028f6,%rax
  80319b:	00 00 00 
  80319e:	ff d0                	callq  *%rax
  8031a0:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8031a3:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8031a7:	79 30                	jns    8031d9 <fork+0x244>
		panic("sys_env_set_status: %e", r);
  8031a9:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8031ac:	89 c1                	mov    %eax,%ecx
  8031ae:	48 ba 47 16 82 00 00 	movabs $0x821647,%rdx
  8031b5:	00 00 00 
  8031b8:	be a7 00 00 00       	mov    $0xa7,%esi
  8031bd:	48 bf 91 15 82 00 00 	movabs $0x821591,%rdi
  8031c4:	00 00 00 
  8031c7:	b8 00 00 00 00       	mov    $0x0,%eax
  8031cc:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  8031d3:	00 00 00 
  8031d6:	41 ff d0             	callq  *%r8

	return envid;
  8031d9:	8b 45 f8             	mov    -0x8(%rbp),%eax

}
  8031dc:	c9                   	leaveq 
  8031dd:	c3                   	retq   

00000000008031de <sfork>:

// Challenge!
int
sfork(void)
{
  8031de:	55                   	push   %rbp
  8031df:	48 89 e5             	mov    %rsp,%rbp
	panic("sfork not implemented");
  8031e2:	48 ba 5e 16 82 00 00 	movabs $0x82165e,%rdx
  8031e9:	00 00 00 
  8031ec:	be b1 00 00 00       	mov    $0xb1,%esi
  8031f1:	48 bf 91 15 82 00 00 	movabs $0x821591,%rdi
  8031f8:	00 00 00 
  8031fb:	b8 00 00 00 00       	mov    $0x0,%eax
  803200:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  803207:	00 00 00 
  80320a:	ff d1                	callq  *%rcx

000000000080320c <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80320c:	55                   	push   %rbp
  80320d:	48 89 e5             	mov    %rsp,%rbp
  803210:	48 83 ec 30          	sub    $0x30,%rsp
  803214:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803218:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80321c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	int r;

	if (!pg)
  803220:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  803225:	75 0e                	jne    803235 <ipc_recv+0x29>
		pg = (void*) UTOP;
  803227:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  80322e:	00 00 00 
  803231:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if ((r = sys_ipc_recv(pg)) < 0) {
  803235:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803239:	48 89 c7             	mov    %rax,%rdi
  80323c:	48 b8 32 2a 80 00 00 	movabs $0x802a32,%rax
  803243:	00 00 00 
  803246:	ff d0                	callq  *%rax
  803248:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80324b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80324f:	79 27                	jns    803278 <ipc_recv+0x6c>
		if (from_env_store)
  803251:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  803256:	74 0a                	je     803262 <ipc_recv+0x56>
			*from_env_store = 0;
  803258:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80325c:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
		if (perm_store)
  803262:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  803267:	74 0a                	je     803273 <ipc_recv+0x67>
			*perm_store = 0;
  803269:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80326d:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
		return r;
  803273:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803276:	eb 53                	jmp    8032cb <ipc_recv+0xbf>
	}
	if (from_env_store)
  803278:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80327d:	74 19                	je     803298 <ipc_recv+0x8c>
		*from_env_store = thisenv->env_ipc_from;
  80327f:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803286:	00 00 00 
  803289:	48 8b 00             	mov    (%rax),%rax
  80328c:	8b 90 0c 01 00 00    	mov    0x10c(%rax),%edx
  803292:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803296:	89 10                	mov    %edx,(%rax)
	if (perm_store)
  803298:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80329d:	74 19                	je     8032b8 <ipc_recv+0xac>
		*perm_store = thisenv->env_ipc_perm;
  80329f:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8032a6:	00 00 00 
  8032a9:	48 8b 00             	mov    (%rax),%rax
  8032ac:	8b 90 10 01 00 00    	mov    0x110(%rax),%edx
  8032b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8032b6:	89 10                	mov    %edx,(%rax)
	return thisenv->env_ipc_value;
  8032b8:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8032bf:	00 00 00 
  8032c2:	48 8b 00             	mov    (%rax),%rax
  8032c5:	8b 80 08 01 00 00    	mov    0x108(%rax),%eax

}
  8032cb:	c9                   	leaveq 
  8032cc:	c3                   	retq   

00000000008032cd <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  8032cd:	55                   	push   %rbp
  8032ce:	48 89 e5             	mov    %rsp,%rbp
  8032d1:	48 83 ec 30          	sub    $0x30,%rsp
  8032d5:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8032d8:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8032db:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  8032df:	89 4d dc             	mov    %ecx,-0x24(%rbp)

	int r;

	if (!pg)
  8032e2:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8032e7:	75 1c                	jne    803305 <ipc_send+0x38>
		pg = (void*) UTOP;
  8032e9:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  8032f0:	00 00 00 
  8032f3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while ((r = sys_ipc_try_send(to_env, val, pg, perm)) == -E_IPC_NOT_RECV) {
  8032f7:	eb 0c                	jmp    803305 <ipc_send+0x38>
		sys_yield();
  8032f9:	48 b8 bb 27 80 00 00 	movabs $0x8027bb,%rax
  803300:	00 00 00 
  803303:	ff d0                	callq  *%rax

	int r;

	if (!pg)
		pg = (void*) UTOP;
	while ((r = sys_ipc_try_send(to_env, val, pg, perm)) == -E_IPC_NOT_RECV) {
  803305:	8b 75 e8             	mov    -0x18(%rbp),%esi
  803308:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  80330b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80330f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803312:	89 c7                	mov    %eax,%edi
  803314:	48 b8 db 29 80 00 00 	movabs $0x8029db,%rax
  80331b:	00 00 00 
  80331e:	ff d0                	callq  *%rax
  803320:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803323:	83 7d fc f8          	cmpl   $0xfffffff8,-0x4(%rbp)
  803327:	74 d0                	je     8032f9 <ipc_send+0x2c>
		sys_yield();
	}
	if (r < 0)
  803329:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80332d:	79 30                	jns    80335f <ipc_send+0x92>
		panic("error in ipc_send: %e", r);
  80332f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803332:	89 c1                	mov    %eax,%ecx
  803334:	48 ba 74 16 82 00 00 	movabs $0x821674,%rdx
  80333b:	00 00 00 
  80333e:	be 47 00 00 00       	mov    $0x47,%esi
  803343:	48 bf 8a 16 82 00 00 	movabs $0x82168a,%rdi
  80334a:	00 00 00 
  80334d:	b8 00 00 00 00       	mov    $0x0,%eax
  803352:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  803359:	00 00 00 
  80335c:	41 ff d0             	callq  *%r8

}
  80335f:	90                   	nop
  803360:	c9                   	leaveq 
  803361:	c3                   	retq   

0000000000803362 <ipc_host_recv>:
#ifdef VMM_GUEST

// Access to host IPC interface through VMCALL.
// Should behave similarly to ipc_recv, except replacing the system call with a vmcall.
int32_t
ipc_host_recv(void *pg) {
  803362:	55                   	push   %rbp
  803363:	48 89 e5             	mov    %rsp,%rbp
  803366:	53                   	push   %rbx
  803367:	48 83 ec 28          	sub    $0x28,%rsp
  80336b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)

	/* FIXME: This should be SOL 8 */
	int r = 0, val = 0;
  80336f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  803376:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)

	if (!pg)
  80337d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  803382:	75 0e                	jne    803392 <ipc_host_recv+0x30>
		pg = (void*) UTOP;
  803384:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  80338b:	00 00 00 
  80338e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	sys_page_alloc(0, pg, PTE_U|PTE_P|PTE_W);
  803392:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803396:	ba 07 00 00 00       	mov    $0x7,%edx
  80339b:	48 89 c6             	mov    %rax,%rsi
  80339e:	bf 00 00 00 00       	mov    $0x0,%edi
  8033a3:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  8033aa:	00 00 00 
  8033ad:	ff d0                	callq  *%rax
	physaddr_t pa = PTE_ADDR(uvpt[PGNUM(pg)]);
  8033af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8033b3:	48 c1 e8 0c          	shr    $0xc,%rax
  8033b7:	48 89 c2             	mov    %rax,%rdx
  8033ba:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8033c1:	01 00 00 
  8033c4:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8033c8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8033ce:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	asm("vmcall": "=a"(r), "=S"(val)  : "0"(VMX_VMCALL_IPCRECV), "b"(pa));
  8033d2:	b8 03 00 00 00       	mov    $0x3,%eax
  8033d7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8033db:	48 89 d3             	mov    %rdx,%rbx
  8033de:	0f 01 c1             	vmcall 
  8033e1:	89 f2                	mov    %esi,%edx
  8033e3:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8033e6:	89 55 e8             	mov    %edx,-0x18(%rbp)
	//cprintf("Returned IPC response from host: %d %d\n", r, -val);
	if (r < 0) {
  8033e9:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8033ed:	79 05                	jns    8033f4 <ipc_host_recv+0x92>
		return r;
  8033ef:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8033f2:	eb 03                	jmp    8033f7 <ipc_host_recv+0x95>
	}
	return val;
  8033f4:	8b 45 e8             	mov    -0x18(%rbp),%eax

}
  8033f7:	48 83 c4 28          	add    $0x28,%rsp
  8033fb:	5b                   	pop    %rbx
  8033fc:	5d                   	pop    %rbp
  8033fd:	c3                   	retq   

00000000008033fe <ipc_host_send>:
// Access to host IPC interface through VMCALL.
// Should behave similarly to ipc_send, except replacing the system call with a vmcall.
// This function should also convert pg from guest virtual to guest physical for the IPC call
void
ipc_host_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  8033fe:	55                   	push   %rbp
  8033ff:	48 89 e5             	mov    %rsp,%rbp
  803402:	53                   	push   %rbx
  803403:	48 83 ec 38          	sub    $0x38,%rsp
  803407:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80340a:	89 75 d8             	mov    %esi,-0x28(%rbp)
  80340d:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  803411:	89 4d cc             	mov    %ecx,-0x34(%rbp)

	/* FIXME: This should be SOL 8 */
	int r = 0;
  803414:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

	if (!pg)
  80341b:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  803420:	75 0e                	jne    803430 <ipc_host_send+0x32>
		pg = (void*) UTOP;
  803422:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  803429:	00 00 00 
  80342c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	// Convert pg from guest virtual address to guest physical address.
	physaddr_t pa = PTE_ADDR(uvpt[PGNUM(pg)]);
  803430:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803434:	48 c1 e8 0c          	shr    $0xc,%rax
  803438:	48 89 c2             	mov    %rax,%rdx
  80343b:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803442:	01 00 00 
  803445:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803449:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80344f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	asm("vmcall": "=a"(r): "0"(VMX_VMCALL_IPCSEND), "b"(to_env), "c"(val), 
  803453:	b8 02 00 00 00       	mov    $0x2,%eax
  803458:	8b 7d dc             	mov    -0x24(%rbp),%edi
  80345b:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  80345e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  803462:	8b 75 cc             	mov    -0x34(%rbp),%esi
  803465:	89 fb                	mov    %edi,%ebx
  803467:	0f 01 c1             	vmcall 
  80346a:	89 45 ec             	mov    %eax,-0x14(%rbp)
            "d"(pa), "S"(perm));
	while(r == -E_IPC_NOT_RECV) {
  80346d:	eb 26                	jmp    803495 <ipc_host_send+0x97>
		sys_yield();
  80346f:	48 b8 bb 27 80 00 00 	movabs $0x8027bb,%rax
  803476:	00 00 00 
  803479:	ff d0                	callq  *%rax
		asm("vmcall": "=a"(r): "0"(VMX_VMCALL_IPCSEND), "b"(to_env), "c"(val), 
  80347b:	b8 02 00 00 00       	mov    $0x2,%eax
  803480:	8b 7d dc             	mov    -0x24(%rbp),%edi
  803483:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  803486:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80348a:	8b 75 cc             	mov    -0x34(%rbp),%esi
  80348d:	89 fb                	mov    %edi,%ebx
  80348f:	0f 01 c1             	vmcall 
  803492:	89 45 ec             	mov    %eax,-0x14(%rbp)
		pg = (void*) UTOP;
	// Convert pg from guest virtual address to guest physical address.
	physaddr_t pa = PTE_ADDR(uvpt[PGNUM(pg)]);
	asm("vmcall": "=a"(r): "0"(VMX_VMCALL_IPCSEND), "b"(to_env), "c"(val), 
            "d"(pa), "S"(perm));
	while(r == -E_IPC_NOT_RECV) {
  803495:	83 7d ec f8          	cmpl   $0xfffffff8,-0x14(%rbp)
  803499:	74 d4                	je     80346f <ipc_host_send+0x71>
		sys_yield();
		asm("vmcall": "=a"(r): "0"(VMX_VMCALL_IPCSEND), "b"(to_env), "c"(val), 
		    "d"(pa), "S"(perm));
	}
	if (r < 0)
  80349b:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80349f:	79 30                	jns    8034d1 <ipc_host_send+0xd3>
		panic("error in ipc_send: %e", r);
  8034a1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8034a4:	89 c1                	mov    %eax,%ecx
  8034a6:	48 ba 74 16 82 00 00 	movabs $0x821674,%rdx
  8034ad:	00 00 00 
  8034b0:	be 79 00 00 00       	mov    $0x79,%esi
  8034b5:	48 bf 8a 16 82 00 00 	movabs $0x82168a,%rdi
  8034bc:	00 00 00 
  8034bf:	b8 00 00 00 00       	mov    $0x0,%eax
  8034c4:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  8034cb:	00 00 00 
  8034ce:	41 ff d0             	callq  *%r8

}
  8034d1:	90                   	nop
  8034d2:	48 83 c4 38          	add    $0x38,%rsp
  8034d6:	5b                   	pop    %rbx
  8034d7:	5d                   	pop    %rbp
  8034d8:	c3                   	retq   

00000000008034d9 <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  8034d9:	55                   	push   %rbp
  8034da:	48 89 e5             	mov    %rsp,%rbp
  8034dd:	48 83 ec 18          	sub    $0x18,%rsp
  8034e1:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int i;
	for (i = 0; i < NENV; i++) {
  8034e4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8034eb:	eb 4d                	jmp    80353a <ipc_find_env+0x61>
		if (envs[i].env_type == type)
  8034ed:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  8034f4:	00 00 00 
  8034f7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8034fa:	48 98                	cltq   
  8034fc:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  803503:	48 01 d0             	add    %rdx,%rax
  803506:	48 05 d0 00 00 00    	add    $0xd0,%rax
  80350c:	8b 00                	mov    (%rax),%eax
  80350e:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  803511:	75 23                	jne    803536 <ipc_find_env+0x5d>
			return envs[i].env_id;
  803513:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  80351a:	00 00 00 
  80351d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803520:	48 98                	cltq   
  803522:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  803529:	48 01 d0             	add    %rdx,%rax
  80352c:	48 05 c8 00 00 00    	add    $0xc8,%rax
  803532:	8b 00                	mov    (%rax),%eax
  803534:	eb 12                	jmp    803548 <ipc_find_env+0x6f>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++) {
  803536:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80353a:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  803541:	7e aa                	jle    8034ed <ipc_find_env+0x14>
		if (envs[i].env_type == type)
			return envs[i].env_id;
	}
	return 0;
  803543:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803548:	c9                   	leaveq 
  803549:	c3                   	retq   

000000000080354a <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

uint64_t
fd2num(struct Fd *fd)
{
  80354a:	55                   	push   %rbp
  80354b:	48 89 e5             	mov    %rsp,%rbp
  80354e:	48 83 ec 08          	sub    $0x8,%rsp
  803552:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  803556:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80355a:	48 b8 00 00 00 30 ff 	movabs $0xffffffff30000000,%rax
  803561:	ff ff ff 
  803564:	48 01 d0             	add    %rdx,%rax
  803567:	48 c1 e8 0c          	shr    $0xc,%rax
}
  80356b:	c9                   	leaveq 
  80356c:	c3                   	retq   

000000000080356d <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80356d:	55                   	push   %rbp
  80356e:	48 89 e5             	mov    %rsp,%rbp
  803571:	48 83 ec 08          	sub    $0x8,%rsp
  803575:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return INDEX2DATA(fd2num(fd));
  803579:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80357d:	48 89 c7             	mov    %rax,%rdi
  803580:	48 b8 4a 35 80 00 00 	movabs $0x80354a,%rax
  803587:	00 00 00 
  80358a:	ff d0                	callq  *%rax
  80358c:	48 05 20 00 0d 00    	add    $0xd0020,%rax
  803592:	48 c1 e0 0c          	shl    $0xc,%rax
}
  803596:	c9                   	leaveq 
  803597:	c3                   	retq   

0000000000803598 <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  803598:	55                   	push   %rbp
  803599:	48 89 e5             	mov    %rsp,%rbp
  80359c:	48 83 ec 18          	sub    $0x18,%rsp
  8035a0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  8035a4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8035ab:	eb 6b                	jmp    803618 <fd_alloc+0x80>
		fd = INDEX2FD(i);
  8035ad:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8035b0:	48 98                	cltq   
  8035b2:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  8035b8:	48 c1 e0 0c          	shl    $0xc,%rax
  8035bc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if ((uvpd[VPD(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  8035c0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8035c4:	48 c1 e8 15          	shr    $0x15,%rax
  8035c8:	48 89 c2             	mov    %rax,%rdx
  8035cb:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  8035d2:	01 00 00 
  8035d5:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8035d9:	83 e0 01             	and    $0x1,%eax
  8035dc:	48 85 c0             	test   %rax,%rax
  8035df:	74 21                	je     803602 <fd_alloc+0x6a>
  8035e1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8035e5:	48 c1 e8 0c          	shr    $0xc,%rax
  8035e9:	48 89 c2             	mov    %rax,%rdx
  8035ec:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8035f3:	01 00 00 
  8035f6:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8035fa:	83 e0 01             	and    $0x1,%eax
  8035fd:	48 85 c0             	test   %rax,%rax
  803600:	75 12                	jne    803614 <fd_alloc+0x7c>
			*fd_store = fd;
  803602:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803606:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80360a:	48 89 10             	mov    %rdx,(%rax)
			return 0;
  80360d:	b8 00 00 00 00       	mov    $0x0,%eax
  803612:	eb 1a                	jmp    80362e <fd_alloc+0x96>
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  803614:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  803618:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  80361c:	7e 8f                	jle    8035ad <fd_alloc+0x15>
		if ((uvpd[VPD(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  80361e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803622:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	return -E_MAX_OPEN;
  803629:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  80362e:	c9                   	leaveq 
  80362f:	c3                   	retq   

0000000000803630 <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  803630:	55                   	push   %rbp
  803631:	48 89 e5             	mov    %rsp,%rbp
  803634:	48 83 ec 20          	sub    $0x20,%rsp
  803638:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80363b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  80363f:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  803643:	78 06                	js     80364b <fd_lookup+0x1b>
  803645:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  803649:	7e 07                	jle    803652 <fd_lookup+0x22>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  80364b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803650:	eb 6c                	jmp    8036be <fd_lookup+0x8e>
	}
	fd = INDEX2FD(fdnum);
  803652:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803655:	48 98                	cltq   
  803657:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  80365d:	48 c1 e0 0c          	shl    $0xc,%rax
  803661:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!(uvpd[VPD(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  803665:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803669:	48 c1 e8 15          	shr    $0x15,%rax
  80366d:	48 89 c2             	mov    %rax,%rdx
  803670:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  803677:	01 00 00 
  80367a:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80367e:	83 e0 01             	and    $0x1,%eax
  803681:	48 85 c0             	test   %rax,%rax
  803684:	74 21                	je     8036a7 <fd_lookup+0x77>
  803686:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80368a:	48 c1 e8 0c          	shr    $0xc,%rax
  80368e:	48 89 c2             	mov    %rax,%rdx
  803691:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803698:	01 00 00 
  80369b:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80369f:	83 e0 01             	and    $0x1,%eax
  8036a2:	48 85 c0             	test   %rax,%rax
  8036a5:	75 07                	jne    8036ae <fd_lookup+0x7e>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  8036a7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8036ac:	eb 10                	jmp    8036be <fd_lookup+0x8e>
	}
	*fd_store = fd;
  8036ae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8036b2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8036b6:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  8036b9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8036be:	c9                   	leaveq 
  8036bf:	c3                   	retq   

00000000008036c0 <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  8036c0:	55                   	push   %rbp
  8036c1:	48 89 e5             	mov    %rsp,%rbp
  8036c4:	48 83 ec 30          	sub    $0x30,%rsp
  8036c8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8036cc:	89 f0                	mov    %esi,%eax
  8036ce:	88 45 d4             	mov    %al,-0x2c(%rbp)
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  8036d1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8036d5:	48 89 c7             	mov    %rax,%rdi
  8036d8:	48 b8 4a 35 80 00 00 	movabs $0x80354a,%rax
  8036df:	00 00 00 
  8036e2:	ff d0                	callq  *%rax
  8036e4:	89 c2                	mov    %eax,%edx
  8036e6:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8036ea:	48 89 c6             	mov    %rax,%rsi
  8036ed:	89 d7                	mov    %edx,%edi
  8036ef:	48 b8 30 36 80 00 00 	movabs $0x803630,%rax
  8036f6:	00 00 00 
  8036f9:	ff d0                	callq  *%rax
  8036fb:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8036fe:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803702:	78 0a                	js     80370e <fd_close+0x4e>
	    || fd != fd2)
  803704:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803708:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80370c:	74 12                	je     803720 <fd_close+0x60>
		return (must_exist ? r : 0);
  80370e:	80 7d d4 00          	cmpb   $0x0,-0x2c(%rbp)
  803712:	74 05                	je     803719 <fd_close+0x59>
  803714:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803717:	eb 70                	jmp    803789 <fd_close+0xc9>
  803719:	b8 00 00 00 00       	mov    $0x0,%eax
  80371e:	eb 69                	jmp    803789 <fd_close+0xc9>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  803720:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803724:	8b 00                	mov    (%rax),%eax
  803726:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  80372a:	48 89 d6             	mov    %rdx,%rsi
  80372d:	89 c7                	mov    %eax,%edi
  80372f:	48 b8 8b 37 80 00 00 	movabs $0x80378b,%rax
  803736:	00 00 00 
  803739:	ff d0                	callq  *%rax
  80373b:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80373e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803742:	78 2a                	js     80376e <fd_close+0xae>
		if (dev->dev_close)
  803744:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803748:	48 8b 40 20          	mov    0x20(%rax),%rax
  80374c:	48 85 c0             	test   %rax,%rax
  80374f:	74 16                	je     803767 <fd_close+0xa7>
			r = (*dev->dev_close)(fd);
  803751:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803755:	48 8b 40 20          	mov    0x20(%rax),%rax
  803759:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80375d:	48 89 d7             	mov    %rdx,%rdi
  803760:	ff d0                	callq  *%rax
  803762:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803765:	eb 07                	jmp    80376e <fd_close+0xae>
		else
			r = 0;
  803767:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  80376e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803772:	48 89 c6             	mov    %rax,%rsi
  803775:	bf 00 00 00 00       	mov    $0x0,%edi
  80377a:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  803781:	00 00 00 
  803784:	ff d0                	callq  *%rax
	return r;
  803786:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  803789:	c9                   	leaveq 
  80378a:	c3                   	retq   

000000000080378b <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  80378b:	55                   	push   %rbp
  80378c:	48 89 e5             	mov    %rsp,%rbp
  80378f:	48 83 ec 20          	sub    $0x20,%rsp
  803793:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803796:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int i;
	for (i = 0; devtab[i]; i++)
  80379a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8037a1:	eb 41                	jmp    8037e4 <dev_lookup+0x59>
		if (devtab[i]->dev_id == dev_id) {
  8037a3:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  8037aa:	00 00 00 
  8037ad:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8037b0:	48 63 d2             	movslq %edx,%rdx
  8037b3:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8037b7:	8b 00                	mov    (%rax),%eax
  8037b9:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8037bc:	75 22                	jne    8037e0 <dev_lookup+0x55>
			*dev = devtab[i];
  8037be:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  8037c5:	00 00 00 
  8037c8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8037cb:	48 63 d2             	movslq %edx,%rdx
  8037ce:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8037d2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8037d6:	48 89 10             	mov    %rdx,(%rax)
			return 0;
  8037d9:	b8 00 00 00 00       	mov    $0x0,%eax
  8037de:	eb 60                	jmp    803840 <dev_lookup+0xb5>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  8037e0:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8037e4:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  8037eb:	00 00 00 
  8037ee:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8037f1:	48 63 d2             	movslq %edx,%rdx
  8037f4:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8037f8:	48 85 c0             	test   %rax,%rax
  8037fb:	75 a6                	jne    8037a3 <dev_lookup+0x18>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  8037fd:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803804:	00 00 00 
  803807:	48 8b 00             	mov    (%rax),%rax
  80380a:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803810:	8b 55 ec             	mov    -0x14(%rbp),%edx
  803813:	89 c6                	mov    %eax,%esi
  803815:	48 bf 98 16 82 00 00 	movabs $0x821698,%rdi
  80381c:	00 00 00 
  80381f:	b8 00 00 00 00       	mov    $0x0,%eax
  803824:	48 b9 32 13 80 00 00 	movabs $0x801332,%rcx
  80382b:	00 00 00 
  80382e:	ff d1                	callq  *%rcx
	*dev = 0;
  803830:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803834:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	return -E_INVAL;
  80383b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  803840:	c9                   	leaveq 
  803841:	c3                   	retq   

0000000000803842 <close>:

int
close(int fdnum)
{
  803842:	55                   	push   %rbp
  803843:	48 89 e5             	mov    %rsp,%rbp
  803846:	48 83 ec 20          	sub    $0x20,%rsp
  80384a:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80384d:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803851:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803854:	48 89 d6             	mov    %rdx,%rsi
  803857:	89 c7                	mov    %eax,%edi
  803859:	48 b8 30 36 80 00 00 	movabs $0x803630,%rax
  803860:	00 00 00 
  803863:	ff d0                	callq  *%rax
  803865:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803868:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80386c:	79 05                	jns    803873 <close+0x31>
		return r;
  80386e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803871:	eb 18                	jmp    80388b <close+0x49>
	else
		return fd_close(fd, 1);
  803873:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803877:	be 01 00 00 00       	mov    $0x1,%esi
  80387c:	48 89 c7             	mov    %rax,%rdi
  80387f:	48 b8 c0 36 80 00 00 	movabs $0x8036c0,%rax
  803886:	00 00 00 
  803889:	ff d0                	callq  *%rax
}
  80388b:	c9                   	leaveq 
  80388c:	c3                   	retq   

000000000080388d <close_all>:

void
close_all(void)
{
  80388d:	55                   	push   %rbp
  80388e:	48 89 e5             	mov    %rsp,%rbp
  803891:	48 83 ec 10          	sub    $0x10,%rsp
	int i;
	for (i = 0; i < MAXFD; i++)
  803895:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80389c:	eb 15                	jmp    8038b3 <close_all+0x26>
		close(i);
  80389e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8038a1:	89 c7                	mov    %eax,%edi
  8038a3:	48 b8 42 38 80 00 00 	movabs $0x803842,%rax
  8038aa:	00 00 00 
  8038ad:	ff d0                	callq  *%rax

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  8038af:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8038b3:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  8038b7:	7e e5                	jle    80389e <close_all+0x11>
		close(i);
}
  8038b9:	90                   	nop
  8038ba:	c9                   	leaveq 
  8038bb:	c3                   	retq   

00000000008038bc <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  8038bc:	55                   	push   %rbp
  8038bd:	48 89 e5             	mov    %rsp,%rbp
  8038c0:	48 83 ec 40          	sub    $0x40,%rsp
  8038c4:	89 7d cc             	mov    %edi,-0x34(%rbp)
  8038c7:	89 75 c8             	mov    %esi,-0x38(%rbp)
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  8038ca:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  8038ce:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8038d1:	48 89 d6             	mov    %rdx,%rsi
  8038d4:	89 c7                	mov    %eax,%edi
  8038d6:	48 b8 30 36 80 00 00 	movabs $0x803630,%rax
  8038dd:	00 00 00 
  8038e0:	ff d0                	callq  *%rax
  8038e2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8038e5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8038e9:	79 08                	jns    8038f3 <dup+0x37>
		return r;
  8038eb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8038ee:	e9 70 01 00 00       	jmpq   803a63 <dup+0x1a7>
	close(newfdnum);
  8038f3:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8038f6:	89 c7                	mov    %eax,%edi
  8038f8:	48 b8 42 38 80 00 00 	movabs $0x803842,%rax
  8038ff:	00 00 00 
  803902:	ff d0                	callq  *%rax

	newfd = INDEX2FD(newfdnum);
  803904:	8b 45 c8             	mov    -0x38(%rbp),%eax
  803907:	48 98                	cltq   
  803909:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  80390f:	48 c1 e0 0c          	shl    $0xc,%rax
  803913:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	ova = fd2data(oldfd);
  803917:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80391b:	48 89 c7             	mov    %rax,%rdi
  80391e:	48 b8 6d 35 80 00 00 	movabs $0x80356d,%rax
  803925:	00 00 00 
  803928:	ff d0                	callq  *%rax
  80392a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	nva = fd2data(newfd);
  80392e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803932:	48 89 c7             	mov    %rax,%rdi
  803935:	48 b8 6d 35 80 00 00 	movabs $0x80356d,%rax
  80393c:	00 00 00 
  80393f:	ff d0                	callq  *%rax
  803941:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	if ((uvpd[VPD(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  803945:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803949:	48 c1 e8 15          	shr    $0x15,%rax
  80394d:	48 89 c2             	mov    %rax,%rdx
  803950:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  803957:	01 00 00 
  80395a:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80395e:	83 e0 01             	and    $0x1,%eax
  803961:	48 85 c0             	test   %rax,%rax
  803964:	74 71                	je     8039d7 <dup+0x11b>
  803966:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80396a:	48 c1 e8 0c          	shr    $0xc,%rax
  80396e:	48 89 c2             	mov    %rax,%rdx
  803971:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803978:	01 00 00 
  80397b:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80397f:	83 e0 01             	and    $0x1,%eax
  803982:	48 85 c0             	test   %rax,%rax
  803985:	74 50                	je     8039d7 <dup+0x11b>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  803987:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80398b:	48 c1 e8 0c          	shr    $0xc,%rax
  80398f:	48 89 c2             	mov    %rax,%rdx
  803992:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803999:	01 00 00 
  80399c:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8039a0:	25 07 0e 00 00       	and    $0xe07,%eax
  8039a5:	89 c1                	mov    %eax,%ecx
  8039a7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8039ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8039af:	41 89 c8             	mov    %ecx,%r8d
  8039b2:	48 89 d1             	mov    %rdx,%rcx
  8039b5:	ba 00 00 00 00       	mov    $0x0,%edx
  8039ba:	48 89 c6             	mov    %rax,%rsi
  8039bd:	bf 00 00 00 00       	mov    $0x0,%edi
  8039c2:	48 b8 4a 28 80 00 00 	movabs $0x80284a,%rax
  8039c9:	00 00 00 
  8039cc:	ff d0                	callq  *%rax
  8039ce:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8039d1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8039d5:	78 55                	js     803a2c <dup+0x170>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  8039d7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8039db:	48 c1 e8 0c          	shr    $0xc,%rax
  8039df:	48 89 c2             	mov    %rax,%rdx
  8039e2:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8039e9:	01 00 00 
  8039ec:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8039f0:	25 07 0e 00 00       	and    $0xe07,%eax
  8039f5:	89 c1                	mov    %eax,%ecx
  8039f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8039fb:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8039ff:	41 89 c8             	mov    %ecx,%r8d
  803a02:	48 89 d1             	mov    %rdx,%rcx
  803a05:	ba 00 00 00 00       	mov    $0x0,%edx
  803a0a:	48 89 c6             	mov    %rax,%rsi
  803a0d:	bf 00 00 00 00       	mov    $0x0,%edi
  803a12:	48 b8 4a 28 80 00 00 	movabs $0x80284a,%rax
  803a19:	00 00 00 
  803a1c:	ff d0                	callq  *%rax
  803a1e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803a21:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803a25:	78 08                	js     803a2f <dup+0x173>
		goto err;

	return newfdnum;
  803a27:	8b 45 c8             	mov    -0x38(%rbp),%eax
  803a2a:	eb 37                	jmp    803a63 <dup+0x1a7>
	ova = fd2data(oldfd);
	nva = fd2data(newfd);

	if ((uvpd[VPD(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
  803a2c:	90                   	nop
  803a2d:	eb 01                	jmp    803a30 <dup+0x174>
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
		goto err;
  803a2f:	90                   	nop

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  803a30:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803a34:	48 89 c6             	mov    %rax,%rsi
  803a37:	bf 00 00 00 00       	mov    $0x0,%edi
  803a3c:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  803a43:	00 00 00 
  803a46:	ff d0                	callq  *%rax
	sys_page_unmap(0, nva);
  803a48:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803a4c:	48 89 c6             	mov    %rax,%rsi
  803a4f:	bf 00 00 00 00       	mov    $0x0,%edi
  803a54:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  803a5b:	00 00 00 
  803a5e:	ff d0                	callq  *%rax
	return r;
  803a60:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  803a63:	c9                   	leaveq 
  803a64:	c3                   	retq   

0000000000803a65 <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  803a65:	55                   	push   %rbp
  803a66:	48 89 e5             	mov    %rsp,%rbp
  803a69:	48 83 ec 40          	sub    $0x40,%rsp
  803a6d:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803a70:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  803a74:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  803a78:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803a7c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803a7f:	48 89 d6             	mov    %rdx,%rsi
  803a82:	89 c7                	mov    %eax,%edi
  803a84:	48 b8 30 36 80 00 00 	movabs $0x803630,%rax
  803a8b:	00 00 00 
  803a8e:	ff d0                	callq  *%rax
  803a90:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803a93:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803a97:	78 24                	js     803abd <read+0x58>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803a99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803a9d:	8b 00                	mov    (%rax),%eax
  803a9f:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803aa3:	48 89 d6             	mov    %rdx,%rsi
  803aa6:	89 c7                	mov    %eax,%edi
  803aa8:	48 b8 8b 37 80 00 00 	movabs $0x80378b,%rax
  803aaf:	00 00 00 
  803ab2:	ff d0                	callq  *%rax
  803ab4:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803ab7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803abb:	79 05                	jns    803ac2 <read+0x5d>
		return r;
  803abd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803ac0:	eb 76                	jmp    803b38 <read+0xd3>
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  803ac2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803ac6:	8b 40 08             	mov    0x8(%rax),%eax
  803ac9:	83 e0 03             	and    $0x3,%eax
  803acc:	83 f8 01             	cmp    $0x1,%eax
  803acf:	75 3a                	jne    803b0b <read+0xa6>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  803ad1:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803ad8:	00 00 00 
  803adb:	48 8b 00             	mov    (%rax),%rax
  803ade:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803ae4:	8b 55 dc             	mov    -0x24(%rbp),%edx
  803ae7:	89 c6                	mov    %eax,%esi
  803ae9:	48 bf b7 16 82 00 00 	movabs $0x8216b7,%rdi
  803af0:	00 00 00 
  803af3:	b8 00 00 00 00       	mov    $0x0,%eax
  803af8:	48 b9 32 13 80 00 00 	movabs $0x801332,%rcx
  803aff:	00 00 00 
  803b02:	ff d1                	callq  *%rcx
		return -E_INVAL;
  803b04:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803b09:	eb 2d                	jmp    803b38 <read+0xd3>
	}
	if (!dev->dev_read)
  803b0b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803b0f:	48 8b 40 10          	mov    0x10(%rax),%rax
  803b13:	48 85 c0             	test   %rax,%rax
  803b16:	75 07                	jne    803b1f <read+0xba>
		return -E_NOT_SUPP;
  803b18:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803b1d:	eb 19                	jmp    803b38 <read+0xd3>
	return (*dev->dev_read)(fd, buf, n);
  803b1f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803b23:	48 8b 40 10          	mov    0x10(%rax),%rax
  803b27:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  803b2b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  803b2f:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  803b33:	48 89 cf             	mov    %rcx,%rdi
  803b36:	ff d0                	callq  *%rax
}
  803b38:	c9                   	leaveq 
  803b39:	c3                   	retq   

0000000000803b3a <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  803b3a:	55                   	push   %rbp
  803b3b:	48 89 e5             	mov    %rsp,%rbp
  803b3e:	48 83 ec 30          	sub    $0x30,%rsp
  803b42:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803b45:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803b49:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  803b4d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  803b54:	eb 47                	jmp    803b9d <readn+0x63>
		m = read(fdnum, (char*)buf + tot, n - tot);
  803b56:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803b59:	48 98                	cltq   
  803b5b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  803b5f:	48 29 c2             	sub    %rax,%rdx
  803b62:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803b65:	48 63 c8             	movslq %eax,%rcx
  803b68:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803b6c:	48 01 c1             	add    %rax,%rcx
  803b6f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803b72:	48 89 ce             	mov    %rcx,%rsi
  803b75:	89 c7                	mov    %eax,%edi
  803b77:	48 b8 65 3a 80 00 00 	movabs $0x803a65,%rax
  803b7e:	00 00 00 
  803b81:	ff d0                	callq  *%rax
  803b83:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (m < 0)
  803b86:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  803b8a:	79 05                	jns    803b91 <readn+0x57>
			return m;
  803b8c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803b8f:	eb 1d                	jmp    803bae <readn+0x74>
		if (m == 0)
  803b91:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  803b95:	74 13                	je     803baa <readn+0x70>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  803b97:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803b9a:	01 45 fc             	add    %eax,-0x4(%rbp)
  803b9d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803ba0:	48 98                	cltq   
  803ba2:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  803ba6:	72 ae                	jb     803b56 <readn+0x1c>
  803ba8:	eb 01                	jmp    803bab <readn+0x71>
		m = read(fdnum, (char*)buf + tot, n - tot);
		if (m < 0)
			return m;
		if (m == 0)
			break;
  803baa:	90                   	nop
	}
	return tot;
  803bab:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  803bae:	c9                   	leaveq 
  803baf:	c3                   	retq   

0000000000803bb0 <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  803bb0:	55                   	push   %rbp
  803bb1:	48 89 e5             	mov    %rsp,%rbp
  803bb4:	48 83 ec 40          	sub    $0x40,%rsp
  803bb8:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803bbb:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  803bbf:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  803bc3:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803bc7:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803bca:	48 89 d6             	mov    %rdx,%rsi
  803bcd:	89 c7                	mov    %eax,%edi
  803bcf:	48 b8 30 36 80 00 00 	movabs $0x803630,%rax
  803bd6:	00 00 00 
  803bd9:	ff d0                	callq  *%rax
  803bdb:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803bde:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803be2:	78 24                	js     803c08 <write+0x58>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803be4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803be8:	8b 00                	mov    (%rax),%eax
  803bea:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803bee:	48 89 d6             	mov    %rdx,%rsi
  803bf1:	89 c7                	mov    %eax,%edi
  803bf3:	48 b8 8b 37 80 00 00 	movabs $0x80378b,%rax
  803bfa:	00 00 00 
  803bfd:	ff d0                	callq  *%rax
  803bff:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803c02:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803c06:	79 05                	jns    803c0d <write+0x5d>
		return r;
  803c08:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803c0b:	eb 75                	jmp    803c82 <write+0xd2>
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  803c0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803c11:	8b 40 08             	mov    0x8(%rax),%eax
  803c14:	83 e0 03             	and    $0x3,%eax
  803c17:	85 c0                	test   %eax,%eax
  803c19:	75 3a                	jne    803c55 <write+0xa5>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  803c1b:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803c22:	00 00 00 
  803c25:	48 8b 00             	mov    (%rax),%rax
  803c28:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803c2e:	8b 55 dc             	mov    -0x24(%rbp),%edx
  803c31:	89 c6                	mov    %eax,%esi
  803c33:	48 bf d3 16 82 00 00 	movabs $0x8216d3,%rdi
  803c3a:	00 00 00 
  803c3d:	b8 00 00 00 00       	mov    $0x0,%eax
  803c42:	48 b9 32 13 80 00 00 	movabs $0x801332,%rcx
  803c49:	00 00 00 
  803c4c:	ff d1                	callq  *%rcx
		return -E_INVAL;
  803c4e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803c53:	eb 2d                	jmp    803c82 <write+0xd2>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  803c55:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803c59:	48 8b 40 18          	mov    0x18(%rax),%rax
  803c5d:	48 85 c0             	test   %rax,%rax
  803c60:	75 07                	jne    803c69 <write+0xb9>
		return -E_NOT_SUPP;
  803c62:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803c67:	eb 19                	jmp    803c82 <write+0xd2>
	return (*dev->dev_write)(fd, buf, n);
  803c69:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803c6d:	48 8b 40 18          	mov    0x18(%rax),%rax
  803c71:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  803c75:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  803c79:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  803c7d:	48 89 cf             	mov    %rcx,%rdi
  803c80:	ff d0                	callq  *%rax
}
  803c82:	c9                   	leaveq 
  803c83:	c3                   	retq   

0000000000803c84 <seek>:

int
seek(int fdnum, off_t offset)
{
  803c84:	55                   	push   %rbp
  803c85:	48 89 e5             	mov    %rsp,%rbp
  803c88:	48 83 ec 18          	sub    $0x18,%rsp
  803c8c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803c8f:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  803c92:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803c96:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803c99:	48 89 d6             	mov    %rdx,%rsi
  803c9c:	89 c7                	mov    %eax,%edi
  803c9e:	48 b8 30 36 80 00 00 	movabs $0x803630,%rax
  803ca5:	00 00 00 
  803ca8:	ff d0                	callq  *%rax
  803caa:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803cad:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803cb1:	79 05                	jns    803cb8 <seek+0x34>
		return r;
  803cb3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803cb6:	eb 0f                	jmp    803cc7 <seek+0x43>
	fd->fd_offset = offset;
  803cb8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803cbc:	8b 55 e8             	mov    -0x18(%rbp),%edx
  803cbf:	89 50 04             	mov    %edx,0x4(%rax)
	return 0;
  803cc2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803cc7:	c9                   	leaveq 
  803cc8:	c3                   	retq   

0000000000803cc9 <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  803cc9:	55                   	push   %rbp
  803cca:	48 89 e5             	mov    %rsp,%rbp
  803ccd:	48 83 ec 30          	sub    $0x30,%rsp
  803cd1:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803cd4:	89 75 d8             	mov    %esi,-0x28(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  803cd7:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803cdb:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803cde:	48 89 d6             	mov    %rdx,%rsi
  803ce1:	89 c7                	mov    %eax,%edi
  803ce3:	48 b8 30 36 80 00 00 	movabs $0x803630,%rax
  803cea:	00 00 00 
  803ced:	ff d0                	callq  *%rax
  803cef:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803cf2:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803cf6:	78 24                	js     803d1c <ftruncate+0x53>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803cf8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803cfc:	8b 00                	mov    (%rax),%eax
  803cfe:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803d02:	48 89 d6             	mov    %rdx,%rsi
  803d05:	89 c7                	mov    %eax,%edi
  803d07:	48 b8 8b 37 80 00 00 	movabs $0x80378b,%rax
  803d0e:	00 00 00 
  803d11:	ff d0                	callq  *%rax
  803d13:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803d16:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803d1a:	79 05                	jns    803d21 <ftruncate+0x58>
		return r;
  803d1c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803d1f:	eb 72                	jmp    803d93 <ftruncate+0xca>
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  803d21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803d25:	8b 40 08             	mov    0x8(%rax),%eax
  803d28:	83 e0 03             	and    $0x3,%eax
  803d2b:	85 c0                	test   %eax,%eax
  803d2d:	75 3a                	jne    803d69 <ftruncate+0xa0>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  803d2f:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803d36:	00 00 00 
  803d39:	48 8b 00             	mov    (%rax),%rax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  803d3c:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803d42:	8b 55 dc             	mov    -0x24(%rbp),%edx
  803d45:	89 c6                	mov    %eax,%esi
  803d47:	48 bf f0 16 82 00 00 	movabs $0x8216f0,%rdi
  803d4e:	00 00 00 
  803d51:	b8 00 00 00 00       	mov    $0x0,%eax
  803d56:	48 b9 32 13 80 00 00 	movabs $0x801332,%rcx
  803d5d:	00 00 00 
  803d60:	ff d1                	callq  *%rcx
			thisenv->env_id, fdnum);
		return -E_INVAL;
  803d62:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803d67:	eb 2a                	jmp    803d93 <ftruncate+0xca>
	}
	if (!dev->dev_trunc)
  803d69:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803d6d:	48 8b 40 30          	mov    0x30(%rax),%rax
  803d71:	48 85 c0             	test   %rax,%rax
  803d74:	75 07                	jne    803d7d <ftruncate+0xb4>
		return -E_NOT_SUPP;
  803d76:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803d7b:	eb 16                	jmp    803d93 <ftruncate+0xca>
	return (*dev->dev_trunc)(fd, newsize);
  803d7d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803d81:	48 8b 40 30          	mov    0x30(%rax),%rax
  803d85:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  803d89:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  803d8c:	89 ce                	mov    %ecx,%esi
  803d8e:	48 89 d7             	mov    %rdx,%rdi
  803d91:	ff d0                	callq  *%rax
}
  803d93:	c9                   	leaveq 
  803d94:	c3                   	retq   

0000000000803d95 <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  803d95:	55                   	push   %rbp
  803d96:	48 89 e5             	mov    %rsp,%rbp
  803d99:	48 83 ec 30          	sub    $0x30,%rsp
  803d9d:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803da0:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  803da4:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803da8:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803dab:	48 89 d6             	mov    %rdx,%rsi
  803dae:	89 c7                	mov    %eax,%edi
  803db0:	48 b8 30 36 80 00 00 	movabs $0x803630,%rax
  803db7:	00 00 00 
  803dba:	ff d0                	callq  *%rax
  803dbc:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803dbf:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803dc3:	78 24                	js     803de9 <fstat+0x54>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803dc5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803dc9:	8b 00                	mov    (%rax),%eax
  803dcb:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803dcf:	48 89 d6             	mov    %rdx,%rsi
  803dd2:	89 c7                	mov    %eax,%edi
  803dd4:	48 b8 8b 37 80 00 00 	movabs $0x80378b,%rax
  803ddb:	00 00 00 
  803dde:	ff d0                	callq  *%rax
  803de0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803de3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803de7:	79 05                	jns    803dee <fstat+0x59>
		return r;
  803de9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803dec:	eb 5e                	jmp    803e4c <fstat+0xb7>
	if (!dev->dev_stat)
  803dee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803df2:	48 8b 40 28          	mov    0x28(%rax),%rax
  803df6:	48 85 c0             	test   %rax,%rax
  803df9:	75 07                	jne    803e02 <fstat+0x6d>
		return -E_NOT_SUPP;
  803dfb:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803e00:	eb 4a                	jmp    803e4c <fstat+0xb7>
	stat->st_name[0] = 0;
  803e02:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803e06:	c6 00 00             	movb   $0x0,(%rax)
	stat->st_size = 0;
  803e09:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803e0d:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%rax)
  803e14:	00 00 00 
	stat->st_isdir = 0;
  803e17:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803e1b:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%rax)
  803e22:	00 00 00 
	stat->st_dev = dev;
  803e25:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  803e29:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803e2d:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
	return (*dev->dev_stat)(fd, stat);
  803e34:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803e38:	48 8b 40 28          	mov    0x28(%rax),%rax
  803e3c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  803e40:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  803e44:	48 89 ce             	mov    %rcx,%rsi
  803e47:	48 89 d7             	mov    %rdx,%rdi
  803e4a:	ff d0                	callq  *%rax
}
  803e4c:	c9                   	leaveq 
  803e4d:	c3                   	retq   

0000000000803e4e <stat>:

int
stat(const char *path, struct Stat *stat)
{
  803e4e:	55                   	push   %rbp
  803e4f:	48 89 e5             	mov    %rsp,%rbp
  803e52:	48 83 ec 20          	sub    $0x20,%rsp
  803e56:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803e5a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  803e5e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803e62:	be 00 00 00 00       	mov    $0x0,%esi
  803e67:	48 89 c7             	mov    %rax,%rdi
  803e6a:	48 b8 3e 3f 80 00 00 	movabs $0x803f3e,%rax
  803e71:	00 00 00 
  803e74:	ff d0                	callq  *%rax
  803e76:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803e79:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803e7d:	79 05                	jns    803e84 <stat+0x36>
		return fd;
  803e7f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803e82:	eb 2f                	jmp    803eb3 <stat+0x65>
	r = fstat(fd, stat);
  803e84:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  803e88:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803e8b:	48 89 d6             	mov    %rdx,%rsi
  803e8e:	89 c7                	mov    %eax,%edi
  803e90:	48 b8 95 3d 80 00 00 	movabs $0x803d95,%rax
  803e97:	00 00 00 
  803e9a:	ff d0                	callq  *%rax
  803e9c:	89 45 f8             	mov    %eax,-0x8(%rbp)
	close(fd);
  803e9f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803ea2:	89 c7                	mov    %eax,%edi
  803ea4:	48 b8 42 38 80 00 00 	movabs $0x803842,%rax
  803eab:	00 00 00 
  803eae:	ff d0                	callq  *%rax
	return r;
  803eb0:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  803eb3:	c9                   	leaveq 
  803eb4:	c3                   	retq   

0000000000803eb5 <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  803eb5:	55                   	push   %rbp
  803eb6:	48 89 e5             	mov    %rsp,%rbp
  803eb9:	48 83 ec 10          	sub    $0x10,%rsp
  803ebd:	89 7d fc             	mov    %edi,-0x4(%rbp)
  803ec0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	static envid_t fsenv;
	if (fsenv == 0)
  803ec4:	48 b8 84 90 82 00 00 	movabs $0x829084,%rax
  803ecb:	00 00 00 
  803ece:	8b 00                	mov    (%rax),%eax
  803ed0:	85 c0                	test   %eax,%eax
  803ed2:	75 1f                	jne    803ef3 <fsipc+0x3e>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  803ed4:	bf 01 00 00 00       	mov    $0x1,%edi
  803ed9:	48 b8 d9 34 80 00 00 	movabs $0x8034d9,%rax
  803ee0:	00 00 00 
  803ee3:	ff d0                	callq  *%rax
  803ee5:	89 c2                	mov    %eax,%edx
  803ee7:	48 b8 84 90 82 00 00 	movabs $0x829084,%rax
  803eee:	00 00 00 
  803ef1:	89 10                	mov    %edx,(%rax)
	//static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  803ef3:	48 b8 84 90 82 00 00 	movabs $0x829084,%rax
  803efa:	00 00 00 
  803efd:	8b 00                	mov    (%rax),%eax
  803eff:	8b 75 fc             	mov    -0x4(%rbp),%esi
  803f02:	b9 07 00 00 00       	mov    $0x7,%ecx
  803f07:	48 ba 00 80 b5 00 00 	movabs $0xb58000,%rdx
  803f0e:	00 00 00 
  803f11:	89 c7                	mov    %eax,%edi
  803f13:	48 b8 cd 32 80 00 00 	movabs $0x8032cd,%rax
  803f1a:	00 00 00 
  803f1d:	ff d0                	callq  *%rax
	return ipc_recv(NULL, dstva, NULL);
  803f1f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803f23:	ba 00 00 00 00       	mov    $0x0,%edx
  803f28:	48 89 c6             	mov    %rax,%rsi
  803f2b:	bf 00 00 00 00       	mov    $0x0,%edi
  803f30:	48 b8 0c 32 80 00 00 	movabs $0x80320c,%rax
  803f37:	00 00 00 
  803f3a:	ff d0                	callq  *%rax
}
  803f3c:	c9                   	leaveq 
  803f3d:	c3                   	retq   

0000000000803f3e <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  803f3e:	55                   	push   %rbp
  803f3f:	48 89 e5             	mov    %rsp,%rbp
  803f42:	48 83 ec 20          	sub    $0x20,%rsp
  803f46:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803f4a:	89 75 e4             	mov    %esi,-0x1c(%rbp)


	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
  803f4d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803f51:	48 89 c7             	mov    %rax,%rdi
  803f54:	48 b8 56 1e 80 00 00 	movabs $0x801e56,%rax
  803f5b:	00 00 00 
  803f5e:	ff d0                	callq  *%rax
  803f60:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  803f65:	7e 0a                	jle    803f71 <open+0x33>
		return -E_BAD_PATH;
  803f67:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
  803f6c:	e9 a5 00 00 00       	jmpq   804016 <open+0xd8>

	if ((r = fd_alloc(&fd)) < 0)
  803f71:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  803f75:	48 89 c7             	mov    %rax,%rdi
  803f78:	48 b8 98 35 80 00 00 	movabs $0x803598,%rax
  803f7f:	00 00 00 
  803f82:	ff d0                	callq  *%rax
  803f84:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803f87:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803f8b:	79 08                	jns    803f95 <open+0x57>
		return r;
  803f8d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803f90:	e9 81 00 00 00       	jmpq   804016 <open+0xd8>

	strcpy(fsipcbuf.open.req_path, path);
  803f95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803f99:	48 89 c6             	mov    %rax,%rsi
  803f9c:	48 bf 00 80 b5 00 00 	movabs $0xb58000,%rdi
  803fa3:	00 00 00 
  803fa6:	48 b8 c2 1e 80 00 00 	movabs $0x801ec2,%rax
  803fad:	00 00 00 
  803fb0:	ff d0                	callq  *%rax
	fsipcbuf.open.req_omode = mode;
  803fb2:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803fb9:	00 00 00 
  803fbc:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  803fbf:	89 90 00 04 00 00    	mov    %edx,0x400(%rax)

	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  803fc5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803fc9:	48 89 c6             	mov    %rax,%rsi
  803fcc:	bf 01 00 00 00       	mov    $0x1,%edi
  803fd1:	48 b8 b5 3e 80 00 00 	movabs $0x803eb5,%rax
  803fd8:	00 00 00 
  803fdb:	ff d0                	callq  *%rax
  803fdd:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803fe0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803fe4:	79 1d                	jns    804003 <open+0xc5>
		fd_close(fd, 0);
  803fe6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803fea:	be 00 00 00 00       	mov    $0x0,%esi
  803fef:	48 89 c7             	mov    %rax,%rdi
  803ff2:	48 b8 c0 36 80 00 00 	movabs $0x8036c0,%rax
  803ff9:	00 00 00 
  803ffc:	ff d0                	callq  *%rax
		return r;
  803ffe:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804001:	eb 13                	jmp    804016 <open+0xd8>
	}

	return fd2num(fd);
  804003:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804007:	48 89 c7             	mov    %rax,%rdi
  80400a:	48 b8 4a 35 80 00 00 	movabs $0x80354a,%rax
  804011:	00 00 00 
  804014:	ff d0                	callq  *%rax

}
  804016:	c9                   	leaveq 
  804017:	c3                   	retq   

0000000000804018 <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  804018:	55                   	push   %rbp
  804019:	48 89 e5             	mov    %rsp,%rbp
  80401c:	48 83 ec 10          	sub    $0x10,%rsp
  804020:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  804024:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804028:	8b 50 0c             	mov    0xc(%rax),%edx
  80402b:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  804032:	00 00 00 
  804035:	89 10                	mov    %edx,(%rax)
	return fsipc(FSREQ_FLUSH, NULL);
  804037:	be 00 00 00 00       	mov    $0x0,%esi
  80403c:	bf 06 00 00 00       	mov    $0x6,%edi
  804041:	48 b8 b5 3e 80 00 00 	movabs $0x803eb5,%rax
  804048:	00 00 00 
  80404b:	ff d0                	callq  *%rax
}
  80404d:	c9                   	leaveq 
  80404e:	c3                   	retq   

000000000080404f <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  80404f:	55                   	push   %rbp
  804050:	48 89 e5             	mov    %rsp,%rbp
  804053:	48 83 ec 30          	sub    $0x30,%rsp
  804057:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80405b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80405f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// bytes read will be written back to fsipcbuf by the file
	// system server.

	int r;

	fsipcbuf.read.req_fileid = fd->fd_file.id;
  804063:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804067:	8b 50 0c             	mov    0xc(%rax),%edx
  80406a:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  804071:	00 00 00 
  804074:	89 10                	mov    %edx,(%rax)
	fsipcbuf.read.req_n = n;
  804076:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  80407d:	00 00 00 
  804080:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  804084:	48 89 50 08          	mov    %rdx,0x8(%rax)
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  804088:	be 00 00 00 00       	mov    $0x0,%esi
  80408d:	bf 03 00 00 00       	mov    $0x3,%edi
  804092:	48 b8 b5 3e 80 00 00 	movabs $0x803eb5,%rax
  804099:	00 00 00 
  80409c:	ff d0                	callq  *%rax
  80409e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8040a1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8040a5:	79 08                	jns    8040af <devfile_read+0x60>
		return r;
  8040a7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8040aa:	e9 a4 00 00 00       	jmpq   804153 <devfile_read+0x104>
	assert(r <= n);
  8040af:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8040b2:	48 98                	cltq   
  8040b4:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8040b8:	76 35                	jbe    8040ef <devfile_read+0xa0>
  8040ba:	48 b9 16 17 82 00 00 	movabs $0x821716,%rcx
  8040c1:	00 00 00 
  8040c4:	48 ba 1d 17 82 00 00 	movabs $0x82171d,%rdx
  8040cb:	00 00 00 
  8040ce:	be 86 00 00 00       	mov    $0x86,%esi
  8040d3:	48 bf 32 17 82 00 00 	movabs $0x821732,%rdi
  8040da:	00 00 00 
  8040dd:	b8 00 00 00 00       	mov    $0x0,%eax
  8040e2:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  8040e9:	00 00 00 
  8040ec:	41 ff d0             	callq  *%r8
	assert(r <= PGSIZE);
  8040ef:	81 7d fc 00 10 00 00 	cmpl   $0x1000,-0x4(%rbp)
  8040f6:	7e 35                	jle    80412d <devfile_read+0xde>
  8040f8:	48 b9 3d 17 82 00 00 	movabs $0x82173d,%rcx
  8040ff:	00 00 00 
  804102:	48 ba 1d 17 82 00 00 	movabs $0x82171d,%rdx
  804109:	00 00 00 
  80410c:	be 87 00 00 00       	mov    $0x87,%esi
  804111:	48 bf 32 17 82 00 00 	movabs $0x821732,%rdi
  804118:	00 00 00 
  80411b:	b8 00 00 00 00       	mov    $0x0,%eax
  804120:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  804127:	00 00 00 
  80412a:	41 ff d0             	callq  *%r8
	memmove(buf, &fsipcbuf, r);
  80412d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804130:	48 63 d0             	movslq %eax,%rdx
  804133:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804137:	48 be 00 80 b5 00 00 	movabs $0xb58000,%rsi
  80413e:	00 00 00 
  804141:	48 89 c7             	mov    %rax,%rdi
  804144:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  80414b:	00 00 00 
  80414e:	ff d0                	callq  *%rax
	return r;
  804150:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  804153:	c9                   	leaveq 
  804154:	c3                   	retq   

0000000000804155 <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  804155:	55                   	push   %rbp
  804156:	48 89 e5             	mov    %rsp,%rbp
  804159:	48 83 ec 40          	sub    $0x40,%rsp
  80415d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  804161:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  804165:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	// remember that write is always allowed to write *fewer*
	// bytes than requested.

	int r;

	n = MIN(n, sizeof(fsipcbuf.write.req_buf));
  804169:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80416d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  804171:	48 c7 45 f0 f4 0f 00 	movq   $0xff4,-0x10(%rbp)
  804178:	00 
  804179:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80417d:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  804181:	48 0f 46 45 f8       	cmovbe -0x8(%rbp),%rax
  804186:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	fsipcbuf.write.req_fileid = fd->fd_file.id;
  80418a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80418e:	8b 50 0c             	mov    0xc(%rax),%edx
  804191:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  804198:	00 00 00 
  80419b:	89 10                	mov    %edx,(%rax)
	fsipcbuf.write.req_n = n;
  80419d:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  8041a4:	00 00 00 
  8041a7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8041ab:	48 89 50 08          	mov    %rdx,0x8(%rax)
	memmove(fsipcbuf.write.req_buf, buf, n);
  8041af:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8041b3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8041b7:	48 89 c6             	mov    %rax,%rsi
  8041ba:	48 bf 10 80 b5 00 00 	movabs $0xb58010,%rdi
  8041c1:	00 00 00 
  8041c4:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  8041cb:	00 00 00 
  8041ce:	ff d0                	callq  *%rax
	if ((r = fsipc(FSREQ_WRITE, NULL)) < 0)
  8041d0:	be 00 00 00 00       	mov    $0x0,%esi
  8041d5:	bf 04 00 00 00       	mov    $0x4,%edi
  8041da:	48 b8 b5 3e 80 00 00 	movabs $0x803eb5,%rax
  8041e1:	00 00 00 
  8041e4:	ff d0                	callq  *%rax
  8041e6:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8041e9:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8041ed:	79 05                	jns    8041f4 <devfile_write+0x9f>
		return r;
  8041ef:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8041f2:	eb 43                	jmp    804237 <devfile_write+0xe2>
	assert(r <= n);
  8041f4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8041f7:	48 98                	cltq   
  8041f9:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8041fd:	76 35                	jbe    804234 <devfile_write+0xdf>
  8041ff:	48 b9 16 17 82 00 00 	movabs $0x821716,%rcx
  804206:	00 00 00 
  804209:	48 ba 1d 17 82 00 00 	movabs $0x82171d,%rdx
  804210:	00 00 00 
  804213:	be a2 00 00 00       	mov    $0xa2,%esi
  804218:	48 bf 32 17 82 00 00 	movabs $0x821732,%rdi
  80421f:	00 00 00 
  804222:	b8 00 00 00 00       	mov    $0x0,%eax
  804227:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  80422e:	00 00 00 
  804231:	41 ff d0             	callq  *%r8
	return r;
  804234:	8b 45 ec             	mov    -0x14(%rbp),%eax

}
  804237:	c9                   	leaveq 
  804238:	c3                   	retq   

0000000000804239 <devfile_stat>:

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  804239:	55                   	push   %rbp
  80423a:	48 89 e5             	mov    %rsp,%rbp
  80423d:	48 83 ec 20          	sub    $0x20,%rsp
  804241:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  804245:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  804249:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80424d:	8b 50 0c             	mov    0xc(%rax),%edx
  804250:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  804257:	00 00 00 
  80425a:	89 10                	mov    %edx,(%rax)
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  80425c:	be 00 00 00 00       	mov    $0x0,%esi
  804261:	bf 05 00 00 00       	mov    $0x5,%edi
  804266:	48 b8 b5 3e 80 00 00 	movabs $0x803eb5,%rax
  80426d:	00 00 00 
  804270:	ff d0                	callq  *%rax
  804272:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804275:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804279:	79 05                	jns    804280 <devfile_stat+0x47>
		return r;
  80427b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80427e:	eb 56                	jmp    8042d6 <devfile_stat+0x9d>
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  804280:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804284:	48 be 00 80 b5 00 00 	movabs $0xb58000,%rsi
  80428b:	00 00 00 
  80428e:	48 89 c7             	mov    %rax,%rdi
  804291:	48 b8 c2 1e 80 00 00 	movabs $0x801ec2,%rax
  804298:	00 00 00 
  80429b:	ff d0                	callq  *%rax
	st->st_size = fsipcbuf.statRet.ret_size;
  80429d:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  8042a4:	00 00 00 
  8042a7:	8b 90 80 00 00 00    	mov    0x80(%rax),%edx
  8042ad:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8042b1:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  8042b7:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  8042be:	00 00 00 
  8042c1:	8b 90 84 00 00 00    	mov    0x84(%rax),%edx
  8042c7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8042cb:	89 90 84 00 00 00    	mov    %edx,0x84(%rax)
	return 0;
  8042d1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8042d6:	c9                   	leaveq 
  8042d7:	c3                   	retq   

00000000008042d8 <devfile_trunc>:

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  8042d8:	55                   	push   %rbp
  8042d9:	48 89 e5             	mov    %rsp,%rbp
  8042dc:	48 83 ec 10          	sub    $0x10,%rsp
  8042e0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8042e4:	89 75 f4             	mov    %esi,-0xc(%rbp)
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  8042e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8042eb:	8b 50 0c             	mov    0xc(%rax),%edx
  8042ee:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  8042f5:	00 00 00 
  8042f8:	89 10                	mov    %edx,(%rax)
	fsipcbuf.set_size.req_size = newsize;
  8042fa:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  804301:	00 00 00 
  804304:	8b 55 f4             	mov    -0xc(%rbp),%edx
  804307:	89 50 04             	mov    %edx,0x4(%rax)
	return fsipc(FSREQ_SET_SIZE, NULL);
  80430a:	be 00 00 00 00       	mov    $0x0,%esi
  80430f:	bf 02 00 00 00       	mov    $0x2,%edi
  804314:	48 b8 b5 3e 80 00 00 	movabs $0x803eb5,%rax
  80431b:	00 00 00 
  80431e:	ff d0                	callq  *%rax
}
  804320:	c9                   	leaveq 
  804321:	c3                   	retq   

0000000000804322 <remove>:

// Delete a file
int
remove(const char *path)
{
  804322:	55                   	push   %rbp
  804323:	48 89 e5             	mov    %rsp,%rbp
  804326:	48 83 ec 10          	sub    $0x10,%rsp
  80432a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (strlen(path) >= MAXPATHLEN)
  80432e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804332:	48 89 c7             	mov    %rax,%rdi
  804335:	48 b8 56 1e 80 00 00 	movabs $0x801e56,%rax
  80433c:	00 00 00 
  80433f:	ff d0                	callq  *%rax
  804341:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  804346:	7e 07                	jle    80434f <remove+0x2d>
		return -E_BAD_PATH;
  804348:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
  80434d:	eb 33                	jmp    804382 <remove+0x60>
	strcpy(fsipcbuf.remove.req_path, path);
  80434f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804353:	48 89 c6             	mov    %rax,%rsi
  804356:	48 bf 00 80 b5 00 00 	movabs $0xb58000,%rdi
  80435d:	00 00 00 
  804360:	48 b8 c2 1e 80 00 00 	movabs $0x801ec2,%rax
  804367:	00 00 00 
  80436a:	ff d0                	callq  *%rax
	return fsipc(FSREQ_REMOVE, NULL);
  80436c:	be 00 00 00 00       	mov    $0x0,%esi
  804371:	bf 07 00 00 00       	mov    $0x7,%edi
  804376:	48 b8 b5 3e 80 00 00 	movabs $0x803eb5,%rax
  80437d:	00 00 00 
  804380:	ff d0                	callq  *%rax
}
  804382:	c9                   	leaveq 
  804383:	c3                   	retq   

0000000000804384 <sync>:

// Synchronize disk with buffer cache
int
sync(void)
{
  804384:	55                   	push   %rbp
  804385:	48 89 e5             	mov    %rsp,%rbp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  804388:	be 00 00 00 00       	mov    $0x0,%esi
  80438d:	bf 08 00 00 00       	mov    $0x8,%edi
  804392:	48 b8 b5 3e 80 00 00 	movabs $0x803eb5,%rax
  804399:	00 00 00 
  80439c:	ff d0                	callq  *%rax
}
  80439e:	5d                   	pop    %rbp
  80439f:	c3                   	retq   

00000000008043a0 <copy>:

//Copy a file from src to dest
int
copy(char *src, char *dest)
{
  8043a0:	55                   	push   %rbp
  8043a1:	48 89 e5             	mov    %rsp,%rbp
  8043a4:	48 81 ec 20 02 00 00 	sub    $0x220,%rsp
  8043ab:	48 89 bd e8 fd ff ff 	mov    %rdi,-0x218(%rbp)
  8043b2:	48 89 b5 e0 fd ff ff 	mov    %rsi,-0x220(%rbp)
	int r;
	int fd_src, fd_dest;
	char buffer[512];	//keep this small
	ssize_t read_size;
	ssize_t write_size;
	fd_src = open(src, O_RDONLY);
  8043b9:	48 8b 85 e8 fd ff ff 	mov    -0x218(%rbp),%rax
  8043c0:	be 00 00 00 00       	mov    $0x0,%esi
  8043c5:	48 89 c7             	mov    %rax,%rdi
  8043c8:	48 b8 3e 3f 80 00 00 	movabs $0x803f3e,%rax
  8043cf:	00 00 00 
  8043d2:	ff d0                	callq  *%rax
  8043d4:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (fd_src < 0) {	//error
  8043d7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8043db:	79 28                	jns    804405 <copy+0x65>
		cprintf("cp open src error:%e\n", fd_src);
  8043dd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8043e0:	89 c6                	mov    %eax,%esi
  8043e2:	48 bf 49 17 82 00 00 	movabs $0x821749,%rdi
  8043e9:	00 00 00 
  8043ec:	b8 00 00 00 00       	mov    $0x0,%eax
  8043f1:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8043f8:	00 00 00 
  8043fb:	ff d2                	callq  *%rdx
		return fd_src;
  8043fd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804400:	e9 76 01 00 00       	jmpq   80457b <copy+0x1db>
	}
	
	fd_dest = open(dest, O_CREAT | O_WRONLY);
  804405:	48 8b 85 e0 fd ff ff 	mov    -0x220(%rbp),%rax
  80440c:	be 01 01 00 00       	mov    $0x101,%esi
  804411:	48 89 c7             	mov    %rax,%rdi
  804414:	48 b8 3e 3f 80 00 00 	movabs $0x803f3e,%rax
  80441b:	00 00 00 
  80441e:	ff d0                	callq  *%rax
  804420:	89 45 f8             	mov    %eax,-0x8(%rbp)
	if (fd_dest < 0) {	//error
  804423:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  804427:	0f 89 ad 00 00 00    	jns    8044da <copy+0x13a>
		cprintf("cp create dest  error:%e\n", fd_dest);
  80442d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804430:	89 c6                	mov    %eax,%esi
  804432:	48 bf 5f 17 82 00 00 	movabs $0x82175f,%rdi
  804439:	00 00 00 
  80443c:	b8 00 00 00 00       	mov    $0x0,%eax
  804441:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  804448:	00 00 00 
  80444b:	ff d2                	callq  *%rdx
		close(fd_src);
  80444d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804450:	89 c7                	mov    %eax,%edi
  804452:	48 b8 42 38 80 00 00 	movabs $0x803842,%rax
  804459:	00 00 00 
  80445c:	ff d0                	callq  *%rax
		return fd_dest;
  80445e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804461:	e9 15 01 00 00       	jmpq   80457b <copy+0x1db>
	}
	
	while ((read_size = read(fd_src, buffer, 512)) > 0) {
		write_size = write(fd_dest, buffer, read_size);
  804466:	8b 45 f4             	mov    -0xc(%rbp),%eax
  804469:	48 63 d0             	movslq %eax,%rdx
  80446c:	48 8d 8d f0 fd ff ff 	lea    -0x210(%rbp),%rcx
  804473:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804476:	48 89 ce             	mov    %rcx,%rsi
  804479:	89 c7                	mov    %eax,%edi
  80447b:	48 b8 b0 3b 80 00 00 	movabs $0x803bb0,%rax
  804482:	00 00 00 
  804485:	ff d0                	callq  *%rax
  804487:	89 45 f0             	mov    %eax,-0x10(%rbp)
		if (write_size < 0) {
  80448a:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  80448e:	79 4a                	jns    8044da <copy+0x13a>
			cprintf("cp write error:%e\n", write_size);
  804490:	8b 45 f0             	mov    -0x10(%rbp),%eax
  804493:	89 c6                	mov    %eax,%esi
  804495:	48 bf 79 17 82 00 00 	movabs $0x821779,%rdi
  80449c:	00 00 00 
  80449f:	b8 00 00 00 00       	mov    $0x0,%eax
  8044a4:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8044ab:	00 00 00 
  8044ae:	ff d2                	callq  *%rdx
			close(fd_src);
  8044b0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8044b3:	89 c7                	mov    %eax,%edi
  8044b5:	48 b8 42 38 80 00 00 	movabs $0x803842,%rax
  8044bc:	00 00 00 
  8044bf:	ff d0                	callq  *%rax
			close(fd_dest);
  8044c1:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8044c4:	89 c7                	mov    %eax,%edi
  8044c6:	48 b8 42 38 80 00 00 	movabs $0x803842,%rax
  8044cd:	00 00 00 
  8044d0:	ff d0                	callq  *%rax
			return write_size;
  8044d2:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8044d5:	e9 a1 00 00 00       	jmpq   80457b <copy+0x1db>
		cprintf("cp create dest  error:%e\n", fd_dest);
		close(fd_src);
		return fd_dest;
	}
	
	while ((read_size = read(fd_src, buffer, 512)) > 0) {
  8044da:	48 8d 8d f0 fd ff ff 	lea    -0x210(%rbp),%rcx
  8044e1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8044e4:	ba 00 02 00 00       	mov    $0x200,%edx
  8044e9:	48 89 ce             	mov    %rcx,%rsi
  8044ec:	89 c7                	mov    %eax,%edi
  8044ee:	48 b8 65 3a 80 00 00 	movabs $0x803a65,%rax
  8044f5:	00 00 00 
  8044f8:	ff d0                	callq  *%rax
  8044fa:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8044fd:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  804501:	0f 8f 5f ff ff ff    	jg     804466 <copy+0xc6>
			close(fd_src);
			close(fd_dest);
			return write_size;
		}		
	}
	if (read_size < 0) {
  804507:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  80450b:	79 47                	jns    804554 <copy+0x1b4>
		cprintf("cp read src error:%e\n", read_size);
  80450d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  804510:	89 c6                	mov    %eax,%esi
  804512:	48 bf 8c 17 82 00 00 	movabs $0x82178c,%rdi
  804519:	00 00 00 
  80451c:	b8 00 00 00 00       	mov    $0x0,%eax
  804521:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  804528:	00 00 00 
  80452b:	ff d2                	callq  *%rdx
		close(fd_src);
  80452d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804530:	89 c7                	mov    %eax,%edi
  804532:	48 b8 42 38 80 00 00 	movabs $0x803842,%rax
  804539:	00 00 00 
  80453c:	ff d0                	callq  *%rax
		close(fd_dest);
  80453e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804541:	89 c7                	mov    %eax,%edi
  804543:	48 b8 42 38 80 00 00 	movabs $0x803842,%rax
  80454a:	00 00 00 
  80454d:	ff d0                	callq  *%rax
		return read_size;
  80454f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  804552:	eb 27                	jmp    80457b <copy+0x1db>
	}
	close(fd_src);
  804554:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804557:	89 c7                	mov    %eax,%edi
  804559:	48 b8 42 38 80 00 00 	movabs $0x803842,%rax
  804560:	00 00 00 
  804563:	ff d0                	callq  *%rax
	close(fd_dest);
  804565:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804568:	89 c7                	mov    %eax,%edi
  80456a:	48 b8 42 38 80 00 00 	movabs $0x803842,%rax
  804571:	00 00 00 
  804574:	ff d0                	callq  *%rax
	return 0;
  804576:	b8 00 00 00 00       	mov    $0x0,%eax
	
}
  80457b:	c9                   	leaveq 
  80457c:	c3                   	retq   

000000000080457d <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  80457d:	55                   	push   %rbp
  80457e:	48 89 e5             	mov    %rsp,%rbp
  804581:	48 83 ec 20          	sub    $0x20,%rsp
  804585:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  804588:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80458c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80458f:	48 89 d6             	mov    %rdx,%rsi
  804592:	89 c7                	mov    %eax,%edi
  804594:	48 b8 30 36 80 00 00 	movabs $0x803630,%rax
  80459b:	00 00 00 
  80459e:	ff d0                	callq  *%rax
  8045a0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8045a3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8045a7:	79 05                	jns    8045ae <fd2sockid+0x31>
		return r;
  8045a9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8045ac:	eb 24                	jmp    8045d2 <fd2sockid+0x55>
	if (sfd->fd_dev_id != devsock.dev_id)
  8045ae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8045b2:	8b 10                	mov    (%rax),%edx
  8045b4:	48 b8 a0 80 82 00 00 	movabs $0x8280a0,%rax
  8045bb:	00 00 00 
  8045be:	8b 00                	mov    (%rax),%eax
  8045c0:	39 c2                	cmp    %eax,%edx
  8045c2:	74 07                	je     8045cb <fd2sockid+0x4e>
		return -E_NOT_SUPP;
  8045c4:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  8045c9:	eb 07                	jmp    8045d2 <fd2sockid+0x55>
	return sfd->fd_sock.sockid;
  8045cb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8045cf:	8b 40 0c             	mov    0xc(%rax),%eax
}
  8045d2:	c9                   	leaveq 
  8045d3:	c3                   	retq   

00000000008045d4 <alloc_sockfd>:

static int
alloc_sockfd(int sockid)
{
  8045d4:	55                   	push   %rbp
  8045d5:	48 89 e5             	mov    %rsp,%rbp
  8045d8:	48 83 ec 20          	sub    $0x20,%rsp
  8045dc:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  8045df:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8045e3:	48 89 c7             	mov    %rax,%rdi
  8045e6:	48 b8 98 35 80 00 00 	movabs $0x803598,%rax
  8045ed:	00 00 00 
  8045f0:	ff d0                	callq  *%rax
  8045f2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8045f5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8045f9:	78 26                	js     804621 <alloc_sockfd+0x4d>
            || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  8045fb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8045ff:	ba 07 04 00 00       	mov    $0x407,%edx
  804604:	48 89 c6             	mov    %rax,%rsi
  804607:	bf 00 00 00 00       	mov    $0x0,%edi
  80460c:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  804613:	00 00 00 
  804616:	ff d0                	callq  *%rax
  804618:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80461b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80461f:	79 16                	jns    804637 <alloc_sockfd+0x63>
		nsipc_close(sockid);
  804621:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804624:	89 c7                	mov    %eax,%edi
  804626:	48 b8 e3 4a 80 00 00 	movabs $0x804ae3,%rax
  80462d:	00 00 00 
  804630:	ff d0                	callq  *%rax
		return r;
  804632:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804635:	eb 3a                	jmp    804671 <alloc_sockfd+0x9d>
	}

	sfd->fd_dev_id = devsock.dev_id;
  804637:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80463b:	48 ba a0 80 82 00 00 	movabs $0x8280a0,%rdx
  804642:	00 00 00 
  804645:	8b 12                	mov    (%rdx),%edx
  804647:	89 10                	mov    %edx,(%rax)
	sfd->fd_omode = O_RDWR;
  804649:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80464d:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%rax)
	sfd->fd_sock.sockid = sockid;
  804654:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804658:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80465b:	89 50 0c             	mov    %edx,0xc(%rax)
	return fd2num(sfd);
  80465e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804662:	48 89 c7             	mov    %rax,%rdi
  804665:	48 b8 4a 35 80 00 00 	movabs $0x80354a,%rax
  80466c:	00 00 00 
  80466f:	ff d0                	callq  *%rax
}
  804671:	c9                   	leaveq 
  804672:	c3                   	retq   

0000000000804673 <accept>:

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  804673:	55                   	push   %rbp
  804674:	48 89 e5             	mov    %rsp,%rbp
  804677:	48 83 ec 30          	sub    $0x30,%rsp
  80467b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80467e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804682:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  804686:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804689:	89 c7                	mov    %eax,%edi
  80468b:	48 b8 7d 45 80 00 00 	movabs $0x80457d,%rax
  804692:	00 00 00 
  804695:	ff d0                	callq  *%rax
  804697:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80469a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80469e:	79 05                	jns    8046a5 <accept+0x32>
		return r;
  8046a0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8046a3:	eb 3b                	jmp    8046e0 <accept+0x6d>
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  8046a5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8046a9:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8046ad:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8046b0:	48 89 ce             	mov    %rcx,%rsi
  8046b3:	89 c7                	mov    %eax,%edi
  8046b5:	48 b8 c0 49 80 00 00 	movabs $0x8049c0,%rax
  8046bc:	00 00 00 
  8046bf:	ff d0                	callq  *%rax
  8046c1:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8046c4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8046c8:	79 05                	jns    8046cf <accept+0x5c>
		return r;
  8046ca:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8046cd:	eb 11                	jmp    8046e0 <accept+0x6d>
	return alloc_sockfd(r);
  8046cf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8046d2:	89 c7                	mov    %eax,%edi
  8046d4:	48 b8 d4 45 80 00 00 	movabs $0x8045d4,%rax
  8046db:	00 00 00 
  8046de:	ff d0                	callq  *%rax
}
  8046e0:	c9                   	leaveq 
  8046e1:	c3                   	retq   

00000000008046e2 <bind>:

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  8046e2:	55                   	push   %rbp
  8046e3:	48 89 e5             	mov    %rsp,%rbp
  8046e6:	48 83 ec 20          	sub    $0x20,%rsp
  8046ea:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8046ed:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8046f1:	89 55 e8             	mov    %edx,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  8046f4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8046f7:	89 c7                	mov    %eax,%edi
  8046f9:	48 b8 7d 45 80 00 00 	movabs $0x80457d,%rax
  804700:	00 00 00 
  804703:	ff d0                	callq  *%rax
  804705:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804708:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80470c:	79 05                	jns    804713 <bind+0x31>
		return r;
  80470e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804711:	eb 1b                	jmp    80472e <bind+0x4c>
	return nsipc_bind(r, name, namelen);
  804713:	8b 55 e8             	mov    -0x18(%rbp),%edx
  804716:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80471a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80471d:	48 89 ce             	mov    %rcx,%rsi
  804720:	89 c7                	mov    %eax,%edi
  804722:	48 b8 3f 4a 80 00 00 	movabs $0x804a3f,%rax
  804729:	00 00 00 
  80472c:	ff d0                	callq  *%rax
}
  80472e:	c9                   	leaveq 
  80472f:	c3                   	retq   

0000000000804730 <shutdown>:

int
shutdown(int s, int how)
{
  804730:	55                   	push   %rbp
  804731:	48 89 e5             	mov    %rsp,%rbp
  804734:	48 83 ec 20          	sub    $0x20,%rsp
  804738:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80473b:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  80473e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804741:	89 c7                	mov    %eax,%edi
  804743:	48 b8 7d 45 80 00 00 	movabs $0x80457d,%rax
  80474a:	00 00 00 
  80474d:	ff d0                	callq  *%rax
  80474f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804752:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804756:	79 05                	jns    80475d <shutdown+0x2d>
		return r;
  804758:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80475b:	eb 16                	jmp    804773 <shutdown+0x43>
	return nsipc_shutdown(r, how);
  80475d:	8b 55 e8             	mov    -0x18(%rbp),%edx
  804760:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804763:	89 d6                	mov    %edx,%esi
  804765:	89 c7                	mov    %eax,%edi
  804767:	48 b8 a3 4a 80 00 00 	movabs $0x804aa3,%rax
  80476e:	00 00 00 
  804771:	ff d0                	callq  *%rax
}
  804773:	c9                   	leaveq 
  804774:	c3                   	retq   

0000000000804775 <devsock_close>:

static int
devsock_close(struct Fd *fd)
{
  804775:	55                   	push   %rbp
  804776:	48 89 e5             	mov    %rsp,%rbp
  804779:	48 83 ec 10          	sub    $0x10,%rsp
  80477d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (pageref(fd) == 1)
  804781:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804785:	48 89 c7             	mov    %rax,%rdi
  804788:	48 b8 a0 5c 80 00 00 	movabs $0x805ca0,%rax
  80478f:	00 00 00 
  804792:	ff d0                	callq  *%rax
  804794:	83 f8 01             	cmp    $0x1,%eax
  804797:	75 17                	jne    8047b0 <devsock_close+0x3b>
		return nsipc_close(fd->fd_sock.sockid);
  804799:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80479d:	8b 40 0c             	mov    0xc(%rax),%eax
  8047a0:	89 c7                	mov    %eax,%edi
  8047a2:	48 b8 e3 4a 80 00 00 	movabs $0x804ae3,%rax
  8047a9:	00 00 00 
  8047ac:	ff d0                	callq  *%rax
  8047ae:	eb 05                	jmp    8047b5 <devsock_close+0x40>
	else
		return 0;
  8047b0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8047b5:	c9                   	leaveq 
  8047b6:	c3                   	retq   

00000000008047b7 <connect>:

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  8047b7:	55                   	push   %rbp
  8047b8:	48 89 e5             	mov    %rsp,%rbp
  8047bb:	48 83 ec 20          	sub    $0x20,%rsp
  8047bf:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8047c2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8047c6:	89 55 e8             	mov    %edx,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  8047c9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8047cc:	89 c7                	mov    %eax,%edi
  8047ce:	48 b8 7d 45 80 00 00 	movabs $0x80457d,%rax
  8047d5:	00 00 00 
  8047d8:	ff d0                	callq  *%rax
  8047da:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8047dd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8047e1:	79 05                	jns    8047e8 <connect+0x31>
		return r;
  8047e3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8047e6:	eb 1b                	jmp    804803 <connect+0x4c>
	return nsipc_connect(r, name, namelen);
  8047e8:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8047eb:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8047ef:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8047f2:	48 89 ce             	mov    %rcx,%rsi
  8047f5:	89 c7                	mov    %eax,%edi
  8047f7:	48 b8 10 4b 80 00 00 	movabs $0x804b10,%rax
  8047fe:	00 00 00 
  804801:	ff d0                	callq  *%rax
}
  804803:	c9                   	leaveq 
  804804:	c3                   	retq   

0000000000804805 <listen>:

int
listen(int s, int backlog)
{
  804805:	55                   	push   %rbp
  804806:	48 89 e5             	mov    %rsp,%rbp
  804809:	48 83 ec 20          	sub    $0x20,%rsp
  80480d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804810:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  804813:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804816:	89 c7                	mov    %eax,%edi
  804818:	48 b8 7d 45 80 00 00 	movabs $0x80457d,%rax
  80481f:	00 00 00 
  804822:	ff d0                	callq  *%rax
  804824:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804827:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80482b:	79 05                	jns    804832 <listen+0x2d>
		return r;
  80482d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804830:	eb 16                	jmp    804848 <listen+0x43>
	return nsipc_listen(r, backlog);
  804832:	8b 55 e8             	mov    -0x18(%rbp),%edx
  804835:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804838:	89 d6                	mov    %edx,%esi
  80483a:	89 c7                	mov    %eax,%edi
  80483c:	48 b8 74 4b 80 00 00 	movabs $0x804b74,%rax
  804843:	00 00 00 
  804846:	ff d0                	callq  *%rax
}
  804848:	c9                   	leaveq 
  804849:	c3                   	retq   

000000000080484a <devsock_read>:

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  80484a:	55                   	push   %rbp
  80484b:	48 89 e5             	mov    %rsp,%rbp
  80484e:	48 83 ec 20          	sub    $0x20,%rsp
  804852:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  804856:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80485a:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  80485e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804862:	89 c2                	mov    %eax,%edx
  804864:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804868:	8b 40 0c             	mov    0xc(%rax),%eax
  80486b:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80486f:	b9 00 00 00 00       	mov    $0x0,%ecx
  804874:	89 c7                	mov    %eax,%edi
  804876:	48 b8 b4 4b 80 00 00 	movabs $0x804bb4,%rax
  80487d:	00 00 00 
  804880:	ff d0                	callq  *%rax
}
  804882:	c9                   	leaveq 
  804883:	c3                   	retq   

0000000000804884 <devsock_write>:

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  804884:	55                   	push   %rbp
  804885:	48 89 e5             	mov    %rsp,%rbp
  804888:	48 83 ec 20          	sub    $0x20,%rsp
  80488c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  804890:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804894:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  804898:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80489c:	89 c2                	mov    %eax,%edx
  80489e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8048a2:	8b 40 0c             	mov    0xc(%rax),%eax
  8048a5:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8048a9:	b9 00 00 00 00       	mov    $0x0,%ecx
  8048ae:	89 c7                	mov    %eax,%edi
  8048b0:	48 b8 80 4c 80 00 00 	movabs $0x804c80,%rax
  8048b7:	00 00 00 
  8048ba:	ff d0                	callq  *%rax
}
  8048bc:	c9                   	leaveq 
  8048bd:	c3                   	retq   

00000000008048be <devsock_stat>:

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  8048be:	55                   	push   %rbp
  8048bf:	48 89 e5             	mov    %rsp,%rbp
  8048c2:	48 83 ec 10          	sub    $0x10,%rsp
  8048c6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8048ca:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	strcpy(stat->st_name, "<sock>");
  8048ce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8048d2:	48 be a7 17 82 00 00 	movabs $0x8217a7,%rsi
  8048d9:	00 00 00 
  8048dc:	48 89 c7             	mov    %rax,%rdi
  8048df:	48 b8 c2 1e 80 00 00 	movabs $0x801ec2,%rax
  8048e6:	00 00 00 
  8048e9:	ff d0                	callq  *%rax
	return 0;
  8048eb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8048f0:	c9                   	leaveq 
  8048f1:	c3                   	retq   

00000000008048f2 <socket>:

int
socket(int domain, int type, int protocol)
{
  8048f2:	55                   	push   %rbp
  8048f3:	48 89 e5             	mov    %rsp,%rbp
  8048f6:	48 83 ec 20          	sub    $0x20,%rsp
  8048fa:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8048fd:	89 75 e8             	mov    %esi,-0x18(%rbp)
  804900:	89 55 e4             	mov    %edx,-0x1c(%rbp)
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  804903:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  804906:	8b 4d e8             	mov    -0x18(%rbp),%ecx
  804909:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80490c:	89 ce                	mov    %ecx,%esi
  80490e:	89 c7                	mov    %eax,%edi
  804910:	48 b8 38 4d 80 00 00 	movabs $0x804d38,%rax
  804917:	00 00 00 
  80491a:	ff d0                	callq  *%rax
  80491c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80491f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804923:	79 05                	jns    80492a <socket+0x38>
		return r;
  804925:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804928:	eb 11                	jmp    80493b <socket+0x49>
	return alloc_sockfd(r);
  80492a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80492d:	89 c7                	mov    %eax,%edi
  80492f:	48 b8 d4 45 80 00 00 	movabs $0x8045d4,%rax
  804936:	00 00 00 
  804939:	ff d0                	callq  *%rax
}
  80493b:	c9                   	leaveq 
  80493c:	c3                   	retq   

000000000080493d <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  80493d:	55                   	push   %rbp
  80493e:	48 89 e5             	mov    %rsp,%rbp
  804941:	48 83 ec 10          	sub    $0x10,%rsp
  804945:	89 7d fc             	mov    %edi,-0x4(%rbp)
	static envid_t nsenv;
	if (nsenv == 0)
  804948:	48 b8 88 90 82 00 00 	movabs $0x829088,%rax
  80494f:	00 00 00 
  804952:	8b 00                	mov    (%rax),%eax
  804954:	85 c0                	test   %eax,%eax
  804956:	75 1f                	jne    804977 <nsipc+0x3a>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  804958:	bf 02 00 00 00       	mov    $0x2,%edi
  80495d:	48 b8 d9 34 80 00 00 	movabs $0x8034d9,%rax
  804964:	00 00 00 
  804967:	ff d0                	callq  *%rax
  804969:	89 c2                	mov    %eax,%edx
  80496b:	48 b8 88 90 82 00 00 	movabs $0x829088,%rax
  804972:	00 00 00 
  804975:	89 10                	mov    %edx,(%rax)
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  804977:	48 b8 88 90 82 00 00 	movabs $0x829088,%rax
  80497e:	00 00 00 
  804981:	8b 00                	mov    (%rax),%eax
  804983:	8b 75 fc             	mov    -0x4(%rbp),%esi
  804986:	b9 07 00 00 00       	mov    $0x7,%ecx
  80498b:	48 ba 00 a0 b5 00 00 	movabs $0xb5a000,%rdx
  804992:	00 00 00 
  804995:	89 c7                	mov    %eax,%edi
  804997:	48 b8 cd 32 80 00 00 	movabs $0x8032cd,%rax
  80499e:	00 00 00 
  8049a1:	ff d0                	callq  *%rax
	return ipc_recv(NULL, NULL, NULL);
  8049a3:	ba 00 00 00 00       	mov    $0x0,%edx
  8049a8:	be 00 00 00 00       	mov    $0x0,%esi
  8049ad:	bf 00 00 00 00       	mov    $0x0,%edi
  8049b2:	48 b8 0c 32 80 00 00 	movabs $0x80320c,%rax
  8049b9:	00 00 00 
  8049bc:	ff d0                	callq  *%rax
}
  8049be:	c9                   	leaveq 
  8049bf:	c3                   	retq   

00000000008049c0 <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  8049c0:	55                   	push   %rbp
  8049c1:	48 89 e5             	mov    %rsp,%rbp
  8049c4:	48 83 ec 30          	sub    $0x30,%rsp
  8049c8:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8049cb:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8049cf:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int r;

	nsipcbuf.accept.req_s = s;
  8049d3:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8049da:	00 00 00 
  8049dd:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8049e0:	89 10                	mov    %edx,(%rax)
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  8049e2:	bf 01 00 00 00       	mov    $0x1,%edi
  8049e7:	48 b8 3d 49 80 00 00 	movabs $0x80493d,%rax
  8049ee:	00 00 00 
  8049f1:	ff d0                	callq  *%rax
  8049f3:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8049f6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8049fa:	78 3e                	js     804a3a <nsipc_accept+0x7a>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
  8049fc:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804a03:	00 00 00 
  804a06:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  804a0a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804a0e:	8b 40 10             	mov    0x10(%rax),%eax
  804a11:	89 c2                	mov    %eax,%edx
  804a13:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  804a17:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804a1b:	48 89 ce             	mov    %rcx,%rsi
  804a1e:	48 89 c7             	mov    %rax,%rdi
  804a21:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  804a28:	00 00 00 
  804a2b:	ff d0                	callq  *%rax
		*addrlen = ret->ret_addrlen;
  804a2d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804a31:	8b 50 10             	mov    0x10(%rax),%edx
  804a34:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804a38:	89 10                	mov    %edx,(%rax)
	}
	return r;
  804a3a:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  804a3d:	c9                   	leaveq 
  804a3e:	c3                   	retq   

0000000000804a3f <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  804a3f:	55                   	push   %rbp
  804a40:	48 89 e5             	mov    %rsp,%rbp
  804a43:	48 83 ec 10          	sub    $0x10,%rsp
  804a47:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804a4a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804a4e:	89 55 f8             	mov    %edx,-0x8(%rbp)
	nsipcbuf.bind.req_s = s;
  804a51:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804a58:	00 00 00 
  804a5b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804a5e:	89 10                	mov    %edx,(%rax)
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  804a60:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804a63:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804a67:	48 89 c6             	mov    %rax,%rsi
  804a6a:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  804a71:	00 00 00 
  804a74:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  804a7b:	00 00 00 
  804a7e:	ff d0                	callq  *%rax
	nsipcbuf.bind.req_namelen = namelen;
  804a80:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804a87:	00 00 00 
  804a8a:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804a8d:	89 50 14             	mov    %edx,0x14(%rax)
	return nsipc(NSREQ_BIND);
  804a90:	bf 02 00 00 00       	mov    $0x2,%edi
  804a95:	48 b8 3d 49 80 00 00 	movabs $0x80493d,%rax
  804a9c:	00 00 00 
  804a9f:	ff d0                	callq  *%rax
}
  804aa1:	c9                   	leaveq 
  804aa2:	c3                   	retq   

0000000000804aa3 <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  804aa3:	55                   	push   %rbp
  804aa4:	48 89 e5             	mov    %rsp,%rbp
  804aa7:	48 83 ec 10          	sub    $0x10,%rsp
  804aab:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804aae:	89 75 f8             	mov    %esi,-0x8(%rbp)
	nsipcbuf.shutdown.req_s = s;
  804ab1:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804ab8:	00 00 00 
  804abb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804abe:	89 10                	mov    %edx,(%rax)
	nsipcbuf.shutdown.req_how = how;
  804ac0:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804ac7:	00 00 00 
  804aca:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804acd:	89 50 04             	mov    %edx,0x4(%rax)
	return nsipc(NSREQ_SHUTDOWN);
  804ad0:	bf 03 00 00 00       	mov    $0x3,%edi
  804ad5:	48 b8 3d 49 80 00 00 	movabs $0x80493d,%rax
  804adc:	00 00 00 
  804adf:	ff d0                	callq  *%rax
}
  804ae1:	c9                   	leaveq 
  804ae2:	c3                   	retq   

0000000000804ae3 <nsipc_close>:

int
nsipc_close(int s)
{
  804ae3:	55                   	push   %rbp
  804ae4:	48 89 e5             	mov    %rsp,%rbp
  804ae7:	48 83 ec 10          	sub    $0x10,%rsp
  804aeb:	89 7d fc             	mov    %edi,-0x4(%rbp)
	nsipcbuf.close.req_s = s;
  804aee:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804af5:	00 00 00 
  804af8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804afb:	89 10                	mov    %edx,(%rax)
	return nsipc(NSREQ_CLOSE);
  804afd:	bf 04 00 00 00       	mov    $0x4,%edi
  804b02:	48 b8 3d 49 80 00 00 	movabs $0x80493d,%rax
  804b09:	00 00 00 
  804b0c:	ff d0                	callq  *%rax
}
  804b0e:	c9                   	leaveq 
  804b0f:	c3                   	retq   

0000000000804b10 <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  804b10:	55                   	push   %rbp
  804b11:	48 89 e5             	mov    %rsp,%rbp
  804b14:	48 83 ec 10          	sub    $0x10,%rsp
  804b18:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804b1b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804b1f:	89 55 f8             	mov    %edx,-0x8(%rbp)
	nsipcbuf.connect.req_s = s;
  804b22:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804b29:	00 00 00 
  804b2c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804b2f:	89 10                	mov    %edx,(%rax)
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  804b31:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804b34:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804b38:	48 89 c6             	mov    %rax,%rsi
  804b3b:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  804b42:	00 00 00 
  804b45:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  804b4c:	00 00 00 
  804b4f:	ff d0                	callq  *%rax
	nsipcbuf.connect.req_namelen = namelen;
  804b51:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804b58:	00 00 00 
  804b5b:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804b5e:	89 50 14             	mov    %edx,0x14(%rax)
	return nsipc(NSREQ_CONNECT);
  804b61:	bf 05 00 00 00       	mov    $0x5,%edi
  804b66:	48 b8 3d 49 80 00 00 	movabs $0x80493d,%rax
  804b6d:	00 00 00 
  804b70:	ff d0                	callq  *%rax
}
  804b72:	c9                   	leaveq 
  804b73:	c3                   	retq   

0000000000804b74 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  804b74:	55                   	push   %rbp
  804b75:	48 89 e5             	mov    %rsp,%rbp
  804b78:	48 83 ec 10          	sub    $0x10,%rsp
  804b7c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804b7f:	89 75 f8             	mov    %esi,-0x8(%rbp)
	nsipcbuf.listen.req_s = s;
  804b82:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804b89:	00 00 00 
  804b8c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804b8f:	89 10                	mov    %edx,(%rax)
	nsipcbuf.listen.req_backlog = backlog;
  804b91:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804b98:	00 00 00 
  804b9b:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804b9e:	89 50 04             	mov    %edx,0x4(%rax)
	return nsipc(NSREQ_LISTEN);
  804ba1:	bf 06 00 00 00       	mov    $0x6,%edi
  804ba6:	48 b8 3d 49 80 00 00 	movabs $0x80493d,%rax
  804bad:	00 00 00 
  804bb0:	ff d0                	callq  *%rax
}
  804bb2:	c9                   	leaveq 
  804bb3:	c3                   	retq   

0000000000804bb4 <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  804bb4:	55                   	push   %rbp
  804bb5:	48 89 e5             	mov    %rsp,%rbp
  804bb8:	48 83 ec 30          	sub    $0x30,%rsp
  804bbc:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804bbf:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804bc3:	89 55 e8             	mov    %edx,-0x18(%rbp)
  804bc6:	89 4d dc             	mov    %ecx,-0x24(%rbp)
	int r;

	nsipcbuf.recv.req_s = s;
  804bc9:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804bd0:	00 00 00 
  804bd3:	8b 55 ec             	mov    -0x14(%rbp),%edx
  804bd6:	89 10                	mov    %edx,(%rax)
	nsipcbuf.recv.req_len = len;
  804bd8:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804bdf:	00 00 00 
  804be2:	8b 55 e8             	mov    -0x18(%rbp),%edx
  804be5:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.recv.req_flags = flags;
  804be8:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804bef:	00 00 00 
  804bf2:	8b 55 dc             	mov    -0x24(%rbp),%edx
  804bf5:	89 50 08             	mov    %edx,0x8(%rax)

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  804bf8:	bf 07 00 00 00       	mov    $0x7,%edi
  804bfd:	48 b8 3d 49 80 00 00 	movabs $0x80493d,%rax
  804c04:	00 00 00 
  804c07:	ff d0                	callq  *%rax
  804c09:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804c0c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804c10:	78 69                	js     804c7b <nsipc_recv+0xc7>
		assert(r < 1600 && r <= len);
  804c12:	81 7d fc 3f 06 00 00 	cmpl   $0x63f,-0x4(%rbp)
  804c19:	7f 08                	jg     804c23 <nsipc_recv+0x6f>
  804c1b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804c1e:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  804c21:	7e 35                	jle    804c58 <nsipc_recv+0xa4>
  804c23:	48 b9 ae 17 82 00 00 	movabs $0x8217ae,%rcx
  804c2a:	00 00 00 
  804c2d:	48 ba c3 17 82 00 00 	movabs $0x8217c3,%rdx
  804c34:	00 00 00 
  804c37:	be 62 00 00 00       	mov    $0x62,%esi
  804c3c:	48 bf d8 17 82 00 00 	movabs $0x8217d8,%rdi
  804c43:	00 00 00 
  804c46:	b8 00 00 00 00       	mov    $0x0,%eax
  804c4b:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  804c52:	00 00 00 
  804c55:	41 ff d0             	callq  *%r8
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  804c58:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804c5b:	48 63 d0             	movslq %eax,%rdx
  804c5e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804c62:	48 be 00 a0 b5 00 00 	movabs $0xb5a000,%rsi
  804c69:	00 00 00 
  804c6c:	48 89 c7             	mov    %rax,%rdi
  804c6f:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  804c76:	00 00 00 
  804c79:	ff d0                	callq  *%rax
	}

	return r;
  804c7b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  804c7e:	c9                   	leaveq 
  804c7f:	c3                   	retq   

0000000000804c80 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  804c80:	55                   	push   %rbp
  804c81:	48 89 e5             	mov    %rsp,%rbp
  804c84:	48 83 ec 20          	sub    $0x20,%rsp
  804c88:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804c8b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804c8f:	89 55 f8             	mov    %edx,-0x8(%rbp)
  804c92:	89 4d ec             	mov    %ecx,-0x14(%rbp)
	nsipcbuf.send.req_s = s;
  804c95:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804c9c:	00 00 00 
  804c9f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804ca2:	89 10                	mov    %edx,(%rax)
	assert(size < 1600);
  804ca4:	81 7d f8 3f 06 00 00 	cmpl   $0x63f,-0x8(%rbp)
  804cab:	7e 35                	jle    804ce2 <nsipc_send+0x62>
  804cad:	48 b9 e4 17 82 00 00 	movabs $0x8217e4,%rcx
  804cb4:	00 00 00 
  804cb7:	48 ba c3 17 82 00 00 	movabs $0x8217c3,%rdx
  804cbe:	00 00 00 
  804cc1:	be 6d 00 00 00       	mov    $0x6d,%esi
  804cc6:	48 bf d8 17 82 00 00 	movabs $0x8217d8,%rdi
  804ccd:	00 00 00 
  804cd0:	b8 00 00 00 00       	mov    $0x0,%eax
  804cd5:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  804cdc:	00 00 00 
  804cdf:	41 ff d0             	callq  *%r8
	memmove(&nsipcbuf.send.req_buf, buf, size);
  804ce2:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804ce5:	48 63 d0             	movslq %eax,%rdx
  804ce8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804cec:	48 89 c6             	mov    %rax,%rsi
  804cef:	48 bf 0c a0 b5 00 00 	movabs $0xb5a00c,%rdi
  804cf6:	00 00 00 
  804cf9:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  804d00:	00 00 00 
  804d03:	ff d0                	callq  *%rax
	nsipcbuf.send.req_size = size;
  804d05:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804d0c:	00 00 00 
  804d0f:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804d12:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.send.req_flags = flags;
  804d15:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804d1c:	00 00 00 
  804d1f:	8b 55 ec             	mov    -0x14(%rbp),%edx
  804d22:	89 50 08             	mov    %edx,0x8(%rax)
	return nsipc(NSREQ_SEND);
  804d25:	bf 08 00 00 00       	mov    $0x8,%edi
  804d2a:	48 b8 3d 49 80 00 00 	movabs $0x80493d,%rax
  804d31:	00 00 00 
  804d34:	ff d0                	callq  *%rax
}
  804d36:	c9                   	leaveq 
  804d37:	c3                   	retq   

0000000000804d38 <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  804d38:	55                   	push   %rbp
  804d39:	48 89 e5             	mov    %rsp,%rbp
  804d3c:	48 83 ec 10          	sub    $0x10,%rsp
  804d40:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804d43:	89 75 f8             	mov    %esi,-0x8(%rbp)
  804d46:	89 55 f4             	mov    %edx,-0xc(%rbp)
	nsipcbuf.socket.req_domain = domain;
  804d49:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804d50:	00 00 00 
  804d53:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804d56:	89 10                	mov    %edx,(%rax)
	nsipcbuf.socket.req_type = type;
  804d58:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804d5f:	00 00 00 
  804d62:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804d65:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.socket.req_protocol = protocol;
  804d68:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804d6f:	00 00 00 
  804d72:	8b 55 f4             	mov    -0xc(%rbp),%edx
  804d75:	89 50 08             	mov    %edx,0x8(%rax)
	return nsipc(NSREQ_SOCKET);
  804d78:	bf 09 00 00 00       	mov    $0x9,%edi
  804d7d:	48 b8 3d 49 80 00 00 	movabs $0x80493d,%rax
  804d84:	00 00 00 
  804d87:	ff d0                	callq  *%rax
}
  804d89:	c9                   	leaveq 
  804d8a:	c3                   	retq   

0000000000804d8b <isfree>:
static uint8_t *mend   = (uint8_t*) 0x10000000;
static uint8_t *mptr;

static int
isfree(void *v, size_t n)
{
  804d8b:	55                   	push   %rbp
  804d8c:	48 89 e5             	mov    %rsp,%rbp
  804d8f:	48 83 ec 20          	sub    $0x20,%rsp
  804d93:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  804d97:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uintptr_t va, end_va = (uintptr_t) v + n;
  804d9b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  804d9f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804da3:	48 01 d0             	add    %rdx,%rax
  804da6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  804daa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804dae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  804db2:	eb 64                	jmp    804e18 <isfree+0x8d>
		if (va >= (uintptr_t) mend
  804db4:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  804dbb:	00 00 00 
  804dbe:	48 8b 00             	mov    (%rax),%rax
  804dc1:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  804dc5:	73 42                	jae    804e09 <isfree+0x7e>
		    || ((uvpd[VPD(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  804dc7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804dcb:	48 c1 e8 15          	shr    $0x15,%rax
  804dcf:	48 89 c2             	mov    %rax,%rdx
  804dd2:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  804dd9:	01 00 00 
  804ddc:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  804de0:	83 e0 01             	and    $0x1,%eax
  804de3:	48 85 c0             	test   %rax,%rax
  804de6:	74 28                	je     804e10 <isfree+0x85>
  804de8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804dec:	48 c1 e8 0c          	shr    $0xc,%rax
  804df0:	48 89 c2             	mov    %rax,%rdx
  804df3:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  804dfa:	01 00 00 
  804dfd:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  804e01:	83 e0 01             	and    $0x1,%eax
  804e04:	48 85 c0             	test   %rax,%rax
  804e07:	74 07                	je     804e10 <isfree+0x85>
			return 0;
  804e09:	b8 00 00 00 00       	mov    $0x0,%eax
  804e0e:	eb 17                	jmp    804e27 <isfree+0x9c>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  804e10:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  804e17:	00 
  804e18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804e1c:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  804e20:	72 92                	jb     804db4 <isfree+0x29>
		if (va >= (uintptr_t) mend
		    || ((uvpd[VPD(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
			return 0;
	return 1;
  804e22:	b8 01 00 00 00       	mov    $0x1,%eax
}
  804e27:	c9                   	leaveq 
  804e28:	c3                   	retq   

0000000000804e29 <malloc>:

void*
malloc(size_t n)
{
  804e29:	55                   	push   %rbp
  804e2a:	48 89 e5             	mov    %rsp,%rbp
  804e2d:	48 83 ec 60          	sub    $0x60,%rsp
  804e31:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  804e35:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804e3c:	00 00 00 
  804e3f:	48 8b 00             	mov    (%rax),%rax
  804e42:	48 85 c0             	test   %rax,%rax
  804e45:	75 1a                	jne    804e61 <malloc+0x38>
		mptr = mbegin;
  804e47:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  804e4e:	00 00 00 
  804e51:	48 8b 10             	mov    (%rax),%rdx
  804e54:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804e5b:	00 00 00 
  804e5e:	48 89 10             	mov    %rdx,(%rax)

	n = ROUNDUP(n, 4);
  804e61:	48 c7 45 f0 04 00 00 	movq   $0x4,-0x10(%rbp)
  804e68:	00 
  804e69:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804e6d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804e71:	48 01 d0             	add    %rdx,%rax
  804e74:	48 83 e8 01          	sub    $0x1,%rax
  804e78:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  804e7c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804e80:	ba 00 00 00 00       	mov    $0x0,%edx
  804e85:	48 f7 75 f0          	divq   -0x10(%rbp)
  804e89:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804e8d:	48 29 d0             	sub    %rdx,%rax
  804e90:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	
	if (n >= MAXMALLOC)
  804e94:	48 81 7d a8 ff ff 0f 	cmpq   $0xfffff,-0x58(%rbp)
  804e9b:	00 
  804e9c:	76 0a                	jbe    804ea8 <malloc+0x7f>
		return 0;
  804e9e:	b8 00 00 00 00       	mov    $0x0,%eax
  804ea3:	e9 f0 02 00 00       	jmpq   805198 <malloc+0x36f>
	
	if ((uintptr_t) mptr % PGSIZE){
  804ea8:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804eaf:	00 00 00 
  804eb2:	48 8b 00             	mov    (%rax),%rax
  804eb5:	25 ff 0f 00 00       	and    $0xfff,%eax
  804eba:	48 85 c0             	test   %rax,%rax
  804ebd:	0f 84 0f 01 00 00    	je     804fd2 <malloc+0x1a9>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  804ec3:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  804eca:	00 
  804ecb:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804ed2:	00 00 00 
  804ed5:	48 8b 00             	mov    (%rax),%rax
  804ed8:	48 89 c2             	mov    %rax,%rdx
  804edb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804edf:	48 01 d0             	add    %rdx,%rax
  804ee2:	48 83 e8 01          	sub    $0x1,%rax
  804ee6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  804eea:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804eee:	ba 00 00 00 00       	mov    $0x0,%edx
  804ef3:	48 f7 75 e0          	divq   -0x20(%rbp)
  804ef7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804efb:	48 29 d0             	sub    %rdx,%rax
  804efe:	48 83 e8 04          	sub    $0x4,%rax
  804f02:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  804f06:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804f0d:	00 00 00 
  804f10:	48 8b 00             	mov    (%rax),%rax
  804f13:	48 c1 e8 0c          	shr    $0xc,%rax
  804f17:	48 89 c1             	mov    %rax,%rcx
  804f1a:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804f21:	00 00 00 
  804f24:	48 8b 00             	mov    (%rax),%rax
  804f27:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804f2b:	48 83 c2 03          	add    $0x3,%rdx
  804f2f:	48 01 d0             	add    %rdx,%rax
  804f32:	48 c1 e8 0c          	shr    $0xc,%rax
  804f36:	48 39 c1             	cmp    %rax,%rcx
  804f39:	75 4a                	jne    804f85 <malloc+0x15c>
			(*ref)++;
  804f3b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804f3f:	8b 00                	mov    (%rax),%eax
  804f41:	8d 50 01             	lea    0x1(%rax),%edx
  804f44:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804f48:	89 10                	mov    %edx,(%rax)
			v = mptr;
  804f4a:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804f51:	00 00 00 
  804f54:	48 8b 00             	mov    (%rax),%rax
  804f57:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			mptr += n;
  804f5b:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804f62:	00 00 00 
  804f65:	48 8b 10             	mov    (%rax),%rdx
  804f68:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804f6c:	48 01 c2             	add    %rax,%rdx
  804f6f:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804f76:	00 00 00 
  804f79:	48 89 10             	mov    %rdx,(%rax)
			return v;
  804f7c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804f80:	e9 13 02 00 00       	jmpq   805198 <malloc+0x36f>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  804f85:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804f8c:	00 00 00 
  804f8f:	48 8b 00             	mov    (%rax),%rax
  804f92:	48 89 c7             	mov    %rax,%rdi
  804f95:	48 b8 9a 51 80 00 00 	movabs $0x80519a,%rax
  804f9c:	00 00 00 
  804f9f:	ff d0                	callq  *%rax
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  804fa1:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804fa8:	00 00 00 
  804fab:	48 8b 00             	mov    (%rax),%rax
  804fae:	48 05 00 10 00 00    	add    $0x1000,%rax
  804fb4:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804fb8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804fbc:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  804fc2:	48 89 c2             	mov    %rax,%rdx
  804fc5:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804fcc:	00 00 00 
  804fcf:	48 89 10             	mov    %rdx,(%rax)
	 * now we need to find some address space for this chunk.
	 * if it's less than a page we leave it open for allocation.
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
  804fd2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	while (1) {
		if (isfree(mptr, n + 4))
  804fd9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804fdd:	48 8d 50 04          	lea    0x4(%rax),%rdx
  804fe1:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804fe8:	00 00 00 
  804feb:	48 8b 00             	mov    (%rax),%rax
  804fee:	48 89 d6             	mov    %rdx,%rsi
  804ff1:	48 89 c7             	mov    %rax,%rdi
  804ff4:	48 b8 8b 4d 80 00 00 	movabs $0x804d8b,%rax
  804ffb:	00 00 00 
  804ffe:	ff d0                	callq  *%rax
  805000:	85 c0                	test   %eax,%eax
  805002:	75 72                	jne    805076 <malloc+0x24d>
			break;
		mptr += PGSIZE;
  805004:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  80500b:	00 00 00 
  80500e:	48 8b 00             	mov    (%rax),%rax
  805011:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  805018:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  80501f:	00 00 00 
  805022:	48 89 10             	mov    %rdx,(%rax)
		if (mptr == mend) {
  805025:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  80502c:	00 00 00 
  80502f:	48 8b 10             	mov    (%rax),%rdx
  805032:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  805039:	00 00 00 
  80503c:	48 8b 00             	mov    (%rax),%rax
  80503f:	48 39 c2             	cmp    %rax,%rdx
  805042:	75 95                	jne    804fd9 <malloc+0x1b0>
			mptr = mbegin;
  805044:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  80504b:	00 00 00 
  80504e:	48 8b 10             	mov    (%rax),%rdx
  805051:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  805058:	00 00 00 
  80505b:	48 89 10             	mov    %rdx,(%rax)
			if (++nwrap == 2)
  80505e:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  805062:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  805066:	0f 85 6d ff ff ff    	jne    804fd9 <malloc+0x1b0>
				return 0;	/* out of address space */
  80506c:	b8 00 00 00 00       	mov    $0x0,%eax
  805071:	e9 22 01 00 00       	jmpq   805198 <malloc+0x36f>
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
  805076:	90                   	nop
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  805077:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80507e:	e9 a1 00 00 00       	jmpq   805124 <malloc+0x2fb>
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  805083:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805086:	05 00 10 00 00       	add    $0x1000,%eax
  80508b:	48 98                	cltq   
  80508d:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  805091:	48 83 c2 04          	add    $0x4,%rdx
  805095:	48 39 d0             	cmp    %rdx,%rax
  805098:	73 07                	jae    8050a1 <malloc+0x278>
  80509a:	b8 00 04 00 00       	mov    $0x400,%eax
  80509f:	eb 05                	jmp    8050a6 <malloc+0x27d>
  8050a1:	b8 00 00 00 00       	mov    $0x0,%eax
  8050a6:	89 45 bc             	mov    %eax,-0x44(%rbp)
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  8050a9:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8050ac:	83 c8 07             	or     $0x7,%eax
  8050af:	89 c2                	mov    %eax,%edx
  8050b1:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  8050b8:	00 00 00 
  8050bb:	48 8b 08             	mov    (%rax),%rcx
  8050be:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8050c1:	48 98                	cltq   
  8050c3:	48 01 c8             	add    %rcx,%rax
  8050c6:	48 89 c6             	mov    %rax,%rsi
  8050c9:	bf 00 00 00 00       	mov    $0x0,%edi
  8050ce:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  8050d5:	00 00 00 
  8050d8:	ff d0                	callq  *%rax
  8050da:	85 c0                	test   %eax,%eax
  8050dc:	79 3f                	jns    80511d <malloc+0x2f4>
			for (; i >= 0; i -= PGSIZE)
  8050de:	eb 30                	jmp    805110 <malloc+0x2e7>
				sys_page_unmap(0, mptr + i);
  8050e0:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  8050e7:	00 00 00 
  8050ea:	48 8b 10             	mov    (%rax),%rdx
  8050ed:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8050f0:	48 98                	cltq   
  8050f2:	48 01 d0             	add    %rdx,%rax
  8050f5:	48 89 c6             	mov    %rax,%rsi
  8050f8:	bf 00 00 00 00       	mov    $0x0,%edi
  8050fd:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  805104:	00 00 00 
  805107:	ff d0                	callq  *%rax
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  805109:	81 6d fc 00 10 00 00 	subl   $0x1000,-0x4(%rbp)
  805110:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805114:	79 ca                	jns    8050e0 <malloc+0x2b7>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
  805116:	b8 00 00 00 00       	mov    $0x0,%eax
  80511b:	eb 7b                	jmp    805198 <malloc+0x36f>
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  80511d:	81 45 fc 00 10 00 00 	addl   $0x1000,-0x4(%rbp)
  805124:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805127:	48 98                	cltq   
  805129:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80512d:	48 83 c2 04          	add    $0x4,%rdx
  805131:	48 39 d0             	cmp    %rdx,%rax
  805134:	0f 82 49 ff ff ff    	jb     805083 <malloc+0x25a>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  80513a:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  805141:	00 00 00 
  805144:	48 8b 00             	mov    (%rax),%rax
  805147:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80514a:	48 63 d2             	movslq %edx,%rdx
  80514d:	48 83 ea 04          	sub    $0x4,%rdx
  805151:	48 01 d0             	add    %rdx,%rax
  805154:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	*ref = 2;	/* reference for mptr, reference for returned block */
  805158:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80515c:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
	v = mptr;
  805162:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  805169:	00 00 00 
  80516c:	48 8b 00             	mov    (%rax),%rax
  80516f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	mptr += n;
  805173:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  80517a:	00 00 00 
  80517d:	48 8b 10             	mov    (%rax),%rdx
  805180:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  805184:	48 01 c2             	add    %rax,%rdx
  805187:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  80518e:	00 00 00 
  805191:	48 89 10             	mov    %rdx,(%rax)
	return v;
  805194:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  805198:	c9                   	leaveq 
  805199:	c3                   	retq   

000000000080519a <free>:

void
free(void *v)
{
  80519a:	55                   	push   %rbp
  80519b:	48 89 e5             	mov    %rsp,%rbp
  80519e:	48 83 ec 30          	sub    $0x30,%rsp
  8051a2:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  8051a6:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8051ab:	0f 84 56 01 00 00    	je     805307 <free+0x16d>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  8051b1:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  8051b8:	00 00 00 
  8051bb:	48 8b 00             	mov    (%rax),%rax
  8051be:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8051c2:	77 13                	ja     8051d7 <free+0x3d>
  8051c4:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  8051cb:	00 00 00 
  8051ce:	48 8b 00             	mov    (%rax),%rax
  8051d1:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8051d5:	72 35                	jb     80520c <free+0x72>
  8051d7:	48 b9 f0 17 82 00 00 	movabs $0x8217f0,%rcx
  8051de:	00 00 00 
  8051e1:	48 ba 1e 18 82 00 00 	movabs $0x82181e,%rdx
  8051e8:	00 00 00 
  8051eb:	be 7b 00 00 00       	mov    $0x7b,%esi
  8051f0:	48 bf 33 18 82 00 00 	movabs $0x821833,%rdi
  8051f7:	00 00 00 
  8051fa:	b8 00 00 00 00       	mov    $0x0,%eax
  8051ff:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  805206:	00 00 00 
  805209:	41 ff d0             	callq  *%r8

	c = ROUNDDOWN(v, PGSIZE);
  80520c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805210:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  805214:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805218:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80521e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  805222:	eb 7b                	jmp    80529f <free+0x105>
		sys_page_unmap(0, c);
  805224:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805228:	48 89 c6             	mov    %rax,%rsi
  80522b:	bf 00 00 00 00       	mov    $0x0,%edi
  805230:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  805237:	00 00 00 
  80523a:	ff d0                	callq  *%rax
		c += PGSIZE;
  80523c:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  805243:	00 
		assert(mbegin <= c && c < mend);
  805244:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  80524b:	00 00 00 
  80524e:	48 8b 00             	mov    (%rax),%rax
  805251:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  805255:	77 13                	ja     80526a <free+0xd0>
  805257:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  80525e:	00 00 00 
  805261:	48 8b 00             	mov    (%rax),%rax
  805264:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  805268:	72 35                	jb     80529f <free+0x105>
  80526a:	48 b9 40 18 82 00 00 	movabs $0x821840,%rcx
  805271:	00 00 00 
  805274:	48 ba 1e 18 82 00 00 	movabs $0x82181e,%rdx
  80527b:	00 00 00 
  80527e:	be 82 00 00 00       	mov    $0x82,%esi
  805283:	48 bf 33 18 82 00 00 	movabs $0x821833,%rdi
  80528a:	00 00 00 
  80528d:	b8 00 00 00 00       	mov    $0x0,%eax
  805292:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  805299:	00 00 00 
  80529c:	41 ff d0             	callq  *%r8
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  80529f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8052a3:	48 c1 e8 0c          	shr    $0xc,%rax
  8052a7:	48 89 c2             	mov    %rax,%rdx
  8052aa:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8052b1:	01 00 00 
  8052b4:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8052b8:	25 00 04 00 00       	and    $0x400,%eax
  8052bd:	48 85 c0             	test   %rax,%rax
  8052c0:	0f 85 5e ff ff ff    	jne    805224 <free+0x8a>

	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
  8052c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8052ca:	48 05 fc 0f 00 00    	add    $0xffc,%rax
  8052d0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (--(*ref) == 0)
  8052d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8052d8:	8b 00                	mov    (%rax),%eax
  8052da:	8d 50 ff             	lea    -0x1(%rax),%edx
  8052dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8052e1:	89 10                	mov    %edx,(%rax)
  8052e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8052e7:	8b 00                	mov    (%rax),%eax
  8052e9:	85 c0                	test   %eax,%eax
  8052eb:	75 1b                	jne    805308 <free+0x16e>
		sys_page_unmap(0, c);
  8052ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8052f1:	48 89 c6             	mov    %rax,%rsi
  8052f4:	bf 00 00 00 00       	mov    $0x0,%edi
  8052f9:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  805300:	00 00 00 
  805303:	ff d0                	callq  *%rax
  805305:	eb 01                	jmp    805308 <free+0x16e>
{
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
		return;
  805307:	90                   	nop
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
		sys_page_unmap(0, c);
}
  805308:	c9                   	leaveq 
  805309:	c3                   	retq   

000000000080530a <pipe>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  80530a:	55                   	push   %rbp
  80530b:	48 89 e5             	mov    %rsp,%rbp
  80530e:	53                   	push   %rbx
  80530f:	48 83 ec 38          	sub    $0x38,%rsp
  805313:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  805317:	48 8d 45 d8          	lea    -0x28(%rbp),%rax
  80531b:	48 89 c7             	mov    %rax,%rdi
  80531e:	48 b8 98 35 80 00 00 	movabs $0x803598,%rax
  805325:	00 00 00 
  805328:	ff d0                	callq  *%rax
  80532a:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80532d:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  805331:	0f 88 bf 01 00 00    	js     8054f6 <pipe+0x1ec>
            || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  805337:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80533b:	ba 07 04 00 00       	mov    $0x407,%edx
  805340:	48 89 c6             	mov    %rax,%rsi
  805343:	bf 00 00 00 00       	mov    $0x0,%edi
  805348:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  80534f:	00 00 00 
  805352:	ff d0                	callq  *%rax
  805354:	89 45 ec             	mov    %eax,-0x14(%rbp)
  805357:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80535b:	0f 88 95 01 00 00    	js     8054f6 <pipe+0x1ec>
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  805361:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  805365:	48 89 c7             	mov    %rax,%rdi
  805368:	48 b8 98 35 80 00 00 	movabs $0x803598,%rax
  80536f:	00 00 00 
  805372:	ff d0                	callq  *%rax
  805374:	89 45 ec             	mov    %eax,-0x14(%rbp)
  805377:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80537b:	0f 88 5d 01 00 00    	js     8054de <pipe+0x1d4>
            || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  805381:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805385:	ba 07 04 00 00       	mov    $0x407,%edx
  80538a:	48 89 c6             	mov    %rax,%rsi
  80538d:	bf 00 00 00 00       	mov    $0x0,%edi
  805392:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  805399:	00 00 00 
  80539c:	ff d0                	callq  *%rax
  80539e:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8053a1:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8053a5:	0f 88 33 01 00 00    	js     8054de <pipe+0x1d4>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  8053ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8053af:	48 89 c7             	mov    %rax,%rdi
  8053b2:	48 b8 6d 35 80 00 00 	movabs $0x80356d,%rax
  8053b9:	00 00 00 
  8053bc:	ff d0                	callq  *%rax
  8053be:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8053c2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8053c6:	ba 07 04 00 00       	mov    $0x407,%edx
  8053cb:	48 89 c6             	mov    %rax,%rsi
  8053ce:	bf 00 00 00 00       	mov    $0x0,%edi
  8053d3:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  8053da:	00 00 00 
  8053dd:	ff d0                	callq  *%rax
  8053df:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8053e2:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8053e6:	0f 88 d9 00 00 00    	js     8054c5 <pipe+0x1bb>
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8053ec:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8053f0:	48 89 c7             	mov    %rax,%rdi
  8053f3:	48 b8 6d 35 80 00 00 	movabs $0x80356d,%rax
  8053fa:	00 00 00 
  8053fd:	ff d0                	callq  *%rax
  8053ff:	48 89 c2             	mov    %rax,%rdx
  805402:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805406:	41 b8 07 04 00 00    	mov    $0x407,%r8d
  80540c:	48 89 d1             	mov    %rdx,%rcx
  80540f:	ba 00 00 00 00       	mov    $0x0,%edx
  805414:	48 89 c6             	mov    %rax,%rsi
  805417:	bf 00 00 00 00       	mov    $0x0,%edi
  80541c:	48 b8 4a 28 80 00 00 	movabs $0x80284a,%rax
  805423:	00 00 00 
  805426:	ff d0                	callq  *%rax
  805428:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80542b:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80542f:	78 79                	js     8054aa <pipe+0x1a0>
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  805431:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805435:	48 ba 00 81 82 00 00 	movabs $0x828100,%rdx
  80543c:	00 00 00 
  80543f:	8b 12                	mov    (%rdx),%edx
  805441:	89 10                	mov    %edx,(%rax)
	fd0->fd_omode = O_RDONLY;
  805443:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805447:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)

	fd1->fd_dev_id = devpipe.dev_id;
  80544e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805452:	48 ba 00 81 82 00 00 	movabs $0x828100,%rdx
  805459:	00 00 00 
  80545c:	8b 12                	mov    (%rdx),%edx
  80545e:	89 10                	mov    %edx,(%rax)
	fd1->fd_omode = O_WRONLY;
  805460:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805464:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%rax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", thisenv->env_id, uvpt[PGNUM(va)]);

	pfd[0] = fd2num(fd0);
  80546b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80546f:	48 89 c7             	mov    %rax,%rdi
  805472:	48 b8 4a 35 80 00 00 	movabs $0x80354a,%rax
  805479:	00 00 00 
  80547c:	ff d0                	callq  *%rax
  80547e:	89 c2                	mov    %eax,%edx
  805480:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  805484:	89 10                	mov    %edx,(%rax)
	pfd[1] = fd2num(fd1);
  805486:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80548a:	48 8d 58 04          	lea    0x4(%rax),%rbx
  80548e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805492:	48 89 c7             	mov    %rax,%rdi
  805495:	48 b8 4a 35 80 00 00 	movabs $0x80354a,%rax
  80549c:	00 00 00 
  80549f:	ff d0                	callq  *%rax
  8054a1:	89 03                	mov    %eax,(%rbx)
	return 0;
  8054a3:	b8 00 00 00 00       	mov    $0x0,%eax
  8054a8:	eb 4f                	jmp    8054f9 <pipe+0x1ef>
	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err3;
  8054aa:	90                   	nop
	pfd[0] = fd2num(fd0);
	pfd[1] = fd2num(fd1);
	return 0;

err3:
	sys_page_unmap(0, va);
  8054ab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8054af:	48 89 c6             	mov    %rax,%rsi
  8054b2:	bf 00 00 00 00       	mov    $0x0,%edi
  8054b7:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  8054be:	00 00 00 
  8054c1:	ff d0                	callq  *%rax
  8054c3:	eb 01                	jmp    8054c6 <pipe+0x1bc>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err2;
  8054c5:	90                   	nop
	return 0;

err3:
	sys_page_unmap(0, va);
err2:
	sys_page_unmap(0, fd1);
  8054c6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8054ca:	48 89 c6             	mov    %rax,%rsi
  8054cd:	bf 00 00 00 00       	mov    $0x0,%edi
  8054d2:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  8054d9:	00 00 00 
  8054dc:	ff d0                	callq  *%rax
err1:
	sys_page_unmap(0, fd0);
  8054de:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8054e2:	48 89 c6             	mov    %rax,%rsi
  8054e5:	bf 00 00 00 00       	mov    $0x0,%edi
  8054ea:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  8054f1:	00 00 00 
  8054f4:	ff d0                	callq  *%rax
err:
	return r;
  8054f6:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  8054f9:	48 83 c4 38          	add    $0x38,%rsp
  8054fd:	5b                   	pop    %rbx
  8054fe:	5d                   	pop    %rbp
  8054ff:	c3                   	retq   

0000000000805500 <_pipeisclosed>:

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  805500:	55                   	push   %rbp
  805501:	48 89 e5             	mov    %rsp,%rbp
  805504:	53                   	push   %rbx
  805505:	48 83 ec 28          	sub    $0x28,%rsp
  805509:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80550d:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)

	int n, nn, ret;

	while (1) {
		n = thisenv->env_runs;
  805511:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  805518:	00 00 00 
  80551b:	48 8b 00             	mov    (%rax),%rax
  80551e:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  805524:	89 45 ec             	mov    %eax,-0x14(%rbp)
		ret = pageref(fd) == pageref(p);
  805527:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80552b:	48 89 c7             	mov    %rax,%rdi
  80552e:	48 b8 a0 5c 80 00 00 	movabs $0x805ca0,%rax
  805535:	00 00 00 
  805538:	ff d0                	callq  *%rax
  80553a:	89 c3                	mov    %eax,%ebx
  80553c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805540:	48 89 c7             	mov    %rax,%rdi
  805543:	48 b8 a0 5c 80 00 00 	movabs $0x805ca0,%rax
  80554a:	00 00 00 
  80554d:	ff d0                	callq  *%rax
  80554f:	39 c3                	cmp    %eax,%ebx
  805551:	0f 94 c0             	sete   %al
  805554:	0f b6 c0             	movzbl %al,%eax
  805557:	89 45 e8             	mov    %eax,-0x18(%rbp)
		nn = thisenv->env_runs;
  80555a:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  805561:	00 00 00 
  805564:	48 8b 00             	mov    (%rax),%rax
  805567:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  80556d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if (n == nn)
  805570:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805573:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  805576:	75 05                	jne    80557d <_pipeisclosed+0x7d>
			return ret;
  805578:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80557b:	eb 4a                	jmp    8055c7 <_pipeisclosed+0xc7>
		if (n != nn && ret == 1)
  80557d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805580:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  805583:	74 8c                	je     805511 <_pipeisclosed+0x11>
  805585:	83 7d e8 01          	cmpl   $0x1,-0x18(%rbp)
  805589:	75 86                	jne    805511 <_pipeisclosed+0x11>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  80558b:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  805592:	00 00 00 
  805595:	48 8b 00             	mov    (%rax),%rax
  805598:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  80559e:	8b 4d e8             	mov    -0x18(%rbp),%ecx
  8055a1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8055a4:	89 c6                	mov    %eax,%esi
  8055a6:	48 bf 5d 18 82 00 00 	movabs $0x82185d,%rdi
  8055ad:	00 00 00 
  8055b0:	b8 00 00 00 00       	mov    $0x0,%eax
  8055b5:	49 b8 32 13 80 00 00 	movabs $0x801332,%r8
  8055bc:	00 00 00 
  8055bf:	41 ff d0             	callq  *%r8
	}
  8055c2:	e9 4a ff ff ff       	jmpq   805511 <_pipeisclosed+0x11>

}
  8055c7:	48 83 c4 28          	add    $0x28,%rsp
  8055cb:	5b                   	pop    %rbx
  8055cc:	5d                   	pop    %rbp
  8055cd:	c3                   	retq   

00000000008055ce <pipeisclosed>:

int
pipeisclosed(int fdnum)
{
  8055ce:	55                   	push   %rbp
  8055cf:	48 89 e5             	mov    %rsp,%rbp
  8055d2:	48 83 ec 30          	sub    $0x30,%rsp
  8055d6:	89 7d dc             	mov    %edi,-0x24(%rbp)
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8055d9:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  8055dd:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8055e0:	48 89 d6             	mov    %rdx,%rsi
  8055e3:	89 c7                	mov    %eax,%edi
  8055e5:	48 b8 30 36 80 00 00 	movabs $0x803630,%rax
  8055ec:	00 00 00 
  8055ef:	ff d0                	callq  *%rax
  8055f1:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8055f4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8055f8:	79 05                	jns    8055ff <pipeisclosed+0x31>
		return r;
  8055fa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8055fd:	eb 31                	jmp    805630 <pipeisclosed+0x62>
	p = (struct Pipe*) fd2data(fd);
  8055ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805603:	48 89 c7             	mov    %rax,%rdi
  805606:	48 b8 6d 35 80 00 00 	movabs $0x80356d,%rax
  80560d:	00 00 00 
  805610:	ff d0                	callq  *%rax
  805612:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	return _pipeisclosed(fd, p);
  805616:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80561a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80561e:	48 89 d6             	mov    %rdx,%rsi
  805621:	48 89 c7             	mov    %rax,%rdi
  805624:	48 b8 00 55 80 00 00 	movabs $0x805500,%rax
  80562b:	00 00 00 
  80562e:	ff d0                	callq  *%rax
}
  805630:	c9                   	leaveq 
  805631:	c3                   	retq   

0000000000805632 <devpipe_read>:

static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  805632:	55                   	push   %rbp
  805633:	48 89 e5             	mov    %rsp,%rbp
  805636:	48 83 ec 40          	sub    $0x40,%rsp
  80563a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80563e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  805642:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)

	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*)fd2data(fd);
  805646:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80564a:	48 89 c7             	mov    %rax,%rdi
  80564d:	48 b8 6d 35 80 00 00 	movabs $0x80356d,%rax
  805654:	00 00 00 
  805657:	ff d0                	callq  *%rax
  805659:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
  80565d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805661:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for (i = 0; i < n; i++) {
  805665:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80566c:	00 
  80566d:	e9 90 00 00 00       	jmpq   805702 <devpipe_read+0xd0>
		while (p->p_rpos == p->p_wpos) {
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
  805672:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  805677:	74 09                	je     805682 <devpipe_read+0x50>
				return i;
  805679:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80567d:	e9 8e 00 00 00       	jmpq   805710 <devpipe_read+0xde>
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
  805682:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  805686:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80568a:	48 89 d6             	mov    %rdx,%rsi
  80568d:	48 89 c7             	mov    %rax,%rdi
  805690:	48 b8 00 55 80 00 00 	movabs $0x805500,%rax
  805697:	00 00 00 
  80569a:	ff d0                	callq  *%rax
  80569c:	85 c0                	test   %eax,%eax
  80569e:	74 07                	je     8056a7 <devpipe_read+0x75>
				return 0;
  8056a0:	b8 00 00 00 00       	mov    $0x0,%eax
  8056a5:	eb 69                	jmp    805710 <devpipe_read+0xde>
			// yield and see what happens
			if (debug)
				cprintf("devpipe_read yield\n");
			sys_yield();
  8056a7:	48 b8 bb 27 80 00 00 	movabs $0x8027bb,%rax
  8056ae:	00 00 00 
  8056b1:	ff d0                	callq  *%rax
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_rpos == p->p_wpos) {
  8056b3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8056b7:	8b 10                	mov    (%rax),%edx
  8056b9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8056bd:	8b 40 04             	mov    0x4(%rax),%eax
  8056c0:	39 c2                	cmp    %eax,%edx
  8056c2:	74 ae                	je     805672 <devpipe_read+0x40>
				cprintf("devpipe_read yield\n");
			sys_yield();
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  8056c4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8056c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8056cc:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8056d0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8056d4:	8b 00                	mov    (%rax),%eax
  8056d6:	99                   	cltd   
  8056d7:	c1 ea 1b             	shr    $0x1b,%edx
  8056da:	01 d0                	add    %edx,%eax
  8056dc:	83 e0 1f             	and    $0x1f,%eax
  8056df:	29 d0                	sub    %edx,%eax
  8056e1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8056e5:	48 98                	cltq   
  8056e7:	0f b6 44 02 08       	movzbl 0x8(%rdx,%rax,1),%eax
  8056ec:	88 01                	mov    %al,(%rcx)
		p->p_rpos++;
  8056ee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8056f2:	8b 00                	mov    (%rax),%eax
  8056f4:	8d 50 01             	lea    0x1(%rax),%edx
  8056f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8056fb:	89 10                	mov    %edx,(%rax)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8056fd:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  805702:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805706:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80570a:	72 a7                	jb     8056b3 <devpipe_read+0x81>
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
  80570c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax

}
  805710:	c9                   	leaveq 
  805711:	c3                   	retq   

0000000000805712 <devpipe_write>:

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  805712:	55                   	push   %rbp
  805713:	48 89 e5             	mov    %rsp,%rbp
  805716:	48 83 ec 40          	sub    $0x40,%rsp
  80571a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80571e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  805722:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)

	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*) fd2data(fd);
  805726:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80572a:	48 89 c7             	mov    %rax,%rdi
  80572d:	48 b8 6d 35 80 00 00 	movabs $0x80356d,%rax
  805734:	00 00 00 
  805737:	ff d0                	callq  *%rax
  805739:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
  80573d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805741:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for (i = 0; i < n; i++) {
  805745:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80574c:	00 
  80574d:	e9 8f 00 00 00       	jmpq   8057e1 <devpipe_write+0xcf>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
  805752:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  805756:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80575a:	48 89 d6             	mov    %rdx,%rsi
  80575d:	48 89 c7             	mov    %rax,%rdi
  805760:	48 b8 00 55 80 00 00 	movabs $0x805500,%rax
  805767:	00 00 00 
  80576a:	ff d0                	callq  *%rax
  80576c:	85 c0                	test   %eax,%eax
  80576e:	74 07                	je     805777 <devpipe_write+0x65>
				return 0;
  805770:	b8 00 00 00 00       	mov    $0x0,%eax
  805775:	eb 78                	jmp    8057ef <devpipe_write+0xdd>
			// yield and see what happens
			if (debug)
				cprintf("devpipe_write yield\n");
			sys_yield();
  805777:	48 b8 bb 27 80 00 00 	movabs $0x8027bb,%rax
  80577e:	00 00 00 
  805781:	ff d0                	callq  *%rax
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  805783:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805787:	8b 40 04             	mov    0x4(%rax),%eax
  80578a:	48 63 d0             	movslq %eax,%rdx
  80578d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805791:	8b 00                	mov    (%rax),%eax
  805793:	48 98                	cltq   
  805795:	48 83 c0 20          	add    $0x20,%rax
  805799:	48 39 c2             	cmp    %rax,%rdx
  80579c:	73 b4                	jae    805752 <devpipe_write+0x40>
				cprintf("devpipe_write yield\n");
			sys_yield();
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  80579e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8057a2:	8b 40 04             	mov    0x4(%rax),%eax
  8057a5:	99                   	cltd   
  8057a6:	c1 ea 1b             	shr    $0x1b,%edx
  8057a9:	01 d0                	add    %edx,%eax
  8057ab:	83 e0 1f             	and    $0x1f,%eax
  8057ae:	29 d0                	sub    %edx,%eax
  8057b0:	89 c6                	mov    %eax,%esi
  8057b2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8057b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8057ba:	48 01 d0             	add    %rdx,%rax
  8057bd:	0f b6 08             	movzbl (%rax),%ecx
  8057c0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8057c4:	48 63 c6             	movslq %esi,%rax
  8057c7:	88 4c 02 08          	mov    %cl,0x8(%rdx,%rax,1)
		p->p_wpos++;
  8057cb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8057cf:	8b 40 04             	mov    0x4(%rax),%eax
  8057d2:	8d 50 01             	lea    0x1(%rax),%edx
  8057d5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8057d9:	89 50 04             	mov    %edx,0x4(%rax)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8057dc:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8057e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8057e5:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8057e9:	72 98                	jb     805783 <devpipe_write+0x71>
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
  8057eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax

}
  8057ef:	c9                   	leaveq 
  8057f0:	c3                   	retq   

00000000008057f1 <devpipe_stat>:

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  8057f1:	55                   	push   %rbp
  8057f2:	48 89 e5             	mov    %rsp,%rbp
  8057f5:	48 83 ec 20          	sub    $0x20,%rsp
  8057f9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8057fd:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  805801:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805805:	48 89 c7             	mov    %rax,%rdi
  805808:	48 b8 6d 35 80 00 00 	movabs $0x80356d,%rax
  80580f:	00 00 00 
  805812:	ff d0                	callq  *%rax
  805814:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	strcpy(stat->st_name, "<pipe>");
  805818:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80581c:	48 be 70 18 82 00 00 	movabs $0x821870,%rsi
  805823:	00 00 00 
  805826:	48 89 c7             	mov    %rax,%rdi
  805829:	48 b8 c2 1e 80 00 00 	movabs $0x801ec2,%rax
  805830:	00 00 00 
  805833:	ff d0                	callq  *%rax
	stat->st_size = p->p_wpos - p->p_rpos;
  805835:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805839:	8b 50 04             	mov    0x4(%rax),%edx
  80583c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805840:	8b 00                	mov    (%rax),%eax
  805842:	29 c2                	sub    %eax,%edx
  805844:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805848:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)
	stat->st_isdir = 0;
  80584e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805852:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%rax)
  805859:	00 00 00 
	stat->st_dev = &devpipe;
  80585c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805860:	48 b9 00 81 82 00 00 	movabs $0x828100,%rcx
  805867:	00 00 00 
  80586a:	48 89 88 88 00 00 00 	mov    %rcx,0x88(%rax)
	return 0;
  805871:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805876:	c9                   	leaveq 
  805877:	c3                   	retq   

0000000000805878 <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  805878:	55                   	push   %rbp
  805879:	48 89 e5             	mov    %rsp,%rbp
  80587c:	48 83 ec 10          	sub    $0x10,%rsp
  805880:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

	(void) sys_page_unmap(0, fd);
  805884:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805888:	48 89 c6             	mov    %rax,%rsi
  80588b:	bf 00 00 00 00       	mov    $0x0,%edi
  805890:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  805897:	00 00 00 
  80589a:	ff d0                	callq  *%rax

	return sys_page_unmap(0, fd2data(fd));
  80589c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8058a0:	48 89 c7             	mov    %rax,%rdi
  8058a3:	48 b8 6d 35 80 00 00 	movabs $0x80356d,%rax
  8058aa:	00 00 00 
  8058ad:	ff d0                	callq  *%rax
  8058af:	48 89 c6             	mov    %rax,%rsi
  8058b2:	bf 00 00 00 00       	mov    $0x0,%edi
  8058b7:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  8058be:	00 00 00 
  8058c1:	ff d0                	callq  *%rax
}
  8058c3:	c9                   	leaveq 
  8058c4:	c3                   	retq   

00000000008058c5 <cputchar>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  8058c5:	55                   	push   %rbp
  8058c6:	48 89 e5             	mov    %rsp,%rbp
  8058c9:	48 83 ec 20          	sub    $0x20,%rsp
  8058cd:	89 7d ec             	mov    %edi,-0x14(%rbp)
	char c = ch;
  8058d0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8058d3:	88 45 ff             	mov    %al,-0x1(%rbp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  8058d6:	48 8d 45 ff          	lea    -0x1(%rbp),%rax
  8058da:	be 01 00 00 00       	mov    $0x1,%esi
  8058df:	48 89 c7             	mov    %rax,%rdi
  8058e2:	48 b8 b0 26 80 00 00 	movabs $0x8026b0,%rax
  8058e9:	00 00 00 
  8058ec:	ff d0                	callq  *%rax
}
  8058ee:	90                   	nop
  8058ef:	c9                   	leaveq 
  8058f0:	c3                   	retq   

00000000008058f1 <getchar>:

int
getchar(void)
{
  8058f1:	55                   	push   %rbp
  8058f2:	48 89 e5             	mov    %rsp,%rbp
  8058f5:	48 83 ec 10          	sub    $0x10,%rsp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  8058f9:	48 8d 45 fb          	lea    -0x5(%rbp),%rax
  8058fd:	ba 01 00 00 00       	mov    $0x1,%edx
  805902:	48 89 c6             	mov    %rax,%rsi
  805905:	bf 00 00 00 00       	mov    $0x0,%edi
  80590a:	48 b8 65 3a 80 00 00 	movabs $0x803a65,%rax
  805911:	00 00 00 
  805914:	ff d0                	callq  *%rax
  805916:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (r < 0)
  805919:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80591d:	79 05                	jns    805924 <getchar+0x33>
		return r;
  80591f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805922:	eb 14                	jmp    805938 <getchar+0x47>
	if (r < 1)
  805924:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805928:	7f 07                	jg     805931 <getchar+0x40>
		return -E_EOF;
  80592a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80592f:	eb 07                	jmp    805938 <getchar+0x47>
	return c;
  805931:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  805935:	0f b6 c0             	movzbl %al,%eax

}
  805938:	c9                   	leaveq 
  805939:	c3                   	retq   

000000000080593a <iscons>:
	.dev_stat =	devcons_stat
};

int
iscons(int fdnum)
{
  80593a:	55                   	push   %rbp
  80593b:	48 89 e5             	mov    %rsp,%rbp
  80593e:	48 83 ec 20          	sub    $0x20,%rsp
  805942:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  805945:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  805949:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80594c:	48 89 d6             	mov    %rdx,%rsi
  80594f:	89 c7                	mov    %eax,%edi
  805951:	48 b8 30 36 80 00 00 	movabs $0x803630,%rax
  805958:	00 00 00 
  80595b:	ff d0                	callq  *%rax
  80595d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  805960:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805964:	79 05                	jns    80596b <iscons+0x31>
		return r;
  805966:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805969:	eb 1a                	jmp    805985 <iscons+0x4b>
	return fd->fd_dev_id == devcons.dev_id;
  80596b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80596f:	8b 10                	mov    (%rax),%edx
  805971:	48 b8 40 81 82 00 00 	movabs $0x828140,%rax
  805978:	00 00 00 
  80597b:	8b 00                	mov    (%rax),%eax
  80597d:	39 c2                	cmp    %eax,%edx
  80597f:	0f 94 c0             	sete   %al
  805982:	0f b6 c0             	movzbl %al,%eax
}
  805985:	c9                   	leaveq 
  805986:	c3                   	retq   

0000000000805987 <opencons>:

int
opencons(void)
{
  805987:	55                   	push   %rbp
  805988:	48 89 e5             	mov    %rsp,%rbp
  80598b:	48 83 ec 10          	sub    $0x10,%rsp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  80598f:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  805993:	48 89 c7             	mov    %rax,%rdi
  805996:	48 b8 98 35 80 00 00 	movabs $0x803598,%rax
  80599d:	00 00 00 
  8059a0:	ff d0                	callq  *%rax
  8059a2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8059a5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8059a9:	79 05                	jns    8059b0 <opencons+0x29>
		return r;
  8059ab:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8059ae:	eb 5b                	jmp    805a0b <opencons+0x84>
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  8059b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8059b4:	ba 07 04 00 00       	mov    $0x407,%edx
  8059b9:	48 89 c6             	mov    %rax,%rsi
  8059bc:	bf 00 00 00 00       	mov    $0x0,%edi
  8059c1:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  8059c8:	00 00 00 
  8059cb:	ff d0                	callq  *%rax
  8059cd:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8059d0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8059d4:	79 05                	jns    8059db <opencons+0x54>
		return r;
  8059d6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8059d9:	eb 30                	jmp    805a0b <opencons+0x84>
	fd->fd_dev_id = devcons.dev_id;
  8059db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8059df:	48 ba 40 81 82 00 00 	movabs $0x828140,%rdx
  8059e6:	00 00 00 
  8059e9:	8b 12                	mov    (%rdx),%edx
  8059eb:	89 10                	mov    %edx,(%rax)
	fd->fd_omode = O_RDWR;
  8059ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8059f1:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%rax)
	return fd2num(fd);
  8059f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8059fc:	48 89 c7             	mov    %rax,%rdi
  8059ff:	48 b8 4a 35 80 00 00 	movabs $0x80354a,%rax
  805a06:	00 00 00 
  805a09:	ff d0                	callq  *%rax
}
  805a0b:	c9                   	leaveq 
  805a0c:	c3                   	retq   

0000000000805a0d <devcons_read>:

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  805a0d:	55                   	push   %rbp
  805a0e:	48 89 e5             	mov    %rsp,%rbp
  805a11:	48 83 ec 30          	sub    $0x30,%rsp
  805a15:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  805a19:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  805a1d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int c;

	if (n == 0)
  805a21:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  805a26:	75 13                	jne    805a3b <devcons_read+0x2e>
		return 0;
  805a28:	b8 00 00 00 00       	mov    $0x0,%eax
  805a2d:	eb 49                	jmp    805a78 <devcons_read+0x6b>

	while ((c = sys_cgetc()) == 0)
		sys_yield();
  805a2f:	48 b8 bb 27 80 00 00 	movabs $0x8027bb,%rax
  805a36:	00 00 00 
  805a39:	ff d0                	callq  *%rax
	int c;

	if (n == 0)
		return 0;

	while ((c = sys_cgetc()) == 0)
  805a3b:	48 b8 fd 26 80 00 00 	movabs $0x8026fd,%rax
  805a42:	00 00 00 
  805a45:	ff d0                	callq  *%rax
  805a47:	89 45 fc             	mov    %eax,-0x4(%rbp)
  805a4a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805a4e:	74 df                	je     805a2f <devcons_read+0x22>
		sys_yield();
	if (c < 0)
  805a50:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805a54:	79 05                	jns    805a5b <devcons_read+0x4e>
		return c;
  805a56:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805a59:	eb 1d                	jmp    805a78 <devcons_read+0x6b>
	if (c == 0x04)	// ctl-d is eof
  805a5b:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  805a5f:	75 07                	jne    805a68 <devcons_read+0x5b>
		return 0;
  805a61:	b8 00 00 00 00       	mov    $0x0,%eax
  805a66:	eb 10                	jmp    805a78 <devcons_read+0x6b>
	*(char*)vbuf = c;
  805a68:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805a6b:	89 c2                	mov    %eax,%edx
  805a6d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805a71:	88 10                	mov    %dl,(%rax)
	return 1;
  805a73:	b8 01 00 00 00       	mov    $0x1,%eax
}
  805a78:	c9                   	leaveq 
  805a79:	c3                   	retq   

0000000000805a7a <devcons_write>:

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  805a7a:	55                   	push   %rbp
  805a7b:	48 89 e5             	mov    %rsp,%rbp
  805a7e:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  805a85:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  805a8c:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  805a93:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  805a9a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  805aa1:	eb 76                	jmp    805b19 <devcons_write+0x9f>
		m = n - tot;
  805aa3:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  805aaa:	89 c2                	mov    %eax,%edx
  805aac:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805aaf:	29 c2                	sub    %eax,%edx
  805ab1:	89 d0                	mov    %edx,%eax
  805ab3:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (m > sizeof(buf) - 1)
  805ab6:	8b 45 f8             	mov    -0x8(%rbp),%eax
  805ab9:	83 f8 7f             	cmp    $0x7f,%eax
  805abc:	76 07                	jbe    805ac5 <devcons_write+0x4b>
			m = sizeof(buf) - 1;
  805abe:	c7 45 f8 7f 00 00 00 	movl   $0x7f,-0x8(%rbp)
		memmove(buf, (char*)vbuf + tot, m);
  805ac5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  805ac8:	48 63 d0             	movslq %eax,%rdx
  805acb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805ace:	48 63 c8             	movslq %eax,%rcx
  805ad1:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  805ad8:	48 01 c1             	add    %rax,%rcx
  805adb:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  805ae2:	48 89 ce             	mov    %rcx,%rsi
  805ae5:	48 89 c7             	mov    %rax,%rdi
  805ae8:	48 b8 e7 21 80 00 00 	movabs $0x8021e7,%rax
  805aef:	00 00 00 
  805af2:	ff d0                	callq  *%rax
		sys_cputs(buf, m);
  805af4:	8b 45 f8             	mov    -0x8(%rbp),%eax
  805af7:	48 63 d0             	movslq %eax,%rdx
  805afa:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  805b01:	48 89 d6             	mov    %rdx,%rsi
  805b04:	48 89 c7             	mov    %rax,%rdi
  805b07:	48 b8 b0 26 80 00 00 	movabs $0x8026b0,%rax
  805b0e:	00 00 00 
  805b11:	ff d0                	callq  *%rax
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  805b13:	8b 45 f8             	mov    -0x8(%rbp),%eax
  805b16:	01 45 fc             	add    %eax,-0x4(%rbp)
  805b19:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805b1c:	48 98                	cltq   
  805b1e:	48 3b 85 58 ff ff ff 	cmp    -0xa8(%rbp),%rax
  805b25:	0f 82 78 ff ff ff    	jb     805aa3 <devcons_write+0x29>
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
		sys_cputs(buf, m);
	}
	return tot;
  805b2b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  805b2e:	c9                   	leaveq 
  805b2f:	c3                   	retq   

0000000000805b30 <devcons_close>:

static int
devcons_close(struct Fd *fd)
{
  805b30:	55                   	push   %rbp
  805b31:	48 89 e5             	mov    %rsp,%rbp
  805b34:	48 83 ec 08          	sub    $0x8,%rsp
  805b38:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	USED(fd);

	return 0;
  805b3c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805b41:	c9                   	leaveq 
  805b42:	c3                   	retq   

0000000000805b43 <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  805b43:	55                   	push   %rbp
  805b44:	48 89 e5             	mov    %rsp,%rbp
  805b47:	48 83 ec 10          	sub    $0x10,%rsp
  805b4b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  805b4f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	strcpy(stat->st_name, "<cons>");
  805b53:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805b57:	48 be 7c 18 82 00 00 	movabs $0x82187c,%rsi
  805b5e:	00 00 00 
  805b61:	48 89 c7             	mov    %rax,%rdi
  805b64:	48 b8 c2 1e 80 00 00 	movabs $0x801ec2,%rax
  805b6b:	00 00 00 
  805b6e:	ff d0                	callq  *%rax
	return 0;
  805b70:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805b75:	c9                   	leaveq 
  805b76:	c3                   	retq   

0000000000805b77 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  805b77:	55                   	push   %rbp
  805b78:	48 89 e5             	mov    %rsp,%rbp
  805b7b:	48 83 ec 20          	sub    $0x20,%rsp
  805b7f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;

	if (_pgfault_handler == 0) {
  805b83:	48 b8 00 b0 b5 00 00 	movabs $0xb5b000,%rax
  805b8a:	00 00 00 
  805b8d:	48 8b 00             	mov    (%rax),%rax
  805b90:	48 85 c0             	test   %rax,%rax
  805b93:	75 6f                	jne    805c04 <set_pgfault_handler+0x8d>

		// map exception stack
		if ((r = sys_page_alloc(0, (void*) (UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
  805b95:	ba 07 00 00 00       	mov    $0x7,%edx
  805b9a:	be 00 f0 7f ef       	mov    $0xef7ff000,%esi
  805b9f:	bf 00 00 00 00       	mov    $0x0,%edi
  805ba4:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  805bab:	00 00 00 
  805bae:	ff d0                	callq  *%rax
  805bb0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  805bb3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805bb7:	79 30                	jns    805be9 <set_pgfault_handler+0x72>
			panic("allocating exception stack: %e", r);
  805bb9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805bbc:	89 c1                	mov    %eax,%ecx
  805bbe:	48 ba 88 18 82 00 00 	movabs $0x821888,%rdx
  805bc5:	00 00 00 
  805bc8:	be 22 00 00 00       	mov    $0x22,%esi
  805bcd:	48 bf a7 18 82 00 00 	movabs $0x8218a7,%rdi
  805bd4:	00 00 00 
  805bd7:	b8 00 00 00 00       	mov    $0x0,%eax
  805bdc:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  805be3:	00 00 00 
  805be6:	41 ff d0             	callq  *%r8

		// register assembly pgfault entrypoint with JOS kernel
		sys_env_set_pgfault_upcall(0, (void*) _pgfault_upcall);
  805be9:	48 be 18 5c 80 00 00 	movabs $0x805c18,%rsi
  805bf0:	00 00 00 
  805bf3:	bf 00 00 00 00       	mov    $0x0,%edi
  805bf8:	48 b8 8f 29 80 00 00 	movabs $0x80298f,%rax
  805bff:	00 00 00 
  805c02:	ff d0                	callq  *%rax

	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  805c04:	48 b8 00 b0 b5 00 00 	movabs $0xb5b000,%rax
  805c0b:	00 00 00 
  805c0e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  805c12:	48 89 10             	mov    %rdx,(%rax)
}
  805c15:	90                   	nop
  805c16:	c9                   	leaveq 
  805c17:	c3                   	retq   

0000000000805c18 <_pgfault_upcall>:
.globl _pgfault_upcall
_pgfault_upcall:
// Call the C page fault handler.
// function argument: pointer to UTF

movq  %rsp,%rdi                // passing the function argument in rdi
  805c18:	48 89 e7             	mov    %rsp,%rdi
movabs _pgfault_handler, %rax
  805c1b:	48 a1 00 b0 b5 00 00 	movabs 0xb5b000,%rax
  805c22:	00 00 00 
call *%rax
  805c25:	ff d0                	callq  *%rax
// registers are available for intermediate calculations.  You
// may find that you have to rearrange your code in non-obvious
// ways as registers become unavailable as scratch space.
//
// LAB 4: Your code here.
subq $8, 152(%rsp)
  805c27:	48 83 ac 24 98 00 00 	subq   $0x8,0x98(%rsp)
  805c2e:	00 08 
    movq 152(%rsp), %rax
  805c30:	48 8b 84 24 98 00 00 	mov    0x98(%rsp),%rax
  805c37:	00 
    movq 136(%rsp), %rbx
  805c38:	48 8b 9c 24 88 00 00 	mov    0x88(%rsp),%rbx
  805c3f:	00 
movq %rbx, (%rax)
  805c40:	48 89 18             	mov    %rbx,(%rax)

    // Restore the trap-time registers.  After you do this, you
    // can no longer modify any general-purpose registers.
    // LAB 4: Your code here.
    addq $16, %rsp
  805c43:	48 83 c4 10          	add    $0x10,%rsp
    POPA_
  805c47:	4c 8b 3c 24          	mov    (%rsp),%r15
  805c4b:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  805c50:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  805c55:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  805c5a:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  805c5f:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  805c64:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  805c69:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  805c6e:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  805c73:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  805c78:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  805c7d:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  805c82:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  805c87:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  805c8c:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  805c91:	48 83 c4 78          	add    $0x78,%rsp

    // Restore eflags from the stack.  After you do this, you can
    // no longer use arithmetic operations or anything else that
    // modifies eflags.
    // LAB 4: Your code here.
pushq 8(%rsp)
  805c95:	ff 74 24 08          	pushq  0x8(%rsp)
    popfq
  805c99:	9d                   	popfq  

    // Switch back to the adjusted trap-time stack.
    // LAB 4: Your code here.
    movq 16(%rsp), %rsp
  805c9a:	48 8b 64 24 10       	mov    0x10(%rsp),%rsp

    // Return to re-execute the instruction that faulted.
    // LAB 4: Your code here.
    retq
  805c9f:	c3                   	retq   

0000000000805ca0 <pageref>:

#include <inc/lib.h>

int
pageref(void *v)
{
  805ca0:	55                   	push   %rbp
  805ca1:	48 89 e5             	mov    %rsp,%rbp
  805ca4:	48 83 ec 18          	sub    $0x18,%rsp
  805ca8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	pte_t pte;

	if (!(uvpd[VPD(v)] & PTE_P))
  805cac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805cb0:	48 c1 e8 15          	shr    $0x15,%rax
  805cb4:	48 89 c2             	mov    %rax,%rdx
  805cb7:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  805cbe:	01 00 00 
  805cc1:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  805cc5:	83 e0 01             	and    $0x1,%eax
  805cc8:	48 85 c0             	test   %rax,%rax
  805ccb:	75 07                	jne    805cd4 <pageref+0x34>
		return 0;
  805ccd:	b8 00 00 00 00       	mov    $0x0,%eax
  805cd2:	eb 56                	jmp    805d2a <pageref+0x8a>
	pte = uvpt[PGNUM(v)];
  805cd4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805cd8:	48 c1 e8 0c          	shr    $0xc,%rax
  805cdc:	48 89 c2             	mov    %rax,%rdx
  805cdf:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  805ce6:	01 00 00 
  805ce9:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  805ced:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!(pte & PTE_P))
  805cf1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805cf5:	83 e0 01             	and    $0x1,%eax
  805cf8:	48 85 c0             	test   %rax,%rax
  805cfb:	75 07                	jne    805d04 <pageref+0x64>
		return 0;
  805cfd:	b8 00 00 00 00       	mov    $0x0,%eax
  805d02:	eb 26                	jmp    805d2a <pageref+0x8a>
	return pages[PPN(pte)].pp_ref;
  805d04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805d08:	48 c1 e8 0c          	shr    $0xc,%rax
  805d0c:	48 89 c2             	mov    %rax,%rdx
  805d0f:	48 b8 00 00 a0 00 80 	movabs $0x8000a00000,%rax
  805d16:	00 00 00 
  805d19:	48 c1 e2 04          	shl    $0x4,%rdx
  805d1d:	48 01 d0             	add    %rdx,%rax
  805d20:	48 83 c0 08          	add    $0x8,%rax
  805d24:	0f b7 00             	movzwl (%rax),%eax
  805d27:	0f b7 c0             	movzwl %ax,%eax
}
  805d2a:	c9                   	leaveq 
  805d2b:	c3                   	retq   

0000000000805d2c <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  805d2c:	55                   	push   %rbp
  805d2d:	48 89 e5             	mov    %rsp,%rbp
  socksem   = sys_sem_new(1);
  805d30:	bf 01 00 00 00       	mov    $0x1,%edi
  805d35:	48 b8 5c 7f 81 00 00 	movabs $0x817f5c,%rax
  805d3c:	00 00 00 
  805d3f:	ff d0                	callq  *%rax
  805d41:	89 c2                	mov    %eax,%edx
  805d43:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805d4a:	00 00 00 
  805d4d:	89 10                	mov    %edx,(%rax)
  selectsem = sys_sem_new(1);
  805d4f:	bf 01 00 00 00       	mov    $0x1,%edi
  805d54:	48 b8 5c 7f 81 00 00 	movabs $0x817f5c,%rax
  805d5b:	00 00 00 
  805d5e:	ff d0                	callq  *%rax
  805d60:	89 c2                	mov    %eax,%edx
  805d62:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  805d69:	00 00 00 
  805d6c:	89 10                	mov    %edx,(%rax)
}
  805d6e:	90                   	nop
  805d6f:	5d                   	pop    %rbp
  805d70:	c3                   	retq   

0000000000805d71 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  805d71:	55                   	push   %rbp
  805d72:	48 89 e5             	mov    %rsp,%rbp
  805d75:	48 83 ec 18          	sub    $0x18,%rsp
  805d79:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  805d7c:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  805d80:	78 06                	js     805d88 <get_socket+0x17>
  805d82:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  805d86:	7e 17                	jle    805d9f <get_socket+0x2e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  805d88:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805d8f:	00 00 00 
  805d92:	c7 00 09 00 00 00    	movl   $0x9,(%rax)
    return NULL;
  805d98:	b8 00 00 00 00       	mov    $0x0,%eax
  805d9d:	eb 44                	jmp    805de3 <get_socket+0x72>
  }

  sock = &sockets[s];
  805d9f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805da2:	48 98                	cltq   
  805da4:	48 c1 e0 05          	shl    $0x5,%rax
  805da8:	48 89 c2             	mov    %rax,%rdx
  805dab:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805db2:	00 00 00 
  805db5:	48 01 d0             	add    %rdx,%rax
  805db8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if (!sock->conn) {
  805dbc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805dc0:	48 8b 00             	mov    (%rax),%rax
  805dc3:	48 85 c0             	test   %rax,%rax
  805dc6:	75 17                	jne    805ddf <get_socket+0x6e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  805dc8:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805dcf:	00 00 00 
  805dd2:	c7 00 09 00 00 00    	movl   $0x9,(%rax)
    return NULL;
  805dd8:	b8 00 00 00 00       	mov    $0x0,%eax
  805ddd:	eb 04                	jmp    805de3 <get_socket+0x72>
  }

  return sock;
  805ddf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  805de3:	c9                   	leaveq 
  805de4:	c3                   	retq   

0000000000805de5 <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  805de5:	55                   	push   %rbp
  805de6:	48 89 e5             	mov    %rsp,%rbp
  805de9:	48 83 ec 20          	sub    $0x20,%rsp
  805ded:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  805df1:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805df8:	00 00 00 
  805dfb:	8b 00                	mov    (%rax),%eax
  805dfd:	89 c7                	mov    %eax,%edi
  805dff:	48 b8 77 e7 80 00 00 	movabs $0x80e777,%rax
  805e06:	00 00 00 
  805e09:	ff d0                	callq  *%rax

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  805e0b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  805e12:	e9 27 01 00 00       	jmpq   805f3e <alloc_socket+0x159>
    if (!sockets[i].conn) {
  805e17:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805e1e:	00 00 00 
  805e21:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805e24:	48 63 d2             	movslq %edx,%rdx
  805e27:	48 c1 e2 05          	shl    $0x5,%rdx
  805e2b:	48 01 d0             	add    %rdx,%rax
  805e2e:	48 8b 00             	mov    (%rax),%rax
  805e31:	48 85 c0             	test   %rax,%rax
  805e34:	0f 85 00 01 00 00    	jne    805f3a <alloc_socket+0x155>
      sockets[i].conn       = newconn;
  805e3a:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805e41:	00 00 00 
  805e44:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805e47:	48 63 d2             	movslq %edx,%rdx
  805e4a:	48 c1 e2 05          	shl    $0x5,%rdx
  805e4e:	48 01 c2             	add    %rax,%rdx
  805e51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805e55:	48 89 02             	mov    %rax,(%rdx)
      sockets[i].lastdata   = NULL;
  805e58:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805e5f:	00 00 00 
  805e62:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805e65:	48 63 d2             	movslq %edx,%rdx
  805e68:	48 c1 e2 05          	shl    $0x5,%rdx
  805e6c:	48 01 d0             	add    %rdx,%rax
  805e6f:	48 83 c0 08          	add    $0x8,%rax
  805e73:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      sockets[i].lastoffset = 0;
  805e7a:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805e81:	00 00 00 
  805e84:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805e87:	48 63 d2             	movslq %edx,%rdx
  805e8a:	48 c1 e2 05          	shl    $0x5,%rdx
  805e8e:	48 01 d0             	add    %rdx,%rax
  805e91:	48 83 c0 10          	add    $0x10,%rax
  805e95:	66 c7 00 00 00       	movw   $0x0,(%rax)
      sockets[i].rcvevent   = 0;
  805e9a:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805ea1:	00 00 00 
  805ea4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805ea7:	48 63 d2             	movslq %edx,%rdx
  805eaa:	48 c1 e2 05          	shl    $0x5,%rdx
  805eae:	48 01 d0             	add    %rdx,%rax
  805eb1:	48 83 c0 12          	add    $0x12,%rax
  805eb5:	66 c7 00 00 00       	movw   $0x0,(%rax)
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  805eba:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805ec1:	00 00 00 
  805ec4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805ec7:	48 63 d2             	movslq %edx,%rdx
  805eca:	48 c1 e2 05          	shl    $0x5,%rdx
  805ece:	48 01 d0             	add    %rdx,%rax
  805ed1:	48 83 c0 14          	add    $0x14,%rax
  805ed5:	66 c7 00 01 00       	movw   $0x1,(%rax)
      sockets[i].flags      = 0;
  805eda:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805ee1:	00 00 00 
  805ee4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805ee7:	48 63 d2             	movslq %edx,%rdx
  805eea:	48 c1 e2 05          	shl    $0x5,%rdx
  805eee:	48 01 d0             	add    %rdx,%rax
  805ef1:	48 83 c0 16          	add    $0x16,%rax
  805ef5:	66 c7 00 00 00       	movw   $0x0,(%rax)
      sockets[i].err        = 0;
  805efa:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805f01:	00 00 00 
  805f04:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805f07:	48 63 d2             	movslq %edx,%rdx
  805f0a:	48 c1 e2 05          	shl    $0x5,%rdx
  805f0e:	48 01 d0             	add    %rdx,%rax
  805f11:	48 83 c0 18          	add    $0x18,%rax
  805f15:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
      sys_sem_signal(socksem);
  805f1b:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805f22:	00 00 00 
  805f25:	8b 00                	mov    (%rax),%eax
  805f27:	89 c7                	mov    %eax,%edi
  805f29:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  805f30:	00 00 00 
  805f33:	ff d0                	callq  *%rax
      return i;
  805f35:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805f38:	eb 2d                	jmp    805f67 <alloc_socket+0x182>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  805f3a:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  805f3e:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  805f42:	0f 8e cf fe ff ff    	jle    805e17 <alloc_socket+0x32>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  805f48:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805f4f:	00 00 00 
  805f52:	8b 00                	mov    (%rax),%eax
  805f54:	89 c7                	mov    %eax,%edi
  805f56:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  805f5d:	00 00 00 
  805f60:	ff d0                	callq  *%rax
  return -1;
  805f62:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  805f67:	c9                   	leaveq 
  805f68:	c3                   	retq   

0000000000805f69 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  805f69:	55                   	push   %rbp
  805f6a:	48 89 e5             	mov    %rsp,%rbp
  805f6d:	48 83 ec 70          	sub    $0x70,%rsp
  805f71:	89 7d ac             	mov    %edi,-0x54(%rbp)
  805f74:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  805f78:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  805f7c:	8b 45 ac             	mov    -0x54(%rbp),%eax
  805f7f:	89 c7                	mov    %eax,%edi
  805f81:	48 b8 71 5d 80 00 00 	movabs $0x805d71,%rax
  805f88:	00 00 00 
  805f8b:	ff d0                	callq  *%rax
  805f8d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  805f91:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  805f96:	75 0a                	jne    805fa2 <lwip_accept+0x39>
    return -1;
  805f98:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805f9d:	e9 f2 02 00 00       	jmpq   806294 <lwip_accept+0x32b>

  newconn = netconn_accept(sock->conn);
  805fa2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805fa6:	48 8b 00             	mov    (%rax),%rax
  805fa9:	48 89 c7             	mov    %rax,%rdi
  805fac:	48 b8 49 a1 81 00 00 	movabs $0x81a149,%rax
  805fb3:	00 00 00 
  805fb6:	ff d0                	callq  *%rax
  805fb8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!newconn) {
  805fbc:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  805fc1:	75 62                	jne    806025 <lwip_accept+0xbc>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  805fc3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805fc7:	48 8b 00             	mov    (%rax),%rax
  805fca:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  805fce:	0f be c0             	movsbl %al,%eax
  805fd1:	f7 d8                	neg    %eax
  805fd3:	83 f8 0e             	cmp    $0xe,%eax
  805fd6:	77 24                	ja     805ffc <lwip_accept+0x93>
  805fd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805fdc:	48 8b 00             	mov    (%rax),%rax
  805fdf:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  805fe3:	0f be c0             	movsbl %al,%eax
  805fe6:	f7 d8                	neg    %eax
  805fe8:	89 c2                	mov    %eax,%edx
  805fea:	48 b8 c0 18 82 00 00 	movabs $0x8218c0,%rax
  805ff1:	00 00 00 
  805ff4:	48 63 d2             	movslq %edx,%rdx
  805ff7:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  805ffa:	eb 05                	jmp    806001 <lwip_accept+0x98>
  805ffc:	b8 05 00 00 00       	mov    $0x5,%eax
  806001:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  806005:	89 42 18             	mov    %eax,0x18(%rdx)
  806008:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80600c:	8b 50 18             	mov    0x18(%rax),%edx
  80600f:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806016:	00 00 00 
  806019:	89 10                	mov    %edx,(%rax)
    return -1;
  80601b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806020:	e9 6f 02 00 00       	jmpq   806294 <lwip_accept+0x32b>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  806025:	48 8d 55 ce          	lea    -0x32(%rbp),%rdx
  806029:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  80602d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806031:	b9 00 00 00 00       	mov    $0x0,%ecx
  806036:	48 89 c7             	mov    %rax,%rdi
  806039:	48 b8 5a 9e 81 00 00 	movabs $0x819e5a,%rax
  806040:	00 00 00 
  806043:	ff d0                	callq  *%rax
  806045:	88 45 ef             	mov    %al,-0x11(%rbp)
  if (err != ERR_OK) {
  806048:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  80604c:	74 61                	je     8060af <lwip_accept+0x146>
    netconn_delete(newconn);
  80604e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806052:	48 89 c7             	mov    %rax,%rdi
  806055:	48 b8 ac 9d 81 00 00 	movabs $0x819dac,%rax
  80605c:	00 00 00 
  80605f:	ff d0                	callq  *%rax
    sock_set_errno(sock, err_to_errno(err));
  806061:	0f be 45 ef          	movsbl -0x11(%rbp),%eax
  806065:	f7 d8                	neg    %eax
  806067:	83 f8 0e             	cmp    $0xe,%eax
  80606a:	77 1a                	ja     806086 <lwip_accept+0x11d>
  80606c:	0f be 45 ef          	movsbl -0x11(%rbp),%eax
  806070:	f7 d8                	neg    %eax
  806072:	89 c2                	mov    %eax,%edx
  806074:	48 b8 c0 18 82 00 00 	movabs $0x8218c0,%rax
  80607b:	00 00 00 
  80607e:	48 63 d2             	movslq %edx,%rdx
  806081:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806084:	eb 05                	jmp    80608b <lwip_accept+0x122>
  806086:	b8 05 00 00 00       	mov    $0x5,%eax
  80608b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80608f:	89 42 18             	mov    %eax,0x18(%rdx)
  806092:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806096:	8b 50 18             	mov    0x18(%rax),%edx
  806099:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8060a0:	00 00 00 
  8060a3:	89 10                	mov    %edx,(%rax)
    return -1;
  8060a5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8060aa:	e9 e5 01 00 00       	jmpq   806294 <lwip_accept+0x32b>
  }

  memset(&sin, 0, sizeof(sin));
  8060af:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  8060b3:	ba 10 00 00 00       	mov    $0x10,%edx
  8060b8:	be 00 00 00 00       	mov    $0x0,%esi
  8060bd:	48 89 c7             	mov    %rax,%rdi
  8060c0:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  8060c7:	00 00 00 
  8060ca:	ff d0                	callq  *%rax
  sin.sin_len = sizeof(sin);
  8060cc:	c6 45 b0 10          	movb   $0x10,-0x50(%rbp)
  sin.sin_family = AF_INET;
  8060d0:	c6 45 b1 02          	movb   $0x2,-0x4f(%rbp)
  sin.sin_port = htons(port);
  8060d4:	0f b7 45 ce          	movzwl -0x32(%rbp),%eax
  8060d8:	0f b7 c0             	movzwl %ax,%eax
  8060db:	89 c7                	mov    %eax,%edi
  8060dd:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8060e4:	00 00 00 
  8060e7:	ff d0                	callq  *%rax
  8060e9:	66 89 45 b2          	mov    %ax,-0x4e(%rbp)
  sin.sin_addr.s_addr = naddr.addr;
  8060ed:	8b 45 d0             	mov    -0x30(%rbp),%eax
  8060f0:	89 45 b4             	mov    %eax,-0x4c(%rbp)

  if (*addrlen > sizeof(sin))
  8060f3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8060f7:	8b 00                	mov    (%rax),%eax
  8060f9:	83 f8 10             	cmp    $0x10,%eax
  8060fc:	76 0a                	jbe    806108 <lwip_accept+0x19f>
    *addrlen = sizeof(sin);
  8060fe:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806102:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

  SMEMCPY(addr, &sin, *addrlen);
  806108:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80610c:	8b 00                	mov    (%rax),%eax
  80610e:	89 c2                	mov    %eax,%edx
  806110:	48 8d 4d b0          	lea    -0x50(%rbp),%rcx
  806114:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806118:	48 89 ce             	mov    %rcx,%rsi
  80611b:	48 89 c7             	mov    %rax,%rdi
  80611e:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  806125:	00 00 00 
  806128:	ff d0                	callq  *%rax

  newsock = alloc_socket(newconn);
  80612a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80612e:	48 89 c7             	mov    %rax,%rdi
  806131:	48 b8 e5 5d 80 00 00 	movabs $0x805de5,%rax
  806138:	00 00 00 
  80613b:	ff d0                	callq  *%rax
  80613d:	89 45 e8             	mov    %eax,-0x18(%rbp)
  if (newsock == -1) {
  806140:	83 7d e8 ff          	cmpl   $0xffffffff,-0x18(%rbp)
  806144:	75 3b                	jne    806181 <lwip_accept+0x218>
    netconn_delete(newconn);
  806146:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80614a:	48 89 c7             	mov    %rax,%rdi
  80614d:	48 b8 ac 9d 81 00 00 	movabs $0x819dac,%rax
  806154:	00 00 00 
  806157:	ff d0                	callq  *%rax
    sock_set_errno(sock, ENFILE);
  806159:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80615d:	c7 40 18 17 00 00 00 	movl   $0x17,0x18(%rax)
  806164:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806168:	8b 50 18             	mov    0x18(%rax),%edx
  80616b:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806172:	00 00 00 
  806175:	89 10                	mov    %edx,(%rax)
    return -1;
  806177:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80617c:	e9 13 01 00 00       	jmpq   806294 <lwip_accept+0x32b>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  806181:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  806185:	78 06                	js     80618d <lwip_accept+0x224>
  806187:	83 7d e8 1f          	cmpl   $0x1f,-0x18(%rbp)
  80618b:	7e 2a                	jle    8061b7 <lwip_accept+0x24e>
  80618d:	48 ba fc 18 82 00 00 	movabs $0x8218fc,%rdx
  806194:	00 00 00 
  806197:	be 26 01 00 00       	mov    $0x126,%esi
  80619c:	48 bf 11 19 82 00 00 	movabs $0x821911,%rdi
  8061a3:	00 00 00 
  8061a6:	b8 00 00 00 00       	mov    $0x0,%eax
  8061ab:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8061b2:	00 00 00 
  8061b5:	ff d1                	callq  *%rcx
  newconn->callback = event_callback;
  8061b7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8061bb:	48 b9 2e 77 80 00 00 	movabs $0x80772e,%rcx
  8061c2:	00 00 00 
  8061c5:	48 89 48 38          	mov    %rcx,0x38(%rax)
  nsock = &sockets[newsock];
  8061c9:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8061cc:	48 98                	cltq   
  8061ce:	48 c1 e0 05          	shl    $0x5,%rax
  8061d2:	48 89 c2             	mov    %rax,%rdx
  8061d5:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  8061dc:	00 00 00 
  8061df:	48 01 d0             	add    %rdx,%rax
  8061e2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);
  8061e6:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8061eb:	75 2a                	jne    806217 <lwip_accept+0x2ae>
  8061ed:	48 ba 28 19 82 00 00 	movabs $0x821928,%rdx
  8061f4:	00 00 00 
  8061f7:	be 29 01 00 00       	mov    $0x129,%esi
  8061fc:	48 bf 11 19 82 00 00 	movabs $0x821911,%rdi
  806203:	00 00 00 
  806206:	b8 00 00 00 00       	mov    $0x0,%eax
  80620b:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  806212:	00 00 00 
  806215:	ff d1                	callq  *%rcx

  sys_sem_wait(socksem);
  806217:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  80621e:	00 00 00 
  806221:	8b 00                	mov    (%rax),%eax
  806223:	89 c7                	mov    %eax,%edi
  806225:	48 b8 77 e7 80 00 00 	movabs $0x80e777,%rax
  80622c:	00 00 00 
  80622f:	ff d0                	callq  *%rax
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  806231:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  806235:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  806239:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80623d:	8b 40 20             	mov    0x20(%rax),%eax
  806240:	29 c2                	sub    %eax,%edx
  806242:	89 d0                	mov    %edx,%eax
  806244:	8d 50 ff             	lea    -0x1(%rax),%edx
  806247:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80624b:	66 89 50 12          	mov    %dx,0x12(%rax)
  newconn->socket = newsock;
  80624f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806253:	8b 55 e8             	mov    -0x18(%rbp),%edx
  806256:	89 50 20             	mov    %edx,0x20(%rax)
  sys_sem_signal(socksem);
  806259:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  806260:	00 00 00 
  806263:	8b 00                	mov    (%rax),%eax
  806265:	89 c7                	mov    %eax,%edi
  806267:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  80626e:	00 00 00 
  806271:	ff d0                	callq  *%rax

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  806273:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806277:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  80627e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806282:	8b 50 18             	mov    0x18(%rax),%edx
  806285:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80628c:	00 00 00 
  80628f:	89 10                	mov    %edx,(%rax)
  return newsock;
  806291:	8b 45 e8             	mov    -0x18(%rbp),%eax
}
  806294:	c9                   	leaveq 
  806295:	c3                   	retq   

0000000000806296 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  806296:	55                   	push   %rbp
  806297:	48 89 e5             	mov    %rsp,%rbp
  80629a:	48 83 ec 20          	sub    $0x20,%rsp
  80629e:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8062a1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8062a5:	89 55 e8             	mov    %edx,-0x18(%rbp)
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  8062a8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8062ab:	89 c7                	mov    %eax,%edi
  8062ad:	48 b8 71 5d 80 00 00 	movabs $0x805d71,%rax
  8062b4:	00 00 00 
  8062b7:	ff d0                	callq  *%rax
  8062b9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  8062bd:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8062c2:	75 0a                	jne    8062ce <lwip_bind+0x38>
    return -1;
  8062c4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8062c9:	e9 fb 00 00 00       	jmpq   8063c9 <lwip_bind+0x133>

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8062ce:	83 7d e8 10          	cmpl   $0x10,-0x18(%rbp)
  8062d2:	75 0c                	jne    8062e0 <lwip_bind+0x4a>
  8062d4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8062d8:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8062dc:	3c 02                	cmp    $0x2,%al
  8062de:	74 2a                	je     80630a <lwip_bind+0x74>
  8062e0:	48 ba 3f 19 82 00 00 	movabs $0x82193f,%rdx
  8062e7:	00 00 00 
  8062ea:	be 4b 01 00 00       	mov    $0x14b,%esi
  8062ef:	48 bf 11 19 82 00 00 	movabs $0x821911,%rdi
  8062f6:	00 00 00 
  8062f9:	b8 00 00 00 00       	mov    $0x0,%eax
  8062fe:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  806305:	00 00 00 
  806308:	ff d1                	callq  *%rcx
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  80630a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80630e:	8b 40 04             	mov    0x4(%rax),%eax
  806311:	89 45 f0             	mov    %eax,-0x10(%rbp)
  local_port = ((struct sockaddr_in *)name)->sin_port;
  806314:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  806318:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80631c:	66 89 45 f6          	mov    %ax,-0xa(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  806320:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  806324:	89 c7                	mov    %eax,%edi
  806326:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  80632d:	00 00 00 
  806330:	ff d0                	callq  *%rax
  806332:	0f b7 d0             	movzwl %ax,%edx
  806335:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806339:	48 8b 00             	mov    (%rax),%rax
  80633c:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  806340:	48 89 ce             	mov    %rcx,%rsi
  806343:	48 89 c7             	mov    %rax,%rdi
  806346:	48 b8 50 9f 81 00 00 	movabs $0x819f50,%rax
  80634d:	00 00 00 
  806350:	ff d0                	callq  *%rax
  806352:	88 45 f5             	mov    %al,-0xb(%rbp)

  if (err != ERR_OK) {
  806355:	80 7d f5 00          	cmpb   $0x0,-0xb(%rbp)
  806359:	74 4b                	je     8063a6 <lwip_bind+0x110>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  80635b:	0f be 45 f5          	movsbl -0xb(%rbp),%eax
  80635f:	f7 d8                	neg    %eax
  806361:	83 f8 0e             	cmp    $0xe,%eax
  806364:	77 1a                	ja     806380 <lwip_bind+0xea>
  806366:	0f be 45 f5          	movsbl -0xb(%rbp),%eax
  80636a:	f7 d8                	neg    %eax
  80636c:	89 c2                	mov    %eax,%edx
  80636e:	48 b8 c0 18 82 00 00 	movabs $0x8218c0,%rax
  806375:	00 00 00 
  806378:	48 63 d2             	movslq %edx,%rdx
  80637b:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  80637e:	eb 05                	jmp    806385 <lwip_bind+0xef>
  806380:	b8 05 00 00 00       	mov    $0x5,%eax
  806385:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  806389:	89 42 18             	mov    %eax,0x18(%rdx)
  80638c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806390:	8b 50 18             	mov    0x18(%rax),%edx
  806393:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80639a:	00 00 00 
  80639d:	89 10                	mov    %edx,(%rax)
    return -1;
  80639f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8063a4:	eb 23                	jmp    8063c9 <lwip_bind+0x133>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8063a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8063aa:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8063b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8063b5:	8b 50 18             	mov    0x18(%rax),%edx
  8063b8:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8063bf:	00 00 00 
  8063c2:	89 10                	mov    %edx,(%rax)
  return 0;
  8063c4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8063c9:	c9                   	leaveq 
  8063ca:	c3                   	retq   

00000000008063cb <lwip_close>:

int
lwip_close(int s)
{
  8063cb:	55                   	push   %rbp
  8063cc:	48 89 e5             	mov    %rsp,%rbp
  8063cf:	48 83 ec 20          	sub    $0x20,%rsp
  8063d3:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  8063d6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8063d9:	89 c7                	mov    %eax,%edi
  8063db:	48 b8 71 5d 80 00 00 	movabs $0x805d71,%rax
  8063e2:	00 00 00 
  8063e5:	ff d0                	callq  *%rax
  8063e7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock) {
  8063eb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8063f0:	75 0a                	jne    8063fc <lwip_close+0x31>
    return -1;
  8063f2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8063f7:	e9 b2 00 00 00       	jmpq   8064ae <lwip_close+0xe3>
  }

  netconn_delete(sock->conn);
  8063fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806400:	48 8b 00             	mov    (%rax),%rax
  806403:	48 89 c7             	mov    %rax,%rdi
  806406:	48 b8 ac 9d 81 00 00 	movabs $0x819dac,%rax
  80640d:	00 00 00 
  806410:	ff d0                	callq  *%rax

  sys_sem_wait(socksem);
  806412:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  806419:	00 00 00 
  80641c:	8b 00                	mov    (%rax),%eax
  80641e:	89 c7                	mov    %eax,%edi
  806420:	48 b8 77 e7 80 00 00 	movabs $0x80e777,%rax
  806427:	00 00 00 
  80642a:	ff d0                	callq  *%rax
  if (sock->lastdata) {
  80642c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806430:	48 8b 40 08          	mov    0x8(%rax),%rax
  806434:	48 85 c0             	test   %rax,%rax
  806437:	74 17                	je     806450 <lwip_close+0x85>
    netbuf_delete(sock->lastdata);
  806439:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80643d:	48 8b 40 08          	mov    0x8(%rax),%rax
  806441:	48 89 c7             	mov    %rax,%rdi
  806444:	48 b8 d7 8e 80 00 00 	movabs $0x808ed7,%rax
  80644b:	00 00 00 
  80644e:	ff d0                	callq  *%rax
  }
  sock->lastdata   = NULL;
  806450:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806454:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80645b:	00 
  sock->lastoffset = 0;
  80645c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806460:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
  sock->conn       = NULL;
  806466:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80646a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  sock_set_errno(sock, 0);
  806471:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806475:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  80647c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806480:	8b 50 18             	mov    0x18(%rax),%edx
  806483:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80648a:	00 00 00 
  80648d:	89 10                	mov    %edx,(%rax)
  sys_sem_signal(socksem);
  80648f:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  806496:	00 00 00 
  806499:	8b 00                	mov    (%rax),%eax
  80649b:	89 c7                	mov    %eax,%edi
  80649d:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  8064a4:	00 00 00 
  8064a7:	ff d0                	callq  *%rax
  return 0;
  8064a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8064ae:	c9                   	leaveq 
  8064af:	c3                   	retq   

00000000008064b0 <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  8064b0:	55                   	push   %rbp
  8064b1:	48 89 e5             	mov    %rsp,%rbp
  8064b4:	48 83 ec 30          	sub    $0x30,%rsp
  8064b8:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8064bb:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8064bf:	89 55 d8             	mov    %edx,-0x28(%rbp)
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  8064c2:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8064c5:	89 c7                	mov    %eax,%edi
  8064c7:	48 b8 71 5d 80 00 00 	movabs $0x805d71,%rax
  8064ce:	00 00 00 
  8064d1:	ff d0                	callq  *%rax
  8064d3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!sock)
  8064d7:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8064dc:	75 0a                	jne    8064e8 <lwip_connect+0x38>
    return -1;
  8064de:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8064e3:	e9 22 01 00 00       	jmpq   80660a <lwip_connect+0x15a>

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8064e8:	83 7d d8 10          	cmpl   $0x10,-0x28(%rbp)
  8064ec:	75 0c                	jne    8064fa <lwip_connect+0x4a>
  8064ee:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8064f2:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8064f6:	3c 02                	cmp    $0x2,%al
  8064f8:	74 2a                	je     806524 <lwip_connect+0x74>
  8064fa:	48 ba 5a 19 82 00 00 	movabs $0x82195a,%rdx
  806501:	00 00 00 
  806504:	be 87 01 00 00       	mov    $0x187,%esi
  806509:	48 bf 11 19 82 00 00 	movabs $0x821911,%rdi
  806510:	00 00 00 
  806513:	b8 00 00 00 00       	mov    $0x0,%eax
  806518:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80651f:	00 00 00 
  806522:	ff d1                	callq  *%rcx
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  if (((struct sockaddr_in *)name)->sin_family == AF_UNSPEC) {
  806524:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  806528:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80652c:	84 c0                	test   %al,%al
  80652e:	75 1b                	jne    80654b <lwip_connect+0x9b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
    err = netconn_disconnect(sock->conn);
  806530:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806534:	48 8b 00             	mov    (%rax),%rax
  806537:	48 89 c7             	mov    %rax,%rdi
  80653a:	48 b8 64 a0 81 00 00 	movabs $0x81a064,%rax
  806541:	00 00 00 
  806544:	ff d0                	callq  *%rax
  806546:	88 45 ff             	mov    %al,-0x1(%rbp)
  806549:	eb 4b                	jmp    806596 <lwip_connect+0xe6>
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  80654b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80654f:	8b 40 04             	mov    0x4(%rax),%eax
  806552:	89 45 e0             	mov    %eax,-0x20(%rbp)
    remote_port = ((struct sockaddr_in *)name)->sin_port;
  806555:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  806559:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80655d:	66 89 45 ee          	mov    %ax,-0x12(%rbp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  806561:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  806565:	89 c7                	mov    %eax,%edi
  806567:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  80656e:	00 00 00 
  806571:	ff d0                	callq  *%rax
  806573:	0f b7 d0             	movzwl %ax,%edx
  806576:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80657a:	48 8b 00             	mov    (%rax),%rax
  80657d:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  806581:	48 89 ce             	mov    %rcx,%rsi
  806584:	48 89 c7             	mov    %rax,%rdi
  806587:	48 b8 da 9f 81 00 00 	movabs $0x819fda,%rax
  80658e:	00 00 00 
  806591:	ff d0                	callq  *%rax
  806593:	88 45 ff             	mov    %al,-0x1(%rbp)
  }

  if (err != ERR_OK) {
  806596:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80659a:	74 4b                	je     8065e7 <lwip_connect+0x137>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  80659c:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  8065a0:	f7 d8                	neg    %eax
  8065a2:	83 f8 0e             	cmp    $0xe,%eax
  8065a5:	77 1a                	ja     8065c1 <lwip_connect+0x111>
  8065a7:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  8065ab:	f7 d8                	neg    %eax
  8065ad:	89 c2                	mov    %eax,%edx
  8065af:	48 b8 c0 18 82 00 00 	movabs $0x8218c0,%rax
  8065b6:	00 00 00 
  8065b9:	48 63 d2             	movslq %edx,%rdx
  8065bc:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  8065bf:	eb 05                	jmp    8065c6 <lwip_connect+0x116>
  8065c1:	b8 05 00 00 00       	mov    $0x5,%eax
  8065c6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8065ca:	89 42 18             	mov    %eax,0x18(%rdx)
  8065cd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8065d1:	8b 50 18             	mov    0x18(%rax),%edx
  8065d4:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8065db:	00 00 00 
  8065de:	89 10                	mov    %edx,(%rax)
    return -1;
  8065e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8065e5:	eb 23                	jmp    80660a <lwip_connect+0x15a>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8065e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8065eb:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8065f2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8065f6:	8b 50 18             	mov    0x18(%rax),%edx
  8065f9:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806600:	00 00 00 
  806603:	89 10                	mov    %edx,(%rax)
  return 0;
  806605:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80660a:	c9                   	leaveq 
  80660b:	c3                   	retq   

000000000080660c <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  80660c:	55                   	push   %rbp
  80660d:	48 89 e5             	mov    %rsp,%rbp
  806610:	48 83 ec 20          	sub    $0x20,%rsp
  806614:	89 7d ec             	mov    %edi,-0x14(%rbp)
  806617:	89 75 e8             	mov    %esi,-0x18(%rbp)
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  80661a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80661d:	89 c7                	mov    %eax,%edi
  80661f:	48 b8 71 5d 80 00 00 	movabs $0x805d71,%rax
  806626:	00 00 00 
  806629:	ff d0                	callq  *%rax
  80662b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  80662f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806634:	75 0a                	jne    806640 <lwip_listen+0x34>
    return -1;
  806636:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80663b:	e9 b2 00 00 00       	jmpq   8066f2 <lwip_listen+0xe6>

  /* limit the "backlog" parameter to fit in an u8_t */
  if (backlog < 0) {
  806640:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  806644:	79 07                	jns    80664d <lwip_listen+0x41>
    backlog = 0;
  806646:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
  }
  if (backlog > 0xff) {
  80664d:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%rbp)
  806654:	7e 07                	jle    80665d <lwip_listen+0x51>
    backlog = 0xff;
  806656:	c7 45 e8 ff 00 00 00 	movl   $0xff,-0x18(%rbp)
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  80665d:	8b 45 e8             	mov    -0x18(%rbp),%eax
  806660:	0f b6 d0             	movzbl %al,%edx
  806663:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806667:	48 8b 00             	mov    (%rax),%rax
  80666a:	89 d6                	mov    %edx,%esi
  80666c:	48 89 c7             	mov    %rax,%rdi
  80666f:	48 b8 d4 a0 81 00 00 	movabs $0x81a0d4,%rax
  806676:	00 00 00 
  806679:	ff d0                	callq  *%rax
  80667b:	88 45 f7             	mov    %al,-0x9(%rbp)

  if (err != ERR_OK) {
  80667e:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  806682:	74 4b                	je     8066cf <lwip_listen+0xc3>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  806684:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806688:	f7 d8                	neg    %eax
  80668a:	83 f8 0e             	cmp    $0xe,%eax
  80668d:	77 1a                	ja     8066a9 <lwip_listen+0x9d>
  80668f:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806693:	f7 d8                	neg    %eax
  806695:	89 c2                	mov    %eax,%edx
  806697:	48 b8 c0 18 82 00 00 	movabs $0x8218c0,%rax
  80669e:	00 00 00 
  8066a1:	48 63 d2             	movslq %edx,%rdx
  8066a4:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  8066a7:	eb 05                	jmp    8066ae <lwip_listen+0xa2>
  8066a9:	b8 05 00 00 00       	mov    $0x5,%eax
  8066ae:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8066b2:	89 42 18             	mov    %eax,0x18(%rdx)
  8066b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8066b9:	8b 50 18             	mov    0x18(%rax),%edx
  8066bc:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8066c3:	00 00 00 
  8066c6:	89 10                	mov    %edx,(%rax)
    return -1;
  8066c8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8066cd:	eb 23                	jmp    8066f2 <lwip_listen+0xe6>
  }

  sock_set_errno(sock, 0);
  8066cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8066d3:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8066da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8066de:	8b 50 18             	mov    0x18(%rax),%edx
  8066e1:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8066e8:	00 00 00 
  8066eb:	89 10                	mov    %edx,(%rax)
  return 0;
  8066ed:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8066f2:	c9                   	leaveq 
  8066f3:	c3                   	retq   

00000000008066f4 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  8066f4:	55                   	push   %rbp
  8066f5:	48 89 e5             	mov    %rsp,%rbp
  8066f8:	48 83 ec 70          	sub    $0x70,%rsp
  8066fc:	89 7d bc             	mov    %edi,-0x44(%rbp)
  8066ff:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  806703:	89 55 b8             	mov    %edx,-0x48(%rbp)
  806706:	89 4d ac             	mov    %ecx,-0x54(%rbp)
  806709:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  80670d:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
  struct lwip_socket *sock;
  struct netbuf      *buf;
  u16_t               buflen, copylen, off = 0;
  806711:	66 c7 45 f4 00 00    	movw   $0x0,-0xc(%rbp)
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;
  806717:	c6 45 e7 00          	movb   $0x0,-0x19(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  80671b:	8b 45 bc             	mov    -0x44(%rbp),%eax
  80671e:	89 c7                	mov    %eax,%edi
  806720:	48 b8 71 5d 80 00 00 	movabs $0x805d71,%rax
  806727:	00 00 00 
  80672a:	ff d0                	callq  *%rax
  80672c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (!sock)
  806730:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  806735:	75 0a                	jne    806741 <lwip_recvfrom+0x4d>
    return -1;
  806737:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80673c:	e9 8a 03 00 00       	jmpq   806acb <lwip_recvfrom+0x3d7>

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  806741:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806745:	48 8b 40 08          	mov    0x8(%rax),%rax
  806749:	48 85 c0             	test   %rax,%rax
  80674c:	74 11                	je     80675f <lwip_recvfrom+0x6b>
      buf = sock->lastdata;
  80674e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806752:	48 8b 40 08          	mov    0x8(%rax),%rax
  806756:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80675a:	e9 0c 01 00 00       	jmpq   80686b <lwip_recvfrom+0x177>
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  80675f:	8b 45 ac             	mov    -0x54(%rbp),%eax
  806762:	83 e0 08             	and    $0x8,%eax
  806765:	85 c0                	test   %eax,%eax
  806767:	75 14                	jne    80677d <lwip_recvfrom+0x89>
  806769:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80676d:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  806771:	0f b7 c0             	movzwl %ax,%eax
  806774:	25 00 08 00 00       	and    $0x800,%eax
  806779:	85 c0                	test   %eax,%eax
  80677b:	74 35                	je     8067b2 <lwip_recvfrom+0xbe>
  80677d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806781:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  806785:	66 85 c0             	test   %ax,%ax
  806788:	75 28                	jne    8067b2 <lwip_recvfrom+0xbe>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  80678a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80678e:	c7 40 18 0b 00 00 00 	movl   $0xb,0x18(%rax)
  806795:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806799:	8b 50 18             	mov    0x18(%rax),%edx
  80679c:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8067a3:	00 00 00 
  8067a6:	89 10                	mov    %edx,(%rax)
        return -1;
  8067a8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8067ad:	e9 19 03 00 00       	jmpq   806acb <lwip_recvfrom+0x3d7>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  8067b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8067b6:	48 8b 00             	mov    (%rax),%rax
  8067b9:	48 89 c7             	mov    %rax,%rdi
  8067bc:	48 b8 0b a2 81 00 00 	movabs $0x81a20b,%rax
  8067c3:	00 00 00 
  8067c6:	ff d0                	callq  *%rax
  8067c8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8067cc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8067d0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8067d4:	48 89 50 08          	mov    %rdx,0x8(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  8067d8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8067dd:	0f 85 88 00 00 00    	jne    80686b <lwip_recvfrom+0x177>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  8067e3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8067e7:	48 8b 00             	mov    (%rax),%rax
  8067ea:	48 8b 40 08          	mov    0x8(%rax),%rax
  8067ee:	48 85 c0             	test   %rax,%rax
  8067f1:	74 0f                	je     806802 <lwip_recvfrom+0x10e>
  8067f3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8067f7:	48 8b 00             	mov    (%rax),%rax
  8067fa:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8067fe:	84 c0                	test   %al,%al
  806800:	74 40                	je     806842 <lwip_recvfrom+0x14e>
  806802:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806806:	48 8b 00             	mov    (%rax),%rax
  806809:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  80680d:	0f be c0             	movsbl %al,%eax
  806810:	f7 d8                	neg    %eax
  806812:	83 f8 0e             	cmp    $0xe,%eax
  806815:	77 24                	ja     80683b <lwip_recvfrom+0x147>
  806817:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80681b:	48 8b 00             	mov    (%rax),%rax
  80681e:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  806822:	0f be c0             	movsbl %al,%eax
  806825:	f7 d8                	neg    %eax
  806827:	89 c2                	mov    %eax,%edx
  806829:	48 b8 c0 18 82 00 00 	movabs $0x8218c0,%rax
  806830:	00 00 00 
  806833:	48 63 d2             	movslq %edx,%rdx
  806836:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806839:	eb 0c                	jmp    806847 <lwip_recvfrom+0x153>
  80683b:	b8 05 00 00 00       	mov    $0x5,%eax
  806840:	eb 05                	jmp    806847 <lwip_recvfrom+0x153>
  806842:	b8 6e 00 00 00       	mov    $0x6e,%eax
  806847:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80684b:	89 42 18             	mov    %eax,0x18(%rdx)
  80684e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806852:	8b 50 18             	mov    0x18(%rax),%edx
  806855:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80685c:	00 00 00 
  80685f:	89 10                	mov    %edx,(%rax)
        return 0;
  806861:	b8 00 00 00 00       	mov    $0x0,%eax
  806866:	e9 60 02 00 00       	jmpq   806acb <lwip_recvfrom+0x3d7>
      }
    }

    buflen = netbuf_len(buf);
  80686b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80686f:	48 8b 00             	mov    (%rax),%rax
  806872:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  806876:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  80687a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80687e:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  806882:	66 29 45 d6          	sub    %ax,-0x2a(%rbp)

    if (len > buflen) {
  806886:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
  80688a:	3b 45 b8             	cmp    -0x48(%rbp),%eax
  80688d:	7d 0a                	jge    806899 <lwip_recvfrom+0x1a5>
      copylen = buflen;
  80688f:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
  806893:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  806897:	eb 07                	jmp    8068a0 <lwip_recvfrom+0x1ac>
    } else {
      copylen = len;
  806899:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80689c:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  8068a0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8068a4:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8068a8:	0f b7 c8             	movzwl %ax,%ecx
  8068ab:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8068af:	0f b7 75 f4          	movzwl -0xc(%rbp),%esi
  8068b3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8068b7:	48 01 c6             	add    %rax,%rsi
  8068ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8068be:	48 8b 00             	mov    (%rax),%rax
  8068c1:	48 89 c7             	mov    %rax,%rdi
  8068c4:	48 b8 d9 e4 80 00 00 	movabs $0x80e4d9,%rax
  8068cb:	00 00 00 
  8068ce:	ff d0                	callq  *%rax

    off += copylen;
  8068d0:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8068d4:	66 01 45 f4          	add    %ax,-0xc(%rbp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8068d8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8068dc:	48 8b 00             	mov    (%rax),%rax
  8068df:	48 89 c7             	mov    %rax,%rdi
  8068e2:	48 b8 15 9e 81 00 00 	movabs $0x819e15,%rax
  8068e9:	00 00 00 
  8068ec:	ff d0                	callq  *%rax
  8068ee:	83 f8 10             	cmp    $0x10,%eax
  8068f1:	75 35                	jne    806928 <lwip_recvfrom+0x234>
      len -= copylen;
  8068f3:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8068f7:	29 45 b8             	sub    %eax,-0x48(%rbp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8068fa:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  8068fe:	7e 22                	jle    806922 <lwip_recvfrom+0x22e>
  806900:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806904:	48 8b 00             	mov    (%rax),%rax
  806907:	0f b6 40 15          	movzbl 0x15(%rax),%eax
  80690b:	0f b6 c0             	movzbl %al,%eax
  80690e:	83 e0 01             	and    $0x1,%eax
  806911:	85 c0                	test   %eax,%eax
  806913:	75 0d                	jne    806922 <lwip_recvfrom+0x22e>
  806915:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806919:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80691d:	66 85 c0             	test   %ax,%ax
  806920:	75 0a                	jne    80692c <lwip_recvfrom+0x238>
        done = 1;
  806922:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
  806926:	eb 04                	jmp    80692c <lwip_recvfrom+0x238>
      }
    } else {
      done = 1;
  806928:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  80692c:	8b 45 ac             	mov    -0x54(%rbp),%eax
  80692f:	83 e0 01             	and    $0x1,%eax
  806932:	85 c0                	test   %eax,%eax
  806934:	75 6d                	jne    8069a3 <lwip_recvfrom+0x2af>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  806936:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80693a:	48 8b 00             	mov    (%rax),%rax
  80693d:	8b 00                	mov    (%rax),%eax
  80693f:	83 f8 10             	cmp    $0x10,%eax
  806942:	75 34                	jne    806978 <lwip_recvfrom+0x284>
  806944:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  806948:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80694c:	29 c2                	sub    %eax,%edx
  80694e:	89 d0                	mov    %edx,%eax
  806950:	85 c0                	test   %eax,%eax
  806952:	7e 24                	jle    806978 <lwip_recvfrom+0x284>
        sock->lastdata = buf;
  806954:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806958:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80695c:	48 89 50 08          	mov    %rdx,0x8(%rax)
        sock->lastoffset += copylen;
  806960:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806964:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  806968:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80696c:	01 c2                	add    %eax,%edx
  80696e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806972:	66 89 50 10          	mov    %dx,0x10(%rax)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  806976:	eb 2f                	jmp    8069a7 <lwip_recvfrom+0x2b3>
      } else {
        sock->lastdata = NULL;
  806978:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80697c:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  806983:	00 
        sock->lastoffset = 0;
  806984:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806988:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  80698e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806992:	48 89 c7             	mov    %rax,%rdi
  806995:	48 b8 d7 8e 80 00 00 	movabs $0x808ed7,%rax
  80699c:	00 00 00 
  80699f:	ff d0                	callq  *%rax
  8069a1:	eb 04                	jmp    8069a7 <lwip_recvfrom+0x2b3>
      }
    } else {
      done = 1;
  8069a3:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
    }
  } while (!done);
  8069a7:	80 7d e7 00          	cmpb   $0x0,-0x19(%rbp)
  8069ab:	0f 84 90 fd ff ff    	je     806741 <lwip_recvfrom+0x4d>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  8069b1:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8069b6:	0f 84 ed 00 00 00    	je     806aa9 <lwip_recvfrom+0x3b5>
  8069bc:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  8069c1:	0f 84 e2 00 00 00    	je     806aa9 <lwip_recvfrom+0x3b5>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8069c7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8069cb:	48 8b 00             	mov    (%rax),%rax
  8069ce:	48 89 c7             	mov    %rax,%rdi
  8069d1:	48 b8 15 9e 81 00 00 	movabs $0x819e15,%rax
  8069d8:	00 00 00 
  8069db:	ff d0                	callq  *%rax
  8069dd:	83 f8 10             	cmp    $0x10,%eax
  8069e0:	75 31                	jne    806a13 <lwip_recvfrom+0x31f>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  8069e2:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8069e6:	48 83 c0 04          	add    $0x4,%rax
  8069ea:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      netconn_getaddr(sock->conn, addr, &port, 0);
  8069ee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8069f2:	48 8b 00             	mov    (%rax),%rax
  8069f5:	48 8d 55 d4          	lea    -0x2c(%rbp),%rdx
  8069f9:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8069fd:	b9 00 00 00 00       	mov    $0x0,%ecx
  806a02:	48 89 c7             	mov    %rax,%rdi
  806a05:	48 b8 5a 9e 81 00 00 	movabs $0x819e5a,%rax
  806a0c:	00 00 00 
  806a0f:	ff d0                	callq  *%rax
  806a11:	eb 18                	jmp    806a2b <lwip_recvfrom+0x337>
    } else {
      addr = netbuf_fromaddr(buf);
  806a13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806a17:	48 8b 40 10          	mov    0x10(%rax),%rax
  806a1b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      port = netbuf_fromport(buf);
  806a1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806a23:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  806a27:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)
    }

    memset(&sin, 0, sizeof(sin));
  806a2b:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  806a2f:	ba 10 00 00 00       	mov    $0x10,%edx
  806a34:	be 00 00 00 00       	mov    $0x0,%esi
  806a39:	48 89 c7             	mov    %rax,%rdi
  806a3c:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  806a43:	00 00 00 
  806a46:	ff d0                	callq  *%rax
    sin.sin_len = sizeof(sin);
  806a48:	c6 45 c0 10          	movb   $0x10,-0x40(%rbp)
    sin.sin_family = AF_INET;
  806a4c:	c6 45 c1 02          	movb   $0x2,-0x3f(%rbp)
    sin.sin_port = htons(port);
  806a50:	0f b7 45 d4          	movzwl -0x2c(%rbp),%eax
  806a54:	0f b7 c0             	movzwl %ax,%eax
  806a57:	89 c7                	mov    %eax,%edi
  806a59:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  806a60:	00 00 00 
  806a63:	ff d0                	callq  *%rax
  806a65:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
    sin.sin_addr.s_addr = addr->addr;
  806a69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  806a6d:	8b 00                	mov    (%rax),%eax
  806a6f:	89 45 c4             	mov    %eax,-0x3c(%rbp)

    if (*fromlen > sizeof(sin))
  806a72:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806a76:	8b 00                	mov    (%rax),%eax
  806a78:	83 f8 10             	cmp    $0x10,%eax
  806a7b:	76 0a                	jbe    806a87 <lwip_recvfrom+0x393>
      *fromlen = sizeof(sin);
  806a7d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806a81:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

    SMEMCPY(from, &sin, *fromlen);
  806a87:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806a8b:	8b 00                	mov    (%rax),%eax
  806a8d:	89 c2                	mov    %eax,%edx
  806a8f:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  806a93:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806a97:	48 89 ce             	mov    %rcx,%rsi
  806a9a:	48 89 c7             	mov    %rax,%rdi
  806a9d:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  806aa4:	00 00 00 
  806aa7:	ff d0                	callq  *%rax
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  806aa9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806aad:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  806ab4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806ab8:	8b 50 18             	mov    0x18(%rax),%edx
  806abb:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806ac2:	00 00 00 
  806ac5:	89 10                	mov    %edx,(%rax)
  return off;
  806ac7:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
}
  806acb:	c9                   	leaveq 
  806acc:	c3                   	retq   

0000000000806acd <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  806acd:	55                   	push   %rbp
  806ace:	48 89 e5             	mov    %rsp,%rbp
  806ad1:	48 83 ec 10          	sub    $0x10,%rsp
  806ad5:	89 7d fc             	mov    %edi,-0x4(%rbp)
  806ad8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  806adc:	89 55 f8             	mov    %edx,-0x8(%rbp)
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  806adf:	8b 55 f8             	mov    -0x8(%rbp),%edx
  806ae2:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  806ae6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806ae9:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  806aef:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  806af5:	b9 00 00 00 00       	mov    $0x0,%ecx
  806afa:	89 c7                	mov    %eax,%edi
  806afc:	48 b8 f4 66 80 00 00 	movabs $0x8066f4,%rax
  806b03:	00 00 00 
  806b06:	ff d0                	callq  *%rax
}
  806b08:	c9                   	leaveq 
  806b09:	c3                   	retq   

0000000000806b0a <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  806b0a:	55                   	push   %rbp
  806b0b:	48 89 e5             	mov    %rsp,%rbp
  806b0e:	48 83 ec 20          	sub    $0x20,%rsp
  806b12:	89 7d fc             	mov    %edi,-0x4(%rbp)
  806b15:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  806b19:	89 55 f8             	mov    %edx,-0x8(%rbp)
  806b1c:	89 4d ec             	mov    %ecx,-0x14(%rbp)
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  806b1f:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  806b22:	8b 55 f8             	mov    -0x8(%rbp),%edx
  806b25:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  806b29:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806b2c:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  806b32:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  806b38:	89 c7                	mov    %eax,%edi
  806b3a:	48 b8 f4 66 80 00 00 	movabs $0x8066f4,%rax
  806b41:	00 00 00 
  806b44:	ff d0                	callq  *%rax
}
  806b46:	c9                   	leaveq 
  806b47:	c3                   	retq   

0000000000806b48 <lwip_send>:

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  806b48:	55                   	push   %rbp
  806b49:	48 89 e5             	mov    %rsp,%rbp
  806b4c:	48 83 ec 30          	sub    $0x30,%rsp
  806b50:	89 7d ec             	mov    %edi,-0x14(%rbp)
  806b53:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  806b57:	89 55 e8             	mov    %edx,-0x18(%rbp)
  806b5a:	89 4d dc             	mov    %ecx,-0x24(%rbp)
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  806b5d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806b60:	89 c7                	mov    %eax,%edi
  806b62:	48 b8 71 5d 80 00 00 	movabs $0x805d71,%rax
  806b69:	00 00 00 
  806b6c:	ff d0                	callq  *%rax
  806b6e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  806b72:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806b77:	75 0a                	jne    806b83 <lwip_send+0x3b>
    return -1;
  806b79:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806b7e:	e9 c5 00 00 00       	jmpq   806c48 <lwip_send+0x100>

  if (sock->conn->type!=NETCONN_TCP) {
  806b83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806b87:	48 8b 00             	mov    (%rax),%rax
  806b8a:	8b 00                	mov    (%rax),%eax
  806b8c:	83 f8 10             	cmp    $0x10,%eax
  806b8f:	74 2c                	je     806bbd <lwip_send+0x75>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  806b91:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  806b94:	8b 55 e8             	mov    -0x18(%rbp),%edx
  806b97:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  806b9b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806b9e:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  806ba4:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  806baa:	89 c7                	mov    %eax,%edi
  806bac:	48 b8 4a 6c 80 00 00 	movabs $0x806c4a,%rax
  806bb3:	00 00 00 
  806bb6:	ff d0                	callq  *%rax
  806bb8:	e9 8b 00 00 00       	jmpq   806c48 <lwip_send+0x100>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  806bbd:	8b 45 dc             	mov    -0x24(%rbp),%eax
  806bc0:	83 e0 10             	and    $0x10,%eax
  806bc3:	85 c0                	test   %eax,%eax
  806bc5:	74 07                	je     806bce <lwip_send+0x86>
  806bc7:	b9 03 00 00 00       	mov    $0x3,%ecx
  806bcc:	eb 05                	jmp    806bd3 <lwip_send+0x8b>
  806bce:	b9 01 00 00 00       	mov    $0x1,%ecx
  806bd3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806bd7:	48 8b 00             	mov    (%rax),%rax
  806bda:	8b 55 e8             	mov    -0x18(%rbp),%edx
  806bdd:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  806be1:	48 89 c7             	mov    %rax,%rdi
  806be4:	48 b8 69 a5 81 00 00 	movabs $0x81a569,%rax
  806beb:	00 00 00 
  806bee:	ff d0                	callq  *%rax
  806bf0:	88 45 f7             	mov    %al,-0x9(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  806bf3:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806bf7:	f7 d8                	neg    %eax
  806bf9:	83 f8 0e             	cmp    $0xe,%eax
  806bfc:	77 1a                	ja     806c18 <lwip_send+0xd0>
  806bfe:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806c02:	f7 d8                	neg    %eax
  806c04:	89 c2                	mov    %eax,%edx
  806c06:	48 b8 c0 18 82 00 00 	movabs $0x8218c0,%rax
  806c0d:	00 00 00 
  806c10:	48 63 d2             	movslq %edx,%rdx
  806c13:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806c16:	eb 05                	jmp    806c1d <lwip_send+0xd5>
  806c18:	b8 05 00 00 00       	mov    $0x5,%eax
  806c1d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  806c21:	89 42 18             	mov    %eax,0x18(%rdx)
  806c24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806c28:	8b 50 18             	mov    0x18(%rax),%edx
  806c2b:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806c32:	00 00 00 
  806c35:	89 10                	mov    %edx,(%rax)
  return (err==ERR_OK?size:-1);
  806c37:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  806c3b:	75 05                	jne    806c42 <lwip_send+0xfa>
  806c3d:	8b 45 e8             	mov    -0x18(%rbp),%eax
  806c40:	eb 05                	jmp    806c47 <lwip_send+0xff>
  806c42:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806c47:	90                   	nop
}
  806c48:	c9                   	leaveq 
  806c49:	c3                   	retq   

0000000000806c4a <lwip_sendto>:

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  806c4a:	55                   	push   %rbp
  806c4b:	48 89 e5             	mov    %rsp,%rbp
  806c4e:	48 83 ec 60          	sub    $0x60,%rsp
  806c52:	89 7d bc             	mov    %edi,-0x44(%rbp)
  806c55:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  806c59:	89 55 b8             	mov    %edx,-0x48(%rbp)
  806c5c:	89 4d ac             	mov    %ecx,-0x54(%rbp)
  806c5f:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  806c63:	44 89 4d a8          	mov    %r9d,-0x58(%rbp)
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  806c67:	8b 45 bc             	mov    -0x44(%rbp),%eax
  806c6a:	89 c7                	mov    %eax,%edi
  806c6c:	48 b8 71 5d 80 00 00 	movabs $0x805d71,%rax
  806c73:	00 00 00 
  806c76:	ff d0                	callq  *%rax
  806c78:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!sock)
  806c7c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  806c81:	75 0a                	jne    806c8d <lwip_sendto+0x43>
    return -1;
  806c83:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806c88:	e9 d9 01 00 00       	jmpq   806e66 <lwip_sendto+0x21c>

  if (sock->conn->type==NETCONN_TCP) {
  806c8d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806c91:	48 8b 00             	mov    (%rax),%rax
  806c94:	8b 00                	mov    (%rax),%eax
  806c96:	83 f8 10             	cmp    $0x10,%eax
  806c99:	75 20                	jne    806cbb <lwip_sendto+0x71>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  806c9b:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  806c9e:	8b 55 b8             	mov    -0x48(%rbp),%edx
  806ca1:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  806ca5:	8b 45 bc             	mov    -0x44(%rbp),%eax
  806ca8:	89 c7                	mov    %eax,%edi
  806caa:	48 b8 48 6b 80 00 00 	movabs $0x806b48,%rax
  806cb1:	00 00 00 
  806cb4:	ff d0                	callq  *%rax
  806cb6:	e9 ab 01 00 00       	jmpq   806e66 <lwip_sendto+0x21c>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  806cbb:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  806cbf:	78 09                	js     806cca <lwip_sendto+0x80>
  806cc1:	81 7d b8 ff ff 00 00 	cmpl   $0xffff,-0x48(%rbp)
  806cc8:	7e 2a                	jle    806cf4 <lwip_sendto+0xaa>
  806cca:	48 ba 78 19 82 00 00 	movabs $0x821978,%rdx
  806cd1:	00 00 00 
  806cd4:	be 98 02 00 00       	mov    $0x298,%esi
  806cd9:	48 bf 11 19 82 00 00 	movabs $0x821911,%rdi
  806ce0:	00 00 00 
  806ce3:	b8 00 00 00 00       	mov    $0x0,%eax
  806ce8:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  806cef:	00 00 00 
  806cf2:	ff d1                	callq  *%rcx
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  806cf4:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  806cf9:	75 06                	jne    806d01 <lwip_sendto+0xb7>
  806cfb:	83 7d a8 00          	cmpl   $0x0,-0x58(%rbp)
  806cff:	74 3c                	je     806d3d <lwip_sendto+0xf3>
  806d01:	83 7d a8 10          	cmpl   $0x10,-0x58(%rbp)
  806d05:	75 0c                	jne    806d13 <lwip_sendto+0xc9>
  806d07:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806d0b:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  806d0f:	3c 02                	cmp    $0x2,%al
  806d11:	74 2a                	je     806d3d <lwip_sendto+0xf3>
  806d13:	48 ba 9c 19 82 00 00 	movabs $0x82199c,%rdx
  806d1a:	00 00 00 
  806d1d:	be 9c 02 00 00       	mov    $0x29c,%esi
  806d22:	48 bf 11 19 82 00 00 	movabs $0x821911,%rdi
  806d29:	00 00 00 
  806d2c:	b8 00 00 00 00       	mov    $0x0,%eax
  806d31:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  806d38:	00 00 00 
  806d3b:	ff d1                	callq  *%rcx
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  806d3d:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  806d44:	00 
  806d45:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  806d49:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  if (to) {
  806d4d:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  806d52:	74 39                	je     806d8d <lwip_sendto+0x143>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  806d54:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806d58:	8b 40 04             	mov    0x4(%rax),%eax
  806d5b:	89 45 e0             	mov    %eax,-0x20(%rbp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  806d5e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806d62:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  806d66:	0f b7 c0             	movzwl %ax,%eax
  806d69:	89 c7                	mov    %eax,%edi
  806d6b:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  806d72:	00 00 00 
  806d75:	ff d0                	callq  *%rax
  806d77:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    buf.addr         = &remote_addr;
  806d7b:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  806d7f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    buf.port         = remote_port;
  806d83:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  806d87:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  806d8b:	eb 1b                	jmp    806da8 <lwip_sendto+0x15e>
  } else {
    remote_addr.addr = 0;
  806d8d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    remote_port      = 0;
  806d94:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
    buf.addr         = NULL;
  806d9a:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  806da1:	00 
    buf.port         = 0;
  806da2:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%rbp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  806da8:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806dab:	0f b7 d0             	movzwl %ax,%edx
  806dae:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  806db2:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  806db6:	48 89 ce             	mov    %rcx,%rsi
  806db9:	48 89 c7             	mov    %rax,%rdi
  806dbc:	48 b8 b4 90 80 00 00 	movabs $0x8090b4,%rax
  806dc3:	00 00 00 
  806dc6:	ff d0                	callq  *%rax
  806dc8:	0f be c0             	movsbl %al,%eax
  806dcb:	89 45 fc             	mov    %eax,-0x4(%rbp)
  806dce:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  806dd2:	75 23                	jne    806df7 <lwip_sendto+0x1ad>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  806dd4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806dd8:	48 8b 00             	mov    (%rax),%rax
  806ddb:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  806ddf:	48 89 d6             	mov    %rdx,%rsi
  806de2:	48 89 c7             	mov    %rax,%rdi
  806de5:	48 b8 ed a4 81 00 00 	movabs $0x81a4ed,%rax
  806dec:	00 00 00 
  806def:	ff d0                	callq  *%rax
  806df1:	0f be c0             	movsbl %al,%eax
  806df4:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  806df7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  806dfb:	48 85 c0             	test   %rax,%rax
  806dfe:	74 13                	je     806e13 <lwip_sendto+0x1c9>
    pbuf_free(buf.p);
  806e00:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  806e04:	48 89 c7             	mov    %rax,%rdi
  806e07:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  806e0e:	00 00 00 
  806e11:	ff d0                	callq  *%rax
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  806e13:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806e16:	f7 d8                	neg    %eax
  806e18:	83 f8 0e             	cmp    $0xe,%eax
  806e1b:	77 19                	ja     806e36 <lwip_sendto+0x1ec>
  806e1d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806e20:	f7 d8                	neg    %eax
  806e22:	89 c2                	mov    %eax,%edx
  806e24:	48 b8 c0 18 82 00 00 	movabs $0x8218c0,%rax
  806e2b:	00 00 00 
  806e2e:	48 63 d2             	movslq %edx,%rdx
  806e31:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806e34:	eb 05                	jmp    806e3b <lwip_sendto+0x1f1>
  806e36:	b8 05 00 00 00       	mov    $0x5,%eax
  806e3b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  806e3f:	89 42 18             	mov    %eax,0x18(%rdx)
  806e42:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806e46:	8b 50 18             	mov    0x18(%rax),%edx
  806e49:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806e50:	00 00 00 
  806e53:	89 10                	mov    %edx,(%rax)
  return (err==ERR_OK?size:-1);
  806e55:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  806e59:	75 05                	jne    806e60 <lwip_sendto+0x216>
  806e5b:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806e5e:	eb 06                	jmp    806e66 <lwip_sendto+0x21c>
  806e60:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806e65:	90                   	nop
}
  806e66:	c9                   	leaveq 
  806e67:	c3                   	retq   

0000000000806e68 <lwip_socket>:

int
lwip_socket(int domain, int type, int protocol)
{
  806e68:	55                   	push   %rbp
  806e69:	48 89 e5             	mov    %rsp,%rbp
  806e6c:	48 83 ec 20          	sub    $0x20,%rsp
  806e70:	89 7d ec             	mov    %edi,-0x14(%rbp)
  806e73:	89 75 e8             	mov    %esi,-0x18(%rbp)
  806e76:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  806e79:	8b 45 e8             	mov    -0x18(%rbp),%eax
  806e7c:	83 f8 02             	cmp    $0x2,%eax
  806e7f:	74 38                	je     806eb9 <lwip_socket+0x51>
  806e81:	83 f8 03             	cmp    $0x3,%eax
  806e84:	74 0a                	je     806e90 <lwip_socket+0x28>
  806e86:	83 f8 01             	cmp    $0x1,%eax
  806e89:	74 66                	je     806ef1 <lwip_socket+0x89>
  806e8b:	e9 87 00 00 00       	jmpq   806f17 <lwip_socket+0xaf>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  806e90:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  806e93:	0f b6 c0             	movzbl %al,%eax
  806e96:	48 ba 2e 77 80 00 00 	movabs $0x80772e,%rdx
  806e9d:	00 00 00 
  806ea0:	89 c6                	mov    %eax,%esi
  806ea2:	bf 40 00 00 00       	mov    $0x40,%edi
  806ea7:	48 b8 09 9c 81 00 00 	movabs $0x819c09,%rax
  806eae:	00 00 00 
  806eb1:	ff d0                	callq  *%rax
  806eb3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  806eb7:	eb 78                	jmp    806f31 <lwip_socket+0xc9>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  806eb9:	81 7d e4 88 00 00 00 	cmpl   $0x88,-0x1c(%rbp)
  806ec0:	75 07                	jne    806ec9 <lwip_socket+0x61>
  806ec2:	b8 21 00 00 00       	mov    $0x21,%eax
  806ec7:	eb 05                	jmp    806ece <lwip_socket+0x66>
  806ec9:	b8 20 00 00 00       	mov    $0x20,%eax
  806ece:	48 ba 2e 77 80 00 00 	movabs $0x80772e,%rdx
  806ed5:	00 00 00 
  806ed8:	be 00 00 00 00       	mov    $0x0,%esi
  806edd:	89 c7                	mov    %eax,%edi
  806edf:	48 b8 09 9c 81 00 00 	movabs $0x819c09,%rax
  806ee6:	00 00 00 
  806ee9:	ff d0                	callq  *%rax
  806eeb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  806eef:	eb 40                	jmp    806f31 <lwip_socket+0xc9>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  806ef1:	48 ba 2e 77 80 00 00 	movabs $0x80772e,%rdx
  806ef8:	00 00 00 
  806efb:	be 00 00 00 00       	mov    $0x0,%esi
  806f00:	bf 10 00 00 00       	mov    $0x10,%edi
  806f05:	48 b8 09 9c 81 00 00 	movabs $0x819c09,%rax
  806f0c:	00 00 00 
  806f0f:	ff d0                	callq  *%rax
  806f11:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  806f15:	eb 1a                	jmp    806f31 <lwip_socket+0xc9>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  806f17:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806f1e:	00 00 00 
  806f21:	c7 00 16 00 00 00    	movl   $0x16,(%rax)
    return -1;
  806f27:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806f2c:	e9 81 00 00 00       	jmpq   806fb2 <lwip_socket+0x14a>
  }

  if (!conn) {
  806f31:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806f36:	75 17                	jne    806f4f <lwip_socket+0xe7>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  806f38:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806f3f:	00 00 00 
  806f42:	c7 00 69 00 00 00    	movl   $0x69,(%rax)
    return -1;
  806f48:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806f4d:	eb 63                	jmp    806fb2 <lwip_socket+0x14a>
  }

  i = alloc_socket(conn);
  806f4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806f53:	48 89 c7             	mov    %rax,%rdi
  806f56:	48 b8 e5 5d 80 00 00 	movabs $0x805de5,%rax
  806f5d:	00 00 00 
  806f60:	ff d0                	callq  *%rax
  806f62:	89 45 f4             	mov    %eax,-0xc(%rbp)

  if (i == -1) {
  806f65:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%rbp)
  806f69:	75 2a                	jne    806f95 <lwip_socket+0x12d>
    netconn_delete(conn);
  806f6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806f6f:	48 89 c7             	mov    %rax,%rdi
  806f72:	48 b8 ac 9d 81 00 00 	movabs $0x819dac,%rax
  806f79:	00 00 00 
  806f7c:	ff d0                	callq  *%rax
    set_errno(ENFILE);
  806f7e:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806f85:	00 00 00 
  806f88:	c7 00 17 00 00 00    	movl   $0x17,(%rax)
    return -1;
  806f8e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806f93:	eb 1d                	jmp    806fb2 <lwip_socket+0x14a>
  }
  conn->socket = i;
  806f95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806f99:	8b 55 f4             	mov    -0xc(%rbp),%edx
  806f9c:	89 50 20             	mov    %edx,0x20(%rax)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  806f9f:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806fa6:	00 00 00 
  806fa9:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  return i;
  806faf:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  806fb2:	c9                   	leaveq 
  806fb3:	c3                   	retq   

0000000000806fb4 <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  806fb4:	55                   	push   %rbp
  806fb5:	48 89 e5             	mov    %rsp,%rbp
  806fb8:	48 83 ec 10          	sub    $0x10,%rsp
  806fbc:	89 7d fc             	mov    %edi,-0x4(%rbp)
  806fbf:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  806fc3:	89 55 f8             	mov    %edx,-0x8(%rbp)
  return lwip_send(s, data, size, 0);
  806fc6:	8b 55 f8             	mov    -0x8(%rbp),%edx
  806fc9:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  806fcd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806fd0:	b9 00 00 00 00       	mov    $0x0,%ecx
  806fd5:	89 c7                	mov    %eax,%edi
  806fd7:	48 b8 48 6b 80 00 00 	movabs $0x806b48,%rax
  806fde:	00 00 00 
  806fe1:	ff d0                	callq  *%rax
}
  806fe3:	c9                   	leaveq 
  806fe4:	c3                   	retq   

0000000000806fe5 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  806fe5:	55                   	push   %rbp
  806fe6:	48 89 e5             	mov    %rsp,%rbp
  806fe9:	48 83 ec 60          	sub    $0x60,%rsp
  806fed:	89 7d bc             	mov    %edi,-0x44(%rbp)
  806ff0:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  806ff4:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  806ff8:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
  int i, nready = 0;
  806ffc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  807003:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  807007:	ba 04 00 00 00       	mov    $0x4,%edx
  80700c:	be 00 00 00 00       	mov    $0x0,%esi
  807011:	48 89 c7             	mov    %rax,%rdi
  807014:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  80701b:	00 00 00 
  80701e:	ff d0                	callq  *%rax
  FD_ZERO(&lwriteset);
  807020:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  807024:	ba 04 00 00 00       	mov    $0x4,%edx
  807029:	be 00 00 00 00       	mov    $0x0,%esi
  80702e:	48 89 c7             	mov    %rax,%rdi
  807031:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  807038:	00 00 00 
  80703b:	ff d0                	callq  *%rax
  FD_ZERO(&lexceptset);
  80703d:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  807041:	ba 04 00 00 00       	mov    $0x4,%edx
  807046:	be 00 00 00 00       	mov    $0x0,%esi
  80704b:	48 89 c7             	mov    %rax,%rdi
  80704e:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  807055:	00 00 00 
  807058:	ff d0                	callq  *%rax
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  80705a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  807061:	e9 33 01 00 00       	jmpq   807199 <lwip_selscan+0x1b4>
    if (FD_ISSET(i, readset)) {
  807066:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807069:	8d 50 07             	lea    0x7(%rax),%edx
  80706c:	85 c0                	test   %eax,%eax
  80706e:	0f 48 c2             	cmovs  %edx,%eax
  807071:	c1 f8 03             	sar    $0x3,%eax
  807074:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  807078:	48 98                	cltq   
  80707a:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80707e:	0f b6 d0             	movzbl %al,%edx
  807081:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807084:	83 e0 07             	and    $0x7,%eax
  807087:	89 c1                	mov    %eax,%ecx
  807089:	d3 fa                	sar    %cl,%edx
  80708b:	89 d0                	mov    %edx,%eax
  80708d:	83 e0 01             	and    $0x1,%eax
  807090:	85 c0                	test   %eax,%eax
  807092:	74 70                	je     807104 <lwip_selscan+0x11f>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  807094:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807097:	89 c7                	mov    %eax,%edi
  807099:	48 b8 71 5d 80 00 00 	movabs $0x805d71,%rax
  8070a0:	00 00 00 
  8070a3:	ff d0                	callq  *%rax
  8070a5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8070a9:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8070ae:	74 54                	je     807104 <lwip_selscan+0x11f>
  8070b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8070b4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8070b8:	48 85 c0             	test   %rax,%rax
  8070bb:	75 0d                	jne    8070ca <lwip_selscan+0xe5>
  8070bd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8070c1:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8070c5:	66 85 c0             	test   %ax,%ax
  8070c8:	74 3a                	je     807104 <lwip_selscan+0x11f>
        FD_SET(i, &lreadset);
  8070ca:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8070cd:	8d 50 07             	lea    0x7(%rax),%edx
  8070d0:	85 c0                	test   %eax,%eax
  8070d2:	0f 48 c2             	cmovs  %edx,%eax
  8070d5:	c1 f8 03             	sar    $0x3,%eax
  8070d8:	89 c2                	mov    %eax,%edx
  8070da:	48 63 c2             	movslq %edx,%rax
  8070dd:	0f b6 44 05 e0       	movzbl -0x20(%rbp,%rax,1),%eax
  8070e2:	89 c7                	mov    %eax,%edi
  8070e4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8070e7:	83 e0 07             	and    $0x7,%eax
  8070ea:	be 01 00 00 00       	mov    $0x1,%esi
  8070ef:	89 c1                	mov    %eax,%ecx
  8070f1:	d3 e6                	shl    %cl,%esi
  8070f3:	89 f0                	mov    %esi,%eax
  8070f5:	09 f8                	or     %edi,%eax
  8070f7:	89 c1                	mov    %eax,%ecx
  8070f9:	48 63 c2             	movslq %edx,%rax
  8070fc:	88 4c 05 e0          	mov    %cl,-0x20(%rbp,%rax,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  807100:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  807104:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807107:	8d 50 07             	lea    0x7(%rax),%edx
  80710a:	85 c0                	test   %eax,%eax
  80710c:	0f 48 c2             	cmovs  %edx,%eax
  80710f:	c1 f8 03             	sar    $0x3,%eax
  807112:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  807116:	48 98                	cltq   
  807118:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80711c:	0f b6 d0             	movzbl %al,%edx
  80711f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807122:	83 e0 07             	and    $0x7,%eax
  807125:	89 c1                	mov    %eax,%ecx
  807127:	d3 fa                	sar    %cl,%edx
  807129:	89 d0                	mov    %edx,%eax
  80712b:	83 e0 01             	and    $0x1,%eax
  80712e:	85 c0                	test   %eax,%eax
  807130:	74 63                	je     807195 <lwip_selscan+0x1b0>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  807132:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807135:	89 c7                	mov    %eax,%edi
  807137:	48 b8 71 5d 80 00 00 	movabs $0x805d71,%rax
  80713e:	00 00 00 
  807141:	ff d0                	callq  *%rax
  807143:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      if (p_sock && p_sock->sendevent) {
  807147:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80714c:	74 47                	je     807195 <lwip_selscan+0x1b0>
  80714e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807152:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  807156:	66 85 c0             	test   %ax,%ax
  807159:	74 3a                	je     807195 <lwip_selscan+0x1b0>
        FD_SET(i, &lwriteset);
  80715b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80715e:	8d 50 07             	lea    0x7(%rax),%edx
  807161:	85 c0                	test   %eax,%eax
  807163:	0f 48 c2             	cmovs  %edx,%eax
  807166:	c1 f8 03             	sar    $0x3,%eax
  807169:	89 c2                	mov    %eax,%edx
  80716b:	48 63 c2             	movslq %edx,%rax
  80716e:	0f b6 44 05 d0       	movzbl -0x30(%rbp,%rax,1),%eax
  807173:	89 c7                	mov    %eax,%edi
  807175:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807178:	83 e0 07             	and    $0x7,%eax
  80717b:	be 01 00 00 00       	mov    $0x1,%esi
  807180:	89 c1                	mov    %eax,%ecx
  807182:	d3 e6                	shl    %cl,%esi
  807184:	89 f0                	mov    %esi,%eax
  807186:	09 f8                	or     %edi,%eax
  807188:	89 c1                	mov    %eax,%ecx
  80718a:	48 63 c2             	movslq %edx,%rax
  80718d:	88 4c 05 d0          	mov    %cl,-0x30(%rbp,%rax,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  807191:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  807195:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  807199:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80719c:	3b 45 bc             	cmp    -0x44(%rbp),%eax
  80719f:	0f 8c c1 fe ff ff    	jl     807066 <lwip_selscan+0x81>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  8071a5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8071a9:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8071ac:	89 10                	mov    %edx,(%rax)
  *writeset = lwriteset;
  8071ae:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8071b2:	8b 55 d0             	mov    -0x30(%rbp),%edx
  8071b5:	89 10                	mov    %edx,(%rax)
  FD_ZERO(exceptset);
  8071b7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8071bb:	ba 04 00 00 00       	mov    $0x4,%edx
  8071c0:	be 00 00 00 00       	mov    $0x0,%esi
  8071c5:	48 89 c7             	mov    %rax,%rdi
  8071c8:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  8071cf:	00 00 00 
  8071d2:	ff d0                	callq  *%rax
  
  return nready;
  8071d4:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  8071d7:	c9                   	leaveq 
  8071d8:	c3                   	retq   

00000000008071d9 <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  8071d9:	55                   	push   %rbp
  8071da:	48 89 e5             	mov    %rsp,%rbp
  8071dd:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8071e4:	89 7d 8c             	mov    %edi,-0x74(%rbp)
  8071e7:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  8071eb:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  8071f2:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  8071f9:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  807200:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  807207:	00 
  select_cb.readset = readset;
  807208:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80720c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  select_cb.writeset = writeset;
  807210:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  807217:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  select_cb.exceptset = exceptset;
  80721b:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  807222:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  select_cb.sem_signalled = 0;
  807226:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  80722d:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807234:	00 00 00 
  807237:	8b 00                	mov    (%rax),%eax
  807239:	89 c7                	mov    %eax,%edi
  80723b:	48 b8 77 e7 80 00 00 	movabs $0x80e777,%rax
  807242:	00 00 00 
  807245:	ff d0                	callq  *%rax

  if (readset)
  807247:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  80724c:	74 0b                	je     807259 <lwip_select+0x80>
    lreadset = *readset;
  80724e:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  807252:	8b 00                	mov    (%rax),%eax
  807254:	89 45 e0             	mov    %eax,-0x20(%rbp)
  807257:	eb 1d                	jmp    807276 <lwip_select+0x9d>
  else
    FD_ZERO(&lreadset);
  807259:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80725d:	ba 04 00 00 00       	mov    $0x4,%edx
  807262:	be 00 00 00 00       	mov    $0x0,%esi
  807267:	48 89 c7             	mov    %rax,%rdi
  80726a:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  807271:	00 00 00 
  807274:	ff d0                	callq  *%rax
  if (writeset)
  807276:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  80727d:	00 
  80727e:	74 0e                	je     80728e <lwip_select+0xb5>
    lwriteset = *writeset;
  807280:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  807287:	8b 00                	mov    (%rax),%eax
  807289:	89 45 d0             	mov    %eax,-0x30(%rbp)
  80728c:	eb 1d                	jmp    8072ab <lwip_select+0xd2>
  else
    FD_ZERO(&lwriteset);
  80728e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  807292:	ba 04 00 00 00       	mov    $0x4,%edx
  807297:	be 00 00 00 00       	mov    $0x0,%esi
  80729c:	48 89 c7             	mov    %rax,%rdi
  80729f:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  8072a6:	00 00 00 
  8072a9:	ff d0                	callq  *%rax
  if (exceptset)
  8072ab:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  8072b2:	00 
  8072b3:	74 0e                	je     8072c3 <lwip_select+0xea>
    lexceptset = *exceptset;
  8072b5:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8072bc:	8b 00                	mov    (%rax),%eax
  8072be:	89 45 c0             	mov    %eax,-0x40(%rbp)
  8072c1:	eb 1d                	jmp    8072e0 <lwip_select+0x107>
  else
    FD_ZERO(&lexceptset);
  8072c3:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8072c7:	ba 04 00 00 00       	mov    $0x4,%edx
  8072cc:	be 00 00 00 00       	mov    $0x0,%esi
  8072d1:	48 89 c7             	mov    %rax,%rdi
  8072d4:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  8072db:	00 00 00 
  8072de:	ff d0                	callq  *%rax

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  8072e0:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  8072e4:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8072e8:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8072ec:	8b 45 8c             	mov    -0x74(%rbp),%eax
  8072ef:	89 c7                	mov    %eax,%edi
  8072f1:	48 b8 e5 6f 80 00 00 	movabs $0x806fe5,%rax
  8072f8:	00 00 00 
  8072fb:	ff d0                	callq  *%rax
  8072fd:	89 45 fc             	mov    %eax,-0x4(%rbp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  807300:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  807304:	0f 85 b9 03 00 00    	jne    8076c3 <lwip_select+0x4ea>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  80730a:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  807311:	00 
  807312:	0f 84 d3 00 00 00    	je     8073eb <lwip_select+0x212>
  807318:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80731f:	48 8b 00             	mov    (%rax),%rax
  807322:	48 85 c0             	test   %rax,%rax
  807325:	0f 85 c0 00 00 00    	jne    8073eb <lwip_select+0x212>
  80732b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  807332:	48 8b 40 08          	mov    0x8(%rax),%rax
  807336:	48 85 c0             	test   %rax,%rax
  807339:	0f 85 ac 00 00 00    	jne    8073eb <lwip_select+0x212>
      sys_sem_signal(selectsem);
  80733f:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807346:	00 00 00 
  807349:	8b 00                	mov    (%rax),%eax
  80734b:	89 c7                	mov    %eax,%edi
  80734d:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  807354:	00 00 00 
  807357:	ff d0                	callq  *%rax
      if (readset)
  807359:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  80735e:	74 1d                	je     80737d <lwip_select+0x1a4>
        FD_ZERO(readset);
  807360:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  807364:	ba 04 00 00 00       	mov    $0x4,%edx
  807369:	be 00 00 00 00       	mov    $0x0,%esi
  80736e:	48 89 c7             	mov    %rax,%rdi
  807371:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  807378:	00 00 00 
  80737b:	ff d0                	callq  *%rax
      if (writeset)
  80737d:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  807384:	00 
  807385:	74 20                	je     8073a7 <lwip_select+0x1ce>
        FD_ZERO(writeset);
  807387:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80738e:	ba 04 00 00 00       	mov    $0x4,%edx
  807393:	be 00 00 00 00       	mov    $0x0,%esi
  807398:	48 89 c7             	mov    %rax,%rdi
  80739b:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  8073a2:	00 00 00 
  8073a5:	ff d0                	callq  *%rax
      if (exceptset)
  8073a7:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  8073ae:	00 
  8073af:	74 20                	je     8073d1 <lwip_select+0x1f8>
        FD_ZERO(exceptset);
  8073b1:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8073b8:	ba 04 00 00 00       	mov    $0x4,%edx
  8073bd:	be 00 00 00 00       	mov    $0x0,%esi
  8073c2:	48 89 c7             	mov    %rax,%rdi
  8073c5:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  8073cc:	00 00 00 
  8073cf:	ff d0                	callq  *%rax
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  8073d1:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8073d8:	00 00 00 
  8073db:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
      return 0;
  8073e1:	b8 00 00 00 00       	mov    $0x0,%eax
  8073e6:	e9 41 03 00 00       	jmpq   80772c <lwip_select+0x553>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  8073eb:	bf 00 00 00 00       	mov    $0x0,%edi
  8073f0:	48 b8 5c 7f 81 00 00 	movabs $0x817f5c,%rax
  8073f7:	00 00 00 
  8073fa:	ff d0                	callq  *%rax
  8073fc:	89 45 b4             	mov    %eax,-0x4c(%rbp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  8073ff:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  807406:	00 00 00 
  807409:	48 8b 00             	mov    (%rax),%rax
  80740c:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    select_cb_list = &select_cb;
  807410:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  807417:	00 00 00 
  80741a:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  80741e:	48 89 10             	mov    %rdx,(%rax)
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  807421:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807428:	00 00 00 
  80742b:	8b 00                	mov    (%rax),%eax
  80742d:	89 c7                	mov    %eax,%edi
  80742f:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  807436:	00 00 00 
  807439:	ff d0                	callq  *%rax
    
    /* Now just wait to be woken */
    if (timeout == 0)
  80743b:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  807442:	00 
  807443:	75 09                	jne    80744e <lwip_select+0x275>
      /* Wait forever */
      msectimeout = 0;
  807445:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  80744c:	eb 55                	jmp    8074a3 <lwip_select+0x2ca>
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  80744e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  807455:	48 8b 00             	mov    (%rax),%rax
  807458:	69 f0 e8 03 00 00    	imul   $0x3e8,%eax,%esi
  80745e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  807465:	48 8b 40 08          	mov    0x8(%rax),%rax
  807469:	48 8d 88 f4 01 00 00 	lea    0x1f4(%rax),%rcx
  807470:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  807477:	9b c4 20 
  80747a:	48 89 c8             	mov    %rcx,%rax
  80747d:	48 f7 ea             	imul   %rdx
  807480:	48 c1 fa 07          	sar    $0x7,%rdx
  807484:	48 89 c8             	mov    %rcx,%rax
  807487:	48 c1 f8 3f          	sar    $0x3f,%rax
  80748b:	48 29 c2             	sub    %rax,%rdx
  80748e:	48 89 d0             	mov    %rdx,%rax
  807491:	01 f0                	add    %esi,%eax
  807493:	89 45 f8             	mov    %eax,-0x8(%rbp)
      if(msectimeout == 0)
  807496:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80749a:	75 07                	jne    8074a3 <lwip_select+0x2ca>
        msectimeout = 1;
  80749c:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%rbp)
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  8074a3:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8074a6:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8074a9:	89 d6                	mov    %edx,%esi
  8074ab:	89 c7                	mov    %eax,%edi
  8074ad:	48 b8 ee eb 80 00 00 	movabs $0x80ebee,%rax
  8074b4:	00 00 00 
  8074b7:	ff d0                	callq  *%rax
  8074b9:	89 45 ec             	mov    %eax,-0x14(%rbp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  8074bc:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8074c3:	00 00 00 
  8074c6:	8b 00                	mov    (%rax),%eax
  8074c8:	89 c7                	mov    %eax,%edi
  8074ca:	48 b8 77 e7 80 00 00 	movabs $0x80e777,%rax
  8074d1:	00 00 00 
  8074d4:	ff d0                	callq  *%rax
    if (select_cb_list == &select_cb)
  8074d6:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  8074dd:	00 00 00 
  8074e0:	48 8b 10             	mov    (%rax),%rdx
  8074e3:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8074e7:	48 39 c2             	cmp    %rax,%rdx
  8074ea:	75 13                	jne    8074ff <lwip_select+0x326>
      select_cb_list = select_cb.next;
  8074ec:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8074f0:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  8074f7:	00 00 00 
  8074fa:	48 89 10             	mov    %rdx,(%rax)
  8074fd:	eb 42                	jmp    807541 <lwip_select+0x368>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  8074ff:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  807506:	00 00 00 
  807509:	48 8b 00             	mov    (%rax),%rax
  80750c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  807510:	eb 28                	jmp    80753a <lwip_select+0x361>
        if (p_selcb->next == &select_cb) {
  807512:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807516:	48 8b 10             	mov    (%rax),%rdx
  807519:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  80751d:	48 39 c2             	cmp    %rax,%rdx
  807520:	75 0d                	jne    80752f <lwip_select+0x356>
          p_selcb->next = select_cb.next;
  807522:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  807526:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80752a:	48 89 10             	mov    %rdx,(%rax)
          break;
  80752d:	eb 12                	jmp    807541 <lwip_select+0x368>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  80752f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807533:	48 8b 00             	mov    (%rax),%rax
  807536:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80753a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80753f:	75 d1                	jne    807512 <lwip_select+0x339>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  807541:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807548:	00 00 00 
  80754b:	8b 00                	mov    (%rax),%eax
  80754d:	89 c7                	mov    %eax,%edi
  80754f:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  807556:	00 00 00 
  807559:	ff d0                	callq  *%rax
    
    sys_sem_free(select_cb.sem);
  80755b:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80755e:	89 c7                	mov    %eax,%edi
  807560:	48 b8 5a 80 81 00 00 	movabs $0x81805a,%rax
  807567:	00 00 00 
  80756a:	ff d0                	callq  *%rax
    if (i == 0)  {
  80756c:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  807570:	0f 85 92 00 00 00    	jne    807608 <lwip_select+0x42f>
      /* Timeout */
      if (readset)
  807576:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  80757b:	74 1d                	je     80759a <lwip_select+0x3c1>
        FD_ZERO(readset);
  80757d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  807581:	ba 04 00 00 00       	mov    $0x4,%edx
  807586:	be 00 00 00 00       	mov    $0x0,%esi
  80758b:	48 89 c7             	mov    %rax,%rdi
  80758e:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  807595:	00 00 00 
  807598:	ff d0                	callq  *%rax
      if (writeset)
  80759a:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  8075a1:	00 
  8075a2:	74 20                	je     8075c4 <lwip_select+0x3eb>
        FD_ZERO(writeset);
  8075a4:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8075ab:	ba 04 00 00 00       	mov    $0x4,%edx
  8075b0:	be 00 00 00 00       	mov    $0x0,%esi
  8075b5:	48 89 c7             	mov    %rax,%rdi
  8075b8:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  8075bf:	00 00 00 
  8075c2:	ff d0                	callq  *%rax
      if (exceptset)
  8075c4:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  8075cb:	00 
  8075cc:	74 20                	je     8075ee <lwip_select+0x415>
        FD_ZERO(exceptset);
  8075ce:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8075d5:	ba 04 00 00 00       	mov    $0x4,%edx
  8075da:	be 00 00 00 00       	mov    $0x0,%esi
  8075df:	48 89 c7             	mov    %rax,%rdi
  8075e2:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  8075e9:	00 00 00 
  8075ec:	ff d0                	callq  *%rax
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  8075ee:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8075f5:	00 00 00 
  8075f8:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
      return 0;
  8075fe:	b8 00 00 00 00       	mov    $0x0,%eax
  807603:	e9 24 01 00 00       	jmpq   80772c <lwip_select+0x553>
    }
    
    if (readset)
  807608:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  80760d:	74 0b                	je     80761a <lwip_select+0x441>
      lreadset = *readset;
  80760f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  807613:	8b 00                	mov    (%rax),%eax
  807615:	89 45 e0             	mov    %eax,-0x20(%rbp)
  807618:	eb 1d                	jmp    807637 <lwip_select+0x45e>
    else
      FD_ZERO(&lreadset);
  80761a:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80761e:	ba 04 00 00 00       	mov    $0x4,%edx
  807623:	be 00 00 00 00       	mov    $0x0,%esi
  807628:	48 89 c7             	mov    %rax,%rdi
  80762b:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  807632:	00 00 00 
  807635:	ff d0                	callq  *%rax
    if (writeset)
  807637:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  80763e:	00 
  80763f:	74 0e                	je     80764f <lwip_select+0x476>
      lwriteset = *writeset;
  807641:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  807648:	8b 00                	mov    (%rax),%eax
  80764a:	89 45 d0             	mov    %eax,-0x30(%rbp)
  80764d:	eb 1d                	jmp    80766c <lwip_select+0x493>
    else
      FD_ZERO(&lwriteset);
  80764f:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  807653:	ba 04 00 00 00       	mov    $0x4,%edx
  807658:	be 00 00 00 00       	mov    $0x0,%esi
  80765d:	48 89 c7             	mov    %rax,%rdi
  807660:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  807667:	00 00 00 
  80766a:	ff d0                	callq  *%rax
    if (exceptset)
  80766c:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  807673:	00 
  807674:	74 0e                	je     807684 <lwip_select+0x4ab>
      lexceptset = *exceptset;
  807676:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80767d:	8b 00                	mov    (%rax),%eax
  80767f:	89 45 c0             	mov    %eax,-0x40(%rbp)
  807682:	eb 1d                	jmp    8076a1 <lwip_select+0x4c8>
    else
      FD_ZERO(&lexceptset);
  807684:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  807688:	ba 04 00 00 00       	mov    $0x4,%edx
  80768d:	be 00 00 00 00       	mov    $0x0,%esi
  807692:	48 89 c7             	mov    %rax,%rdi
  807695:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  80769c:	00 00 00 
  80769f:	ff d0                	callq  *%rax
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  8076a1:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  8076a5:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8076a9:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8076ad:	8b 45 8c             	mov    -0x74(%rbp),%eax
  8076b0:	89 c7                	mov    %eax,%edi
  8076b2:	48 b8 e5 6f 80 00 00 	movabs $0x806fe5,%rax
  8076b9:	00 00 00 
  8076bc:	ff d0                	callq  *%rax
  8076be:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8076c1:	eb 1a                	jmp    8076dd <lwip_select+0x504>
  } else
    sys_sem_signal(selectsem);
  8076c3:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8076ca:	00 00 00 
  8076cd:	8b 00                	mov    (%rax),%eax
  8076cf:	89 c7                	mov    %eax,%edi
  8076d1:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  8076d8:	00 00 00 
  8076db:	ff d0                	callq  *%rax
  
  if (readset)
  8076dd:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  8076e2:	74 09                	je     8076ed <lwip_select+0x514>
    *readset = lreadset;
  8076e4:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8076e8:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8076eb:	89 10                	mov    %edx,(%rax)
  if (writeset)
  8076ed:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  8076f4:	00 
  8076f5:	74 0c                	je     807703 <lwip_select+0x52a>
    *writeset = lwriteset;
  8076f7:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8076fe:	8b 55 d0             	mov    -0x30(%rbp),%edx
  807701:	89 10                	mov    %edx,(%rax)
  if (exceptset)
  807703:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  80770a:	00 
  80770b:	74 0c                	je     807719 <lwip_select+0x540>
    *exceptset = lexceptset;
  80770d:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  807714:	8b 55 c0             	mov    -0x40(%rbp),%edx
  807717:	89 10                	mov    %edx,(%rax)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  807719:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807720:	00 00 00 
  807723:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
  return nready;
  807729:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80772c:	c9                   	leaveq 
  80772d:	c3                   	retq   

000000000080772e <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  80772e:	55                   	push   %rbp
  80772f:	48 89 e5             	mov    %rsp,%rbp
  807732:	48 83 ec 30          	sub    $0x30,%rsp
  807736:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80773a:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  80773d:	89 d0                	mov    %edx,%eax
  80773f:	66 89 45 d0          	mov    %ax,-0x30(%rbp)
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  807743:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  807748:	0f 84 b3 02 00 00    	je     807a01 <event_callback+0x2d3>
    s = conn->socket;
  80774e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807752:	8b 40 20             	mov    0x20(%rax),%eax
  807755:	89 45 f4             	mov    %eax,-0xc(%rbp)
    if (s < 0) {
  807758:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  80775c:	79 75                	jns    8077d3 <event_callback+0xa5>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  80775e:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  807765:	00 00 00 
  807768:	8b 00                	mov    (%rax),%eax
  80776a:	89 c7                	mov    %eax,%edi
  80776c:	48 b8 77 e7 80 00 00 	movabs $0x80e777,%rax
  807773:	00 00 00 
  807776:	ff d0                	callq  *%rax
      if (conn->socket < 0) {
  807778:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80777c:	8b 40 20             	mov    0x20(%rax),%eax
  80777f:	85 c0                	test   %eax,%eax
  807781:	79 36                	jns    8077b9 <event_callback+0x8b>
        if (evt == NETCONN_EVT_RCVPLUS) {
  807783:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  807787:	75 11                	jne    80779a <event_callback+0x6c>
          conn->socket--;
  807789:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80778d:	8b 40 20             	mov    0x20(%rax),%eax
  807790:	8d 50 ff             	lea    -0x1(%rax),%edx
  807793:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807797:	89 50 20             	mov    %edx,0x20(%rax)
        }
        sys_sem_signal(socksem);
  80779a:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  8077a1:	00 00 00 
  8077a4:	8b 00                	mov    (%rax),%eax
  8077a6:	89 c7                	mov    %eax,%edi
  8077a8:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  8077af:	00 00 00 
  8077b2:	ff d0                	callq  *%rax
        return;
  8077b4:	e9 4c 02 00 00       	jmpq   807a05 <event_callback+0x2d7>
      }
      sys_sem_signal(socksem);
  8077b9:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  8077c0:	00 00 00 
  8077c3:	8b 00                	mov    (%rax),%eax
  8077c5:	89 c7                	mov    %eax,%edi
  8077c7:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  8077ce:	00 00 00 
  8077d1:	ff d0                	callq  *%rax
    }

    sock = get_socket(s);
  8077d3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8077d6:	89 c7                	mov    %eax,%edi
  8077d8:	48 b8 71 5d 80 00 00 	movabs $0x805d71,%rax
  8077df:	00 00 00 
  8077e2:	ff d0                	callq  *%rax
  8077e4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (!sock) {
  8077e8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8077ed:	0f 84 11 02 00 00    	je     807a04 <event_callback+0x2d6>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  8077f3:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8077fa:	00 00 00 
  8077fd:	8b 00                	mov    (%rax),%eax
  8077ff:	89 c7                	mov    %eax,%edi
  807801:	48 b8 77 e7 80 00 00 	movabs $0x80e777,%rax
  807808:	00 00 00 
  80780b:	ff d0                	callq  *%rax
  /* Set event as required */
  switch (evt) {
  80780d:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  807810:	83 f8 01             	cmp    $0x1,%eax
  807813:	74 26                	je     80783b <event_callback+0x10d>
  807815:	83 f8 01             	cmp    $0x1,%eax
  807818:	72 0c                	jb     807826 <event_callback+0xf8>
  80781a:	83 f8 02             	cmp    $0x2,%eax
  80781d:	74 31                	je     807850 <event_callback+0x122>
  80781f:	83 f8 03             	cmp    $0x3,%eax
  807822:	74 38                	je     80785c <event_callback+0x12e>
  807824:	eb 42                	jmp    807868 <event_callback+0x13a>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  807826:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80782a:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80782e:	8d 50 01             	lea    0x1(%rax),%edx
  807831:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807835:	66 89 50 12          	mov    %dx,0x12(%rax)
      break;
  807839:	eb 57                	jmp    807892 <event_callback+0x164>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  80783b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80783f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  807843:	8d 50 ff             	lea    -0x1(%rax),%edx
  807846:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80784a:	66 89 50 12          	mov    %dx,0x12(%rax)
      break;
  80784e:	eb 42                	jmp    807892 <event_callback+0x164>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  807850:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807854:	66 c7 40 14 01 00    	movw   $0x1,0x14(%rax)
      break;
  80785a:	eb 36                	jmp    807892 <event_callback+0x164>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  80785c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807860:	66 c7 40 14 00 00    	movw   $0x0,0x14(%rax)
      break;
  807866:	eb 2a                	jmp    807892 <event_callback+0x164>
    default:
      LWIP_ASSERT("unknown event", 0);
  807868:	48 ba b9 19 82 00 00 	movabs $0x8219b9,%rdx
  80786f:	00 00 00 
  807872:	be 18 04 00 00       	mov    $0x418,%esi
  807877:	48 bf 11 19 82 00 00 	movabs $0x821911,%rdi
  80787e:	00 00 00 
  807881:	b8 00 00 00 00       	mov    $0x0,%eax
  807886:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80788d:	00 00 00 
  807890:	ff d1                	callq  *%rcx
      break;
  }
  sys_sem_signal(selectsem);
  807892:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  807899:	00 00 00 
  80789c:	8b 00                	mov    (%rax),%eax
  80789e:	89 c7                	mov    %eax,%edi
  8078a0:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  8078a7:	00 00 00 
  8078aa:	ff d0                	callq  *%rax
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  8078ac:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8078b3:	00 00 00 
  8078b6:	8b 00                	mov    (%rax),%eax
  8078b8:	89 c7                	mov    %eax,%edi
  8078ba:	48 b8 77 e7 80 00 00 	movabs $0x80e777,%rax
  8078c1:	00 00 00 
  8078c4:	ff d0                	callq  *%rax
    for (scb = select_cb_list; scb; scb = scb->next) {
  8078c6:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  8078cd:	00 00 00 
  8078d0:	48 8b 00             	mov    (%rax),%rax
  8078d3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8078d7:	e9 b2 00 00 00       	jmpq   80798e <event_callback+0x260>
      if (scb->sem_signalled == 0) {
  8078dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8078e0:	8b 40 20             	mov    0x20(%rax),%eax
  8078e3:	85 c0                	test   %eax,%eax
  8078e5:	0f 85 98 00 00 00    	jne    807983 <event_callback+0x255>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  8078eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8078ef:	48 8b 40 08          	mov    0x8(%rax),%rax
  8078f3:	48 85 c0             	test   %rax,%rax
  8078f6:	74 3f                	je     807937 <event_callback+0x209>
  8078f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8078fc:	48 8b 50 08          	mov    0x8(%rax),%rdx
  807900:	8b 45 f4             	mov    -0xc(%rbp),%eax
  807903:	8d 48 07             	lea    0x7(%rax),%ecx
  807906:	85 c0                	test   %eax,%eax
  807908:	0f 48 c1             	cmovs  %ecx,%eax
  80790b:	c1 f8 03             	sar    $0x3,%eax
  80790e:	48 98                	cltq   
  807910:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  807914:	0f b6 d0             	movzbl %al,%edx
  807917:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80791a:	83 e0 07             	and    $0x7,%eax
  80791d:	89 c1                	mov    %eax,%ecx
  80791f:	d3 fa                	sar    %cl,%edx
  807921:	89 d0                	mov    %edx,%eax
  807923:	83 e0 01             	and    $0x1,%eax
  807926:	85 c0                	test   %eax,%eax
  807928:	74 0d                	je     807937 <event_callback+0x209>
          if (sock->rcvevent)
  80792a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80792e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  807932:	66 85 c0             	test   %ax,%ax
  807935:	75 64                	jne    80799b <event_callback+0x26d>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  807937:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80793b:	48 8b 40 10          	mov    0x10(%rax),%rax
  80793f:	48 85 c0             	test   %rax,%rax
  807942:	74 3f                	je     807983 <event_callback+0x255>
  807944:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807948:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80794c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80794f:	8d 48 07             	lea    0x7(%rax),%ecx
  807952:	85 c0                	test   %eax,%eax
  807954:	0f 48 c1             	cmovs  %ecx,%eax
  807957:	c1 f8 03             	sar    $0x3,%eax
  80795a:	48 98                	cltq   
  80795c:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  807960:	0f b6 d0             	movzbl %al,%edx
  807963:	8b 45 f4             	mov    -0xc(%rbp),%eax
  807966:	83 e0 07             	and    $0x7,%eax
  807969:	89 c1                	mov    %eax,%ecx
  80796b:	d3 fa                	sar    %cl,%edx
  80796d:	89 d0                	mov    %edx,%eax
  80796f:	83 e0 01             	and    $0x1,%eax
  807972:	85 c0                	test   %eax,%eax
  807974:	74 0d                	je     807983 <event_callback+0x255>
          if (sock->sendevent)
  807976:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80797a:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  80797e:	66 85 c0             	test   %ax,%ax
  807981:	75 1b                	jne    80799e <event_callback+0x270>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  807983:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807987:	48 8b 00             	mov    (%rax),%rax
  80798a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80798e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  807993:	0f 85 43 ff ff ff    	jne    8078dc <event_callback+0x1ae>
  807999:	eb 04                	jmp    80799f <event_callback+0x271>
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
          if (sock->rcvevent)
            break;
  80799b:	90                   	nop
  80799c:	eb 01                	jmp    80799f <event_callback+0x271>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
          if (sock->sendevent)
            break;
  80799e:	90                   	nop
      }
    }
    if (scb) {
  80799f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8079a4:	74 3f                	je     8079e5 <event_callback+0x2b7>
      scb->sem_signalled = 1;
  8079a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8079aa:	c7 40 20 01 00 00 00 	movl   $0x1,0x20(%rax)
      sys_sem_signal(selectsem);
  8079b1:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8079b8:	00 00 00 
  8079bb:	8b 00                	mov    (%rax),%eax
  8079bd:	89 c7                	mov    %eax,%edi
  8079bf:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  8079c6:	00 00 00 
  8079c9:	ff d0                	callq  *%rax
      sys_sem_signal(scb->sem);
  8079cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8079cf:	8b 40 24             	mov    0x24(%rax),%eax
  8079d2:	89 c7                	mov    %eax,%edi
  8079d4:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  8079db:	00 00 00 
  8079de:	ff d0                	callq  *%rax
  8079e0:	e9 c7 fe ff ff       	jmpq   8078ac <event_callback+0x17e>
    } else {
      sys_sem_signal(selectsem);
  8079e5:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8079ec:	00 00 00 
  8079ef:	8b 00                	mov    (%rax),%eax
  8079f1:	89 c7                	mov    %eax,%edi
  8079f3:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  8079fa:	00 00 00 
  8079fd:	ff d0                	callq  *%rax
      break;
  8079ff:	eb 04                	jmp    807a05 <event_callback+0x2d7>
    sock = get_socket(s);
    if (!sock) {
      return;
    }
  } else {
    return;
  807a01:	90                   	nop
  807a02:	eb 01                	jmp    807a05 <event_callback+0x2d7>
      sys_sem_signal(socksem);
    }

    sock = get_socket(s);
    if (!sock) {
      return;
  807a04:	90                   	nop
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
}
  807a05:	c9                   	leaveq 
  807a06:	c3                   	retq   

0000000000807a07 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  807a07:	55                   	push   %rbp
  807a08:	48 89 e5             	mov    %rsp,%rbp
  807a0b:	48 83 ec 10          	sub    $0x10,%rsp
  807a0f:	89 7d fc             	mov    %edi,-0x4(%rbp)
  807a12:	89 75 f8             	mov    %esi,-0x8(%rbp)
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  807a15:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807a18:	89 c7                	mov    %eax,%edi
  807a1a:	48 b8 cb 63 80 00 00 	movabs $0x8063cb,%rax
  807a21:	00 00 00 
  807a24:	ff d0                	callq  *%rax
}
  807a26:	c9                   	leaveq 
  807a27:	c3                   	retq   

0000000000807a28 <lwip_getaddrname>:

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  807a28:	55                   	push   %rbp
  807a29:	48 89 e5             	mov    %rsp,%rbp
  807a2c:	48 83 ec 50          	sub    $0x50,%rsp
  807a30:	89 7d cc             	mov    %edi,-0x34(%rbp)
  807a33:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  807a37:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  807a3b:	89 c8                	mov    %ecx,%eax
  807a3d:	88 45 c8             	mov    %al,-0x38(%rbp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  807a40:	8b 45 cc             	mov    -0x34(%rbp),%eax
  807a43:	89 c7                	mov    %eax,%edi
  807a45:	48 b8 71 5d 80 00 00 	movabs $0x805d71,%rax
  807a4c:	00 00 00 
  807a4f:	ff d0                	callq  *%rax
  807a51:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  807a55:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  807a5a:	75 0a                	jne    807a66 <lwip_getaddrname+0x3e>
    return -1;
  807a5c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807a61:	e9 c9 00 00 00       	jmpq   807b2f <lwip_getaddrname+0x107>

  memset(&sin, 0, sizeof(sin));
  807a66:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  807a6a:	ba 10 00 00 00       	mov    $0x10,%edx
  807a6f:	be 00 00 00 00       	mov    $0x0,%esi
  807a74:	48 89 c7             	mov    %rax,%rdi
  807a77:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  807a7e:	00 00 00 
  807a81:	ff d0                	callq  *%rax
  sin.sin_len = sizeof(sin);
  807a83:	c6 45 e0 10          	movb   $0x10,-0x20(%rbp)
  sin.sin_family = AF_INET;
  807a87:	c6 45 e1 02          	movb   $0x2,-0x1f(%rbp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  807a8b:	0f b6 55 c8          	movzbl -0x38(%rbp),%edx
  807a8f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807a93:	48 8b 00             	mov    (%rax),%rax
  807a96:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  807a9a:	48 8d 79 02          	lea    0x2(%rcx),%rdi
  807a9e:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  807aa2:	89 d1                	mov    %edx,%ecx
  807aa4:	48 89 fa             	mov    %rdi,%rdx
  807aa7:	48 89 c7             	mov    %rax,%rdi
  807aaa:	48 b8 5a 9e 81 00 00 	movabs $0x819e5a,%rax
  807ab1:	00 00 00 
  807ab4:	ff d0                	callq  *%rax

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  807ab6:	0f b7 45 e2          	movzwl -0x1e(%rbp),%eax
  807aba:	0f b7 c0             	movzwl %ax,%eax
  807abd:	89 c7                	mov    %eax,%edi
  807abf:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  807ac6:	00 00 00 
  807ac9:	ff d0                	callq  *%rax
  807acb:	66 89 45 e2          	mov    %ax,-0x1e(%rbp)
  sin.sin_addr.s_addr = naddr.addr;
  807acf:	8b 45 d0             	mov    -0x30(%rbp),%eax
  807ad2:	89 45 e4             	mov    %eax,-0x1c(%rbp)

  if (*namelen > sizeof(sin))
  807ad5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  807ad9:	8b 00                	mov    (%rax),%eax
  807adb:	83 f8 10             	cmp    $0x10,%eax
  807ade:	76 0a                	jbe    807aea <lwip_getaddrname+0xc2>
    *namelen = sizeof(sin);
  807ae0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  807ae4:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

  SMEMCPY(name, &sin, *namelen);
  807aea:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  807aee:	8b 00                	mov    (%rax),%eax
  807af0:	89 c2                	mov    %eax,%edx
  807af2:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  807af6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  807afa:	48 89 ce             	mov    %rcx,%rsi
  807afd:	48 89 c7             	mov    %rax,%rdi
  807b00:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  807b07:	00 00 00 
  807b0a:	ff d0                	callq  *%rax
  sock_set_errno(sock, 0);
  807b0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807b10:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  807b17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807b1b:	8b 50 18             	mov    0x18(%rax),%edx
  807b1e:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807b25:	00 00 00 
  807b28:	89 10                	mov    %edx,(%rax)
  return 0;
  807b2a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  807b2f:	c9                   	leaveq 
  807b30:	c3                   	retq   

0000000000807b31 <lwip_getpeername>:

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  807b31:	55                   	push   %rbp
  807b32:	48 89 e5             	mov    %rsp,%rbp
  807b35:	48 83 ec 20          	sub    $0x20,%rsp
  807b39:	89 7d fc             	mov    %edi,-0x4(%rbp)
  807b3c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  807b40:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  return lwip_getaddrname(s, name, namelen, 0);
  807b44:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  807b48:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  807b4c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807b4f:	b9 00 00 00 00       	mov    $0x0,%ecx
  807b54:	89 c7                	mov    %eax,%edi
  807b56:	48 b8 28 7a 80 00 00 	movabs $0x807a28,%rax
  807b5d:	00 00 00 
  807b60:	ff d0                	callq  *%rax
}
  807b62:	c9                   	leaveq 
  807b63:	c3                   	retq   

0000000000807b64 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  807b64:	55                   	push   %rbp
  807b65:	48 89 e5             	mov    %rsp,%rbp
  807b68:	48 83 ec 20          	sub    $0x20,%rsp
  807b6c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  807b6f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  807b73:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  return lwip_getaddrname(s, name, namelen, 1);
  807b77:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  807b7b:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  807b7f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807b82:	b9 01 00 00 00       	mov    $0x1,%ecx
  807b87:	89 c7                	mov    %eax,%edi
  807b89:	48 b8 28 7a 80 00 00 	movabs $0x807a28,%rax
  807b90:	00 00 00 
  807b93:	ff d0                	callq  *%rax
}
  807b95:	c9                   	leaveq 
  807b96:	c3                   	retq   

0000000000807b97 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  807b97:	55                   	push   %rbp
  807b98:	48 89 e5             	mov    %rsp,%rbp
  807b9b:	48 83 ec 60          	sub    $0x60,%rsp
  807b9f:	89 7d bc             	mov    %edi,-0x44(%rbp)
  807ba2:	89 75 b8             	mov    %esi,-0x48(%rbp)
  807ba5:	89 55 b4             	mov    %edx,-0x4c(%rbp)
  807ba8:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  807bac:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  err_t err = ERR_OK;
  807bb0:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  struct lwip_socket *sock = get_socket(s);
  807bb4:	8b 45 bc             	mov    -0x44(%rbp),%eax
  807bb7:	89 c7                	mov    %eax,%edi
  807bb9:	48 b8 71 5d 80 00 00 	movabs $0x805d71,%rax
  807bc0:	00 00 00 
  807bc3:	ff d0                	callq  *%rax
  807bc5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct lwip_setgetsockopt_data data;

  if (!sock)
  807bc9:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  807bce:	75 0a                	jne    807bda <lwip_getsockopt+0x43>
    return -1;
  807bd0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807bd5:	e9 15 02 00 00       	jmpq   807def <lwip_getsockopt+0x258>

  if ((NULL == optval) || (NULL == optlen)) {
  807bda:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  807bdf:	74 07                	je     807be8 <lwip_getsockopt+0x51>
  807be1:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  807be6:	75 28                	jne    807c10 <lwip_getsockopt+0x79>
    sock_set_errno(sock, EFAULT);
  807be8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807bec:	c7 40 18 0e 00 00 00 	movl   $0xe,0x18(%rax)
  807bf3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807bf7:	8b 50 18             	mov    0x18(%rax),%edx
  807bfa:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807c01:	00 00 00 
  807c04:	89 10                	mov    %edx,(%rax)
    return -1;
  807c06:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807c0b:	e9 df 01 00 00       	jmpq   807def <lwip_getsockopt+0x258>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  807c10:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807c13:	83 f8 06             	cmp    $0x6,%eax
  807c16:	0f 84 c2 00 00 00    	je     807cde <lwip_getsockopt+0x147>
  807c1c:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807c21:	74 0d                	je     807c30 <lwip_getsockopt+0x99>
  807c23:	85 c0                	test   %eax,%eax
  807c25:	0f 84 8e 00 00 00    	je     807cb9 <lwip_getsockopt+0x122>
  807c2b:	e9 eb 00 00 00       	jmpq   807d1b <lwip_getsockopt+0x184>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807c30:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807c33:	83 f8 20             	cmp    $0x20,%eax
  807c36:	74 28                	je     807c60 <lwip_getsockopt+0xc9>
  807c38:	83 f8 20             	cmp    $0x20,%eax
  807c3b:	7f 0c                	jg     807c49 <lwip_getsockopt+0xb2>
  807c3d:	83 f8 02             	cmp    $0x2,%eax
  807c40:	74 1e                	je     807c60 <lwip_getsockopt+0xc9>
  807c42:	83 f8 08             	cmp    $0x8,%eax
  807c45:	74 19                	je     807c60 <lwip_getsockopt+0xc9>
  807c47:	eb 64                	jmp    807cad <lwip_getsockopt+0x116>
  807c49:	3d 07 10 00 00       	cmp    $0x1007,%eax
  807c4e:	7c 5d                	jl     807cad <lwip_getsockopt+0x116>
  807c50:	3d 08 10 00 00       	cmp    $0x1008,%eax
  807c55:	7e 09                	jle    807c60 <lwip_getsockopt+0xc9>
  807c57:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  807c5c:	74 13                	je     807c71 <lwip_getsockopt+0xda>
  807c5e:	eb 4d                	jmp    807cad <lwip_getsockopt+0x116>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  807c60:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807c64:	8b 00                	mov    (%rax),%eax
  807c66:	83 f8 03             	cmp    $0x3,%eax
  807c69:	77 48                	ja     807cb3 <lwip_getsockopt+0x11c>
        err = EINVAL;
  807c6b:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
      break;
  807c6f:	eb 42                	jmp    807cb3 <lwip_getsockopt+0x11c>

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
  807c71:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807c75:	8b 00                	mov    (%rax),%eax
  807c77:	83 f8 03             	cmp    $0x3,%eax
  807c7a:	77 04                	ja     807c80 <lwip_getsockopt+0xe9>
        err = EINVAL;
  807c7c:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  807c80:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c84:	48 8b 00             	mov    (%rax),%rax
  807c87:	8b 00                	mov    (%rax),%eax
  807c89:	83 f8 20             	cmp    $0x20,%eax
  807c8c:	75 19                	jne    807ca7 <lwip_getsockopt+0x110>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  807c8e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c92:	48 8b 00             	mov    (%rax),%rax
  807c95:	48 8b 40 08          	mov    0x8(%rax),%rax
  807c99:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  807c9d:	0f b6 c0             	movzbl %al,%eax
  807ca0:	83 e0 02             	and    $0x2,%eax
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  807ca3:	85 c0                	test   %eax,%eax
  807ca5:	74 0f                	je     807cb6 <lwip_getsockopt+0x11f>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  807ca7:	c6 45 ff 61          	movb   $0x61,-0x1(%rbp)
      }
#endif /* LWIP_UDP */
      break;
  807cab:	eb 09                	jmp    807cb6 <lwip_getsockopt+0x11f>

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  807cad:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  807cb1:	eb 6c                	jmp    807d1f <lwip_getsockopt+0x188>
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
  807cb3:	90                   	nop
  807cb4:	eb 69                	jmp    807d1f <lwip_getsockopt+0x188>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
      }
#endif /* LWIP_UDP */
      break;
  807cb6:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  807cb7:	eb 66                	jmp    807d1f <lwip_getsockopt+0x188>
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  807cb9:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807cbc:	83 e8 01             	sub    $0x1,%eax
  807cbf:	83 f8 01             	cmp    $0x1,%eax
  807cc2:	77 11                	ja     807cd5 <lwip_getsockopt+0x13e>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  807cc4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807cc8:	8b 00                	mov    (%rax),%eax
  807cca:	83 f8 03             	cmp    $0x3,%eax
  807ccd:	77 0c                	ja     807cdb <lwip_getsockopt+0x144>
        err = EINVAL;
  807ccf:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
      break;
  807cd3:	eb 06                	jmp    807cdb <lwip_getsockopt+0x144>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  807cd5:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  807cd9:	eb 44                	jmp    807d1f <lwip_getsockopt+0x188>
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
  807cdb:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  807cdc:	eb 41                	jmp    807d1f <lwip_getsockopt+0x188>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  807cde:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807ce2:	8b 00                	mov    (%rax),%eax
  807ce4:	83 f8 03             	cmp    $0x3,%eax
  807ce7:	77 06                	ja     807cef <lwip_getsockopt+0x158>
      err = EINVAL;
  807ce9:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      break;
  807ced:	eb 30                	jmp    807d1f <lwip_getsockopt+0x188>
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  807cef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807cf3:	48 8b 00             	mov    (%rax),%rax
  807cf6:	8b 00                	mov    (%rax),%eax
  807cf8:	83 f8 10             	cmp    $0x10,%eax
  807cfb:	74 0a                	je     807d07 <lwip_getsockopt+0x170>
      return 0;
  807cfd:	b8 00 00 00 00       	mov    $0x0,%eax
  807d02:	e9 e8 00 00 00       	jmpq   807def <lwip_getsockopt+0x258>

    switch (optname) {
  807d07:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807d0a:	83 e8 01             	sub    $0x1,%eax
  807d0d:	83 f8 01             	cmp    $0x1,%eax
  807d10:	76 06                	jbe    807d18 <lwip_getsockopt+0x181>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  807d12:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  807d16:	eb 07                	jmp    807d1f <lwip_getsockopt+0x188>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
  807d18:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  807d19:	eb 04                	jmp    807d1f <lwip_getsockopt+0x188>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  807d1b:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
  }  /* switch */

   
  if (err != ERR_OK) {
  807d1f:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  807d23:	74 28                	je     807d4d <lwip_getsockopt+0x1b6>
    sock_set_errno(sock, err);
  807d25:	0f be 55 ff          	movsbl -0x1(%rbp),%edx
  807d29:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807d2d:	89 50 18             	mov    %edx,0x18(%rax)
  807d30:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807d34:	8b 50 18             	mov    0x18(%rax),%edx
  807d37:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807d3e:	00 00 00 
  807d41:	89 10                	mov    %edx,(%rax)
    return -1;
  807d43:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807d48:	e9 a2 00 00 00       	jmpq   807def <lwip_getsockopt+0x258>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  807d4d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807d51:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  data.level = level;
  807d55:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807d58:	89 45 cc             	mov    %eax,-0x34(%rbp)
  data.optname = optname;
  807d5b:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807d5e:	89 45 d0             	mov    %eax,-0x30(%rbp)
  data.optval = optval;
  807d61:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  807d65:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  data.optlen = optlen;
  807d69:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807d6d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  data.err = err;
  807d71:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  807d75:	88 45 e8             	mov    %al,-0x18(%rbp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  807d78:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  807d7c:	ba 01 00 00 00       	mov    $0x1,%edx
  807d81:	48 89 c6             	mov    %rax,%rsi
  807d84:	48 bf f1 7d 80 00 00 	movabs $0x807df1,%rdi
  807d8b:	00 00 00 
  807d8e:	48 b8 61 8b 80 00 00 	movabs $0x808b61,%rax
  807d95:	00 00 00 
  807d98:	ff d0                	callq  *%rax
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  807d9a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807d9e:	48 8b 00             	mov    (%rax),%rax
  807da1:	8b 40 14             	mov    0x14(%rax),%eax
  807da4:	be 00 00 00 00       	mov    $0x0,%esi
  807da9:	89 c7                	mov    %eax,%edi
  807dab:	48 b8 ea 82 81 00 00 	movabs $0x8182ea,%rax
  807db2:	00 00 00 
  807db5:	ff d0                	callq  *%rax
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  807db7:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  807dbb:	88 45 ff             	mov    %al,-0x1(%rbp)

  sock_set_errno(sock, err);
  807dbe:	0f be 55 ff          	movsbl -0x1(%rbp),%edx
  807dc2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807dc6:	89 50 18             	mov    %edx,0x18(%rax)
  807dc9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807dcd:	8b 50 18             	mov    0x18(%rax),%edx
  807dd0:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807dd7:	00 00 00 
  807dda:	89 10                	mov    %edx,(%rax)
  return err ? -1 : 0;
  807ddc:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  807de0:	74 07                	je     807de9 <lwip_getsockopt+0x252>
  807de2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807de7:	eb 06                	jmp    807def <lwip_getsockopt+0x258>
  807de9:	b8 00 00 00 00       	mov    $0x0,%eax
  807dee:	90                   	nop
}
  807def:	c9                   	leaveq 
  807df0:	c3                   	retq   

0000000000807df1 <lwip_getsockopt_internal>:

static void
lwip_getsockopt_internal(void *arg)
{
  807df1:	55                   	push   %rbp
  807df2:	48 89 e5             	mov    %rsp,%rbp
  807df5:	48 83 ec 40          	sub    $0x40,%rsp
  807df9:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  807dfd:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  807e02:	75 2a                	jne    807e2e <lwip_getsockopt_internal+0x3d>
  807e04:	48 ba c7 19 82 00 00 	movabs $0x8219c7,%rdx
  807e0b:	00 00 00 
  807e0e:	be 39 05 00 00       	mov    $0x539,%esi
  807e13:	48 bf 11 19 82 00 00 	movabs $0x821911,%rdi
  807e1a:	00 00 00 
  807e1d:	b8 00 00 00 00       	mov    $0x0,%eax
  807e22:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  807e29:	00 00 00 
  807e2c:	ff d1                	callq  *%rcx

  data = (struct lwip_setgetsockopt_data*)arg;
  807e2e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  807e32:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sock = data->sock;
  807e36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807e3a:	48 8b 00             	mov    (%rax),%rax
  807e3d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#ifdef LWIP_DEBUG
  s = data->s;
  807e41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807e45:	8b 40 08             	mov    0x8(%rax),%eax
  807e48:	89 45 ec             	mov    %eax,-0x14(%rbp)
#endif /* LWIP_DEBUG */
  level = data->level;
  807e4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807e4f:	8b 40 0c             	mov    0xc(%rax),%eax
  807e52:	89 45 e8             	mov    %eax,-0x18(%rbp)
  optname = data->optname;
  807e55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807e59:	8b 40 10             	mov    0x10(%rax),%eax
  807e5c:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  optval = data->optval;
  807e5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807e63:	48 8b 40 18          	mov    0x18(%rax),%rax
  807e67:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  switch (level) {
  807e6b:	8b 45 e8             	mov    -0x18(%rbp),%eax
  807e6e:	83 f8 06             	cmp    $0x6,%eax
  807e71:	0f 84 bc 01 00 00    	je     808033 <lwip_getsockopt_internal+0x242>
  807e77:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807e7c:	74 0d                	je     807e8b <lwip_getsockopt_internal+0x9a>
  807e7e:	85 c0                	test   %eax,%eax
  807e80:	0f 84 69 01 00 00    	je     807fef <lwip_getsockopt_internal+0x1fe>
  807e86:	e9 f1 01 00 00       	jmpq   80807c <lwip_getsockopt_internal+0x28b>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807e8b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807e8e:	83 f8 20             	cmp    $0x20,%eax
  807e91:	74 36                	je     807ec9 <lwip_getsockopt_internal+0xd8>
  807e93:	83 f8 20             	cmp    $0x20,%eax
  807e96:	7f 0f                	jg     807ea7 <lwip_getsockopt_internal+0xb6>
  807e98:	83 f8 02             	cmp    $0x2,%eax
  807e9b:	74 2c                	je     807ec9 <lwip_getsockopt_internal+0xd8>
  807e9d:	83 f8 08             	cmp    $0x8,%eax
  807ea0:	74 27                	je     807ec9 <lwip_getsockopt_internal+0xd8>
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
  807ea2:	e9 d5 01 00 00       	jmpq   80807c <lwip_getsockopt_internal+0x28b>

  switch (level) {
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807ea7:	3d 08 10 00 00       	cmp    $0x1008,%eax
  807eac:	74 3d                	je     807eeb <lwip_getsockopt_internal+0xfa>
  807eae:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  807eb3:	0f 84 0d 01 00 00    	je     807fc6 <lwip_getsockopt_internal+0x1d5>
  807eb9:	3d 07 10 00 00       	cmp    $0x1007,%eax
  807ebe:	0f 84 85 00 00 00    	je     807f49 <lwip_getsockopt_internal+0x158>
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
  807ec4:	e9 b3 01 00 00       	jmpq   80807c <lwip_getsockopt_internal+0x28b>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  807ec9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807ecd:	48 8b 00             	mov    (%rax),%rax
  807ed0:	48 8b 40 08          	mov    0x8(%rax),%rax
  807ed4:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  807ed8:	0f b7 c0             	movzwl %ax,%eax
  807edb:	23 45 e4             	and    -0x1c(%rbp),%eax
  807ede:	89 c2                	mov    %eax,%edx
  807ee0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807ee4:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  807ee6:	e9 ff 00 00 00       	jmpq   807fea <lwip_getsockopt_internal+0x1f9>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  807eeb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807eef:	48 8b 00             	mov    (%rax),%rax
  807ef2:	8b 00                	mov    (%rax),%eax
  807ef4:	25 f0 00 00 00       	and    $0xf0,%eax
  807ef9:	83 f8 20             	cmp    $0x20,%eax
  807efc:	74 24                	je     807f22 <lwip_getsockopt_internal+0x131>
  807efe:	83 f8 40             	cmp    $0x40,%eax
  807f01:	74 07                	je     807f0a <lwip_getsockopt_internal+0x119>
  807f03:	83 f8 10             	cmp    $0x10,%eax
  807f06:	74 0e                	je     807f16 <lwip_getsockopt_internal+0x125>
  807f08:	eb 24                	jmp    807f2e <lwip_getsockopt_internal+0x13d>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  807f0a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807f0e:	c7 00 03 00 00 00    	movl   $0x3,(%rax)
        break;
  807f14:	eb 2e                	jmp    807f44 <lwip_getsockopt_internal+0x153>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
  807f16:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807f1a:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
        break;
  807f20:	eb 22                	jmp    807f44 <lwip_getsockopt_internal+0x153>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  807f22:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807f26:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
        break;
  807f2c:	eb 16                	jmp    807f44 <lwip_getsockopt_internal+0x153>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  807f2e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f32:	48 8b 00             	mov    (%rax),%rax
  807f35:	8b 00                	mov    (%rax),%eax
  807f37:	89 c2                	mov    %eax,%edx
  807f39:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807f3d:	89 10                	mov    %edx,(%rax)
                    ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
                    s, *(int *)optval));
      }  /* switch (sock->conn->type) */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;
  807f3f:	e9 a6 00 00 00       	jmpq   807fea <lwip_getsockopt_internal+0x1f9>
  807f44:	e9 a1 00 00 00       	jmpq   807fea <lwip_getsockopt_internal+0x1f9>

    case SO_ERROR:
      if (sock->err == 0) {
  807f49:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f4d:	8b 40 18             	mov    0x18(%rax),%eax
  807f50:	85 c0                	test   %eax,%eax
  807f52:	75 58                	jne    807fac <lwip_getsockopt_internal+0x1bb>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  807f54:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f58:	48 8b 00             	mov    (%rax),%rax
  807f5b:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  807f5f:	0f be c0             	movsbl %al,%eax
  807f62:	f7 d8                	neg    %eax
  807f64:	83 f8 0e             	cmp    $0xe,%eax
  807f67:	77 24                	ja     807f8d <lwip_getsockopt_internal+0x19c>
  807f69:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f6d:	48 8b 00             	mov    (%rax),%rax
  807f70:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  807f74:	0f be c0             	movsbl %al,%eax
  807f77:	f7 d8                	neg    %eax
  807f79:	89 c2                	mov    %eax,%edx
  807f7b:	48 b8 c0 18 82 00 00 	movabs $0x8218c0,%rax
  807f82:	00 00 00 
  807f85:	48 63 d2             	movslq %edx,%rdx
  807f88:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  807f8b:	eb 05                	jmp    807f92 <lwip_getsockopt_internal+0x1a1>
  807f8d:	b8 05 00 00 00       	mov    $0x5,%eax
  807f92:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  807f96:	89 42 18             	mov    %eax,0x18(%rdx)
  807f99:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f9d:	8b 50 18             	mov    0x18(%rax),%edx
  807fa0:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807fa7:	00 00 00 
  807faa:	89 10                	mov    %edx,(%rax)
      } 
      *(int *)optval = sock->err;
  807fac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807fb0:	8b 50 18             	mov    0x18(%rax),%edx
  807fb3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807fb7:	89 10                	mov    %edx,(%rax)
      sock->err = 0;
  807fb9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807fbd:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  807fc4:	eb 24                	jmp    807fea <lwip_getsockopt_internal+0x1f9>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  807fc6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807fca:	48 8b 00             	mov    (%rax),%rax
  807fcd:	48 8b 40 08          	mov    0x8(%rax),%rax
  807fd1:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  807fd5:	0f b6 c0             	movzbl %al,%eax
  807fd8:	83 e0 01             	and    $0x1,%eax
  807fdb:	85 c0                	test   %eax,%eax
  807fdd:	0f 95 c0             	setne  %al
  807fe0:	0f b6 d0             	movzbl %al,%edx
  807fe3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807fe7:	89 10                	mov    %edx,(%rax)
      break;
  807fe9:	90                   	nop
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
  807fea:	e9 8d 00 00 00       	jmpq   80807c <lwip_getsockopt_internal+0x28b>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  807fef:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807ff2:	83 f8 01             	cmp    $0x1,%eax
  807ff5:	74 21                	je     808018 <lwip_getsockopt_internal+0x227>
  807ff7:	83 f8 02             	cmp    $0x2,%eax
  807ffa:	74 02                	je     807ffe <lwip_getsockopt_internal+0x20d>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  807ffc:	eb 7e                	jmp    80807c <lwip_getsockopt_internal+0x28b>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  807ffe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808002:	48 8b 00             	mov    (%rax),%rax
  808005:	48 8b 40 08          	mov    0x8(%rax),%rax
  808009:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  80800d:	0f b6 d0             	movzbl %al,%edx
  808010:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  808014:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  808016:	eb 19                	jmp    808031 <lwip_getsockopt_internal+0x240>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  808018:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80801c:	48 8b 00             	mov    (%rax),%rax
  80801f:	48 8b 40 08          	mov    0x8(%rax),%rax
  808023:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  808027:	0f b6 d0             	movzbl %al,%edx
  80802a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80802e:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
  808030:	90                   	nop
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  808031:	eb 49                	jmp    80807c <lwip_getsockopt_internal+0x28b>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  808033:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  808036:	83 f8 01             	cmp    $0x1,%eax
  808039:	74 07                	je     808042 <lwip_getsockopt_internal+0x251>
  80803b:	83 f8 02             	cmp    $0x2,%eax
  80803e:	74 21                	je     808061 <lwip_getsockopt_internal+0x270>
                  s, *(int *)optval));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  808040:	eb 39                	jmp    80807b <lwip_getsockopt_internal+0x28a>
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  808042:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808046:	48 8b 00             	mov    (%rax),%rax
  808049:	48 8b 40 08          	mov    0x8(%rax),%rax
  80804d:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  808051:	0f b6 c0             	movzbl %al,%eax
  808054:	83 e0 40             	and    $0x40,%eax
  808057:	89 c2                	mov    %eax,%edx
  808059:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80805d:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  80805f:	eb 1a                	jmp    80807b <lwip_getsockopt_internal+0x28a>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  808061:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808065:	48 8b 00             	mov    (%rax),%rax
  808068:	48 8b 40 08          	mov    0x8(%rax),%rax
  80806c:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  808072:	89 c2                	mov    %eax,%edx
  808074:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  808078:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPALIVE) = %d\n",
                  s, *(int *)optval));
      break;
  80807a:	90                   	nop
                  s, *(int *)optval));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  80807b:	90                   	nop
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  80807c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808080:	48 8b 00             	mov    (%rax),%rax
  808083:	8b 40 14             	mov    0x14(%rax),%eax
  808086:	89 c7                	mov    %eax,%edi
  808088:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  80808f:	00 00 00 
  808092:	ff d0                	callq  *%rax
}
  808094:	90                   	nop
  808095:	c9                   	leaveq 
  808096:	c3                   	retq   

0000000000808097 <lwip_setsockopt>:

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  808097:	55                   	push   %rbp
  808098:	48 89 e5             	mov    %rsp,%rbp
  80809b:	48 83 ec 60          	sub    $0x60,%rsp
  80809f:	89 7d bc             	mov    %edi,-0x44(%rbp)
  8080a2:	89 75 b8             	mov    %esi,-0x48(%rbp)
  8080a5:	89 55 b4             	mov    %edx,-0x4c(%rbp)
  8080a8:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  8080ac:	44 89 45 b0          	mov    %r8d,-0x50(%rbp)
  struct lwip_socket *sock = get_socket(s);
  8080b0:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8080b3:	89 c7                	mov    %eax,%edi
  8080b5:	48 b8 71 5d 80 00 00 	movabs $0x805d71,%rax
  8080bc:	00 00 00 
  8080bf:	ff d0                	callq  *%rax
  8080c1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  int err = ERR_OK;
  8080c5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  struct lwip_setgetsockopt_data data;

  if (!sock)
  8080cc:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8080d1:	75 0a                	jne    8080dd <lwip_setsockopt+0x46>
    return -1;
  8080d3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8080d8:	e9 fd 01 00 00       	jmpq   8082da <lwip_setsockopt+0x243>

  if (NULL == optval) {
  8080dd:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  8080e2:	75 28                	jne    80810c <lwip_setsockopt+0x75>
    sock_set_errno(sock, EFAULT);
  8080e4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8080e8:	c7 40 18 0e 00 00 00 	movl   $0xe,0x18(%rax)
  8080ef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8080f3:	8b 50 18             	mov    0x18(%rax),%edx
  8080f6:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8080fd:	00 00 00 
  808100:	89 10                	mov    %edx,(%rax)
    return -1;
  808102:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808107:	e9 ce 01 00 00       	jmpq   8082da <lwip_setsockopt+0x243>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  80810c:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80810f:	83 f8 06             	cmp    $0x6,%eax
  808112:	0f 84 ab 00 00 00    	je     8081c3 <lwip_setsockopt+0x12c>
  808118:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  80811d:	74 09                	je     808128 <lwip_setsockopt+0x91>
  80811f:	85 c0                	test   %eax,%eax
  808121:	74 78                	je     80819b <lwip_setsockopt+0x104>
  808123:	e9 db 00 00 00       	jmpq   808203 <lwip_setsockopt+0x16c>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  808128:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80812b:	83 f8 20             	cmp    $0x20,%eax
  80812e:	74 0c                	je     80813c <lwip_setsockopt+0xa5>
  808130:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  808135:	74 16                	je     80814d <lwip_setsockopt+0xb6>
  808137:	83 f8 08             	cmp    $0x8,%eax
  80813a:	75 50                	jne    80818c <lwip_setsockopt+0xf5>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  80813c:	8b 45 b0             	mov    -0x50(%rbp),%eax
  80813f:	83 f8 03             	cmp    $0x3,%eax
  808142:	77 51                	ja     808195 <lwip_setsockopt+0xfe>
        err = EINVAL;
  808144:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
      break;
  80814b:	eb 48                	jmp    808195 <lwip_setsockopt+0xfe>
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
  80814d:	8b 45 b0             	mov    -0x50(%rbp),%eax
  808150:	83 f8 03             	cmp    $0x3,%eax
  808153:	77 07                	ja     80815c <lwip_setsockopt+0xc5>
        err = EINVAL;
  808155:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  80815c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808160:	48 8b 00             	mov    (%rax),%rax
  808163:	8b 00                	mov    (%rax),%eax
  808165:	83 f8 20             	cmp    $0x20,%eax
  808168:	75 19                	jne    808183 <lwip_setsockopt+0xec>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  80816a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80816e:	48 8b 00             	mov    (%rax),%rax
  808171:	48 8b 40 08          	mov    0x8(%rax),%rax
  808175:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  808179:	0f b6 c0             	movzbl %al,%eax
  80817c:	83 e0 02             	and    $0x2,%eax
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  80817f:	85 c0                	test   %eax,%eax
  808181:	74 15                	je     808198 <lwip_setsockopt+0x101>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  808183:	c7 45 fc 61 00 00 00 	movl   $0x61,-0x4(%rbp)
      }
#endif /* LWIP_UDP */
      break;
  80818a:	eb 0c                	jmp    808198 <lwip_setsockopt+0x101>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  80818c:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  808193:	eb 75                	jmp    80820a <lwip_setsockopt+0x173>
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
  808195:	90                   	nop
  808196:	eb 72                	jmp    80820a <lwip_setsockopt+0x173>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
      }
#endif /* LWIP_UDP */
      break;
  808198:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  808199:	eb 6f                	jmp    80820a <lwip_setsockopt+0x173>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  80819b:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80819e:	83 e8 01             	sub    $0x1,%eax
  8081a1:	83 f8 01             	cmp    $0x1,%eax
  8081a4:	77 11                	ja     8081b7 <lwip_setsockopt+0x120>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  8081a6:	8b 45 b0             	mov    -0x50(%rbp),%eax
  8081a9:	83 f8 03             	cmp    $0x3,%eax
  8081ac:	77 12                	ja     8081c0 <lwip_setsockopt+0x129>
        err = EINVAL;
  8081ae:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
      break;
  8081b5:	eb 09                	jmp    8081c0 <lwip_setsockopt+0x129>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  8081b7:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  8081be:	eb 4a                	jmp    80820a <lwip_setsockopt+0x173>
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
  8081c0:	90                   	nop
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  8081c1:	eb 47                	jmp    80820a <lwip_setsockopt+0x173>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  8081c3:	8b 45 b0             	mov    -0x50(%rbp),%eax
  8081c6:	83 f8 03             	cmp    $0x3,%eax
  8081c9:	77 09                	ja     8081d4 <lwip_setsockopt+0x13d>
      err = EINVAL;
  8081cb:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      break;
  8081d2:	eb 36                	jmp    80820a <lwip_setsockopt+0x173>
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  8081d4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8081d8:	48 8b 00             	mov    (%rax),%rax
  8081db:	8b 00                	mov    (%rax),%eax
  8081dd:	83 f8 10             	cmp    $0x10,%eax
  8081e0:	74 0a                	je     8081ec <lwip_setsockopt+0x155>
      return 0;
  8081e2:	b8 00 00 00 00       	mov    $0x0,%eax
  8081e7:	e9 ee 00 00 00       	jmpq   8082da <lwip_setsockopt+0x243>

    switch (optname) {
  8081ec:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8081ef:	83 e8 01             	sub    $0x1,%eax
  8081f2:	83 f8 01             	cmp    $0x1,%eax
  8081f5:	76 09                	jbe    808200 <lwip_setsockopt+0x169>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  8081f7:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  8081fe:	eb 0a                	jmp    80820a <lwip_setsockopt+0x173>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
  808200:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  808201:	eb 07                	jmp    80820a <lwip_setsockopt+0x173>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  808203:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
  }  /* switch (level) */


  if (err != ERR_OK) {
  80820a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80820e:	74 27                	je     808237 <lwip_setsockopt+0x1a0>
    sock_set_errno(sock, err);
  808210:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808214:	8b 55 fc             	mov    -0x4(%rbp),%edx
  808217:	89 50 18             	mov    %edx,0x18(%rax)
  80821a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80821e:	8b 50 18             	mov    0x18(%rax),%edx
  808221:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  808228:	00 00 00 
  80822b:	89 10                	mov    %edx,(%rax)
    return -1;
  80822d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808232:	e9 a3 00 00 00       	jmpq   8082da <lwip_setsockopt+0x243>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  808237:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80823b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  data.level = level;
  80823f:	8b 45 b8             	mov    -0x48(%rbp),%eax
  808242:	89 45 cc             	mov    %eax,-0x34(%rbp)
  data.optname = optname;
  808245:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  808248:	89 45 d0             	mov    %eax,-0x30(%rbp)
  data.optval = (void*)optval;
  80824b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80824f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  data.optlen = &optlen;
  808253:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  808257:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  data.err = err;
  80825b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80825e:	88 45 e8             	mov    %al,-0x18(%rbp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  808261:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  808265:	ba 01 00 00 00       	mov    $0x1,%edx
  80826a:	48 89 c6             	mov    %rax,%rsi
  80826d:	48 bf dc 82 80 00 00 	movabs $0x8082dc,%rdi
  808274:	00 00 00 
  808277:	48 b8 61 8b 80 00 00 	movabs $0x808b61,%rax
  80827e:	00 00 00 
  808281:	ff d0                	callq  *%rax
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  808283:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808287:	48 8b 00             	mov    (%rax),%rax
  80828a:	8b 40 14             	mov    0x14(%rax),%eax
  80828d:	be 00 00 00 00       	mov    $0x0,%esi
  808292:	89 c7                	mov    %eax,%edi
  808294:	48 b8 ea 82 81 00 00 	movabs $0x8182ea,%rax
  80829b:	00 00 00 
  80829e:	ff d0                	callq  *%rax
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  8082a0:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  8082a4:	0f be c0             	movsbl %al,%eax
  8082a7:	89 45 fc             	mov    %eax,-0x4(%rbp)

  sock_set_errno(sock, err);
  8082aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8082ae:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8082b1:	89 50 18             	mov    %edx,0x18(%rax)
  8082b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8082b8:	8b 50 18             	mov    0x18(%rax),%edx
  8082bb:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8082c2:	00 00 00 
  8082c5:	89 10                	mov    %edx,(%rax)
  return err ? -1 : 0;
  8082c7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8082cb:	74 07                	je     8082d4 <lwip_setsockopt+0x23d>
  8082cd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8082d2:	eb 06                	jmp    8082da <lwip_setsockopt+0x243>
  8082d4:	b8 00 00 00 00       	mov    $0x0,%eax
  8082d9:	90                   	nop
}
  8082da:	c9                   	leaveq 
  8082db:	c3                   	retq   

00000000008082dc <lwip_setsockopt_internal>:

static void
lwip_setsockopt_internal(void *arg)
{
  8082dc:	55                   	push   %rbp
  8082dd:	48 89 e5             	mov    %rsp,%rbp
  8082e0:	48 83 ec 40          	sub    $0x40,%rsp
  8082e4:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  8082e8:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8082ed:	75 2a                	jne    808319 <lwip_setsockopt_internal+0x3d>
  8082ef:	48 ba c7 19 82 00 00 	movabs $0x8219c7,%rdx
  8082f6:	00 00 00 
  8082f9:	be af 06 00 00       	mov    $0x6af,%esi
  8082fe:	48 bf 11 19 82 00 00 	movabs $0x821911,%rdi
  808305:	00 00 00 
  808308:	b8 00 00 00 00       	mov    $0x0,%eax
  80830d:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  808314:	00 00 00 
  808317:	ff d1                	callq  *%rcx

  data = (struct lwip_setgetsockopt_data*)arg;
  808319:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80831d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sock = data->sock;
  808321:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808325:	48 8b 00             	mov    (%rax),%rax
  808328:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#ifdef LWIP_DEBUG
  s = data->s;
  80832c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808330:	8b 40 08             	mov    0x8(%rax),%eax
  808333:	89 45 ec             	mov    %eax,-0x14(%rbp)
#endif /* LWIP_DEBUG */
  level = data->level;
  808336:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80833a:	8b 40 0c             	mov    0xc(%rax),%eax
  80833d:	89 45 e8             	mov    %eax,-0x18(%rbp)
  optname = data->optname;
  808340:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808344:	8b 40 10             	mov    0x10(%rax),%eax
  808347:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  optval = data->optval;
  80834a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80834e:	48 8b 40 18          	mov    0x18(%rax),%rax
  808352:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  switch (level) {
  808356:	8b 45 e8             	mov    -0x18(%rbp),%eax
  808359:	83 f8 06             	cmp    $0x6,%eax
  80835c:	0f 84 18 01 00 00    	je     80847a <lwip_setsockopt_internal+0x19e>
  808362:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  808367:	74 0d                	je     808376 <lwip_setsockopt_internal+0x9a>
  808369:	85 c0                	test   %eax,%eax
  80836b:	0f 84 ca 00 00 00    	je     80843b <lwip_setsockopt_internal+0x15f>
  808371:	e9 7a 01 00 00       	jmpq   8084f0 <lwip_setsockopt_internal+0x214>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  808376:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  808379:	83 f8 20             	cmp    $0x20,%eax
  80837c:	74 11                	je     80838f <lwip_setsockopt_internal+0xb3>
  80837e:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  808383:	74 64                	je     8083e9 <lwip_setsockopt_internal+0x10d>
  808385:	83 f8 08             	cmp    $0x8,%eax
  808388:	74 05                	je     80838f <lwip_setsockopt_internal+0xb3>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
  80838a:	e9 61 01 00 00       	jmpq   8084f0 <lwip_setsockopt_internal+0x214>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  80838f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  808393:	8b 00                	mov    (%rax),%eax
  808395:	85 c0                	test   %eax,%eax
  808397:	74 27                	je     8083c0 <lwip_setsockopt_internal+0xe4>
        sock->conn->pcb.ip->so_options |= optname;
  808399:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80839d:	48 8b 00             	mov    (%rax),%rax
  8083a0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8083a4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8083a8:	48 8b 12             	mov    (%rdx),%rdx
  8083ab:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8083af:	0f b7 52 08          	movzwl 0x8(%rdx),%edx
  8083b3:	89 d1                	mov    %edx,%ecx
  8083b5:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8083b8:	09 ca                	or     %ecx,%edx
  8083ba:	66 89 50 08          	mov    %dx,0x8(%rax)
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
  8083be:	eb 76                	jmp    808436 <lwip_setsockopt_internal+0x15a>
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
        sock->conn->pcb.ip->so_options |= optname;
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  8083c0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8083c4:	48 8b 00             	mov    (%rax),%rax
  8083c7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8083cb:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8083cf:	48 8b 12             	mov    (%rdx),%rdx
  8083d2:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8083d6:	0f b7 52 08          	movzwl 0x8(%rdx),%edx
  8083da:	89 d1                	mov    %edx,%ecx
  8083dc:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8083df:	f7 d2                	not    %edx
  8083e1:	21 ca                	and    %ecx,%edx
  8083e3:	66 89 50 08          	mov    %dx,0x8(%rax)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
  8083e7:	eb 4d                	jmp    808436 <lwip_setsockopt_internal+0x15a>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  8083e9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8083ed:	8b 00                	mov    (%rax),%eax
  8083ef:	85 c0                	test   %eax,%eax
  8083f1:	74 22                	je     808415 <lwip_setsockopt_internal+0x139>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  8083f3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8083f7:	48 8b 00             	mov    (%rax),%rax
  8083fa:	48 8b 40 08          	mov    0x8(%rax),%rax
  8083fe:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808402:	48 8b 12             	mov    (%rdx),%rdx
  808405:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  808409:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  80840d:	83 ca 01             	or     $0x1,%edx
  808410:	88 50 18             	mov    %dl,0x18(%rax)
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
  808413:	eb 20                	jmp    808435 <lwip_setsockopt_internal+0x159>
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  808415:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808419:	48 8b 00             	mov    (%rax),%rax
  80841c:	48 8b 40 08          	mov    0x8(%rax),%rax
  808420:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808424:	48 8b 12             	mov    (%rdx),%rdx
  808427:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  80842b:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  80842f:	83 e2 fe             	and    $0xfffffffe,%edx
  808432:	88 50 18             	mov    %dl,0x18(%rax)
      }
      break;
  808435:	90                   	nop
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
  808436:	e9 b5 00 00 00       	jmpq   8084f0 <lwip_setsockopt_internal+0x214>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  80843b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80843e:	83 f8 01             	cmp    $0x1,%eax
  808441:	74 20                	je     808463 <lwip_setsockopt_internal+0x187>
  808443:	83 f8 02             	cmp    $0x2,%eax
  808446:	74 05                	je     80844d <lwip_setsockopt_internal+0x171>
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  808448:	e9 a3 00 00 00       	jmpq   8084f0 <lwip_setsockopt_internal+0x214>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  80844d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808451:	48 8b 00             	mov    (%rax),%rax
  808454:	48 8b 40 08          	mov    0x8(%rax),%rax
  808458:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80845c:	8b 12                	mov    (%rdx),%edx
  80845e:	88 50 0b             	mov    %dl,0xb(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  808461:	eb 15                	jmp    808478 <lwip_setsockopt_internal+0x19c>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  808463:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808467:	48 8b 00             	mov    (%rax),%rax
  80846a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80846e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  808472:	8b 12                	mov    (%rdx),%edx
  808474:	88 50 0a             	mov    %dl,0xa(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
                  s, sock->conn->pcb.ip->tos));
      break;
  808477:	90                   	nop
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  808478:	eb 76                	jmp    8084f0 <lwip_setsockopt_internal+0x214>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  80847a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80847d:	83 f8 01             	cmp    $0x1,%eax
  808480:	74 07                	je     808489 <lwip_setsockopt_internal+0x1ad>
  808482:	83 f8 02             	cmp    $0x2,%eax
  808485:	74 50                	je     8084d7 <lwip_setsockopt_internal+0x1fb>
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  808487:	eb 66                	jmp    8084ef <lwip_setsockopt_internal+0x213>
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
  808489:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80848d:	8b 00                	mov    (%rax),%eax
  80848f:	85 c0                	test   %eax,%eax
  808491:	74 22                	je     8084b5 <lwip_setsockopt_internal+0x1d9>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  808493:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808497:	48 8b 00             	mov    (%rax),%rax
  80849a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80849e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8084a2:	48 8b 12             	mov    (%rdx),%rdx
  8084a5:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8084a9:	0f b6 52 2c          	movzbl 0x2c(%rdx),%edx
  8084ad:	83 ca 40             	or     $0x40,%edx
  8084b0:	88 50 2c             	mov    %dl,0x2c(%rax)
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
  8084b3:	eb 3a                	jmp    8084ef <lwip_setsockopt_internal+0x213>
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  8084b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8084b9:	48 8b 00             	mov    (%rax),%rax
  8084bc:	48 8b 40 08          	mov    0x8(%rax),%rax
  8084c0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8084c4:	48 8b 12             	mov    (%rdx),%rdx
  8084c7:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8084cb:	0f b6 52 2c          	movzbl 0x2c(%rdx),%edx
  8084cf:	83 e2 bf             	and    $0xffffffbf,%edx
  8084d2:	88 50 2c             	mov    %dl,0x2c(%rax)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
  8084d5:	eb 18                	jmp    8084ef <lwip_setsockopt_internal+0x213>
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  8084d7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8084db:	48 8b 00             	mov    (%rax),%rax
  8084de:	48 8b 40 08          	mov    0x8(%rax),%rax
  8084e2:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8084e6:	8b 12                	mov    (%rdx),%edx
  8084e8:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %lu\n",
                  s, sock->conn->pcb.tcp->keep_idle));
      break;
  8084ee:	90                   	nop
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  8084ef:	90                   	nop
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  8084f0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8084f4:	48 8b 00             	mov    (%rax),%rax
  8084f7:	8b 40 14             	mov    0x14(%rax),%eax
  8084fa:	89 c7                	mov    %eax,%edi
  8084fc:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  808503:	00 00 00 
  808506:	ff d0                	callq  *%rax
}
  808508:	90                   	nop
  808509:	c9                   	leaveq 
  80850a:	c3                   	retq   

000000000080850b <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  80850b:	55                   	push   %rbp
  80850c:	48 89 e5             	mov    %rsp,%rbp
  80850f:	48 83 ec 28          	sub    $0x28,%rsp
  808513:	89 7d ec             	mov    %edi,-0x14(%rbp)
  808516:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80851a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  struct lwip_socket *sock = get_socket(s);
  80851e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  808521:	89 c7                	mov    %eax,%edi
  808523:	48 b8 71 5d 80 00 00 	movabs $0x805d71,%rax
  80852a:	00 00 00 
  80852d:	ff d0                	callq  *%rax
  80852f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  u16_t buflen = 0;
  808533:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)

  if (!sock)
  808539:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80853e:	75 0a                	jne    80854a <lwip_ioctl+0x3f>
    return -1;
  808540:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808545:	e9 4d 01 00 00       	jmpq   808697 <lwip_ioctl+0x18c>

  switch (cmd) {
  80854a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80854e:	48 3d 7f 66 08 40    	cmp    $0x4008667f,%rax
  808554:	74 13                	je     808569 <lwip_ioctl+0x5e>
  808556:	ba 7e 66 08 80       	mov    $0x8008667e,%edx
  80855b:	48 39 d0             	cmp    %rdx,%rax
  80855e:	0f 84 ae 00 00 00    	je     808612 <lwip_ioctl+0x107>
  808564:	e9 0b 01 00 00       	jmpq   808674 <lwip_ioctl+0x169>
  case FIONREAD:
    if (!argp) {
  808569:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80856e:	75 28                	jne    808598 <lwip_ioctl+0x8d>
      sock_set_errno(sock, EINVAL);
  808570:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808574:	c7 40 18 16 00 00 00 	movl   $0x16,0x18(%rax)
  80857b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80857f:	8b 50 18             	mov    0x18(%rax),%edx
  808582:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  808589:	00 00 00 
  80858c:	89 10                	mov    %edx,(%rax)
      return -1;
  80858e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808593:	e9 ff 00 00 00       	jmpq   808697 <lwip_ioctl+0x18c>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  808598:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80859c:	48 8b 00             	mov    (%rax),%rax
  80859f:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  8085a3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8085a7:	66 89 10             	mov    %dx,(%rax)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  8085aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085ae:	48 8b 40 08          	mov    0x8(%rax),%rax
  8085b2:	48 85 c0             	test   %rax,%rax
  8085b5:	74 33                	je     8085ea <lwip_ioctl+0xdf>
      buflen = netbuf_len(sock->lastdata);
  8085b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085bb:	48 8b 40 08          	mov    0x8(%rax),%rax
  8085bf:	48 8b 00             	mov    (%rax),%rax
  8085c2:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8085c6:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
      buflen -= sock->lastoffset;
  8085ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085ce:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8085d2:	66 29 45 f6          	sub    %ax,-0xa(%rbp)

      *((u16_t*)argp) += buflen;
  8085d6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8085da:	0f b7 10             	movzwl (%rax),%edx
  8085dd:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8085e1:	01 c2                	add    %eax,%edx
  8085e3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8085e7:	66 89 10             	mov    %dx,(%rax)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  8085ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085ee:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8085f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085f9:	8b 50 18             	mov    0x18(%rax),%edx
  8085fc:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  808603:	00 00 00 
  808606:	89 10                	mov    %edx,(%rax)
    return 0;
  808608:	b8 00 00 00 00       	mov    $0x0,%eax
  80860d:	e9 85 00 00 00       	jmpq   808697 <lwip_ioctl+0x18c>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  808612:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  808617:	74 21                	je     80863a <lwip_ioctl+0x12f>
  808619:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80861d:	8b 00                	mov    (%rax),%eax
  80861f:	85 c0                	test   %eax,%eax
  808621:	74 17                	je     80863a <lwip_ioctl+0x12f>
      sock->flags |= O_NONBLOCK;
  808623:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808627:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80862b:	80 cc 08             	or     $0x8,%ah
  80862e:	89 c2                	mov    %eax,%edx
  808630:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808634:	66 89 50 16          	mov    %dx,0x16(%rax)
  808638:	eb 15                	jmp    80864f <lwip_ioctl+0x144>
    else
      sock->flags &= ~O_NONBLOCK;
  80863a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80863e:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  808642:	80 e4 f7             	and    $0xf7,%ah
  808645:	89 c2                	mov    %eax,%edx
  808647:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80864b:	66 89 50 16          	mov    %dx,0x16(%rax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  80864f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808653:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  80865a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80865e:	8b 50 18             	mov    0x18(%rax),%edx
  808661:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  808668:	00 00 00 
  80866b:	89 10                	mov    %edx,(%rax)
    return 0;
  80866d:	b8 00 00 00 00       	mov    $0x0,%eax
  808672:	eb 23                	jmp    808697 <lwip_ioctl+0x18c>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  808674:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808678:	c7 40 18 26 00 00 00 	movl   $0x26,0x18(%rax)
  80867f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808683:	8b 50 18             	mov    0x18(%rax),%edx
  808686:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80868d:	00 00 00 
  808690:	89 10                	mov    %edx,(%rax)
    return -1;
  808692:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  } /* switch (cmd) */
}
  808697:	c9                   	leaveq 
  808698:	c3                   	retq   

0000000000808699 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  808699:	55                   	push   %rbp
  80869a:	48 89 e5             	mov    %rsp,%rbp
  80869d:	48 83 ec 10          	sub    $0x10,%rsp
  8086a1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  8086a5:	48 b8 bd ec 80 00 00 	movabs $0x80ecbd,%rax
  8086ac:	00 00 00 
  8086af:	ff d0                	callq  *%rax
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  8086b1:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  8086b8:	00 00 00 
  8086bb:	48 8b 00             	mov    (%rax),%rax
  8086be:	48 85 c0             	test   %rax,%rax
  8086c1:	75 12                	jne    8086d5 <tcpip_tcp_timer+0x3c>
  8086c3:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  8086ca:	00 00 00 
  8086cd:	48 8b 00             	mov    (%rax),%rax
  8086d0:	48 85 c0             	test   %rax,%rax
  8086d3:	74 22                	je     8086f7 <tcpip_tcp_timer+0x5e>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  8086d5:	ba 00 00 00 00       	mov    $0x0,%edx
  8086da:	48 be 99 86 80 00 00 	movabs $0x808699,%rsi
  8086e1:	00 00 00 
  8086e4:	bf fa 00 00 00       	mov    $0xfa,%edi
  8086e9:	48 b8 9e e8 80 00 00 	movabs $0x80e89e,%rax
  8086f0:	00 00 00 
  8086f3:	ff d0                	callq  *%rax
  8086f5:	eb 10                	jmp    808707 <tcpip_tcp_timer+0x6e>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  8086f7:	48 b8 c0 94 82 00 00 	movabs $0x8294c0,%rax
  8086fe:	00 00 00 
  808701:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  }
}
  808707:	90                   	nop
  808708:	c9                   	leaveq 
  808709:	c3                   	retq   

000000000080870a <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  80870a:	55                   	push   %rbp
  80870b:	48 89 e5             	mov    %rsp,%rbp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  80870e:	48 b8 c0 94 82 00 00 	movabs $0x8294c0,%rax
  808715:	00 00 00 
  808718:	8b 00                	mov    (%rax),%eax
  80871a:	85 c0                	test   %eax,%eax
  80871c:	75 54                	jne    808772 <tcp_timer_needed+0x68>
  80871e:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  808725:	00 00 00 
  808728:	48 8b 00             	mov    (%rax),%rax
  80872b:	48 85 c0             	test   %rax,%rax
  80872e:	75 12                	jne    808742 <tcp_timer_needed+0x38>
  808730:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  808737:	00 00 00 
  80873a:	48 8b 00             	mov    (%rax),%rax
  80873d:	48 85 c0             	test   %rax,%rax
  808740:	74 30                	je     808772 <tcp_timer_needed+0x68>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  808742:	48 b8 c0 94 82 00 00 	movabs $0x8294c0,%rax
  808749:	00 00 00 
  80874c:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  808752:	ba 00 00 00 00       	mov    $0x0,%edx
  808757:	48 be 99 86 80 00 00 	movabs $0x808699,%rsi
  80875e:	00 00 00 
  808761:	bf fa 00 00 00       	mov    $0xfa,%edi
  808766:	48 b8 9e e8 80 00 00 	movabs $0x80e89e,%rax
  80876d:	00 00 00 
  808770:	ff d0                	callq  *%rax
  }
}
  808772:	90                   	nop
  808773:	5d                   	pop    %rbp
  808774:	c3                   	retq   

0000000000808775 <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  808775:	55                   	push   %rbp
  808776:	48 89 e5             	mov    %rsp,%rbp
  808779:	48 83 ec 10          	sub    $0x10,%rsp
  80877d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  808781:	48 b8 05 17 81 00 00 	movabs $0x811705,%rax
  808788:	00 00 00 
  80878b:	ff d0                	callq  *%rax
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  80878d:	ba 00 00 00 00       	mov    $0x0,%edx
  808792:	48 be 75 87 80 00 00 	movabs $0x808775,%rsi
  808799:	00 00 00 
  80879c:	bf e8 03 00 00       	mov    $0x3e8,%edi
  8087a1:	48 b8 9e e8 80 00 00 	movabs $0x80e89e,%rax
  8087a8:	00 00 00 
  8087ab:	ff d0                	callq  *%rax
}
  8087ad:	90                   	nop
  8087ae:	c9                   	leaveq 
  8087af:	c3                   	retq   

00000000008087b0 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  8087b0:	55                   	push   %rbp
  8087b1:	48 89 e5             	mov    %rsp,%rbp
  8087b4:	48 83 ec 10          	sub    $0x10,%rsp
  8087b8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  8087bc:	48 b8 1a 5c 81 00 00 	movabs $0x815c1a,%rax
  8087c3:	00 00 00 
  8087c6:	ff d0                	callq  *%rax
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  8087c8:	ba 00 00 00 00       	mov    $0x0,%edx
  8087cd:	48 be b0 87 80 00 00 	movabs $0x8087b0,%rsi
  8087d4:	00 00 00 
  8087d7:	bf 88 13 00 00       	mov    $0x1388,%edi
  8087dc:	48 b8 9e e8 80 00 00 	movabs $0x80e89e,%rax
  8087e3:	00 00 00 
  8087e6:	ff d0                	callq  *%rax
}
  8087e8:	90                   	nop
  8087e9:	c9                   	leaveq 
  8087ea:	c3                   	retq   

00000000008087eb <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  8087eb:	55                   	push   %rbp
  8087ec:	48 89 e5             	mov    %rsp,%rbp
  8087ef:	48 83 ec 10          	sub    $0x10,%rsp
  8087f3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  8087f7:	48 b8 33 99 80 00 00 	movabs $0x809933,%rax
  8087fe:	00 00 00 
  808801:	ff d0                	callq  *%rax
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  808803:	ba 00 00 00 00       	mov    $0x0,%edx
  808808:	48 be eb 87 80 00 00 	movabs $0x8087eb,%rsi
  80880f:	00 00 00 
  808812:	bf 60 ea 00 00       	mov    $0xea60,%edi
  808817:	48 b8 9e e8 80 00 00 	movabs $0x80e89e,%rax
  80881e:	00 00 00 
  808821:	ff d0                	callq  *%rax
}
  808823:	90                   	nop
  808824:	c9                   	leaveq 
  808825:	c3                   	retq   

0000000000808826 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  808826:	55                   	push   %rbp
  808827:	48 89 e5             	mov    %rsp,%rbp
  80882a:	48 83 ec 10          	sub    $0x10,%rsp
  80882e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  808832:	48 b8 ca 99 80 00 00 	movabs $0x8099ca,%rax
  808839:	00 00 00 
  80883c:	ff d0                	callq  *%rax
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  80883e:	ba 00 00 00 00       	mov    $0x0,%edx
  808843:	48 be 26 88 80 00 00 	movabs $0x808826,%rsi
  80884a:	00 00 00 
  80884d:	bf f4 01 00 00       	mov    $0x1f4,%edi
  808852:	48 b8 9e e8 80 00 00 	movabs $0x80e89e,%rax
  808859:	00 00 00 
  80885c:	ff d0                	callq  *%rax
}
  80885e:	90                   	nop
  80885f:	c9                   	leaveq 
  808860:	c3                   	retq   

0000000000808861 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  808861:	55                   	push   %rbp
  808862:	48 89 e5             	mov    %rsp,%rbp
  808865:	48 83 ec 20          	sub    $0x20,%rsp
  808869:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  80886d:	ba 00 00 00 00       	mov    $0x0,%edx
  808872:	48 be 75 87 80 00 00 	movabs $0x808775,%rsi
  808879:	00 00 00 
  80887c:	bf e8 03 00 00       	mov    $0x3e8,%edi
  808881:	48 b8 9e e8 80 00 00 	movabs $0x80e89e,%rax
  808888:	00 00 00 
  80888b:	ff d0                	callq  *%rax
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  80888d:	ba 00 00 00 00       	mov    $0x0,%edx
  808892:	48 be b0 87 80 00 00 	movabs $0x8087b0,%rsi
  808899:	00 00 00 
  80889c:	bf 88 13 00 00       	mov    $0x1388,%edi
  8088a1:	48 b8 9e e8 80 00 00 	movabs $0x80e89e,%rax
  8088a8:	00 00 00 
  8088ab:	ff d0                	callq  *%rax
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8088ad:	ba 00 00 00 00       	mov    $0x0,%edx
  8088b2:	48 be eb 87 80 00 00 	movabs $0x8087eb,%rsi
  8088b9:	00 00 00 
  8088bc:	bf 60 ea 00 00       	mov    $0xea60,%edi
  8088c1:	48 b8 9e e8 80 00 00 	movabs $0x80e89e,%rax
  8088c8:	00 00 00 
  8088cb:	ff d0                	callq  *%rax
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8088cd:	ba 00 00 00 00       	mov    $0x0,%edx
  8088d2:	48 be 26 88 80 00 00 	movabs $0x808826,%rsi
  8088d9:	00 00 00 
  8088dc:	bf f4 01 00 00       	mov    $0x1f4,%edi
  8088e1:	48 b8 9e e8 80 00 00 	movabs $0x80e89e,%rax
  8088e8:	00 00 00 
  8088eb:	ff d0                	callq  *%rax
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  8088ed:	48 b8 b0 94 82 00 00 	movabs $0x8294b0,%rax
  8088f4:	00 00 00 
  8088f7:	48 8b 00             	mov    (%rax),%rax
  8088fa:	48 85 c0             	test   %rax,%rax
  8088fd:	74 1f                	je     80891e <tcpip_thread+0xbd>
    tcpip_init_done(tcpip_init_done_arg);
  8088ff:	48 b8 b0 94 82 00 00 	movabs $0x8294b0,%rax
  808906:	00 00 00 
  808909:	48 8b 00             	mov    (%rax),%rax
  80890c:	48 ba b8 94 82 00 00 	movabs $0x8294b8,%rdx
  808913:	00 00 00 
  808916:	48 8b 12             	mov    (%rdx),%rdx
  808919:	48 89 d7             	mov    %rdx,%rdi
  80891c:	ff d0                	callq  *%rax
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  80891e:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808925:	00 00 00 
  808928:	8b 00                	mov    (%rax),%eax
  80892a:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  80892e:	48 89 d6             	mov    %rdx,%rsi
  808931:	89 c7                	mov    %eax,%edi
  808933:	48 b8 3d e6 80 00 00 	movabs $0x80e63d,%rax
  80893a:	00 00 00 
  80893d:	ff d0                	callq  *%rax
    switch (msg->type) {
  80893f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808943:	8b 00                	mov    (%rax),%eax
  808945:	83 f8 01             	cmp    $0x1,%eax
  808948:	74 3d                	je     808987 <tcpip_thread+0x126>
  80894a:	83 f8 01             	cmp    $0x1,%eax
  80894d:	72 17                	jb     808966 <tcpip_thread+0x105>
  80894f:	83 f8 02             	cmp    $0x2,%eax
  808952:	0f 84 a8 00 00 00    	je     808a00 <tcpip_thread+0x19f>
  808958:	83 f8 03             	cmp    $0x3,%eax
  80895b:	0f 84 ce 00 00 00    	je     808a2f <tcpip_thread+0x1ce>
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
      break;

    default:
      break;
  808961:	e9 3a 01 00 00       	jmpq   808aa0 <tcpip_thread+0x23f>
    sys_mbox_fetch(mbox, (void *)&msg);
    switch (msg->type) {
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  808966:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80896a:	48 8b 40 10          	mov    0x10(%rax),%rax
  80896e:	48 8b 00             	mov    (%rax),%rax
  808971:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808975:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  808979:	48 83 c2 08          	add    $0x8,%rdx
  80897d:	48 89 d7             	mov    %rdx,%rdi
  808980:	ff d0                	callq  *%rax
      break;
  808982:	e9 19 01 00 00       	jmpq   808aa0 <tcpip_thread+0x23f>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  808987:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80898b:	48 8b 40 18          	mov    0x18(%rax),%rax
  80898f:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  808993:	0f b6 c0             	movzbl %al,%eax
  808996:	83 e0 20             	and    $0x20,%eax
  808999:	85 c0                	test   %eax,%eax
  80899b:	74 24                	je     8089c1 <tcpip_thread+0x160>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  80899d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089a1:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8089a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089a9:	48 8b 40 10          	mov    0x10(%rax),%rax
  8089ad:	48 89 d6             	mov    %rdx,%rsi
  8089b0:	48 89 c7             	mov    %rax,%rdi
  8089b3:	48 b8 c0 74 81 00 00 	movabs $0x8174c0,%rax
  8089ba:	00 00 00 
  8089bd:	ff d0                	callq  *%rax
  8089bf:	eb 22                	jmp    8089e3 <tcpip_thread+0x182>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  8089c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089c5:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8089c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089cd:	48 8b 40 10          	mov    0x10(%rax),%rax
  8089d1:	48 89 d6             	mov    %rdx,%rsi
  8089d4:	48 89 c7             	mov    %rax,%rdi
  8089d7:	48 b8 3a 0f 81 00 00 	movabs $0x810f3a,%rax
  8089de:	00 00 00 
  8089e1:	ff d0                	callq  *%rax
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8089e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089e7:	48 89 c6             	mov    %rax,%rsi
  8089ea:	bf 09 00 00 00       	mov    $0x9,%edi
  8089ef:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  8089f6:	00 00 00 
  8089f9:	ff d0                	callq  *%rax
      break;
  8089fb:	e9 a0 00 00 00       	jmpq   808aa0 <tcpip_thread+0x23f>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  808a00:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a04:	48 8b 40 10          	mov    0x10(%rax),%rax
  808a08:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808a0c:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  808a10:	48 89 d7             	mov    %rdx,%rdi
  808a13:	ff d0                	callq  *%rax
      memp_free(MEMP_TCPIP_MSG_API, msg);
  808a15:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a19:	48 89 c6             	mov    %rax,%rsi
  808a1c:	bf 08 00 00 00       	mov    $0x8,%edi
  808a21:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  808a28:	00 00 00 
  808a2b:	ff d0                	callq  *%rax
      break;
  808a2d:	eb 71                	jmp    808aa0 <tcpip_thread+0x23f>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  808a2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a33:	8b 40 10             	mov    0x10(%rax),%eax
  808a36:	83 f8 ff             	cmp    $0xffffffff,%eax
  808a39:	74 2a                	je     808a65 <tcpip_thread+0x204>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  808a3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a3f:	48 8b 50 20          	mov    0x20(%rax),%rdx
  808a43:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a47:	48 8b 48 18          	mov    0x18(%rax),%rcx
  808a4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a4f:	8b 40 10             	mov    0x10(%rax),%eax
  808a52:	48 89 ce             	mov    %rcx,%rsi
  808a55:	89 c7                	mov    %eax,%edi
  808a57:	48 b8 9e e8 80 00 00 	movabs $0x80e89e,%rax
  808a5e:	00 00 00 
  808a61:	ff d0                	callq  *%rax
  808a63:	eb 22                	jmp    808a87 <tcpip_thread+0x226>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  808a65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a69:	48 8b 50 20          	mov    0x20(%rax),%rdx
  808a6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a71:	48 8b 40 18          	mov    0x18(%rax),%rax
  808a75:	48 89 d6             	mov    %rdx,%rsi
  808a78:	48 89 c7             	mov    %rax,%rdi
  808a7b:	48 b8 87 ea 80 00 00 	movabs $0x80ea87,%rax
  808a82:	00 00 00 
  808a85:	ff d0                	callq  *%rax
      memp_free(MEMP_TCPIP_MSG_API, msg);
  808a87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a8b:	48 89 c6             	mov    %rax,%rsi
  808a8e:	bf 08 00 00 00       	mov    $0x8,%edi
  808a93:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  808a9a:	00 00 00 
  808a9d:	ff d0                	callq  *%rax
      break;
  808a9f:	90                   	nop

    default:
      break;
    }
  }
  808aa0:	e9 79 fe ff ff       	jmpq   80891e <tcpip_thread+0xbd>

0000000000808aa5 <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  808aa5:	55                   	push   %rbp
  808aa6:	48 89 e5             	mov    %rsp,%rbp
  808aa9:	48 83 ec 20          	sub    $0x20,%rsp
  808aad:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  808ab1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  808ab5:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808abc:	00 00 00 
  808abf:	8b 00                	mov    (%rax),%eax
  808ac1:	83 f8 ff             	cmp    $0xffffffff,%eax
  808ac4:	0f 84 90 00 00 00    	je     808b5a <tcpip_input+0xb5>
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  808aca:	bf 09 00 00 00       	mov    $0x9,%edi
  808acf:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  808ad6:	00 00 00 
  808ad9:	ff d0                	callq  *%rax
  808adb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  808adf:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808ae4:	75 07                	jne    808aed <tcpip_input+0x48>
      return ERR_MEM;
  808ae6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808aeb:	eb 72                	jmp    808b5f <tcpip_input+0xba>
    }

    msg->type = TCPIP_MSG_INPKT;
  808aed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808af1:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    msg->msg.inp.p = p;
  808af7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808afb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  808aff:	48 89 50 10          	mov    %rdx,0x10(%rax)
    msg->msg.inp.netif = inp;
  808b03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b07:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  808b0b:	48 89 50 18          	mov    %rdx,0x18(%rax)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  808b0f:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808b16:	00 00 00 
  808b19:	8b 00                	mov    (%rax),%eax
  808b1b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808b1f:	48 89 d6             	mov    %rdx,%rsi
  808b22:	89 c7                	mov    %eax,%edi
  808b24:	48 b8 e6 7c 81 00 00 	movabs $0x817ce6,%rax
  808b2b:	00 00 00 
  808b2e:	ff d0                	callq  *%rax
  808b30:	84 c0                	test   %al,%al
  808b32:	74 1f                	je     808b53 <tcpip_input+0xae>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  808b34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b38:	48 89 c6             	mov    %rax,%rsi
  808b3b:	bf 09 00 00 00       	mov    $0x9,%edi
  808b40:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  808b47:	00 00 00 
  808b4a:	ff d0                	callq  *%rax
      return ERR_MEM;
  808b4c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808b51:	eb 0c                	jmp    808b5f <tcpip_input+0xba>
    }
    return ERR_OK;
  808b53:	b8 00 00 00 00       	mov    $0x0,%eax
  808b58:	eb 05                	jmp    808b5f <tcpip_input+0xba>
  }
  return ERR_VAL;
  808b5a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808b5f:	c9                   	leaveq 
  808b60:	c3                   	retq   

0000000000808b61 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  808b61:	55                   	push   %rbp
  808b62:	48 89 e5             	mov    %rsp,%rbp
  808b65:	48 83 ec 30          	sub    $0x30,%rsp
  808b69:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  808b6d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  808b71:	89 d0                	mov    %edx,%eax
  808b73:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  808b76:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808b7d:	00 00 00 
  808b80:	8b 00                	mov    (%rax),%eax
  808b82:	83 f8 ff             	cmp    $0xffffffff,%eax
  808b85:	0f 84 bc 00 00 00    	je     808c47 <tcpip_callback_with_block+0xe6>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  808b8b:	bf 08 00 00 00       	mov    $0x8,%edi
  808b90:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  808b97:	00 00 00 
  808b9a:	ff d0                	callq  *%rax
  808b9c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  808ba0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808ba5:	75 0a                	jne    808bb1 <tcpip_callback_with_block+0x50>
      return ERR_MEM;
  808ba7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808bac:	e9 9b 00 00 00       	jmpq   808c4c <tcpip_callback_with_block+0xeb>
    }

    msg->type = TCPIP_MSG_CALLBACK;
  808bb1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808bb5:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
    msg->msg.cb.f = f;
  808bbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808bbf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  808bc3:	48 89 50 10          	mov    %rdx,0x10(%rax)
    msg->msg.cb.ctx = ctx;
  808bc7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808bcb:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  808bcf:	48 89 50 18          	mov    %rdx,0x18(%rax)
    if (block) {
  808bd3:	80 7d dc 00          	cmpb   $0x0,-0x24(%rbp)
  808bd7:	74 23                	je     808bfc <tcpip_callback_with_block+0x9b>
      sys_mbox_post(mbox, msg);
  808bd9:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808be0:	00 00 00 
  808be3:	8b 00                	mov    (%rax),%eax
  808be5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808be9:	48 89 d6             	mov    %rdx,%rsi
  808bec:	89 c7                	mov    %eax,%edi
  808bee:	48 b8 83 7c 81 00 00 	movabs $0x817c83,%rax
  808bf5:	00 00 00 
  808bf8:	ff d0                	callq  *%rax
  808bfa:	eb 44                	jmp    808c40 <tcpip_callback_with_block+0xdf>
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  808bfc:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808c03:	00 00 00 
  808c06:	8b 00                	mov    (%rax),%eax
  808c08:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808c0c:	48 89 d6             	mov    %rdx,%rsi
  808c0f:	89 c7                	mov    %eax,%edi
  808c11:	48 b8 e6 7c 81 00 00 	movabs $0x817ce6,%rax
  808c18:	00 00 00 
  808c1b:	ff d0                	callq  *%rax
  808c1d:	84 c0                	test   %al,%al
  808c1f:	74 1f                	je     808c40 <tcpip_callback_with_block+0xdf>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  808c21:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c25:	48 89 c6             	mov    %rax,%rsi
  808c28:	bf 08 00 00 00       	mov    $0x8,%edi
  808c2d:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  808c34:	00 00 00 
  808c37:	ff d0                	callq  *%rax
        return ERR_MEM;
  808c39:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808c3e:	eb 0c                	jmp    808c4c <tcpip_callback_with_block+0xeb>
      }
    }
    return ERR_OK;
  808c40:	b8 00 00 00 00       	mov    $0x0,%eax
  808c45:	eb 05                	jmp    808c4c <tcpip_callback_with_block+0xeb>
  }
  return ERR_VAL;
  808c47:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808c4c:	c9                   	leaveq 
  808c4d:	c3                   	retq   

0000000000808c4e <tcpip_timeout>:

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  808c4e:	55                   	push   %rbp
  808c4f:	48 89 e5             	mov    %rsp,%rbp
  808c52:	48 83 ec 30          	sub    $0x30,%rsp
  808c56:	89 7d ec             	mov    %edi,-0x14(%rbp)
  808c59:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  808c5d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  808c61:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808c68:	00 00 00 
  808c6b:	8b 00                	mov    (%rax),%eax
  808c6d:	83 f8 ff             	cmp    $0xffffffff,%eax
  808c70:	74 77                	je     808ce9 <tcpip_timeout+0x9b>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  808c72:	bf 08 00 00 00       	mov    $0x8,%edi
  808c77:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  808c7e:	00 00 00 
  808c81:	ff d0                	callq  *%rax
  808c83:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  808c87:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808c8c:	75 07                	jne    808c95 <tcpip_timeout+0x47>
      return ERR_MEM;
  808c8e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808c93:	eb 59                	jmp    808cee <tcpip_timeout+0xa0>
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  808c95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c99:	c7 00 03 00 00 00    	movl   $0x3,(%rax)
    msg->msg.tmo.msecs = msecs;
  808c9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ca3:	8b 55 ec             	mov    -0x14(%rbp),%edx
  808ca6:	89 50 10             	mov    %edx,0x10(%rax)
    msg->msg.tmo.h = h;
  808ca9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808cad:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  808cb1:	48 89 50 18          	mov    %rdx,0x18(%rax)
    msg->msg.tmo.arg = arg;
  808cb5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808cb9:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  808cbd:	48 89 50 20          	mov    %rdx,0x20(%rax)
    sys_mbox_post(mbox, msg);
  808cc1:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808cc8:	00 00 00 
  808ccb:	8b 00                	mov    (%rax),%eax
  808ccd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808cd1:	48 89 d6             	mov    %rdx,%rsi
  808cd4:	89 c7                	mov    %eax,%edi
  808cd6:	48 b8 83 7c 81 00 00 	movabs $0x817c83,%rax
  808cdd:	00 00 00 
  808ce0:	ff d0                	callq  *%rax
    return ERR_OK;
  808ce2:	b8 00 00 00 00       	mov    $0x0,%eax
  808ce7:	eb 05                	jmp    808cee <tcpip_timeout+0xa0>
  }
  return ERR_VAL;
  808ce9:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808cee:	c9                   	leaveq 
  808cef:	c3                   	retq   

0000000000808cf0 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  808cf0:	55                   	push   %rbp
  808cf1:	48 89 e5             	mov    %rsp,%rbp
  808cf4:	48 83 ec 40          	sub    $0x40,%rsp
  808cf8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  808cfc:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808d03:	00 00 00 
  808d06:	8b 00                	mov    (%rax),%eax
  808d08:	83 f8 ff             	cmp    $0xffffffff,%eax
  808d0b:	74 55                	je     808d62 <tcpip_apimsg+0x72>
    msg.type = TCPIP_MSG_API;
  808d0d:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%rbp)
    msg.msg.apimsg = apimsg;
  808d14:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  808d18:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    sys_mbox_post(mbox, &msg);
  808d1c:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808d23:	00 00 00 
  808d26:	8b 00                	mov    (%rax),%eax
  808d28:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  808d2c:	48 89 d6             	mov    %rdx,%rsi
  808d2f:	89 c7                	mov    %eax,%edi
  808d31:	48 b8 83 7c 81 00 00 	movabs $0x817c83,%rax
  808d38:	00 00 00 
  808d3b:	ff d0                	callq  *%rax
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  808d3d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  808d41:	48 8b 40 08          	mov    0x8(%rax),%rax
  808d45:	8b 40 14             	mov    0x14(%rax),%eax
  808d48:	be 00 00 00 00       	mov    $0x0,%esi
  808d4d:	89 c7                	mov    %eax,%edi
  808d4f:	48 b8 ea 82 81 00 00 	movabs $0x8182ea,%rax
  808d56:	00 00 00 
  808d59:	ff d0                	callq  *%rax
    return ERR_OK;
  808d5b:	b8 00 00 00 00       	mov    $0x0,%eax
  808d60:	eb 05                	jmp    808d67 <tcpip_apimsg+0x77>
  }
  return ERR_VAL;
  808d62:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808d67:	c9                   	leaveq 
  808d68:	c3                   	retq   

0000000000808d69 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  808d69:	55                   	push   %rbp
  808d6a:	48 89 e5             	mov    %rsp,%rbp
  808d6d:	48 83 ec 10          	sub    $0x10,%rsp
  808d71:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808d75:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  lwip_init();
  808d79:	48 b8 23 94 80 00 00 	movabs $0x809423,%rax
  808d80:	00 00 00 
  808d83:	ff d0                	callq  *%rax

  tcpip_init_done = initfunc;
  808d85:	48 b8 b0 94 82 00 00 	movabs $0x8294b0,%rax
  808d8c:	00 00 00 
  808d8f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808d93:	48 89 10             	mov    %rdx,(%rax)
  tcpip_init_done_arg = arg;
  808d96:	48 b8 b8 94 82 00 00 	movabs $0x8294b8,%rax
  808d9d:	00 00 00 
  808da0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808da4:	48 89 10             	mov    %rdx,(%rax)
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  808da7:	bf 00 00 00 00       	mov    $0x0,%edi
  808dac:	48 b8 59 78 81 00 00 	movabs $0x817859,%rax
  808db3:	00 00 00 
  808db6:	ff d0                	callq  *%rax
  808db8:	89 c2                	mov    %eax,%edx
  808dba:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808dc1:	00 00 00 
  808dc4:	89 10                	mov    %edx,(%rax)
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  808dc6:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  808dcc:	b9 00 00 00 00       	mov    $0x0,%ecx
  808dd1:	ba 00 00 00 00       	mov    $0x0,%edx
  808dd6:	48 be 61 88 80 00 00 	movabs $0x808861,%rsi
  808ddd:	00 00 00 
  808de0:	48 bf d3 19 82 00 00 	movabs $0x8219d3,%rdi
  808de7:	00 00 00 
  808dea:	48 b8 2b 88 81 00 00 	movabs $0x81882b,%rax
  808df1:	00 00 00 
  808df4:	ff d0                	callq  *%rax
}
  808df6:	90                   	nop
  808df7:	c9                   	leaveq 
  808df8:	c3                   	retq   

0000000000808df9 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  808df9:	55                   	push   %rbp
  808dfa:	48 89 e5             	mov    %rsp,%rbp
  808dfd:	48 83 ec 20          	sub    $0x20,%rsp
  808e01:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct pbuf *q = p;
  808e05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808e09:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  pbuf_free(q);
  808e0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e11:	48 89 c7             	mov    %rax,%rdi
  808e14:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  808e1b:	00 00 00 
  808e1e:	ff d0                	callq  *%rax
}
  808e20:	90                   	nop
  808e21:	c9                   	leaveq 
  808e22:	c3                   	retq   

0000000000808e23 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  808e23:	55                   	push   %rbp
  808e24:	48 89 e5             	mov    %rsp,%rbp
  808e27:	48 83 ec 10          	sub    $0x10,%rsp
  808e2b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  808e2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e33:	ba 00 00 00 00       	mov    $0x0,%edx
  808e38:	48 89 c6             	mov    %rax,%rsi
  808e3b:	48 bf f9 8d 80 00 00 	movabs $0x808df9,%rdi
  808e42:	00 00 00 
  808e45:	48 b8 61 8b 80 00 00 	movabs $0x808b61,%rax
  808e4c:	00 00 00 
  808e4f:	ff d0                	callq  *%rax
}
  808e51:	c9                   	leaveq 
  808e52:	c3                   	retq   

0000000000808e53 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  808e53:	55                   	push   %rbp
  808e54:	48 89 e5             	mov    %rsp,%rbp
  808e57:	48 83 ec 10          	sub    $0x10,%rsp
  808e5b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return tcpip_callback_with_block(mem_free, m, 0);
  808e5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808e63:	ba 00 00 00 00       	mov    $0x0,%edx
  808e68:	48 89 c6             	mov    %rax,%rsi
  808e6b:	48 bf 6d c5 80 00 00 	movabs $0x80c56d,%rdi
  808e72:	00 00 00 
  808e75:	48 b8 61 8b 80 00 00 	movabs $0x808b61,%rax
  808e7c:	00 00 00 
  808e7f:	ff d0                	callq  *%rax
}
  808e81:	c9                   	leaveq 
  808e82:	c3                   	retq   

0000000000808e83 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  808e83:	55                   	push   %rbp
  808e84:	48 89 e5             	mov    %rsp,%rbp
  808e87:	48 83 ec 10          	sub    $0x10,%rsp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  808e8b:	bf 06 00 00 00       	mov    $0x6,%edi
  808e90:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  808e97:	00 00 00 
  808e9a:	ff d0                	callq  *%rax
  808e9c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (buf != NULL) {
  808ea0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808ea5:	74 29                	je     808ed0 <netbuf_new+0x4d>
    buf->p = NULL;
  808ea7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808eab:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    buf->ptr = NULL;
  808eb2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808eb6:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808ebd:	00 
    buf->addr = NULL;
  808ebe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ec2:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  808ec9:	00 
    return buf;
  808eca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ece:	eb 05                	jmp    808ed5 <netbuf_new+0x52>
  } else {
    return NULL;
  808ed0:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
  808ed5:	c9                   	leaveq 
  808ed6:	c3                   	retq   

0000000000808ed7 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  808ed7:	55                   	push   %rbp
  808ed8:	48 89 e5             	mov    %rsp,%rbp
  808edb:	48 83 ec 10          	sub    $0x10,%rsp
  808edf:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (buf != NULL) {
  808ee3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808ee8:	74 55                	je     808f3f <netbuf_delete+0x68>
    if (buf->p != NULL) {
  808eea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808eee:	48 8b 00             	mov    (%rax),%rax
  808ef1:	48 85 c0             	test   %rax,%rax
  808ef4:	74 31                	je     808f27 <netbuf_delete+0x50>
      pbuf_free(buf->p);
  808ef6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808efa:	48 8b 00             	mov    (%rax),%rax
  808efd:	48 89 c7             	mov    %rax,%rdi
  808f00:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  808f07:	00 00 00 
  808f0a:	ff d0                	callq  *%rax
      buf->p = buf->ptr = NULL;
  808f0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f10:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808f17:	00 
  808f18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f1c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  808f20:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f24:	48 89 10             	mov    %rdx,(%rax)
    }
    memp_free(MEMP_NETBUF, buf);
  808f27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f2b:	48 89 c6             	mov    %rax,%rsi
  808f2e:	bf 06 00 00 00       	mov    $0x6,%edi
  808f33:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  808f3a:	00 00 00 
  808f3d:	ff d0                	callq  *%rax
  }
}
  808f3f:	90                   	nop
  808f40:	c9                   	leaveq 
  808f41:	c3                   	retq   

0000000000808f42 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  808f42:	55                   	push   %rbp
  808f43:	48 89 e5             	mov    %rsp,%rbp
  808f46:	48 83 ec 10          	sub    $0x10,%rsp
  808f4a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808f4e:	89 f0                	mov    %esi,%eax
  808f50:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  808f54:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808f59:	75 2a                	jne    808f85 <netbuf_alloc+0x43>
  808f5b:	48 ba e0 19 82 00 00 	movabs $0x8219e0,%rdx
  808f62:	00 00 00 
  808f65:	be 64 00 00 00       	mov    $0x64,%esi
  808f6a:	48 bf fa 19 82 00 00 	movabs $0x8219fa,%rdi
  808f71:	00 00 00 
  808f74:	b8 00 00 00 00       	mov    $0x0,%eax
  808f79:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  808f80:	00 00 00 
  808f83:	ff d1                	callq  *%rcx

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  808f85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f89:	48 8b 00             	mov    (%rax),%rax
  808f8c:	48 85 c0             	test   %rax,%rax
  808f8f:	74 16                	je     808fa7 <netbuf_alloc+0x65>
    pbuf_free(buf->p);
  808f91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f95:	48 8b 00             	mov    (%rax),%rax
  808f98:	48 89 c7             	mov    %rax,%rdi
  808f9b:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  808fa2:	00 00 00 
  808fa5:	ff d0                	callq  *%rax
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  808fa7:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  808fab:	ba 00 00 00 00       	mov    $0x0,%edx
  808fb0:	89 c6                	mov    %eax,%esi
  808fb2:	bf 00 00 00 00       	mov    $0x0,%edi
  808fb7:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  808fbe:	00 00 00 
  808fc1:	ff d0                	callq  *%rax
  808fc3:	48 89 c2             	mov    %rax,%rdx
  808fc6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808fca:	48 89 10             	mov    %rdx,(%rax)
  if (buf->p == NULL) {
  808fcd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808fd1:	48 8b 00             	mov    (%rax),%rax
  808fd4:	48 85 c0             	test   %rax,%rax
  808fd7:	75 07                	jne    808fe0 <netbuf_alloc+0x9e>
     return NULL;
  808fd9:	b8 00 00 00 00       	mov    $0x0,%eax
  808fde:	eb 55                	jmp    809035 <netbuf_alloc+0xf3>
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  808fe0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808fe4:	48 8b 00             	mov    (%rax),%rax
  808fe7:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  808feb:	66 3b 45 f4          	cmp    -0xc(%rbp),%ax
  808fef:	73 2a                	jae    80901b <netbuf_alloc+0xd9>
  808ff1:	48 ba 10 1a 82 00 00 	movabs $0x821a10,%rdx
  808ff8:	00 00 00 
  808ffb:	be 6f 00 00 00       	mov    $0x6f,%esi
  809000:	48 bf fa 19 82 00 00 	movabs $0x8219fa,%rdi
  809007:	00 00 00 
  80900a:	b8 00 00 00 00       	mov    $0x0,%eax
  80900f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  809016:	00 00 00 
  809019:	ff d1                	callq  *%rcx
             (buf->p->len >= size));
  buf->ptr = buf->p;
  80901b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80901f:	48 8b 10             	mov    (%rax),%rdx
  809022:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809026:	48 89 50 08          	mov    %rdx,0x8(%rax)
  return buf->p->payload;
  80902a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80902e:	48 8b 00             	mov    (%rax),%rax
  809031:	48 8b 40 08          	mov    0x8(%rax),%rax
}
  809035:	c9                   	leaveq 
  809036:	c3                   	retq   

0000000000809037 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  809037:	55                   	push   %rbp
  809038:	48 89 e5             	mov    %rsp,%rbp
  80903b:	48 83 ec 10          	sub    $0x10,%rsp
  80903f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  809043:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809048:	75 2a                	jne    809074 <netbuf_free+0x3d>
  80904a:	48 ba 34 1a 82 00 00 	movabs $0x821a34,%rdx
  809051:	00 00 00 
  809054:	be 7c 00 00 00       	mov    $0x7c,%esi
  809059:	48 bf fa 19 82 00 00 	movabs $0x8219fa,%rdi
  809060:	00 00 00 
  809063:	b8 00 00 00 00       	mov    $0x0,%eax
  809068:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80906f:	00 00 00 
  809072:	ff d1                	callq  *%rcx
  if (buf->p != NULL) {
  809074:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809078:	48 8b 00             	mov    (%rax),%rax
  80907b:	48 85 c0             	test   %rax,%rax
  80907e:	74 16                	je     809096 <netbuf_free+0x5f>
    pbuf_free(buf->p);
  809080:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809084:	48 8b 00             	mov    (%rax),%rax
  809087:	48 89 c7             	mov    %rax,%rdi
  80908a:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  809091:	00 00 00 
  809094:	ff d0                	callq  *%rax
  }
  buf->p = buf->ptr = NULL;
  809096:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80909a:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8090a1:	00 
  8090a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090a6:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8090aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090ae:	48 89 10             	mov    %rdx,(%rax)
}
  8090b1:	90                   	nop
  8090b2:	c9                   	leaveq 
  8090b3:	c3                   	retq   

00000000008090b4 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  8090b4:	55                   	push   %rbp
  8090b5:	48 89 e5             	mov    %rsp,%rbp
  8090b8:	48 83 ec 20          	sub    $0x20,%rsp
  8090bc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8090c0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8090c4:	89 d0                	mov    %edx,%eax
  8090c6:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  8090ca:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8090cf:	75 2a                	jne    8090fb <netbuf_ref+0x47>
  8090d1:	48 ba 4d 1a 82 00 00 	movabs $0x821a4d,%rdx
  8090d8:	00 00 00 
  8090db:	be 8f 00 00 00       	mov    $0x8f,%esi
  8090e0:	48 bf fa 19 82 00 00 	movabs $0x8219fa,%rdi
  8090e7:	00 00 00 
  8090ea:	b8 00 00 00 00       	mov    $0x0,%eax
  8090ef:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8090f6:	00 00 00 
  8090f9:	ff d1                	callq  *%rcx
  if (buf->p != NULL) {
  8090fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090ff:	48 8b 00             	mov    (%rax),%rax
  809102:	48 85 c0             	test   %rax,%rax
  809105:	74 16                	je     80911d <netbuf_ref+0x69>
    pbuf_free(buf->p);
  809107:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80910b:	48 8b 00             	mov    (%rax),%rax
  80910e:	48 89 c7             	mov    %rax,%rdi
  809111:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  809118:	00 00 00 
  80911b:	ff d0                	callq  *%rax
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  80911d:	ba 02 00 00 00       	mov    $0x2,%edx
  809122:	be 00 00 00 00       	mov    $0x0,%esi
  809127:	bf 00 00 00 00       	mov    $0x0,%edi
  80912c:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  809133:	00 00 00 
  809136:	ff d0                	callq  *%rax
  809138:	48 89 c2             	mov    %rax,%rdx
  80913b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80913f:	48 89 10             	mov    %rdx,(%rax)
  if (buf->p == NULL) {
  809142:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809146:	48 8b 00             	mov    (%rax),%rax
  809149:	48 85 c0             	test   %rax,%rax
  80914c:	75 13                	jne    809161 <netbuf_ref+0xad>
    buf->ptr = NULL;
  80914e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809152:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  809159:	00 
    return ERR_MEM;
  80915a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80915f:	eb 41                	jmp    8091a2 <netbuf_ref+0xee>
  }
  buf->p->payload = (void*)dataptr;
  809161:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809165:	48 8b 00             	mov    (%rax),%rax
  809168:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80916c:	48 89 50 08          	mov    %rdx,0x8(%rax)
  buf->p->len = buf->p->tot_len = size;
  809170:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809174:	48 8b 10             	mov    (%rax),%rdx
  809177:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80917b:	48 8b 00             	mov    (%rax),%rax
  80917e:	0f b7 4d ec          	movzwl -0x14(%rbp),%ecx
  809182:	66 89 48 10          	mov    %cx,0x10(%rax)
  809186:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80918a:	66 89 42 12          	mov    %ax,0x12(%rdx)
  buf->ptr = buf->p;
  80918e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809192:	48 8b 10             	mov    (%rax),%rdx
  809195:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809199:	48 89 50 08          	mov    %rdx,0x8(%rax)
  return ERR_OK;
  80919d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8091a2:	c9                   	leaveq 
  8091a3:	c3                   	retq   

00000000008091a4 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  8091a4:	55                   	push   %rbp
  8091a5:	48 89 e5             	mov    %rsp,%rbp
  8091a8:	48 83 ec 10          	sub    $0x10,%rsp
  8091ac:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8091b0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  8091b4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8091b9:	75 2a                	jne    8091e5 <netbuf_chain+0x41>
  8091bb:	48 ba 65 1a 82 00 00 	movabs $0x821a65,%rdx
  8091c2:	00 00 00 
  8091c5:	be a7 00 00 00       	mov    $0xa7,%esi
  8091ca:	48 bf fa 19 82 00 00 	movabs $0x8219fa,%rdi
  8091d1:	00 00 00 
  8091d4:	b8 00 00 00 00       	mov    $0x0,%eax
  8091d9:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8091e0:	00 00 00 
  8091e3:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  8091e5:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8091ea:	75 2a                	jne    809216 <netbuf_chain+0x72>
  8091ec:	48 ba 7e 1a 82 00 00 	movabs $0x821a7e,%rdx
  8091f3:	00 00 00 
  8091f6:	be a8 00 00 00       	mov    $0xa8,%esi
  8091fb:	48 bf fa 19 82 00 00 	movabs $0x8219fa,%rdi
  809202:	00 00 00 
  809205:	b8 00 00 00 00       	mov    $0x0,%eax
  80920a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  809211:	00 00 00 
  809214:	ff d1                	callq  *%rcx
  pbuf_chain(head->p, tail->p);
  809216:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80921a:	48 8b 10             	mov    (%rax),%rdx
  80921d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809221:	48 8b 00             	mov    (%rax),%rax
  809224:	48 89 d6             	mov    %rdx,%rsi
  809227:	48 89 c7             	mov    %rax,%rdi
  80922a:	48 b8 f4 e0 80 00 00 	movabs $0x80e0f4,%rax
  809231:	00 00 00 
  809234:	ff d0                	callq  *%rax
  head->ptr = head->p;
  809236:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80923a:	48 8b 10             	mov    (%rax),%rdx
  80923d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809241:	48 89 50 08          	mov    %rdx,0x8(%rax)
  memp_free(MEMP_NETBUF, tail);
  809245:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809249:	48 89 c6             	mov    %rax,%rsi
  80924c:	bf 06 00 00 00       	mov    $0x6,%edi
  809251:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  809258:	00 00 00 
  80925b:	ff d0                	callq  *%rax
}
  80925d:	90                   	nop
  80925e:	c9                   	leaveq 
  80925f:	c3                   	retq   

0000000000809260 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  809260:	55                   	push   %rbp
  809261:	48 89 e5             	mov    %rsp,%rbp
  809264:	48 83 ec 20          	sub    $0x20,%rsp
  809268:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80926c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  809270:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  809274:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809279:	75 2a                	jne    8092a5 <netbuf_data+0x45>
  80927b:	48 ba 99 1a 82 00 00 	movabs $0x821a99,%rdx
  809282:	00 00 00 
  809285:	be ba 00 00 00       	mov    $0xba,%esi
  80928a:	48 bf fa 19 82 00 00 	movabs $0x8219fa,%rdi
  809291:	00 00 00 
  809294:	b8 00 00 00 00       	mov    $0x0,%eax
  809299:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8092a0:	00 00 00 
  8092a3:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  8092a5:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8092aa:	75 2a                	jne    8092d6 <netbuf_data+0x76>
  8092ac:	48 ba b2 1a 82 00 00 	movabs $0x821ab2,%rdx
  8092b3:	00 00 00 
  8092b6:	be bb 00 00 00       	mov    $0xbb,%esi
  8092bb:	48 bf fa 19 82 00 00 	movabs $0x8219fa,%rdi
  8092c2:	00 00 00 
  8092c5:	b8 00 00 00 00       	mov    $0x0,%eax
  8092ca:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8092d1:	00 00 00 
  8092d4:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  8092d6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8092db:	75 2a                	jne    809307 <netbuf_data+0xa7>
  8092dd:	48 ba cf 1a 82 00 00 	movabs $0x821acf,%rdx
  8092e4:	00 00 00 
  8092e7:	be bc 00 00 00       	mov    $0xbc,%esi
  8092ec:	48 bf fa 19 82 00 00 	movabs $0x8219fa,%rdi
  8092f3:	00 00 00 
  8092f6:	b8 00 00 00 00       	mov    $0x0,%eax
  8092fb:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  809302:	00 00 00 
  809305:	ff d1                	callq  *%rcx

  if (buf->ptr == NULL) {
  809307:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80930b:	48 8b 40 08          	mov    0x8(%rax),%rax
  80930f:	48 85 c0             	test   %rax,%rax
  809312:	75 07                	jne    80931b <netbuf_data+0xbb>
    return ERR_BUF;
  809314:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  809319:	eb 2b                	jmp    809346 <netbuf_data+0xe6>
  }
  *dataptr = buf->ptr->payload;
  80931b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80931f:	48 8b 40 08          	mov    0x8(%rax),%rax
  809323:	48 8b 50 08          	mov    0x8(%rax),%rdx
  809327:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80932b:	48 89 10             	mov    %rdx,(%rax)
  *len = buf->ptr->len;
  80932e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809332:	48 8b 40 08          	mov    0x8(%rax),%rax
  809336:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80933a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80933e:	66 89 10             	mov    %dx,(%rax)
  return ERR_OK;
  809341:	b8 00 00 00 00       	mov    $0x0,%eax
}
  809346:	c9                   	leaveq 
  809347:	c3                   	retq   

0000000000809348 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  809348:	55                   	push   %rbp
  809349:	48 89 e5             	mov    %rsp,%rbp
  80934c:	48 83 ec 10          	sub    $0x10,%rsp
  809350:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  809354:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809359:	75 2a                	jne    809385 <netbuf_next+0x3d>
  80935b:	48 ba 34 1a 82 00 00 	movabs $0x821a34,%rdx
  809362:	00 00 00 
  809365:	be d3 00 00 00       	mov    $0xd3,%esi
  80936a:	48 bf fa 19 82 00 00 	movabs $0x8219fa,%rdi
  809371:	00 00 00 
  809374:	b8 00 00 00 00       	mov    $0x0,%eax
  809379:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  809380:	00 00 00 
  809383:	ff d1                	callq  *%rcx
  if (buf->ptr->next == NULL) {
  809385:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809389:	48 8b 40 08          	mov    0x8(%rax),%rax
  80938d:	48 8b 00             	mov    (%rax),%rax
  809390:	48 85 c0             	test   %rax,%rax
  809393:	75 07                	jne    80939c <netbuf_next+0x54>
    return -1;
  809395:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80939a:	eb 2f                	jmp    8093cb <netbuf_next+0x83>
  }
  buf->ptr = buf->ptr->next;
  80939c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8093a0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8093a4:	48 8b 10             	mov    (%rax),%rdx
  8093a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8093ab:	48 89 50 08          	mov    %rdx,0x8(%rax)
  if (buf->ptr->next == NULL) {
  8093af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8093b3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8093b7:	48 8b 00             	mov    (%rax),%rax
  8093ba:	48 85 c0             	test   %rax,%rax
  8093bd:	75 07                	jne    8093c6 <netbuf_next+0x7e>
    return 1;
  8093bf:	b8 01 00 00 00       	mov    $0x1,%eax
  8093c4:	eb 05                	jmp    8093cb <netbuf_next+0x83>
  }
  return 0;
  8093c6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8093cb:	c9                   	leaveq 
  8093cc:	c3                   	retq   

00000000008093cd <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  8093cd:	55                   	push   %rbp
  8093ce:	48 89 e5             	mov    %rsp,%rbp
  8093d1:	48 83 ec 10          	sub    $0x10,%rsp
  8093d5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8093d9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8093de:	75 2a                	jne    80940a <netbuf_first+0x3d>
  8093e0:	48 ba 34 1a 82 00 00 	movabs $0x821a34,%rdx
  8093e7:	00 00 00 
  8093ea:	be e8 00 00 00       	mov    $0xe8,%esi
  8093ef:	48 bf fa 19 82 00 00 	movabs $0x8219fa,%rdi
  8093f6:	00 00 00 
  8093f9:	b8 00 00 00 00       	mov    $0x0,%eax
  8093fe:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  809405:	00 00 00 
  809408:	ff d1                	callq  *%rcx
  buf->ptr = buf->p;
  80940a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80940e:	48 8b 10             	mov    (%rax),%rdx
  809411:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809415:	48 89 50 08          	mov    %rdx,0x8(%rax)
}
  809419:	90                   	nop
  80941a:	c9                   	leaveq 
  80941b:	c3                   	retq   

000000000080941c <lwip_sanity_check>:
#endif

#ifdef LWIP_DEBUG
static void
lwip_sanity_check(void)
{
  80941c:	55                   	push   %rbp
  80941d:	48 89 e5             	mov    %rsp,%rbp
  if (TCP_WND > (PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE))
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is larger than space provided by PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE\n"));
  if (TCP_WND < TCP_MSS)
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is smaller than MSS\n"));
#endif /* LWIP_TCP */
}
  809420:	90                   	nop
  809421:	5d                   	pop    %rbp
  809422:	c3                   	retq   

0000000000809423 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  809423:	55                   	push   %rbp
  809424:	48 89 e5             	mov    %rsp,%rbp
  /* Sanity check user-configurable values */
  lwip_sanity_check();
  809427:	48 b8 1c 94 80 00 00 	movabs $0x80941c,%rax
  80942e:	00 00 00 
  809431:	ff d0                	callq  *%rax

  /* Modules initialization */
  stats_init();
  sys_init();
  809433:	48 b8 d2 75 81 00 00 	movabs $0x8175d2,%rax
  80943a:	00 00 00 
  80943d:	ff d0                	callq  *%rax
  mem_init();
  80943f:	48 b8 80 c4 80 00 00 	movabs $0x80c480,%rax
  809446:	00 00 00 
  809449:	ff d0                	callq  *%rax
  memp_init();
  80944b:	48 b8 ed cd 80 00 00 	movabs $0x80cded,%rax
  809452:	00 00 00 
  809455:	ff d0                	callq  *%rax
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  809457:	48 b8 2c 5d 80 00 00 	movabs $0x805d2c,%rax
  80945e:	00 00 00 
  809461:	ff d0                	callq  *%rax
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  809463:	90                   	nop
  809464:	5d                   	pop    %rbp
  809465:	c3                   	retq   

0000000000809466 <dhcp_handle_nak>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  809466:	55                   	push   %rbp
  809467:	48 89 e5             	mov    %rsp,%rbp
  80946a:	48 83 ec 20          	sub    $0x20,%rsp
  80946e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809472:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809476:	48 8b 40 38          	mov    0x38(%rax),%rax
  80947a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  80947e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809482:	48 89 c7             	mov    %rax,%rdi
  809485:	48 b8 91 d4 80 00 00 	movabs $0x80d491,%rax
  80948c:	00 00 00 
  80948f:	ff d0                	callq  *%rax
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  809491:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809495:	48 be e8 28 82 00 00 	movabs $0x8228e8,%rsi
  80949c:	00 00 00 
  80949f:	48 89 c7             	mov    %rax,%rdi
  8094a2:	48 b8 a4 d2 80 00 00 	movabs $0x80d2a4,%rax
  8094a9:	00 00 00 
  8094ac:	ff d0                	callq  *%rax
  netif_set_gw(netif, IP_ADDR_ANY);
  8094ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8094b2:	48 be e8 28 82 00 00 	movabs $0x8228e8,%rsi
  8094b9:	00 00 00 
  8094bc:	48 89 c7             	mov    %rax,%rdi
  8094bf:	48 b8 ab d3 80 00 00 	movabs $0x80d3ab,%rax
  8094c6:	00 00 00 
  8094c9:	ff d0                	callq  *%rax
  netif_set_netmask(netif, IP_ADDR_ANY); 
  8094cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8094cf:	48 be e8 28 82 00 00 	movabs $0x8228e8,%rsi
  8094d6:	00 00 00 
  8094d9:	48 89 c7             	mov    %rax,%rdi
  8094dc:	48 b8 d9 d3 80 00 00 	movabs $0x80d3d9,%rax
  8094e3:	00 00 00 
  8094e6:	ff d0                	callq  *%rax
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  8094e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8094ec:	be 0c 00 00 00       	mov    $0xc,%esi
  8094f1:	48 89 c7             	mov    %rax,%rdi
  8094f4:	48 b8 1d b2 80 00 00 	movabs $0x80b21d,%rax
  8094fb:	00 00 00 
  8094fe:	ff d0                	callq  *%rax
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  809500:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809504:	48 89 c7             	mov    %rax,%rdi
  809507:	48 b8 36 a6 80 00 00 	movabs $0x80a636,%rax
  80950e:	00 00 00 
  809511:	ff d0                	callq  *%rax
}
  809513:	90                   	nop
  809514:	c9                   	leaveq 
  809515:	c3                   	retq   

0000000000809516 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  809516:	55                   	push   %rbp
  809517:	48 89 e5             	mov    %rsp,%rbp
  80951a:	48 83 ec 20          	sub    $0x20,%rsp
  80951e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809522:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809526:	48 8b 40 38          	mov    0x38(%rax),%rax
  80952a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  80952e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809532:	48 8d 48 4c          	lea    0x4c(%rax),%rcx
  809536:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80953a:	ba 00 00 00 00       	mov    $0x0,%edx
  80953f:	48 89 ce             	mov    %rcx,%rsi
  809542:	48 89 c7             	mov    %rax,%rdi
  809545:	48 b8 75 6d 81 00 00 	movabs $0x816d75,%rax
  80954c:	00 00 00 
  80954f:	ff d0                	callq  *%rax
  809551:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  809554:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809558:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80955c:	8d 50 01             	lea    0x1(%rax),%edx
  80955f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809563:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = 500;
  809566:	66 c7 45 f4 f4 01    	movw   $0x1f4,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80956c:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  809570:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  809576:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80957b:	89 c8                	mov    %ecx,%eax
  80957d:	f7 ea                	imul   %edx
  80957f:	c1 fa 05             	sar    $0x5,%edx
  809582:	89 c8                	mov    %ecx,%eax
  809584:	c1 f8 1f             	sar    $0x1f,%eax
  809587:	29 c2                	sub    %eax,%edx
  809589:	89 d0                	mov    %edx,%eax
  80958b:	89 c2                	mov    %eax,%edx
  80958d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809591:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  809595:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809599:	be 08 00 00 00       	mov    $0x8,%esi
  80959e:	48 89 c7             	mov    %rax,%rdi
  8095a1:	48 b8 1d b2 80 00 00 	movabs $0x80b21d,%rax
  8095a8:	00 00 00 
  8095ab:	ff d0                	callq  *%rax
}
  8095ad:	90                   	nop
  8095ae:	c9                   	leaveq 
  8095af:	c3                   	retq   

00000000008095b0 <dhcp_handle_offer>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  8095b0:	55                   	push   %rbp
  8095b1:	48 89 e5             	mov    %rsp,%rbp
  8095b4:	48 83 ec 20          	sub    $0x20,%rsp
  8095b8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  8095bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8095c0:	48 8b 40 38          	mov    0x38(%rax),%rax
  8095c4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  8095c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095cc:	be 36 00 00 00       	mov    $0x36,%esi
  8095d1:	48 89 c7             	mov    %rax,%rdi
  8095d4:	48 b8 05 c0 80 00 00 	movabs $0x80c005,%rax
  8095db:	00 00 00 
  8095de:	ff d0                	callq  *%rax
  8095e0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  8095e4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8095e9:	74 6b                	je     809656 <dhcp_handle_offer+0xa6>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8095eb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8095ef:	48 83 c0 02          	add    $0x2,%rax
  8095f3:	48 89 c7             	mov    %rax,%rdi
  8095f6:	48 b8 dc c1 80 00 00 	movabs $0x80c1dc,%rax
  8095fd:	00 00 00 
  809600:	ff d0                	callq  *%rax
  809602:	89 c7                	mov    %eax,%edi
  809604:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  80960b:	00 00 00 
  80960e:	ff d0                	callq  *%rax
  809610:	89 c2                	mov    %eax,%edx
  809612:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809616:	89 50 48             	mov    %edx,0x48(%rax)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  809619:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80961d:	48 8b 40 18          	mov    0x18(%rax),%rax
  809621:	48 83 c0 10          	add    $0x10,%rax
  809625:	48 85 c0             	test   %rax,%rax
  809628:	74 0d                	je     809637 <dhcp_handle_offer+0x87>
  80962a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80962e:	48 8b 40 18          	mov    0x18(%rax),%rax
  809632:	8b 40 10             	mov    0x10(%rax),%eax
  809635:	eb 05                	jmp    80963c <dhcp_handle_offer+0x8c>
  809637:	b8 00 00 00 00       	mov    $0x0,%eax
  80963c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  809640:	89 42 4c             	mov    %eax,0x4c(%rdx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  809643:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809647:	48 89 c7             	mov    %rax,%rdi
  80964a:	48 b8 59 96 80 00 00 	movabs $0x809659,%rax
  809651:	00 00 00 
  809654:	ff d0                	callq  *%rax
  }
}
  809656:	90                   	nop
  809657:	c9                   	leaveq 
  809658:	c3                   	retq   

0000000000809659 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  809659:	55                   	push   %rbp
  80965a:	48 89 e5             	mov    %rsp,%rbp
  80965d:	48 83 ec 20          	sub    $0x20,%rsp
  809661:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809665:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809669:	48 8b 40 38          	mov    0x38(%rax),%rax
  80966d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  809671:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809675:	48 89 c7             	mov    %rax,%rdi
  809678:	48 b8 2d ba 80 00 00 	movabs $0x80ba2d,%rax
  80967f:	00 00 00 
  809682:	ff d0                	callq  *%rax
  809684:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  809687:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80968b:	0f 85 3a 02 00 00    	jne    8098cb <dhcp_select+0x272>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  809691:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809695:	ba 01 00 00 00       	mov    $0x1,%edx
  80969a:	be 35 00 00 00       	mov    $0x35,%esi
  80969f:	48 89 c7             	mov    %rax,%rdi
  8096a2:	48 b8 4f b2 80 00 00 	movabs $0x80b24f,%rax
  8096a9:	00 00 00 
  8096ac:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  8096ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096b2:	be 03 00 00 00       	mov    $0x3,%esi
  8096b7:	48 89 c7             	mov    %rax,%rdi
  8096ba:	48 b8 01 b3 80 00 00 	movabs $0x80b301,%rax
  8096c1:	00 00 00 
  8096c4:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8096c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096ca:	ba 02 00 00 00       	mov    $0x2,%edx
  8096cf:	be 39 00 00 00       	mov    $0x39,%esi
  8096d4:	48 89 c7             	mov    %rax,%rdi
  8096d7:	48 b8 4f b2 80 00 00 	movabs $0x80b24f,%rax
  8096de:	00 00 00 
  8096e1:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  8096e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096e7:	be 40 02 00 00       	mov    $0x240,%esi
  8096ec:	48 89 c7             	mov    %rax,%rdi
  8096ef:	48 b8 78 b3 80 00 00 	movabs $0x80b378,%rax
  8096f6:	00 00 00 
  8096f9:	ff d0                	callq  *%rax

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8096fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096ff:	ba 04 00 00 00       	mov    $0x4,%edx
  809704:	be 32 00 00 00       	mov    $0x32,%esi
  809709:	48 89 c7             	mov    %rax,%rdi
  80970c:	48 b8 4f b2 80 00 00 	movabs $0x80b24f,%rax
  809713:	00 00 00 
  809716:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  809718:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80971c:	8b 40 4c             	mov    0x4c(%rax),%eax
  80971f:	89 c7                	mov    %eax,%edi
  809721:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  809728:	00 00 00 
  80972b:	ff d0                	callq  *%rax
  80972d:	89 c2                	mov    %eax,%edx
  80972f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809733:	89 d6                	mov    %edx,%esi
  809735:	48 89 c7             	mov    %rax,%rdi
  809738:	48 b8 24 b4 80 00 00 	movabs $0x80b424,%rax
  80973f:	00 00 00 
  809742:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  809744:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809748:	ba 04 00 00 00       	mov    $0x4,%edx
  80974d:	be 36 00 00 00       	mov    $0x36,%esi
  809752:	48 89 c7             	mov    %rax,%rdi
  809755:	48 b8 4f b2 80 00 00 	movabs $0x80b24f,%rax
  80975c:	00 00 00 
  80975f:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  809761:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809765:	8b 40 48             	mov    0x48(%rax),%eax
  809768:	89 c7                	mov    %eax,%edi
  80976a:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  809771:	00 00 00 
  809774:	ff d0                	callq  *%rax
  809776:	89 c2                	mov    %eax,%edx
  809778:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80977c:	89 d6                	mov    %edx,%esi
  80977e:	48 89 c7             	mov    %rax,%rdi
  809781:	48 b8 24 b4 80 00 00 	movabs $0x80b424,%rax
  809788:	00 00 00 
  80978b:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  80978d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809791:	ba 04 00 00 00       	mov    $0x4,%edx
  809796:	be 37 00 00 00       	mov    $0x37,%esi
  80979b:	48 89 c7             	mov    %rax,%rdi
  80979e:	48 b8 4f b2 80 00 00 	movabs $0x80b24f,%rax
  8097a5:	00 00 00 
  8097a8:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  8097aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097ae:	be 01 00 00 00       	mov    $0x1,%esi
  8097b3:	48 89 c7             	mov    %rax,%rdi
  8097b6:	48 b8 01 b3 80 00 00 	movabs $0x80b301,%rax
  8097bd:	00 00 00 
  8097c0:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  8097c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097c6:	be 03 00 00 00       	mov    $0x3,%esi
  8097cb:	48 89 c7             	mov    %rax,%rdi
  8097ce:	48 b8 01 b3 80 00 00 	movabs $0x80b301,%rax
  8097d5:	00 00 00 
  8097d8:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  8097da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097de:	be 1c 00 00 00       	mov    $0x1c,%esi
  8097e3:	48 89 c7             	mov    %rax,%rdi
  8097e6:	48 b8 01 b3 80 00 00 	movabs $0x80b301,%rax
  8097ed:	00 00 00 
  8097f0:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  8097f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097f6:	be 06 00 00 00       	mov    $0x6,%esi
  8097fb:	48 89 c7             	mov    %rax,%rdi
  8097fe:	48 b8 01 b3 80 00 00 	movabs $0x80b301,%rax
  809805:	00 00 00 
  809808:	ff d0                	callq  *%rax
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  80980a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80980e:	48 89 c7             	mov    %rax,%rdi
  809811:	48 b8 ac be 80 00 00 	movabs $0x80beac,%rax
  809818:	00 00 00 
  80981b:	ff d0                	callq  *%rax
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80981d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809821:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  809825:	66 05 f0 00          	add    $0xf0,%ax
  809829:	0f b7 d0             	movzwl %ax,%edx
  80982c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809830:	48 8b 40 30          	mov    0x30(%rax),%rax
  809834:	89 d6                	mov    %edx,%esi
  809836:	48 89 c7             	mov    %rax,%rdi
  809839:	48 b8 ba d9 80 00 00 	movabs $0x80d9ba,%rax
  809840:	00 00 00 
  809843:	ff d0                	callq  *%rax

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  809845:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809849:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80984d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809851:	48 8b 40 08          	mov    0x8(%rax),%rax
  809855:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  809859:	49 89 d0             	mov    %rdx,%r8
  80985c:	b9 43 00 00 00       	mov    $0x43,%ecx
  809861:	48 ba ec 28 82 00 00 	movabs $0x8228ec,%rdx
  809868:	00 00 00 
  80986b:	48 89 c7             	mov    %rax,%rdi
  80986e:	48 b8 b3 54 81 00 00 	movabs $0x8154b3,%rax
  809875:	00 00 00 
  809878:	ff d0                	callq  *%rax
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80987a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80987e:	48 8b 40 08          	mov    0x8(%rax),%rax
  809882:	ba 43 00 00 00       	mov    $0x43,%edx
  809887:	48 be e8 28 82 00 00 	movabs $0x8228e8,%rsi
  80988e:	00 00 00 
  809891:	48 89 c7             	mov    %rax,%rdi
  809894:	48 b8 bd 58 81 00 00 	movabs $0x8158bd,%rax
  80989b:	00 00 00 
  80989e:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  8098a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8098a4:	48 89 c7             	mov    %rax,%rdi
  8098a7:	48 b8 85 bd 80 00 00 	movabs $0x80bd85,%rax
  8098ae:	00 00 00 
  8098b1:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  8098b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098b7:	be 01 00 00 00       	mov    $0x1,%esi
  8098bc:	48 89 c7             	mov    %rax,%rdi
  8098bf:	48 b8 1d b2 80 00 00 	movabs $0x80b21d,%rax
  8098c6:	00 00 00 
  8098c9:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8098cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098cf:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8098d3:	8d 50 01             	lea    0x1(%rax),%edx
  8098d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098da:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  8098dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098e1:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8098e5:	3c 03                	cmp    $0x3,%al
  8098e7:	77 12                	ja     8098fb <dhcp_select+0x2a2>
  8098e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8098ed:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8098f1:	0f b6 c0             	movzbl %al,%eax
  8098f4:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  8098f9:	eb 05                	jmp    809900 <dhcp_select+0x2a7>
  8098fb:	b8 a0 0f 00 00       	mov    $0xfa0,%eax
  809900:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  809904:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  809908:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80990e:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  809913:	89 c8                	mov    %ecx,%eax
  809915:	f7 ea                	imul   %edx
  809917:	c1 fa 05             	sar    $0x5,%edx
  80991a:	89 c8                	mov    %ecx,%eax
  80991c:	c1 f8 1f             	sar    $0x1f,%eax
  80991f:	29 c2                	sub    %eax,%edx
  809921:	89 d0                	mov    %edx,%eax
  809923:	89 c2                	mov    %eax,%edx
  809925:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809929:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80992d:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  809931:	c9                   	leaveq 
  809932:	c3                   	retq   

0000000000809933 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  809933:	55                   	push   %rbp
  809934:	48 89 e5             	mov    %rsp,%rbp
  809937:	48 83 ec 10          	sub    $0x10,%rsp
  struct netif *netif = netif_list;
  80993b:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  809942:	00 00 00 
  809945:	48 8b 00             	mov    (%rax),%rax
  809948:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  80994c:	eb 72                	jmp    8099c0 <dhcp_coarse_tmr+0x8d>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  80994e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809952:	48 8b 40 38          	mov    0x38(%rax),%rax
  809956:	48 85 c0             	test   %rax,%rax
  809959:	74 5a                	je     8099b5 <dhcp_coarse_tmr+0x82>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  80995b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80995f:	48 8b 40 38          	mov    0x38(%rax),%rax
  809963:	0f b7 50 46          	movzwl 0x46(%rax),%edx
  809967:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  80996a:	66 89 48 46          	mov    %cx,0x46(%rax)
  80996e:	66 83 fa 01          	cmp    $0x1,%dx
  809972:	75 15                	jne    809989 <dhcp_coarse_tmr+0x56>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
  809974:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809978:	48 89 c7             	mov    %rax,%rdi
  80997b:	48 b8 0e 9c 80 00 00 	movabs $0x809c0e,%rax
  809982:	00 00 00 
  809985:	ff d0                	callq  *%rax
  809987:	eb 2c                	jmp    8099b5 <dhcp_coarse_tmr+0x82>
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  809989:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80998d:	48 8b 40 38          	mov    0x38(%rax),%rax
  809991:	0f b7 50 44          	movzwl 0x44(%rax),%edx
  809995:	8d 4a ff             	lea    -0x1(%rdx),%ecx
  809998:	66 89 48 44          	mov    %cx,0x44(%rax)
  80999c:	66 83 fa 01          	cmp    $0x1,%dx
  8099a0:	75 13                	jne    8099b5 <dhcp_coarse_tmr+0x82>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
  8099a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099a6:	48 89 c7             	mov    %rax,%rdi
  8099a9:	48 b8 bf 9b 80 00 00 	movabs $0x809bbf,%rax
  8099b0:	00 00 00 
  8099b3:	ff d0                	callq  *%rax
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  8099b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099b9:	48 8b 00             	mov    (%rax),%rax
  8099bc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  8099c0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8099c5:	75 87                	jne    80994e <dhcp_coarse_tmr+0x1b>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  8099c7:	90                   	nop
  8099c8:	c9                   	leaveq 
  8099c9:	c3                   	retq   

00000000008099ca <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  8099ca:	55                   	push   %rbp
  8099cb:	48 89 e5             	mov    %rsp,%rbp
  8099ce:	48 83 ec 10          	sub    $0x10,%rsp
  struct netif *netif = netif_list;
  8099d2:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  8099d9:	00 00 00 
  8099dc:	48 8b 00             	mov    (%rax),%rax
  8099df:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* loop through netif's */
  while (netif != NULL) {
  8099e3:	eb 77                	jmp    809a5c <dhcp_fine_tmr+0x92>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  8099e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099e9:	48 8b 40 38          	mov    0x38(%rax),%rax
  8099ed:	48 85 c0             	test   %rax,%rax
  8099f0:	74 5f                	je     809a51 <dhcp_fine_tmr+0x87>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  8099f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099f6:	48 8b 40 38          	mov    0x38(%rax),%rax
  8099fa:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  8099fe:	66 83 f8 01          	cmp    $0x1,%ax
  809a02:	76 15                	jbe    809a19 <dhcp_fine_tmr+0x4f>
        netif->dhcp->request_timeout--;
  809a04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a08:	48 8b 40 38          	mov    0x38(%rax),%rax
  809a0c:	0f b7 50 42          	movzwl 0x42(%rax),%edx
  809a10:	83 ea 01             	sub    $0x1,%edx
  809a13:	66 89 50 42          	mov    %dx,0x42(%rax)
  809a17:	eb 38                	jmp    809a51 <dhcp_fine_tmr+0x87>
      }
      else if (netif->dhcp->request_timeout == 1) {
  809a19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a1d:	48 8b 40 38          	mov    0x38(%rax),%rax
  809a21:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  809a25:	66 83 f8 01          	cmp    $0x1,%ax
  809a29:	75 26                	jne    809a51 <dhcp_fine_tmr+0x87>
        netif->dhcp->request_timeout--;
  809a2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a2f:	48 8b 40 38          	mov    0x38(%rax),%rax
  809a33:	0f b7 50 42          	movzwl 0x42(%rax),%edx
  809a37:	83 ea 01             	sub    $0x1,%edx
  809a3a:	66 89 50 42          	mov    %dx,0x42(%rax)
        /* { netif->dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
  809a3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a42:	48 89 c7             	mov    %rax,%rdi
  809a45:	48 b8 66 9a 80 00 00 	movabs $0x809a66,%rax
  809a4c:	00 00 00 
  809a4f:	ff d0                	callq  *%rax
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  809a51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a55:	48 8b 00             	mov    (%rax),%rax
  809a58:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  809a5c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809a61:	75 82                	jne    8099e5 <dhcp_fine_tmr+0x1b>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  809a63:	90                   	nop
  809a64:	c9                   	leaveq 
  809a65:	c3                   	retq   

0000000000809a66 <dhcp_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  809a66:	55                   	push   %rbp
  809a67:	48 89 e5             	mov    %rsp,%rbp
  809a6a:	48 83 ec 20          	sub    $0x20,%rsp
  809a6e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809a72:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809a76:	48 8b 40 38          	mov    0x38(%rax),%rax
  809a7a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  809a7e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a82:	0f b6 00             	movzbl (%rax),%eax
  809a85:	3c 0c                	cmp    $0xc,%al
  809a87:	74 0b                	je     809a94 <dhcp_timeout+0x2e>
  809a89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a8d:	0f b6 00             	movzbl (%rax),%eax
  809a90:	3c 06                	cmp    $0x6,%al
  809a92:	75 18                	jne    809aac <dhcp_timeout+0x46>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  809a94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809a98:	48 89 c7             	mov    %rax,%rdi
  809a9b:	48 b8 36 a6 80 00 00 	movabs $0x80a636,%rax
  809aa2:	00 00 00 
  809aa5:	ff d0                	callq  *%rax
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  }
}
  809aa7:	e9 10 01 00 00       	jmpq   809bbc <dhcp_timeout+0x156>
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  809aac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809ab0:	0f b6 00             	movzbl (%rax),%eax
  809ab3:	3c 01                	cmp    $0x1,%al
  809ab5:	75 4f                	jne    809b06 <dhcp_timeout+0xa0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  809ab7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809abb:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809abf:	3c 05                	cmp    $0x5,%al
  809ac1:	77 18                	ja     809adb <dhcp_timeout+0x75>
      dhcp_select(netif);
  809ac3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809ac7:	48 89 c7             	mov    %rax,%rdi
  809aca:	48 b8 59 96 80 00 00 	movabs $0x809659,%rax
  809ad1:	00 00 00 
  809ad4:	ff d0                	callq  *%rax
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  }
}
  809ad6:	e9 e1 00 00 00       	jmpq   809bbc <dhcp_timeout+0x156>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
      dhcp_select(netif);
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  809adb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809adf:	48 89 c7             	mov    %rax,%rdi
  809ae2:	48 b8 b2 ae 80 00 00 	movabs $0x80aeb2,%rax
  809ae9:	00 00 00 
  809aec:	ff d0                	callq  *%rax
      dhcp_discover(netif);
  809aee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809af2:	48 89 c7             	mov    %rax,%rdi
  809af5:	48 b8 36 a6 80 00 00 	movabs $0x80a636,%rax
  809afc:	00 00 00 
  809aff:	ff d0                	callq  *%rax
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  }
}
  809b01:	e9 b6 00 00 00       	jmpq   809bbc <dhcp_timeout+0x156>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  809b06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809b0a:	0f b6 00             	movzbl (%rax),%eax
  809b0d:	3c 08                	cmp    $0x8,%al
  809b0f:	75 39                	jne    809b4a <dhcp_timeout+0xe4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  809b11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809b15:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809b19:	3c 01                	cmp    $0x1,%al
  809b1b:	77 18                	ja     809b35 <dhcp_timeout+0xcf>
      dhcp_check(netif);
  809b1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b21:	48 89 c7             	mov    %rax,%rdi
  809b24:	48 b8 16 95 80 00 00 	movabs $0x809516,%rax
  809b2b:	00 00 00 
  809b2e:	ff d0                	callq  *%rax
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  }
}
  809b30:	e9 87 00 00 00       	jmpq   809bbc <dhcp_timeout+0x156>
      dhcp_check(netif);
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  809b35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b39:	48 89 c7             	mov    %rax,%rdi
  809b3c:	48 b8 98 a8 80 00 00 	movabs $0x80a898,%rax
  809b43:	00 00 00 
  809b46:	ff d0                	callq  *%rax
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  }
}
  809b48:	eb 72                	jmp    809bbc <dhcp_timeout+0x156>
      /* bind the interface to the offered address */
      dhcp_bind(netif);
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  809b4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809b4e:	0f b6 00             	movzbl (%rax),%eax
  809b51:	3c 05                	cmp    $0x5,%al
  809b53:	75 15                	jne    809b6a <dhcp_timeout+0x104>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  809b55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b59:	48 89 c7             	mov    %rax,%rdi
  809b5c:	48 b8 1d ab 80 00 00 	movabs $0x80ab1d,%rax
  809b63:	00 00 00 
  809b66:	ff d0                	callq  *%rax
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  }
}
  809b68:	eb 52                	jmp    809bbc <dhcp_timeout+0x156>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  809b6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809b6e:	0f b6 00             	movzbl (%rax),%eax
  809b71:	3c 04                	cmp    $0x4,%al
  809b73:	75 47                	jne    809bbc <dhcp_timeout+0x156>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  809b75:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809b79:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809b7d:	3c 08                	cmp    $0x8,%al
  809b7f:	77 15                	ja     809b96 <dhcp_timeout+0x130>
      dhcp_rebind(netif);
  809b81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b85:	48 89 c7             	mov    %rax,%rdi
  809b88:	48 b8 e7 ac 80 00 00 	movabs $0x80ace7,%rax
  809b8f:	00 00 00 
  809b92:	ff d0                	callq  *%rax
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  }
}
  809b94:	eb 26                	jmp    809bbc <dhcp_timeout+0x156>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
      dhcp_rebind(netif);
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  809b96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b9a:	48 89 c7             	mov    %rax,%rdi
  809b9d:	48 b8 b2 ae 80 00 00 	movabs $0x80aeb2,%rax
  809ba4:	00 00 00 
  809ba7:	ff d0                	callq  *%rax
      dhcp_discover(netif);
  809ba9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809bad:	48 89 c7             	mov    %rax,%rdi
  809bb0:	48 b8 36 a6 80 00 00 	movabs $0x80a636,%rax
  809bb7:	00 00 00 
  809bba:	ff d0                	callq  *%rax
    }
  }
}
  809bbc:	90                   	nop
  809bbd:	c9                   	leaveq 
  809bbe:	c3                   	retq   

0000000000809bbf <dhcp_t1_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
  809bbf:	55                   	push   %rbp
  809bc0:	48 89 e5             	mov    %rsp,%rbp
  809bc3:	48 83 ec 20          	sub    $0x20,%rsp
  809bc7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809bcb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809bcf:	48 8b 40 38          	mov    0x38(%rax),%rax
  809bd3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  809bd7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809bdb:	0f b6 00             	movzbl (%rax),%eax
  809bde:	3c 01                	cmp    $0x1,%al
  809be0:	74 16                	je     809bf8 <dhcp_t1_timeout+0x39>
  809be2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809be6:	0f b6 00             	movzbl (%rax),%eax
  809be9:	3c 0a                	cmp    $0xa,%al
  809beb:	74 0b                	je     809bf8 <dhcp_t1_timeout+0x39>
  809bed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809bf1:	0f b6 00             	movzbl (%rax),%eax
  809bf4:	3c 05                	cmp    $0x5,%al
  809bf6:	75 13                	jne    809c0b <dhcp_t1_timeout+0x4c>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  809bf8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809bfc:	48 89 c7             	mov    %rax,%rdi
  809bff:	48 b8 1d ab 80 00 00 	movabs $0x80ab1d,%rax
  809c06:	00 00 00 
  809c09:	ff d0                	callq  *%rax
  }
}
  809c0b:	90                   	nop
  809c0c:	c9                   	leaveq 
  809c0d:	c3                   	retq   

0000000000809c0e <dhcp_t2_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
  809c0e:	55                   	push   %rbp
  809c0f:	48 89 e5             	mov    %rsp,%rbp
  809c12:	48 83 ec 20          	sub    $0x20,%rsp
  809c16:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809c1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809c1e:	48 8b 40 38          	mov    0x38(%rax),%rax
  809c22:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  809c26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809c2a:	0f b6 00             	movzbl (%rax),%eax
  809c2d:	3c 01                	cmp    $0x1,%al
  809c2f:	74 16                	je     809c47 <dhcp_t2_timeout+0x39>
  809c31:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809c35:	0f b6 00             	movzbl (%rax),%eax
  809c38:	3c 0a                	cmp    $0xa,%al
  809c3a:	74 0b                	je     809c47 <dhcp_t2_timeout+0x39>
  809c3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809c40:	0f b6 00             	movzbl (%rax),%eax
  809c43:	3c 05                	cmp    $0x5,%al
  809c45:	75 13                	jne    809c5a <dhcp_t2_timeout+0x4c>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  809c47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809c4b:	48 89 c7             	mov    %rax,%rdi
  809c4e:	48 b8 e7 ac 80 00 00 	movabs $0x80ace7,%rax
  809c55:	00 00 00 
  809c58:	ff d0                	callq  *%rax
  }
}
  809c5a:	90                   	nop
  809c5b:	c9                   	leaveq 
  809c5c:	c3                   	retq   

0000000000809c5d <dhcp_handle_ack>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  809c5d:	55                   	push   %rbp
  809c5e:	48 89 e5             	mov    %rsp,%rbp
  809c61:	53                   	push   %rbx
  809c62:	48 83 ec 38          	sub    $0x38,%rsp
  809c66:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809c6a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  809c6e:	48 8b 40 38          	mov    0x38(%rax),%rax
  809c72:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  809c76:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809c7a:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%rax)
  dhcp->offered_gw_addr.addr = 0;
  809c81:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809c85:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%rax)
  dhcp->offered_bc_addr.addr = 0;
  809c8c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809c90:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%rax)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  809c97:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809c9b:	be 33 00 00 00       	mov    $0x33,%esi
  809ca0:	48 89 c7             	mov    %rax,%rdi
  809ca3:	48 b8 05 c0 80 00 00 	movabs $0x80c005,%rax
  809caa:	00 00 00 
  809cad:	ff d0                	callq  *%rax
  809caf:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809cb3:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809cb8:	74 20                	je     809cda <dhcp_handle_ack+0x7d>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  809cba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809cbe:	48 83 c0 02          	add    $0x2,%rax
  809cc2:	48 89 c7             	mov    %rax,%rdi
  809cc5:	48 b8 dc c1 80 00 00 	movabs $0x80c1dc,%rax
  809ccc:	00 00 00 
  809ccf:	ff d0                	callq  *%rax
  809cd1:	89 c2                	mov    %eax,%edx
  809cd3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809cd7:	89 50 68             	mov    %edx,0x68(%rax)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  809cda:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809cde:	be 3a 00 00 00       	mov    $0x3a,%esi
  809ce3:	48 89 c7             	mov    %rax,%rdi
  809ce6:	48 b8 05 c0 80 00 00 	movabs $0x80c005,%rax
  809ced:	00 00 00 
  809cf0:	ff d0                	callq  *%rax
  809cf2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809cf6:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809cfb:	74 22                	je     809d1f <dhcp_handle_ack+0xc2>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  809cfd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809d01:	48 83 c0 02          	add    $0x2,%rax
  809d05:	48 89 c7             	mov    %rax,%rdi
  809d08:	48 b8 dc c1 80 00 00 	movabs $0x80c1dc,%rax
  809d0f:	00 00 00 
  809d12:	ff d0                	callq  *%rax
  809d14:	89 c2                	mov    %eax,%edx
  809d16:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d1a:	89 50 6c             	mov    %edx,0x6c(%rax)
  809d1d:	eb 12                	jmp    809d31 <dhcp_handle_ack+0xd4>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  809d1f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d23:	8b 40 68             	mov    0x68(%rax),%eax
  809d26:	d1 e8                	shr    %eax
  809d28:	89 c2                	mov    %eax,%edx
  809d2a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d2e:	89 50 6c             	mov    %edx,0x6c(%rax)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  809d31:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d35:	be 3b 00 00 00       	mov    $0x3b,%esi
  809d3a:	48 89 c7             	mov    %rax,%rdi
  809d3d:	48 b8 05 c0 80 00 00 	movabs $0x80c005,%rax
  809d44:	00 00 00 
  809d47:	ff d0                	callq  *%rax
  809d49:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809d4d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809d52:	74 22                	je     809d76 <dhcp_handle_ack+0x119>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  809d54:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809d58:	48 83 c0 02          	add    $0x2,%rax
  809d5c:	48 89 c7             	mov    %rax,%rdi
  809d5f:	48 b8 dc c1 80 00 00 	movabs $0x80c1dc,%rax
  809d66:	00 00 00 
  809d69:	ff d0                	callq  *%rax
  809d6b:	89 c2                	mov    %eax,%edx
  809d6d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d71:	89 50 70             	mov    %edx,0x70(%rax)
  809d74:	eb 0e                	jmp    809d84 <dhcp_handle_ack+0x127>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  809d76:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d7a:	8b 50 68             	mov    0x68(%rax),%edx
  809d7d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d81:	89 50 70             	mov    %edx,0x70(%rax)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  809d84:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d88:	48 8b 40 18          	mov    0x18(%rax),%rax
  809d8c:	48 83 c0 10          	add    $0x10,%rax
  809d90:	48 85 c0             	test   %rax,%rax
  809d93:	74 0d                	je     809da2 <dhcp_handle_ack+0x145>
  809d95:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809d99:	48 8b 40 18          	mov    0x18(%rax),%rax
  809d9d:	8b 40 10             	mov    0x10(%rax),%eax
  809da0:	eb 05                	jmp    809da7 <dhcp_handle_ack+0x14a>
  809da2:	b8 00 00 00 00       	mov    $0x0,%eax
  809da7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809dab:	89 42 4c             	mov    %eax,0x4c(%rdx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  809dae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809db2:	be 01 00 00 00       	mov    $0x1,%esi
  809db7:	48 89 c7             	mov    %rax,%rdi
  809dba:	48 b8 05 c0 80 00 00 	movabs $0x80c005,%rax
  809dc1:	00 00 00 
  809dc4:	ff d0                	callq  *%rax
  809dc6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  /* subnet mask given? */
  if (option_ptr != NULL) {
  809dca:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809dcf:	74 2e                	je     809dff <dhcp_handle_ack+0x1a2>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  809dd1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809dd5:	48 83 c0 02          	add    $0x2,%rax
  809dd9:	48 89 c7             	mov    %rax,%rdi
  809ddc:	48 b8 dc c1 80 00 00 	movabs $0x80c1dc,%rax
  809de3:	00 00 00 
  809de6:	ff d0                	callq  *%rax
  809de8:	89 c7                	mov    %eax,%edi
  809dea:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  809df1:	00 00 00 
  809df4:	ff d0                	callq  *%rax
  809df6:	89 c2                	mov    %eax,%edx
  809df8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809dfc:	89 50 50             	mov    %edx,0x50(%rax)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  809dff:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809e03:	be 03 00 00 00       	mov    $0x3,%esi
  809e08:	48 89 c7             	mov    %rax,%rdi
  809e0b:	48 b8 05 c0 80 00 00 	movabs $0x80c005,%rax
  809e12:	00 00 00 
  809e15:	ff d0                	callq  *%rax
  809e17:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809e1b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809e20:	74 2e                	je     809e50 <dhcp_handle_ack+0x1f3>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  809e22:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809e26:	48 83 c0 02          	add    $0x2,%rax
  809e2a:	48 89 c7             	mov    %rax,%rdi
  809e2d:	48 b8 dc c1 80 00 00 	movabs $0x80c1dc,%rax
  809e34:	00 00 00 
  809e37:	ff d0                	callq  *%rax
  809e39:	89 c7                	mov    %eax,%edi
  809e3b:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  809e42:	00 00 00 
  809e45:	ff d0                	callq  *%rax
  809e47:	89 c2                	mov    %eax,%edx
  809e49:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809e4d:	89 50 54             	mov    %edx,0x54(%rax)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  809e50:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809e54:	be 1c 00 00 00       	mov    $0x1c,%esi
  809e59:	48 89 c7             	mov    %rax,%rdi
  809e5c:	48 b8 05 c0 80 00 00 	movabs $0x80c005,%rax
  809e63:	00 00 00 
  809e66:	ff d0                	callq  *%rax
  809e68:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809e6c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809e71:	74 2e                	je     809ea1 <dhcp_handle_ack+0x244>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  809e73:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809e77:	48 83 c0 02          	add    $0x2,%rax
  809e7b:	48 89 c7             	mov    %rax,%rdi
  809e7e:	48 b8 dc c1 80 00 00 	movabs $0x80c1dc,%rax
  809e85:	00 00 00 
  809e88:	ff d0                	callq  *%rax
  809e8a:	89 c7                	mov    %eax,%edi
  809e8c:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  809e93:	00 00 00 
  809e96:	ff d0                	callq  *%rax
  809e98:	89 c2                	mov    %eax,%edx
  809e9a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809e9e:	89 50 58             	mov    %edx,0x58(%rax)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  809ea1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809ea5:	be 06 00 00 00       	mov    $0x6,%esi
  809eaa:	48 89 c7             	mov    %rax,%rdi
  809ead:	48 b8 05 c0 80 00 00 	movabs $0x80c005,%rax
  809eb4:	00 00 00 
  809eb7:	ff d0                	callq  *%rax
  809eb9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809ebd:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809ec2:	0f 84 9f 00 00 00    	je     809f67 <dhcp_handle_ack+0x30a>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  809ec8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809ecc:	48 83 c0 01          	add    $0x1,%rax
  809ed0:	48 89 c7             	mov    %rax,%rdi
  809ed3:	48 b8 c7 c1 80 00 00 	movabs $0x80c1c7,%rax
  809eda:	00 00 00 
  809edd:	ff d0                	callq  *%rax
  809edf:	c0 e8 02             	shr    $0x2,%al
  809ee2:	0f b6 d0             	movzbl %al,%edx
  809ee5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809ee9:	89 50 5c             	mov    %edx,0x5c(%rax)
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
  809eec:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809ef0:	8b 40 5c             	mov    0x5c(%rax),%eax
  809ef3:	83 f8 02             	cmp    $0x2,%eax
  809ef6:	76 0b                	jbe    809f03 <dhcp_handle_ack+0x2a6>
      dhcp->dns_count = DHCP_MAX_DNS;
  809ef8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809efc:	c7 40 5c 02 00 00 00 	movl   $0x2,0x5c(%rax)
    for (n = 0; n < dhcp->dns_count; n++) {
  809f03:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  809f07:	eb 4f                	jmp    809f58 <dhcp_handle_ack+0x2fb>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  809f09:	0f b6 5d ef          	movzbl -0x11(%rbp),%ebx
  809f0d:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  809f11:	c1 e0 02             	shl    $0x2,%eax
  809f14:	83 c0 02             	add    $0x2,%eax
  809f17:	48 63 d0             	movslq %eax,%rdx
  809f1a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809f1e:	48 01 d0             	add    %rdx,%rax
  809f21:	48 89 c7             	mov    %rax,%rdi
  809f24:	48 b8 dc c1 80 00 00 	movabs $0x80c1dc,%rax
  809f2b:	00 00 00 
  809f2e:	ff d0                	callq  *%rax
  809f30:	89 c7                	mov    %eax,%edi
  809f32:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  809f39:	00 00 00 
  809f3c:	ff d0                	callq  *%rax
  809f3e:	89 c1                	mov    %eax,%ecx
  809f40:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809f44:	48 63 d3             	movslq %ebx,%rdx
  809f47:	48 83 c2 18          	add    $0x18,%rdx
  809f4b:	89 0c 90             	mov    %ecx,(%rax,%rdx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  809f4e:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  809f52:	83 c0 01             	add    $0x1,%eax
  809f55:	88 45 ef             	mov    %al,-0x11(%rbp)
  809f58:	0f b6 55 ef          	movzbl -0x11(%rbp),%edx
  809f5c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809f60:	8b 40 5c             	mov    0x5c(%rax),%eax
  809f63:	39 c2                	cmp    %eax,%edx
  809f65:	72 a2                	jb     809f09 <dhcp_handle_ack+0x2ac>
    }
#if LWIP_DNS
    dns_setserver( n, (struct ip_addr *)(&ip_addr_any));
#endif /* LWIP_DNS */
  }
}
  809f67:	90                   	nop
  809f68:	48 83 c4 38          	add    $0x38,%rsp
  809f6c:	5b                   	pop    %rbx
  809f6d:	5d                   	pop    %rbp
  809f6e:	c3                   	retq   

0000000000809f6f <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  809f6f:	55                   	push   %rbp
  809f70:	48 89 e5             	mov    %rsp,%rbp
  809f73:	48 83 ec 20          	sub    $0x20,%rsp
  809f77:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp;
  err_t result = ERR_OK;
  809f7b:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  809f7f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  809f84:	75 2a                	jne    809fb0 <dhcp_start+0x41>
  809f86:	48 ba e8 1a 82 00 00 	movabs $0x821ae8,%rdx
  809f8d:	00 00 00 
  809f90:	be 39 02 00 00       	mov    $0x239,%esi
  809f95:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  809f9c:	00 00 00 
  809f9f:	b8 00 00 00 00       	mov    $0x0,%eax
  809fa4:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  809fab:	00 00 00 
  809fae:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  809fb0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809fb4:	48 8b 40 38          	mov    0x38(%rax),%rax
  809fb8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  809fbc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809fc0:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  809fc4:	83 e0 f7             	and    $0xfffffff7,%eax
  809fc7:	89 c2                	mov    %eax,%edx
  809fc9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809fcd:	88 50 4a             	mov    %dl,0x4a(%rax)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  809fd0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809fd5:	75 32                	jne    80a009 <dhcp_start+0x9a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  809fd7:	bf 78 00 00 00       	mov    $0x78,%edi
  809fdc:	48 b8 10 ca 80 00 00 	movabs $0x80ca10,%rax
  809fe3:	00 00 00 
  809fe6:	ff d0                	callq  *%rax
  809fe8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (dhcp == NULL) {
  809fec:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809ff1:	75 0a                	jne    809ffd <dhcp_start+0x8e>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  809ff3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809ff8:	e9 3d 01 00 00       	jmpq   80a13a <dhcp_start+0x1cb>
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  809ffd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a001:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80a005:	48 89 50 38          	mov    %rdx,0x38(%rax)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  80a009:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a00d:	ba 78 00 00 00       	mov    $0x78,%edx
  80a012:	be 00 00 00 00       	mov    $0x0,%esi
  80a017:	48 89 c7             	mov    %rax,%rdi
  80a01a:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  80a021:	00 00 00 
  80a024:	ff d0                	callq  *%rax
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  80a026:	48 b8 d0 5a 81 00 00 	movabs $0x815ad0,%rax
  80a02d:	00 00 00 
  80a030:	ff d0                	callq  *%rax
  80a032:	48 89 c2             	mov    %rax,%rdx
  80a035:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a039:	48 89 50 08          	mov    %rdx,0x8(%rax)
  if (dhcp->pcb == NULL) {
  80a03d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a041:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a045:	48 85 c0             	test   %rax,%rax
  80a048:	75 31                	jne    80a07b <dhcp_start+0x10c>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  80a04a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a04e:	48 89 c7             	mov    %rax,%rdi
  80a051:	48 b8 6d c5 80 00 00 	movabs $0x80c56d,%rax
  80a058:	00 00 00 
  80a05b:	ff d0                	callq  *%rax
    netif->dhcp = dhcp = NULL;
  80a05d:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80a064:	00 
  80a065:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a069:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80a06d:	48 89 50 38          	mov    %rdx,0x38(%rax)
    return ERR_MEM;
  80a071:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a076:	e9 bf 00 00 00       	jmpq   80a13a <dhcp_start+0x1cb>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80a07b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a07f:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a083:	ba 44 00 00 00       	mov    $0x44,%edx
  80a088:	48 be e8 28 82 00 00 	movabs $0x8228e8,%rsi
  80a08f:	00 00 00 
  80a092:	48 89 c7             	mov    %rax,%rdi
  80a095:	48 b8 71 57 81 00 00 	movabs $0x815771,%rax
  80a09c:	00 00 00 
  80a09f:	ff d0                	callq  *%rax
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a0a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a0a5:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a0a9:	ba 43 00 00 00       	mov    $0x43,%edx
  80a0ae:	48 be e8 28 82 00 00 	movabs $0x8228e8,%rsi
  80a0b5:	00 00 00 
  80a0b8:	48 89 c7             	mov    %rax,%rdi
  80a0bb:	48 b8 bd 58 81 00 00 	movabs $0x8158bd,%rax
  80a0c2:	00 00 00 
  80a0c5:	ff d0                	callq  *%rax
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  80a0c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a0cb:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a0cf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a0d3:	48 be cd b7 80 00 00 	movabs $0x80b7cd,%rsi
  80a0da:	00 00 00 
  80a0dd:	48 89 c7             	mov    %rax,%rdi
  80a0e0:	48 b8 f6 59 81 00 00 	movabs $0x8159f6,%rax
  80a0e7:	00 00 00 
  80a0ea:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  80a0ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a0f0:	48 89 c7             	mov    %rax,%rdi
  80a0f3:	48 b8 36 a6 80 00 00 	movabs $0x80a636,%rax
  80a0fa:	00 00 00 
  80a0fd:	ff d0                	callq  *%rax
  80a0ff:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result != ERR_OK) {
  80a102:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a106:	74 1a                	je     80a122 <dhcp_start+0x1b3>
    /* free resources allocated above */
    dhcp_stop(netif);
  80a108:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a10c:	48 89 c7             	mov    %rax,%rdi
  80a10f:	48 b8 20 b1 80 00 00 	movabs $0x80b120,%rax
  80a116:	00 00 00 
  80a119:	ff d0                	callq  *%rax
    return ERR_MEM;
  80a11b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a120:	eb 18                	jmp    80a13a <dhcp_start+0x1cb>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  80a122:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a126:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80a12a:	83 c8 08             	or     $0x8,%eax
  80a12d:	89 c2                	mov    %eax,%edx
  80a12f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a133:	88 50 4a             	mov    %dl,0x4a(%rax)
  return result;
  80a136:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a13a:	c9                   	leaveq 
  80a13b:	c3                   	retq   

000000000080a13c <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  80a13c:	55                   	push   %rbp
  80a13d:	48 89 e5             	mov    %rsp,%rbp
  80a140:	48 83 ec 30          	sub    $0x30,%rsp
  80a144:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  80a148:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a14c:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a150:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  80a154:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  dhcp = mem_malloc(sizeof(struct dhcp));
  80a158:	bf 78 00 00 00       	mov    $0x78,%edi
  80a15d:	48 b8 10 ca 80 00 00 	movabs $0x80ca10,%rax
  80a164:	00 00 00 
  80a167:	ff d0                	callq  *%rax
  80a169:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (dhcp == NULL) {
  80a16d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80a172:	0f 84 3c 02 00 00    	je     80a3b4 <dhcp_inform+0x278>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  80a178:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a17c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a180:	48 89 50 38          	mov    %rdx,0x38(%rax)
  memset(dhcp, 0, sizeof(struct dhcp));
  80a184:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a188:	ba 78 00 00 00       	mov    $0x78,%edx
  80a18d:	be 00 00 00 00       	mov    $0x0,%esi
  80a192:	48 89 c7             	mov    %rax,%rdi
  80a195:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  80a19c:	00 00 00 
  80a19f:	ff d0                	callq  *%rax

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  80a1a1:	48 b8 d0 5a 81 00 00 	movabs $0x815ad0,%rax
  80a1a8:	00 00 00 
  80a1ab:	ff d0                	callq  *%rax
  80a1ad:	48 89 c2             	mov    %rax,%rdx
  80a1b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a1b4:	48 89 50 08          	mov    %rdx,0x8(%rax)
  if (dhcp->pcb == NULL) {
  80a1b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a1bc:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a1c0:	48 85 c0             	test   %rax,%rax
  80a1c3:	75 18                	jne    80a1dd <dhcp_inform+0xa1>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  80a1c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a1c9:	48 89 c7             	mov    %rax,%rdi
  80a1cc:	48 b8 6d c5 80 00 00 	movabs $0x80c56d,%rax
  80a1d3:	00 00 00 
  80a1d6:	ff d0                	callq  *%rax
    return;
  80a1d8:	e9 d8 01 00 00       	jmpq   80a3b5 <dhcp_inform+0x279>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a1dd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a1e1:	48 89 c7             	mov    %rax,%rdi
  80a1e4:	48 b8 2d ba 80 00 00 	movabs $0x80ba2d,%rax
  80a1eb:	00 00 00 
  80a1ee:	ff d0                	callq  *%rax
  80a1f0:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a1f3:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a1f7:	0f 85 5f 01 00 00    	jne    80a35c <dhcp_inform+0x220>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a1fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a201:	ba 01 00 00 00       	mov    $0x1,%edx
  80a206:	be 35 00 00 00       	mov    $0x35,%esi
  80a20b:	48 89 c7             	mov    %rax,%rdi
  80a20e:	48 b8 4f b2 80 00 00 	movabs $0x80b24f,%rax
  80a215:	00 00 00 
  80a218:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_INFORM);
  80a21a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a21e:	be 08 00 00 00       	mov    $0x8,%esi
  80a223:	48 89 c7             	mov    %rax,%rdi
  80a226:	48 b8 01 b3 80 00 00 	movabs $0x80b301,%rax
  80a22d:	00 00 00 
  80a230:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a232:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a236:	ba 02 00 00 00       	mov    $0x2,%edx
  80a23b:	be 39 00 00 00       	mov    $0x39,%esi
  80a240:	48 89 c7             	mov    %rax,%rdi
  80a243:	48 b8 4f b2 80 00 00 	movabs $0x80b24f,%rax
  80a24a:	00 00 00 
  80a24d:	ff d0                	callq  *%rax
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  80a24f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a253:	be 40 02 00 00       	mov    $0x240,%esi
  80a258:	48 89 c7             	mov    %rax,%rdi
  80a25b:	48 b8 78 b3 80 00 00 	movabs $0x80b378,%rax
  80a262:	00 00 00 
  80a265:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80a267:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a26b:	48 89 c7             	mov    %rax,%rdi
  80a26e:	48 b8 ac be 80 00 00 	movabs $0x80beac,%rax
  80a275:	00 00 00 
  80a278:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a27a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a27e:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a282:	66 05 f0 00          	add    $0xf0,%ax
  80a286:	0f b7 d0             	movzwl %ax,%edx
  80a289:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a28d:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a291:	89 d6                	mov    %edx,%esi
  80a293:	48 89 c7             	mov    %rax,%rdi
  80a296:	48 b8 ba d9 80 00 00 	movabs $0x80d9ba,%rax
  80a29d:	00 00 00 
  80a2a0:	ff d0                	callq  *%rax

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80a2a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a2a6:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a2aa:	ba 44 00 00 00       	mov    $0x44,%edx
  80a2af:	48 be e8 28 82 00 00 	movabs $0x8228e8,%rsi
  80a2b6:	00 00 00 
  80a2b9:	48 89 c7             	mov    %rax,%rdi
  80a2bc:	48 b8 71 57 81 00 00 	movabs $0x815771,%rax
  80a2c3:	00 00 00 
  80a2c6:	ff d0                	callq  *%rax
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  80a2c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a2cc:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a2d0:	ba 43 00 00 00       	mov    $0x43,%edx
  80a2d5:	48 be ec 28 82 00 00 	movabs $0x8228ec,%rsi
  80a2dc:	00 00 00 
  80a2df:	48 89 c7             	mov    %rax,%rdi
  80a2e2:	48 b8 bd 58 81 00 00 	movabs $0x8158bd,%rax
  80a2e9:	00 00 00 
  80a2ec:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a2ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a2f2:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a2f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a2fa:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a2fe:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80a302:	49 89 d0             	mov    %rdx,%r8
  80a305:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a30a:	48 ba ec 28 82 00 00 	movabs $0x8228ec,%rdx
  80a311:	00 00 00 
  80a314:	48 89 c7             	mov    %rax,%rdi
  80a317:	48 b8 b3 54 81 00 00 	movabs $0x8154b3,%rax
  80a31e:	00 00 00 
  80a321:	ff d0                	callq  *%rax
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a323:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a327:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a32b:	ba 43 00 00 00       	mov    $0x43,%edx
  80a330:	48 be e8 28 82 00 00 	movabs $0x8228e8,%rsi
  80a337:	00 00 00 
  80a33a:	48 89 c7             	mov    %rax,%rdi
  80a33d:	48 b8 bd 58 81 00 00 	movabs $0x8158bd,%rax
  80a344:	00 00 00 
  80a347:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80a349:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a34d:	48 89 c7             	mov    %rax,%rdi
  80a350:	48 b8 85 bd 80 00 00 	movabs $0x80bd85,%rax
  80a357:	00 00 00 
  80a35a:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
  80a35c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80a361:	74 52                	je     80a3b5 <dhcp_inform+0x279>
    if (dhcp->pcb != NULL) {
  80a363:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a367:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a36b:	48 85 c0             	test   %rax,%rax
  80a36e:	74 17                	je     80a387 <dhcp_inform+0x24b>
      udp_remove(dhcp->pcb);
  80a370:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a374:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a378:	48 89 c7             	mov    %rax,%rdi
  80a37b:	48 b8 25 5a 81 00 00 	movabs $0x815a25,%rax
  80a382:	00 00 00 
  80a385:	ff d0                	callq  *%rax
    }
    dhcp->pcb = NULL;
  80a387:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a38b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80a392:	00 
    mem_free((void *)dhcp);
  80a393:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a397:	48 89 c7             	mov    %rax,%rdi
  80a39a:	48 b8 6d c5 80 00 00 	movabs $0x80c56d,%rax
  80a3a1:	00 00 00 
  80a3a4:	ff d0                	callq  *%rax
    netif->dhcp = old_dhcp;
  80a3a6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80a3aa:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80a3ae:	48 89 50 38          	mov    %rdx,0x38(%rax)
  80a3b2:	eb 01                	jmp    80a3b5 <dhcp_inform+0x279>
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  80a3b4:	90                   	nop
    }
    dhcp->pcb = NULL;
    mem_free((void *)dhcp);
    netif->dhcp = old_dhcp;
  }
}
  80a3b5:	c9                   	leaveq 
  80a3b6:	c3                   	retq   

000000000080a3b7 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  80a3b7:	55                   	push   %rbp
  80a3b8:	48 89 e5             	mov    %rsp,%rbp
  80a3bb:	48 83 ec 10          	sub    $0x10,%rsp
  80a3bf:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80a3c3:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80a3c7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80a3cc:	75 2a                	jne    80a3f8 <dhcp_arp_reply+0x41>
  80a3ce:	48 ba e8 1a 82 00 00 	movabs $0x821ae8,%rdx
  80a3d5:	00 00 00 
  80a3d8:	be b6 02 00 00       	mov    $0x2b6,%esi
  80a3dd:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80a3e4:	00 00 00 
  80a3e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80a3ec:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80a3f3:	00 00 00 
  80a3f6:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  80a3f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3fc:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a400:	48 85 c0             	test   %rax,%rax
  80a403:	74 37                	je     80a43c <dhcp_arp_reply+0x85>
  80a405:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a409:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a40d:	0f b6 00             	movzbl (%rax),%eax
  80a410:	3c 08                	cmp    $0x8,%al
  80a412:	75 28                	jne    80a43c <dhcp_arp_reply+0x85>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  80a414:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a418:	8b 10                	mov    (%rax),%edx
  80a41a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a41e:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a422:	8b 40 4c             	mov    0x4c(%rax),%eax
  80a425:	39 c2                	cmp    %eax,%edx
  80a427:	75 13                	jne    80a43c <dhcp_arp_reply+0x85>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
  80a429:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a42d:	48 89 c7             	mov    %rax,%rdi
  80a430:	48 b8 3f a4 80 00 00 	movabs $0x80a43f,%rax
  80a437:	00 00 00 
  80a43a:	ff d0                	callq  *%rax
    }
  }
}
  80a43c:	90                   	nop
  80a43d:	c9                   	leaveq 
  80a43e:	c3                   	retq   

000000000080a43f <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
  80a43f:	55                   	push   %rbp
  80a440:	48 89 e5             	mov    %rsp,%rbp
  80a443:	48 83 ec 20          	sub    $0x20,%rsp
  80a447:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a44b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a44f:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a453:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  80a457:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  80a45b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a45f:	be 0c 00 00 00       	mov    $0xc,%esi
  80a464:	48 89 c7             	mov    %rax,%rdi
  80a467:	48 b8 1d b2 80 00 00 	movabs $0x80b21d,%rax
  80a46e:	00 00 00 
  80a471:	ff d0                	callq  *%rax
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a473:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a477:	48 89 c7             	mov    %rax,%rdi
  80a47a:	48 b8 2d ba 80 00 00 	movabs $0x80ba2d,%rax
  80a481:	00 00 00 
  80a484:	ff d0                	callq  *%rax
  80a486:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a489:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a48d:	0f 85 5c 01 00 00    	jne    80a5ef <dhcp_decline+0x1b0>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a493:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a497:	ba 01 00 00 00       	mov    $0x1,%edx
  80a49c:	be 35 00 00 00       	mov    $0x35,%esi
  80a4a1:	48 89 c7             	mov    %rax,%rdi
  80a4a4:	48 b8 4f b2 80 00 00 	movabs $0x80b24f,%rax
  80a4ab:	00 00 00 
  80a4ae:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  80a4b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a4b4:	be 04 00 00 00       	mov    $0x4,%esi
  80a4b9:	48 89 c7             	mov    %rax,%rdi
  80a4bc:	48 b8 01 b3 80 00 00 	movabs $0x80b301,%rax
  80a4c3:	00 00 00 
  80a4c6:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a4c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a4cc:	ba 02 00 00 00       	mov    $0x2,%edx
  80a4d1:	be 39 00 00 00       	mov    $0x39,%esi
  80a4d6:	48 89 c7             	mov    %rax,%rdi
  80a4d9:	48 b8 4f b2 80 00 00 	movabs $0x80b24f,%rax
  80a4e0:	00 00 00 
  80a4e3:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80a4e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a4e9:	be 40 02 00 00       	mov    $0x240,%esi
  80a4ee:	48 89 c7             	mov    %rax,%rdi
  80a4f1:	48 b8 78 b3 80 00 00 	movabs $0x80b378,%rax
  80a4f8:	00 00 00 
  80a4fb:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  80a4fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a501:	ba 04 00 00 00       	mov    $0x4,%edx
  80a506:	be 32 00 00 00       	mov    $0x32,%esi
  80a50b:	48 89 c7             	mov    %rax,%rdi
  80a50e:	48 b8 4f b2 80 00 00 	movabs $0x80b24f,%rax
  80a515:	00 00 00 
  80a518:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  80a51a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a51e:	8b 40 4c             	mov    0x4c(%rax),%eax
  80a521:	89 c7                	mov    %eax,%edi
  80a523:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  80a52a:	00 00 00 
  80a52d:	ff d0                	callq  *%rax
  80a52f:	89 c2                	mov    %eax,%edx
  80a531:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a535:	89 d6                	mov    %edx,%esi
  80a537:	48 89 c7             	mov    %rax,%rdi
  80a53a:	48 b8 24 b4 80 00 00 	movabs $0x80b424,%rax
  80a541:	00 00 00 
  80a544:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80a546:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a54a:	48 89 c7             	mov    %rax,%rdi
  80a54d:	48 b8 ac be 80 00 00 	movabs $0x80beac,%rax
  80a554:	00 00 00 
  80a557:	ff d0                	callq  *%rax
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a559:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a55d:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a561:	66 05 f0 00          	add    $0xf0,%ax
  80a565:	0f b7 d0             	movzwl %ax,%edx
  80a568:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a56c:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a570:	89 d6                	mov    %edx,%esi
  80a572:	48 89 c7             	mov    %rax,%rdi
  80a575:	48 b8 ba d9 80 00 00 	movabs $0x80d9ba,%rax
  80a57c:	00 00 00 
  80a57f:	ff d0                	callq  *%rax

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a581:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a585:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a589:	ba 43 00 00 00       	mov    $0x43,%edx
  80a58e:	48 be e8 28 82 00 00 	movabs $0x8228e8,%rsi
  80a595:	00 00 00 
  80a598:	48 89 c7             	mov    %rax,%rdi
  80a59b:	48 b8 bd 58 81 00 00 	movabs $0x8158bd,%rax
  80a5a2:	00 00 00 
  80a5a5:	ff d0                	callq  *%rax
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a5a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5ab:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a5af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5b3:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a5b7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a5bb:	49 89 d0             	mov    %rdx,%r8
  80a5be:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a5c3:	48 ba ec 28 82 00 00 	movabs $0x8228ec,%rdx
  80a5ca:	00 00 00 
  80a5cd:	48 89 c7             	mov    %rax,%rdi
  80a5d0:	48 b8 b3 54 81 00 00 	movabs $0x8154b3,%rax
  80a5d7:	00 00 00 
  80a5da:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80a5dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a5e0:	48 89 c7             	mov    %rax,%rdi
  80a5e3:	48 b8 85 bd 80 00 00 	movabs $0x80bd85,%rax
  80a5ea:	00 00 00 
  80a5ed:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a5ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5f3:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a5f7:	8d 50 01             	lea    0x1(%rax),%edx
  80a5fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5fe:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = 10*1000;
  80a601:	66 c7 45 f4 10 27    	movw   $0x2710,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a607:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a60b:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a611:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a616:	89 c8                	mov    %ecx,%eax
  80a618:	f7 ea                	imul   %edx
  80a61a:	c1 fa 05             	sar    $0x5,%edx
  80a61d:	89 c8                	mov    %ecx,%eax
  80a61f:	c1 f8 1f             	sar    $0x1f,%eax
  80a622:	29 c2                	sub    %eax,%edx
  80a624:	89 d0                	mov    %edx,%eax
  80a626:	89 c2                	mov    %eax,%edx
  80a628:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a62c:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80a630:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a634:	c9                   	leaveq 
  80a635:	c3                   	retq   

000000000080a636 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  80a636:	55                   	push   %rbp
  80a637:	48 89 e5             	mov    %rsp,%rbp
  80a63a:	48 83 ec 20          	sub    $0x20,%rsp
  80a63e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a642:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a646:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a64a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  80a64e:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  80a652:	48 b8 e8 28 82 00 00 	movabs $0x8228e8,%rax
  80a659:	00 00 00 
  80a65c:	8b 10                	mov    (%rax),%edx
  80a65e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a662:	89 50 4c             	mov    %edx,0x4c(%rax)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a665:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a669:	48 89 c7             	mov    %rax,%rdi
  80a66c:	48 b8 2d ba 80 00 00 	movabs $0x80ba2d,%rax
  80a673:	00 00 00 
  80a676:	ff d0                	callq  *%rax
  80a678:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a67b:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a67f:	0f 85 a8 01 00 00    	jne    80a82d <dhcp_discover+0x1f7>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a685:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a689:	ba 01 00 00 00       	mov    $0x1,%edx
  80a68e:	be 35 00 00 00       	mov    $0x35,%esi
  80a693:	48 89 c7             	mov    %rax,%rdi
  80a696:	48 b8 4f b2 80 00 00 	movabs $0x80b24f,%rax
  80a69d:	00 00 00 
  80a6a0:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  80a6a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6a6:	be 01 00 00 00       	mov    $0x1,%esi
  80a6ab:	48 89 c7             	mov    %rax,%rdi
  80a6ae:	48 b8 01 b3 80 00 00 	movabs $0x80b301,%rax
  80a6b5:	00 00 00 
  80a6b8:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a6ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6be:	ba 02 00 00 00       	mov    $0x2,%edx
  80a6c3:	be 39 00 00 00       	mov    $0x39,%esi
  80a6c8:	48 89 c7             	mov    %rax,%rdi
  80a6cb:	48 b8 4f b2 80 00 00 	movabs $0x80b24f,%rax
  80a6d2:	00 00 00 
  80a6d5:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80a6d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6db:	be 40 02 00 00       	mov    $0x240,%esi
  80a6e0:	48 89 c7             	mov    %rax,%rdi
  80a6e3:	48 b8 78 b3 80 00 00 	movabs $0x80b378,%rax
  80a6ea:	00 00 00 
  80a6ed:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  80a6ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6f3:	ba 04 00 00 00       	mov    $0x4,%edx
  80a6f8:	be 37 00 00 00       	mov    $0x37,%esi
  80a6fd:	48 89 c7             	mov    %rax,%rdi
  80a700:	48 b8 4f b2 80 00 00 	movabs $0x80b24f,%rax
  80a707:	00 00 00 
  80a70a:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  80a70c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a710:	be 01 00 00 00       	mov    $0x1,%esi
  80a715:	48 89 c7             	mov    %rax,%rdi
  80a718:	48 b8 01 b3 80 00 00 	movabs $0x80b301,%rax
  80a71f:	00 00 00 
  80a722:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80a724:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a728:	be 03 00 00 00       	mov    $0x3,%esi
  80a72d:	48 89 c7             	mov    %rax,%rdi
  80a730:	48 b8 01 b3 80 00 00 	movabs $0x80b301,%rax
  80a737:	00 00 00 
  80a73a:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  80a73c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a740:	be 1c 00 00 00       	mov    $0x1c,%esi
  80a745:	48 89 c7             	mov    %rax,%rdi
  80a748:	48 b8 01 b3 80 00 00 	movabs $0x80b301,%rax
  80a74f:	00 00 00 
  80a752:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  80a754:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a758:	be 06 00 00 00       	mov    $0x6,%esi
  80a75d:	48 89 c7             	mov    %rax,%rdi
  80a760:	48 b8 01 b3 80 00 00 	movabs $0x80b301,%rax
  80a767:	00 00 00 
  80a76a:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80a76c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a770:	48 89 c7             	mov    %rax,%rdi
  80a773:	48 b8 ac be 80 00 00 	movabs $0x80beac,%rax
  80a77a:	00 00 00 
  80a77d:	ff d0                	callq  *%rax

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a77f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a783:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a787:	66 05 f0 00          	add    $0xf0,%ax
  80a78b:	0f b7 d0             	movzwl %ax,%edx
  80a78e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a792:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a796:	89 d6                	mov    %edx,%esi
  80a798:	48 89 c7             	mov    %rax,%rdi
  80a79b:	48 b8 ba d9 80 00 00 	movabs $0x80d9ba,%rax
  80a7a2:	00 00 00 
  80a7a5:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a7a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7ab:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a7af:	ba 43 00 00 00       	mov    $0x43,%edx
  80a7b4:	48 be e8 28 82 00 00 	movabs $0x8228e8,%rsi
  80a7bb:	00 00 00 
  80a7be:	48 89 c7             	mov    %rax,%rdi
  80a7c1:	48 b8 bd 58 81 00 00 	movabs $0x8158bd,%rax
  80a7c8:	00 00 00 
  80a7cb:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a7cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7d1:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a7d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7d9:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a7dd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a7e1:	49 89 d0             	mov    %rdx,%r8
  80a7e4:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a7e9:	48 ba ec 28 82 00 00 	movabs $0x8228ec,%rdx
  80a7f0:	00 00 00 
  80a7f3:	48 89 c7             	mov    %rax,%rdi
  80a7f6:	48 b8 b3 54 81 00 00 	movabs $0x8154b3,%rax
  80a7fd:	00 00 00 
  80a800:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  80a802:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a806:	48 89 c7             	mov    %rax,%rdi
  80a809:	48 b8 85 bd 80 00 00 	movabs $0x80bd85,%rax
  80a810:	00 00 00 
  80a813:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  80a815:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a819:	be 06 00 00 00       	mov    $0x6,%esi
  80a81e:	48 89 c7             	mov    %rax,%rdi
  80a821:	48 b8 1d b2 80 00 00 	movabs $0x80b21d,%rax
  80a828:	00 00 00 
  80a82b:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a82d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a831:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a835:	8d 50 01             	lea    0x1(%rax),%edx
  80a838:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a83c:	88 50 01             	mov    %dl,0x1(%rax)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  80a83f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a843:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a847:	3c 03                	cmp    $0x3,%al
  80a849:	77 15                	ja     80a860 <dhcp_discover+0x22a>
  80a84b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a84f:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a853:	0f b6 c0             	movzbl %al,%eax
  80a856:	83 c0 01             	add    $0x1,%eax
  80a859:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80a85e:	eb 05                	jmp    80a865 <dhcp_discover+0x22f>
  80a860:	b8 10 27 00 00       	mov    $0x2710,%eax
  80a865:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a869:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a86d:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a873:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a878:	89 c8                	mov    %ecx,%eax
  80a87a:	f7 ea                	imul   %edx
  80a87c:	c1 fa 05             	sar    $0x5,%edx
  80a87f:	89 c8                	mov    %ecx,%eax
  80a881:	c1 f8 1f             	sar    $0x1f,%eax
  80a884:	29 c2                	sub    %eax,%edx
  80a886:	89 d0                	mov    %edx,%eax
  80a888:	89 c2                	mov    %eax,%edx
  80a88a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a88e:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80a892:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a896:	c9                   	leaveq 
  80a897:	c3                   	retq   

000000000080a898 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  80a898:	55                   	push   %rbp
  80a899:	48 89 e5             	mov    %rsp,%rbp
  80a89c:	48 83 ec 40          	sub    $0x40,%rsp
  80a8a0:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  80a8a4:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80a8a9:	75 2a                	jne    80a8d5 <dhcp_bind+0x3d>
  80a8ab:	48 ba 0b 1b 82 00 00 	movabs $0x821b0b,%rdx
  80a8b2:	00 00 00 
  80a8b5:	be 3e 03 00 00       	mov    $0x33e,%esi
  80a8ba:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80a8c1:	00 00 00 
  80a8c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80a8c9:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80a8d0:	00 00 00 
  80a8d3:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80a8d5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80a8d9:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a8dd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80a8e1:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80a8e6:	75 2a                	jne    80a912 <dhcp_bind+0x7a>
  80a8e8:	48 ba 24 1b 82 00 00 	movabs $0x821b24,%rdx
  80a8ef:	00 00 00 
  80a8f2:	be 40 03 00 00       	mov    $0x340,%esi
  80a8f7:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80a8fe:	00 00 00 
  80a901:	b8 00 00 00 00       	mov    $0x0,%eax
  80a906:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80a90d:	00 00 00 
  80a910:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  80a912:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a916:	8b 40 6c             	mov    0x6c(%rax),%eax
  80a919:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a91c:	74 4d                	je     80a96b <dhcp_bind+0xd3>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80a91e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a922:	8b 40 6c             	mov    0x6c(%rax),%eax
  80a925:	83 c0 1e             	add    $0x1e,%eax
  80a928:	ba 89 88 88 88       	mov    $0x88888889,%edx
  80a92d:	f7 e2                	mul    %edx
  80a92f:	89 d0                	mov    %edx,%eax
  80a931:	c1 e8 05             	shr    $0x5,%eax
  80a934:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if(timeout > 0xffff) {
  80a937:	81 7d fc ff ff 00 00 	cmpl   $0xffff,-0x4(%rbp)
  80a93e:	76 07                	jbe    80a947 <dhcp_bind+0xaf>
      timeout = 0xffff;
  80a940:	c7 45 fc ff ff 00 00 	movl   $0xffff,-0x4(%rbp)
    }
    dhcp->t1_timeout = (u16_t)timeout;
  80a947:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80a94a:	89 c2                	mov    %eax,%edx
  80a94c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a950:	66 89 50 44          	mov    %dx,0x44(%rax)
    if (dhcp->t1_timeout == 0) {
  80a954:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a958:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  80a95c:	66 85 c0             	test   %ax,%ax
  80a95f:	75 0a                	jne    80a96b <dhcp_bind+0xd3>
      dhcp->t1_timeout = 1;
  80a961:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a965:	66 c7 40 44 01 00    	movw   $0x1,0x44(%rax)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  80a96b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a96f:	8b 40 70             	mov    0x70(%rax),%eax
  80a972:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a975:	74 4d                	je     80a9c4 <dhcp_bind+0x12c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80a977:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a97b:	8b 40 70             	mov    0x70(%rax),%eax
  80a97e:	83 c0 1e             	add    $0x1e,%eax
  80a981:	ba 89 88 88 88       	mov    $0x88888889,%edx
  80a986:	f7 e2                	mul    %edx
  80a988:	89 d0                	mov    %edx,%eax
  80a98a:	c1 e8 05             	shr    $0x5,%eax
  80a98d:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if(timeout > 0xffff) {
  80a990:	81 7d fc ff ff 00 00 	cmpl   $0xffff,-0x4(%rbp)
  80a997:	76 07                	jbe    80a9a0 <dhcp_bind+0x108>
      timeout = 0xffff;
  80a999:	c7 45 fc ff ff 00 00 	movl   $0xffff,-0x4(%rbp)
    }
    dhcp->t2_timeout = (u16_t)timeout;
  80a9a0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80a9a3:	89 c2                	mov    %eax,%edx
  80a9a5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a9a9:	66 89 50 46          	mov    %dx,0x46(%rax)
    if (dhcp->t2_timeout == 0) {
  80a9ad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a9b1:	0f b7 40 46          	movzwl 0x46(%rax),%eax
  80a9b5:	66 85 c0             	test   %ax,%ax
  80a9b8:	75 0a                	jne    80a9c4 <dhcp_bind+0x12c>
      dhcp->t2_timeout = 1;
  80a9ba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a9be:	66 c7 40 46 01 00    	movw   $0x1,0x46(%rax)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80a9c4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a9c8:	48 83 c0 50          	add    $0x50,%rax
  80a9cc:	48 85 c0             	test   %rax,%rax
  80a9cf:	74 09                	je     80a9da <dhcp_bind+0x142>
  80a9d1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80a9d5:	8b 40 50             	mov    0x50(%rax),%eax
  80a9d8:	eb 05                	jmp    80a9df <dhcp_bind+0x147>
  80a9da:	b8 00 00 00 00       	mov    $0x0,%eax
  80a9df:	89 45 e0             	mov    %eax,-0x20(%rbp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  80a9e2:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80a9e5:	85 c0                	test   %eax,%eax
  80a9e7:	75 65                	jne    80aa4e <dhcp_bind+0x1b6>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  80a9e9:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80a9ec:	89 c7                	mov    %eax,%edi
  80a9ee:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  80a9f5:	00 00 00 
  80a9f8:	ff d0                	callq  *%rax
  80a9fa:	c1 e8 18             	shr    $0x18,%eax
  80a9fd:	88 45 ef             	mov    %al,-0x11(%rbp)
    if (first_octet <= 127) {
  80aa00:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80aa04:	84 c0                	test   %al,%al
  80aa06:	78 16                	js     80aa1e <dhcp_bind+0x186>
      sn_mask.addr = htonl(0xff000000);
  80aa08:	bf 00 00 00 ff       	mov    $0xff000000,%edi
  80aa0d:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  80aa14:	00 00 00 
  80aa17:	ff d0                	callq  *%rax
  80aa19:	89 45 e0             	mov    %eax,-0x20(%rbp)
  80aa1c:	eb 30                	jmp    80aa4e <dhcp_bind+0x1b6>
    } else if (first_octet >= 192) {
  80aa1e:	80 7d ef bf          	cmpb   $0xbf,-0x11(%rbp)
  80aa22:	76 16                	jbe    80aa3a <dhcp_bind+0x1a2>
      sn_mask.addr = htonl(0xffffff00);
  80aa24:	bf 00 ff ff ff       	mov    $0xffffff00,%edi
  80aa29:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  80aa30:	00 00 00 
  80aa33:	ff d0                	callq  *%rax
  80aa35:	89 45 e0             	mov    %eax,-0x20(%rbp)
  80aa38:	eb 14                	jmp    80aa4e <dhcp_bind+0x1b6>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  80aa3a:	bf 00 00 ff ff       	mov    $0xffff0000,%edi
  80aa3f:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  80aa46:	00 00 00 
  80aa49:	ff d0                	callq  *%rax
  80aa4b:	89 45 e0             	mov    %eax,-0x20(%rbp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  80aa4e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80aa52:	48 83 c0 54          	add    $0x54,%rax
  80aa56:	48 85 c0             	test   %rax,%rax
  80aa59:	74 09                	je     80aa64 <dhcp_bind+0x1cc>
  80aa5b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80aa5f:	8b 40 54             	mov    0x54(%rax),%eax
  80aa62:	eb 05                	jmp    80aa69 <dhcp_bind+0x1d1>
  80aa64:	b8 00 00 00 00       	mov    $0x0,%eax
  80aa69:	89 45 d0             	mov    %eax,-0x30(%rbp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  80aa6c:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80aa6f:	85 c0                	test   %eax,%eax
  80aa71:	75 2a                	jne    80aa9d <dhcp_bind+0x205>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  80aa73:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80aa77:	8b 50 4c             	mov    0x4c(%rax),%edx
  80aa7a:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80aa7d:	21 d0                	and    %edx,%eax
  80aa7f:	89 45 d0             	mov    %eax,-0x30(%rbp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  80aa82:	bf 01 00 00 00       	mov    $0x1,%edi
  80aa87:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  80aa8e:	00 00 00 
  80aa91:	ff d0                	callq  *%rax
  80aa93:	89 c2                	mov    %eax,%edx
  80aa95:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80aa98:	09 d0                	or     %edx,%eax
  80aa9a:	89 45 d0             	mov    %eax,-0x30(%rbp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  80aa9d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80aaa1:	48 8d 50 4c          	lea    0x4c(%rax),%rdx
  80aaa5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80aaa9:	48 89 d6             	mov    %rdx,%rsi
  80aaac:	48 89 c7             	mov    %rax,%rdi
  80aaaf:	48 b8 a4 d2 80 00 00 	movabs $0x80d2a4,%rax
  80aab6:	00 00 00 
  80aab9:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  80aabb:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  80aabf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80aac3:	48 89 d6             	mov    %rdx,%rsi
  80aac6:	48 89 c7             	mov    %rax,%rdi
  80aac9:	48 b8 d9 d3 80 00 00 	movabs $0x80d3d9,%rax
  80aad0:	00 00 00 
  80aad3:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  80aad5:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80aad9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80aadd:	48 89 d6             	mov    %rdx,%rsi
  80aae0:	48 89 c7             	mov    %rax,%rdi
  80aae3:	48 b8 ab d3 80 00 00 	movabs $0x80d3ab,%rax
  80aaea:	00 00 00 
  80aaed:	ff d0                	callq  *%rax
  /* bring the interface up */
  netif_set_up(netif);
  80aaef:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80aaf3:	48 89 c7             	mov    %rax,%rdi
  80aaf6:	48 b8 27 d4 80 00 00 	movabs $0x80d427,%rax
  80aafd:	00 00 00 
  80ab00:	ff d0                	callq  *%rax
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  80ab02:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ab06:	be 0a 00 00 00       	mov    $0xa,%esi
  80ab0b:	48 89 c7             	mov    %rax,%rdi
  80ab0e:	48 b8 1d b2 80 00 00 	movabs $0x80b21d,%rax
  80ab15:	00 00 00 
  80ab18:	ff d0                	callq  *%rax
}
  80ab1a:	90                   	nop
  80ab1b:	c9                   	leaveq 
  80ab1c:	c3                   	retq   

000000000080ab1d <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  80ab1d:	55                   	push   %rbp
  80ab1e:	48 89 e5             	mov    %rsp,%rbp
  80ab21:	48 83 ec 20          	sub    $0x20,%rsp
  80ab25:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80ab29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ab2d:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ab31:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  80ab35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab39:	be 05 00 00 00       	mov    $0x5,%esi
  80ab3e:	48 89 c7             	mov    %rax,%rdi
  80ab41:	48 b8 1d b2 80 00 00 	movabs $0x80b21d,%rax
  80ab48:	00 00 00 
  80ab4b:	ff d0                	callq  *%rax

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80ab4d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ab51:	48 89 c7             	mov    %rax,%rdi
  80ab54:	48 b8 2d ba 80 00 00 	movabs $0x80ba2d,%rax
  80ab5b:	00 00 00 
  80ab5e:	ff d0                	callq  *%rax
  80ab60:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80ab63:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80ab67:	0f 85 12 01 00 00    	jne    80ac7f <dhcp_renew+0x162>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80ab6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab71:	ba 01 00 00 00       	mov    $0x1,%edx
  80ab76:	be 35 00 00 00       	mov    $0x35,%esi
  80ab7b:	48 89 c7             	mov    %rax,%rdi
  80ab7e:	48 b8 4f b2 80 00 00 	movabs $0x80b24f,%rax
  80ab85:	00 00 00 
  80ab88:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80ab8a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab8e:	be 03 00 00 00       	mov    $0x3,%esi
  80ab93:	48 89 c7             	mov    %rax,%rdi
  80ab96:	48 b8 01 b3 80 00 00 	movabs $0x80b301,%rax
  80ab9d:	00 00 00 
  80aba0:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80aba2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aba6:	ba 02 00 00 00       	mov    $0x2,%edx
  80abab:	be 39 00 00 00       	mov    $0x39,%esi
  80abb0:	48 89 c7             	mov    %rax,%rdi
  80abb3:	48 b8 4f b2 80 00 00 	movabs $0x80b24f,%rax
  80abba:	00 00 00 
  80abbd:	ff d0                	callq  *%rax
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  80abbf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abc3:	be 40 02 00 00       	mov    $0x240,%esi
  80abc8:	48 89 c7             	mov    %rax,%rdi
  80abcb:	48 b8 78 b3 80 00 00 	movabs $0x80b378,%rax
  80abd2:	00 00 00 
  80abd5:	ff d0                	callq  *%rax
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  80abd7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abdb:	48 89 c7             	mov    %rax,%rdi
  80abde:	48 b8 ac be 80 00 00 	movabs $0x80beac,%rax
  80abe5:	00 00 00 
  80abe8:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80abea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abee:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80abf2:	66 05 f0 00          	add    $0xf0,%ax
  80abf6:	0f b7 d0             	movzwl %ax,%edx
  80abf9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abfd:	48 8b 40 30          	mov    0x30(%rax),%rax
  80ac01:	89 d6                	mov    %edx,%esi
  80ac03:	48 89 c7             	mov    %rax,%rdi
  80ac06:	48 b8 ba d9 80 00 00 	movabs $0x80d9ba,%rax
  80ac0d:	00 00 00 
  80ac10:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  80ac12:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac16:	48 8d 48 48          	lea    0x48(%rax),%rcx
  80ac1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac1e:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ac22:	ba 43 00 00 00       	mov    $0x43,%edx
  80ac27:	48 89 ce             	mov    %rcx,%rsi
  80ac2a:	48 89 c7             	mov    %rax,%rdi
  80ac2d:	48 b8 bd 58 81 00 00 	movabs $0x8158bd,%rax
  80ac34:	00 00 00 
  80ac37:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  80ac39:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac3d:	48 8d 50 48          	lea    0x48(%rax),%rdx
  80ac41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac45:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80ac49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac4d:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ac51:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80ac55:	49 89 c8             	mov    %rcx,%r8
  80ac58:	b9 43 00 00 00       	mov    $0x43,%ecx
  80ac5d:	48 89 c7             	mov    %rax,%rdi
  80ac60:	48 b8 b3 54 81 00 00 	movabs $0x8154b3,%rax
  80ac67:	00 00 00 
  80ac6a:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80ac6c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ac70:	48 89 c7             	mov    %rax,%rdi
  80ac73:	48 b8 85 bd 80 00 00 	movabs $0x80bd85,%rax
  80ac7a:	00 00 00 
  80ac7d:	ff d0                	callq  *%rax

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80ac7f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac83:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ac87:	8d 50 01             	lea    0x1(%rax),%edx
  80ac8a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac8e:	88 50 01             	mov    %dl,0x1(%rax)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  80ac91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac95:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ac99:	3c 09                	cmp    $0x9,%al
  80ac9b:	77 12                	ja     80acaf <dhcp_renew+0x192>
  80ac9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aca1:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80aca5:	0f b6 c0             	movzbl %al,%eax
  80aca8:	66 69 c0 d0 07       	imul   $0x7d0,%ax,%ax
  80acad:	eb 05                	jmp    80acb4 <dhcp_renew+0x197>
  80acaf:	b8 20 4e 00 00       	mov    $0x4e20,%eax
  80acb4:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80acb8:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80acbc:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80acc2:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80acc7:	89 c8                	mov    %ecx,%eax
  80acc9:	f7 ea                	imul   %edx
  80accb:	c1 fa 05             	sar    $0x5,%edx
  80acce:	89 c8                	mov    %ecx,%eax
  80acd0:	c1 f8 1f             	sar    $0x1f,%eax
  80acd3:	29 c2                	sub    %eax,%edx
  80acd5:	89 d0                	mov    %edx,%eax
  80acd7:	89 c2                	mov    %eax,%edx
  80acd9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80acdd:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80ace1:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80ace5:	c9                   	leaveq 
  80ace6:	c3                   	retq   

000000000080ace7 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  80ace7:	55                   	push   %rbp
  80ace8:	48 89 e5             	mov    %rsp,%rbp
  80aceb:	48 83 ec 20          	sub    $0x20,%rsp
  80acef:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80acf3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80acf7:	48 8b 40 38          	mov    0x38(%rax),%rax
  80acfb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  80acff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad03:	be 04 00 00 00       	mov    $0x4,%esi
  80ad08:	48 89 c7             	mov    %rax,%rdi
  80ad0b:	48 b8 1d b2 80 00 00 	movabs $0x80b21d,%rax
  80ad12:	00 00 00 
  80ad15:	ff d0                	callq  *%rax

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80ad17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ad1b:	48 89 c7             	mov    %rax,%rdi
  80ad1e:	48 b8 2d ba 80 00 00 	movabs $0x80ba2d,%rax
  80ad25:	00 00 00 
  80ad28:	ff d0                	callq  *%rax
  80ad2a:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80ad2d:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80ad31:	0f 85 13 01 00 00    	jne    80ae4a <dhcp_rebind+0x163>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80ad37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad3b:	ba 01 00 00 00       	mov    $0x1,%edx
  80ad40:	be 35 00 00 00       	mov    $0x35,%esi
  80ad45:	48 89 c7             	mov    %rax,%rdi
  80ad48:	48 b8 4f b2 80 00 00 	movabs $0x80b24f,%rax
  80ad4f:	00 00 00 
  80ad52:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80ad54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad58:	be 03 00 00 00       	mov    $0x3,%esi
  80ad5d:	48 89 c7             	mov    %rax,%rdi
  80ad60:	48 b8 01 b3 80 00 00 	movabs $0x80b301,%rax
  80ad67:	00 00 00 
  80ad6a:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80ad6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad70:	ba 02 00 00 00       	mov    $0x2,%edx
  80ad75:	be 39 00 00 00       	mov    $0x39,%esi
  80ad7a:	48 89 c7             	mov    %rax,%rdi
  80ad7d:	48 b8 4f b2 80 00 00 	movabs $0x80b24f,%rax
  80ad84:	00 00 00 
  80ad87:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80ad89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad8d:	be 40 02 00 00       	mov    $0x240,%esi
  80ad92:	48 89 c7             	mov    %rax,%rdi
  80ad95:	48 b8 78 b3 80 00 00 	movabs $0x80b378,%rax
  80ad9c:	00 00 00 
  80ad9f:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  80ada1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ada5:	48 89 c7             	mov    %rax,%rdi
  80ada8:	48 b8 ac be 80 00 00 	movabs $0x80beac,%rax
  80adaf:	00 00 00 
  80adb2:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80adb4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80adb8:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80adbc:	66 05 f0 00          	add    $0xf0,%ax
  80adc0:	0f b7 d0             	movzwl %ax,%edx
  80adc3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80adc7:	48 8b 40 30          	mov    0x30(%rax),%rax
  80adcb:	89 d6                	mov    %edx,%esi
  80adcd:	48 89 c7             	mov    %rax,%rdi
  80add0:	48 b8 ba d9 80 00 00 	movabs $0x80d9ba,%rax
  80add7:	00 00 00 
  80adda:	ff d0                	callq  *%rax

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80addc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ade0:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ade4:	ba 43 00 00 00       	mov    $0x43,%edx
  80ade9:	48 be e8 28 82 00 00 	movabs $0x8228e8,%rsi
  80adf0:	00 00 00 
  80adf3:	48 89 c7             	mov    %rax,%rdi
  80adf6:	48 b8 bd 58 81 00 00 	movabs $0x8158bd,%rax
  80adfd:	00 00 00 
  80ae00:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80ae02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae06:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80ae0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae0e:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ae12:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80ae16:	49 89 d0             	mov    %rdx,%r8
  80ae19:	b9 43 00 00 00       	mov    $0x43,%ecx
  80ae1e:	48 ba ec 28 82 00 00 	movabs $0x8228ec,%rdx
  80ae25:	00 00 00 
  80ae28:	48 89 c7             	mov    %rax,%rdi
  80ae2b:	48 b8 b3 54 81 00 00 	movabs $0x8154b3,%rax
  80ae32:	00 00 00 
  80ae35:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80ae37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ae3b:	48 89 c7             	mov    %rax,%rdi
  80ae3e:	48 b8 85 bd 80 00 00 	movabs $0x80bd85,%rax
  80ae45:	00 00 00 
  80ae48:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80ae4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae4e:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ae52:	8d 50 01             	lea    0x1(%rax),%edx
  80ae55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae59:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80ae5c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae60:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ae64:	3c 09                	cmp    $0x9,%al
  80ae66:	77 12                	ja     80ae7a <dhcp_rebind+0x193>
  80ae68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae6c:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ae70:	0f b6 c0             	movzbl %al,%eax
  80ae73:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80ae78:	eb 05                	jmp    80ae7f <dhcp_rebind+0x198>
  80ae7a:	b8 10 27 00 00       	mov    $0x2710,%eax
  80ae7f:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80ae83:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80ae87:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80ae8d:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80ae92:	89 c8                	mov    %ecx,%eax
  80ae94:	f7 ea                	imul   %edx
  80ae96:	c1 fa 05             	sar    $0x5,%edx
  80ae99:	89 c8                	mov    %ecx,%eax
  80ae9b:	c1 f8 1f             	sar    $0x1f,%eax
  80ae9e:	29 c2                	sub    %eax,%edx
  80aea0:	89 d0                	mov    %edx,%eax
  80aea2:	89 c2                	mov    %eax,%edx
  80aea4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aea8:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80aeac:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80aeb0:	c9                   	leaveq 
  80aeb1:	c3                   	retq   

000000000080aeb2 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  80aeb2:	55                   	push   %rbp
  80aeb3:	48 89 e5             	mov    %rsp,%rbp
  80aeb6:	48 83 ec 20          	sub    $0x20,%rsp
  80aeba:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80aebe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aec2:	48 8b 40 38          	mov    0x38(%rax),%rax
  80aec6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  80aeca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aece:	be 0d 00 00 00       	mov    $0xd,%esi
  80aed3:	48 89 c7             	mov    %rax,%rdi
  80aed6:	48 b8 1d b2 80 00 00 	movabs $0x80b21d,%rax
  80aedd:	00 00 00 
  80aee0:	ff d0                	callq  *%rax
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  80aee2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aee6:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%rax)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  80aeed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aef1:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%rax)
  80aef8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aefc:	8b 50 50             	mov    0x50(%rax),%edx
  80aeff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af03:	89 50 4c             	mov    %edx,0x4c(%rax)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  80af06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af0a:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%rax)
  80af11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af15:	8b 50 58             	mov    0x58(%rax),%edx
  80af18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af1c:	89 50 54             	mov    %edx,0x54(%rax)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  80af1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af23:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%rax)
  80af2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af2e:	8b 50 70             	mov    0x70(%rax),%edx
  80af31:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af35:	89 50 6c             	mov    %edx,0x6c(%rax)
  80af38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af3c:	8b 50 6c             	mov    0x6c(%rax),%edx
  80af3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af43:	89 50 68             	mov    %edx,0x68(%rax)
  dhcp->dns_count = 0;
  80af46:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af4a:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80af51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80af55:	48 89 c7             	mov    %rax,%rdi
  80af58:	48 b8 2d ba 80 00 00 	movabs $0x80ba2d,%rax
  80af5f:	00 00 00 
  80af62:	ff d0                	callq  *%rax
  80af64:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80af67:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80af6b:	0f 85 dd 00 00 00    	jne    80b04e <dhcp_release+0x19c>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80af71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af75:	ba 01 00 00 00       	mov    $0x1,%edx
  80af7a:	be 35 00 00 00       	mov    $0x35,%esi
  80af7f:	48 89 c7             	mov    %rax,%rdi
  80af82:	48 b8 4f b2 80 00 00 	movabs $0x80b24f,%rax
  80af89:	00 00 00 
  80af8c:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  80af8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af92:	be 07 00 00 00       	mov    $0x7,%esi
  80af97:	48 89 c7             	mov    %rax,%rdi
  80af9a:	48 b8 01 b3 80 00 00 	movabs $0x80b301,%rax
  80afa1:	00 00 00 
  80afa4:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80afa6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80afaa:	48 89 c7             	mov    %rax,%rdi
  80afad:	48 b8 ac be 80 00 00 	movabs $0x80beac,%rax
  80afb4:	00 00 00 
  80afb7:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80afb9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80afbd:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80afc1:	66 05 f0 00          	add    $0xf0,%ax
  80afc5:	0f b7 d0             	movzwl %ax,%edx
  80afc8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80afcc:	48 8b 40 30          	mov    0x30(%rax),%rax
  80afd0:	89 d6                	mov    %edx,%esi
  80afd2:	48 89 c7             	mov    %rax,%rdi
  80afd5:	48 b8 ba d9 80 00 00 	movabs $0x80d9ba,%rax
  80afdc:	00 00 00 
  80afdf:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  80afe1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80afe5:	48 8d 48 48          	lea    0x48(%rax),%rcx
  80afe9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80afed:	48 8b 40 08          	mov    0x8(%rax),%rax
  80aff1:	ba 43 00 00 00       	mov    $0x43,%edx
  80aff6:	48 89 ce             	mov    %rcx,%rsi
  80aff9:	48 89 c7             	mov    %rax,%rdi
  80affc:	48 b8 bd 58 81 00 00 	movabs $0x8158bd,%rax
  80b003:	00 00 00 
  80b006:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  80b008:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b00c:	48 8d 50 48          	lea    0x48(%rax),%rdx
  80b010:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b014:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80b018:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b01c:	48 8b 40 08          	mov    0x8(%rax),%rax
  80b020:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80b024:	49 89 c8             	mov    %rcx,%r8
  80b027:	b9 43 00 00 00       	mov    $0x43,%ecx
  80b02c:	48 89 c7             	mov    %rax,%rdi
  80b02f:	48 b8 b3 54 81 00 00 	movabs $0x8154b3,%rax
  80b036:	00 00 00 
  80b039:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80b03b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b03f:	48 89 c7             	mov    %rax,%rdi
  80b042:	48 b8 85 bd 80 00 00 	movabs $0x80bd85,%rax
  80b049:	00 00 00 
  80b04c:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80b04e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b052:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80b056:	8d 50 01             	lea    0x1(%rax),%edx
  80b059:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b05d:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80b060:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b064:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80b068:	3c 09                	cmp    $0x9,%al
  80b06a:	77 12                	ja     80b07e <dhcp_release+0x1cc>
  80b06c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b070:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80b074:	0f b6 c0             	movzbl %al,%eax
  80b077:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80b07c:	eb 05                	jmp    80b083 <dhcp_release+0x1d1>
  80b07e:	b8 10 27 00 00       	mov    $0x2710,%eax
  80b083:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80b087:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80b08b:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80b091:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80b096:	89 c8                	mov    %ecx,%eax
  80b098:	f7 ea                	imul   %edx
  80b09a:	c1 fa 05             	sar    $0x5,%edx
  80b09d:	89 c8                	mov    %ecx,%eax
  80b09f:	c1 f8 1f             	sar    $0x1f,%eax
  80b0a2:	29 c2                	sub    %eax,%edx
  80b0a4:	89 d0                	mov    %edx,%eax
  80b0a6:	89 c2                	mov    %eax,%edx
  80b0a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b0ac:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  80b0b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b0b4:	48 89 c7             	mov    %rax,%rdi
  80b0b7:	48 b8 91 d4 80 00 00 	movabs $0x80d491,%rax
  80b0be:	00 00 00 
  80b0c1:	ff d0                	callq  *%rax
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  80b0c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b0c7:	48 be e8 28 82 00 00 	movabs $0x8228e8,%rsi
  80b0ce:	00 00 00 
  80b0d1:	48 89 c7             	mov    %rax,%rdi
  80b0d4:	48 b8 a4 d2 80 00 00 	movabs $0x80d2a4,%rax
  80b0db:	00 00 00 
  80b0de:	ff d0                	callq  *%rax
  netif_set_gw(netif, IP_ADDR_ANY);
  80b0e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b0e4:	48 be e8 28 82 00 00 	movabs $0x8228e8,%rsi
  80b0eb:	00 00 00 
  80b0ee:	48 89 c7             	mov    %rax,%rdi
  80b0f1:	48 b8 ab d3 80 00 00 	movabs $0x80d3ab,%rax
  80b0f8:	00 00 00 
  80b0fb:	ff d0                	callq  *%rax
  netif_set_netmask(netif, IP_ADDR_ANY);
  80b0fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b101:	48 be e8 28 82 00 00 	movabs $0x8228e8,%rsi
  80b108:	00 00 00 
  80b10b:	48 89 c7             	mov    %rax,%rdi
  80b10e:	48 b8 d9 d3 80 00 00 	movabs $0x80d3d9,%rax
  80b115:	00 00 00 
  80b118:	ff d0                	callq  *%rax
  
  /* TODO: netif_down(netif); */
  return result;
  80b11a:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80b11e:	c9                   	leaveq 
  80b11f:	c3                   	retq   

000000000080b120 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  80b120:	55                   	push   %rbp
  80b121:	48 89 e5             	mov    %rsp,%rbp
  80b124:	48 83 ec 20          	sub    $0x20,%rsp
  80b128:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80b12c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b130:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b134:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  80b138:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80b13d:	75 2a                	jne    80b169 <dhcp_stop+0x49>
  80b13f:	48 ba 3c 1b 82 00 00 	movabs $0x821b3c,%rdx
  80b146:	00 00 00 
  80b149:	be 2d 04 00 00       	mov    $0x42d,%esi
  80b14e:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80b155:	00 00 00 
  80b158:	b8 00 00 00 00       	mov    $0x0,%eax
  80b15d:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80b164:	00 00 00 
  80b167:	ff d1                	callq  *%rcx
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  80b169:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b16d:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80b171:	83 e0 f7             	and    $0xfffffff7,%eax
  80b174:	89 c2                	mov    %eax,%edx
  80b176:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b17a:	88 50 4a             	mov    %dl,0x4a(%rax)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  80b17d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80b182:	0f 84 92 00 00 00    	je     80b21a <dhcp_stop+0xfa>
    if (dhcp->pcb != NULL) {
  80b188:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b18c:	48 8b 40 08          	mov    0x8(%rax),%rax
  80b190:	48 85 c0             	test   %rax,%rax
  80b193:	74 23                	je     80b1b8 <dhcp_stop+0x98>
      udp_remove(dhcp->pcb);
  80b195:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b199:	48 8b 40 08          	mov    0x8(%rax),%rax
  80b19d:	48 89 c7             	mov    %rax,%rdi
  80b1a0:	48 b8 25 5a 81 00 00 	movabs $0x815a25,%rax
  80b1a7:	00 00 00 
  80b1aa:	ff d0                	callq  *%rax
      dhcp->pcb = NULL;
  80b1ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1b0:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80b1b7:	00 
    }
    if (dhcp->p != NULL) {
  80b1b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1bc:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b1c0:	48 85 c0             	test   %rax,%rax
  80b1c3:	74 23                	je     80b1e8 <dhcp_stop+0xc8>
      pbuf_free(dhcp->p);
  80b1c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1c9:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b1cd:	48 89 c7             	mov    %rax,%rdi
  80b1d0:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  80b1d7:	00 00 00 
  80b1da:	ff d0                	callq  *%rax
      dhcp->p = NULL;
  80b1dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1e0:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80b1e7:	00 
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  80b1e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1ec:	48 89 c7             	mov    %rax,%rdi
  80b1ef:	48 b8 54 b7 80 00 00 	movabs $0x80b754,%rax
  80b1f6:	00 00 00 
  80b1f9:	ff d0                	callq  *%rax
    mem_free((void *)dhcp);
  80b1fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1ff:	48 89 c7             	mov    %rax,%rdi
  80b202:	48 b8 6d c5 80 00 00 	movabs $0x80c56d,%rax
  80b209:	00 00 00 
  80b20c:	ff d0                	callq  *%rax
    netif->dhcp = NULL;
  80b20e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b212:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80b219:	00 
  }
}
  80b21a:	90                   	nop
  80b21b:	c9                   	leaveq 
  80b21c:	c3                   	retq   

000000000080b21d <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  80b21d:	55                   	push   %rbp
  80b21e:	48 89 e5             	mov    %rsp,%rbp
  80b221:	48 83 ec 10          	sub    $0x10,%rsp
  80b225:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b229:	89 f0                	mov    %esi,%eax
  80b22b:	88 45 f4             	mov    %al,-0xc(%rbp)
  if (new_state != dhcp->state) {
  80b22e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b232:	0f b6 00             	movzbl (%rax),%eax
  80b235:	3a 45 f4             	cmp    -0xc(%rbp),%al
  80b238:	74 12                	je     80b24c <dhcp_set_state+0x2f>
    dhcp->state = new_state;
  80b23a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b23e:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  80b242:	88 10                	mov    %dl,(%rax)
    dhcp->tries = 0;
  80b244:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b248:	c6 40 01 00          	movb   $0x0,0x1(%rax)
  }
}
  80b24c:	90                   	nop
  80b24d:	c9                   	leaveq 
  80b24e:	c3                   	retq   

000000000080b24f <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  80b24f:	55                   	push   %rbp
  80b250:	48 89 e5             	mov    %rsp,%rbp
  80b253:	48 83 ec 10          	sub    $0x10,%rsp
  80b257:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b25b:	89 f1                	mov    %esi,%ecx
  80b25d:	89 d0                	mov    %edx,%eax
  80b25f:	88 4d f4             	mov    %cl,-0xc(%rbp)
  80b262:	88 45 f0             	mov    %al,-0x10(%rbp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  80b265:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b269:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b26d:	0f b7 d0             	movzwl %ax,%edx
  80b270:	0f b6 45 f0          	movzbl -0x10(%rbp),%eax
  80b274:	01 d0                	add    %edx,%eax
  80b276:	83 c0 02             	add    $0x2,%eax
  80b279:	83 f8 44             	cmp    $0x44,%eax
  80b27c:	76 2a                	jbe    80b2a8 <dhcp_option+0x59>
  80b27e:	48 ba 58 1b 82 00 00 	movabs $0x821b58,%rdx
  80b285:	00 00 00 
  80b288:	be 5b 04 00 00       	mov    $0x45b,%esi
  80b28d:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80b294:	00 00 00 
  80b297:	b8 00 00 00 00       	mov    $0x0,%eax
  80b29c:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80b2a3:	00 00 00 
  80b2a6:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  80b2a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b2ac:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b2b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b2b4:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b2b8:	8d 70 01             	lea    0x1(%rax),%esi
  80b2bb:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b2bf:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b2c3:	0f b7 c0             	movzwl %ax,%eax
  80b2c6:	48 98                	cltq   
  80b2c8:	0f b6 4d f4          	movzbl -0xc(%rbp),%ecx
  80b2cc:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  80b2d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b2d7:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b2db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b2df:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b2e3:	8d 70 01             	lea    0x1(%rax),%esi
  80b2e6:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b2ea:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b2ee:	0f b7 c0             	movzwl %ax,%eax
  80b2f1:	48 98                	cltq   
  80b2f3:	0f b6 4d f0          	movzbl -0x10(%rbp),%ecx
  80b2f7:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80b2fe:	90                   	nop
  80b2ff:	c9                   	leaveq 
  80b300:	c3                   	retq   

000000000080b301 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  80b301:	55                   	push   %rbp
  80b302:	48 89 e5             	mov    %rsp,%rbp
  80b305:	48 83 ec 10          	sub    $0x10,%rsp
  80b309:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b30d:	89 f0                	mov    %esi,%eax
  80b30f:	88 45 f4             	mov    %al,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80b312:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b316:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b31a:	66 83 f8 43          	cmp    $0x43,%ax
  80b31e:	76 2a                	jbe    80b34a <dhcp_option_byte+0x49>
  80b320:	48 ba a0 1b 82 00 00 	movabs $0x821ba0,%rdx
  80b327:	00 00 00 
  80b32a:	be 66 04 00 00       	mov    $0x466,%esi
  80b32f:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80b336:	00 00 00 
  80b339:	b8 00 00 00 00       	mov    $0x0,%eax
  80b33e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80b345:	00 00 00 
  80b348:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  80b34a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b34e:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b352:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b356:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b35a:	8d 70 01             	lea    0x1(%rax),%esi
  80b35d:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b361:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b365:	0f b7 c0             	movzwl %ax,%eax
  80b368:	48 98                	cltq   
  80b36a:	0f b6 4d f4          	movzbl -0xc(%rbp),%ecx
  80b36e:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80b375:	90                   	nop
  80b376:	c9                   	leaveq 
  80b377:	c3                   	retq   

000000000080b378 <dhcp_option_short>:

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  80b378:	55                   	push   %rbp
  80b379:	48 89 e5             	mov    %rsp,%rbp
  80b37c:	48 83 ec 10          	sub    $0x10,%rsp
  80b380:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b384:	89 f0                	mov    %esi,%eax
  80b386:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  80b38a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b38e:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b392:	0f b7 c0             	movzwl %ax,%eax
  80b395:	83 c0 02             	add    $0x2,%eax
  80b398:	83 f8 44             	cmp    $0x44,%eax
  80b39b:	76 2a                	jbe    80b3c7 <dhcp_option_short+0x4f>
  80b39d:	48 ba e0 1b 82 00 00 	movabs $0x821be0,%rdx
  80b3a4:	00 00 00 
  80b3a7:	be 6d 04 00 00       	mov    $0x46d,%esi
  80b3ac:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80b3b3:	00 00 00 
  80b3b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80b3bb:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80b3c2:	00 00 00 
  80b3c5:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  80b3c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b3cb:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b3cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b3d3:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b3d7:	8d 70 01             	lea    0x1(%rax),%esi
  80b3da:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b3de:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b3e2:	0f b7 c0             	movzwl %ax,%eax
  80b3e5:	0f b7 4d f4          	movzwl -0xc(%rbp),%ecx
  80b3e9:	66 c1 e9 08          	shr    $0x8,%cx
  80b3ed:	48 98                	cltq   
  80b3ef:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  80b3f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b3fa:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b3fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b402:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b406:	8d 70 01             	lea    0x1(%rax),%esi
  80b409:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b40d:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b411:	0f b7 c0             	movzwl %ax,%eax
  80b414:	0f b7 4d f4          	movzwl -0xc(%rbp),%ecx
  80b418:	48 98                	cltq   
  80b41a:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80b421:	90                   	nop
  80b422:	c9                   	leaveq 
  80b423:	c3                   	retq   

000000000080b424 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  80b424:	55                   	push   %rbp
  80b425:	48 89 e5             	mov    %rsp,%rbp
  80b428:	48 83 ec 10          	sub    $0x10,%rsp
  80b42c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80b430:	89 75 f4             	mov    %esi,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  80b433:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b437:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b43b:	0f b7 c0             	movzwl %ax,%eax
  80b43e:	83 c0 04             	add    $0x4,%eax
  80b441:	83 f8 44             	cmp    $0x44,%eax
  80b444:	76 2a                	jbe    80b470 <dhcp_option_long+0x4c>
  80b446:	48 ba 28 1c 82 00 00 	movabs $0x821c28,%rdx
  80b44d:	00 00 00 
  80b450:	be 75 04 00 00       	mov    $0x475,%esi
  80b455:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80b45c:	00 00 00 
  80b45f:	b8 00 00 00 00       	mov    $0x0,%eax
  80b464:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80b46b:	00 00 00 
  80b46e:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  80b470:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b474:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b478:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b47c:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b480:	8d 70 01             	lea    0x1(%rax),%esi
  80b483:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b487:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b48b:	0f b7 c0             	movzwl %ax,%eax
  80b48e:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b491:	c1 e9 18             	shr    $0x18,%ecx
  80b494:	48 98                	cltq   
  80b496:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  80b49d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b4a1:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b4a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b4a9:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b4ad:	8d 70 01             	lea    0x1(%rax),%esi
  80b4b0:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b4b4:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b4b8:	0f b7 c0             	movzwl %ax,%eax
  80b4bb:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b4be:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
  80b4c4:	48 c1 e9 10          	shr    $0x10,%rcx
  80b4c8:	48 98                	cltq   
  80b4ca:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  80b4d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b4d5:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b4d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b4dd:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b4e1:	8d 70 01             	lea    0x1(%rax),%esi
  80b4e4:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b4e8:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b4ec:	0f b7 c0             	movzwl %ax,%eax
  80b4ef:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b4f2:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  80b4f8:	48 c1 e9 08          	shr    $0x8,%rcx
  80b4fc:	48 98                	cltq   
  80b4fe:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  80b505:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b509:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b50d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b511:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b515:	8d 70 01             	lea    0x1(%rax),%esi
  80b518:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80b51c:	66 89 71 40          	mov    %si,0x40(%rcx)
  80b520:	0f b7 c0             	movzwl %ax,%eax
  80b523:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80b526:	48 98                	cltq   
  80b528:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
}
  80b52f:	90                   	nop
  80b530:	c9                   	leaveq 
  80b531:	c3                   	retq   

000000000080b532 <dhcp_unfold_reply>:
 * use that further on.
 *
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  80b532:	55                   	push   %rbp
  80b533:	48 89 e5             	mov    %rsp,%rbp
  80b536:	48 83 ec 20          	sub    $0x20,%rsp
  80b53a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  80b53e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80b543:	75 2a                	jne    80b56f <dhcp_unfold_reply+0x3d>
  80b545:	48 ba 68 1c 82 00 00 	movabs $0x821c68,%rdx
  80b54c:	00 00 00 
  80b54f:	be 8a 04 00 00       	mov    $0x48a,%esi
  80b554:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80b55b:	00 00 00 
  80b55e:	b8 00 00 00 00       	mov    $0x0,%eax
  80b563:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80b56a:	00 00 00 
  80b56d:	ff d1                	callq  *%rcx
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  80b56f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b573:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b577:	48 85 c0             	test   %rax,%rax
  80b57a:	75 2a                	jne    80b5a6 <dhcp_unfold_reply+0x74>
  80b57c:	48 ba 75 1c 82 00 00 	movabs $0x821c75,%rdx
  80b583:	00 00 00 
  80b586:	be 8b 04 00 00       	mov    $0x48b,%esi
  80b58b:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80b592:	00 00 00 
  80b595:	b8 00 00 00 00       	mov    $0x0,%eax
  80b59a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80b5a1:	00 00 00 
  80b5a4:	ff d1                	callq  *%rcx
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  80b5a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5aa:	48 89 c7             	mov    %rax,%rdi
  80b5ad:	48 b8 54 b7 80 00 00 	movabs $0x80b754,%rax
  80b5b4:	00 00 00 
  80b5b7:	ff d0                	callq  *%rax
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  80b5b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5bd:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b5c1:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80b5c5:	66 3d f0 00          	cmp    $0xf0,%ax
  80b5c9:	76 55                	jbe    80b620 <dhcp_unfold_reply+0xee>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b5cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5cf:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b5d3:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80b5d7:	8d 90 10 ff ff ff    	lea    -0xf0(%rax),%edx
  80b5dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5e1:	66 89 50 28          	mov    %dx,0x28(%rax)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  80b5e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5e9:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b5ed:	0f b7 c0             	movzwl %ax,%eax
  80b5f0:	89 c7                	mov    %eax,%edi
  80b5f2:	48 b8 10 ca 80 00 00 	movabs $0x80ca10,%rax
  80b5f9:	00 00 00 
  80b5fc:	ff d0                	callq  *%rax
  80b5fe:	48 89 c2             	mov    %rax,%rdx
  80b601:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b605:	48 89 50 20          	mov    %rdx,0x20(%rax)
    if (dhcp->options_in == NULL) {
  80b609:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b60d:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b611:	48 85 c0             	test   %rax,%rax
  80b614:	75 0a                	jne    80b620 <dhcp_unfold_reply+0xee>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
  80b616:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b61b:	e9 32 01 00 00       	jmpq   80b752 <dhcp_unfold_reply+0x220>
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b620:	bf f0 00 00 00       	mov    $0xf0,%edi
  80b625:	48 b8 10 ca 80 00 00 	movabs $0x80ca10,%rax
  80b62c:	00 00 00 
  80b62f:	ff d0                	callq  *%rax
  80b631:	48 89 c2             	mov    %rax,%rdx
  80b634:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b638:	48 89 50 18          	mov    %rdx,0x18(%rax)
  if (dhcp->msg_in == NULL) {
  80b63c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b640:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b644:	48 85 c0             	test   %rax,%rax
  80b647:	75 2d                	jne    80b676 <dhcp_unfold_reply+0x144>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  80b649:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b64d:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b651:	48 89 c7             	mov    %rax,%rdi
  80b654:	48 b8 6d c5 80 00 00 	movabs $0x80c56d,%rax
  80b65b:	00 00 00 
  80b65e:	ff d0                	callq  *%rax
    dhcp->options_in = NULL;
  80b660:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b664:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  80b66b:	00 
    return ERR_MEM;
  80b66c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b671:	e9 dc 00 00 00       	jmpq   80b752 <dhcp_unfold_reply+0x220>
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  80b676:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b67a:	48 8b 70 18          	mov    0x18(%rax),%rsi
  80b67e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b682:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b686:	b9 00 00 00 00       	mov    $0x0,%ecx
  80b68b:	ba f0 00 00 00       	mov    $0xf0,%edx
  80b690:	48 89 c7             	mov    %rax,%rdi
  80b693:	48 b8 d9 e4 80 00 00 	movabs $0x80e4d9,%rax
  80b69a:	00 00 00 
  80b69d:	ff d0                	callq  *%rax
  80b69f:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b6a3:	66 81 7d fe f0 00    	cmpw   $0xf0,-0x2(%rbp)
  80b6a9:	74 2a                	je     80b6d5 <dhcp_unfold_reply+0x1a3>
  80b6ab:	48 ba 88 1c 82 00 00 	movabs $0x821c88,%rdx
  80b6b2:	00 00 00 
  80b6b5:	be a1 04 00 00       	mov    $0x4a1,%esi
  80b6ba:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80b6c1:	00 00 00 
  80b6c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80b6c9:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80b6d0:	00 00 00 
  80b6d3:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  80b6d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b6d9:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b6dd:	48 85 c0             	test   %rax,%rax
  80b6e0:	74 6b                	je     80b74d <dhcp_unfold_reply+0x21b>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b6e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b6e6:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b6ea:	0f b7 d0             	movzwl %ax,%edx
  80b6ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b6f1:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80b6f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b6f9:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b6fd:	b9 f0 00 00 00       	mov    $0xf0,%ecx
  80b702:	48 89 c7             	mov    %rax,%rdi
  80b705:	48 b8 d9 e4 80 00 00 	movabs $0x80e4d9,%rax
  80b70c:	00 00 00 
  80b70f:	ff d0                	callq  *%rax
  80b711:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  80b715:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b719:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b71d:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80b721:	74 2a                	je     80b74d <dhcp_unfold_reply+0x21b>
  80b723:	48 ba ba 1c 82 00 00 	movabs $0x821cba,%rdx
  80b72a:	00 00 00 
  80b72d:	be a8 04 00 00       	mov    $0x4a8,%esi
  80b732:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80b739:	00 00 00 
  80b73c:	b8 00 00 00 00       	mov    $0x0,%eax
  80b741:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80b748:	00 00 00 
  80b74b:	ff d1                	callq  *%rcx
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes to dhcp->options_in[]\n",
      dhcp->options_in_len));
  }
  LWIP_UNUSED_ARG(ret);
  return ERR_OK;
  80b74d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b752:	c9                   	leaveq 
  80b753:	c3                   	retq   

000000000080b754 <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  80b754:	55                   	push   %rbp
  80b755:	48 89 e5             	mov    %rsp,%rbp
  80b758:	48 83 ec 10          	sub    $0x10,%rsp
  80b75c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (dhcp->msg_in != NULL) {
  80b760:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b764:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b768:	48 85 c0             	test   %rax,%rax
  80b76b:	74 23                	je     80b790 <dhcp_free_reply+0x3c>
    mem_free((void *)dhcp->msg_in);
  80b76d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b771:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b775:	48 89 c7             	mov    %rax,%rdi
  80b778:	48 b8 6d c5 80 00 00 	movabs $0x80c56d,%rax
  80b77f:	00 00 00 
  80b782:	ff d0                	callq  *%rax
    dhcp->msg_in = NULL;
  80b784:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b788:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  80b78f:	00 
  }
  if (dhcp->options_in) {
  80b790:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b794:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b798:	48 85 c0             	test   %rax,%rax
  80b79b:	74 2d                	je     80b7ca <dhcp_free_reply+0x76>
    mem_free((void *)dhcp->options_in);
  80b79d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b7a1:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b7a5:	48 89 c7             	mov    %rax,%rdi
  80b7a8:	48 b8 6d c5 80 00 00 	movabs $0x80c56d,%rax
  80b7af:	00 00 00 
  80b7b2:	ff d0                	callq  *%rax
    dhcp->options_in = NULL;
  80b7b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b7b8:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  80b7bf:	00 
    dhcp->options_in_len = 0;
  80b7c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b7c4:	66 c7 40 28 00 00    	movw   $0x0,0x28(%rax)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  80b7ca:	90                   	nop
  80b7cb:	c9                   	leaveq 
  80b7cc:	c3                   	retq   

000000000080b7cd <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  80b7cd:	55                   	push   %rbp
  80b7ce:	48 89 e5             	mov    %rsp,%rbp
  80b7d1:	48 83 ec 60          	sub    $0x60,%rsp
  80b7d5:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80b7d9:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80b7dd:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80b7e1:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80b7e5:	44 89 c0             	mov    %r8d,%eax
  80b7e8:	66 89 45 ac          	mov    %ax,-0x54(%rbp)
  struct netif *netif = (struct netif *)arg;
  80b7ec:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80b7f0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80b7f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b7f8:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b7fc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  80b800:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80b804:	48 8b 40 08          	mov    0x8(%rax),%rax
  80b808:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  80b80c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b810:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80b814:	48 89 50 10          	mov    %rdx,0x10(%rax)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  80b818:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b81c:	0f b6 00             	movzbl (%rax),%eax
  80b81f:	3c 02                	cmp    $0x2,%al
  80b821:	0f 85 d7 01 00 00    	jne    80b9fe <dhcp_recv+0x231>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80b827:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  80b82b:	eb 30                	jmp    80b85d <dhcp_recv+0x90>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  80b82d:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80b831:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80b835:	48 98                	cltq   
  80b837:	0f b6 4c 02 41       	movzbl 0x41(%rdx,%rax,1),%ecx
  80b83c:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80b840:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80b844:	48 98                	cltq   
  80b846:	0f b6 44 02 1c       	movzbl 0x1c(%rdx,%rax,1),%eax
  80b84b:	38 c1                	cmp    %al,%cl
  80b84d:	0f 85 ae 01 00 00    	jne    80ba01 <dhcp_recv+0x234>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80b853:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80b857:	83 c0 01             	add    $0x1,%eax
  80b85a:	88 45 ff             	mov    %al,-0x1(%rbp)
  80b85d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b861:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  80b865:	3a 45 ff             	cmp    -0x1(%rbp),%al
  80b868:	77 c3                	ja     80b82d <dhcp_recv+0x60>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  80b86a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b86e:	8b 40 04             	mov    0x4(%rax),%eax
  80b871:	89 c7                	mov    %eax,%edi
  80b873:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  80b87a:	00 00 00 
  80b87d:	ff d0                	callq  *%rax
  80b87f:	89 c2                	mov    %eax,%edx
  80b881:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b885:	8b 40 04             	mov    0x4(%rax),%eax
  80b888:	39 c2                	cmp    %eax,%edx
  80b88a:	0f 85 74 01 00 00    	jne    80ba04 <dhcp_recv+0x237>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  }
  /* option fields could be unfold? */
  if (dhcp_unfold_reply(dhcp) != ERR_OK) {
  80b890:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b894:	48 89 c7             	mov    %rax,%rdi
  80b897:	48 b8 32 b5 80 00 00 	movabs $0x80b532,%rax
  80b89e:	00 00 00 
  80b8a1:	ff d0                	callq  *%rax
  80b8a3:	84 c0                	test   %al,%al
  80b8a5:	0f 85 5c 01 00 00    	jne    80ba07 <dhcp_recv+0x23a>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  80b8ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b8af:	be 35 00 00 00       	mov    $0x35,%esi
  80b8b4:	48 89 c7             	mov    %rax,%rdi
  80b8b7:	48 b8 05 c0 80 00 00 	movabs $0x80c005,%rax
  80b8be:	00 00 00 
  80b8c1:	ff d0                	callq  *%rax
  80b8c3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (options_ptr == NULL) {
  80b8c7:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80b8cc:	0f 84 38 01 00 00    	je     80ba0a <dhcp_recv+0x23d>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  80b8d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b8d6:	48 83 c0 02          	add    $0x2,%rax
  80b8da:	48 89 c7             	mov    %rax,%rdi
  80b8dd:	48 b8 c7 c1 80 00 00 	movabs $0x80c1c7,%rax
  80b8e4:	00 00 00 
  80b8e7:	ff d0                	callq  *%rax
  80b8e9:	88 45 d7             	mov    %al,-0x29(%rbp)
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  80b8ec:	80 7d d7 05          	cmpb   $0x5,-0x29(%rbp)
  80b8f0:	0f 85 87 00 00 00    	jne    80b97d <dhcp_recv+0x1b0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  80b8f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b8fa:	0f b6 00             	movzbl (%rax),%eax
  80b8fd:	3c 01                	cmp    $0x1,%al
  80b8ff:	75 35                	jne    80b936 <dhcp_recv+0x169>
      dhcp_handle_ack(netif);
  80b901:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b905:	48 89 c7             	mov    %rax,%rdi
  80b908:	48 b8 5d 9c 80 00 00 	movabs $0x809c5d,%rax
  80b90f:	00 00 00 
  80b912:	ff d0                	callq  *%rax
      dhcp->request_timeout = 0;
  80b914:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b918:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  80b91e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b922:	48 89 c7             	mov    %rax,%rdi
  80b925:	48 b8 16 95 80 00 00 	movabs $0x809516,%rax
  80b92c:	00 00 00 
  80b92f:	ff d0                	callq  *%rax
  80b931:	e9 d5 00 00 00       	jmpq   80ba0b <dhcp_recv+0x23e>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  80b936:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b93a:	0f b6 00             	movzbl (%rax),%eax
  80b93d:	3c 03                	cmp    $0x3,%al
  80b93f:	74 1a                	je     80b95b <dhcp_recv+0x18e>
  80b941:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b945:	0f b6 00             	movzbl (%rax),%eax
  80b948:	3c 04                	cmp    $0x4,%al
  80b94a:	74 0f                	je     80b95b <dhcp_recv+0x18e>
  80b94c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b950:	0f b6 00             	movzbl (%rax),%eax
  80b953:	3c 05                	cmp    $0x5,%al
  80b955:	0f 85 b0 00 00 00    	jne    80ba0b <dhcp_recv+0x23e>
      dhcp->request_timeout = 0;
  80b95b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b95f:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
      dhcp_bind(netif);
  80b965:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b969:	48 89 c7             	mov    %rax,%rdi
  80b96c:	48 b8 98 a8 80 00 00 	movabs $0x80a898,%rax
  80b973:	00 00 00 
  80b976:	ff d0                	callq  *%rax
  80b978:	e9 8e 00 00 00       	jmpq   80ba0b <dhcp_recv+0x23e>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  80b97d:	80 7d d7 06          	cmpb   $0x6,-0x29(%rbp)
  80b981:	75 4b                	jne    80b9ce <dhcp_recv+0x201>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b983:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b987:	0f b6 00             	movzbl (%rax),%eax
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  80b98a:	3c 03                	cmp    $0x3,%al
  80b98c:	74 21                	je     80b9af <dhcp_recv+0x1e2>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b98e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b992:	0f b6 00             	movzbl (%rax),%eax
  80b995:	3c 01                	cmp    $0x1,%al
  80b997:	74 16                	je     80b9af <dhcp_recv+0x1e2>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  80b999:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b99d:	0f b6 00             	movzbl (%rax),%eax
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b9a0:	3c 04                	cmp    $0x4,%al
  80b9a2:	74 0b                	je     80b9af <dhcp_recv+0x1e2>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  80b9a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b9a8:	0f b6 00             	movzbl (%rax),%eax
  80b9ab:	3c 05                	cmp    $0x5,%al
  80b9ad:	75 1f                	jne    80b9ce <dhcp_recv+0x201>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  80b9af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b9b3:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
    dhcp_handle_nak(netif);
  80b9b9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b9bd:	48 89 c7             	mov    %rax,%rdi
  80b9c0:	48 b8 66 94 80 00 00 	movabs $0x809466,%rax
  80b9c7:	00 00 00 
  80b9ca:	ff d0                	callq  *%rax
  80b9cc:	eb 3d                	jmp    80ba0b <dhcp_recv+0x23e>
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  80b9ce:	80 7d d7 02          	cmpb   $0x2,-0x29(%rbp)
  80b9d2:	75 37                	jne    80ba0b <dhcp_recv+0x23e>
  80b9d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b9d8:	0f b6 00             	movzbl (%rax),%eax
  80b9db:	3c 06                	cmp    $0x6,%al
  80b9dd:	75 2c                	jne    80ba0b <dhcp_recv+0x23e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  80b9df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b9e3:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
    /* remember offered lease */
    dhcp_handle_offer(netif);
  80b9e9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b9ed:	48 89 c7             	mov    %rax,%rdi
  80b9f0:	48 b8 b0 95 80 00 00 	movabs $0x8095b0,%rax
  80b9f7:	00 00 00 
  80b9fa:	ff d0                	callq  *%rax
  80b9fc:	eb 0d                	jmp    80ba0b <dhcp_recv+0x23e>
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  80b9fe:	90                   	nop
  80b9ff:	eb 0a                	jmp    80ba0b <dhcp_recv+0x23e>
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("netif->hwaddr[%"U16_F"]==%02"X16_F" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
  80ba01:	90                   	nop
  80ba02:	eb 07                	jmp    80ba0b <dhcp_recv+0x23e>
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  80ba04:	90                   	nop
  80ba05:	eb 04                	jmp    80ba0b <dhcp_recv+0x23e>
  }
  /* option fields could be unfold? */
  if (dhcp_unfold_reply(dhcp) != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("problem unfolding DHCP message - too short on memory?\n"));
    goto free_pbuf_and_return;
  80ba07:	90                   	nop
  80ba08:	eb 01                	jmp    80ba0b <dhcp_recv+0x23e>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  if (options_ptr == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  80ba0a:	90                   	nop
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  80ba0b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ba0f:	48 89 c7             	mov    %rax,%rdi
  80ba12:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  80ba19:	00 00 00 
  80ba1c:	ff d0                	callq  *%rax
  dhcp->p = NULL;
  80ba1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ba22:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80ba29:	00 
}
  80ba2a:	90                   	nop
  80ba2b:	c9                   	leaveq 
  80ba2c:	c3                   	retq   

000000000080ba2d <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  80ba2d:	55                   	push   %rbp
  80ba2e:	48 89 e5             	mov    %rsp,%rbp
  80ba31:	53                   	push   %rbx
  80ba32:	48 83 ec 28          	sub    $0x28,%rsp
  80ba36:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  80ba3a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80ba3f:	75 2a                	jne    80ba6b <dhcp_create_request+0x3e>
  80ba41:	48 ba d8 1c 82 00 00 	movabs $0x821cd8,%rdx
  80ba48:	00 00 00 
  80ba4b:	be 2e 05 00 00       	mov    $0x52e,%esi
  80ba50:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80ba57:	00 00 00 
  80ba5a:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba5f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80ba66:	00 00 00 
  80ba69:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80ba6b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80ba6f:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ba73:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  80ba77:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80ba7c:	75 2a                	jne    80baa8 <dhcp_create_request+0x7b>
  80ba7e:	48 ba 00 1d 82 00 00 	movabs $0x821d00,%rdx
  80ba85:	00 00 00 
  80ba88:	be 30 05 00 00       	mov    $0x530,%esi
  80ba8d:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80ba94:	00 00 00 
  80ba97:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba9c:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80baa3:	00 00 00 
  80baa6:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  80baa8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80baac:	48 8b 40 30          	mov    0x30(%rax),%rax
  80bab0:	48 85 c0             	test   %rax,%rax
  80bab3:	74 2a                	je     80badf <dhcp_create_request+0xb2>
  80bab5:	48 ba 28 1d 82 00 00 	movabs $0x821d28,%rdx
  80babc:	00 00 00 
  80babf:	be 31 05 00 00       	mov    $0x531,%esi
  80bac4:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80bacb:	00 00 00 
  80bace:	b8 00 00 00 00       	mov    $0x0,%eax
  80bad3:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80bada:	00 00 00 
  80badd:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  80badf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bae3:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bae7:	48 85 c0             	test   %rax,%rax
  80baea:	74 2a                	je     80bb16 <dhcp_create_request+0xe9>
  80baec:	48 ba 58 1d 82 00 00 	movabs $0x821d58,%rdx
  80baf3:	00 00 00 
  80baf6:	be 32 05 00 00       	mov    $0x532,%esi
  80bafb:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80bb02:	00 00 00 
  80bb05:	b8 00 00 00 00       	mov    $0x0,%eax
  80bb0a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80bb11:	00 00 00 
  80bb14:	ff d1                	callq  *%rcx
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  80bb16:	ba 00 00 00 00       	mov    $0x0,%edx
  80bb1b:	be 34 01 00 00       	mov    $0x134,%esi
  80bb20:	bf 00 00 00 00       	mov    $0x0,%edi
  80bb25:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  80bb2c:	00 00 00 
  80bb2f:	ff d0                	callq  *%rax
  80bb31:	48 89 c2             	mov    %rax,%rdx
  80bb34:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb38:	48 89 50 30          	mov    %rdx,0x30(%rax)
  if (dhcp->p_out == NULL) {
  80bb3c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb40:	48 8b 40 30          	mov    0x30(%rax),%rax
  80bb44:	48 85 c0             	test   %rax,%rax
  80bb47:	75 0a                	jne    80bb53 <dhcp_create_request+0x126>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  80bb49:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bb4e:	e9 2b 02 00 00       	jmpq   80bd7e <dhcp_create_request+0x351>
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  80bb53:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bb57:	48 8b 40 30          	mov    0x30(%rax),%rax
  80bb5b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80bb5f:	66 3d 33 01          	cmp    $0x133,%ax
  80bb63:	77 2a                	ja     80bb8f <dhcp_create_request+0x162>
  80bb65:	48 ba 88 1d 82 00 00 	movabs $0x821d88,%rdx
  80bb6c:	00 00 00 
  80bb6f:	be 39 05 00 00       	mov    $0x539,%esi
  80bb74:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80bb7b:	00 00 00 
  80bb7e:	b8 00 00 00 00       	mov    $0x0,%eax
  80bb83:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80bb8a:	00 00 00 
  80bb8d:	ff d1                	callq  *%rcx
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  80bb8f:	48 b8 7c 81 82 00 00 	movabs $0x82817c,%rax
  80bb96:	00 00 00 
  80bb99:	8b 00                	mov    (%rax),%eax
  80bb9b:	8d 48 01             	lea    0x1(%rax),%ecx
  80bb9e:	48 ba 7c 81 82 00 00 	movabs $0x82817c,%rdx
  80bba5:	00 00 00 
  80bba8:	89 0a                	mov    %ecx,(%rdx)
  80bbaa:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80bbae:	89 42 04             	mov    %eax,0x4(%rdx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  80bbb1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbb5:	48 8b 40 30          	mov    0x30(%rax),%rax
  80bbb9:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80bbbd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbc1:	48 89 50 38          	mov    %rdx,0x38(%rax)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  80bbc5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbc9:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bbcd:	c6 00 01             	movb   $0x1,(%rax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  80bbd0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbd4:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bbd8:	c6 40 01 01          	movb   $0x1,0x1(%rax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  80bbdc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbe0:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bbe4:	c6 40 02 06          	movb   $0x6,0x2(%rax)
  dhcp->msg_out->hops = 0;
  80bbe8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbec:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bbf0:	c6 40 03 00          	movb   $0x0,0x3(%rax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  80bbf4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bbf8:	48 8b 58 38          	mov    0x38(%rax),%rbx
  80bbfc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bc00:	8b 40 04             	mov    0x4(%rax),%eax
  80bc03:	89 c7                	mov    %eax,%edi
  80bc05:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  80bc0c:	00 00 00 
  80bc0f:	ff d0                	callq  *%rax
  80bc11:	89 43 04             	mov    %eax,0x4(%rbx)
  dhcp->msg_out->secs = 0;
  80bc14:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bc18:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bc1c:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
  dhcp->msg_out->flags = 0;
  80bc22:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bc26:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bc2a:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  80bc30:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bc34:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bc38:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80bc3c:	8b 52 08             	mov    0x8(%rdx),%edx
  80bc3f:	89 50 0c             	mov    %edx,0xc(%rax)
  dhcp->msg_out->yiaddr.addr = 0;
  80bc42:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bc46:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bc4a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
  dhcp->msg_out->siaddr.addr = 0;
  80bc51:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bc55:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bc59:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%rax)
  dhcp->msg_out->giaddr.addr = 0;
  80bc60:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bc64:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bc68:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  80bc6f:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80bc75:	eb 45                	jmp    80bcbc <dhcp_create_request+0x28f>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  80bc77:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bc7b:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80bc7f:	0f b7 75 ee          	movzwl -0x12(%rbp),%esi
  80bc83:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bc87:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  80bc8b:	0f b6 c0             	movzbl %al,%eax
  80bc8e:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80bc92:	76 11                	jbe    80bca5 <dhcp_create_request+0x278>
  80bc94:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bc98:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80bc9c:	48 98                	cltq   
  80bc9e:	0f b6 44 02 41       	movzbl 0x41(%rdx,%rax,1),%eax
  80bca3:	eb 05                	jmp    80bcaa <dhcp_create_request+0x27d>
  80bca5:	b8 00 00 00 00       	mov    $0x0,%eax
  80bcaa:	48 63 d6             	movslq %esi,%rdx
  80bcad:	88 44 11 1c          	mov    %al,0x1c(%rcx,%rdx,1)
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  80bcb1:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bcb5:	83 c0 01             	add    $0x1,%eax
  80bcb8:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80bcbc:	66 83 7d ee 0f       	cmpw   $0xf,-0x12(%rbp)
  80bcc1:	76 b4                	jbe    80bc77 <dhcp_create_request+0x24a>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80bcc3:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80bcc9:	eb 1e                	jmp    80bce9 <dhcp_create_request+0x2bc>
    dhcp->msg_out->sname[i] = 0;
  80bccb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bccf:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bcd3:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bcd7:	48 98                	cltq   
  80bcd9:	c6 44 02 2c 00       	movb   $0x0,0x2c(%rdx,%rax,1)
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80bcde:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bce2:	83 c0 01             	add    $0x1,%eax
  80bce5:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80bce9:	66 83 7d ee 3f       	cmpw   $0x3f,-0x12(%rbp)
  80bcee:	76 db                	jbe    80bccb <dhcp_create_request+0x29e>
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80bcf0:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80bcf6:	eb 1e                	jmp    80bd16 <dhcp_create_request+0x2e9>
    dhcp->msg_out->file[i] = 0;
  80bcf8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bcfc:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bd00:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bd04:	48 98                	cltq   
  80bd06:	c6 44 02 6c 00       	movb   $0x0,0x6c(%rdx,%rax,1)
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80bd0b:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bd0f:	83 c0 01             	add    $0x1,%eax
  80bd12:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80bd16:	66 83 7d ee 7f       	cmpw   $0x7f,-0x12(%rbp)
  80bd1b:	76 db                	jbe    80bcf8 <dhcp_create_request+0x2cb>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  80bd1d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bd21:	48 8b 58 38          	mov    0x38(%rax),%rbx
  80bd25:	bf 63 53 82 63       	mov    $0x63825363,%edi
  80bd2a:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  80bd31:	00 00 00 
  80bd34:	ff d0                	callq  *%rax
  80bd36:	89 83 ec 00 00 00    	mov    %eax,0xec(%rbx)
  dhcp->options_out_len = 0;
  80bd3c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bd40:	66 c7 40 40 00 00    	movw   $0x0,0x40(%rax)
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  80bd46:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80bd4c:	eb 24                	jmp    80bd72 <dhcp_create_request+0x345>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  80bd4e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bd52:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bd56:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bd5a:	0f b7 4d ee          	movzwl -0x12(%rbp),%ecx
  80bd5e:	48 98                	cltq   
  80bd60:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  80bd67:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bd6b:	83 c0 01             	add    $0x1,%eax
  80bd6e:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  80bd72:	66 83 7d ee 43       	cmpw   $0x43,-0x12(%rbp)
  80bd77:	76 d5                	jbe    80bd4e <dhcp_create_request+0x321>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
  80bd79:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80bd7e:	48 83 c4 28          	add    $0x28,%rsp
  80bd82:	5b                   	pop    %rbx
  80bd83:	5d                   	pop    %rbp
  80bd84:	c3                   	retq   

000000000080bd85 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  80bd85:	55                   	push   %rbp
  80bd86:	48 89 e5             	mov    %rsp,%rbp
  80bd89:	48 83 ec 20          	sub    $0x20,%rsp
  80bd8d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  80bd91:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80bd96:	75 2a                	jne    80bdc2 <dhcp_delete_request+0x3d>
  80bd98:	48 ba d0 1d 82 00 00 	movabs $0x821dd0,%rdx
  80bd9f:	00 00 00 
  80bda2:	be 6a 05 00 00       	mov    $0x56a,%esi
  80bda7:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80bdae:	00 00 00 
  80bdb1:	b8 00 00 00 00       	mov    $0x0,%eax
  80bdb6:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80bdbd:	00 00 00 
  80bdc0:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80bdc2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bdc6:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bdca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  80bdce:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80bdd3:	75 2a                	jne    80bdff <dhcp_delete_request+0x7a>
  80bdd5:	48 ba f8 1d 82 00 00 	movabs $0x821df8,%rdx
  80bddc:	00 00 00 
  80bddf:	be 6c 05 00 00       	mov    $0x56c,%esi
  80bde4:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80bdeb:	00 00 00 
  80bdee:	b8 00 00 00 00       	mov    $0x0,%eax
  80bdf3:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80bdfa:	00 00 00 
  80bdfd:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  80bdff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be03:	48 8b 40 30          	mov    0x30(%rax),%rax
  80be07:	48 85 c0             	test   %rax,%rax
  80be0a:	75 2a                	jne    80be36 <dhcp_delete_request+0xb1>
  80be0c:	48 ba 20 1e 82 00 00 	movabs $0x821e20,%rdx
  80be13:	00 00 00 
  80be16:	be 6d 05 00 00       	mov    $0x56d,%esi
  80be1b:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80be22:	00 00 00 
  80be25:	b8 00 00 00 00       	mov    $0x0,%eax
  80be2a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80be31:	00 00 00 
  80be34:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  80be36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be3a:	48 8b 40 38          	mov    0x38(%rax),%rax
  80be3e:	48 85 c0             	test   %rax,%rax
  80be41:	75 2a                	jne    80be6d <dhcp_delete_request+0xe8>
  80be43:	48 ba 50 1e 82 00 00 	movabs $0x821e50,%rdx
  80be4a:	00 00 00 
  80be4d:	be 6e 05 00 00       	mov    $0x56e,%esi
  80be52:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80be59:	00 00 00 
  80be5c:	b8 00 00 00 00       	mov    $0x0,%eax
  80be61:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80be68:	00 00 00 
  80be6b:	ff d1                	callq  *%rcx
  if (dhcp->p_out != NULL) {
  80be6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be71:	48 8b 40 30          	mov    0x30(%rax),%rax
  80be75:	48 85 c0             	test   %rax,%rax
  80be78:	74 17                	je     80be91 <dhcp_delete_request+0x10c>
    pbuf_free(dhcp->p_out);
  80be7a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be7e:	48 8b 40 30          	mov    0x30(%rax),%rax
  80be82:	48 89 c7             	mov    %rax,%rdi
  80be85:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  80be8c:	00 00 00 
  80be8f:	ff d0                	callq  *%rax
  }
  dhcp->p_out = NULL;
  80be91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be95:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  80be9c:	00 
  dhcp->msg_out = NULL;
  80be9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bea1:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80bea8:	00 
}
  80bea9:	90                   	nop
  80beaa:	c9                   	leaveq 
  80beab:	c3                   	retq   

000000000080beac <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  80beac:	55                   	push   %rbp
  80bead:	48 89 e5             	mov    %rsp,%rbp
  80beb0:	48 83 ec 10          	sub    $0x10,%rsp
  80beb4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  80beb8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80bebd:	75 2a                	jne    80bee9 <dhcp_option_trailer+0x3d>
  80bebf:	48 ba 80 1e 82 00 00 	movabs $0x821e80,%rdx
  80bec6:	00 00 00 
  80bec9:	be 81 05 00 00       	mov    $0x581,%esi
  80bece:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80bed5:	00 00 00 
  80bed8:	b8 00 00 00 00       	mov    $0x0,%eax
  80bedd:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80bee4:	00 00 00 
  80bee7:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  80bee9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80beed:	48 8b 40 38          	mov    0x38(%rax),%rax
  80bef1:	48 85 c0             	test   %rax,%rax
  80bef4:	75 2a                	jne    80bf20 <dhcp_option_trailer+0x74>
  80bef6:	48 ba a8 1e 82 00 00 	movabs $0x821ea8,%rdx
  80befd:	00 00 00 
  80bf00:	be 82 05 00 00       	mov    $0x582,%esi
  80bf05:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80bf0c:	00 00 00 
  80bf0f:	b8 00 00 00 00       	mov    $0x0,%eax
  80bf14:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80bf1b:	00 00 00 
  80bf1e:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80bf20:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bf24:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bf28:	66 83 f8 43          	cmp    $0x43,%ax
  80bf2c:	76 2a                	jbe    80bf58 <dhcp_option_trailer+0xac>
  80bf2e:	48 ba d8 1e 82 00 00 	movabs $0x821ed8,%rdx
  80bf35:	00 00 00 
  80bf38:	be 83 05 00 00       	mov    $0x583,%esi
  80bf3d:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80bf44:	00 00 00 
  80bf47:	b8 00 00 00 00       	mov    $0x0,%eax
  80bf4c:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80bf53:	00 00 00 
  80bf56:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  80bf58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bf5c:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bf60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bf64:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bf68:	8d 70 01             	lea    0x1(%rax),%esi
  80bf6b:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80bf6f:	66 89 71 40          	mov    %si,0x40(%rcx)
  80bf73:	0f b7 c0             	movzwl %ax,%eax
  80bf76:	48 98                	cltq   
  80bf78:	c6 84 02 f0 00 00 00 	movb   $0xff,0xf0(%rdx,%rax,1)
  80bf7f:	ff 
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  80bf80:	eb 60                	jmp    80bfe2 <dhcp_option_trailer+0x136>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80bf82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bf86:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bf8a:	66 83 f8 43          	cmp    $0x43,%ax
  80bf8e:	76 2a                	jbe    80bfba <dhcp_option_trailer+0x10e>
  80bf90:	48 ba d8 1e 82 00 00 	movabs $0x821ed8,%rdx
  80bf97:	00 00 00 
  80bf9a:	be 88 05 00 00       	mov    $0x588,%esi
  80bf9f:	48 bf f6 1a 82 00 00 	movabs $0x821af6,%rdi
  80bfa6:	00 00 00 
  80bfa9:	b8 00 00 00 00       	mov    $0x0,%eax
  80bfae:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80bfb5:	00 00 00 
  80bfb8:	ff d1                	callq  *%rcx
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  80bfba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bfbe:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80bfc2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bfc6:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bfca:	8d 70 01             	lea    0x1(%rax),%esi
  80bfcd:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80bfd1:	66 89 71 40          	mov    %si,0x40(%rcx)
  80bfd5:	0f b7 c0             	movzwl %ax,%eax
  80bfd8:	48 98                	cltq   
  80bfda:	c6 84 02 f0 00 00 00 	movb   $0x0,0xf0(%rdx,%rax,1)
  80bfe1:	00 
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  80bfe2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bfe6:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bfea:	66 83 f8 43          	cmp    $0x43,%ax
  80bfee:	76 92                	jbe    80bf82 <dhcp_option_trailer+0xd6>
  80bff0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bff4:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bff8:	0f b7 c0             	movzwl %ax,%eax
  80bffb:	83 e0 03             	and    $0x3,%eax
  80bffe:	85 c0                	test   %eax,%eax
  80c000:	75 80                	jne    80bf82 <dhcp_option_trailer+0xd6>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  80c002:	90                   	nop
  80c003:	c9                   	leaveq 
  80c004:	c3                   	retq   

000000000080c005 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  80c005:	55                   	push   %rbp
  80c006:	48 89 e5             	mov    %rsp,%rbp
  80c009:	48 83 ec 30          	sub    $0x30,%rsp
  80c00d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80c011:	89 f0                	mov    %esi,%eax
  80c013:	88 45 d4             	mov    %al,-0x2c(%rbp)
  u8_t overload = DHCP_OVERLOAD_NONE;
  80c016:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80c01a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c01e:	48 8b 40 20          	mov    0x20(%rax),%rax
  80c022:	48 85 c0             	test   %rax,%rax
  80c025:	0f 84 95 01 00 00    	je     80c1c0 <dhcp_get_option_ptr+0x1bb>
  80c02b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c02f:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80c033:	66 85 c0             	test   %ax,%ax
  80c036:	0f 84 84 01 00 00    	je     80c1c0 <dhcp_get_option_ptr+0x1bb>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
  80c03c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c040:	48 8b 40 20          	mov    0x20(%rax),%rax
  80c044:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    u16_t offset = 0;
  80c048:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80c04e:	e9 80 00 00 00       	jmpq   80c0d3 <dhcp_get_option_ptr+0xce>
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  80c053:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c057:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c05b:	48 01 d0             	add    %rdx,%rax
  80c05e:	0f b6 00             	movzbl (%rax),%eax
  80c061:	3c 34                	cmp    $0x34,%al
  80c063:	75 22                	jne    80c087 <dhcp_get_option_ptr+0x82>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  80c065:	66 83 45 ee 02       	addw   $0x2,-0x12(%rbp)
        overload = options[offset++];
  80c06a:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c06e:	8d 50 01             	lea    0x1(%rax),%edx
  80c071:	66 89 55 ee          	mov    %dx,-0x12(%rbp)
  80c075:	0f b7 d0             	movzwl %ax,%edx
  80c078:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c07c:	48 01 d0             	add    %rdx,%rax
  80c07f:	0f b6 00             	movzbl (%rax),%eax
  80c082:	88 45 ff             	mov    %al,-0x1(%rbp)
  80c085:	eb 4c                	jmp    80c0d3 <dhcp_get_option_ptr+0xce>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  80c087:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c08b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c08f:	48 01 d0             	add    %rdx,%rax
  80c092:	0f b6 00             	movzbl (%rax),%eax
  80c095:	3a 45 d4             	cmp    -0x2c(%rbp),%al
  80c098:	75 10                	jne    80c0aa <dhcp_get_option_ptr+0xa5>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset %"U16_F" in options\n", offset));
        return &options[offset];
  80c09a:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c09e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c0a2:	48 01 d0             	add    %rdx,%rax
  80c0a5:	e9 1b 01 00 00       	jmpq   80c1c5 <dhcp_get_option_ptr+0x1c0>
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  80c0aa:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c0ae:	83 c0 01             	add    $0x1,%eax
  80c0b1:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  80c0b5:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c0b9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c0bd:	48 01 d0             	add    %rdx,%rax
  80c0c0:	0f b6 00             	movzbl (%rax),%eax
  80c0c3:	0f b6 d0             	movzbl %al,%edx
  80c0c6:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c0ca:	01 d0                	add    %edx,%eax
  80c0cc:	83 c0 01             	add    $0x1,%eax
  80c0cf:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80c0d3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c0d7:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80c0db:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80c0df:	76 16                	jbe    80c0f7 <dhcp_get_option_ptr+0xf2>
  80c0e1:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c0e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c0e9:	48 01 d0             	add    %rdx,%rax
  80c0ec:	0f b6 00             	movzbl (%rax),%eax
  80c0ef:	3c ff                	cmp    $0xff,%al
  80c0f1:	0f 85 5c ff ff ff    	jne    80c053 <dhcp_get_option_ptr+0x4e>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  80c0f7:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80c0fb:	0f 84 bf 00 00 00    	je     80c1c0 <dhcp_get_option_ptr+0x1bb>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  80c101:	80 7d ff 01          	cmpb   $0x1,-0x1(%rbp)
  80c105:	75 18                	jne    80c11f <dhcp_get_option_ptr+0x11a>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  80c107:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c10b:	48 8b 40 18          	mov    0x18(%rax),%rax
  80c10f:	48 83 c0 6c          	add    $0x6c,%rax
  80c113:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_FILE_LEN;
  80c117:	66 c7 45 ec 80 00    	movw   $0x80,-0x14(%rbp)
  80c11d:	eb 34                	jmp    80c153 <dhcp_get_option_ptr+0x14e>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  80c11f:	80 7d ff 02          	cmpb   $0x2,-0x1(%rbp)
  80c123:	75 18                	jne    80c13d <dhcp_get_option_ptr+0x138>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80c125:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c129:	48 8b 40 18          	mov    0x18(%rax),%rax
  80c12d:	48 83 c0 2c          	add    $0x2c,%rax
  80c131:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_SNAME_LEN;
  80c135:	66 c7 45 ec 40 00    	movw   $0x40,-0x14(%rbp)
  80c13b:	eb 16                	jmp    80c153 <dhcp_get_option_ptr+0x14e>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80c13d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c141:	48 8b 40 18          	mov    0x18(%rax),%rax
  80c145:	48 83 c0 2c          	add    $0x2c,%rax
  80c149:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  80c14d:	66 c7 45 ec c0 00    	movw   $0xc0,-0x14(%rbp)
      }
      offset = 0;
  80c153:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80c159:	eb 49                	jmp    80c1a4 <dhcp_get_option_ptr+0x19f>
        if (options[offset] == option_type) {
  80c15b:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c15f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c163:	48 01 d0             	add    %rdx,%rax
  80c166:	0f b6 00             	movzbl (%rax),%eax
  80c169:	3a 45 d4             	cmp    -0x2c(%rbp),%al
  80c16c:	75 0d                	jne    80c17b <dhcp_get_option_ptr+0x176>
           LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset=%"U16_F"\n", offset));
          return &options[offset];
  80c16e:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c172:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c176:	48 01 d0             	add    %rdx,%rax
  80c179:	eb 4a                	jmp    80c1c5 <dhcp_get_option_ptr+0x1c0>
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  80c17b:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c17f:	83 c0 01             	add    $0x1,%eax
  80c182:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
          offset += 1 + options[offset];
  80c186:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c18a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c18e:	48 01 d0             	add    %rdx,%rax
  80c191:	0f b6 00             	movzbl (%rax),%eax
  80c194:	0f b6 d0             	movzbl %al,%edx
  80c197:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c19b:	01 d0                	add    %edx,%eax
  80c19d:	83 c0 01             	add    $0x1,%eax
  80c1a0:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80c1a4:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80c1a8:	66 3b 45 ec          	cmp    -0x14(%rbp),%ax
  80c1ac:	73 12                	jae    80c1c0 <dhcp_get_option_ptr+0x1bb>
  80c1ae:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80c1b2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c1b6:	48 01 d0             	add    %rdx,%rax
  80c1b9:	0f b6 00             	movzbl (%rax),%eax
  80c1bc:	3c ff                	cmp    $0xff,%al
  80c1be:	75 9b                	jne    80c15b <dhcp_get_option_ptr+0x156>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  80c1c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80c1c5:	c9                   	leaveq 
  80c1c6:	c3                   	retq   

000000000080c1c7 <dhcp_get_option_byte>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  80c1c7:	55                   	push   %rbp
  80c1c8:	48 89 e5             	mov    %rsp,%rbp
  80c1cb:	48 83 ec 08          	sub    $0x8,%rsp
  80c1cf:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  80c1d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c1d7:	0f b6 00             	movzbl (%rax),%eax
}
  80c1da:	c9                   	leaveq 
  80c1db:	c3                   	retq   

000000000080c1dc <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  80c1dc:	55                   	push   %rbp
  80c1dd:	48 89 e5             	mov    %rsp,%rbp
  80c1e0:	48 83 ec 18          	sub    $0x18,%rsp
  80c1e4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  80c1e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c1ec:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80c1f0:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80c1f4:	0f b6 00             	movzbl (%rax),%eax
  80c1f7:	0f b6 c0             	movzbl %al,%eax
  80c1fa:	c1 e0 18             	shl    $0x18,%eax
  80c1fd:	89 45 fc             	mov    %eax,-0x4(%rbp)
  value |= (u32_t)(*ptr++) << 16;
  80c200:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c204:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80c208:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80c20c:	0f b6 00             	movzbl (%rax),%eax
  80c20f:	0f b6 c0             	movzbl %al,%eax
  80c212:	c1 e0 10             	shl    $0x10,%eax
  80c215:	09 45 fc             	or     %eax,-0x4(%rbp)
  value |= (u32_t)(*ptr++) << 8;
  80c218:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c21c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80c220:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80c224:	0f b6 00             	movzbl (%rax),%eax
  80c227:	0f b6 c0             	movzbl %al,%eax
  80c22a:	c1 e0 08             	shl    $0x8,%eax
  80c22d:	09 45 fc             	or     %eax,-0x4(%rbp)
  value |= (u32_t)(*ptr++);
  80c230:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c234:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80c238:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80c23c:	0f b6 00             	movzbl (%rax),%eax
  80c23f:	0f b6 c0             	movzbl %al,%eax
  80c242:	09 45 fc             	or     %eax,-0x4(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
  80c245:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80c248:	c9                   	leaveq 
  80c249:	c3                   	retq   

000000000080c24a <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
  80c24a:	55                   	push   %rbp
  80c24b:	48 89 e5             	mov    %rsp,%rbp
  80c24e:	48 83 ec 20          	sub    $0x20,%rsp
  80c252:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  80c256:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c25d:	00 00 00 
  80c260:	48 8b 00             	mov    (%rax),%rax
  80c263:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c267:	73 2a                	jae    80c293 <plug_holes+0x49>
  80c269:	48 ba 18 1f 82 00 00 	movabs $0x821f18,%rdx
  80c270:	00 00 00 
  80c273:	be e4 00 00 00       	mov    $0xe4,%esi
  80c278:	48 bf 2f 1f 82 00 00 	movabs $0x821f2f,%rdi
  80c27f:	00 00 00 
  80c282:	b8 00 00 00 00       	mov    $0x0,%eax
  80c287:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80c28e:	00 00 00 
  80c291:	ff d1                	callq  *%rcx
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80c293:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c29a:	00 00 00 
  80c29d:	48 8b 00             	mov    (%rax),%rax
  80c2a0:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c2a4:	72 2a                	jb     80c2d0 <plug_holes+0x86>
  80c2a6:	48 ba 43 1f 82 00 00 	movabs $0x821f43,%rdx
  80c2ad:	00 00 00 
  80c2b0:	be e5 00 00 00       	mov    $0xe5,%esi
  80c2b5:	48 bf 2f 1f 82 00 00 	movabs $0x821f2f,%rdi
  80c2bc:	00 00 00 
  80c2bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80c2c4:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80c2cb:	00 00 00 
  80c2ce:	ff d1                	callq  *%rcx
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
  80c2d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c2d4:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c2d8:	84 c0                	test   %al,%al
  80c2da:	74 2a                	je     80c306 <plug_holes+0xbc>
  80c2dc:	48 ba 5d 1f 82 00 00 	movabs $0x821f5d,%rdx
  80c2e3:	00 00 00 
  80c2e6:	be e6 00 00 00       	mov    $0xe6,%esi
  80c2eb:	48 bf 2f 1f 82 00 00 	movabs $0x821f2f,%rdi
  80c2f2:	00 00 00 
  80c2f5:	b8 00 00 00 00       	mov    $0x0,%eax
  80c2fa:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80c301:	00 00 00 
  80c304:	ff d1                	callq  *%rcx

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  80c306:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c30a:	8b 00                	mov    (%rax),%eax
  80c30c:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c311:	76 2a                	jbe    80c33d <plug_holes+0xf3>
  80c313:	48 ba 78 1f 82 00 00 	movabs $0x821f78,%rdx
  80c31a:	00 00 00 
  80c31d:	be e9 00 00 00       	mov    $0xe9,%esi
  80c322:	48 bf 2f 1f 82 00 00 	movabs $0x821f2f,%rdi
  80c329:	00 00 00 
  80c32c:	b8 00 00 00 00       	mov    $0x0,%eax
  80c331:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80c338:	00 00 00 
  80c33b:	ff d1                	callq  *%rcx

  nmem = (struct mem *)&ram[mem->next];
  80c33d:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c344:	00 00 00 
  80c347:	48 8b 10             	mov    (%rax),%rdx
  80c34a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c34e:	8b 00                	mov    (%rax),%eax
  80c350:	89 c0                	mov    %eax,%eax
  80c352:	48 01 d0             	add    %rdx,%rax
  80c355:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  80c359:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c35d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80c361:	0f 84 81 00 00 00    	je     80c3e8 <plug_holes+0x19e>
  80c367:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c36b:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c36f:	84 c0                	test   %al,%al
  80c371:	75 75                	jne    80c3e8 <plug_holes+0x19e>
  80c373:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c37a:	00 00 00 
  80c37d:	48 8b 00             	mov    (%rax),%rax
  80c380:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80c384:	74 62                	je     80c3e8 <plug_holes+0x19e>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  80c386:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c38d:	00 00 00 
  80c390:	48 8b 00             	mov    (%rax),%rax
  80c393:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80c397:	75 11                	jne    80c3aa <plug_holes+0x160>
      lfree = mem;
  80c399:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c3a0:	00 00 00 
  80c3a3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80c3a7:	48 89 10             	mov    %rdx,(%rax)
    }
    mem->next = nmem->next;
  80c3aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c3ae:	8b 10                	mov    (%rax),%edx
  80c3b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c3b4:	89 10                	mov    %edx,(%rax)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  80c3b6:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c3bd:	00 00 00 
  80c3c0:	48 8b 10             	mov    (%rax),%rdx
  80c3c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c3c7:	8b 00                	mov    (%rax),%eax
  80c3c9:	89 c0                	mov    %eax,%eax
  80c3cb:	48 01 c2             	add    %rax,%rdx
  80c3ce:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80c3d2:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c3d9:	00 00 00 
  80c3dc:	48 8b 00             	mov    (%rax),%rax
  80c3df:	48 29 c1             	sub    %rax,%rcx
  80c3e2:	48 89 c8             	mov    %rcx,%rax
  80c3e5:	89 42 04             	mov    %eax,0x4(%rdx)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  80c3e8:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c3ef:	00 00 00 
  80c3f2:	48 8b 10             	mov    (%rax),%rdx
  80c3f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c3f9:	8b 40 04             	mov    0x4(%rax),%eax
  80c3fc:	89 c0                	mov    %eax,%eax
  80c3fe:	48 01 d0             	add    %rdx,%rax
  80c401:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (pmem != mem && pmem->used == 0) {
  80c405:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c409:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c40d:	74 6e                	je     80c47d <plug_holes+0x233>
  80c40f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c413:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c417:	84 c0                	test   %al,%al
  80c419:	75 62                	jne    80c47d <plug_holes+0x233>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  80c41b:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c422:	00 00 00 
  80c425:	48 8b 00             	mov    (%rax),%rax
  80c428:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c42c:	75 11                	jne    80c43f <plug_holes+0x1f5>
      lfree = pmem;
  80c42e:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c435:	00 00 00 
  80c438:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80c43c:	48 89 10             	mov    %rdx,(%rax)
    }
    pmem->next = mem->next;
  80c43f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c443:	8b 10                	mov    (%rax),%edx
  80c445:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c449:	89 10                	mov    %edx,(%rax)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  80c44b:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c452:	00 00 00 
  80c455:	48 8b 10             	mov    (%rax),%rdx
  80c458:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c45c:	8b 00                	mov    (%rax),%eax
  80c45e:	89 c0                	mov    %eax,%eax
  80c460:	48 01 c2             	add    %rax,%rdx
  80c463:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80c467:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c46e:	00 00 00 
  80c471:	48 8b 00             	mov    (%rax),%rax
  80c474:	48 29 c1             	sub    %rax,%rcx
  80c477:	48 89 c8             	mov    %rcx,%rax
  80c47a:	89 42 04             	mov    %eax,0x4(%rdx)
  }
}
  80c47d:	90                   	nop
  80c47e:	c9                   	leaveq 
  80c47f:	c3                   	retq   

000000000080c480 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  80c480:	55                   	push   %rbp
  80c481:	48 89 e5             	mov    %rsp,%rbp
  80c484:	48 83 ec 10          	sub    $0x10,%rsp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  80c488:	48 b8 e0 94 82 00 00 	movabs $0x8294e0,%rax
  80c48f:	00 00 00 
  80c492:	48 83 c0 03          	add    $0x3,%rax
  80c496:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80c49a:	48 89 c2             	mov    %rax,%rdx
  80c49d:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c4a4:	00 00 00 
  80c4a7:	48 89 10             	mov    %rdx,(%rax)
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  80c4aa:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c4b1:	00 00 00 
  80c4b4:	48 8b 00             	mov    (%rax),%rax
  80c4b7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  mem->next = MEM_SIZE_ALIGNED;
  80c4bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c4bf:	c7 00 00 00 22 00    	movl   $0x220000,(%rax)
  mem->prev = 0;
  80c4c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c4c9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  mem->used = 0;
  80c4d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c4d4:	c6 40 08 00          	movb   $0x0,0x8(%rax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  80c4d8:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c4df:	00 00 00 
  80c4e2:	48 8b 00             	mov    (%rax),%rax
  80c4e5:	48 8d 90 00 00 22 00 	lea    0x220000(%rax),%rdx
  80c4ec:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c4f3:	00 00 00 
  80c4f6:	48 89 10             	mov    %rdx,(%rax)
  ram_end->used = 1;
  80c4f9:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c500:	00 00 00 
  80c503:	48 8b 00             	mov    (%rax),%rax
  80c506:	c6 40 08 01          	movb   $0x1,0x8(%rax)
  ram_end->next = MEM_SIZE_ALIGNED;
  80c50a:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c511:	00 00 00 
  80c514:	48 8b 00             	mov    (%rax),%rax
  80c517:	c7 00 00 00 22 00    	movl   $0x220000,(%rax)
  ram_end->prev = MEM_SIZE_ALIGNED;
  80c51d:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c524:	00 00 00 
  80c527:	48 8b 00             	mov    (%rax),%rax
  80c52a:	c7 40 04 00 00 22 00 	movl   $0x220000,0x4(%rax)

  mem_sem = sys_sem_new(1);
  80c531:	bf 01 00 00 00       	mov    $0x1,%edi
  80c536:	48 b8 5c 7f 81 00 00 	movabs $0x817f5c,%rax
  80c53d:	00 00 00 
  80c540:	ff d0                	callq  *%rax
  80c542:	89 c2                	mov    %eax,%edx
  80c544:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c54b:	00 00 00 
  80c54e:	89 10                	mov    %edx,(%rax)

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  80c550:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c557:	00 00 00 
  80c55a:	48 8b 10             	mov    (%rax),%rdx
  80c55d:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c564:	00 00 00 
  80c567:	48 89 10             	mov    %rdx,(%rax)

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  80c56a:	90                   	nop
  80c56b:	c9                   	leaveq 
  80c56c:	c3                   	retq   

000000000080c56d <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  80c56d:	55                   	push   %rbp
  80c56e:	48 89 e5             	mov    %rsp,%rbp
  80c571:	48 83 ec 20          	sub    $0x20,%rsp
  80c575:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  80c579:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80c57e:	0f 84 70 01 00 00    	je     80c6f4 <mem_free+0x187>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  80c584:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c588:	83 e0 03             	and    $0x3,%eax
  80c58b:	48 85 c0             	test   %rax,%rax
  80c58e:	74 2a                	je     80c5ba <mem_free+0x4d>
  80c590:	48 ba a8 1f 82 00 00 	movabs $0x821fa8,%rdx
  80c597:	00 00 00 
  80c59a:	be 31 01 00 00       	mov    $0x131,%esi
  80c59f:	48 bf 2f 1f 82 00 00 	movabs $0x821f2f,%rdi
  80c5a6:	00 00 00 
  80c5a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80c5ae:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80c5b5:	00 00 00 
  80c5b8:	ff d1                	callq  *%rcx

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80c5ba:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c5c1:	00 00 00 
  80c5c4:	48 8b 00             	mov    (%rax),%rax
  80c5c7:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c5cb:	72 13                	jb     80c5e0 <mem_free+0x73>
  80c5cd:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c5d4:	00 00 00 
  80c5d7:	48 8b 00             	mov    (%rax),%rax
  80c5da:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c5de:	72 2a                	jb     80c60a <mem_free+0x9d>
  80c5e0:	48 ba c9 1f 82 00 00 	movabs $0x821fc9,%rdx
  80c5e7:	00 00 00 
  80c5ea:	be 34 01 00 00       	mov    $0x134,%esi
  80c5ef:	48 bf 2f 1f 82 00 00 	movabs $0x821f2f,%rdi
  80c5f6:	00 00 00 
  80c5f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80c5fe:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80c605:	00 00 00 
  80c608:	ff d1                	callq  *%rcx
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  80c60a:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c611:	00 00 00 
  80c614:	48 8b 00             	mov    (%rax),%rax
  80c617:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c61b:	0f 82 d6 00 00 00    	jb     80c6f7 <mem_free+0x18a>
  80c621:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c628:	00 00 00 
  80c62b:	48 8b 00             	mov    (%rax),%rax
  80c62e:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c632:	0f 83 bf 00 00 00    	jae    80c6f7 <mem_free+0x18a>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80c638:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c63f:	00 00 00 
  80c642:	8b 00                	mov    (%rax),%eax
  80c644:	be 00 00 00 00       	mov    $0x0,%esi
  80c649:	89 c7                	mov    %eax,%edi
  80c64b:	48 b8 ea 82 81 00 00 	movabs $0x8182ea,%rax
  80c652:	00 00 00 
  80c655:	ff d0                	callq  *%rax
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80c657:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c65b:	48 83 e8 0c          	sub    $0xc,%rax
  80c65f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  80c663:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c667:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c66b:	84 c0                	test   %al,%al
  80c66d:	75 2a                	jne    80c699 <mem_free+0x12c>
  80c66f:	48 ba e0 1f 82 00 00 	movabs $0x821fe0,%rdx
  80c676:	00 00 00 
  80c679:	be 44 01 00 00       	mov    $0x144,%esi
  80c67e:	48 bf 2f 1f 82 00 00 	movabs $0x821f2f,%rdi
  80c685:	00 00 00 
  80c688:	b8 00 00 00 00       	mov    $0x0,%eax
  80c68d:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80c694:	00 00 00 
  80c697:	ff d1                	callq  *%rcx
  /* ... and is now unused. */
  mem->used = 0;
  80c699:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c69d:	c6 40 08 00          	movb   $0x0,0x8(%rax)

  if (mem < lfree) {
  80c6a1:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c6a8:	00 00 00 
  80c6ab:	48 8b 00             	mov    (%rax),%rax
  80c6ae:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80c6b2:	73 11                	jae    80c6c5 <mem_free+0x158>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  80c6b4:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c6bb:	00 00 00 
  80c6be:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c6c2:	48 89 10             	mov    %rdx,(%rax)
  }

  MEM_STATS_DEC_USED(used, mem->next - ((u8_t *)mem - ram));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
  80c6c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c6c9:	48 89 c7             	mov    %rax,%rdi
  80c6cc:	48 b8 4a c2 80 00 00 	movabs $0x80c24a,%rax
  80c6d3:	00 00 00 
  80c6d6:	ff d0                	callq  *%rax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80c6d8:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c6df:	00 00 00 
  80c6e2:	8b 00                	mov    (%rax),%eax
  80c6e4:	89 c7                	mov    %eax,%edi
  80c6e6:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  80c6ed:	00 00 00 
  80c6f0:	ff d0                	callq  *%rax
  80c6f2:	eb 04                	jmp    80c6f8 <mem_free+0x18b>
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  80c6f4:	90                   	nop
  80c6f5:	eb 01                	jmp    80c6f8 <mem_free+0x18b>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  80c6f7:	90                   	nop
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
  80c6f8:	c9                   	leaveq 
  80c6f9:	c3                   	retq   

000000000080c6fa <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  80c6fa:	55                   	push   %rbp
  80c6fb:	48 89 e5             	mov    %rsp,%rbp
  80c6fe:	48 83 ec 30          	sub    $0x30,%rsp
  80c702:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80c706:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  80c709:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c70c:	83 c0 03             	add    $0x3,%eax
  80c70f:	83 e0 fc             	and    $0xfffffffc,%eax
  80c712:	89 45 d4             	mov    %eax,-0x2c(%rbp)

  if(newsize < MIN_SIZE_ALIGNED) {
  80c715:	83 7d d4 0b          	cmpl   $0xb,-0x2c(%rbp)
  80c719:	77 07                	ja     80c722 <mem_realloc+0x28>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  80c71b:	c7 45 d4 0c 00 00 00 	movl   $0xc,-0x2c(%rbp)
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  80c722:	81 7d d4 00 00 22 00 	cmpl   $0x220000,-0x2c(%rbp)
  80c729:	76 0a                	jbe    80c735 <mem_realloc+0x3b>
    return NULL;
  80c72b:	b8 00 00 00 00       	mov    $0x0,%eax
  80c730:	e9 d9 02 00 00       	jmpq   80ca0e <mem_realloc+0x314>
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80c735:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c73c:	00 00 00 
  80c73f:	48 8b 00             	mov    (%rax),%rax
  80c742:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c746:	72 13                	jb     80c75b <mem_realloc+0x61>
  80c748:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c74f:	00 00 00 
  80c752:	48 8b 00             	mov    (%rax),%rax
  80c755:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c759:	72 2a                	jb     80c785 <mem_realloc+0x8b>
  80c75b:	48 ba f4 1f 82 00 00 	movabs $0x821ff4,%rdx
  80c762:	00 00 00 
  80c765:	be 7a 01 00 00       	mov    $0x17a,%esi
  80c76a:	48 bf 2f 1f 82 00 00 	movabs $0x821f2f,%rdi
  80c771:	00 00 00 
  80c774:	b8 00 00 00 00       	mov    $0x0,%eax
  80c779:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80c780:	00 00 00 
  80c783:	ff d1                	callq  *%rcx
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  80c785:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c78c:	00 00 00 
  80c78f:	48 8b 00             	mov    (%rax),%rax
  80c792:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c796:	72 13                	jb     80c7ab <mem_realloc+0xb1>
  80c798:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c79f:	00 00 00 
  80c7a2:	48 8b 00             	mov    (%rax),%rax
  80c7a5:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c7a9:	72 09                	jb     80c7b4 <mem_realloc+0xba>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_realloc: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  80c7ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c7af:	e9 5a 02 00 00       	jmpq   80ca0e <mem_realloc+0x314>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80c7b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c7b8:	48 83 e8 0c          	sub    $0xc,%rax
  80c7bc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  80c7c0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c7c4:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c7cb:	00 00 00 
  80c7ce:	48 8b 00             	mov    (%rax),%rax
  80c7d1:	48 29 c2             	sub    %rax,%rdx
  80c7d4:	48 89 d0             	mov    %rdx,%rax
  80c7d7:	89 45 f4             	mov    %eax,-0xc(%rbp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  80c7da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c7de:	8b 00                	mov    (%rax),%eax
  80c7e0:	2b 45 f4             	sub    -0xc(%rbp),%eax
  80c7e3:	83 e8 0c             	sub    $0xc,%eax
  80c7e6:	89 45 f0             	mov    %eax,-0x10(%rbp)
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  80c7e9:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c7ec:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c7ef:	76 2a                	jbe    80c81b <mem_realloc+0x121>
  80c7f1:	48 ba 10 20 82 00 00 	movabs $0x822010,%rdx
  80c7f8:	00 00 00 
  80c7fb:	be 8b 01 00 00       	mov    $0x18b,%esi
  80c800:	48 bf 2f 1f 82 00 00 	movabs $0x821f2f,%rdi
  80c807:	00 00 00 
  80c80a:	b8 00 00 00 00       	mov    $0x0,%eax
  80c80f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80c816:	00 00 00 
  80c819:	ff d1                	callq  *%rcx
  if (newsize > size) {
  80c81b:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c81e:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c821:	76 0a                	jbe    80c82d <mem_realloc+0x133>
    /* not supported */
    return NULL;
  80c823:	b8 00 00 00 00       	mov    $0x0,%eax
  80c828:	e9 e1 01 00 00       	jmpq   80ca0e <mem_realloc+0x314>
  }
  if (newsize == size) {
  80c82d:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c830:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c833:	75 09                	jne    80c83e <mem_realloc+0x144>
    /* No change in size, simply return */
    return rmem;
  80c835:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c839:	e9 d0 01 00 00       	jmpq   80ca0e <mem_realloc+0x314>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80c83e:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c845:	00 00 00 
  80c848:	8b 00                	mov    (%rax),%eax
  80c84a:	be 00 00 00 00       	mov    $0x0,%esi
  80c84f:	89 c7                	mov    %eax,%edi
  80c851:	48 b8 ea 82 81 00 00 	movabs $0x8182ea,%rax
  80c858:	00 00 00 
  80c85b:	ff d0                	callq  *%rax

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  80c85d:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c864:	00 00 00 
  80c867:	48 8b 10             	mov    (%rax),%rdx
  80c86a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c86e:	8b 00                	mov    (%rax),%eax
  80c870:	89 c0                	mov    %eax,%eax
  80c872:	48 01 d0             	add    %rdx,%rax
  80c875:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if(mem2->used == 0) {
  80c879:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c87d:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c881:	84 c0                	test   %al,%al
  80c883:	0f 85 b9 00 00 00    	jne    80c942 <mem_realloc+0x248>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  80c889:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c88d:	8b 00                	mov    (%rax),%eax
  80c88f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80c892:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c895:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c898:	01 d0                	add    %edx,%eax
  80c89a:	83 c0 0c             	add    $0xc,%eax
  80c89d:	89 45 e0             	mov    %eax,-0x20(%rbp)
    if (lfree == mem2) {
  80c8a0:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c8a7:	00 00 00 
  80c8aa:	48 8b 00             	mov    (%rax),%rax
  80c8ad:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c8b1:	75 20                	jne    80c8d3 <mem_realloc+0x1d9>
      lfree = (struct mem *)&ram[ptr2];
  80c8b3:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c8ba:	00 00 00 
  80c8bd:	48 8b 10             	mov    (%rax),%rdx
  80c8c0:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c8c3:	48 01 c2             	add    %rax,%rdx
  80c8c6:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c8cd:	00 00 00 
  80c8d0:	48 89 10             	mov    %rdx,(%rax)
    }
    mem2 = (struct mem *)&ram[ptr2];
  80c8d3:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c8da:	00 00 00 
  80c8dd:	48 8b 10             	mov    (%rax),%rdx
  80c8e0:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c8e3:	48 01 d0             	add    %rdx,%rax
  80c8e6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    mem2->used = 0;
  80c8ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c8ee:	c6 40 08 00          	movb   $0x0,0x8(%rax)
    /* restore the next pointer */
    mem2->next = next;
  80c8f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c8f6:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80c8f9:	89 10                	mov    %edx,(%rax)
    /* link it back to mem */
    mem2->prev = ptr;
  80c8fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c8ff:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c902:	89 50 04             	mov    %edx,0x4(%rax)
    /* link mem to it */
    mem->next = ptr2;
  80c905:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c909:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80c90c:	89 10                	mov    %edx,(%rax)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80c90e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c912:	8b 00                	mov    (%rax),%eax
  80c914:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c919:	0f 84 d1 00 00 00    	je     80c9f0 <mem_realloc+0x2f6>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80c91f:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c926:	00 00 00 
  80c929:	48 8b 10             	mov    (%rax),%rdx
  80c92c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c930:	8b 00                	mov    (%rax),%eax
  80c932:	89 c0                	mov    %eax,%eax
  80c934:	48 01 c2             	add    %rax,%rdx
  80c937:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c93a:	89 42 04             	mov    %eax,0x4(%rdx)
  80c93d:	e9 ae 00 00 00       	jmpq   80c9f0 <mem_realloc+0x2f6>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  80c942:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c945:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80c949:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80c94c:	48 39 c2             	cmp    %rax,%rdx
  80c94f:	0f 87 9b 00 00 00    	ja     80c9f0 <mem_realloc+0x2f6>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80c955:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c958:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c95b:	01 d0                	add    %edx,%eax
  80c95d:	83 c0 0c             	add    $0xc,%eax
  80c960:	89 45 e0             	mov    %eax,-0x20(%rbp)
    mem2 = (struct mem *)&ram[ptr2];
  80c963:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c96a:	00 00 00 
  80c96d:	48 8b 10             	mov    (%rax),%rdx
  80c970:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c973:	48 01 d0             	add    %rdx,%rax
  80c976:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (mem2 < lfree) {
  80c97a:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c981:	00 00 00 
  80c984:	48 8b 00             	mov    (%rax),%rax
  80c987:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c98b:	73 11                	jae    80c99e <mem_realloc+0x2a4>
      lfree = mem2;
  80c98d:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c994:	00 00 00 
  80c997:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80c99b:	48 89 10             	mov    %rdx,(%rax)
    }
    mem2->used = 0;
  80c99e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c9a2:	c6 40 08 00          	movb   $0x0,0x8(%rax)
    mem2->next = mem->next;
  80c9a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c9aa:	8b 10                	mov    (%rax),%edx
  80c9ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c9b0:	89 10                	mov    %edx,(%rax)
    mem2->prev = ptr;
  80c9b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c9b6:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c9b9:	89 50 04             	mov    %edx,0x4(%rax)
    mem->next = ptr2;
  80c9bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c9c0:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80c9c3:	89 10                	mov    %edx,(%rax)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80c9c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c9c9:	8b 00                	mov    (%rax),%eax
  80c9cb:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c9d0:	74 1e                	je     80c9f0 <mem_realloc+0x2f6>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80c9d2:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c9d9:	00 00 00 
  80c9dc:	48 8b 10             	mov    (%rax),%rdx
  80c9df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c9e3:	8b 00                	mov    (%rax),%eax
  80c9e5:	89 c0                	mov    %eax,%eax
  80c9e7:	48 01 c2             	add    %rax,%rdx
  80c9ea:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c9ed:	89 42 04             	mov    %eax,0x4(%rdx)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80c9f0:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c9f7:	00 00 00 
  80c9fa:	8b 00                	mov    (%rax),%eax
  80c9fc:	89 c7                	mov    %eax,%edi
  80c9fe:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  80ca05:	00 00 00 
  80ca08:	ff d0                	callq  *%rax
  return rmem;
  80ca0a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
}
  80ca0e:	c9                   	leaveq 
  80ca0f:	c3                   	retq   

000000000080ca10 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  80ca10:	55                   	push   %rbp
  80ca11:	48 89 e5             	mov    %rsp,%rbp
  80ca14:	48 83 ec 30          	sub    $0x30,%rsp
  80ca18:	89 7d dc             	mov    %edi,-0x24(%rbp)
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  80ca1b:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80ca1f:	75 0a                	jne    80ca2b <mem_malloc+0x1b>
    return NULL;
  80ca21:	b8 00 00 00 00       	mov    $0x0,%eax
  80ca26:	e9 6b 03 00 00       	jmpq   80cd96 <mem_malloc+0x386>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  80ca2b:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80ca2e:	83 c0 03             	add    $0x3,%eax
  80ca31:	83 e0 fc             	and    $0xfffffffc,%eax
  80ca34:	89 45 dc             	mov    %eax,-0x24(%rbp)

  if(size < MIN_SIZE_ALIGNED) {
  80ca37:	83 7d dc 0b          	cmpl   $0xb,-0x24(%rbp)
  80ca3b:	77 07                	ja     80ca44 <mem_malloc+0x34>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  80ca3d:	c7 45 dc 0c 00 00 00 	movl   $0xc,-0x24(%rbp)
  }

  if (size > MEM_SIZE_ALIGNED) {
  80ca44:	81 7d dc 00 00 22 00 	cmpl   $0x220000,-0x24(%rbp)
  80ca4b:	76 0a                	jbe    80ca57 <mem_malloc+0x47>
    return NULL;
  80ca4d:	b8 00 00 00 00       	mov    $0x0,%eax
  80ca52:	e9 3f 03 00 00       	jmpq   80cd96 <mem_malloc+0x386>
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  80ca57:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80ca5e:	00 00 00 
  80ca61:	8b 00                	mov    (%rax),%eax
  80ca63:	be 00 00 00 00       	mov    $0x0,%esi
  80ca68:	89 c7                	mov    %eax,%edi
  80ca6a:	48 b8 ea 82 81 00 00 	movabs $0x8182ea,%rax
  80ca71:	00 00 00 
  80ca74:	ff d0                	callq  *%rax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80ca76:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80ca7d:	00 00 00 
  80ca80:	48 8b 00             	mov    (%rax),%rax
  80ca83:	48 89 c2             	mov    %rax,%rdx
  80ca86:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80ca8d:	00 00 00 
  80ca90:	48 8b 00             	mov    (%rax),%rax
  80ca93:	48 29 c2             	sub    %rax,%rdx
  80ca96:	48 89 d0             	mov    %rdx,%rax
  80ca99:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80ca9c:	e9 c5 02 00 00       	jmpq   80cd66 <mem_malloc+0x356>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  80caa1:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80caa8:	00 00 00 
  80caab:	48 8b 10             	mov    (%rax),%rdx
  80caae:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80cab1:	48 01 d0             	add    %rdx,%rax
  80cab4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80cab8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cabc:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80cac0:	84 c0                	test   %al,%al
  80cac2:	0f 85 86 02 00 00    	jne    80cd4e <mem_malloc+0x33e>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  80cac8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cacc:	8b 00                	mov    (%rax),%eax
  80cace:	89 c2                	mov    %eax,%edx
  80cad0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80cad3:	48 29 c2             	sub    %rax,%rdx
  80cad6:	48 89 d0             	mov    %rdx,%rax
  80cad9:	48 8d 50 f4          	lea    -0xc(%rax),%rdx
  80cadd:	8b 45 dc             	mov    -0x24(%rbp),%eax
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80cae0:	48 39 c2             	cmp    %rax,%rdx
  80cae3:	0f 82 65 02 00 00    	jb     80cd4e <mem_malloc+0x33e>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  80cae9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80caed:	8b 00                	mov    (%rax),%eax
  80caef:	89 c2                	mov    %eax,%edx
  80caf1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80caf4:	48 29 c2             	sub    %rax,%rdx
  80caf7:	48 89 d0             	mov    %rdx,%rax
  80cafa:	48 8d 50 f4          	lea    -0xc(%rax),%rdx
  80cafe:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80cb01:	48 83 c0 18          	add    $0x18,%rax
  80cb05:	48 39 c2             	cmp    %rax,%rdx
  80cb08:	0f 82 81 00 00 00    	jb     80cb8f <mem_malloc+0x17f>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  80cb0e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80cb11:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80cb14:	01 d0                	add    %edx,%eax
  80cb16:	83 c0 0c             	add    $0xc,%eax
  80cb19:	89 45 ec             	mov    %eax,-0x14(%rbp)
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  80cb1c:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80cb23:	00 00 00 
  80cb26:	48 8b 10             	mov    (%rax),%rdx
  80cb29:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80cb2c:	48 01 d0             	add    %rdx,%rax
  80cb2f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          mem2->used = 0;
  80cb33:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cb37:	c6 40 08 00          	movb   $0x0,0x8(%rax)
          mem2->next = mem->next;
  80cb3b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cb3f:	8b 10                	mov    (%rax),%edx
  80cb41:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cb45:	89 10                	mov    %edx,(%rax)
          mem2->prev = ptr;
  80cb47:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cb4b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80cb4e:	89 50 04             	mov    %edx,0x4(%rax)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  80cb51:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cb55:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cb58:	89 10                	mov    %edx,(%rax)
          mem->used = 1;
  80cb5a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cb5e:	c6 40 08 01          	movb   $0x1,0x8(%rax)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  80cb62:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cb66:	8b 00                	mov    (%rax),%eax
  80cb68:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80cb6d:	74 28                	je     80cb97 <mem_malloc+0x187>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80cb6f:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80cb76:	00 00 00 
  80cb79:	48 8b 10             	mov    (%rax),%rdx
  80cb7c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cb80:	8b 00                	mov    (%rax),%eax
  80cb82:	89 c0                	mov    %eax,%eax
  80cb84:	48 01 c2             	add    %rax,%rdx
  80cb87:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80cb8a:	89 42 04             	mov    %eax,0x4(%rdx)
  80cb8d:	eb 08                	jmp    80cb97 <mem_malloc+0x187>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  80cb8f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cb93:	c6 40 08 01          	movb   $0x1,0x8(%rax)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  80cb97:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cb9e:	00 00 00 
  80cba1:	48 8b 00             	mov    (%rax),%rax
  80cba4:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  80cba8:	0f 85 c2 00 00 00    	jne    80cc70 <mem_malloc+0x260>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80cbae:	eb 2e                	jmp    80cbde <mem_malloc+0x1ce>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  80cbb0:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80cbb7:	00 00 00 
  80cbba:	48 8b 10             	mov    (%rax),%rdx
  80cbbd:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cbc4:	00 00 00 
  80cbc7:	48 8b 00             	mov    (%rax),%rax
  80cbca:	8b 00                	mov    (%rax),%eax
  80cbcc:	89 c0                	mov    %eax,%eax
  80cbce:	48 01 c2             	add    %rax,%rdx
  80cbd1:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cbd8:	00 00 00 
  80cbdb:	48 89 10             	mov    %rdx,(%rax)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80cbde:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cbe5:	00 00 00 
  80cbe8:	48 8b 00             	mov    (%rax),%rax
  80cbeb:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80cbef:	84 c0                	test   %al,%al
  80cbf1:	74 1f                	je     80cc12 <mem_malloc+0x202>
  80cbf3:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cbfa:	00 00 00 
  80cbfd:	48 8b 10             	mov    (%rax),%rdx
  80cc00:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80cc07:	00 00 00 
  80cc0a:	48 8b 00             	mov    (%rax),%rax
  80cc0d:	48 39 c2             	cmp    %rax,%rdx
  80cc10:	75 9e                	jne    80cbb0 <mem_malloc+0x1a0>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  80cc12:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cc19:	00 00 00 
  80cc1c:	48 8b 10             	mov    (%rax),%rdx
  80cc1f:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80cc26:	00 00 00 
  80cc29:	48 8b 00             	mov    (%rax),%rax
  80cc2c:	48 39 c2             	cmp    %rax,%rdx
  80cc2f:	74 3f                	je     80cc70 <mem_malloc+0x260>
  80cc31:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80cc38:	00 00 00 
  80cc3b:	48 8b 00             	mov    (%rax),%rax
  80cc3e:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80cc42:	84 c0                	test   %al,%al
  80cc44:	74 2a                	je     80cc70 <mem_malloc+0x260>
  80cc46:	48 ba 33 20 82 00 00 	movabs $0x822033,%rdx
  80cc4d:	00 00 00 
  80cc50:	be 47 02 00 00       	mov    $0x247,%esi
  80cc55:	48 bf 2f 1f 82 00 00 	movabs $0x821f2f,%rdi
  80cc5c:	00 00 00 
  80cc5f:	b8 00 00 00 00       	mov    $0x0,%eax
  80cc64:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80cc6b:	00 00 00 
  80cc6e:	ff d1                	callq  *%rcx
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  80cc70:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80cc77:	00 00 00 
  80cc7a:	8b 00                	mov    (%rax),%eax
  80cc7c:	89 c7                	mov    %eax,%edi
  80cc7e:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  80cc85:	00 00 00 
  80cc88:	ff d0                	callq  *%rax
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  80cc8a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80cc8d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cc91:	48 01 d0             	add    %rdx,%rax
  80cc94:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  80cc98:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80cc9f:	00 00 00 
  80cca2:	48 8b 00             	mov    (%rax),%rax
  80cca5:	48 39 c2             	cmp    %rax,%rdx
  80cca8:	76 2a                	jbe    80ccd4 <mem_malloc+0x2c4>
  80ccaa:	48 ba 50 20 82 00 00 	movabs $0x822050,%rdx
  80ccb1:	00 00 00 
  80ccb4:	be 4c 02 00 00       	mov    $0x24c,%esi
  80ccb9:	48 bf 2f 1f 82 00 00 	movabs $0x821f2f,%rdi
  80ccc0:	00 00 00 
  80ccc3:	b8 00 00 00 00       	mov    $0x0,%eax
  80ccc8:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80cccf:	00 00 00 
  80ccd2:	ff d1                	callq  *%rcx
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  80ccd4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ccd8:	48 83 c0 0c          	add    $0xc,%rax
  80ccdc:	83 e0 03             	and    $0x3,%eax
  80ccdf:	48 85 c0             	test   %rax,%rax
  80cce2:	74 2a                	je     80cd0e <mem_malloc+0x2fe>
  80cce4:	48 ba 80 20 82 00 00 	movabs $0x822080,%rdx
  80cceb:	00 00 00 
  80ccee:	be 4e 02 00 00       	mov    $0x24e,%esi
  80ccf3:	48 bf 2f 1f 82 00 00 	movabs $0x821f2f,%rdi
  80ccfa:	00 00 00 
  80ccfd:	b8 00 00 00 00       	mov    $0x0,%eax
  80cd02:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80cd09:	00 00 00 
  80cd0c:	ff d1                	callq  *%rcx
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  80cd0e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cd12:	83 e0 03             	and    $0x3,%eax
  80cd15:	48 85 c0             	test   %rax,%rax
  80cd18:	74 2a                	je     80cd44 <mem_malloc+0x334>
  80cd1a:	48 ba b0 20 82 00 00 	movabs $0x8220b0,%rdx
  80cd21:	00 00 00 
  80cd24:	be 50 02 00 00       	mov    $0x250,%esi
  80cd29:	48 bf 2f 1f 82 00 00 	movabs $0x821f2f,%rdi
  80cd30:	00 00 00 
  80cd33:	b8 00 00 00 00       	mov    $0x0,%eax
  80cd38:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80cd3f:	00 00 00 
  80cd42:	ff d1                	callq  *%rcx
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
  80cd44:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cd48:	48 83 c0 0c          	add    $0xc,%rax
  80cd4c:	eb 48                	jmp    80cd96 <mem_malloc+0x386>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  80cd4e:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80cd55:	00 00 00 
  80cd58:	48 8b 10             	mov    (%rax),%rdx
  80cd5b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80cd5e:	48 01 d0             	add    %rdx,%rax
  80cd61:	8b 00                	mov    (%rax),%eax
  80cd63:	89 45 fc             	mov    %eax,-0x4(%rbp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80cd66:	b8 00 00 22 00       	mov    $0x220000,%eax
  80cd6b:	2b 45 dc             	sub    -0x24(%rbp),%eax
  80cd6e:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80cd71:	0f 87 2a fd ff ff    	ja     80caa1 <mem_malloc+0x91>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  80cd77:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80cd7e:	00 00 00 
  80cd81:	8b 00                	mov    (%rax),%eax
  80cd83:	89 c7                	mov    %eax,%edi
  80cd85:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  80cd8c:	00 00 00 
  80cd8f:	ff d0                	callq  *%rax
  return NULL;
  80cd91:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80cd96:	c9                   	leaveq 
  80cd97:	c3                   	retq   

000000000080cd98 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  80cd98:	55                   	push   %rbp
  80cd99:	48 89 e5             	mov    %rsp,%rbp
  80cd9c:	48 83 ec 20          	sub    $0x20,%rsp
  80cda0:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80cda3:	89 75 e8             	mov    %esi,-0x18(%rbp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  80cda6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80cda9:	0f af 45 e8          	imul   -0x18(%rbp),%eax
  80cdad:	89 c7                	mov    %eax,%edi
  80cdaf:	48 b8 10 ca 80 00 00 	movabs $0x80ca10,%rax
  80cdb6:	00 00 00 
  80cdb9:	ff d0                	callq  *%rax
  80cdbb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (p) {
  80cdbf:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80cdc4:	74 21                	je     80cde7 <mem_calloc+0x4f>
    /* zero the memory */
    memset(p, 0, count * size);
  80cdc6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80cdc9:	0f af 45 e8          	imul   -0x18(%rbp),%eax
  80cdcd:	89 c2                	mov    %eax,%edx
  80cdcf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cdd3:	be 00 00 00 00       	mov    $0x0,%esi
  80cdd8:	48 89 c7             	mov    %rax,%rdi
  80cddb:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  80cde2:	00 00 00 
  80cde5:	ff d0                	callq  *%rax
  }
  return p;
  80cde7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80cdeb:	c9                   	leaveq 
  80cdec:	c3                   	retq   

000000000080cded <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  80cded:	55                   	push   %rbp
  80cdee:	48 89 e5             	mov    %rsp,%rbp
  80cdf1:	48 83 ec 10          	sub    $0x10,%rsp
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
  80cdf5:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)
  80cdfb:	eb 05                	jmp    80ce02 <memp_init+0x15>
  80cdfd:	66 83 45 f6 01       	addw   $0x1,-0xa(%rbp)
  80ce02:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%rbp)
  80ce07:	76 f4                	jbe    80cdfd <memp_init+0x10>
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  80ce09:	48 b8 a0 95 a4 00 00 	movabs $0xa495a0,%rax
  80ce10:	00 00 00 
  80ce13:	48 83 c0 03          	add    $0x3,%rax
  80ce17:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80ce1b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80ce1f:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)
  80ce25:	e9 97 00 00 00       	jmpq   80cec1 <memp_init+0xd4>
    memp_tab[i] = NULL;
  80ce2a:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80ce2e:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80ce35:	00 00 00 
  80ce38:	48 63 d2             	movslq %edx,%rdx
  80ce3b:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  80ce42:	00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80ce43:	66 c7 45 f4 00 00    	movw   $0x0,-0xc(%rbp)
  80ce49:	eb 56                	jmp    80cea1 <memp_init+0xb4>
      memp->next = memp_tab[i];
  80ce4b:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80ce4f:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80ce56:	00 00 00 
  80ce59:	48 63 d2             	movslq %edx,%rdx
  80ce5c:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  80ce60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce64:	48 89 10             	mov    %rdx,(%rax)
      memp_tab[i] = memp;
  80ce67:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80ce6b:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80ce72:	00 00 00 
  80ce75:	48 63 d2             	movslq %edx,%rdx
  80ce78:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80ce7c:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80ce80:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80ce84:	48 b8 e0 20 82 00 00 	movabs $0x8220e0,%rax
  80ce8b:	00 00 00 
  80ce8e:	48 63 d2             	movslq %edx,%rdx
  80ce91:	0f b7 04 50          	movzwl (%rax,%rdx,2),%eax
  80ce95:	0f b7 c0             	movzwl %ax,%eax
  80ce98:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80ce9c:	66 83 45 f4 01       	addw   $0x1,-0xc(%rbp)
  80cea1:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80cea5:	48 b8 00 21 82 00 00 	movabs $0x822100,%rax
  80ceac:	00 00 00 
  80ceaf:	48 63 d2             	movslq %edx,%rdx
  80ceb2:	0f b7 04 50          	movzwl (%rax,%rdx,2),%eax
  80ceb6:	66 3b 45 f4          	cmp    -0xc(%rbp),%ax
  80ceba:	77 8f                	ja     80ce4b <memp_init+0x5e>
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80cebc:	66 83 45 f6 01       	addw   $0x1,-0xa(%rbp)
  80cec1:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%rbp)
  80cec6:	0f 86 5e ff ff ff    	jbe    80ce2a <memp_init+0x3d>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  80cecc:	90                   	nop
  80cecd:	c9                   	leaveq 
  80cece:	c3                   	retq   

000000000080cecf <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  80cecf:	55                   	push   %rbp
  80ced0:	48 89 e5             	mov    %rsp,%rbp
  80ced3:	48 83 ec 20          	sub    $0x20,%rsp
  80ced7:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  80ceda:	83 7d ec 0d          	cmpl   $0xd,-0x14(%rbp)
  80cede:	76 2a                	jbe    80cf0a <memp_malloc+0x3b>
  80cee0:	48 ba af 21 82 00 00 	movabs $0x8221af,%rdx
  80cee7:	00 00 00 
  80ceea:	be 2e 01 00 00       	mov    $0x12e,%esi
  80ceef:	48 bf cc 21 82 00 00 	movabs $0x8221cc,%rdi
  80cef6:	00 00 00 
  80cef9:	b8 00 00 00 00       	mov    $0x0,%eax
  80cefe:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80cf05:	00 00 00 
  80cf08:	ff d1                	callq  *%rcx
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  80cf0a:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cf11:	00 00 00 
  80cf14:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cf17:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80cf1b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
  if (memp != NULL) {    
  80cf1f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80cf24:	74 4e                	je     80cf74 <memp_malloc+0xa5>
    memp_tab[type] = memp->next;    
  80cf26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf2a:	48 8b 08             	mov    (%rax),%rcx
  80cf2d:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cf34:	00 00 00 
  80cf37:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cf3a:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  80cf3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf42:	83 e0 03             	and    $0x3,%eax
  80cf45:	48 85 c0             	test   %rax,%rax
  80cf48:	74 2a                	je     80cf74 <memp_malloc+0xa5>
  80cf4a:	48 ba e8 21 82 00 00 	movabs $0x8221e8,%rdx
  80cf51:	00 00 00 
  80cf54:	be 40 01 00 00       	mov    $0x140,%esi
  80cf59:	48 bf cc 21 82 00 00 	movabs $0x8221cc,%rdi
  80cf60:	00 00 00 
  80cf63:	b8 00 00 00 00       	mov    $0x0,%eax
  80cf68:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80cf6f:	00 00 00 
  80cf72:	ff d1                	callq  *%rcx
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
  80cf74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80cf78:	c9                   	leaveq 
  80cf79:	c3                   	retq   

000000000080cf7a <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  80cf7a:	55                   	push   %rbp
  80cf7b:	48 89 e5             	mov    %rsp,%rbp
  80cf7e:	48 83 ec 20          	sub    $0x20,%rsp
  80cf82:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80cf85:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  80cf89:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80cf8e:	74 6d                	je     80cffd <memp_free+0x83>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  80cf90:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cf94:	83 e0 03             	and    $0x3,%eax
  80cf97:	48 85 c0             	test   %rax,%rax
  80cf9a:	74 2a                	je     80cfc6 <memp_free+0x4c>
  80cf9c:	48 ba 10 22 82 00 00 	movabs $0x822210,%rdx
  80cfa3:	00 00 00 
  80cfa6:	be 5c 01 00 00       	mov    $0x15c,%esi
  80cfab:	48 bf cc 21 82 00 00 	movabs $0x8221cc,%rdi
  80cfb2:	00 00 00 
  80cfb5:	b8 00 00 00 00       	mov    $0x0,%eax
  80cfba:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80cfc1:	00 00 00 
  80cfc4:	ff d1                	callq  *%rcx
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)((u8_t*)mem - MEMP_SIZE);
  80cfc6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cfca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  80cfce:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cfd5:	00 00 00 
  80cfd8:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cfdb:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  80cfdf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfe3:	48 89 10             	mov    %rdx,(%rax)
  memp_tab[type] = memp;
  80cfe6:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80cfed:	00 00 00 
  80cff0:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cff3:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80cff7:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
  80cffb:	eb 01                	jmp    80cffe <memp_free+0x84>
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
  80cffd:	90                   	nop
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  80cffe:	c9                   	leaveq 
  80cfff:	c3                   	retq   

000000000080d000 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  80d000:	55                   	push   %rbp
  80d001:	48 89 e5             	mov    %rsp,%rbp
  80d004:	48 83 ec 30          	sub    $0x30,%rsp
  80d008:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80d00c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80d010:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80d014:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  80d018:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  80d01c:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  80d020:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d024:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
  netif->netmask.addr = 0;
  80d02b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d02f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
  netif->gw.addr = 0;
  80d036:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d03a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
  netif->flags = 0;
  80d041:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d045:	c6 40 4a 00          	movb   $0x0,0x4a(%rax)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  80d049:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d04d:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80d054:	00 
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  80d055:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d059:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80d05d:	48 89 50 30          	mov    %rdx,0x30(%rax)
  netif->num = netifnum++;
  80d061:	48 b8 4b b0 b4 00 00 	movabs $0xb4b04b,%rax
  80d068:	00 00 00 
  80d06b:	0f b6 00             	movzbl (%rax),%eax
  80d06e:	8d 48 01             	lea    0x1(%rax),%ecx
  80d071:	48 ba 4b b0 b4 00 00 	movabs $0xb4b04b,%rdx
  80d078:	00 00 00 
  80d07b:	88 0a                	mov    %cl,(%rdx)
  80d07d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d081:	88 42 4d             	mov    %al,0x4d(%rdx)
  netif->input = input;
  80d084:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d088:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80d08c:	48 89 50 18          	mov    %rdx,0x18(%rax)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  80d090:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80d094:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80d098:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80d09c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d0a0:	48 89 c7             	mov    %rax,%rdi
  80d0a3:	48 b8 f2 d0 80 00 00 	movabs $0x80d0f2,%rax
  80d0aa:	00 00 00 
  80d0ad:	ff d0                	callq  *%rax

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  80d0af:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d0b3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80d0b7:	48 89 d7             	mov    %rdx,%rdi
  80d0ba:	ff d0                	callq  *%rax
  80d0bc:	84 c0                	test   %al,%al
  80d0be:	74 07                	je     80d0c7 <netif_add+0xc7>
    return NULL;
  80d0c0:	b8 00 00 00 00       	mov    $0x0,%eax
  80d0c5:	eb 29                	jmp    80d0f0 <netif_add+0xf0>
  }

  /* add this netif to the list */
  netif->next = netif_list;
  80d0c7:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d0ce:	00 00 00 
  80d0d1:	48 8b 10             	mov    (%rax),%rdx
  80d0d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d0d8:	48 89 10             	mov    %rdx,(%rax)
  netif_list = netif;
  80d0db:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d0e2:	00 00 00 
  80d0e5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d0e9:	48 89 10             	mov    %rdx,(%rax)
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  80d0ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80d0f0:	c9                   	leaveq 
  80d0f1:	c3                   	retq   

000000000080d0f2 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  80d0f2:	55                   	push   %rbp
  80d0f3:	48 89 e5             	mov    %rsp,%rbp
  80d0f6:	48 83 ec 20          	sub    $0x20,%rsp
  80d0fa:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80d0fe:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80d102:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80d106:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  netif_set_ipaddr(netif, ipaddr);
  80d10a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80d10e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d112:	48 89 d6             	mov    %rdx,%rsi
  80d115:	48 89 c7             	mov    %rax,%rdi
  80d118:	48 b8 a4 d2 80 00 00 	movabs $0x80d2a4,%rax
  80d11f:	00 00 00 
  80d122:	ff d0                	callq  *%rax
  netif_set_netmask(netif, netmask);
  80d124:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80d128:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d12c:	48 89 d6             	mov    %rdx,%rsi
  80d12f:	48 89 c7             	mov    %rax,%rdi
  80d132:	48 b8 d9 d3 80 00 00 	movabs $0x80d3d9,%rax
  80d139:	00 00 00 
  80d13c:	ff d0                	callq  *%rax
  netif_set_gw(netif, gw);
  80d13e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80d142:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d146:	48 89 d6             	mov    %rdx,%rsi
  80d149:	48 89 c7             	mov    %rax,%rdi
  80d14c:	48 b8 ab d3 80 00 00 	movabs $0x80d3ab,%rax
  80d153:	00 00 00 
  80d156:	ff d0                	callq  *%rax
}
  80d158:	90                   	nop
  80d159:	c9                   	leaveq 
  80d15a:	c3                   	retq   

000000000080d15b <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  80d15b:	55                   	push   %rbp
  80d15c:	48 89 e5             	mov    %rsp,%rbp
  80d15f:	48 83 ec 20          	sub    $0x20,%rsp
  80d163:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if ( netif == NULL ) return;
  80d167:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d16c:	0f 84 98 00 00 00    	je     80d20a <netif_remove+0xaf>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  80d172:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d179:	00 00 00 
  80d17c:	48 8b 00             	mov    (%rax),%rax
  80d17f:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80d183:	75 16                	jne    80d19b <netif_remove+0x40>
    netif_list = netif->next;
  80d185:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d189:	48 8b 10             	mov    (%rax),%rdx
  80d18c:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d193:	00 00 00 
  80d196:	48 89 10             	mov    %rdx,(%rax)
  80d199:	eb 49                	jmp    80d1e4 <netif_remove+0x89>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80d19b:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d1a2:	00 00 00 
  80d1a5:	48 8b 00             	mov    (%rax),%rax
  80d1a8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d1ac:	eb 28                	jmp    80d1d6 <netif_remove+0x7b>
      if (tmpNetif->next == netif) {
  80d1ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d1b2:	48 8b 00             	mov    (%rax),%rax
  80d1b5:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80d1b9:	75 10                	jne    80d1cb <netif_remove+0x70>
        tmpNetif->next = netif->next;
  80d1bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d1bf:	48 8b 10             	mov    (%rax),%rdx
  80d1c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d1c6:	48 89 10             	mov    %rdx,(%rax)
        snmp_dec_iflist();
        break;
  80d1c9:	eb 12                	jmp    80d1dd <netif_remove+0x82>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80d1cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d1cf:	48 8b 00             	mov    (%rax),%rax
  80d1d2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d1d6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d1db:	75 d1                	jne    80d1ae <netif_remove+0x53>
        tmpNetif->next = netif->next;
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
  80d1dd:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d1e2:	74 29                	je     80d20d <netif_remove+0xb2>
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  80d1e4:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  80d1eb:	00 00 00 
  80d1ee:	48 8b 00             	mov    (%rax),%rax
  80d1f1:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80d1f5:	75 17                	jne    80d20e <netif_remove+0xb3>
    /* reset default netif */
    netif_set_default(NULL);
  80d1f7:	bf 00 00 00 00       	mov    $0x0,%edi
  80d1fc:	48 b8 07 d4 80 00 00 	movabs $0x80d407,%rax
  80d203:	00 00 00 
  80d206:	ff d0                	callq  *%rax
  80d208:	eb 04                	jmp    80d20e <netif_remove+0xb3>
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  if ( netif == NULL ) return;
  80d20a:	90                   	nop
  80d20b:	eb 01                	jmp    80d20e <netif_remove+0xb3>
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  80d20d:	90                   	nop
  /* this netif is default? */
  if (netif_default == netif)
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  80d20e:	c9                   	leaveq 
  80d20f:	c3                   	retq   

000000000080d210 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  80d210:	55                   	push   %rbp
  80d211:	48 89 e5             	mov    %rsp,%rbp
  80d214:	48 83 ec 18          	sub    $0x18,%rsp
  80d218:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  80d21c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d221:	75 07                	jne    80d22a <netif_find+0x1a>
    return NULL;
  80d223:	b8 00 00 00 00       	mov    $0x0,%eax
  80d228:	eb 78                	jmp    80d2a2 <netif_find+0x92>
  }

  num = name[2] - '0';
  80d22a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d22e:	48 83 c0 02          	add    $0x2,%rax
  80d232:	0f b6 00             	movzbl (%rax),%eax
  80d235:	83 e8 30             	sub    $0x30,%eax
  80d238:	88 45 f7             	mov    %al,-0x9(%rbp)

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80d23b:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80d242:	00 00 00 
  80d245:	48 8b 00             	mov    (%rax),%rax
  80d248:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d24c:	eb 48                	jmp    80d296 <netif_find+0x86>
    if (num == netif->num &&
  80d24e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d252:	0f b6 40 4d          	movzbl 0x4d(%rax),%eax
  80d256:	3a 45 f7             	cmp    -0x9(%rbp),%al
  80d259:	75 30                	jne    80d28b <netif_find+0x7b>
       name[0] == netif->name[0] &&
  80d25b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d25f:	0f b6 10             	movzbl (%rax),%edx
  80d262:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d266:	0f b6 40 4b          	movzbl 0x4b(%rax),%eax
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
  80d26a:	38 c2                	cmp    %al,%dl
  80d26c:	75 1d                	jne    80d28b <netif_find+0x7b>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
  80d26e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d272:	48 83 c0 01          	add    $0x1,%rax
  80d276:	0f b6 10             	movzbl (%rax),%edx
  80d279:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d27d:	0f b6 40 4c          	movzbl 0x4c(%rax),%eax

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
       name[0] == netif->name[0] &&
  80d281:	38 c2                	cmp    %al,%dl
  80d283:	75 06                	jne    80d28b <netif_find+0x7b>
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
  80d285:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d289:	eb 17                	jmp    80d2a2 <netif_find+0x92>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80d28b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d28f:	48 8b 00             	mov    (%rax),%rax
  80d292:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d296:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d29b:	75 b1                	jne    80d24e <netif_find+0x3e>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
  80d29d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80d2a2:	c9                   	leaveq 
  80d2a3:	c3                   	retq   

000000000080d2a4 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  80d2a4:	55                   	push   %rbp
  80d2a5:	48 89 e5             	mov    %rsp,%rbp
  80d2a8:	48 83 ec 30          	sub    $0x30,%rsp
  80d2ac:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80d2b0:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  80d2b4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80d2b8:	8b 10                	mov    (%rax),%edx
  80d2ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d2be:	8b 40 08             	mov    0x8(%rax),%eax
  80d2c1:	39 c2                	cmp    %eax,%edx
  80d2c3:	0f 84 c4 00 00 00    	je     80d38d <netif_set_ipaddr+0xe9>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  80d2c9:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80d2d0:	00 00 00 
  80d2d3:	48 8b 00             	mov    (%rax),%rax
  80d2d6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (pcb != NULL) {
  80d2da:	eb 46                	jmp    80d322 <netif_set_ipaddr+0x7e>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80d2dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d2e0:	8b 10                	mov    (%rax),%edx
  80d2e2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d2e6:	8b 40 08             	mov    0x8(%rax),%eax
  80d2e9:	39 c2                	cmp    %eax,%edx
  80d2eb:	75 29                	jne    80d316 <netif_set_ipaddr+0x72>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  80d2ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d2f1:	48 8b 40 10          	mov    0x10(%rax),%rax
  80d2f5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  80d2f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d2fd:	48 89 c7             	mov    %rax,%rdi
  80d300:	48 b8 97 ef 80 00 00 	movabs $0x80ef97,%rax
  80d307:	00 00 00 
  80d30a:	ff d0                	callq  *%rax
        pcb = next;
  80d30c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d310:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d314:	eb 0c                	jmp    80d322 <netif_set_ipaddr+0x7e>
      } else {
        pcb = pcb->next;
  80d316:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d31a:	48 8b 40 10          	mov    0x10(%rax),%rax
  80d31e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  80d322:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d327:	75 b3                	jne    80d2dc <netif_set_ipaddr+0x38>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d329:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80d330:	00 00 00 
  80d333:	48 8b 00             	mov    (%rax),%rax
  80d336:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80d33a:	eb 4a                	jmp    80d386 <netif_set_ipaddr+0xe2>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80d33c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d340:	48 85 c0             	test   %rax,%rax
  80d343:	74 35                	je     80d37a <netif_set_ipaddr+0xd6>
  80d345:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d349:	8b 00                	mov    (%rax),%eax
  80d34b:	85 c0                	test   %eax,%eax
  80d34d:	74 2b                	je     80d37a <netif_set_ipaddr+0xd6>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
  80d34f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d353:	8b 10                	mov    (%rax),%edx
  80d355:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d359:	8b 40 08             	mov    0x8(%rax),%eax
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80d35c:	39 c2                	cmp    %eax,%edx
  80d35e:	75 1a                	jne    80d37a <netif_set_ipaddr+0xd6>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  80d360:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80d365:	74 08                	je     80d36f <netif_set_ipaddr+0xcb>
  80d367:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80d36b:	8b 00                	mov    (%rax),%eax
  80d36d:	eb 05                	jmp    80d374 <netif_set_ipaddr+0xd0>
  80d36f:	b8 00 00 00 00       	mov    $0x0,%eax
  80d374:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80d378:	89 02                	mov    %eax,(%rdx)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d37a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d37e:	48 8b 40 10          	mov    0x10(%rax),%rax
  80d382:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80d386:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80d38b:	75 af                	jne    80d33c <netif_set_ipaddr+0x98>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  80d38d:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80d392:	74 08                	je     80d39c <netif_set_ipaddr+0xf8>
  80d394:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80d398:	8b 00                	mov    (%rax),%eax
  80d39a:	eb 05                	jmp    80d3a1 <netif_set_ipaddr+0xfd>
  80d39c:	b8 00 00 00 00       	mov    $0x0,%eax
  80d3a1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80d3a5:	89 42 08             	mov    %eax,0x8(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  80d3a8:	90                   	nop
  80d3a9:	c9                   	leaveq 
  80d3aa:	c3                   	retq   

000000000080d3ab <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  80d3ab:	55                   	push   %rbp
  80d3ac:	48 89 e5             	mov    %rsp,%rbp
  80d3af:	48 83 ec 10          	sub    $0x10,%rsp
  80d3b3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80d3b7:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&(netif->gw), gw);
  80d3bb:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80d3c0:	74 08                	je     80d3ca <netif_set_gw+0x1f>
  80d3c2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d3c6:	8b 00                	mov    (%rax),%eax
  80d3c8:	eb 05                	jmp    80d3cf <netif_set_gw+0x24>
  80d3ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80d3cf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d3d3:	89 42 10             	mov    %eax,0x10(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  80d3d6:	90                   	nop
  80d3d7:	c9                   	leaveq 
  80d3d8:	c3                   	retq   

000000000080d3d9 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  80d3d9:	55                   	push   %rbp
  80d3da:	48 89 e5             	mov    %rsp,%rbp
  80d3dd:	48 83 ec 10          	sub    $0x10,%rsp
  80d3e1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80d3e5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  80d3e9:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80d3ee:	74 08                	je     80d3f8 <netif_set_netmask+0x1f>
  80d3f0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d3f4:	8b 00                	mov    (%rax),%eax
  80d3f6:	eb 05                	jmp    80d3fd <netif_set_netmask+0x24>
  80d3f8:	b8 00 00 00 00       	mov    $0x0,%eax
  80d3fd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d401:	89 42 0c             	mov    %eax,0xc(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  80d404:	90                   	nop
  80d405:	c9                   	leaveq 
  80d406:	c3                   	retq   

000000000080d407 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  80d407:	55                   	push   %rbp
  80d408:	48 89 e5             	mov    %rsp,%rbp
  80d40b:	48 83 ec 08          	sub    $0x8,%rsp
  80d40f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  80d413:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  80d41a:	00 00 00 
  80d41d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80d421:	48 89 10             	mov    %rdx,(%rax)
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  80d424:	90                   	nop
  80d425:	c9                   	leaveq 
  80d426:	c3                   	retq   

000000000080d427 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  80d427:	55                   	push   %rbp
  80d428:	48 89 e5             	mov    %rsp,%rbp
  80d42b:	48 83 ec 10          	sub    $0x10,%rsp
  80d42f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  80d433:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d437:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d43b:	0f b6 c0             	movzbl %al,%eax
  80d43e:	83 e0 01             	and    $0x1,%eax
  80d441:	85 c0                	test   %eax,%eax
  80d443:	75 49                	jne    80d48e <netif_set_up+0x67>
    netif->flags |= NETIF_FLAG_UP;
  80d445:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d449:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d44d:	83 c8 01             	or     $0x1,%eax
  80d450:	89 c2                	mov    %eax,%edx
  80d452:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d456:	88 50 4a             	mov    %dl,0x4a(%rax)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  80d459:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d45d:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d461:	0f b6 c0             	movzbl %al,%eax
  80d464:	83 e0 20             	and    $0x20,%eax
  80d467:	85 c0                	test   %eax,%eax
  80d469:	74 23                	je     80d48e <netif_set_up+0x67>
      etharp_query(netif, &(netif->ip_addr), NULL);
  80d46b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d46f:	48 8d 48 08          	lea    0x8(%rax),%rcx
  80d473:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d477:	ba 00 00 00 00       	mov    $0x0,%edx
  80d47c:	48 89 ce             	mov    %rcx,%rsi
  80d47f:	48 89 c7             	mov    %rax,%rdi
  80d482:	48 b8 75 6d 81 00 00 	movabs $0x816d75,%rax
  80d489:	00 00 00 
  80d48c:	ff d0                	callq  *%rax
    }
#endif /* LWIP_ARP */
    
  }
}
  80d48e:	90                   	nop
  80d48f:	c9                   	leaveq 
  80d490:	c3                   	retq   

000000000080d491 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  80d491:	55                   	push   %rbp
  80d492:	48 89 e5             	mov    %rsp,%rbp
  80d495:	48 83 ec 08          	sub    $0x8,%rsp
  80d499:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if ( netif->flags & NETIF_FLAG_UP )
  80d49d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4a1:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d4a5:	0f b6 c0             	movzbl %al,%eax
  80d4a8:	83 e0 01             	and    $0x1,%eax
  80d4ab:	85 c0                	test   %eax,%eax
  80d4ad:	74 14                	je     80d4c3 <netif_set_down+0x32>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  80d4af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4b3:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d4b7:	83 e0 fe             	and    $0xfffffffe,%eax
  80d4ba:	89 c2                	mov    %eax,%edx
  80d4bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4c0:	88 50 4a             	mov    %dl,0x4a(%rax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  80d4c3:	90                   	nop
  80d4c4:	c9                   	leaveq 
  80d4c5:	c3                   	retq   

000000000080d4c6 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  80d4c6:	55                   	push   %rbp
  80d4c7:	48 89 e5             	mov    %rsp,%rbp
  80d4ca:	48 83 ec 08          	sub    $0x8,%rsp
  80d4ce:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  80d4d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4d6:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d4da:	0f b6 c0             	movzbl %al,%eax
  80d4dd:	83 e0 01             	and    $0x1,%eax
  80d4e0:	85 c0                	test   %eax,%eax
  80d4e2:	0f 95 c0             	setne  %al
}
  80d4e5:	c9                   	leaveq 
  80d4e6:	c3                   	retq   

000000000080d4e7 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  80d4e7:	55                   	push   %rbp
  80d4e8:	48 89 e5             	mov    %rsp,%rbp
  80d4eb:	48 83 ec 30          	sub    $0x30,%rsp
  80d4ef:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80d4f2:	89 f0                	mov    %esi,%eax
  80d4f4:	89 55 d4             	mov    %edx,-0x2c(%rbp)
  80d4f7:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  80d4fb:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  switch (layer) {
  80d501:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80d504:	83 f8 01             	cmp    $0x1,%eax
  80d507:	74 16                	je     80d51f <pbuf_alloc+0x38>
  80d509:	83 f8 01             	cmp    $0x1,%eax
  80d50c:	72 0c                	jb     80d51a <pbuf_alloc+0x33>
  80d50e:	83 f8 02             	cmp    $0x2,%eax
  80d511:	74 11                	je     80d524 <pbuf_alloc+0x3d>
  80d513:	83 f8 03             	cmp    $0x3,%eax
  80d516:	74 3d                	je     80d555 <pbuf_alloc+0x6e>
  80d518:	eb 11                	jmp    80d52b <pbuf_alloc+0x44>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  80d51a:	66 83 45 ee 14       	addw   $0x14,-0x12(%rbp)
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  80d51f:	66 83 45 ee 14       	addw   $0x14,-0x12(%rbp)
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  80d524:	66 83 45 ee 0e       	addw   $0xe,-0x12(%rbp)
    break;
  80d529:	eb 2b                	jmp    80d556 <pbuf_alloc+0x6f>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  80d52b:	48 ba 30 22 82 00 00 	movabs $0x822230,%rdx
  80d532:	00 00 00 
  80d535:	be 8b 00 00 00       	mov    $0x8b,%esi
  80d53a:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80d541:	00 00 00 
  80d544:	b8 00 00 00 00       	mov    $0x0,%eax
  80d549:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80d550:	00 00 00 
  80d553:	ff d1                	callq  *%rcx
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    break;
  80d555:	90                   	nop
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
  80d556:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d559:	83 f8 02             	cmp    $0x2,%eax
  80d55c:	77 0e                	ja     80d56c <pbuf_alloc+0x85>
  80d55e:	83 f8 01             	cmp    $0x1,%eax
  80d561:	0f 83 a9 03 00 00    	jae    80d910 <pbuf_alloc+0x429>
  80d567:	e9 d6 02 00 00       	jmpq   80d842 <pbuf_alloc+0x35b>
  80d56c:	83 f8 03             	cmp    $0x3,%eax
  80d56f:	0f 85 02 04 00 00    	jne    80d977 <pbuf_alloc+0x490>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  80d575:	bf 0d 00 00 00       	mov    $0xd,%edi
  80d57a:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  80d581:	00 00 00 
  80d584:	ff d0                	callq  *%rax
  80d586:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  80d58a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d58f:	75 0a                	jne    80d59b <pbuf_alloc+0xb4>
      return NULL;
  80d591:	b8 00 00 00 00       	mov    $0x0,%eax
  80d596:	e9 1d 04 00 00       	jmpq   80d9b8 <pbuf_alloc+0x4d1>
    }
    p->type = type;
  80d59b:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d59e:	89 c2                	mov    %eax,%edx
  80d5a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d5a4:	88 50 14             	mov    %dl,0x14(%rax)
    p->next = NULL;
  80d5a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d5ab:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  80d5b2:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d5b6:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80d5ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d5be:	48 01 d0             	add    %rdx,%rax
  80d5c1:	48 83 c0 03          	add    $0x3,%rax
  80d5c5:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80d5c9:	48 89 c2             	mov    %rax,%rdx
  80d5cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d5d0:	48 89 50 08          	mov    %rdx,0x8(%rax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
  80d5d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d5d8:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d5dc:	83 e0 03             	and    $0x3,%eax
  80d5df:	48 85 c0             	test   %rax,%rax
  80d5e2:	74 2a                	je     80d60e <pbuf_alloc+0x127>
  80d5e4:	48 ba 60 22 82 00 00 	movabs $0x822260,%rdx
  80d5eb:	00 00 00 
  80d5ee:	be 9d 00 00 00       	mov    $0x9d,%esi
  80d5f3:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80d5fa:	00 00 00 
  80d5fd:	b8 00 00 00 00       	mov    $0x0,%eax
  80d602:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80d609:	00 00 00 
  80d60c:	ff d1                	callq  *%rcx
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  80d60e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d612:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d616:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  80d61a:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d61e:	83 c0 03             	add    $0x3,%eax
  80d621:	83 e0 fc             	and    $0xfffffffc,%eax
  80d624:	ba d0 07 00 00       	mov    $0x7d0,%edx
  80d629:	29 c2                	sub    %eax,%edx
  80d62b:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  80d62f:	39 c2                	cmp    %eax,%edx
  80d631:	0f 4e c2             	cmovle %edx,%eax
  80d634:	89 c2                	mov    %eax,%edx
  80d636:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d63a:	66 89 50 12          	mov    %dx,0x12(%rax)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80d63e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d642:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80d646:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d64a:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d64e:	0f b7 c0             	movzwl %ax,%eax
  80d651:	48 01 c2             	add    %rax,%rdx
  80d654:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d658:	48 05 e8 07 00 00    	add    $0x7e8,%rax
  80d65e:	48 39 c2             	cmp    %rax,%rdx
  80d661:	76 2a                	jbe    80d68d <pbuf_alloc+0x1a6>
  80d663:	48 ba 90 22 82 00 00 	movabs $0x822290,%rdx
  80d66a:	00 00 00 
  80d66d:	be a4 00 00 00       	mov    $0xa4,%esi
  80d672:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80d679:	00 00 00 
  80d67c:	b8 00 00 00 00       	mov    $0x0,%eax
  80d681:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80d688:	00 00 00 
  80d68b:	ff d1                	callq  *%rcx
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  80d68d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d691:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  80d697:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d69b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* remaining length to be allocated */
    rem_len = length - p->len;
  80d69f:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d6a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d6a7:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d6ab:	0f b7 c0             	movzwl %ax,%eax
  80d6ae:	29 c2                	sub    %eax,%edx
  80d6b0:	89 d0                	mov    %edx,%eax
  80d6b2:	89 45 e8             	mov    %eax,-0x18(%rbp)
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  80d6b5:	e9 79 01 00 00       	jmpq   80d833 <pbuf_alloc+0x34c>
      q = memp_malloc(MEMP_PBUF_POOL);
  80d6ba:	bf 0d 00 00 00       	mov    $0xd,%edi
  80d6bf:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  80d6c6:	00 00 00 
  80d6c9:	ff d0                	callq  *%rax
  80d6cb:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      if (q == NULL) {
  80d6cf:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80d6d4:	75 1d                	jne    80d6f3 <pbuf_alloc+0x20c>
        /* free chain so far allocated */
        pbuf_free(p);
  80d6d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d6da:	48 89 c7             	mov    %rax,%rdi
  80d6dd:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  80d6e4:	00 00 00 
  80d6e7:	ff d0                	callq  *%rax
        /* bail out unsuccesfully */
        return NULL;
  80d6e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80d6ee:	e9 c5 02 00 00       	jmpq   80d9b8 <pbuf_alloc+0x4d1>
      }
      q->type = type;
  80d6f3:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d6f6:	89 c2                	mov    %eax,%edx
  80d6f8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d6fc:	88 50 14             	mov    %dl,0x14(%rax)
      q->flags = 0;
  80d6ff:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d703:	c6 40 15 00          	movb   $0x0,0x15(%rax)
      q->next = NULL;
  80d707:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d70b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  80d712:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d716:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80d71a:	48 89 10             	mov    %rdx,(%rax)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  80d71d:	81 7d e8 fe ff 00 00 	cmpl   $0xfffe,-0x18(%rbp)
  80d724:	7e 2a                	jle    80d750 <pbuf_alloc+0x269>
  80d726:	48 ba c1 22 82 00 00 	movabs $0x8222c1,%rdx
  80d72d:	00 00 00 
  80d730:	be bd 00 00 00       	mov    $0xbd,%esi
  80d735:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80d73c:	00 00 00 
  80d73f:	b8 00 00 00 00       	mov    $0x0,%eax
  80d744:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80d74b:	00 00 00 
  80d74e:	ff d1                	callq  *%rcx
      q->tot_len = (u16_t)rem_len;
  80d750:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80d753:	89 c2                	mov    %eax,%edx
  80d755:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d759:	66 89 50 10          	mov    %dx,0x10(%rax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  80d75d:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80d760:	0f b7 c0             	movzwl %ax,%eax
  80d763:	ba d0 07 00 00       	mov    $0x7d0,%edx
  80d768:	3d d0 07 00 00       	cmp    $0x7d0,%eax
  80d76d:	0f 4f c2             	cmovg  %edx,%eax
  80d770:	89 c2                	mov    %eax,%edx
  80d772:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d776:	66 89 50 12          	mov    %dx,0x12(%rax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  80d77a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d77e:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80d782:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d786:	48 89 50 08          	mov    %rdx,0x8(%rax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  80d78a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d78e:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d792:	83 e0 03             	and    $0x3,%eax
  80d795:	48 85 c0             	test   %rax,%rax
  80d798:	74 2a                	je     80d7c4 <pbuf_alloc+0x2dd>
  80d79a:	48 ba d8 22 82 00 00 	movabs $0x8222d8,%rdx
  80d7a1:	00 00 00 
  80d7a4:	be c3 00 00 00       	mov    $0xc3,%esi
  80d7a9:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80d7b0:	00 00 00 
  80d7b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80d7b8:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80d7bf:	00 00 00 
  80d7c2:	ff d1                	callq  *%rcx
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80d7c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d7c8:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80d7cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d7d0:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d7d4:	0f b7 c0             	movzwl %ax,%eax
  80d7d7:	48 01 c2             	add    %rax,%rdx
  80d7da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d7de:	48 05 e8 07 00 00    	add    $0x7e8,%rax
  80d7e4:	48 39 c2             	cmp    %rax,%rdx
  80d7e7:	76 2a                	jbe    80d813 <pbuf_alloc+0x32c>
  80d7e9:	48 ba 90 22 82 00 00 	movabs $0x822290,%rdx
  80d7f0:	00 00 00 
  80d7f3:	be c6 00 00 00       	mov    $0xc6,%esi
  80d7f8:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80d7ff:	00 00 00 
  80d802:	b8 00 00 00 00       	mov    $0x0,%eax
  80d807:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80d80e:	00 00 00 
  80d811:	ff d1                	callq  *%rcx
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  80d813:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d817:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  80d81d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d821:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d825:	0f b7 c0             	movzwl %ax,%eax
  80d828:	29 45 e8             	sub    %eax,-0x18(%rbp)
      /* remember this pbuf for linkage in next iteration */
      r = q;
  80d82b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d82f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  80d833:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80d837:	0f 8f 7d fe ff ff    	jg     80d6ba <pbuf_alloc+0x1d3>
      r = q;
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
  80d83d:	e9 60 01 00 00       	jmpq   80d9a2 <pbuf_alloc+0x4bb>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  80d842:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d846:	83 c0 1b             	add    $0x1b,%eax
  80d849:	83 e0 fc             	and    $0xfffffffc,%eax
  80d84c:	89 c2                	mov    %eax,%edx
  80d84e:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  80d852:	83 c0 03             	add    $0x3,%eax
  80d855:	83 e0 fc             	and    $0xfffffffc,%eax
  80d858:	01 d0                	add    %edx,%eax
  80d85a:	89 c7                	mov    %eax,%edi
  80d85c:	48 b8 10 ca 80 00 00 	movabs $0x80ca10,%rax
  80d863:	00 00 00 
  80d866:	ff d0                	callq  *%rax
  80d868:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (p == NULL) {
  80d86c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d871:	75 0a                	jne    80d87d <pbuf_alloc+0x396>
      return NULL;
  80d873:	b8 00 00 00 00       	mov    $0x0,%eax
  80d878:	e9 3b 01 00 00       	jmpq   80d9b8 <pbuf_alloc+0x4d1>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  80d87d:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d881:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80d885:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d889:	48 01 d0             	add    %rdx,%rax
  80d88c:	48 83 c0 03          	add    $0x3,%rax
  80d890:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80d894:	48 89 c2             	mov    %rax,%rdx
  80d897:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d89b:	48 89 50 08          	mov    %rdx,0x8(%rax)
    p->len = p->tot_len = length;
  80d89f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d8a3:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d8a7:	66 89 50 10          	mov    %dx,0x10(%rax)
  80d8ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d8af:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d8b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d8b7:	66 89 50 12          	mov    %dx,0x12(%rax)
    p->next = NULL;
  80d8bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d8bf:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    p->type = type;
  80d8c6:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d8c9:	89 c2                	mov    %eax,%edx
  80d8cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d8cf:	88 50 14             	mov    %dl,0x14(%rax)

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
  80d8d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d8d6:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d8da:	83 e0 03             	and    $0x3,%eax
  80d8dd:	48 85 c0             	test   %rax,%rax
  80d8e0:	0f 84 bb 00 00 00    	je     80d9a1 <pbuf_alloc+0x4ba>
  80d8e6:	48 ba 08 23 82 00 00 	movabs $0x822308,%rdx
  80d8ed:	00 00 00 
  80d8f0:	be de 00 00 00       	mov    $0xde,%esi
  80d8f5:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80d8fc:	00 00 00 
  80d8ff:	b8 00 00 00 00       	mov    $0x0,%eax
  80d904:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80d90b:	00 00 00 
  80d90e:	ff d1                	callq  *%rcx
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  80d910:	bf 0c 00 00 00       	mov    $0xc,%edi
  80d915:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  80d91c:	00 00 00 
  80d91f:	ff d0                	callq  *%rax
  80d921:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (p == NULL) {
  80d925:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d92a:	75 0a                	jne    80d936 <pbuf_alloc+0x44f>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
  80d92c:	b8 00 00 00 00       	mov    $0x0,%eax
  80d931:	e9 82 00 00 00       	jmpq   80d9b8 <pbuf_alloc+0x4d1>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  80d936:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d93a:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80d941:	00 
    p->len = p->tot_len = length;
  80d942:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d946:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d94a:	66 89 50 10          	mov    %dx,0x10(%rax)
  80d94e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d952:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d956:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d95a:	66 89 50 12          	mov    %dx,0x12(%rax)
    p->next = NULL;
  80d95e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d962:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    p->type = type;
  80d969:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d96c:	89 c2                	mov    %eax,%edx
  80d96e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d972:	88 50 14             	mov    %dl,0x14(%rax)
    break;
  80d975:	eb 2b                	jmp    80d9a2 <pbuf_alloc+0x4bb>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  80d977:	48 ba 33 23 82 00 00 	movabs $0x822333,%rdx
  80d97e:	00 00 00 
  80d981:	be f2 00 00 00       	mov    $0xf2,%esi
  80d986:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80d98d:	00 00 00 
  80d990:	b8 00 00 00 00       	mov    $0x0,%eax
  80d995:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80d99c:	00 00 00 
  80d99f:	ff d1                	callq  *%rcx
    p->next = NULL;
    p->type = type;

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
  80d9a1:	90                   	nop
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  80d9a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d9a6:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)
  /* set flags */
  p->flags = 0;
  80d9ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d9b0:	c6 40 15 00          	movb   $0x0,0x15(%rax)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
  80d9b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80d9b8:	c9                   	leaveq 
  80d9b9:	c3                   	retq   

000000000080d9ba <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  80d9ba:	55                   	push   %rbp
  80d9bb:	48 89 e5             	mov    %rsp,%rbp
  80d9be:	48 83 ec 20          	sub    $0x20,%rsp
  80d9c2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80d9c6:	89 f0                	mov    %esi,%eax
  80d9c8:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  80d9cc:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d9d1:	75 2a                	jne    80d9fd <pbuf_realloc+0x43>
  80d9d3:	48 ba 4e 23 82 00 00 	movabs $0x82234e,%rdx
  80d9da:	00 00 00 
  80d9dd:	be 14 01 00 00       	mov    $0x114,%esi
  80d9e2:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80d9e9:	00 00 00 
  80d9ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80d9f1:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80d9f8:	00 00 00 
  80d9fb:	ff d1                	callq  *%rcx
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  80d9fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80da01:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80da05:	3c 03                	cmp    $0x3,%al
  80da07:	74 4e                	je     80da57 <pbuf_realloc+0x9d>
  80da09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80da0d:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80da11:	3c 01                	cmp    $0x1,%al
  80da13:	74 42                	je     80da57 <pbuf_realloc+0x9d>
  80da15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80da19:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80da1d:	84 c0                	test   %al,%al
  80da1f:	74 36                	je     80da57 <pbuf_realloc+0x9d>
  80da21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80da25:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80da29:	3c 02                	cmp    $0x2,%al
  80da2b:	74 2a                	je     80da57 <pbuf_realloc+0x9d>
  80da2d:	48 ba 66 23 82 00 00 	movabs $0x822366,%rdx
  80da34:	00 00 00 
  80da37:	be 18 01 00 00       	mov    $0x118,%esi
  80da3c:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80da43:	00 00 00 
  80da46:	b8 00 00 00 00       	mov    $0x0,%eax
  80da4b:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80da52:	00 00 00 
  80da55:	ff d1                	callq  *%rcx
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  80da57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80da5b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80da5f:	66 3b 45 e4          	cmp    -0x1c(%rbp),%ax
  80da63:	0f 86 99 01 00 00    	jbe    80dc02 <pbuf_realloc+0x248>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  80da69:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  80da6d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80da71:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80da75:	0f b7 c0             	movzwl %ax,%eax
  80da78:	29 c2                	sub    %eax,%edx
  80da7a:	89 d0                	mov    %edx,%eax
  80da7c:	89 45 f0             	mov    %eax,-0x10(%rbp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  80da7f:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80da83:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  q = p;
  80da87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80da8b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  80da8f:	e9 90 00 00 00       	jmpq   80db24 <pbuf_realloc+0x16a>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  80da94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da98:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80da9c:	66 29 45 f6          	sub    %ax,-0xa(%rbp)
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  80daa0:	81 7d f0 fe ff 00 00 	cmpl   $0xfffe,-0x10(%rbp)
  80daa7:	7e 2a                	jle    80dad3 <pbuf_realloc+0x119>
  80daa9:	48 ba 81 23 82 00 00 	movabs $0x822381,%rdx
  80dab0:	00 00 00 
  80dab3:	be 2c 01 00 00       	mov    $0x12c,%esi
  80dab8:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80dabf:	00 00 00 
  80dac2:	b8 00 00 00 00       	mov    $0x0,%eax
  80dac7:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80dace:	00 00 00 
  80dad1:	ff d1                	callq  *%rcx
    q->tot_len += (u16_t)grow;
  80dad3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dad7:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80dadb:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80dade:	01 c2                	add    %eax,%edx
  80dae0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dae4:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* proceed to next pbuf in chain */
    q = q->next;
  80dae8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80daec:	48 8b 00             	mov    (%rax),%rax
  80daef:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  80daf3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80daf8:	75 2a                	jne    80db24 <pbuf_realloc+0x16a>
  80dafa:	48 ba 92 23 82 00 00 	movabs $0x822392,%rdx
  80db01:	00 00 00 
  80db04:	be 30 01 00 00       	mov    $0x130,%esi
  80db09:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80db10:	00 00 00 
  80db13:	b8 00 00 00 00       	mov    $0x0,%eax
  80db18:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80db1f:	00 00 00 
  80db22:	ff d1                	callq  *%rcx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  80db24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db28:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80db2c:	66 3b 45 f6          	cmp    -0xa(%rbp),%ax
  80db30:	0f 82 5e ff ff ff    	jb     80da94 <pbuf_realloc+0xda>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  80db36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db3a:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80db3e:	84 c0                	test   %al,%al
  80db40:	75 75                	jne    80dbb7 <pbuf_realloc+0x1fd>
  80db42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db46:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80db4a:	66 3b 45 f6          	cmp    -0xa(%rbp),%ax
  80db4e:	74 67                	je     80dbb7 <pbuf_realloc+0x1fd>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  80db50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db54:	48 8b 40 08          	mov    0x8(%rax),%rax
  80db58:	48 89 c2             	mov    %rax,%rdx
  80db5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db5f:	48 29 c2             	sub    %rax,%rdx
  80db62:	48 89 d0             	mov    %rdx,%rax
  80db65:	89 c2                	mov    %eax,%edx
  80db67:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80db6b:	01 c2                	add    %eax,%edx
  80db6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db71:	89 d6                	mov    %edx,%esi
  80db73:	48 89 c7             	mov    %rax,%rdi
  80db76:	48 b8 fa c6 80 00 00 	movabs $0x80c6fa,%rax
  80db7d:	00 00 00 
  80db80:	ff d0                	callq  *%rax
  80db82:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  80db86:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80db8b:	75 2a                	jne    80dbb7 <pbuf_realloc+0x1fd>
  80db8d:	48 ba aa 23 82 00 00 	movabs $0x8223aa,%rdx
  80db94:	00 00 00 
  80db97:	be 3a 01 00 00       	mov    $0x13a,%esi
  80db9c:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80dba3:	00 00 00 
  80dba6:	b8 00 00 00 00       	mov    $0x0,%eax
  80dbab:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80dbb2:	00 00 00 
  80dbb5:	ff d1                	callq  *%rcx
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  80dbb7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dbbb:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80dbbf:	66 89 50 12          	mov    %dx,0x12(%rax)
  q->tot_len = q->len;
  80dbc3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dbc7:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80dbcb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dbcf:	66 89 50 10          	mov    %dx,0x10(%rax)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  80dbd3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dbd7:	48 8b 00             	mov    (%rax),%rax
  80dbda:	48 85 c0             	test   %rax,%rax
  80dbdd:	74 16                	je     80dbf5 <pbuf_realloc+0x23b>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  80dbdf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dbe3:	48 8b 00             	mov    (%rax),%rax
  80dbe6:	48 89 c7             	mov    %rax,%rdi
  80dbe9:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  80dbf0:	00 00 00 
  80dbf3:	ff d0                	callq  *%rax
  }
  /* q is last packet in chain */
  q->next = NULL;
  80dbf5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dbf9:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  80dc00:	eb 01                	jmp    80dc03 <pbuf_realloc+0x249>
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    /* enlarging not yet supported */
    return;
  80dc02:	90                   	nop
    pbuf_free(q->next);
  }
  /* q is last packet in chain */
  q->next = NULL;

}
  80dc03:	c9                   	leaveq 
  80dc04:	c3                   	retq   

000000000080dc05 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  80dc05:	55                   	push   %rbp
  80dc06:	48 89 e5             	mov    %rsp,%rbp
  80dc09:	48 83 ec 20          	sub    $0x20,%rsp
  80dc0d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80dc11:	89 f0                	mov    %esi,%eax
  80dc13:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  80dc17:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80dc1c:	75 2a                	jne    80dc48 <pbuf_header+0x43>
  80dc1e:	48 ba c5 23 82 00 00 	movabs $0x8223c5,%rdx
  80dc25:	00 00 00 
  80dc28:	be 65 01 00 00       	mov    $0x165,%esi
  80dc2d:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80dc34:	00 00 00 
  80dc37:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc3c:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80dc43:	00 00 00 
  80dc46:	ff d1                	callq  *%rcx
  if ((header_size_increment == 0) || (p == NULL))
  80dc48:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80dc4d:	74 07                	je     80dc56 <pbuf_header+0x51>
  80dc4f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80dc54:	75 0a                	jne    80dc60 <pbuf_header+0x5b>
    return 0;
  80dc56:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc5b:	e9 66 01 00 00       	jmpq   80ddc6 <pbuf_header+0x1c1>
 
  if (header_size_increment < 0){
  80dc60:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80dc65:	79 42                	jns    80dca9 <pbuf_header+0xa4>
    increment_magnitude = -header_size_increment;
  80dc67:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80dc6b:	f7 d8                	neg    %eax
  80dc6d:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  80dc71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dc75:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dc79:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80dc7d:	73 32                	jae    80dcb1 <pbuf_header+0xac>
  80dc7f:	48 ba cf 23 82 00 00 	movabs $0x8223cf,%rdx
  80dc86:	00 00 00 
  80dc89:	be 6c 01 00 00       	mov    $0x16c,%esi
  80dc8e:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80dc95:	00 00 00 
  80dc98:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc9d:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80dca4:	00 00 00 
  80dca7:	ff d1                	callq  *%rcx
  } else {
    increment_magnitude = header_size_increment;
  80dca9:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80dcad:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  80dcb1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dcb5:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80dcb9:	0f b6 c0             	movzbl %al,%eax
  80dcbc:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  /* remember current payload pointer */
  payload = p->payload;
  80dcc0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dcc4:	48 8b 40 08          	mov    0x8(%rax),%rax
  80dcc8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  80dccc:	66 83 7d fc 00       	cmpw   $0x0,-0x4(%rbp)
  80dcd1:	74 07                	je     80dcda <pbuf_header+0xd5>
  80dcd3:	66 83 7d fc 03       	cmpw   $0x3,-0x4(%rbp)
  80dcd8:	75 4a                	jne    80dd24 <pbuf_header+0x11f>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  80dcda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dcde:	48 8b 40 08          	mov    0x8(%rax),%rax
  80dce2:	48 0f bf 55 e4       	movswq -0x1c(%rbp),%rdx
  80dce7:	48 f7 da             	neg    %rdx
  80dcea:	48 01 c2             	add    %rax,%rdx
  80dced:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dcf1:	48 89 50 08          	mov    %rdx,0x8(%rax)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  80dcf5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dcf9:	48 8b 40 08          	mov    0x8(%rax),%rax
  80dcfd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80dd01:	48 83 c2 18          	add    $0x18,%rdx
  80dd05:	48 39 d0             	cmp    %rdx,%rax
  80dd08:	0f 83 87 00 00 00    	jae    80dd95 <pbuf_header+0x190>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  80dd0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd12:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80dd16:	48 89 50 08          	mov    %rdx,0x8(%rax)
      /* bail out unsuccesfully */
      return 1;
  80dd1a:	b8 01 00 00 00       	mov    $0x1,%eax
  80dd1f:	e9 a2 00 00 00       	jmpq   80ddc6 <pbuf_header+0x1c1>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  80dd24:	66 83 7d fc 02       	cmpw   $0x2,-0x4(%rbp)
  80dd29:	74 07                	je     80dd32 <pbuf_header+0x12d>
  80dd2b:	66 83 7d fc 01       	cmpw   $0x1,-0x4(%rbp)
  80dd30:	75 39                	jne    80dd6b <pbuf_header+0x166>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  80dd32:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80dd37:	79 2b                	jns    80dd64 <pbuf_header+0x15f>
  80dd39:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd3d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dd41:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80dd45:	72 1d                	jb     80dd64 <pbuf_header+0x15f>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  80dd47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd4b:	48 8b 40 08          	mov    0x8(%rax),%rax
  80dd4f:	48 0f bf 55 e4       	movswq -0x1c(%rbp),%rdx
  80dd54:	48 f7 da             	neg    %rdx
  80dd57:	48 01 c2             	add    %rax,%rdx
  80dd5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd5e:	48 89 50 08          	mov    %rdx,0x8(%rax)
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  80dd62:	eb 31                	jmp    80dd95 <pbuf_header+0x190>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  80dd64:	b8 01 00 00 00       	mov    $0x1,%eax
  80dd69:	eb 5b                	jmp    80ddc6 <pbuf_header+0x1c1>
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  80dd6b:	48 ba ed 23 82 00 00 	movabs $0x8223ed,%rdx
  80dd72:	00 00 00 
  80dd75:	be 9b 01 00 00       	mov    $0x19b,%esi
  80dd7a:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80dd81:	00 00 00 
  80dd84:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd89:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80dd90:	00 00 00 
  80dd93:	ff d1                	callq  *%rcx
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  80dd95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dd99:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80dd9d:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80dda1:	01 c2                	add    %eax,%edx
  80dda3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dda7:	66 89 50 12          	mov    %dx,0x12(%rax)
  p->tot_len += header_size_increment;
  80ddab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ddaf:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80ddb3:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80ddb7:	01 c2                	add    %eax,%edx
  80ddb9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ddbd:	66 89 50 10          	mov    %dx,0x10(%rax)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  80ddc1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ddc6:	c9                   	leaveq 
  80ddc7:	c3                   	retq   

000000000080ddc8 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  80ddc8:	55                   	push   %rbp
  80ddc9:	48 89 e5             	mov    %rsp,%rbp
  80ddcc:	48 83 ec 30          	sub    $0x30,%rsp
  80ddd0:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  80ddd4:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80ddd9:	75 3b                	jne    80de16 <pbuf_free+0x4e>
    LWIP_ASSERT("p != NULL", p != NULL);
  80dddb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80dde0:	75 2a                	jne    80de0c <pbuf_free+0x44>
  80dde2:	48 ba c5 23 82 00 00 	movabs $0x8223c5,%rdx
  80dde9:	00 00 00 
  80ddec:	be d1 01 00 00       	mov    $0x1d1,%esi
  80ddf1:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80ddf8:	00 00 00 
  80ddfb:	b8 00 00 00 00       	mov    $0x0,%eax
  80de00:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80de07:	00 00 00 
  80de0a:	ff d1                	callq  *%rcx
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_free(p == NULL) was called.\n"));
    return 0;
  80de0c:	b8 00 00 00 00       	mov    $0x0,%eax
  80de11:	e9 65 01 00 00       	jmpq   80df7b <pbuf_free+0x1b3>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  80de16:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de1a:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80de1e:	84 c0                	test   %al,%al
  80de20:	74 4e                	je     80de70 <pbuf_free+0xa8>
  80de22:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de26:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80de2a:	3c 01                	cmp    $0x1,%al
  80de2c:	74 42                	je     80de70 <pbuf_free+0xa8>
  80de2e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de32:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80de36:	3c 02                	cmp    $0x2,%al
  80de38:	74 36                	je     80de70 <pbuf_free+0xa8>
  80de3a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de3e:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80de42:	3c 03                	cmp    $0x3,%al
  80de44:	74 2a                	je     80de70 <pbuf_free+0xa8>
  80de46:	48 ba fb 23 82 00 00 	movabs $0x8223fb,%rdx
  80de4d:	00 00 00 
  80de50:	be dc 01 00 00       	mov    $0x1dc,%esi
  80de55:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80de5c:	00 00 00 
  80de5f:	b8 00 00 00 00       	mov    $0x0,%eax
  80de64:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80de6b:	00 00 00 
  80de6e:	ff d1                	callq  *%rcx
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  80de70:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  80de74:	e9 f3 00 00 00       	jmpq   80df6c <pbuf_free+0x1a4>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  80de79:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de7d:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80de81:	66 85 c0             	test   %ax,%ax
  80de84:	75 2a                	jne    80deb0 <pbuf_free+0xe8>
  80de86:	48 ba 10 24 82 00 00 	movabs $0x822410,%rdx
  80de8d:	00 00 00 
  80de90:	be e9 01 00 00       	mov    $0x1e9,%esi
  80de95:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80de9c:	00 00 00 
  80de9f:	b8 00 00 00 00       	mov    $0x0,%eax
  80dea4:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80deab:	00 00 00 
  80deae:	ff d1                	callq  *%rcx
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  80deb0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80deb4:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80deb8:	8d 50 ff             	lea    -0x1(%rax),%edx
  80debb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80debf:	66 89 50 16          	mov    %dx,0x16(%rax)
  80dec3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dec7:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80decb:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  80decf:	66 83 7d fc 00       	cmpw   $0x0,-0x4(%rbp)
  80ded4:	0f 85 8a 00 00 00    	jne    80df64 <pbuf_free+0x19c>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  80deda:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dede:	48 8b 00             	mov    (%rax),%rax
  80dee1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  80dee5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dee9:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80deed:	0f b6 c0             	movzbl %al,%eax
  80def0:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  80def4:	66 83 7d ee 03       	cmpw   $0x3,-0x12(%rbp)
  80def9:	75 1a                	jne    80df15 <pbuf_free+0x14d>
        memp_free(MEMP_PBUF_POOL, p);
  80defb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80deff:	48 89 c6             	mov    %rax,%rsi
  80df02:	bf 0d 00 00 00       	mov    $0xd,%edi
  80df07:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  80df0e:	00 00 00 
  80df11:	ff d0                	callq  *%rax
  80df13:	eb 3b                	jmp    80df50 <pbuf_free+0x188>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  80df15:	66 83 7d ee 01       	cmpw   $0x1,-0x12(%rbp)
  80df1a:	74 07                	je     80df23 <pbuf_free+0x15b>
  80df1c:	66 83 7d ee 02       	cmpw   $0x2,-0x12(%rbp)
  80df21:	75 1a                	jne    80df3d <pbuf_free+0x175>
        memp_free(MEMP_PBUF, p);
  80df23:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80df27:	48 89 c6             	mov    %rax,%rsi
  80df2a:	bf 0c 00 00 00       	mov    $0xc,%edi
  80df2f:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  80df36:	00 00 00 
  80df39:	ff d0                	callq  *%rax
  80df3b:	eb 13                	jmp    80df50 <pbuf_free+0x188>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  80df3d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80df41:	48 89 c7             	mov    %rax,%rdi
  80df44:	48 b8 6d c5 80 00 00 	movabs $0x80c56d,%rax
  80df4b:	00 00 00 
  80df4e:	ff d0                	callq  *%rax
      }
      count++;
  80df50:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80df54:	83 c0 01             	add    $0x1,%eax
  80df57:	88 45 ff             	mov    %al,-0x1(%rbp)
      /* proceed to next pbuf */
      p = q;
  80df5a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80df5e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80df62:	eb 08                	jmp    80df6c <pbuf_free+0x1a4>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
  80df64:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  80df6b:	00 
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  80df6c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80df71:	0f 85 02 ff ff ff    	jne    80de79 <pbuf_free+0xb1>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
  80df77:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80df7b:	c9                   	leaveq 
  80df7c:	c3                   	retq   

000000000080df7d <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  80df7d:	55                   	push   %rbp
  80df7e:	48 89 e5             	mov    %rsp,%rbp
  80df81:	48 83 ec 18          	sub    $0x18,%rsp
  80df85:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t len;

  len = 0;
  80df89:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  while (p != NULL) {
  80df8d:	eb 0f                	jmp    80df9e <pbuf_clen+0x21>
    ++len;
  80df8f:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
    p = p->next;
  80df93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80df97:	48 8b 00             	mov    (%rax),%rax
  80df9a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  80df9e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80dfa3:	75 ea                	jne    80df8f <pbuf_clen+0x12>
    ++len;
    p = p->next;
  }
  return len;
  80dfa5:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80dfa9:	c9                   	leaveq 
  80dfaa:	c3                   	retq   

000000000080dfab <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  80dfab:	55                   	push   %rbp
  80dfac:	48 89 e5             	mov    %rsp,%rbp
  80dfaf:	48 83 ec 08          	sub    $0x8,%rsp
  80dfb3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  80dfb7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80dfbc:	74 13                	je     80dfd1 <pbuf_ref+0x26>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  80dfbe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dfc2:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80dfc6:	8d 50 01             	lea    0x1(%rax),%edx
  80dfc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dfcd:	66 89 50 16          	mov    %dx,0x16(%rax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  80dfd1:	90                   	nop
  80dfd2:	c9                   	leaveq 
  80dfd3:	c3                   	retq   

000000000080dfd4 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  80dfd4:	55                   	push   %rbp
  80dfd5:	48 89 e5             	mov    %rsp,%rbp
  80dfd8:	48 83 ec 20          	sub    $0x20,%rsp
  80dfdc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80dfe0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  80dfe4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80dfe9:	74 07                	je     80dff2 <pbuf_cat+0x1e>
  80dfeb:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80dff0:	75 2a                	jne    80e01c <pbuf_cat+0x48>
  80dff2:	48 ba 28 24 82 00 00 	movabs $0x822428,%rdx
  80dff9:	00 00 00 
  80dffc:	be 43 02 00 00       	mov    $0x243,%esi
  80e001:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80e008:	00 00 00 
  80e00b:	b8 00 00 00 00       	mov    $0x0,%eax
  80e010:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e017:	00 00 00 
  80e01a:	ff d1                	callq  *%rcx
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  80e01c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e020:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e024:	eb 25                	jmp    80e04b <pbuf_cat+0x77>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  80e026:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e02a:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80e02e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e032:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e036:	01 c2                	add    %eax,%edx
  80e038:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e03c:	66 89 50 10          	mov    %dx,0x10(%rax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  80e040:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e044:	48 8b 00             	mov    (%rax),%rax
  80e047:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e04b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e04f:	48 8b 00             	mov    (%rax),%rax
  80e052:	48 85 c0             	test   %rax,%rax
  80e055:	75 cf                	jne    80e026 <pbuf_cat+0x52>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  80e057:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e05b:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80e05f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e063:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e067:	66 39 c2             	cmp    %ax,%dx
  80e06a:	74 2a                	je     80e096 <pbuf_cat+0xc2>
  80e06c:	48 ba 60 24 82 00 00 	movabs $0x822460,%rdx
  80e073:	00 00 00 
  80e076:	be 4b 02 00 00       	mov    $0x24b,%esi
  80e07b:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80e082:	00 00 00 
  80e085:	b8 00 00 00 00       	mov    $0x0,%eax
  80e08a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e091:	00 00 00 
  80e094:	ff d1                	callq  *%rcx
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  80e096:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e09a:	48 8b 00             	mov    (%rax),%rax
  80e09d:	48 85 c0             	test   %rax,%rax
  80e0a0:	74 2a                	je     80e0cc <pbuf_cat+0xf8>
  80e0a2:	48 ba 8d 24 82 00 00 	movabs $0x82248d,%rdx
  80e0a9:	00 00 00 
  80e0ac:	be 4c 02 00 00       	mov    $0x24c,%esi
  80e0b1:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80e0b8:	00 00 00 
  80e0bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80e0c0:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e0c7:	00 00 00 
  80e0ca:	ff d1                	callq  *%rcx
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  80e0cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e0d0:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80e0d4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e0d8:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e0dc:	01 c2                	add    %eax,%edx
  80e0de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e0e2:	66 89 50 10          	mov    %dx,0x10(%rax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  80e0e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e0ea:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e0ee:	48 89 10             	mov    %rdx,(%rax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  80e0f1:	90                   	nop
  80e0f2:	c9                   	leaveq 
  80e0f3:	c3                   	retq   

000000000080e0f4 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  80e0f4:	55                   	push   %rbp
  80e0f5:	48 89 e5             	mov    %rsp,%rbp
  80e0f8:	48 83 ec 10          	sub    $0x10,%rsp
  80e0fc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80e100:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pbuf_cat(h, t);
  80e104:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e108:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e10c:	48 89 d6             	mov    %rdx,%rsi
  80e10f:	48 89 c7             	mov    %rax,%rdi
  80e112:	48 b8 d4 df 80 00 00 	movabs $0x80dfd4,%rax
  80e119:	00 00 00 
  80e11c:	ff d0                	callq  *%rax
  /* t is now referenced by h */
  pbuf_ref(t);
  80e11e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e122:	48 89 c7             	mov    %rax,%rdi
  80e125:	48 b8 ab df 80 00 00 	movabs $0x80dfab,%rax
  80e12c:	00 00 00 
  80e12f:	ff d0                	callq  *%rax
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  80e131:	90                   	nop
  80e132:	c9                   	leaveq 
  80e133:	c3                   	retq   

000000000080e134 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  80e134:	55                   	push   %rbp
  80e135:	48 89 e5             	mov    %rsp,%rbp
  80e138:	48 83 ec 20          	sub    $0x20,%rsp
  80e13c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct pbuf *q;
  u8_t tail_gone = 1;
  80e140:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  /* tail */
  q = p->next;
  80e144:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e148:	48 8b 00             	mov    (%rax),%rax
  80e14b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  /* pbuf has successor in chain? */
  if (q != NULL) {
  80e14f:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e154:	0f 84 9e 00 00 00    	je     80e1f8 <pbuf_dechain+0xc4>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  80e15a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e15e:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e162:	0f b7 d0             	movzwl %ax,%edx
  80e165:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e169:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e16d:	0f b7 c8             	movzwl %ax,%ecx
  80e170:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e174:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e178:	0f b7 c0             	movzwl %ax,%eax
  80e17b:	29 c1                	sub    %eax,%ecx
  80e17d:	89 c8                	mov    %ecx,%eax
  80e17f:	39 c2                	cmp    %eax,%edx
  80e181:	74 2a                	je     80e1ad <pbuf_dechain+0x79>
  80e183:	48 ba a0 24 82 00 00 	movabs $0x8224a0,%rdx
  80e18a:	00 00 00 
  80e18d:	be 81 02 00 00       	mov    $0x281,%esi
  80e192:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80e199:	00 00 00 
  80e19c:	b8 00 00 00 00       	mov    $0x0,%eax
  80e1a1:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e1a8:	00 00 00 
  80e1ab:	ff d1                	callq  *%rcx
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  80e1ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e1b1:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80e1b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e1b9:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e1bd:	29 c2                	sub    %eax,%edx
  80e1bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e1c3:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* decouple pbuf from remainder */
    p->next = NULL;
  80e1c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e1cb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  80e1d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e1d6:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80e1da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e1de:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  80e1e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e1e6:	48 89 c7             	mov    %rax,%rdi
  80e1e9:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  80e1f0:	00 00 00 
  80e1f3:	ff d0                	callq  *%rax
  80e1f5:	88 45 ff             	mov    %al,-0x1(%rbp)
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  80e1f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e1fc:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80e200:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e204:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e208:	66 39 c2             	cmp    %ax,%dx
  80e20b:	74 2a                	je     80e237 <pbuf_dechain+0x103>
  80e20d:	48 ba c2 24 82 00 00 	movabs $0x8224c2,%rdx
  80e214:	00 00 00 
  80e217:	be 92 02 00 00       	mov    $0x292,%esi
  80e21c:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80e223:	00 00 00 
  80e226:	b8 00 00 00 00       	mov    $0x0,%eax
  80e22b:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e232:	00 00 00 
  80e235:	ff d1                	callq  *%rcx
  return ((tail_gone > 0) ? NULL : q);
  80e237:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80e23b:	75 06                	jne    80e243 <pbuf_dechain+0x10f>
  80e23d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e241:	eb 05                	jmp    80e248 <pbuf_dechain+0x114>
  80e243:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80e248:	c9                   	leaveq 
  80e249:	c3                   	retq   

000000000080e24a <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  80e24a:	55                   	push   %rbp
  80e24b:	48 89 e5             	mov    %rsp,%rbp
  80e24e:	48 83 ec 20          	sub    $0x20,%rsp
  80e252:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80e256:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  u16_t offset_to=0, offset_from=0, len;
  80e25a:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
  80e260:	66 c7 45 fc 00 00    	movw   $0x0,-0x4(%rbp)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  80e266:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e26b:	74 1c                	je     80e289 <pbuf_copy+0x3f>
  80e26d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e272:	74 15                	je     80e289 <pbuf_copy+0x3f>
  80e274:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e278:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80e27c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e280:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e284:	66 39 c2             	cmp    %ax,%dx
  80e287:	73 2a                	jae    80e2b3 <pbuf_copy+0x69>
  80e289:	48 ba d8 24 82 00 00 	movabs $0x8224d8,%rdx
  80e290:	00 00 00 
  80e293:	be b2 02 00 00       	mov    $0x2b2,%esi
  80e298:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80e29f:	00 00 00 
  80e2a2:	b8 00 00 00 00       	mov    $0x0,%eax
  80e2a7:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e2ae:	00 00 00 
  80e2b1:	ff d1                	callq  *%rcx
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  80e2b3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e2b8:	75 2a                	jne    80e2e4 <pbuf_copy+0x9a>
  80e2ba:	48 ba 08 25 82 00 00 	movabs $0x822508,%rdx
  80e2c1:	00 00 00 
  80e2c4:	be b7 02 00 00       	mov    $0x2b7,%esi
  80e2c9:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80e2d0:	00 00 00 
  80e2d3:	b8 00 00 00 00       	mov    $0x0,%eax
  80e2d8:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e2df:	00 00 00 
  80e2e2:	ff d1                	callq  *%rcx
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  80e2e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e2e8:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e2ec:	0f b7 d0             	movzwl %ax,%edx
  80e2ef:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  80e2f3:	89 d1                	mov    %edx,%ecx
  80e2f5:	29 c1                	sub    %eax,%ecx
  80e2f7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e2fb:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e2ff:	0f b7 d0             	movzwl %ax,%edx
  80e302:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  80e306:	29 c2                	sub    %eax,%edx
  80e308:	89 d0                	mov    %edx,%eax
  80e30a:	39 c1                	cmp    %eax,%ecx
  80e30c:	7c 12                	jl     80e320 <pbuf_copy+0xd6>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  80e30e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e312:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e316:	66 2b 45 fc          	sub    -0x4(%rbp),%ax
  80e31a:	66 89 45 fa          	mov    %ax,-0x6(%rbp)
  80e31e:	eb 10                	jmp    80e330 <pbuf_copy+0xe6>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
  80e320:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e324:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e328:	66 2b 45 fe          	sub    -0x2(%rbp),%ax
  80e32c:	66 89 45 fa          	mov    %ax,-0x6(%rbp)
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  80e330:	0f b7 45 fa          	movzwl -0x6(%rbp),%eax
  80e334:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e338:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80e33c:	0f b7 55 fc          	movzwl -0x4(%rbp),%edx
  80e340:	48 8d 34 11          	lea    (%rcx,%rdx,1),%rsi
  80e344:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80e348:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80e34c:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  80e350:	48 01 d1             	add    %rdx,%rcx
  80e353:	48 89 c2             	mov    %rax,%rdx
  80e356:	48 89 cf             	mov    %rcx,%rdi
  80e359:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  80e360:	00 00 00 
  80e363:	ff d0                	callq  *%rax
    offset_to += len;
  80e365:	0f b7 45 fa          	movzwl -0x6(%rbp),%eax
  80e369:	66 01 45 fe          	add    %ax,-0x2(%rbp)
    offset_from += len;
  80e36d:	0f b7 45 fa          	movzwl -0x6(%rbp),%eax
  80e371:	66 01 45 fc          	add    %ax,-0x4(%rbp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  80e375:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e379:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e37d:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80e381:	73 2a                	jae    80e3ad <pbuf_copy+0x163>
  80e383:	48 ba 15 25 82 00 00 	movabs $0x822515,%rdx
  80e38a:	00 00 00 
  80e38d:	be c3 02 00 00       	mov    $0x2c3,%esi
  80e392:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80e399:	00 00 00 
  80e39c:	b8 00 00 00 00       	mov    $0x0,%eax
  80e3a1:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e3a8:	00 00 00 
  80e3ab:	ff d1                	callq  *%rcx
    if (offset_to == p_to->len) {
  80e3ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e3b1:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e3b5:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80e3b9:	75 11                	jne    80e3cc <pbuf_copy+0x182>
      /* on to next p_to (if any) */
      offset_to = 0;
  80e3bb:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
      p_to = p_to->next;
  80e3c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e3c5:	48 8b 00             	mov    (%rax),%rax
  80e3c8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  80e3cc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e3d0:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e3d4:	66 3b 45 fc          	cmp    -0x4(%rbp),%ax
  80e3d8:	73 2a                	jae    80e404 <pbuf_copy+0x1ba>
  80e3da:	48 ba 2c 25 82 00 00 	movabs $0x82252c,%rdx
  80e3e1:	00 00 00 
  80e3e4:	be c9 02 00 00       	mov    $0x2c9,%esi
  80e3e9:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80e3f0:	00 00 00 
  80e3f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80e3f8:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e3ff:	00 00 00 
  80e402:	ff d1                	callq  *%rcx
    if (offset_from >= p_from->len) {
  80e404:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e408:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e40c:	66 3b 45 fc          	cmp    -0x4(%rbp),%ax
  80e410:	77 11                	ja     80e423 <pbuf_copy+0x1d9>
      /* on to next p_from (if any) */
      offset_from = 0;
  80e412:	66 c7 45 fc 00 00    	movw   $0x0,-0x4(%rbp)
      p_from = p_from->next;
  80e418:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e41c:	48 8b 00             	mov    (%rax),%rax
  80e41f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  80e423:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e428:	74 4b                	je     80e475 <pbuf_copy+0x22b>
  80e42a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e42e:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80e432:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e436:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e43a:	66 39 c2             	cmp    %ax,%dx
  80e43d:	75 36                	jne    80e475 <pbuf_copy+0x22b>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80e43f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e443:	48 8b 00             	mov    (%rax),%rax
  80e446:	48 85 c0             	test   %rax,%rax
  80e449:	74 2a                	je     80e475 <pbuf_copy+0x22b>
  80e44b:	48 ba 48 25 82 00 00 	movabs $0x822548,%rdx
  80e452:	00 00 00 
  80e455:	be d3 02 00 00       	mov    $0x2d3,%esi
  80e45a:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80e461:	00 00 00 
  80e464:	b8 00 00 00 00       	mov    $0x0,%eax
  80e469:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e470:	00 00 00 
  80e473:	ff d1                	callq  *%rcx
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  80e475:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e47a:	74 4b                	je     80e4c7 <pbuf_copy+0x27d>
  80e47c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e480:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80e484:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e488:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80e48c:	66 39 c2             	cmp    %ax,%dx
  80e48f:	75 36                	jne    80e4c7 <pbuf_copy+0x27d>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80e491:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e495:	48 8b 00             	mov    (%rax),%rax
  80e498:	48 85 c0             	test   %rax,%rax
  80e49b:	74 2a                	je     80e4c7 <pbuf_copy+0x27d>
  80e49d:	48 ba 48 25 82 00 00 	movabs $0x822548,%rdx
  80e4a4:	00 00 00 
  80e4a7:	be d8 02 00 00       	mov    $0x2d8,%esi
  80e4ac:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80e4b3:	00 00 00 
  80e4b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80e4bb:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e4c2:	00 00 00 
  80e4c5:	ff d1                	callq  *%rcx
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  80e4c7:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e4cc:	0f 85 e1 fd ff ff    	jne    80e2b3 <pbuf_copy+0x69>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
  80e4d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80e4d7:	c9                   	leaveq 
  80e4d8:	c3                   	retq   

000000000080e4d9 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  80e4d9:	55                   	push   %rbp
  80e4da:	48 89 e5             	mov    %rsp,%rbp
  80e4dd:	48 83 ec 30          	sub    $0x30,%rsp
  80e4e1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80e4e5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80e4e9:	89 c8                	mov    %ecx,%eax
  80e4eb:	66 89 55 dc          	mov    %dx,-0x24(%rbp)
  80e4ef:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
  80e4f3:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%rbp)

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  80e4f9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e4fe:	75 2a                	jne    80e52a <pbuf_copy_partial+0x51>
  80e500:	48 ba 78 25 82 00 00 	movabs $0x822578,%rdx
  80e507:	00 00 00 
  80e50a:	be f0 02 00 00       	mov    $0x2f0,%esi
  80e50f:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80e516:	00 00 00 
  80e519:	b8 00 00 00 00       	mov    $0x0,%eax
  80e51e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e525:	00 00 00 
  80e528:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  80e52a:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e52f:	75 2a                	jne    80e55b <pbuf_copy_partial+0x82>
  80e531:	48 ba a0 25 82 00 00 	movabs $0x8225a0,%rdx
  80e538:	00 00 00 
  80e53b:	be f1 02 00 00       	mov    $0x2f1,%esi
  80e540:	48 bf 4b 22 82 00 00 	movabs $0x82224b,%rdi
  80e547:	00 00 00 
  80e54a:	b8 00 00 00 00       	mov    $0x0,%eax
  80e54f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e556:	00 00 00 
  80e559:	ff d1                	callq  *%rcx

  left = 0;
  80e55b:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)

  if((buf == NULL) || (dataptr == NULL)) {
  80e561:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e566:	74 07                	je     80e56f <pbuf_copy_partial+0x96>
  80e568:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e56d:	75 0a                	jne    80e579 <pbuf_copy_partial+0xa0>
    return 0;
  80e56f:	b8 00 00 00 00       	mov    $0x0,%eax
  80e574:	e9 c2 00 00 00       	jmpq   80e63b <pbuf_copy_partial+0x162>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80e579:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e57d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e581:	e9 9f 00 00 00       	jmpq   80e625 <pbuf_copy_partial+0x14c>
    if ((offset != 0) && (offset >= p->len)) {
  80e586:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%rbp)
  80e58b:	74 1c                	je     80e5a9 <pbuf_copy_partial+0xd0>
  80e58d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e591:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e595:	66 3b 45 d8          	cmp    -0x28(%rbp),%ax
  80e599:	77 0e                	ja     80e5a9 <pbuf_copy_partial+0xd0>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  80e59b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e59f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e5a3:	66 29 45 d8          	sub    %ax,-0x28(%rbp)
  80e5a7:	eb 71                	jmp    80e61a <pbuf_copy_partial+0x141>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  80e5a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e5ad:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e5b1:	66 2b 45 d8          	sub    -0x28(%rbp),%ax
  80e5b5:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
      if (buf_copy_len > len)
  80e5b9:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e5bd:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80e5c1:	76 08                	jbe    80e5cb <pbuf_copy_partial+0xf2>
          buf_copy_len = len;
  80e5c3:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  80e5c7:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  80e5cb:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e5cf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80e5d3:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80e5d7:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80e5db:	48 8d 34 11          	lea    (%rcx,%rdx,1),%rsi
  80e5df:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  80e5e3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e5e7:	48 01 d1             	add    %rdx,%rcx
  80e5ea:	48 89 c2             	mov    %rax,%rdx
  80e5ed:	48 89 cf             	mov    %rcx,%rdi
  80e5f0:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  80e5f7:	00 00 00 
  80e5fa:	ff d0                	callq  *%rax
      copied_total += buf_copy_len;
  80e5fc:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e600:	66 01 45 f2          	add    %ax,-0xe(%rbp)
      left += buf_copy_len;
  80e604:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e608:	66 01 45 f6          	add    %ax,-0xa(%rbp)
      len -= buf_copy_len;
  80e60c:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e610:	66 29 45 dc          	sub    %ax,-0x24(%rbp)
      offset = 0;
  80e614:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%rbp)
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80e61a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e61e:	48 8b 00             	mov    (%rax),%rax
  80e621:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e625:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  80e62a:	74 0b                	je     80e637 <pbuf_copy_partial+0x15e>
  80e62c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80e631:	0f 85 4f ff ff ff    	jne    80e586 <pbuf_copy_partial+0xad>
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
  80e637:	0f b7 45 f2          	movzwl -0xe(%rbp),%eax
}
  80e63b:	c9                   	leaveq 
  80e63c:	c3                   	retq   

000000000080e63d <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  80e63d:	55                   	push   %rbp
  80e63e:	48 89 e5             	mov    %rsp,%rbp
  80e641:	48 83 ec 40          	sub    $0x40,%rsp
  80e645:	89 7d cc             	mov    %edi,-0x34(%rbp)
  80e648:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  80e64c:	48 b8 16 8a 81 00 00 	movabs $0x818a16,%rax
  80e653:	00 00 00 
  80e656:	ff d0                	callq  *%rax
  80e658:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if (!timeouts || !timeouts->next) {
  80e65c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e661:	74 0c                	je     80e66f <sys_mbox_fetch+0x32>
  80e663:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e667:	48 8b 00             	mov    (%rax),%rax
  80e66a:	48 85 c0             	test   %rax,%rax
  80e66d:	75 25                	jne    80e694 <sys_mbox_fetch+0x57>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  80e66f:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80e673:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e676:	ba 00 00 00 00       	mov    $0x0,%edx
  80e67b:	48 89 ce             	mov    %rcx,%rsi
  80e67e:	89 c7                	mov    %eax,%edi
  80e680:	48 b8 21 85 81 00 00 	movabs $0x818521,%rax
  80e687:	00 00 00 
  80e68a:	ff d0                	callq  *%rax
  80e68c:	89 45 fc             	mov    %eax,-0x4(%rbp)
      } else {
        timeouts->next->time = 0;
      }
    }
  }
}
  80e68f:	e9 e0 00 00 00       	jmpq   80e774 <sys_mbox_fetch+0x137>
  if (!timeouts || !timeouts->next) {
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  80e694:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e698:	48 8b 00             	mov    (%rax),%rax
  80e69b:	8b 40 08             	mov    0x8(%rax),%eax
  80e69e:	85 c0                	test   %eax,%eax
  80e6a0:	74 27                	je     80e6c9 <sys_mbox_fetch+0x8c>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  80e6a2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e6a6:	48 8b 00             	mov    (%rax),%rax
  80e6a9:	8b 50 08             	mov    0x8(%rax),%edx
  80e6ac:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80e6b0:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e6b3:	48 89 ce             	mov    %rcx,%rsi
  80e6b6:	89 c7                	mov    %eax,%edi
  80e6b8:	48 b8 21 85 81 00 00 	movabs $0x818521,%rax
  80e6bf:	00 00 00 
  80e6c2:	ff d0                	callq  *%rax
  80e6c4:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80e6c7:	eb 07                	jmp    80e6d0 <sys_mbox_fetch+0x93>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
  80e6c9:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80e6d0:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80e6d4:	75 68                	jne    80e73e <sys_mbox_fetch+0x101>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80e6d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e6da:	48 8b 00             	mov    (%rax),%rax
  80e6dd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      timeouts->next = tmptimeout->next;
  80e6e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e6e5:	48 8b 10             	mov    (%rax),%rdx
  80e6e8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e6ec:	48 89 10             	mov    %rdx,(%rax)
      h   = tmptimeout->h;
  80e6ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e6f3:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e6f7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      arg = tmptimeout->arg;
  80e6fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e6ff:	48 8b 40 18          	mov    0x18(%rax),%rax
  80e703:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80e707:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e70b:	48 89 c6             	mov    %rax,%rsi
  80e70e:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e713:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  80e71a:	00 00 00 
  80e71d:	ff d0                	callq  *%rax
      if (h != NULL) {
  80e71f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e723:	48 85 c0             	test   %rax,%rax
  80e726:	0f 84 20 ff ff ff    	je     80e64c <sys_mbox_fetch+0xf>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  80e72c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e730:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e734:	48 89 d7             	mov    %rdx,%rdi
  80e737:	ff d0                	callq  *%rax
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80e739:	e9 0e ff ff ff       	jmpq   80e64c <sys_mbox_fetch+0xf>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  80e73e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e742:	48 8b 00             	mov    (%rax),%rax
  80e745:	8b 40 08             	mov    0x8(%rax),%eax
  80e748:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80e74b:	76 19                	jbe    80e766 <sys_mbox_fetch+0x129>
        timeouts->next->time -= time_needed;
  80e74d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e751:	48 8b 00             	mov    (%rax),%rax
  80e754:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e758:	48 8b 12             	mov    (%rdx),%rdx
  80e75b:	8b 52 08             	mov    0x8(%rdx),%edx
  80e75e:	2b 55 fc             	sub    -0x4(%rbp),%edx
  80e761:	89 50 08             	mov    %edx,0x8(%rax)
      } else {
        timeouts->next->time = 0;
      }
    }
  }
}
  80e764:	eb 0e                	jmp    80e774 <sys_mbox_fetch+0x137>
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
        timeouts->next->time -= time_needed;
      } else {
        timeouts->next->time = 0;
  80e766:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e76a:	48 8b 00             	mov    (%rax),%rax
  80e76d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      }
    }
  }
}
  80e774:	90                   	nop
  80e775:	c9                   	leaveq 
  80e776:	c3                   	retq   

000000000080e777 <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  80e777:	55                   	push   %rbp
  80e778:	48 89 e5             	mov    %rsp,%rbp
  80e77b:	48 83 ec 40          	sub    $0x40,%rsp
  80e77f:	89 7d cc             	mov    %edi,-0x34(%rbp)
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  80e782:	48 b8 16 8a 81 00 00 	movabs $0x818a16,%rax
  80e789:	00 00 00 
  80e78c:	ff d0                	callq  *%rax
  80e78e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if (!timeouts || !timeouts->next) {
  80e792:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e797:	74 0c                	je     80e7a5 <sys_sem_wait+0x2e>
  80e799:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e79d:	48 8b 00             	mov    (%rax),%rax
  80e7a0:	48 85 c0             	test   %rax,%rax
  80e7a3:	75 1b                	jne    80e7c0 <sys_sem_wait+0x49>
    sys_arch_sem_wait(sem, 0);
  80e7a5:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e7a8:	be 00 00 00 00       	mov    $0x0,%esi
  80e7ad:	89 c7                	mov    %eax,%edi
  80e7af:	48 b8 ea 82 81 00 00 	movabs $0x8182ea,%rax
  80e7b6:	00 00 00 
  80e7b9:	ff d0                	callq  *%rax
      } else {
        timeouts->next->time = 0;
      }
    }
  }
}
  80e7bb:	e9 db 00 00 00       	jmpq   80e89b <sys_sem_wait+0x124>
  timeouts = sys_arch_timeouts();

  if (!timeouts || !timeouts->next) {
    sys_arch_sem_wait(sem, 0);
  } else {
    if (timeouts->next->time > 0) {
  80e7c0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e7c4:	48 8b 00             	mov    (%rax),%rax
  80e7c7:	8b 40 08             	mov    0x8(%rax),%eax
  80e7ca:	85 c0                	test   %eax,%eax
  80e7cc:	74 22                	je     80e7f0 <sys_sem_wait+0x79>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  80e7ce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e7d2:	48 8b 00             	mov    (%rax),%rax
  80e7d5:	8b 50 08             	mov    0x8(%rax),%edx
  80e7d8:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e7db:	89 d6                	mov    %edx,%esi
  80e7dd:	89 c7                	mov    %eax,%edi
  80e7df:	48 b8 ea 82 81 00 00 	movabs $0x8182ea,%rax
  80e7e6:	00 00 00 
  80e7e9:	ff d0                	callq  *%rax
  80e7eb:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80e7ee:	eb 07                	jmp    80e7f7 <sys_sem_wait+0x80>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
  80e7f0:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80e7f7:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80e7fb:	75 68                	jne    80e865 <sys_sem_wait+0xee>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80e7fd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e801:	48 8b 00             	mov    (%rax),%rax
  80e804:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      timeouts->next = tmptimeout->next;
  80e808:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e80c:	48 8b 10             	mov    (%rax),%rdx
  80e80f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e813:	48 89 10             	mov    %rdx,(%rax)
      h = tmptimeout->h;
  80e816:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e81a:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e81e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      arg = tmptimeout->arg;
  80e822:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e826:	48 8b 40 18          	mov    0x18(%rax),%rax
  80e82a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80e82e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e832:	48 89 c6             	mov    %rax,%rsi
  80e835:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e83a:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  80e841:	00 00 00 
  80e844:	ff d0                	callq  *%rax
      if (h != NULL) {
  80e846:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e84a:	48 85 c0             	test   %rax,%rax
  80e84d:	0f 84 2f ff ff ff    	je     80e782 <sys_sem_wait+0xb>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  80e853:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e857:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e85b:	48 89 d7             	mov    %rdx,%rdi
  80e85e:	ff d0                	callq  *%rax
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80e860:	e9 1d ff ff ff       	jmpq   80e782 <sys_sem_wait+0xb>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  80e865:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e869:	48 8b 00             	mov    (%rax),%rax
  80e86c:	8b 40 08             	mov    0x8(%rax),%eax
  80e86f:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80e872:	76 19                	jbe    80e88d <sys_sem_wait+0x116>
        timeouts->next->time -= time_needed;
  80e874:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e878:	48 8b 00             	mov    (%rax),%rax
  80e87b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e87f:	48 8b 12             	mov    (%rdx),%rdx
  80e882:	8b 52 08             	mov    0x8(%rdx),%edx
  80e885:	2b 55 fc             	sub    -0x4(%rbp),%edx
  80e888:	89 50 08             	mov    %edx,0x8(%rax)
      } else {
        timeouts->next->time = 0;
      }
    }
  }
}
  80e88b:	eb 0e                	jmp    80e89b <sys_sem_wait+0x124>
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
        timeouts->next->time -= time_needed;
      } else {
        timeouts->next->time = 0;
  80e88d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e891:	48 8b 00             	mov    (%rax),%rax
  80e894:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      }
    }
  }
}
  80e89b:	90                   	nop
  80e89c:	c9                   	leaveq 
  80e89d:	c3                   	retq   

000000000080e89e <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  80e89e:	55                   	push   %rbp
  80e89f:	48 89 e5             	mov    %rsp,%rbp
  80e8a2:	48 83 ec 40          	sub    $0x40,%rsp
  80e8a6:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80e8a9:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80e8ad:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  80e8b1:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e8b6:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  80e8bd:	00 00 00 
  80e8c0:	ff d0                	callq  *%rax
  80e8c2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (timeout == NULL) {
  80e8c6:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e8cb:	75 35                	jne    80e902 <sys_timeout+0x64>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  80e8cd:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e8d2:	0f 85 a9 01 00 00    	jne    80ea81 <sys_timeout+0x1e3>
  80e8d8:	48 ba c8 25 82 00 00 	movabs $0x8225c8,%rdx
  80e8df:	00 00 00 
  80e8e2:	be c4 00 00 00       	mov    $0xc4,%esi
  80e8e7:	48 bf e5 25 82 00 00 	movabs $0x8225e5,%rdi
  80e8ee:	00 00 00 
  80e8f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80e8f6:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e8fd:	00 00 00 
  80e900:	ff d1                	callq  *%rcx
    return;
  }
  timeout->next = NULL;
  80e902:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e906:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  timeout->h = h;
  80e90d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80e911:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e915:	48 89 50 10          	mov    %rdx,0x10(%rax)
  timeout->arg = arg;
  80e919:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e91d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80e921:	48 89 50 18          	mov    %rdx,0x18(%rax)
  timeout->time = msecs;
  80e925:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e929:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80e92c:	89 50 08             	mov    %edx,0x8(%rax)

  timeouts = sys_arch_timeouts();
  80e92f:	48 b8 16 8a 81 00 00 	movabs $0x818a16,%rax
  80e936:	00 00 00 
  80e939:	ff d0                	callq  *%rax
  80e93b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  80e93f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e944:	75 35                	jne    80e97b <sys_timeout+0xdd>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  80e946:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e94b:	0f 85 33 01 00 00    	jne    80ea84 <sys_timeout+0x1e6>
  80e951:	48 ba f9 25 82 00 00 	movabs $0x8225f9,%rdx
  80e958:	00 00 00 
  80e95b:	be d2 00 00 00       	mov    $0xd2,%esi
  80e960:	48 bf e5 25 82 00 00 	movabs $0x8225e5,%rdi
  80e967:	00 00 00 
  80e96a:	b8 00 00 00 00       	mov    $0x0,%eax
  80e96f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80e976:	00 00 00 
  80e979:	ff d1                	callq  *%rcx
    return;
  }

  if (timeouts->next == NULL) {
  80e97b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e97f:	48 8b 00             	mov    (%rax),%rax
  80e982:	48 85 c0             	test   %rax,%rax
  80e985:	75 10                	jne    80e997 <sys_timeout+0xf9>
    timeouts->next = timeout;
  80e987:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e98b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e98f:	48 89 10             	mov    %rdx,(%rax)
    return;
  80e992:	e9 ee 00 00 00       	jmpq   80ea85 <sys_timeout+0x1e7>
  }

  if (timeouts->next->time > msecs) {
  80e997:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e99b:	48 8b 00             	mov    (%rax),%rax
  80e99e:	8b 40 08             	mov    0x8(%rax),%eax
  80e9a1:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  80e9a4:	76 35                	jbe    80e9db <sys_timeout+0x13d>
    timeouts->next->time -= msecs;
  80e9a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e9aa:	48 8b 00             	mov    (%rax),%rax
  80e9ad:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80e9b1:	48 8b 12             	mov    (%rdx),%rdx
  80e9b4:	8b 52 08             	mov    0x8(%rdx),%edx
  80e9b7:	2b 55 dc             	sub    -0x24(%rbp),%edx
  80e9ba:	89 50 08             	mov    %edx,0x8(%rax)
    timeout->next = timeouts->next;
  80e9bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e9c1:	48 8b 10             	mov    (%rax),%rdx
  80e9c4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e9c8:	48 89 10             	mov    %rdx,(%rax)
    timeouts->next = timeout;
  80e9cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e9cf:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e9d3:	48 89 10             	mov    %rdx,(%rax)
  80e9d6:	e9 aa 00 00 00       	jmpq   80ea85 <sys_timeout+0x1e7>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
  80e9db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e9df:	48 8b 00             	mov    (%rax),%rax
  80e9e2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e9e6:	e9 89 00 00 00       	jmpq   80ea74 <sys_timeout+0x1d6>
      timeout->time -= t->time;
  80e9eb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e9ef:	8b 50 08             	mov    0x8(%rax),%edx
  80e9f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e9f6:	8b 40 08             	mov    0x8(%rax),%eax
  80e9f9:	29 c2                	sub    %eax,%edx
  80e9fb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e9ff:	89 50 08             	mov    %edx,0x8(%rax)
      if (t->next == NULL || t->next->time > timeout->time) {
  80ea02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea06:	48 8b 00             	mov    (%rax),%rax
  80ea09:	48 85 c0             	test   %rax,%rax
  80ea0c:	74 15                	je     80ea23 <sys_timeout+0x185>
  80ea0e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea12:	48 8b 00             	mov    (%rax),%rax
  80ea15:	8b 50 08             	mov    0x8(%rax),%edx
  80ea18:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ea1c:	8b 40 08             	mov    0x8(%rax),%eax
  80ea1f:	39 c2                	cmp    %eax,%edx
  80ea21:	76 46                	jbe    80ea69 <sys_timeout+0x1cb>
        if (t->next != NULL) {
  80ea23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea27:	48 8b 00             	mov    (%rax),%rax
  80ea2a:	48 85 c0             	test   %rax,%rax
  80ea2d:	74 1f                	je     80ea4e <sys_timeout+0x1b0>
          t->next->time -= timeout->time;
  80ea2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea33:	48 8b 00             	mov    (%rax),%rax
  80ea36:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80ea3a:	48 8b 12             	mov    (%rdx),%rdx
  80ea3d:	8b 4a 08             	mov    0x8(%rdx),%ecx
  80ea40:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80ea44:	8b 52 08             	mov    0x8(%rdx),%edx
  80ea47:	29 d1                	sub    %edx,%ecx
  80ea49:	89 ca                	mov    %ecx,%edx
  80ea4b:	89 50 08             	mov    %edx,0x8(%rax)
        }
        timeout->next = t->next;
  80ea4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea52:	48 8b 10             	mov    (%rax),%rdx
  80ea55:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ea59:	48 89 10             	mov    %rdx,(%rax)
        t->next = timeout;
  80ea5c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea60:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80ea64:	48 89 10             	mov    %rdx,(%rax)
        break;
  80ea67:	eb 1c                	jmp    80ea85 <sys_timeout+0x1e7>
  if (timeouts->next->time > msecs) {
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
  80ea69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ea6d:	48 8b 00             	mov    (%rax),%rax
  80ea70:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ea74:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ea79:	0f 85 6c ff ff ff    	jne    80e9eb <sys_timeout+0x14d>
  80ea7f:	eb 04                	jmp    80ea85 <sys_timeout+0x1e7>
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
    return;
  80ea81:	90                   	nop
  80ea82:	eb 01                	jmp    80ea85 <sys_timeout+0x1e7>
  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
    return;
  80ea84:	90                   	nop
        t->next = timeout;
        break;
      }
    }
  }
}
  80ea85:	c9                   	leaveq 
  80ea86:	c3                   	retq   

000000000080ea87 <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  80ea87:	55                   	push   %rbp
  80ea88:	48 89 e5             	mov    %rsp,%rbp
  80ea8b:	48 83 ec 30          	sub    $0x30,%rsp
  80ea8f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80ea93:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  80ea97:	48 b8 16 8a 81 00 00 	movabs $0x818a16,%rax
  80ea9e:	00 00 00 
  80eaa1:	ff d0                	callq  *%rax
  80eaa3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  if (timeouts == NULL) {
  80eaa7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80eaac:	75 35                	jne    80eae3 <sys_untimeout+0x5c>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  80eaae:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80eab3:	0f 85 f7 00 00 00    	jne    80ebb0 <sys_untimeout+0x129>
  80eab9:	48 ba 18 26 82 00 00 	movabs $0x822618,%rdx
  80eac0:	00 00 00 
  80eac3:	be 01 01 00 00       	mov    $0x101,%esi
  80eac8:	48 bf e5 25 82 00 00 	movabs $0x8225e5,%rdi
  80eacf:	00 00 00 
  80ead2:	b8 00 00 00 00       	mov    $0x0,%eax
  80ead7:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80eade:	00 00 00 
  80eae1:	ff d1                	callq  *%rcx
    return;
  }
  if (timeouts->next == NULL) {
  80eae3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eae7:	48 8b 00             	mov    (%rax),%rax
  80eaea:	48 85 c0             	test   %rax,%rax
  80eaed:	0f 84 c0 00 00 00    	je     80ebb3 <sys_untimeout+0x12c>
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80eaf3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eaf7:	48 8b 00             	mov    (%rax),%rax
  80eafa:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80eafe:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80eb05:	00 
  80eb06:	e9 97 00 00 00       	jmpq   80eba2 <sys_untimeout+0x11b>
    if ((t->h == h) && (t->arg == arg)) {
  80eb0b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eb0f:	48 8b 40 10          	mov    0x10(%rax),%rax
  80eb13:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80eb17:	75 76                	jne    80eb8f <sys_untimeout+0x108>
  80eb19:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eb1d:	48 8b 40 18          	mov    0x18(%rax),%rax
  80eb21:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80eb25:	75 68                	jne    80eb8f <sys_untimeout+0x108>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  80eb27:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80eb2c:	75 10                	jne    80eb3e <sys_untimeout+0xb7>
        timeouts->next = t->next;
  80eb2e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eb32:	48 8b 10             	mov    (%rax),%rdx
  80eb35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eb39:	48 89 10             	mov    %rdx,(%rax)
  80eb3c:	eb 0e                	jmp    80eb4c <sys_untimeout+0xc5>
      else
        prev_t->next = t->next;
  80eb3e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eb42:	48 8b 10             	mov    (%rax),%rdx
  80eb45:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eb49:	48 89 10             	mov    %rdx,(%rax)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  80eb4c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eb50:	48 8b 00             	mov    (%rax),%rax
  80eb53:	48 85 c0             	test   %rax,%rax
  80eb56:	74 1d                	je     80eb75 <sys_untimeout+0xee>
        t->next->time += t->time;
  80eb58:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eb5c:	48 8b 00             	mov    (%rax),%rax
  80eb5f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80eb63:	48 8b 12             	mov    (%rdx),%rdx
  80eb66:	8b 4a 08             	mov    0x8(%rdx),%ecx
  80eb69:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80eb6d:	8b 52 08             	mov    0x8(%rdx),%edx
  80eb70:	01 ca                	add    %ecx,%edx
  80eb72:	89 50 08             	mov    %edx,0x8(%rax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  80eb75:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eb79:	48 89 c6             	mov    %rax,%rsi
  80eb7c:	bf 0b 00 00 00       	mov    $0xb,%edi
  80eb81:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  80eb88:	00 00 00 
  80eb8b:	ff d0                	callq  *%rax
      return;
  80eb8d:	eb 25                	jmp    80ebb4 <sys_untimeout+0x12d>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80eb8f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eb93:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80eb97:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80eb9b:	48 8b 00             	mov    (%rax),%rax
  80eb9e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80eba2:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80eba7:	0f 85 5e ff ff ff    	jne    80eb0b <sys_untimeout+0x84>
        t->next->time += t->time;
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
  80ebad:	90                   	nop
  80ebae:	eb 04                	jmp    80ebb4 <sys_untimeout+0x12d>

  timeouts = sys_arch_timeouts();

  if (timeouts == NULL) {
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
    return;
  80ebb0:	90                   	nop
  80ebb1:	eb 01                	jmp    80ebb4 <sys_untimeout+0x12d>
  }
  if (timeouts->next == NULL) {
    return;
  80ebb3:	90                   	nop
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  80ebb4:	c9                   	leaveq 
  80ebb5:	c3                   	retq   

000000000080ebb6 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  80ebb6:	55                   	push   %rbp
  80ebb7:	48 89 e5             	mov    %rsp,%rbp
  80ebba:	48 83 ec 20          	sub    $0x20,%rsp
  80ebbe:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;
  80ebc2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ebc6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  80ebca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ebce:	66 c7 00 01 00       	movw   $0x1,(%rax)
  sys_sem_signal(*(sswt_cb->psem));
  80ebd3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ebd7:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ebdb:	8b 00                	mov    (%rax),%eax
  80ebdd:	89 c7                	mov    %eax,%edi
  80ebdf:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  80ebe6:	00 00 00 
  80ebe9:	ff d0                	callq  *%rax
}
  80ebeb:	90                   	nop
  80ebec:	c9                   	leaveq 
  80ebed:	c3                   	retq   

000000000080ebee <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  80ebee:	55                   	push   %rbp
  80ebef:	48 89 e5             	mov    %rsp,%rbp
  80ebf2:	48 83 ec 20          	sub    $0x20,%rsp
  80ebf6:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80ebf9:	89 75 e8             	mov    %esi,-0x18(%rbp)
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  80ebfc:	48 8d 45 ec          	lea    -0x14(%rbp),%rax
  80ec00:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sswt_cb.timeflag = 0;
  80ec04:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%rbp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  80ec0a:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80ec0e:	74 1f                	je     80ec2f <sys_sem_wait_timeout+0x41>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  80ec10:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80ec14:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80ec17:	48 be b6 eb 80 00 00 	movabs $0x80ebb6,%rsi
  80ec1e:	00 00 00 
  80ec21:	89 c7                	mov    %eax,%edi
  80ec23:	48 b8 9e e8 80 00 00 	movabs $0x80e89e,%rax
  80ec2a:	00 00 00 
  80ec2d:	ff d0                	callq  *%rax
  }
  sys_sem_wait(sem);
  80ec2f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80ec32:	89 c7                	mov    %eax,%edi
  80ec34:	48 b8 77 e7 80 00 00 	movabs $0x80e777,%rax
  80ec3b:	00 00 00 
  80ec3e:	ff d0                	callq  *%rax
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  80ec40:	0f b7 45 f0          	movzwl -0x10(%rbp),%eax
  80ec44:	66 85 c0             	test   %ax,%ax
  80ec47:	74 07                	je     80ec50 <sys_sem_wait_timeout+0x62>
    /* timeout */
    return 0;
  80ec49:	b8 00 00 00 00       	mov    $0x0,%eax
  80ec4e:	eb 22                	jmp    80ec72 <sys_sem_wait_timeout+0x84>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  80ec50:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  80ec54:	48 89 c6             	mov    %rax,%rsi
  80ec57:	48 bf b6 eb 80 00 00 	movabs $0x80ebb6,%rdi
  80ec5e:	00 00 00 
  80ec61:	48 b8 87 ea 80 00 00 	movabs $0x80ea87,%rax
  80ec68:	00 00 00 
  80ec6b:	ff d0                	callq  *%rax
    return 1;
  80ec6d:	b8 01 00 00 00       	mov    $0x1,%eax
  }
}
  80ec72:	c9                   	leaveq 
  80ec73:	c3                   	retq   

000000000080ec74 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  80ec74:	55                   	push   %rbp
  80ec75:	48 89 e5             	mov    %rsp,%rbp
  80ec78:	48 83 ec 20          	sub    $0x20,%rsp
  80ec7c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  sys_sem_t delaysem = sys_sem_new(0);
  80ec7f:	bf 00 00 00 00       	mov    $0x0,%edi
  80ec84:	48 b8 5c 7f 81 00 00 	movabs $0x817f5c,%rax
  80ec8b:	00 00 00 
  80ec8e:	ff d0                	callq  *%rax
  80ec90:	89 45 fc             	mov    %eax,-0x4(%rbp)

  sys_sem_wait_timeout(delaysem, ms);
  80ec93:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80ec96:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80ec99:	89 d6                	mov    %edx,%esi
  80ec9b:	89 c7                	mov    %eax,%edi
  80ec9d:	48 b8 ee eb 80 00 00 	movabs $0x80ebee,%rax
  80eca4:	00 00 00 
  80eca7:	ff d0                	callq  *%rax

  sys_sem_free(delaysem);
  80eca9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80ecac:	89 c7                	mov    %eax,%edi
  80ecae:	48 b8 5a 80 81 00 00 	movabs $0x81805a,%rax
  80ecb5:	00 00 00 
  80ecb8:	ff d0                	callq  *%rax
}
  80ecba:	90                   	nop
  80ecbb:	c9                   	leaveq 
  80ecbc:	c3                   	retq   

000000000080ecbd <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  80ecbd:	55                   	push   %rbp
  80ecbe:	48 89 e5             	mov    %rsp,%rbp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  80ecc1:	48 b8 b9 03 81 00 00 	movabs $0x8103b9,%rax
  80ecc8:	00 00 00 
  80eccb:	ff d0                	callq  *%rax

  if (++tcp_timer & 1) {
  80eccd:	48 b8 4c b0 b4 00 00 	movabs $0xb4b04c,%rax
  80ecd4:	00 00 00 
  80ecd7:	0f b6 00             	movzbl (%rax),%eax
  80ecda:	8d 50 01             	lea    0x1(%rax),%edx
  80ecdd:	48 b8 4c b0 b4 00 00 	movabs $0xb4b04c,%rax
  80ece4:	00 00 00 
  80ece7:	88 10                	mov    %dl,(%rax)
  80ece9:	48 b8 4c b0 b4 00 00 	movabs $0xb4b04c,%rax
  80ecf0:	00 00 00 
  80ecf3:	0f b6 00             	movzbl (%rax),%eax
  80ecf6:	0f b6 c0             	movzbl %al,%eax
  80ecf9:	83 e0 01             	and    $0x1,%eax
  80ecfc:	85 c0                	test   %eax,%eax
  80ecfe:	74 0c                	je     80ed0c <tcp_tmr+0x4f>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  80ed00:	48 b8 7a fb 80 00 00 	movabs $0x80fb7a,%rax
  80ed07:	00 00 00 
  80ed0a:	ff d0                	callq  *%rax
  }
}
  80ed0c:	90                   	nop
  80ed0d:	5d                   	pop    %rbp
  80ed0e:	c3                   	retq   

000000000080ed0f <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  80ed0f:	55                   	push   %rbp
  80ed10:	48 89 e5             	mov    %rsp,%rbp
  80ed13:	48 83 ec 20          	sub    $0x20,%rsp
  80ed17:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  80ed1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed1f:	8b 40 18             	mov    0x18(%rax),%eax
  80ed22:	83 f8 07             	cmp    $0x7,%eax
  80ed25:	0f 87 31 02 00 00    	ja     80ef5c <tcp_close+0x24d>
  80ed2b:	89 c0                	mov    %eax,%eax
  80ed2d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80ed34:	00 
  80ed35:	48 b8 50 26 82 00 00 	movabs $0x822650,%rax
  80ed3c:	00 00 00 
  80ed3f:	48 01 d0             	add    %rdx,%rax
  80ed42:	48 8b 00             	mov    (%rax),%rax
  80ed45:	ff e0                	jmpq   *%rax
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
  80ed47:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    TCP_RMV(&tcp_bound_pcbs, pcb);
  80ed4b:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ed52:	00 00 00 
  80ed55:	48 8b 00             	mov    (%rax),%rax
  80ed58:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80ed5c:	75 23                	jne    80ed81 <tcp_close+0x72>
  80ed5e:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ed65:	00 00 00 
  80ed68:	48 8b 00             	mov    (%rax),%rax
  80ed6b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80ed6f:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ed76:	00 00 00 
  80ed79:	48 89 10             	mov    %rdx,(%rax)
  80ed7c:	e9 94 00 00 00       	jmpq   80ee15 <tcp_close+0x106>
  80ed81:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ed88:	00 00 00 
  80ed8b:	48 8b 10             	mov    (%rax),%rdx
  80ed8e:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ed95:	00 00 00 
  80ed98:	48 89 10             	mov    %rdx,(%rax)
  80ed9b:	eb 66                	jmp    80ee03 <tcp_close+0xf4>
  80ed9d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80eda4:	00 00 00 
  80eda7:	48 8b 00             	mov    (%rax),%rax
  80edaa:	48 8b 40 10          	mov    0x10(%rax),%rax
  80edae:	48 85 c0             	test   %rax,%rax
  80edb1:	74 32                	je     80ede5 <tcp_close+0xd6>
  80edb3:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80edba:	00 00 00 
  80edbd:	48 8b 00             	mov    (%rax),%rax
  80edc0:	48 8b 40 10          	mov    0x10(%rax),%rax
  80edc4:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80edc8:	75 1b                	jne    80ede5 <tcp_close+0xd6>
  80edca:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80edd1:	00 00 00 
  80edd4:	48 8b 00             	mov    (%rax),%rax
  80edd7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80eddb:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80eddf:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80ede3:	eb 30                	jmp    80ee15 <tcp_close+0x106>
  80ede5:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80edec:	00 00 00 
  80edef:	48 8b 00             	mov    (%rax),%rax
  80edf2:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80edf6:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80edfd:	00 00 00 
  80ee00:	48 89 10             	mov    %rdx,(%rax)
  80ee03:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ee0a:	00 00 00 
  80ee0d:	48 8b 00             	mov    (%rax),%rax
  80ee10:	48 85 c0             	test   %rax,%rax
  80ee13:	75 88                	jne    80ed9d <tcp_close+0x8e>
  80ee15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee19:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80ee20:	00 
    memp_free(MEMP_TCP_PCB, pcb);
  80ee21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee25:	48 89 c6             	mov    %rax,%rsi
  80ee28:	bf 02 00 00 00       	mov    $0x2,%edi
  80ee2d:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  80ee34:	00 00 00 
  80ee37:	ff d0                	callq  *%rax
    pcb = NULL;
  80ee39:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80ee40:	00 
    break;
  80ee41:	e9 2b 01 00 00       	jmpq   80ef71 <tcp_close+0x262>
  case LISTEN:
    err = ERR_OK;
  80ee46:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  80ee4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee4e:	48 89 c6             	mov    %rax,%rsi
  80ee51:	48 bf 28 b0 b5 00 00 	movabs $0xb5b028,%rdi
  80ee58:	00 00 00 
  80ee5b:	48 b8 52 0b 81 00 00 	movabs $0x810b52,%rax
  80ee62:	00 00 00 
  80ee65:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  80ee67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee6b:	48 89 c6             	mov    %rax,%rsi
  80ee6e:	bf 03 00 00 00       	mov    $0x3,%edi
  80ee73:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  80ee7a:	00 00 00 
  80ee7d:	ff d0                	callq  *%rax
    pcb = NULL;
  80ee7f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80ee86:	00 
    break;
  80ee87:	e9 e5 00 00 00       	jmpq   80ef71 <tcp_close+0x262>
  case SYN_SENT:
    err = ERR_OK;
  80ee8c:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80ee90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee94:	48 89 c6             	mov    %rax,%rsi
  80ee97:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  80ee9e:	00 00 00 
  80eea1:	48 b8 52 0b 81 00 00 	movabs $0x810b52,%rax
  80eea8:	00 00 00 
  80eeab:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB, pcb);
  80eead:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eeb1:	48 89 c6             	mov    %rax,%rsi
  80eeb4:	bf 02 00 00 00       	mov    $0x2,%edi
  80eeb9:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  80eec0:	00 00 00 
  80eec3:	ff d0                	callq  *%rax
    pcb = NULL;
  80eec5:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80eecc:	00 
    snmp_inc_tcpattemptfails();
    break;
  80eecd:	e9 9f 00 00 00       	jmpq   80ef71 <tcp_close+0x262>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80eed2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eed6:	be 01 00 00 00       	mov    $0x1,%esi
  80eedb:	48 89 c7             	mov    %rax,%rdi
  80eede:	48 b8 b3 31 81 00 00 	movabs $0x8131b3,%rax
  80eee5:	00 00 00 
  80eee8:	ff d0                	callq  *%rax
  80eeea:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80eeed:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80eef1:	75 77                	jne    80ef6a <tcp_close+0x25b>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  80eef3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eef7:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%rax)
    }
    break;
  80eefe:	eb 6a                	jmp    80ef6a <tcp_close+0x25b>
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80ef00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ef04:	be 01 00 00 00       	mov    $0x1,%esi
  80ef09:	48 89 c7             	mov    %rax,%rdi
  80ef0c:	48 b8 b3 31 81 00 00 	movabs $0x8131b3,%rax
  80ef13:	00 00 00 
  80ef16:	ff d0                	callq  *%rax
  80ef18:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80ef1b:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80ef1f:	75 4c                	jne    80ef6d <tcp_close+0x25e>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  80ef21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ef25:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%rax)
    }
    break;
  80ef2c:	eb 3f                	jmp    80ef6d <tcp_close+0x25e>
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80ef2e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ef32:	be 01 00 00 00       	mov    $0x1,%esi
  80ef37:	48 89 c7             	mov    %rax,%rdi
  80ef3a:	48 b8 b3 31 81 00 00 	movabs $0x8131b3,%rax
  80ef41:	00 00 00 
  80ef44:	ff d0                	callq  *%rax
  80ef46:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80ef49:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80ef4d:	75 21                	jne    80ef70 <tcp_close+0x261>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  80ef4f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ef53:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
    }
    break;
  80ef5a:	eb 14                	jmp    80ef70 <tcp_close+0x261>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
  80ef5c:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    pcb = NULL;
  80ef60:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80ef67:	00 
    break;
  80ef68:	eb 07                	jmp    80ef71 <tcp_close+0x262>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    }
    break;
  80ef6a:	90                   	nop
  80ef6b:	eb 04                	jmp    80ef71 <tcp_close+0x262>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
  80ef6d:	90                   	nop
  80ef6e:	eb 01                	jmp    80ef71 <tcp_close+0x262>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    }
    break;
  80ef70:	90                   	nop
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  80ef71:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80ef76:	74 19                	je     80ef91 <tcp_close+0x282>
  80ef78:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80ef7c:	75 13                	jne    80ef91 <tcp_close+0x282>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  80ef7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ef82:	48 89 c7             	mov    %rax,%rdi
  80ef85:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  80ef8c:	00 00 00 
  80ef8f:	ff d0                	callq  *%rax
  }
  return err;
  80ef91:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80ef95:	c9                   	leaveq 
  80ef96:	c3                   	retq   

000000000080ef97 <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  80ef97:	55                   	push   %rbp
  80ef98:	48 89 e5             	mov    %rsp,%rbp
  80ef9b:	48 83 ec 50          	sub    $0x50,%rsp
  80ef9f:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  80efa3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80efa7:	8b 40 18             	mov    0x18(%rax),%eax
  80efaa:	83 f8 0a             	cmp    $0xa,%eax
  80efad:	75 3a                	jne    80efe9 <tcp_abort+0x52>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  80efaf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80efb3:	48 89 c6             	mov    %rax,%rsi
  80efb6:	48 bf 40 b0 b5 00 00 	movabs $0xb5b040,%rdi
  80efbd:	00 00 00 
  80efc0:	48 b8 52 0b 81 00 00 	movabs $0x810b52,%rax
  80efc7:	00 00 00 
  80efca:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB, pcb);
  80efcc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80efd0:	48 89 c6             	mov    %rax,%rsi
  80efd3:	bf 02 00 00 00       	mov    $0x2,%edi
  80efd8:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  80efdf:	00 00 00 
  80efe2:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB, pcb);
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  }
}
  80efe4:	e9 75 01 00 00       	jmpq   80f15e <tcp_abort+0x1c7>
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
  } else {
    seqno = pcb->snd_nxt;
  80efe9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80efed:	8b 40 60             	mov    0x60(%rax),%eax
  80eff0:	89 45 fc             	mov    %eax,-0x4(%rbp)
    ackno = pcb->rcv_nxt;
  80eff3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eff7:	8b 40 30             	mov    0x30(%rax),%eax
  80effa:	89 45 f8             	mov    %eax,-0x8(%rbp)
    ip_addr_set(&local_ip, &(pcb->local_ip));
  80effd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f001:	48 85 c0             	test   %rax,%rax
  80f004:	74 08                	je     80f00e <tcp_abort+0x77>
  80f006:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f00a:	8b 00                	mov    (%rax),%eax
  80f00c:	eb 05                	jmp    80f013 <tcp_abort+0x7c>
  80f00e:	b8 00 00 00 00       	mov    $0x0,%eax
  80f013:	89 45 c0             	mov    %eax,-0x40(%rbp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  80f016:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f01a:	48 83 c0 04          	add    $0x4,%rax
  80f01e:	48 85 c0             	test   %rax,%rax
  80f021:	74 09                	je     80f02c <tcp_abort+0x95>
  80f023:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f027:	8b 40 04             	mov    0x4(%rax),%eax
  80f02a:	eb 05                	jmp    80f031 <tcp_abort+0x9a>
  80f02c:	b8 00 00 00 00       	mov    $0x0,%eax
  80f031:	89 45 d0             	mov    %eax,-0x30(%rbp)
    local_port = pcb->local_port;
  80f034:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f038:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f03c:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    remote_port = pcb->remote_port;
  80f040:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f044:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  80f048:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  80f04c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f050:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  80f057:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  80f05b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f05f:	48 8b 40 20          	mov    0x20(%rax),%rax
  80f063:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80f067:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f06b:	48 89 c6             	mov    %rax,%rsi
  80f06e:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  80f075:	00 00 00 
  80f078:	48 b8 52 0b 81 00 00 	movabs $0x810b52,%rax
  80f07f:	00 00 00 
  80f082:	ff d0                	callq  *%rax
    if (pcb->unacked != NULL) {
  80f084:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f088:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80f08f:	48 85 c0             	test   %rax,%rax
  80f092:	74 1a                	je     80f0ae <tcp_abort+0x117>
      tcp_segs_free(pcb->unacked);
  80f094:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f098:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80f09f:	48 89 c7             	mov    %rax,%rdi
  80f0a2:	48 b8 d3 04 81 00 00 	movabs $0x8104d3,%rax
  80f0a9:	00 00 00 
  80f0ac:	ff d0                	callq  *%rax
    }
    if (pcb->unsent != NULL) {
  80f0ae:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f0b2:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80f0b9:	48 85 c0             	test   %rax,%rax
  80f0bc:	74 1a                	je     80f0d8 <tcp_abort+0x141>
      tcp_segs_free(pcb->unsent);
  80f0be:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f0c2:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80f0c9:	48 89 c7             	mov    %rax,%rdi
  80f0cc:	48 b8 d3 04 81 00 00 	movabs $0x8104d3,%rax
  80f0d3:	00 00 00 
  80f0d6:	ff d0                	callq  *%rax
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  80f0d8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f0dc:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80f0e3:	48 85 c0             	test   %rax,%rax
  80f0e6:	74 1a                	je     80f102 <tcp_abort+0x16b>
      tcp_segs_free(pcb->ooseq);
  80f0e8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f0ec:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80f0f3:	48 89 c7             	mov    %rax,%rdi
  80f0f6:	48 b8 d3 04 81 00 00 	movabs $0x8104d3,%rax
  80f0fd:	00 00 00 
  80f100:	ff d0                	callq  *%rax
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  80f102:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80f106:	48 89 c6             	mov    %rax,%rsi
  80f109:	bf 02 00 00 00       	mov    $0x2,%edi
  80f10e:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  80f115:	00 00 00 
  80f118:	ff d0                	callq  *%rax
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  80f11a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80f11f:	74 12                	je     80f133 <tcp_abort+0x19c>
  80f121:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f125:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f129:	be fb ff ff ff       	mov    $0xfffffffb,%esi
  80f12e:	48 89 d7             	mov    %rdx,%rdi
  80f131:	ff d0                	callq  *%rax
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  80f133:	44 0f b7 45 f4       	movzwl -0xc(%rbp),%r8d
  80f138:	0f b7 7d f6          	movzwl -0xa(%rbp),%edi
  80f13c:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80f140:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  80f144:	8b 75 f8             	mov    -0x8(%rbp),%esi
  80f147:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80f14a:	45 89 c1             	mov    %r8d,%r9d
  80f14d:	41 89 f8             	mov    %edi,%r8d
  80f150:	89 c7                	mov    %eax,%edi
  80f152:	48 b8 80 46 81 00 00 	movabs $0x814680,%rax
  80f159:	00 00 00 
  80f15c:	ff d0                	callq  *%rax
  }
}
  80f15e:	90                   	nop
  80f15f:	c9                   	leaveq 
  80f160:	c3                   	retq   

000000000080f161 <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80f161:	55                   	push   %rbp
  80f162:	48 89 e5             	mov    %rsp,%rbp
  80f165:	48 83 ec 30          	sub    $0x30,%rsp
  80f169:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80f16d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80f171:	89 d0                	mov    %edx,%eax
  80f173:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80f177:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f17b:	8b 40 18             	mov    0x18(%rax),%eax
  80f17e:	85 c0                	test   %eax,%eax
  80f180:	74 2a                	je     80f1ac <tcp_bind+0x4b>
  80f182:	48 ba 90 26 82 00 00 	movabs $0x822690,%rdx
  80f189:	00 00 00 
  80f18c:	be 06 01 00 00       	mov    $0x106,%esi
  80f191:	48 bf bb 26 82 00 00 	movabs $0x8226bb,%rdi
  80f198:	00 00 00 
  80f19b:	b8 00 00 00 00       	mov    $0x0,%eax
  80f1a0:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80f1a7:	00 00 00 
  80f1aa:	ff d1                	callq  *%rcx

  if (port == 0) {
  80f1ac:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  80f1b1:	75 10                	jne    80f1c3 <tcp_bind+0x62>
    port = tcp_new_port();
  80f1b3:	48 b8 75 f7 80 00 00 	movabs $0x80f775,%rax
  80f1ba:	00 00 00 
  80f1bd:	ff d0                	callq  *%rax
  80f1bf:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80f1c3:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f1ca:	00 00 00 
  80f1cd:	48 8b 00             	mov    (%rax),%rax
  80f1d0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f1d4:	eb 58                	jmp    80f22e <tcp_bind+0xcd>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80f1d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1da:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f1de:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80f1e2:	75 3e                	jne    80f222 <tcp_bind+0xc1>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80f1e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1e8:	48 85 c0             	test   %rax,%rax
  80f1eb:	74 2b                	je     80f218 <tcp_bind+0xb7>
  80f1ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1f1:	8b 00                	mov    (%rax),%eax
  80f1f3:	85 c0                	test   %eax,%eax
  80f1f5:	74 21                	je     80f218 <tcp_bind+0xb7>
  80f1f7:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f1fc:	74 1a                	je     80f218 <tcp_bind+0xb7>
          ip_addr_isany(ipaddr) ||
  80f1fe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f202:	8b 00                	mov    (%rax),%eax
  80f204:	85 c0                	test   %eax,%eax
  80f206:	74 10                	je     80f218 <tcp_bind+0xb7>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80f208:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f20c:	8b 10                	mov    (%rax),%edx
  80f20e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f212:	8b 00                	mov    (%rax),%eax
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80f214:	39 c2                	cmp    %eax,%edx
  80f216:	75 0a                	jne    80f222 <tcp_bind+0xc1>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80f218:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80f21d:	e9 a2 01 00 00       	jmpq   80f3c4 <tcp_bind+0x263>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80f222:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f226:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f22a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80f22e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f233:	75 a1                	jne    80f1d6 <tcp_bind+0x75>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  80f235:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f23c:	00 00 00 
  80f23f:	48 8b 00             	mov    (%rax),%rax
  80f242:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f246:	eb 58                	jmp    80f2a0 <tcp_bind+0x13f>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80f248:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f24c:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f250:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80f254:	75 3e                	jne    80f294 <tcp_bind+0x133>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80f256:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f25a:	48 85 c0             	test   %rax,%rax
  80f25d:	74 2b                	je     80f28a <tcp_bind+0x129>
  80f25f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f263:	8b 00                	mov    (%rax),%eax
  80f265:	85 c0                	test   %eax,%eax
  80f267:	74 21                	je     80f28a <tcp_bind+0x129>
  80f269:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f26e:	74 1a                	je     80f28a <tcp_bind+0x129>
          ip_addr_isany(ipaddr) ||
  80f270:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f274:	8b 00                	mov    (%rax),%eax
  80f276:	85 c0                	test   %eax,%eax
  80f278:	74 10                	je     80f28a <tcp_bind+0x129>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80f27a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f27e:	8b 10                	mov    (%rax),%edx
  80f280:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f284:	8b 00                	mov    (%rax),%eax
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80f286:	39 c2                	cmp    %eax,%edx
  80f288:	75 0a                	jne    80f294 <tcp_bind+0x133>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80f28a:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80f28f:	e9 30 01 00 00       	jmpq   80f3c4 <tcp_bind+0x263>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80f294:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f298:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f29c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  80f2a0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f2a5:	75 a1                	jne    80f248 <tcp_bind+0xe7>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80f2a7:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f2ae:	00 00 00 
  80f2b1:	48 8b 00             	mov    (%rax),%rax
  80f2b4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f2b8:	eb 58                	jmp    80f312 <tcp_bind+0x1b1>
    if (cpcb->local_port == port) {
  80f2ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2be:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f2c2:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80f2c6:	75 3e                	jne    80f306 <tcp_bind+0x1a5>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80f2c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2cc:	48 85 c0             	test   %rax,%rax
  80f2cf:	74 2b                	je     80f2fc <tcp_bind+0x19b>
  80f2d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2d5:	8b 00                	mov    (%rax),%eax
  80f2d7:	85 c0                	test   %eax,%eax
  80f2d9:	74 21                	je     80f2fc <tcp_bind+0x19b>
  80f2db:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f2e0:	74 1a                	je     80f2fc <tcp_bind+0x19b>
          ip_addr_isany(ipaddr) ||
  80f2e2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f2e6:	8b 00                	mov    (%rax),%eax
  80f2e8:	85 c0                	test   %eax,%eax
  80f2ea:	74 10                	je     80f2fc <tcp_bind+0x19b>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80f2ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2f0:	8b 10                	mov    (%rax),%edx
  80f2f2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f2f6:	8b 00                	mov    (%rax),%eax
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80f2f8:	39 c2                	cmp    %eax,%edx
  80f2fa:	75 0a                	jne    80f306 <tcp_bind+0x1a5>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80f2fc:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80f301:	e9 be 00 00 00       	jmpq   80f3c4 <tcp_bind+0x263>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80f306:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f30a:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f30e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f312:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f317:	75 a1                	jne    80f2ba <tcp_bind+0x159>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80f319:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80f320:	00 00 00 
  80f323:	48 8b 00             	mov    (%rax),%rax
  80f326:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f32a:	eb 31                	jmp    80f35d <tcp_bind+0x1fc>
    if (cpcb->local_port == port) {
  80f32c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f330:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f334:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80f338:	75 17                	jne    80f351 <tcp_bind+0x1f0>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80f33a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f33e:	8b 10                	mov    (%rax),%edx
  80f340:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f344:	8b 00                	mov    (%rax),%eax
  80f346:	39 c2                	cmp    %eax,%edx
  80f348:	75 07                	jne    80f351 <tcp_bind+0x1f0>
        return ERR_USE;
  80f34a:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80f34f:	eb 73                	jmp    80f3c4 <tcp_bind+0x263>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80f351:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f355:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f359:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f35d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f362:	75 c8                	jne    80f32c <tcp_bind+0x1cb>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  80f364:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f369:	74 16                	je     80f381 <tcp_bind+0x220>
  80f36b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80f36f:	8b 00                	mov    (%rax),%eax
  80f371:	85 c0                	test   %eax,%eax
  80f373:	74 0c                	je     80f381 <tcp_bind+0x220>
    pcb->local_ip = *ipaddr;
  80f375:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f379:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f37d:	8b 12                	mov    (%rdx),%edx
  80f37f:	89 10                	mov    %edx,(%rax)
  }
  pcb->local_port = port;
  80f381:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f385:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80f389:	66 89 50 28          	mov    %dx,0x28(%rax)
  TCP_REG(&tcp_bound_pcbs, pcb);
  80f38d:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f394:	00 00 00 
  80f397:	48 8b 10             	mov    (%rax),%rdx
  80f39a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f39e:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f3a2:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f3a9:	00 00 00 
  80f3ac:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f3b0:	48 89 10             	mov    %rdx,(%rax)
  80f3b3:	48 b8 0a 87 80 00 00 	movabs $0x80870a,%rax
  80f3ba:	00 00 00 
  80f3bd:	ff d0                	callq  *%rax
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  80f3bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f3c4:	c9                   	leaveq 
  80f3c5:	c3                   	retq   

000000000080f3c6 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80f3c6:	55                   	push   %rbp
  80f3c7:	48 89 e5             	mov    %rsp,%rbp
  80f3ca:	48 83 ec 18          	sub    $0x18,%rsp
  80f3ce:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80f3d2:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80f3d6:	89 d0                	mov    %edx,%eax
  80f3d8:	88 45 ec             	mov    %al,-0x14(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
  80f3db:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  80f3e0:	c9                   	leaveq 
  80f3e1:	c3                   	retq   

000000000080f3e2 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  80f3e2:	55                   	push   %rbp
  80f3e3:	48 89 e5             	mov    %rsp,%rbp
  80f3e6:	48 83 ec 20          	sub    $0x20,%rsp
  80f3ea:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80f3ee:	89 f0                	mov    %esi,%eax
  80f3f0:	88 45 e4             	mov    %al,-0x1c(%rbp)
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  80f3f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f3f7:	8b 40 18             	mov    0x18(%rax),%eax
  80f3fa:	85 c0                	test   %eax,%eax
  80f3fc:	74 2a                	je     80f428 <tcp_listen_with_backlog+0x46>
  80f3fe:	48 ba d0 26 82 00 00 	movabs $0x8226d0,%rdx
  80f405:	00 00 00 
  80f408:	be 61 01 00 00       	mov    $0x161,%esi
  80f40d:	48 bf bb 26 82 00 00 	movabs $0x8226bb,%rdi
  80f414:	00 00 00 
  80f417:	b8 00 00 00 00       	mov    $0x0,%eax
  80f41c:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80f423:	00 00 00 
  80f426:	ff d1                	callq  *%rcx

  /* already listening? */
  if (pcb->state == LISTEN) {
  80f428:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f42c:	8b 40 18             	mov    0x18(%rax),%eax
  80f42f:	83 f8 01             	cmp    $0x1,%eax
  80f432:	75 09                	jne    80f43d <tcp_listen_with_backlog+0x5b>
    return pcb;
  80f434:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f438:	e9 e6 01 00 00       	jmpq   80f623 <tcp_listen_with_backlog+0x241>
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  80f43d:	bf 03 00 00 00       	mov    $0x3,%edi
  80f442:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  80f449:	00 00 00 
  80f44c:	ff d0                	callq  *%rax
  80f44e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (lpcb == NULL) {
  80f452:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f457:	75 0a                	jne    80f463 <tcp_listen_with_backlog+0x81>
    return NULL;
  80f459:	b8 00 00 00 00       	mov    $0x0,%eax
  80f45e:	e9 c0 01 00 00       	jmpq   80f623 <tcp_listen_with_backlog+0x241>
  }
  lpcb->callback_arg = pcb->callback_arg;
  80f463:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f467:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80f46b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f46f:	48 89 50 20          	mov    %rdx,0x20(%rax)
  lpcb->local_port = pcb->local_port;
  80f473:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f477:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f47b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f47f:	66 89 50 28          	mov    %dx,0x28(%rax)
  lpcb->state = LISTEN;
  80f483:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f487:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%rax)
  lpcb->so_options = pcb->so_options;
  80f48e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f492:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  80f496:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f49a:	66 89 50 08          	mov    %dx,0x8(%rax)
  lpcb->so_options |= SOF_ACCEPTCONN;
  80f49e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f4a2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80f4a6:	83 c8 02             	or     $0x2,%eax
  80f4a9:	89 c2                	mov    %eax,%edx
  80f4ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f4af:	66 89 50 08          	mov    %dx,0x8(%rax)
  lpcb->ttl = pcb->ttl;
  80f4b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f4b7:	0f b6 50 0b          	movzbl 0xb(%rax),%edx
  80f4bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f4bf:	88 50 0b             	mov    %dl,0xb(%rax)
  lpcb->tos = pcb->tos;
  80f4c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f4c6:	0f b6 50 0a          	movzbl 0xa(%rax),%edx
  80f4ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f4ce:	88 50 0a             	mov    %dl,0xa(%rax)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  80f4d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f4d5:	48 85 c0             	test   %rax,%rax
  80f4d8:	74 08                	je     80f4e2 <tcp_listen_with_backlog+0x100>
  80f4da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f4de:	8b 00                	mov    (%rax),%eax
  80f4e0:	eb 05                	jmp    80f4e7 <tcp_listen_with_backlog+0x105>
  80f4e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80f4e7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80f4eb:	89 02                	mov    %eax,(%rdx)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80f4ed:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f4f4:	00 00 00 
  80f4f7:	48 8b 00             	mov    (%rax),%rax
  80f4fa:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80f4fe:	75 23                	jne    80f523 <tcp_listen_with_backlog+0x141>
  80f500:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f507:	00 00 00 
  80f50a:	48 8b 00             	mov    (%rax),%rax
  80f50d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f511:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f518:	00 00 00 
  80f51b:	48 89 10             	mov    %rdx,(%rax)
  80f51e:	e9 94 00 00 00       	jmpq   80f5b7 <tcp_listen_with_backlog+0x1d5>
  80f523:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f52a:	00 00 00 
  80f52d:	48 8b 10             	mov    (%rax),%rdx
  80f530:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f537:	00 00 00 
  80f53a:	48 89 10             	mov    %rdx,(%rax)
  80f53d:	eb 66                	jmp    80f5a5 <tcp_listen_with_backlog+0x1c3>
  80f53f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f546:	00 00 00 
  80f549:	48 8b 00             	mov    (%rax),%rax
  80f54c:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f550:	48 85 c0             	test   %rax,%rax
  80f553:	74 32                	je     80f587 <tcp_listen_with_backlog+0x1a5>
  80f555:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f55c:	00 00 00 
  80f55f:	48 8b 00             	mov    (%rax),%rax
  80f562:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f566:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80f56a:	75 1b                	jne    80f587 <tcp_listen_with_backlog+0x1a5>
  80f56c:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f573:	00 00 00 
  80f576:	48 8b 00             	mov    (%rax),%rax
  80f579:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f57d:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80f581:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f585:	eb 30                	jmp    80f5b7 <tcp_listen_with_backlog+0x1d5>
  80f587:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f58e:	00 00 00 
  80f591:	48 8b 00             	mov    (%rax),%rax
  80f594:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f598:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f59f:	00 00 00 
  80f5a2:	48 89 10             	mov    %rdx,(%rax)
  80f5a5:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f5ac:	00 00 00 
  80f5af:	48 8b 00             	mov    (%rax),%rax
  80f5b2:	48 85 c0             	test   %rax,%rax
  80f5b5:	75 88                	jne    80f53f <tcp_listen_with_backlog+0x15d>
  80f5b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f5bb:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80f5c2:	00 
  memp_free(MEMP_TCP_PCB, pcb);
  80f5c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f5c7:	48 89 c6             	mov    %rax,%rsi
  80f5ca:	bf 02 00 00 00       	mov    $0x2,%edi
  80f5cf:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  80f5d6:	00 00 00 
  80f5d9:	ff d0                	callq  *%rax
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  80f5db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f5df:	48 b9 c6 f3 80 00 00 	movabs $0x80f3c6,%rcx
  80f5e6:	00 00 00 
  80f5e9:	48 89 48 30          	mov    %rcx,0x30(%rax)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  80f5ed:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f5f4:	00 00 00 
  80f5f7:	48 8b 10             	mov    (%rax),%rdx
  80f5fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f5fe:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f602:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f609:	00 00 00 
  80f60c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80f610:	48 89 10             	mov    %rdx,(%rax)
  80f613:	48 b8 0a 87 80 00 00 	movabs $0x80870a,%rax
  80f61a:	00 00 00 
  80f61d:	ff d0                	callq  *%rax
  return (struct tcp_pcb *)lpcb;
  80f61f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80f623:	c9                   	leaveq 
  80f624:	c3                   	retq   

000000000080f625 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  80f625:	55                   	push   %rbp
  80f626:	48 89 e5             	mov    %rsp,%rbp
  80f629:	48 83 ec 10          	sub    $0x10,%rsp
  80f62d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80f631:	89 f0                	mov    %esi,%eax
  80f633:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  80f637:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f63b:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  80f63f:	0f b7 d0             	movzwl %ax,%edx
  80f642:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80f646:	01 d0                	add    %edx,%eax
  80f648:	3d c0 5d 00 00       	cmp    $0x5dc0,%eax
  80f64d:	76 16                	jbe    80f665 <tcp_recved+0x40>
    pcb->rcv_wnd = TCP_WND;
  80f64f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f653:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
    pcb->rcv_ann_wnd = TCP_WND;
  80f659:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f65d:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
  80f663:	eb 3b                	jmp    80f6a0 <tcp_recved+0x7b>
  } else {
    pcb->rcv_wnd += len;
  80f665:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f669:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80f66d:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80f671:	01 c2                	add    %eax,%edx
  80f673:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f677:	66 89 50 34          	mov    %dx,0x34(%rax)
    if (pcb->rcv_wnd >= pcb->mss) {
  80f67b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f67f:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80f683:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f687:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f68b:	66 39 c2             	cmp    %ax,%dx
  80f68e:	72 10                	jb     80f6a0 <tcp_recved+0x7b>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  80f690:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f694:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80f698:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f69c:	66 89 50 36          	mov    %dx,0x36(%rax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  80f6a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6a4:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f6a8:	0f b6 c0             	movzbl %al,%eax
  80f6ab:	83 e0 01             	and    $0x1,%eax
  80f6ae:	85 c0                	test   %eax,%eax
  80f6b0:	75 77                	jne    80f729 <tcp_recved+0x104>
     !(pcb->flags & TF_ACK_NOW)) {
  80f6b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6b6:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f6ba:	0f b6 c0             	movzbl %al,%eax
  80f6bd:	83 e0 02             	and    $0x2,%eax
    if (pcb->rcv_wnd >= pcb->mss) {
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  80f6c0:	85 c0                	test   %eax,%eax
  80f6c2:	75 65                	jne    80f729 <tcp_recved+0x104>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  80f6c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6c8:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f6cc:	0f b6 c0             	movzbl %al,%eax
  80f6cf:	83 e0 01             	and    $0x1,%eax
  80f6d2:	85 c0                	test   %eax,%eax
  80f6d4:	74 3d                	je     80f713 <tcp_recved+0xee>
  80f6d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6da:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f6de:	83 e0 fe             	and    $0xfffffffe,%eax
  80f6e1:	89 c2                	mov    %eax,%edx
  80f6e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6e7:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f6ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6ee:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f6f2:	83 c8 02             	or     $0x2,%eax
  80f6f5:	89 c2                	mov    %eax,%edx
  80f6f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6fb:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f6fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f702:	48 89 c7             	mov    %rax,%rdi
  80f705:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  80f70c:	00 00 00 
  80f70f:	ff d0                	callq  *%rax
  80f711:	eb 5f                	jmp    80f772 <tcp_recved+0x14d>
  80f713:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f717:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f71b:	83 c8 01             	or     $0x1,%eax
  80f71e:	89 c2                	mov    %eax,%edx
  80f720:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f724:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f727:	eb 49                	jmp    80f772 <tcp_recved+0x14d>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  80f729:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f72d:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f731:	0f b6 c0             	movzbl %al,%eax
  80f734:	83 e0 01             	and    $0x1,%eax
  80f737:	85 c0                	test   %eax,%eax
  80f739:	74 37                	je     80f772 <tcp_recved+0x14d>
  80f73b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f73f:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  80f743:	66 3d df 2e          	cmp    $0x2edf,%ax
  80f747:	76 29                	jbe    80f772 <tcp_recved+0x14d>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  80f749:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f74d:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f751:	83 c8 02             	or     $0x2,%eax
  80f754:	89 c2                	mov    %eax,%edx
  80f756:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f75a:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f75d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f761:	48 89 c7             	mov    %rax,%rdi
  80f764:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  80f76b:	00 00 00 
  80f76e:	ff d0                	callq  *%rax
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  80f770:	eb 00                	jmp    80f772 <tcp_recved+0x14d>
  80f772:	90                   	nop
  80f773:	c9                   	leaveq 
  80f774:	c3                   	retq   

000000000080f775 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80f775:	55                   	push   %rbp
  80f776:	48 89 e5             	mov    %rsp,%rbp
  80f779:	48 83 ec 10          	sub    $0x10,%rsp
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  80f77d:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f784:	00 00 00 
  80f787:	0f b7 00             	movzwl (%rax),%eax
  80f78a:	8d 50 01             	lea    0x1(%rax),%edx
  80f78d:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f794:	00 00 00 
  80f797:	66 89 10             	mov    %dx,(%rax)
  80f79a:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f7a1:	00 00 00 
  80f7a4:	0f b7 00             	movzwl (%rax),%eax
  80f7a7:	66 85 c0             	test   %ax,%ax
  80f7aa:	79 0f                	jns    80f7bb <tcp_new_port+0x46>
    port = TCP_LOCAL_PORT_RANGE_START;
  80f7ac:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f7b3:	00 00 00 
  80f7b6:	66 c7 00 00 10       	movw   $0x1000,(%rax)
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80f7bb:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f7c2:	00 00 00 
  80f7c5:	48 8b 00             	mov    (%rax),%rax
  80f7c8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f7cc:	eb 28                	jmp    80f7f6 <tcp_new_port+0x81>
    if (pcb->local_port == port) {
  80f7ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7d2:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f7d6:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f7dd:	00 00 00 
  80f7e0:	0f b7 00             	movzwl (%rax),%eax
  80f7e3:	66 39 c2             	cmp    %ax,%dx
  80f7e6:	75 02                	jne    80f7ea <tcp_new_port+0x75>
      goto again;
  80f7e8:	eb 93                	jmp    80f77d <tcp_new_port+0x8>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80f7ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7ee:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f7f2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f7f6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f7fb:	75 d1                	jne    80f7ce <tcp_new_port+0x59>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80f7fd:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80f804:	00 00 00 
  80f807:	48 8b 00             	mov    (%rax),%rax
  80f80a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f80e:	eb 2b                	jmp    80f83b <tcp_new_port+0xc6>
    if (pcb->local_port == port) {
  80f810:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f814:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f818:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f81f:	00 00 00 
  80f822:	0f b7 00             	movzwl (%rax),%eax
  80f825:	66 39 c2             	cmp    %ax,%dx
  80f828:	75 05                	jne    80f82f <tcp_new_port+0xba>
      goto again;
  80f82a:	e9 4e ff ff ff       	jmpq   80f77d <tcp_new_port+0x8>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80f82f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f833:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f837:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f83b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f840:	75 ce                	jne    80f810 <tcp_new_port+0x9b>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80f842:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f849:	00 00 00 
  80f84c:	48 8b 00             	mov    (%rax),%rax
  80f84f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f853:	eb 2b                	jmp    80f880 <tcp_new_port+0x10b>
    if (pcb->local_port == port) {
  80f855:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f859:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f85d:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f864:	00 00 00 
  80f867:	0f b7 00             	movzwl (%rax),%eax
  80f86a:	66 39 c2             	cmp    %ax,%dx
  80f86d:	75 05                	jne    80f874 <tcp_new_port+0xff>
      goto again;
  80f86f:	e9 09 ff ff ff       	jmpq   80f77d <tcp_new_port+0x8>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80f874:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f878:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f87c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f880:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f885:	75 ce                	jne    80f855 <tcp_new_port+0xe0>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
  80f887:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  80f88e:	00 00 00 
  80f891:	0f b7 00             	movzwl (%rax),%eax
}
  80f894:	c9                   	leaveq 
  80f895:	c3                   	retq   

000000000080f896 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  80f896:	55                   	push   %rbp
  80f897:	48 89 e5             	mov    %rsp,%rbp
  80f89a:	48 83 ec 30          	sub    $0x30,%rsp
  80f89e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80f8a2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80f8a6:	89 d0                	mov    %edx,%eax
  80f8a8:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  80f8ac:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80f8b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8b4:	8b 40 18             	mov    0x18(%rax),%eax
  80f8b7:	85 c0                	test   %eax,%eax
  80f8b9:	74 2a                	je     80f8e5 <tcp_connect+0x4f>
  80f8bb:	48 ba f8 26 82 00 00 	movabs $0x8226f8,%rdx
  80f8c2:	00 00 00 
  80f8c5:	be ed 01 00 00       	mov    $0x1ed,%esi
  80f8ca:	48 bf bb 26 82 00 00 	movabs $0x8226bb,%rdi
  80f8d1:	00 00 00 
  80f8d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80f8d9:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80f8e0:	00 00 00 
  80f8e3:	ff d1                	callq  *%rcx

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  80f8e5:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f8ea:	74 28                	je     80f914 <tcp_connect+0x7e>
    pcb->remote_ip = *ipaddr;
  80f8ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8f0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f8f4:	8b 12                	mov    (%rdx),%edx
  80f8f6:	89 50 04             	mov    %edx,0x4(%rax)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  80f8f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f8fd:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80f901:	66 89 50 2a          	mov    %dx,0x2a(%rax)
  if (pcb->local_port == 0) {
  80f905:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f909:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f90d:	66 85 c0             	test   %ax,%ax
  80f910:	75 22                	jne    80f934 <tcp_connect+0x9e>
  80f912:	eb 0a                	jmp    80f91e <tcp_connect+0x88>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  80f914:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80f919:	e9 5a 02 00 00       	jmpq   80fb78 <tcp_connect+0x2e2>
  }
  pcb->remote_port = port;
  if (pcb->local_port == 0) {
    pcb->local_port = tcp_new_port();
  80f91e:	48 b8 75 f7 80 00 00 	movabs $0x80f775,%rax
  80f925:	00 00 00 
  80f928:	ff d0                	callq  *%rax
  80f92a:	89 c2                	mov    %eax,%edx
  80f92c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f930:	66 89 50 28          	mov    %dx,0x28(%rax)
  }
  iss = tcp_next_iss();
  80f934:	48 b8 50 0d 81 00 00 	movabs $0x810d50,%rax
  80f93b:	00 00 00 
  80f93e:	ff d0                	callq  *%rax
  80f940:	89 45 fc             	mov    %eax,-0x4(%rbp)
  pcb->rcv_nxt = 0;
  80f943:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f947:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
  pcb->snd_nxt = iss;
  80f94e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f952:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80f955:	89 50 60             	mov    %edx,0x60(%rax)
  pcb->lastack = iss - 1;
  80f958:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80f95b:	8d 50 ff             	lea    -0x1(%rax),%edx
  80f95e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f962:	89 50 54             	mov    %edx,0x54(%rax)
  pcb->snd_lbb = iss - 1;
  80f965:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80f968:	8d 50 ff             	lea    -0x1(%rax),%edx
  80f96b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f96f:	89 50 74             	mov    %edx,0x74(%rax)
  pcb->rcv_wnd = TCP_WND;
  80f972:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f976:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
  pcb->rcv_ann_wnd = TCP_WND;
  80f97c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f980:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
  pcb->snd_wnd = TCP_WND;
  80f986:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f98a:	66 c7 40 68 c0 5d    	movw   $0x5dc0,0x68(%rax)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80f990:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f994:	66 c7 40 40 18 02    	movw   $0x218,0x40(%rax)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  80f99a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f99e:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f9a2:	0f b7 c0             	movzwl %ax,%eax
  80f9a5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f9a9:	48 89 d6             	mov    %rdx,%rsi
  80f9ac:	89 c7                	mov    %eax,%edi
  80f9ae:	48 b8 88 0d 81 00 00 	movabs $0x810d88,%rax
  80f9b5:	00 00 00 
  80f9b8:	ff d0                	callq  *%rax
  80f9ba:	89 c2                	mov    %eax,%edx
  80f9bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f9c0:	66 89 50 40          	mov    %dx,0x40(%rax)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  80f9c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f9c8:	66 c7 40 5a 01 00    	movw   $0x1,0x5a(%rax)
  pcb->ssthresh = pcb->mss * 10;
  80f9ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f9d2:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  80f9d6:	89 d0                	mov    %edx,%eax
  80f9d8:	c1 e0 02             	shl    $0x2,%eax
  80f9db:	01 d0                	add    %edx,%eax
  80f9dd:	01 c0                	add    %eax,%eax
  80f9df:	89 c2                	mov    %eax,%edx
  80f9e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f9e5:	66 89 50 5c          	mov    %dx,0x5c(%rax)
  pcb->state = SYN_SENT;
  80f9e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f9ed:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%rax)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  80f9f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f9f8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80f9fc:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80fa03:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80fa0a:	00 00 00 
  80fa0d:	48 8b 00             	mov    (%rax),%rax
  80fa10:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80fa14:	75 23                	jne    80fa39 <tcp_connect+0x1a3>
  80fa16:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80fa1d:	00 00 00 
  80fa20:	48 8b 00             	mov    (%rax),%rax
  80fa23:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80fa27:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80fa2e:	00 00 00 
  80fa31:	48 89 10             	mov    %rdx,(%rax)
  80fa34:	e9 94 00 00 00       	jmpq   80facd <tcp_connect+0x237>
  80fa39:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80fa40:	00 00 00 
  80fa43:	48 8b 10             	mov    (%rax),%rdx
  80fa46:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80fa4d:	00 00 00 
  80fa50:	48 89 10             	mov    %rdx,(%rax)
  80fa53:	eb 66                	jmp    80fabb <tcp_connect+0x225>
  80fa55:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80fa5c:	00 00 00 
  80fa5f:	48 8b 00             	mov    (%rax),%rax
  80fa62:	48 8b 40 10          	mov    0x10(%rax),%rax
  80fa66:	48 85 c0             	test   %rax,%rax
  80fa69:	74 32                	je     80fa9d <tcp_connect+0x207>
  80fa6b:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80fa72:	00 00 00 
  80fa75:	48 8b 00             	mov    (%rax),%rax
  80fa78:	48 8b 40 10          	mov    0x10(%rax),%rax
  80fa7c:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80fa80:	75 1b                	jne    80fa9d <tcp_connect+0x207>
  80fa82:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80fa89:	00 00 00 
  80fa8c:	48 8b 00             	mov    (%rax),%rax
  80fa8f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80fa93:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80fa97:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80fa9b:	eb 30                	jmp    80facd <tcp_connect+0x237>
  80fa9d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80faa4:	00 00 00 
  80faa7:	48 8b 00             	mov    (%rax),%rax
  80faaa:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80faae:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80fab5:	00 00 00 
  80fab8:	48 89 10             	mov    %rdx,(%rax)
  80fabb:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80fac2:	00 00 00 
  80fac5:	48 8b 00             	mov    (%rax),%rax
  80fac8:	48 85 c0             	test   %rax,%rax
  80facb:	75 88                	jne    80fa55 <tcp_connect+0x1bf>
  80facd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80fad1:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80fad8:	00 
  TCP_REG(&tcp_active_pcbs, pcb);
  80fad9:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fae0:	00 00 00 
  80fae3:	48 8b 10             	mov    (%rax),%rdx
  80fae6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80faea:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80faee:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80faf5:	00 00 00 
  80faf8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80fafc:	48 89 10             	mov    %rdx,(%rax)
  80faff:	48 b8 0a 87 80 00 00 	movabs $0x80870a,%rax
  80fb06:	00 00 00 
  80fb09:	ff d0                	callq  *%rax

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  80fb0b:	bf b4 05 04 02       	mov    $0x20405b4,%edi
  80fb10:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  80fb17:	00 00 00 
  80fb1a:	ff d0                	callq  *%rax
  80fb1c:	89 45 f4             	mov    %eax,-0xc(%rbp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  80fb1f:	48 8d 55 f4          	lea    -0xc(%rbp),%rdx
  80fb23:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80fb27:	48 83 ec 08          	sub    $0x8,%rsp
  80fb2b:	6a 04                	pushq  $0x4
  80fb2d:	49 89 d1             	mov    %rdx,%r9
  80fb30:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80fb36:	b9 02 00 00 00       	mov    $0x2,%ecx
  80fb3b:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb40:	be 00 00 00 00       	mov    $0x0,%esi
  80fb45:	48 89 c7             	mov    %rax,%rdi
  80fb48:	48 b8 96 32 81 00 00 	movabs $0x813296,%rax
  80fb4f:	00 00 00 
  80fb52:	ff d0                	callq  *%rax
  80fb54:	48 83 c4 10          	add    $0x10,%rsp
  80fb58:	88 45 fb             	mov    %al,-0x5(%rbp)
  if (ret == ERR_OK) { 
  80fb5b:	80 7d fb 00          	cmpb   $0x0,-0x5(%rbp)
  80fb5f:	75 13                	jne    80fb74 <tcp_connect+0x2de>
    tcp_output(pcb);
  80fb61:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80fb65:	48 89 c7             	mov    %rax,%rdi
  80fb68:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  80fb6f:	00 00 00 
  80fb72:	ff d0                	callq  *%rax
  }
  return ret;
  80fb74:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
} 
  80fb78:	c9                   	leaveq 
  80fb79:	c3                   	retq   

000000000080fb7a <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  80fb7a:	55                   	push   %rbp
  80fb7b:	48 89 e5             	mov    %rsp,%rbp
  80fb7e:	48 83 ec 20          	sub    $0x20,%rsp
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  80fb82:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)

  ++tcp_ticks;
  80fb86:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fb8d:	00 00 00 
  80fb90:	8b 00                	mov    (%rax),%eax
  80fb92:	8d 50 01             	lea    0x1(%rax),%edx
  80fb95:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fb9c:	00 00 00 
  80fb9f:	89 10                	mov    %edx,(%rax)

  /* Steps through all of the active PCBs. */
  prev = NULL;
  80fba1:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80fba8:	00 
  pcb = tcp_active_pcbs;
  80fba9:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fbb0:	00 00 00 
  80fbb3:	48 8b 00             	mov    (%rax),%rax
  80fbb6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  80fbba:	e9 60 06 00 00       	jmpq   81021f <tcp_slowtmr+0x6a5>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  80fbbf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbc3:	8b 40 18             	mov    0x18(%rax),%eax
  80fbc6:	85 c0                	test   %eax,%eax
  80fbc8:	75 2a                	jne    80fbf4 <tcp_slowtmr+0x7a>
  80fbca:	48 ba 30 27 82 00 00 	movabs $0x822730,%rdx
  80fbd1:	00 00 00 
  80fbd4:	be 37 02 00 00       	mov    $0x237,%esi
  80fbd9:	48 bf bb 26 82 00 00 	movabs $0x8226bb,%rdi
  80fbe0:	00 00 00 
  80fbe3:	b8 00 00 00 00       	mov    $0x0,%eax
  80fbe8:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80fbef:	00 00 00 
  80fbf2:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  80fbf4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbf8:	8b 40 18             	mov    0x18(%rax),%eax
  80fbfb:	83 f8 01             	cmp    $0x1,%eax
  80fbfe:	75 2a                	jne    80fc2a <tcp_slowtmr+0xb0>
  80fc00:	48 ba 60 27 82 00 00 	movabs $0x822760,%rdx
  80fc07:	00 00 00 
  80fc0a:	be 38 02 00 00       	mov    $0x238,%esi
  80fc0f:	48 bf bb 26 82 00 00 	movabs $0x8226bb,%rdi
  80fc16:	00 00 00 
  80fc19:	b8 00 00 00 00       	mov    $0x0,%eax
  80fc1e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80fc25:	00 00 00 
  80fc28:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  80fc2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc2e:	8b 40 18             	mov    0x18(%rax),%eax
  80fc31:	83 f8 0a             	cmp    $0xa,%eax
  80fc34:	75 2a                	jne    80fc60 <tcp_slowtmr+0xe6>
  80fc36:	48 ba 90 27 82 00 00 	movabs $0x822790,%rdx
  80fc3d:	00 00 00 
  80fc40:	be 39 02 00 00       	mov    $0x239,%esi
  80fc45:	48 bf bb 26 82 00 00 	movabs $0x8226bb,%rdi
  80fc4c:	00 00 00 
  80fc4f:	b8 00 00 00 00       	mov    $0x0,%eax
  80fc54:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  80fc5b:	00 00 00 
  80fc5e:	ff d1                	callq  *%rcx

    pcb_remove = 0;
  80fc60:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  80fc64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc68:	8b 40 18             	mov    0x18(%rax),%eax
  80fc6b:	83 f8 02             	cmp    $0x2,%eax
  80fc6e:	75 15                	jne    80fc85 <tcp_slowtmr+0x10b>
  80fc70:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc74:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80fc78:	3c 06                	cmp    $0x6,%al
  80fc7a:	75 09                	jne    80fc85 <tcp_slowtmr+0x10b>
      ++pcb_remove;
  80fc7c:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
  80fc80:	e9 e6 01 00 00       	jmpq   80fe6b <tcp_slowtmr+0x2f1>
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  80fc85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc89:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80fc8d:	3c 0c                	cmp    $0xc,%al
  80fc8f:	75 09                	jne    80fc9a <tcp_slowtmr+0x120>
      ++pcb_remove;
  80fc91:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  80fc95:	e9 d1 01 00 00       	jmpq   80fe6b <tcp_slowtmr+0x2f1>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  80fc9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc9e:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80fca5:	84 c0                	test   %al,%al
  80fca7:	0f 84 9a 00 00 00    	je     80fd47 <tcp_slowtmr+0x1cd>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  80fcad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcb1:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80fcb7:	8d 50 01             	lea    0x1(%rax),%edx
  80fcba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcbe:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  80fcc4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcc8:	8b 88 d4 00 00 00    	mov    0xd4(%rax),%ecx
  80fcce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcd2:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80fcd9:	0f b6 c0             	movzbl %al,%eax
  80fcdc:	83 e8 01             	sub    $0x1,%eax
  80fcdf:	48 ba 45 26 82 00 00 	movabs $0x822645,%rdx
  80fce6:	00 00 00 
  80fce9:	48 98                	cltq   
  80fceb:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80fcef:	0f b6 c0             	movzbl %al,%eax
  80fcf2:	39 c1                	cmp    %eax,%ecx
  80fcf4:	0f 82 71 01 00 00    	jb     80fe6b <tcp_slowtmr+0x2f1>
          pcb->persist_cnt = 0;
  80fcfa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcfe:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  80fd05:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  80fd08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd0c:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80fd13:	3c 06                	cmp    $0x6,%al
  80fd15:	77 18                	ja     80fd2f <tcp_slowtmr+0x1b5>
            pcb->persist_backoff++;
  80fd17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd1b:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80fd22:	8d 50 01             	lea    0x1(%rax),%edx
  80fd25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd29:	88 90 d8 00 00 00    	mov    %dl,0xd8(%rax)
          }
          tcp_zero_window_probe(pcb);
  80fd2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd33:	48 89 c7             	mov    %rax,%rdi
  80fd36:	48 b8 7e 4c 81 00 00 	movabs $0x814c7e,%rax
  80fd3d:	00 00 00 
  80fd40:	ff d0                	callq  *%rax
  80fd42:	e9 24 01 00 00       	jmpq   80fe6b <tcp_slowtmr+0x2f1>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  80fd47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd4b:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80fd4f:	66 85 c0             	test   %ax,%ax
  80fd52:	78 15                	js     80fd69 <tcp_slowtmr+0x1ef>
          ++pcb->rtime;
  80fd54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd58:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80fd5c:	83 c0 01             	add    $0x1,%eax
  80fd5f:	89 c2                	mov    %eax,%edx
  80fd61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd65:	66 89 50 3e          	mov    %dx,0x3e(%rax)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  80fd69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd6d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80fd74:	48 85 c0             	test   %rax,%rax
  80fd77:	0f 84 ee 00 00 00    	je     80fe6b <tcp_slowtmr+0x2f1>
  80fd7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd81:	0f b7 50 3e          	movzwl 0x3e(%rax),%edx
  80fd85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd89:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80fd8d:	66 39 c2             	cmp    %ax,%dx
  80fd90:	0f 8c d5 00 00 00    	jl     80fe6b <tcp_slowtmr+0x2f1>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  80fd96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd9a:	8b 40 18             	mov    0x18(%rax),%eax
  80fd9d:	83 f8 02             	cmp    $0x2,%eax
  80fda0:	74 49                	je     80fdeb <tcp_slowtmr+0x271>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  80fda2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fda6:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80fdaa:	66 c1 f8 03          	sar    $0x3,%ax
  80fdae:	0f bf d0             	movswl %ax,%edx
  80fdb1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdb5:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  80fdb9:	98                   	cwtl   
  80fdba:	8d 34 02             	lea    (%rdx,%rax,1),%esi
  80fdbd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdc1:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80fdc5:	0f b6 c0             	movzbl %al,%eax
  80fdc8:	48 ba 38 26 82 00 00 	movabs $0x822638,%rdx
  80fdcf:	00 00 00 
  80fdd2:	48 98                	cltq   
  80fdd4:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80fdd8:	0f b6 c0             	movzbl %al,%eax
  80fddb:	89 c1                	mov    %eax,%ecx
  80fddd:	d3 e6                	shl    %cl,%esi
  80fddf:	89 f0                	mov    %esi,%eax
  80fde1:	89 c2                	mov    %eax,%edx
  80fde3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fde7:	66 89 50 50          	mov    %dx,0x50(%rax)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  80fdeb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdef:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  80fdf5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdf9:	0f b7 50 68          	movzwl 0x68(%rax),%edx
  80fdfd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe01:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  80fe05:	66 39 c2             	cmp    %ax,%dx
  80fe08:	0f 46 c2             	cmovbe %edx,%eax
  80fe0b:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
          pcb->ssthresh = eff_wnd >> 1;
  80fe0f:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  80fe13:	66 d1 e8             	shr    %ax
  80fe16:	89 c2                	mov    %eax,%edx
  80fe18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe1c:	66 89 50 5c          	mov    %dx,0x5c(%rax)
          if (pcb->ssthresh < pcb->mss) {
  80fe20:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe24:	0f b7 50 5c          	movzwl 0x5c(%rax),%edx
  80fe28:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe2c:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80fe30:	66 39 c2             	cmp    %ax,%dx
  80fe33:	73 13                	jae    80fe48 <tcp_slowtmr+0x2ce>
            pcb->ssthresh = pcb->mss * 2;
  80fe35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe39:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80fe3d:	8d 14 00             	lea    (%rax,%rax,1),%edx
  80fe40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe44:	66 89 50 5c          	mov    %dx,0x5c(%rax)
          }
          pcb->cwnd = pcb->mss;
  80fe48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe4c:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  80fe50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe54:	66 89 50 5a          	mov    %dx,0x5a(%rax)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  80fe58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe5c:	48 89 c7             	mov    %rax,%rdi
  80fe5f:	48 b8 9c 48 81 00 00 	movabs $0x81489c,%rax
  80fe66:	00 00 00 
  80fe69:	ff d0                	callq  *%rax
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  80fe6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe6f:	8b 40 18             	mov    0x18(%rax),%eax
  80fe72:	83 f8 06             	cmp    $0x6,%eax
  80fe75:	75 20                	jne    80fe97 <tcp_slowtmr+0x31d>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80fe77:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fe7e:	00 00 00 
  80fe81:	8b 10                	mov    (%rax),%edx
  80fe83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe87:	8b 40 38             	mov    0x38(%rax),%eax
  80fe8a:	29 c2                	sub    %eax,%edx
  80fe8c:	89 d0                	mov    %edx,%eax
  80fe8e:	83 f8 28             	cmp    $0x28,%eax
  80fe91:	76 04                	jbe    80fe97 <tcp_slowtmr+0x31d>
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80fe93:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  80fe97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe9b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80fe9f:	0f b7 c0             	movzwl %ax,%eax
  80fea2:	83 e0 08             	and    $0x8,%eax
  80fea5:	85 c0                	test   %eax,%eax
  80fea7:	0f 84 01 01 00 00    	je     80ffae <tcp_slowtmr+0x434>
       ((pcb->state == ESTABLISHED) || 
  80fead:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80feb1:	8b 40 18             	mov    0x18(%rax),%eax
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  80feb4:	83 f8 04             	cmp    $0x4,%eax
  80feb7:	74 10                	je     80fec9 <tcp_slowtmr+0x34f>
       ((pcb->state == ESTABLISHED) || 
        (pcb->state == CLOSE_WAIT))) {
  80feb9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80febd:	8b 40 18             	mov    0x18(%rax),%eax
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
       ((pcb->state == ESTABLISHED) || 
  80fec0:	83 f8 07             	cmp    $0x7,%eax
  80fec3:	0f 85 e5 00 00 00    	jne    80ffae <tcp_slowtmr+0x434>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80fec9:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fed0:	00 00 00 
  80fed3:	8b 10                	mov    (%rax),%edx
  80fed5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fed9:	8b 40 38             	mov    0x38(%rax),%eax
  80fedc:	29 c2                	sub    %eax,%edx
  80fede:	89 d0                	mov    %edx,%eax
  80fee0:	89 c1                	mov    %eax,%ecx
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  80fee2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fee6:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80feec:	89 c0                	mov    %eax,%eax
  80feee:	48 05 b8 4c 0a 00    	add    $0xa4cb8,%rax
  80fef4:	48 c1 e8 02          	shr    $0x2,%rax
  80fef8:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  80feff:	9b c4 20 
  80ff02:	48 f7 e2             	mul    %rdx
  80ff05:	48 89 d0             	mov    %rdx,%rax
  80ff08:	48 c1 e8 04          	shr    $0x4,%rax
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80ff0c:	48 39 c1             	cmp    %rax,%rcx
  80ff0f:	76 18                	jbe    80ff29 <tcp_slowtmr+0x3af>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  80ff11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff15:	48 89 c7             	mov    %rax,%rdi
  80ff18:	48 b8 97 ef 80 00 00 	movabs $0x80ef97,%rax
  80ff1f:	00 00 00 
  80ff22:	ff d0                	callq  *%rax
  80ff24:	e9 85 00 00 00       	jmpq   80ffae <tcp_slowtmr+0x434>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80ff29:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80ff30:	00 00 00 
  80ff33:	8b 10                	mov    (%rax),%edx
  80ff35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff39:	8b 40 38             	mov    0x38(%rax),%eax
  80ff3c:	29 c2                	sub    %eax,%edx
  80ff3e:	89 d0                	mov    %edx,%eax
  80ff40:	89 c1                	mov    %eax,%ecx
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  80ff42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff46:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80ff4c:	89 c2                	mov    %eax,%edx
  80ff4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff52:	0f b6 80 d9 00 00 00 	movzbl 0xd9(%rax),%eax
  80ff59:	0f b6 c0             	movzbl %al,%eax
  80ff5c:	48 69 c0 f8 24 01 00 	imul   $0x124f8,%rax,%rax
  80ff63:	48 01 d0             	add    %rdx,%rax
              / TCP_SLOW_INTERVAL)
  80ff66:	48 c1 e8 02          	shr    $0x2,%rax
  80ff6a:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  80ff71:	9b c4 20 
  80ff74:	48 f7 e2             	mul    %rdx
  80ff77:	48 89 d0             	mov    %rdx,%rax
  80ff7a:	48 c1 e8 04          	shr    $0x4,%rax
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80ff7e:	48 39 c1             	cmp    %rax,%rcx
  80ff81:	76 2b                	jbe    80ffae <tcp_slowtmr+0x434>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  80ff83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff87:	48 89 c7             	mov    %rax,%rdi
  80ff8a:	48 b8 47 4a 81 00 00 	movabs $0x814a47,%rax
  80ff91:	00 00 00 
  80ff94:	ff d0                	callq  *%rax
        pcb->keep_cnt_sent++;
  80ff96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff9a:	0f b6 80 d9 00 00 00 	movzbl 0xd9(%rax),%eax
  80ffa1:	8d 50 01             	lea    0x1(%rax),%edx
  80ffa4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffa8:	88 90 d9 00 00 00    	mov    %dl,0xd9(%rax)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80ffae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffb2:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80ffb9:	48 85 c0             	test   %rax,%rax
  80ffbc:	74 57                	je     810015 <tcp_slowtmr+0x49b>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  80ffbe:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80ffc5:	00 00 00 
  80ffc8:	8b 10                	mov    (%rax),%edx
  80ffca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffce:	8b 40 38             	mov    0x38(%rax),%eax
  80ffd1:	89 d1                	mov    %edx,%ecx
  80ffd3:	29 c1                	sub    %eax,%ecx
  80ffd5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffd9:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80ffdd:	0f bf d0             	movswl %ax,%edx
  80ffe0:	89 d0                	mov    %edx,%eax
  80ffe2:	01 c0                	add    %eax,%eax
  80ffe4:	01 d0                	add    %edx,%eax
  80ffe6:	01 c0                	add    %eax,%eax

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80ffe8:	39 c1                	cmp    %eax,%ecx
  80ffea:	72 29                	jb     810015 <tcp_slowtmr+0x49b>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  80ffec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fff0:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80fff7:	48 89 c7             	mov    %rax,%rdi
  80fffa:	48 b8 d3 04 81 00 00 	movabs $0x8104d3,%rax
  810001:	00 00 00 
  810004:	ff d0                	callq  *%rax
      pcb->ooseq = NULL;
  810006:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81000a:	48 c7 80 90 00 00 00 	movq   $0x0,0x90(%rax)
  810011:	00 00 00 00 
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  810015:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810019:	8b 40 18             	mov    0x18(%rax),%eax
  81001c:	83 f8 03             	cmp    $0x3,%eax
  81001f:	75 20                	jne    810041 <tcp_slowtmr+0x4c7>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  810021:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810028:	00 00 00 
  81002b:	8b 10                	mov    (%rax),%edx
  81002d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810031:	8b 40 38             	mov    0x38(%rax),%eax
  810034:	29 c2                	sub    %eax,%edx
  810036:	89 d0                	mov    %edx,%eax
  810038:	83 f8 28             	cmp    $0x28,%eax
  81003b:	76 04                	jbe    810041 <tcp_slowtmr+0x4c7>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  81003d:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  810041:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810045:	8b 40 18             	mov    0x18(%rax),%eax
  810048:	83 f8 09             	cmp    $0x9,%eax
  81004b:	75 22                	jne    81006f <tcp_slowtmr+0x4f5>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  81004d:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810054:	00 00 00 
  810057:	8b 10                	mov    (%rax),%edx
  810059:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81005d:	8b 40 38             	mov    0x38(%rax),%eax
  810060:	29 c2                	sub    %eax,%edx
  810062:	89 d0                	mov    %edx,%eax
  810064:	3d f0 00 00 00       	cmp    $0xf0,%eax
  810069:	76 04                	jbe    81006f <tcp_slowtmr+0x4f5>
        ++pcb_remove;
  81006b:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  81006f:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  810073:	0f 84 19 01 00 00    	je     810192 <tcp_slowtmr+0x618>
      tcp_pcb_purge(pcb);      
  810079:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81007d:	48 89 c7             	mov    %rax,%rdi
  810080:	48 b8 4f 0a 81 00 00 	movabs $0x810a4f,%rax
  810087:	00 00 00 
  81008a:	ff d0                	callq  *%rax
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  81008c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  810091:	74 4f                	je     8100e2 <tcp_slowtmr+0x568>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  810093:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81009a:	00 00 00 
  81009d:	48 8b 00             	mov    (%rax),%rax
  8100a0:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8100a4:	75 2a                	jne    8100d0 <tcp_slowtmr+0x556>
  8100a6:	48 ba c0 27 82 00 00 	movabs $0x8227c0,%rdx
  8100ad:	00 00 00 
  8100b0:	be c2 02 00 00       	mov    $0x2c2,%esi
  8100b5:	48 bf bb 26 82 00 00 	movabs $0x8226bb,%rdi
  8100bc:	00 00 00 
  8100bf:	b8 00 00 00 00       	mov    $0x0,%eax
  8100c4:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8100cb:	00 00 00 
  8100ce:	ff d1                	callq  *%rcx
        prev->next = pcb->next;
  8100d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100d4:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8100d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8100dc:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8100e0:	eb 52                	jmp    810134 <tcp_slowtmr+0x5ba>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  8100e2:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  8100e9:	00 00 00 
  8100ec:	48 8b 00             	mov    (%rax),%rax
  8100ef:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8100f3:	74 2a                	je     81011f <tcp_slowtmr+0x5a5>
  8100f5:	48 ba f0 27 82 00 00 	movabs $0x8227f0,%rdx
  8100fc:	00 00 00 
  8100ff:	be c6 02 00 00       	mov    $0x2c6,%esi
  810104:	48 bf bb 26 82 00 00 	movabs $0x8226bb,%rdi
  81010b:	00 00 00 
  81010e:	b8 00 00 00 00       	mov    $0x0,%eax
  810113:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81011a:	00 00 00 
  81011d:	ff d1                	callq  *%rcx
        tcp_active_pcbs = pcb->next;
  81011f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810123:	48 8b 50 10          	mov    0x10(%rax),%rdx
  810127:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81012e:	00 00 00 
  810131:	48 89 10             	mov    %rdx,(%rax)
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  810134:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810138:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  81013f:	48 85 c0             	test   %rax,%rax
  810142:	74 1d                	je     810161 <tcp_slowtmr+0x5e7>
  810144:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810148:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  81014f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  810153:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  810157:	be fb ff ff ff       	mov    $0xfffffffb,%esi
  81015c:	48 89 d7             	mov    %rdx,%rdi
  81015f:	ff d0                	callq  *%rax

      pcb2 = pcb->next;
  810161:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810165:	48 8b 40 10          	mov    0x10(%rax),%rax
  810169:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_TCP_PCB, pcb);
  81016d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810171:	48 89 c6             	mov    %rax,%rsi
  810174:	bf 02 00 00 00       	mov    $0x2,%edi
  810179:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  810180:	00 00 00 
  810183:	ff d0                	callq  *%rax
      pcb = pcb2;
  810185:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810189:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81018d:	e9 8d 00 00 00       	jmpq   81021f <tcp_slowtmr+0x6a5>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  810192:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810196:	0f b6 40 3c          	movzbl 0x3c(%rax),%eax
  81019a:	8d 50 01             	lea    0x1(%rax),%edx
  81019d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8101a1:	88 50 3c             	mov    %dl,0x3c(%rax)
      if (pcb->polltmr >= pcb->pollinterval) {
  8101a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8101a8:	0f b6 50 3c          	movzbl 0x3c(%rax),%edx
  8101ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8101b0:	0f b6 40 3d          	movzbl 0x3d(%rax),%eax
  8101b4:	38 c2                	cmp    %al,%dl
  8101b6:	72 53                	jb     81020b <tcp_slowtmr+0x691>
        pcb->polltmr = 0;
  8101b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8101bc:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  8101c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8101c4:	48 8b 80 c0 00 00 00 	mov    0xc0(%rax),%rax
  8101cb:	48 85 c0             	test   %rax,%rax
  8101ce:	74 22                	je     8101f2 <tcp_slowtmr+0x678>
  8101d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8101d4:	48 8b 80 c0 00 00 00 	mov    0xc0(%rax),%rax
  8101db:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8101df:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  8101e3:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8101e7:	48 89 ce             	mov    %rcx,%rsi
  8101ea:	48 89 d7             	mov    %rdx,%rdi
  8101ed:	ff d0                	callq  *%rax
  8101ef:	88 45 ee             	mov    %al,-0x12(%rbp)
        if (err == ERR_OK) {
  8101f2:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  8101f6:	75 13                	jne    81020b <tcp_slowtmr+0x691>
          tcp_output(pcb);
  8101f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8101fc:	48 89 c7             	mov    %rax,%rdi
  8101ff:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  810206:	00 00 00 
  810209:	ff d0                	callq  *%rax
        }
      }
      
      prev = pcb;
  81020b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81020f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb = pcb->next;
  810213:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810217:	48 8b 40 10          	mov    0x10(%rax),%rax
  81021b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  81021f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810224:	0f 85 95 f9 ff ff    	jne    80fbbf <tcp_slowtmr+0x45>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  81022a:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  810231:	00 
  pcb = tcp_tw_pcbs;
  810232:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  810239:	00 00 00 
  81023c:	48 8b 00             	mov    (%rax),%rax
  81023f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (pcb != NULL) {
  810243:	e9 63 01 00 00       	jmpq   8103ab <tcp_slowtmr+0x831>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  810248:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81024c:	8b 40 18             	mov    0x18(%rax),%eax
  81024f:	83 f8 0a             	cmp    $0xa,%eax
  810252:	74 2a                	je     81027e <tcp_slowtmr+0x704>
  810254:	48 ba 20 28 82 00 00 	movabs $0x822820,%rdx
  81025b:	00 00 00 
  81025e:	be e6 02 00 00       	mov    $0x2e6,%esi
  810263:	48 bf bb 26 82 00 00 	movabs $0x8226bb,%rdi
  81026a:	00 00 00 
  81026d:	b8 00 00 00 00       	mov    $0x0,%eax
  810272:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  810279:	00 00 00 
  81027c:	ff d1                	callq  *%rcx
    pcb_remove = 0;
  81027e:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  810282:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810289:	00 00 00 
  81028c:	8b 10                	mov    (%rax),%edx
  81028e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810292:	8b 40 38             	mov    0x38(%rax),%eax
  810295:	29 c2                	sub    %eax,%edx
  810297:	89 d0                	mov    %edx,%eax
  810299:	3d f0 00 00 00       	cmp    $0xf0,%eax
  81029e:	76 04                	jbe    8102a4 <tcp_slowtmr+0x72a>
      ++pcb_remove;
  8102a0:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  8102a4:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  8102a8:	0f 84 e9 00 00 00    	je     810397 <tcp_slowtmr+0x81d>
      tcp_pcb_purge(pcb);      
  8102ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102b2:	48 89 c7             	mov    %rax,%rdi
  8102b5:	48 b8 4f 0a 81 00 00 	movabs $0x810a4f,%rax
  8102bc:	00 00 00 
  8102bf:	ff d0                	callq  *%rax
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  8102c1:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8102c6:	74 4f                	je     810317 <tcp_slowtmr+0x79d>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  8102c8:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  8102cf:	00 00 00 
  8102d2:	48 8b 00             	mov    (%rax),%rax
  8102d5:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8102d9:	75 2a                	jne    810305 <tcp_slowtmr+0x78b>
  8102db:	48 ba 50 28 82 00 00 	movabs $0x822850,%rdx
  8102e2:	00 00 00 
  8102e5:	be f5 02 00 00       	mov    $0x2f5,%esi
  8102ea:	48 bf bb 26 82 00 00 	movabs $0x8226bb,%rdi
  8102f1:	00 00 00 
  8102f4:	b8 00 00 00 00       	mov    $0x0,%eax
  8102f9:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  810300:	00 00 00 
  810303:	ff d1                	callq  *%rcx
        prev->next = pcb->next;
  810305:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810309:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81030d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810311:	48 89 50 10          	mov    %rdx,0x10(%rax)
  810315:	eb 52                	jmp    810369 <tcp_slowtmr+0x7ef>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  810317:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81031e:	00 00 00 
  810321:	48 8b 00             	mov    (%rax),%rax
  810324:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  810328:	74 2a                	je     810354 <tcp_slowtmr+0x7da>
  81032a:	48 ba 78 28 82 00 00 	movabs $0x822878,%rdx
  810331:	00 00 00 
  810334:	be f9 02 00 00       	mov    $0x2f9,%esi
  810339:	48 bf bb 26 82 00 00 	movabs $0x8226bb,%rdi
  810340:	00 00 00 
  810343:	b8 00 00 00 00       	mov    $0x0,%eax
  810348:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81034f:	00 00 00 
  810352:	ff d1                	callq  *%rcx
        tcp_tw_pcbs = pcb->next;
  810354:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810358:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81035c:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  810363:	00 00 00 
  810366:	48 89 10             	mov    %rdx,(%rax)
      }
      pcb2 = pcb->next;
  810369:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81036d:	48 8b 40 10          	mov    0x10(%rax),%rax
  810371:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_TCP_PCB, pcb);
  810375:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810379:	48 89 c6             	mov    %rax,%rsi
  81037c:	bf 02 00 00 00       	mov    $0x2,%edi
  810381:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  810388:	00 00 00 
  81038b:	ff d0                	callq  *%rax
      pcb = pcb2;
  81038d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810391:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810395:	eb 14                	jmp    8103ab <tcp_slowtmr+0x831>
    } else {
      prev = pcb;
  810397:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81039b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb = pcb->next;
  81039f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103a3:	48 8b 40 10          	mov    0x10(%rax),%rax
  8103a7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  8103ab:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8103b0:	0f 85 92 fe ff ff    	jne    810248 <tcp_slowtmr+0x6ce>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  8103b6:	90                   	nop
  8103b7:	c9                   	leaveq 
  8103b8:	c3                   	retq   

00000000008103b9 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  8103b9:	55                   	push   %rbp
  8103ba:	48 89 e5             	mov    %rsp,%rbp
  8103bd:	48 83 ec 10          	sub    $0x10,%rsp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8103c1:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  8103c8:	00 00 00 
  8103cb:	48 8b 00             	mov    (%rax),%rax
  8103ce:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8103d2:	e9 ee 00 00 00       	jmpq   8104c5 <tcp_fasttmr+0x10c>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  8103d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103db:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  8103e2:	48 85 c0             	test   %rax,%rax
  8103e5:	0f 84 81 00 00 00    	je     81046c <tcp_fasttmr+0xb3>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  8103eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103ef:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8103f6:	48 85 c0             	test   %rax,%rax
  8103f9:	74 2e                	je     810429 <tcp_fasttmr+0x70>
  8103fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103ff:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  810406:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81040a:	48 8b 92 98 00 00 00 	mov    0x98(%rdx),%rdx
  810411:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  810415:	48 8b 79 20          	mov    0x20(%rcx),%rdi
  810419:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81041d:	b9 00 00 00 00       	mov    $0x0,%ecx
  810422:	ff d0                	callq  *%rax
  810424:	88 45 f7             	mov    %al,-0x9(%rbp)
  810427:	eb 2e                	jmp    810457 <tcp_fasttmr+0x9e>
  810429:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  81042d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810431:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  810438:	48 85 c0             	test   %rax,%rax
  81043b:	74 1a                	je     810457 <tcp_fasttmr+0x9e>
  81043d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810441:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  810448:	48 89 c7             	mov    %rax,%rdi
  81044b:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  810452:	00 00 00 
  810455:	ff d0                	callq  *%rax
      if (err == ERR_OK) {
  810457:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  81045b:	75 0f                	jne    81046c <tcp_fasttmr+0xb3>
        pcb->refused_data = NULL;
  81045d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810461:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  810468:	00 00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  81046c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810470:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  810474:	0f b6 c0             	movzbl %al,%eax
  810477:	83 e0 01             	and    $0x1,%eax
  81047a:	85 c0                	test   %eax,%eax
  81047c:	74 3b                	je     8104b9 <tcp_fasttmr+0x100>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  81047e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810482:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  810486:	83 c8 02             	or     $0x2,%eax
  810489:	89 c2                	mov    %eax,%edx
  81048b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81048f:	88 50 2c             	mov    %dl,0x2c(%rax)
  810492:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810496:	48 89 c7             	mov    %rax,%rdi
  810499:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  8104a0:	00 00 00 
  8104a3:	ff d0                	callq  *%rax
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8104a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104a9:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8104ad:	83 e0 fc             	and    $0xfffffffc,%eax
  8104b0:	89 c2                	mov    %eax,%edx
  8104b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104b6:	88 50 2c             	mov    %dl,0x2c(%rax)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8104b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104bd:	48 8b 40 10          	mov    0x10(%rax),%rax
  8104c1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8104c5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8104ca:	0f 85 07 ff ff ff    	jne    8103d7 <tcp_fasttmr+0x1e>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  8104d0:	90                   	nop
  8104d1:	c9                   	leaveq 
  8104d2:	c3                   	retq   

00000000008104d3 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  8104d3:	55                   	push   %rbp
  8104d4:	48 89 e5             	mov    %rsp,%rbp
  8104d7:	48 83 ec 20          	sub    $0x20,%rsp
  8104db:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t count = 0;
  8104df:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  struct tcp_seg *next;
  while (seg != NULL) {
  8104e3:	eb 29                	jmp    81050e <tcp_segs_free+0x3b>
    next = seg->next;
  8104e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8104e9:	48 8b 00             	mov    (%rax),%rax
  8104ec:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    count += tcp_seg_free(seg);
  8104f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8104f4:	48 89 c7             	mov    %rax,%rdi
  8104f7:	48 b8 1b 05 81 00 00 	movabs $0x81051b,%rax
  8104fe:	00 00 00 
  810501:	ff d0                	callq  *%rax
  810503:	00 45 ff             	add    %al,-0x1(%rbp)
    seg = next;
  810506:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81050a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  81050e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  810513:	75 d0                	jne    8104e5 <tcp_segs_free+0x12>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
  810515:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  810519:	c9                   	leaveq 
  81051a:	c3                   	retq   

000000000081051b <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  81051b:	55                   	push   %rbp
  81051c:	48 89 e5             	mov    %rsp,%rbp
  81051f:	48 83 ec 20          	sub    $0x20,%rsp
  810523:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t count = 0;
  810527:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  
  if (seg != NULL) {
  81052b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  810530:	74 3f                	je     810571 <tcp_seg_free+0x56>
    if (seg->p != NULL) {
  810532:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810536:	48 8b 40 08          	mov    0x8(%rax),%rax
  81053a:	48 85 c0             	test   %rax,%rax
  81053d:	74 1a                	je     810559 <tcp_seg_free+0x3e>
      count = pbuf_free(seg->p);
  81053f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810543:	48 8b 40 08          	mov    0x8(%rax),%rax
  810547:	48 89 c7             	mov    %rax,%rdi
  81054a:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  810551:	00 00 00 
  810554:	ff d0                	callq  *%rax
  810556:	88 45 ff             	mov    %al,-0x1(%rbp)
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  810559:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81055d:	48 89 c6             	mov    %rax,%rsi
  810560:	bf 04 00 00 00       	mov    $0x4,%edi
  810565:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  81056c:	00 00 00 
  81056f:	ff d0                	callq  *%rax
  }
  return count;
  810571:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  810575:	c9                   	leaveq 
  810576:	c3                   	retq   

0000000000810577 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  810577:	55                   	push   %rbp
  810578:	48 89 e5             	mov    %rsp,%rbp
  81057b:	48 83 ec 10          	sub    $0x10,%rsp
  81057f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810583:	89 f0                	mov    %esi,%eax
  810585:	88 45 f4             	mov    %al,-0xc(%rbp)
  pcb->prio = prio;
  810588:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81058c:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  810590:	88 50 1c             	mov    %dl,0x1c(%rax)
}
  810593:	90                   	nop
  810594:	c9                   	leaveq 
  810595:	c3                   	retq   

0000000000810596 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  810596:	55                   	push   %rbp
  810597:	48 89 e5             	mov    %rsp,%rbp
  81059a:	48 83 ec 20          	sub    $0x20,%rsp
  81059e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  8105a2:	bf 04 00 00 00       	mov    $0x4,%edi
  8105a7:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  8105ae:	00 00 00 
  8105b1:	ff d0                	callq  *%rax
  8105b3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (cseg == NULL) {
  8105b7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8105bc:	75 07                	jne    8105c5 <tcp_seg_copy+0x2f>
    return NULL;
  8105be:	b8 00 00 00 00       	mov    $0x0,%eax
  8105c3:	eb 3a                	jmp    8105ff <tcp_seg_copy+0x69>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  8105c5:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8105c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8105cd:	ba 28 00 00 00       	mov    $0x28,%edx
  8105d2:	48 89 ce             	mov    %rcx,%rsi
  8105d5:	48 89 c7             	mov    %rax,%rdi
  8105d8:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  8105df:	00 00 00 
  8105e2:	ff d0                	callq  *%rax
  pbuf_ref(cseg->p);
  8105e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8105e8:	48 8b 40 08          	mov    0x8(%rax),%rax
  8105ec:	48 89 c7             	mov    %rax,%rdi
  8105ef:	48 b8 ab df 80 00 00 	movabs $0x80dfab,%rax
  8105f6:	00 00 00 
  8105f9:	ff d0                	callq  *%rax
  return cseg;
  8105fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8105ff:	c9                   	leaveq 
  810600:	c3                   	retq   

0000000000810601 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  810601:	55                   	push   %rbp
  810602:	48 89 e5             	mov    %rsp,%rbp
  810605:	48 83 ec 20          	sub    $0x20,%rsp
  810609:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81060d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  810611:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  810615:	89 c8                	mov    %ecx,%eax
  810617:	88 45 e4             	mov    %al,-0x1c(%rbp)
  arg = arg;
  if (p != NULL) {
  81061a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81061f:	74 15                	je     810636 <tcp_recv_null+0x35>
    pbuf_free(p);
  810621:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810625:	48 89 c7             	mov    %rax,%rdi
  810628:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81062f:	00 00 00 
  810632:	ff d0                	callq  *%rax
  810634:	eb 1b                	jmp    810651 <tcp_recv_null+0x50>
  } else if (err == ERR_OK) {
  810636:	80 7d e4 00          	cmpb   $0x0,-0x1c(%rbp)
  81063a:	75 15                	jne    810651 <tcp_recv_null+0x50>
    return tcp_close(pcb);
  81063c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810640:	48 89 c7             	mov    %rax,%rdi
  810643:	48 b8 0f ed 80 00 00 	movabs $0x80ed0f,%rax
  81064a:	00 00 00 
  81064d:	ff d0                	callq  *%rax
  81064f:	eb 05                	jmp    810656 <tcp_recv_null+0x55>
  }
  return ERR_OK;
  810651:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810656:	c9                   	leaveq 
  810657:	c3                   	retq   

0000000000810658 <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
  810658:	55                   	push   %rbp
  810659:	48 89 e5             	mov    %rsp,%rbp
  81065c:	48 83 ec 30          	sub    $0x30,%rsp
  810660:	89 f8                	mov    %edi,%eax
  810662:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  810665:	c6 45 eb 7f          	movb   $0x7f,-0x15(%rbp)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  810669:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  inactive = NULL;
  810670:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  810677:	00 
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  810678:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81067f:	00 00 00 
  810682:	48 8b 00             	mov    (%rax),%rax
  810685:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810689:	eb 6f                	jmp    8106fa <tcp_kill_prio+0xa2>
    if (pcb->prio <= prio &&
  81068b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81068f:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  810693:	3a 45 dc             	cmp    -0x24(%rbp),%al
  810696:	77 56                	ja     8106ee <tcp_kill_prio+0x96>
       pcb->prio <= mprio &&
  810698:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81069c:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  8106a0:	3a 45 eb             	cmp    -0x15(%rbp),%al
  8106a3:	77 49                	ja     8106ee <tcp_kill_prio+0x96>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8106a5:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  8106ac:	00 00 00 
  8106af:	8b 10                	mov    (%rax),%edx
  8106b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106b5:	8b 40 38             	mov    0x38(%rax),%eax
  8106b8:	29 c2                	sub    %eax,%edx
  8106ba:	89 d0                	mov    %edx,%eax
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
  8106bc:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8106bf:	72 2d                	jb     8106ee <tcp_kill_prio+0x96>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  8106c1:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  8106c8:	00 00 00 
  8106cb:	8b 10                	mov    (%rax),%edx
  8106cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106d1:	8b 40 38             	mov    0x38(%rax),%eax
  8106d4:	29 c2                	sub    %eax,%edx
  8106d6:	89 d0                	mov    %edx,%eax
  8106d8:	89 45 ec             	mov    %eax,-0x14(%rbp)
      inactive = pcb;
  8106db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106df:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      mprio = pcb->prio;
  8106e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106e7:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8106eb:	88 45 eb             	mov    %al,-0x15(%rbp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8106ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106f2:	48 8b 40 10          	mov    0x10(%rax),%rax
  8106f6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8106fa:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8106ff:	75 8a                	jne    81068b <tcp_kill_prio+0x33>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  810701:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  810706:	74 13                	je     81071b <tcp_kill_prio+0xc3>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  810708:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81070c:	48 89 c7             	mov    %rax,%rdi
  81070f:	48 b8 97 ef 80 00 00 	movabs $0x80ef97,%rax
  810716:	00 00 00 
  810719:	ff d0                	callq  *%rax
  }      
}
  81071b:	90                   	nop
  81071c:	c9                   	leaveq 
  81071d:	c3                   	retq   

000000000081071e <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
  81071e:	55                   	push   %rbp
  81071f:	48 89 e5             	mov    %rsp,%rbp
  810722:	48 83 ec 20          	sub    $0x20,%rsp
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  810726:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  inactive = NULL;
  81072d:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  810734:	00 
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  810735:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81073c:	00 00 00 
  81073f:	48 8b 00             	mov    (%rax),%rax
  810742:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810746:	eb 4a                	jmp    810792 <tcp_kill_timewait+0x74>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  810748:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81074f:	00 00 00 
  810752:	8b 10                	mov    (%rax),%edx
  810754:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810758:	8b 40 38             	mov    0x38(%rax),%eax
  81075b:	29 c2                	sub    %eax,%edx
  81075d:	89 d0                	mov    %edx,%eax
  81075f:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  810762:	72 22                	jb     810786 <tcp_kill_timewait+0x68>
      inactivity = tcp_ticks - pcb->tmr;
  810764:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81076b:	00 00 00 
  81076e:	8b 10                	mov    (%rax),%edx
  810770:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810774:	8b 40 38             	mov    0x38(%rax),%eax
  810777:	29 c2                	sub    %eax,%edx
  810779:	89 d0                	mov    %edx,%eax
  81077b:	89 45 ec             	mov    %eax,-0x14(%rbp)
      inactive = pcb;
  81077e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810782:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  810786:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81078a:	48 8b 40 10          	mov    0x10(%rax),%rax
  81078e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810792:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810797:	75 af                	jne    810748 <tcp_kill_timewait+0x2a>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  810799:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81079e:	74 13                	je     8107b3 <tcp_kill_timewait+0x95>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  8107a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8107a4:	48 89 c7             	mov    %rax,%rdi
  8107a7:	48 b8 97 ef 80 00 00 	movabs $0x80ef97,%rax
  8107ae:	00 00 00 
  8107b1:	ff d0                	callq  *%rax
  }      
}
  8107b3:	90                   	nop
  8107b4:	c9                   	leaveq 
  8107b5:	c3                   	retq   

00000000008107b6 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  8107b6:	55                   	push   %rbp
  8107b7:	48 89 e5             	mov    %rsp,%rbp
  8107ba:	48 83 ec 20          	sub    $0x20,%rsp
  8107be:	89 f8                	mov    %edi,%eax
  8107c0:	88 45 ec             	mov    %al,-0x14(%rbp)
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  8107c3:	bf 02 00 00 00       	mov    $0x2,%edi
  8107c8:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  8107cf:	00 00 00 
  8107d2:	ff d0                	callq  *%rax
  8107d4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (pcb == NULL) {
  8107d8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8107dd:	75 4f                	jne    81082e <tcp_alloc+0x78>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
  8107df:	48 b8 1e 07 81 00 00 	movabs $0x81071e,%rax
  8107e6:	00 00 00 
  8107e9:	ff d0                	callq  *%rax
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  8107eb:	bf 02 00 00 00       	mov    $0x2,%edi
  8107f0:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  8107f7:	00 00 00 
  8107fa:	ff d0                	callq  *%rax
  8107fc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (pcb == NULL) {
  810800:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810805:	75 27                	jne    81082e <tcp_alloc+0x78>
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
  810807:	0f b6 45 ec          	movzbl -0x14(%rbp),%eax
  81080b:	89 c7                	mov    %eax,%edi
  81080d:	48 b8 58 06 81 00 00 	movabs $0x810658,%rax
  810814:	00 00 00 
  810817:	ff d0                	callq  *%rax
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  810819:	bf 02 00 00 00       	mov    $0x2,%edi
  81081e:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  810825:	00 00 00 
  810828:	ff d0                	callq  *%rax
  81082a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    }
  }
  if (pcb != NULL) {
  81082e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810833:	0f 84 23 01 00 00    	je     81095c <tcp_alloc+0x1a6>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  810839:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81083d:	ba e0 00 00 00       	mov    $0xe0,%edx
  810842:	be 00 00 00 00       	mov    $0x0,%esi
  810847:	48 89 c7             	mov    %rax,%rdi
  81084a:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  810851:	00 00 00 
  810854:	ff d0                	callq  *%rax
    pcb->prio = TCP_PRIO_NORMAL;
  810856:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81085a:	c6 40 1c 40          	movb   $0x40,0x1c(%rax)
    pcb->snd_buf = TCP_SND_BUF;
  81085e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810862:	66 c7 40 7a 40 5b    	movw   $0x5b40,0x7a(%rax)
    pcb->snd_queuelen = 0;
  810868:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81086c:	66 c7 40 7c 00 00    	movw   $0x0,0x7c(%rax)
    pcb->rcv_wnd = TCP_WND;
  810872:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810876:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
    pcb->rcv_ann_wnd = TCP_WND;
  81087c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810880:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
    pcb->tos = 0;
  810886:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81088a:	c6 40 0a 00          	movb   $0x0,0xa(%rax)
    pcb->ttl = TCP_TTL;
  81088e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810892:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  810896:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81089a:	66 c7 40 40 18 02    	movw   $0x218,0x40(%rax)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  8108a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108a4:	66 c7 40 50 06 00    	movw   $0x6,0x50(%rax)
    pcb->sa = 0;
  8108aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108ae:	66 c7 40 4c 00 00    	movw   $0x0,0x4c(%rax)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  8108b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108b8:	66 c7 40 4e 06 00    	movw   $0x6,0x4e(%rax)
    pcb->rtime = -1;
  8108be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108c2:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
    pcb->cwnd = 1;
  8108c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108cc:	66 c7 40 5a 01 00    	movw   $0x1,0x5a(%rax)
    iss = tcp_next_iss();
  8108d2:	48 b8 50 0d 81 00 00 	movabs $0x810d50,%rax
  8108d9:	00 00 00 
  8108dc:	ff d0                	callq  *%rax
  8108de:	89 45 f4             	mov    %eax,-0xc(%rbp)
    pcb->snd_wl2 = iss;
  8108e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108e5:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8108e8:	89 50 70             	mov    %edx,0x70(%rax)
    pcb->snd_nxt = iss;
  8108eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108ef:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8108f2:	89 50 60             	mov    %edx,0x60(%rax)
    pcb->snd_max = iss;
  8108f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8108f9:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8108fc:	89 50 64             	mov    %edx,0x64(%rax)
    pcb->lastack = iss;
  8108ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810903:	8b 55 f4             	mov    -0xc(%rbp),%edx
  810906:	89 50 54             	mov    %edx,0x54(%rax)
    pcb->snd_lbb = iss;   
  810909:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81090d:	8b 55 f4             	mov    -0xc(%rbp),%edx
  810910:	89 50 74             	mov    %edx,0x74(%rax)
    pcb->tmr = tcp_ticks;
  810913:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81091a:	00 00 00 
  81091d:	8b 10                	mov    (%rax),%edx
  81091f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810923:	89 50 38             	mov    %edx,0x38(%rax)

    pcb->polltmr = 0;
  810926:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81092a:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  81092e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810932:	48 b9 01 06 81 00 00 	movabs $0x810601,%rcx
  810939:	00 00 00 
  81093c:	48 89 88 a8 00 00 00 	mov    %rcx,0xa8(%rax)
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  810943:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810947:	c7 80 d0 00 00 00 00 	movl   $0x6ddd00,0xd0(%rax)
  81094e:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  810951:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810955:	c6 80 d9 00 00 00 00 	movb   $0x0,0xd9(%rax)
  }
  return pcb;
  81095c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  810960:	c9                   	leaveq 
  810961:	c3                   	retq   

0000000000810962 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  810962:	55                   	push   %rbp
  810963:	48 89 e5             	mov    %rsp,%rbp
  return tcp_alloc(TCP_PRIO_NORMAL);
  810966:	bf 40 00 00 00       	mov    $0x40,%edi
  81096b:	48 b8 b6 07 81 00 00 	movabs $0x8107b6,%rax
  810972:	00 00 00 
  810975:	ff d0                	callq  *%rax
}
  810977:	5d                   	pop    %rbp
  810978:	c3                   	retq   

0000000000810979 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  810979:	55                   	push   %rbp
  81097a:	48 89 e5             	mov    %rsp,%rbp
  81097d:	48 83 ec 10          	sub    $0x10,%rsp
  810981:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810985:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->callback_arg = arg;
  810989:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81098d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  810991:	48 89 50 20          	mov    %rdx,0x20(%rax)
}
  810995:	90                   	nop
  810996:	c9                   	leaveq 
  810997:	c3                   	retq   

0000000000810998 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  810998:	55                   	push   %rbp
  810999:	48 89 e5             	mov    %rsp,%rbp
  81099c:	48 83 ec 10          	sub    $0x10,%rsp
  8109a0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8109a4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->recv = recv;
  8109a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8109ac:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8109b0:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
}
  8109b7:	90                   	nop
  8109b8:	c9                   	leaveq 
  8109b9:	c3                   	retq   

00000000008109ba <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  8109ba:	55                   	push   %rbp
  8109bb:	48 89 e5             	mov    %rsp,%rbp
  8109be:	48 83 ec 10          	sub    $0x10,%rsp
  8109c2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8109c6:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->sent = sent;
  8109ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8109ce:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8109d2:	48 89 90 a0 00 00 00 	mov    %rdx,0xa0(%rax)
}
  8109d9:	90                   	nop
  8109da:	c9                   	leaveq 
  8109db:	c3                   	retq   

00000000008109dc <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  8109dc:	55                   	push   %rbp
  8109dd:	48 89 e5             	mov    %rsp,%rbp
  8109e0:	48 83 ec 10          	sub    $0x10,%rsp
  8109e4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8109e8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->errf = errf;
  8109ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8109f0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8109f4:	48 89 90 c8 00 00 00 	mov    %rdx,0xc8(%rax)
}
  8109fb:	90                   	nop
  8109fc:	c9                   	leaveq 
  8109fd:	c3                   	retq   

00000000008109fe <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  8109fe:	55                   	push   %rbp
  8109ff:	48 89 e5             	mov    %rsp,%rbp
  810a02:	48 83 ec 10          	sub    $0x10,%rsp
  810a06:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810a0a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  810a0e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a12:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  810a16:	48 89 50 30          	mov    %rdx,0x30(%rax)
}
  810a1a:	90                   	nop
  810a1b:	c9                   	leaveq 
  810a1c:	c3                   	retq   

0000000000810a1d <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  810a1d:	55                   	push   %rbp
  810a1e:	48 89 e5             	mov    %rsp,%rbp
  810a21:	48 83 ec 18          	sub    $0x18,%rsp
  810a25:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810a29:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  810a2d:	89 d0                	mov    %edx,%eax
  810a2f:	88 45 ec             	mov    %al,-0x14(%rbp)
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  810a32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a36:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  810a3a:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  810a41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a45:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  810a49:	88 50 3d             	mov    %dl,0x3d(%rax)
}
  810a4c:	90                   	nop
  810a4d:	c9                   	leaveq 
  810a4e:	c3                   	retq   

0000000000810a4f <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  810a4f:	55                   	push   %rbp
  810a50:	48 89 e5             	mov    %rsp,%rbp
  810a53:	48 83 ec 10          	sub    $0x10,%rsp
  810a57:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (pcb->state != CLOSED &&
  810a5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a5f:	8b 40 18             	mov    0x18(%rax),%eax
  810a62:	85 c0                	test   %eax,%eax
  810a64:	0f 84 e5 00 00 00    	je     810b4f <tcp_pcb_purge+0x100>
     pcb->state != TIME_WAIT &&
  810a6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a6e:	8b 40 18             	mov    0x18(%rax),%eax
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
  810a71:	83 f8 0a             	cmp    $0xa,%eax
  810a74:	0f 84 d5 00 00 00    	je     810b4f <tcp_pcb_purge+0x100>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {
  810a7a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a7e:	8b 40 18             	mov    0x18(%rax),%eax
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
  810a81:	83 f8 01             	cmp    $0x1,%eax
  810a84:	0f 84 c5 00 00 00    	je     810b4f <tcp_pcb_purge+0x100>
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  810a8a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a8e:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  810a95:	48 85 c0             	test   %rax,%rax
  810a98:	74 29                	je     810ac3 <tcp_pcb_purge+0x74>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  810a9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a9e:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  810aa5:	48 89 c7             	mov    %rax,%rdi
  810aa8:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  810aaf:	00 00 00 
  810ab2:	ff d0                	callq  *%rax
      pcb->refused_data = NULL;
  810ab4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810ab8:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  810abf:	00 00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  810ac3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810ac7:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)

    tcp_segs_free(pcb->ooseq);
  810acd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810ad1:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  810ad8:	48 89 c7             	mov    %rax,%rdi
  810adb:	48 b8 d3 04 81 00 00 	movabs $0x8104d3,%rax
  810ae2:	00 00 00 
  810ae5:	ff d0                	callq  *%rax
    pcb->ooseq = NULL;
  810ae7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810aeb:	48 c7 80 90 00 00 00 	movq   $0x0,0x90(%rax)
  810af2:	00 00 00 00 
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  810af6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810afa:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  810b01:	48 89 c7             	mov    %rax,%rdi
  810b04:	48 b8 d3 04 81 00 00 	movabs $0x8104d3,%rax
  810b0b:	00 00 00 
  810b0e:	ff d0                	callq  *%rax
    tcp_segs_free(pcb->unacked);
  810b10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810b14:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  810b1b:	48 89 c7             	mov    %rax,%rdi
  810b1e:	48 b8 d3 04 81 00 00 	movabs $0x8104d3,%rax
  810b25:	00 00 00 
  810b28:	ff d0                	callq  *%rax
    pcb->unacked = pcb->unsent = NULL;
  810b2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810b2e:	48 c7 80 80 00 00 00 	movq   $0x0,0x80(%rax)
  810b35:	00 00 00 00 
  810b39:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810b3d:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
  810b44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810b48:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
  }
}
  810b4f:	90                   	nop
  810b50:	c9                   	leaveq 
  810b51:	c3                   	retq   

0000000000810b52 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  810b52:	55                   	push   %rbp
  810b53:	48 89 e5             	mov    %rsp,%rbp
  810b56:	48 83 ec 10          	sub    $0x10,%rsp
  810b5a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810b5e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  TCP_RMV(pcblist, pcb);
  810b62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810b66:	48 8b 00             	mov    (%rax),%rax
  810b69:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  810b6d:	75 17                	jne    810b86 <tcp_pcb_remove+0x34>
  810b6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810b73:	48 8b 00             	mov    (%rax),%rax
  810b76:	48 8b 50 10          	mov    0x10(%rax),%rdx
  810b7a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810b7e:	48 89 10             	mov    %rdx,(%rax)
  810b81:	e9 8e 00 00 00       	jmpq   810c14 <tcp_pcb_remove+0xc2>
  810b86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810b8a:	48 8b 10             	mov    (%rax),%rdx
  810b8d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810b94:	00 00 00 
  810b97:	48 89 10             	mov    %rdx,(%rax)
  810b9a:	eb 66                	jmp    810c02 <tcp_pcb_remove+0xb0>
  810b9c:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810ba3:	00 00 00 
  810ba6:	48 8b 00             	mov    (%rax),%rax
  810ba9:	48 8b 40 10          	mov    0x10(%rax),%rax
  810bad:	48 85 c0             	test   %rax,%rax
  810bb0:	74 32                	je     810be4 <tcp_pcb_remove+0x92>
  810bb2:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810bb9:	00 00 00 
  810bbc:	48 8b 00             	mov    (%rax),%rax
  810bbf:	48 8b 40 10          	mov    0x10(%rax),%rax
  810bc3:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  810bc7:	75 1b                	jne    810be4 <tcp_pcb_remove+0x92>
  810bc9:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810bd0:	00 00 00 
  810bd3:	48 8b 00             	mov    (%rax),%rax
  810bd6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  810bda:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  810bde:	48 89 50 10          	mov    %rdx,0x10(%rax)
  810be2:	eb 30                	jmp    810c14 <tcp_pcb_remove+0xc2>
  810be4:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810beb:	00 00 00 
  810bee:	48 8b 00             	mov    (%rax),%rax
  810bf1:	48 8b 50 10          	mov    0x10(%rax),%rdx
  810bf5:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810bfc:	00 00 00 
  810bff:	48 89 10             	mov    %rdx,(%rax)
  810c02:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810c09:	00 00 00 
  810c0c:	48 8b 00             	mov    (%rax),%rax
  810c0f:	48 85 c0             	test   %rax,%rax
  810c12:	75 88                	jne    810b9c <tcp_pcb_remove+0x4a>
  810c14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c18:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  810c1f:	00 

  tcp_pcb_purge(pcb);
  810c20:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c24:	48 89 c7             	mov    %rax,%rdi
  810c27:	48 b8 4f 0a 81 00 00 	movabs $0x810a4f,%rax
  810c2e:	00 00 00 
  810c31:	ff d0                	callq  *%rax
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  810c33:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c37:	8b 40 18             	mov    0x18(%rax),%eax
  810c3a:	83 f8 0a             	cmp    $0xa,%eax
  810c3d:	74 45                	je     810c84 <tcp_pcb_remove+0x132>
     pcb->state != LISTEN &&
  810c3f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c43:	8b 40 18             	mov    0x18(%rax),%eax
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  810c46:	83 f8 01             	cmp    $0x1,%eax
  810c49:	74 39                	je     810c84 <tcp_pcb_remove+0x132>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  810c4b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c4f:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  810c53:	0f b6 c0             	movzbl %al,%eax
  810c56:	83 e0 01             	and    $0x1,%eax

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  810c59:	85 c0                	test   %eax,%eax
  810c5b:	74 27                	je     810c84 <tcp_pcb_remove+0x132>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  810c5d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c61:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  810c65:	83 c8 02             	or     $0x2,%eax
  810c68:	89 c2                	mov    %eax,%edx
  810c6a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c6e:	88 50 2c             	mov    %dl,0x2c(%rax)
    tcp_output(pcb);
  810c71:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c75:	48 89 c7             	mov    %rax,%rdi
  810c78:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  810c7f:	00 00 00 
  810c82:	ff d0                	callq  *%rax
  }

  if (pcb->state != LISTEN) {
  810c84:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c88:	8b 40 18             	mov    0x18(%rax),%eax
  810c8b:	83 f8 01             	cmp    $0x1,%eax
  810c8e:	0f 84 ae 00 00 00    	je     810d42 <tcp_pcb_remove+0x1f0>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  810c94:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810c98:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  810c9f:	48 85 c0             	test   %rax,%rax
  810ca2:	74 2a                	je     810cce <tcp_pcb_remove+0x17c>
  810ca4:	48 ba 9e 28 82 00 00 	movabs $0x82289e,%rdx
  810cab:	00 00 00 
  810cae:	be b5 04 00 00       	mov    $0x4b5,%esi
  810cb3:	48 bf bb 26 82 00 00 	movabs $0x8226bb,%rdi
  810cba:	00 00 00 
  810cbd:	b8 00 00 00 00       	mov    $0x0,%eax
  810cc2:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  810cc9:	00 00 00 
  810ccc:	ff d1                	callq  *%rcx
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  810cce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810cd2:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  810cd9:	48 85 c0             	test   %rax,%rax
  810cdc:	74 2a                	je     810d08 <tcp_pcb_remove+0x1b6>
  810cde:	48 ba b6 28 82 00 00 	movabs $0x8228b6,%rdx
  810ce5:	00 00 00 
  810ce8:	be b6 04 00 00       	mov    $0x4b6,%esi
  810ced:	48 bf bb 26 82 00 00 	movabs $0x8226bb,%rdi
  810cf4:	00 00 00 
  810cf7:	b8 00 00 00 00       	mov    $0x0,%eax
  810cfc:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  810d03:	00 00 00 
  810d06:	ff d1                	callq  *%rcx
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  810d08:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810d0c:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  810d13:	48 85 c0             	test   %rax,%rax
  810d16:	74 2a                	je     810d42 <tcp_pcb_remove+0x1f0>
  810d18:	48 ba cf 28 82 00 00 	movabs $0x8228cf,%rdx
  810d1f:	00 00 00 
  810d22:	be b8 04 00 00       	mov    $0x4b8,%esi
  810d27:	48 bf bb 26 82 00 00 	movabs $0x8226bb,%rdi
  810d2e:	00 00 00 
  810d31:	b8 00 00 00 00       	mov    $0x0,%eax
  810d36:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  810d3d:	00 00 00 
  810d40:	ff d1                	callq  *%rcx
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  810d42:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810d46:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  810d4d:	90                   	nop
  810d4e:	c9                   	leaveq 
  810d4f:	c3                   	retq   

0000000000810d50 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  810d50:	55                   	push   %rbp
  810d51:	48 89 e5             	mov    %rsp,%rbp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  810d54:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  810d5b:	00 00 00 
  810d5e:	8b 10                	mov    (%rax),%edx
  810d60:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810d67:	00 00 00 
  810d6a:	8b 00                	mov    (%rax),%eax
  810d6c:	01 c2                	add    %eax,%edx
  810d6e:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  810d75:	00 00 00 
  810d78:	89 10                	mov    %edx,(%rax)
  return iss;
  810d7a:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  810d81:	00 00 00 
  810d84:	8b 00                	mov    (%rax),%eax
}
  810d86:	5d                   	pop    %rbp
  810d87:	c3                   	retq   

0000000000810d88 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  810d88:	55                   	push   %rbp
  810d89:	48 89 e5             	mov    %rsp,%rbp
  810d8c:	48 83 ec 20          	sub    $0x20,%rsp
  810d90:	89 f8                	mov    %edi,%eax
  810d92:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  810d96:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  810d9a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810d9e:	48 89 c7             	mov    %rax,%rdi
  810da1:	48 b8 88 0e 81 00 00 	movabs $0x810e88,%rax
  810da8:	00 00 00 
  810dab:	ff d0                	callq  *%rax
  810dad:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if ((outif != NULL) && (outif->mtu != 0)) {
  810db1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810db6:	74 2d                	je     810de5 <tcp_eff_send_mss+0x5d>
  810db8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810dbc:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  810dc0:	66 85 c0             	test   %ax,%ax
  810dc3:	74 20                	je     810de5 <tcp_eff_send_mss+0x5d>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  810dc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810dc9:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  810dcd:	83 e8 28             	sub    $0x28,%eax
  810dd0:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  810dd4:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  810dd8:	66 39 45 f6          	cmp    %ax,-0xa(%rbp)
  810ddc:	66 0f 46 45 f6       	cmovbe -0xa(%rbp),%ax
  810de1:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  }
  return sendmss;
  810de5:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
}
  810de9:	c9                   	leaveq 
  810dea:	c3                   	retq   

0000000000810deb <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  810deb:	55                   	push   %rbp
  810dec:	48 89 e5             	mov    %rsp,%rbp
  810def:	48 83 ec 20          	sub    $0x20,%rsp
  810df3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  810df7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  u32_t addr2test;

  addr2test = addr->addr;
  810dfb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810dff:	8b 00                	mov    (%rax),%eax
  810e01:	89 45 fc             	mov    %eax,-0x4(%rbp)
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  810e04:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  810e08:	74 06                	je     810e10 <ip_addr_isbroadcast+0x25>
  810e0a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  810e0e:	75 07                	jne    810e17 <ip_addr_isbroadcast+0x2c>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  810e10:	b8 01 00 00 00       	mov    $0x1,%eax
  810e15:	eb 6f                	jmp    810e86 <ip_addr_isbroadcast+0x9b>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  810e17:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810e1b:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  810e1f:	0f b6 c0             	movzbl %al,%eax
  810e22:	83 e0 02             	and    $0x2,%eax
  810e25:	85 c0                	test   %eax,%eax
  810e27:	75 07                	jne    810e30 <ip_addr_isbroadcast+0x45>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  810e29:	b8 00 00 00 00       	mov    $0x0,%eax
  810e2e:	eb 56                	jmp    810e86 <ip_addr_isbroadcast+0x9b>
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  810e30:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810e34:	8b 40 08             	mov    0x8(%rax),%eax
  810e37:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  810e3a:	75 07                	jne    810e43 <ip_addr_isbroadcast+0x58>
    return 0;
  810e3c:	b8 00 00 00 00       	mov    $0x0,%eax
  810e41:	eb 43                	jmp    810e86 <ip_addr_isbroadcast+0x9b>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  810e43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810e47:	8b 10                	mov    (%rax),%edx
  810e49:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810e4d:	8b 40 08             	mov    0x8(%rax),%eax
  810e50:	31 c2                	xor    %eax,%edx
  810e52:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810e56:	8b 40 0c             	mov    0xc(%rax),%eax
  810e59:	21 d0                	and    %edx,%eax
  810e5b:	85 c0                	test   %eax,%eax
  810e5d:	75 22                	jne    810e81 <ip_addr_isbroadcast+0x96>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  810e5f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810e63:	8b 40 0c             	mov    0xc(%rax),%eax
  810e66:	f7 d0                	not    %eax
  810e68:	23 45 fc             	and    -0x4(%rbp),%eax
  810e6b:	89 c2                	mov    %eax,%edx
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
  810e6d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810e71:	8b 40 0c             	mov    0xc(%rax),%eax
  810e74:	f7 d0                	not    %eax
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  810e76:	39 c2                	cmp    %eax,%edx
  810e78:	75 07                	jne    810e81 <ip_addr_isbroadcast+0x96>
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  810e7a:	b8 01 00 00 00       	mov    $0x1,%eax
  810e7f:	eb 05                	jmp    810e86 <ip_addr_isbroadcast+0x9b>
  else
    return 0;
  810e81:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810e86:	c9                   	leaveq 
  810e87:	c3                   	retq   

0000000000810e88 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  810e88:	55                   	push   %rbp
  810e89:	48 89 e5             	mov    %rsp,%rbp
  810e8c:	48 83 ec 20          	sub    $0x20,%rsp
  810e90:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  810e94:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  810e9b:	00 00 00 
  810e9e:	48 8b 00             	mov    (%rax),%rax
  810ea1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810ea5:	eb 44                	jmp    810eeb <ip_route+0x63>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  810ea7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810eab:	48 89 c7             	mov    %rax,%rdi
  810eae:	48 b8 c6 d4 80 00 00 	movabs $0x80d4c6,%rax
  810eb5:	00 00 00 
  810eb8:	ff d0                	callq  *%rax
  810eba:	84 c0                	test   %al,%al
  810ebc:	74 22                	je     810ee0 <ip_route+0x58>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  810ebe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810ec2:	8b 10                	mov    (%rax),%edx
  810ec4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810ec8:	8b 40 08             	mov    0x8(%rax),%eax
  810ecb:	31 c2                	xor    %eax,%edx
  810ecd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810ed1:	8b 40 0c             	mov    0xc(%rax),%eax
  810ed4:	21 d0                	and    %edx,%eax
  810ed6:	85 c0                	test   %eax,%eax
  810ed8:	75 06                	jne    810ee0 <ip_route+0x58>
        /* return netif on which to forward IP packet */
        return netif;
  810eda:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810ede:	eb 58                	jmp    810f38 <ip_route+0xb0>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  810ee0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810ee4:	48 8b 00             	mov    (%rax),%rax
  810ee7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810eeb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810ef0:	75 b5                	jne    810ea7 <ip_route+0x1f>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  810ef2:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  810ef9:	00 00 00 
  810efc:	48 8b 00             	mov    (%rax),%rax
  810eff:	48 85 c0             	test   %rax,%rax
  810f02:	74 20                	je     810f24 <ip_route+0x9c>
  810f04:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  810f0b:	00 00 00 
  810f0e:	48 8b 00             	mov    (%rax),%rax
  810f11:	48 89 c7             	mov    %rax,%rdi
  810f14:	48 b8 c6 d4 80 00 00 	movabs $0x80d4c6,%rax
  810f1b:	00 00 00 
  810f1e:	ff d0                	callq  *%rax
  810f20:	84 c0                	test   %al,%al
  810f22:	75 07                	jne    810f2b <ip_route+0xa3>
    LWIP_DEBUGF(IP_DEBUG | 2, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  810f24:	b8 00 00 00 00       	mov    $0x0,%eax
  810f29:	eb 0d                	jmp    810f38 <ip_route+0xb0>
  }
  /* no matching netif found, use default netif */
  return netif_default;
  810f2b:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  810f32:	00 00 00 
  810f35:	48 8b 00             	mov    (%rax),%rax
}
  810f38:	c9                   	leaveq 
  810f39:	c3                   	retq   

0000000000810f3a <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  810f3a:	55                   	push   %rbp
  810f3b:	48 89 e5             	mov    %rsp,%rbp
  810f3e:	53                   	push   %rbx
  810f3f:	48 83 ec 38          	sub    $0x38,%rsp
  810f43:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  810f47:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if LWIP_DHCP
  int check_ip_src=1;
  810f4b:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  810f52:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810f56:	48 8b 40 08          	mov    0x8(%rax),%rax
  810f5a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (IPH_V(iphdr) != 4) {
  810f5e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810f62:	0f b7 00             	movzwl (%rax),%eax
  810f65:	0f b7 c0             	movzwl %ax,%eax
  810f68:	89 c7                	mov    %eax,%edi
  810f6a:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  810f71:	00 00 00 
  810f74:	ff d0                	callq  *%rax
  810f76:	66 c1 e8 0c          	shr    $0xc,%ax
  810f7a:	66 83 f8 04          	cmp    $0x4,%ax
  810f7e:	74 1d                	je     810f9d <ip_input+0x63>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  810f80:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810f84:	48 89 c7             	mov    %rax,%rdi
  810f87:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  810f8e:	00 00 00 
  810f91:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  810f93:	b8 00 00 00 00       	mov    $0x0,%eax
  810f98:	e9 1a 04 00 00       	jmpq   8113b7 <ip_input+0x47d>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  810f9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810fa1:	0f b7 00             	movzwl (%rax),%eax
  810fa4:	0f b7 c0             	movzwl %ax,%eax
  810fa7:	89 c7                	mov    %eax,%edi
  810fa9:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  810fb0:	00 00 00 
  810fb3:	ff d0                	callq  *%rax
  810fb5:	66 c1 e8 08          	shr    $0x8,%ax
  810fb9:	83 e0 0f             	and    $0xf,%eax
  810fbc:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  810fc0:	66 c1 65 d6 02       	shlw   $0x2,-0x2a(%rbp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  810fc5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810fc9:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  810fcd:	0f b7 c0             	movzwl %ax,%eax
  810fd0:	89 c7                	mov    %eax,%edi
  810fd2:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  810fd9:	00 00 00 
  810fdc:	ff d0                	callq  *%rax
  810fde:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  810fe2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810fe6:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  810fea:	66 3b 45 d6          	cmp    -0x2a(%rbp),%ax
  810fee:	72 0e                	jb     810ffe <ip_input+0xc4>
  810ff0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810ff4:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  810ff8:	66 3b 45 d4          	cmp    -0x2c(%rbp),%ax
  810ffc:	73 1d                	jae    81101b <ip_input+0xe1>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  810ffe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811002:	48 89 c7             	mov    %rax,%rdi
  811005:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81100c:	00 00 00 
  81100f:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  811011:	b8 00 00 00 00       	mov    $0x0,%eax
  811016:	e9 9c 03 00 00       	jmpq   8113b7 <ip_input+0x47d>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  81101b:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  81101f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811023:	89 d6                	mov    %edx,%esi
  811025:	48 89 c7             	mov    %rax,%rdi
  811028:	48 b8 c9 2b 81 00 00 	movabs $0x812bc9,%rax
  81102f:	00 00 00 
  811032:	ff d0                	callq  *%rax
  811034:	66 85 c0             	test   %ax,%ax
  811037:	74 1d                	je     811056 <ip_input+0x11c>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  811039:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81103d:	48 89 c7             	mov    %rax,%rdi
  811040:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  811047:	00 00 00 
  81104a:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  81104c:	b8 00 00 00 00       	mov    $0x0,%eax
  811051:	e9 61 03 00 00       	jmpq   8113b7 <ip_input+0x47d>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  811056:	0f b7 55 d4          	movzwl -0x2c(%rbp),%edx
  81105a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81105e:	89 d6                	mov    %edx,%esi
  811060:	48 89 c7             	mov    %rax,%rdi
  811063:	48 b8 ba d9 80 00 00 	movabs $0x80d9ba,%rax
  81106a:	00 00 00 
  81106d:	ff d0                	callq  *%rax
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  81106f:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
    netif = inp;
  811076:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81107a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  81107e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811082:	48 89 c7             	mov    %rax,%rdi
  811085:	48 b8 c6 d4 80 00 00 	movabs $0x80d4c6,%rax
  81108c:	00 00 00 
  81108f:	ff d0                	callq  *%rax
  811091:	84 c0                	test   %al,%al
  811093:	74 4c                	je     8110e1 <ip_input+0x1a7>
  811095:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811099:	48 83 c0 08          	add    $0x8,%rax
  81109d:	48 85 c0             	test   %rax,%rax
  8110a0:	74 3f                	je     8110e1 <ip_input+0x1a7>
  8110a2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8110a6:	8b 40 08             	mov    0x8(%rax),%eax
  8110a9:	85 c0                	test   %eax,%eax
  8110ab:	74 34                	je     8110e1 <ip_input+0x1a7>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  8110ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8110b1:	8b 50 10             	mov    0x10(%rax),%edx
  8110b4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8110b8:	8b 40 08             	mov    0x8(%rax),%eax
  8110bb:	39 c2                	cmp    %eax,%edx
  8110bd:	74 6f                	je     81112e <ip_input+0x1f4>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  8110bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8110c3:	48 8d 50 10          	lea    0x10(%rax),%rdx
  8110c7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8110cb:	48 89 c6             	mov    %rax,%rsi
  8110ce:	48 89 d7             	mov    %rdx,%rdi
  8110d1:	48 b8 eb 0d 81 00 00 	movabs $0x810deb,%rax
  8110d8:	00 00 00 
  8110db:	ff d0                	callq  *%rax
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  8110dd:	84 c0                	test   %al,%al
  8110df:	75 4d                	jne    81112e <ip_input+0x1f4>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  8110e1:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  8110e5:	74 1a                	je     811101 <ip_input+0x1c7>
        first = 0;
  8110e7:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
        netif = netif_list;
  8110ee:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  8110f5:	00 00 00 
  8110f8:	48 8b 00             	mov    (%rax),%rax
  8110fb:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8110ff:	eb 0b                	jmp    81110c <ip_input+0x1d2>
      } else {
        netif = netif->next;
  811101:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811105:	48 8b 00             	mov    (%rax),%rax
  811108:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      }
      if (netif == inp) {
  81110c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811110:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  811114:	75 0b                	jne    811121 <ip_input+0x1e7>
        netif = netif->next;
  811116:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81111a:	48 8b 00             	mov    (%rax),%rax
  81111d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      }
    } while(netif != NULL);
  811121:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811126:	0f 85 52 ff ff ff    	jne    81107e <ip_input+0x144>
  81112c:	eb 01                	jmp    81112f <ip_input+0x1f5>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
          LWIP_DEBUGF(IP_DEBUG, ("ip_input: packet accepted on interface %c%c\n",
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
  81112e:	90                   	nop
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  81112f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811134:	75 59                	jne    81118f <ip_input+0x255>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  811136:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81113a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81113e:	0f b7 c0             	movzwl %ax,%eax
  811141:	89 c7                	mov    %eax,%edi
  811143:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81114a:	00 00 00 
  81114d:	ff d0                	callq  *%rax
  81114f:	0f b7 c0             	movzwl %ax,%eax
  811152:	0f b6 c0             	movzbl %al,%eax
  811155:	83 f8 11             	cmp    $0x11,%eax
  811158:	75 35                	jne    81118f <ip_input+0x255>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  81115a:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  81115e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811162:	48 01 d0             	add    %rdx,%rax
  811165:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  811169:	0f b7 c0             	movzwl %ax,%eax
  81116c:	89 c7                	mov    %eax,%edi
  81116e:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  811175:	00 00 00 
  811178:	ff d0                	callq  *%rax
  81117a:	66 83 f8 44          	cmp    $0x44,%ax
  81117e:	75 0f                	jne    81118f <ip_input+0x255>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  811180:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  811184:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        check_ip_src = 0;
  811188:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
  }
#endif /* LWIP_DHCP */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
  81118f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  811193:	74 6e                	je     811203 <ip_input+0x2c9>
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  811195:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811199:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  81119d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8111a1:	48 89 c6             	mov    %rax,%rsi
  8111a4:	48 89 d7             	mov    %rdx,%rdi
  8111a7:	48 b8 eb 0d 81 00 00 	movabs $0x810deb,%rax
  8111ae:	00 00 00 
  8111b1:	ff d0                	callq  *%rax
  8111b3:	84 c0                	test   %al,%al
  8111b5:	75 2f                	jne    8111e6 <ip_input+0x2ac>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  8111b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8111bb:	8b 58 0c             	mov    0xc(%rax),%ebx
  8111be:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  8111c3:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  8111ca:	00 00 00 
  8111cd:	ff d0                	callq  *%rax
  8111cf:	21 c3                	and    %eax,%ebx
  8111d1:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  8111d6:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  8111dd:	00 00 00 
  8111e0:	ff d0                	callq  *%rax

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  8111e2:	39 c3                	cmp    %eax,%ebx
  8111e4:	75 1d                	jne    811203 <ip_input+0x2c9>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  8111e6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8111ea:	48 89 c7             	mov    %rax,%rdi
  8111ed:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  8111f4:	00 00 00 
  8111f7:	ff d0                	callq  *%rax
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  8111f9:	b8 00 00 00 00       	mov    $0x0,%eax
  8111fe:	e9 b4 01 00 00       	jmpq   8113b7 <ip_input+0x47d>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  811203:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811208:	75 1d                	jne    811227 <ip_input+0x2ed>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  81120a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81120e:	48 89 c7             	mov    %rax,%rdi
  811211:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  811218:	00 00 00 
  81121b:	ff d0                	callq  *%rax
    return ERR_OK;
  81121d:	b8 00 00 00 00       	mov    $0x0,%eax
  811222:	e9 90 01 00 00       	jmpq   8113b7 <ip_input+0x47d>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  811227:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81122b:	0f b7 58 06          	movzwl 0x6(%rax),%ebx
  81122f:	bf ff 3f 00 00       	mov    $0x3fff,%edi
  811234:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  81123b:	00 00 00 
  81123e:	ff d0                	callq  *%rax
  811240:	21 d8                	and    %ebx,%eax
  811242:	66 85 c0             	test   %ax,%ax
  811245:	74 34                	je     81127b <ip_input+0x341>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  811247:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81124b:	48 89 c7             	mov    %rax,%rdi
  81124e:	48 b8 a7 20 81 00 00 	movabs $0x8120a7,%rax
  811255:	00 00 00 
  811258:	ff d0                	callq  *%rax
  81125a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  81125e:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  811263:	75 0a                	jne    81126f <ip_input+0x335>
      return ERR_OK;
  811265:	b8 00 00 00 00       	mov    $0x0,%eax
  81126a:	e9 48 01 00 00       	jmpq   8113b7 <ip_input+0x47d>
    }
    iphdr = p->payload;
  81126f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811273:	48 8b 40 08          	mov    0x8(%rax),%rax
  811277:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  81127b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  81127f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811283:	48 89 d6             	mov    %rdx,%rsi
  811286:	48 89 c7             	mov    %rax,%rdi
  811289:	48 b8 6b ff 81 00 00 	movabs $0x81ff6b,%rax
  811290:	00 00 00 
  811293:	ff d0                	callq  *%rax
  811295:	84 c0                	test   %al,%al
  811297:	0f 85 15 01 00 00    	jne    8113b2 <ip_input+0x478>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  81129d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8112a1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8112a5:	0f b7 c0             	movzwl %ax,%eax
  8112a8:	89 c7                	mov    %eax,%edi
  8112aa:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  8112b1:	00 00 00 
  8112b4:	ff d0                	callq  *%rax
  8112b6:	0f b7 c0             	movzwl %ax,%eax
  8112b9:	0f b6 c0             	movzbl %al,%eax
  8112bc:	83 f8 06             	cmp    $0x6,%eax
  8112bf:	74 2b                	je     8112ec <ip_input+0x3b2>
  8112c1:	83 f8 11             	cmp    $0x11,%eax
  8112c4:	74 07                	je     8112cd <ip_input+0x393>
  8112c6:	83 f8 01             	cmp    $0x1,%eax
  8112c9:	74 40                	je     81130b <ip_input+0x3d1>
  8112cb:	eb 5d                	jmp    81132a <ip_input+0x3f0>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  8112cd:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8112d1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8112d5:	48 89 d6             	mov    %rdx,%rsi
  8112d8:	48 89 c7             	mov    %rax,%rdi
  8112db:	48 b8 f2 4e 81 00 00 	movabs $0x814ef2,%rax
  8112e2:	00 00 00 
  8112e5:	ff d0                	callq  *%rax
      break;
  8112e7:	e9 c6 00 00 00       	jmpq   8113b2 <ip_input+0x478>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  8112ec:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8112f0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8112f4:	48 89 d6             	mov    %rdx,%rsi
  8112f7:	48 89 c7             	mov    %rax,%rdi
  8112fa:	48 b8 07 c6 81 00 00 	movabs $0x81c607,%rax
  811301:	00 00 00 
  811304:	ff d0                	callq  *%rax
      break;
  811306:	e9 a7 00 00 00       	jmpq   8113b2 <ip_input+0x478>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  81130b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  81130f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811313:	48 89 d6             	mov    %rdx,%rsi
  811316:	48 89 c7             	mov    %rax,%rdi
  811319:	48 b8 26 04 82 00 00 	movabs $0x820426,%rax
  811320:	00 00 00 
  811323:	ff d0                	callq  *%rax
      break;
  811325:	e9 88 00 00 00       	jmpq   8113b2 <ip_input+0x478>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  81132a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81132e:	48 8d 50 10          	lea    0x10(%rax),%rdx
  811332:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  811336:	48 89 c6             	mov    %rax,%rsi
  811339:	48 89 d7             	mov    %rdx,%rdi
  81133c:	48 b8 eb 0d 81 00 00 	movabs $0x810deb,%rax
  811343:	00 00 00 
  811346:	ff d0                	callq  *%rax
  811348:	84 c0                	test   %al,%al
  81134a:	75 53                	jne    81139f <ip_input+0x465>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  81134c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811350:	8b 58 10             	mov    0x10(%rax),%ebx
  811353:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  811358:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  81135f:	00 00 00 
  811362:	ff d0                	callq  *%rax
  811364:	21 c3                	and    %eax,%ebx
  811366:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81136b:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  811372:	00 00 00 
  811375:	ff d0                	callq  *%rax
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  811377:	39 c3                	cmp    %eax,%ebx
  811379:	74 24                	je     81139f <ip_input+0x465>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  81137b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81137f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811383:	48 89 50 08          	mov    %rdx,0x8(%rax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  811387:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81138b:	be 02 00 00 00       	mov    $0x2,%esi
  811390:	48 89 c7             	mov    %rax,%rdi
  811393:	48 b8 5a 09 82 00 00 	movabs $0x82095a,%rax
  81139a:	00 00 00 
  81139d:	ff d0                	callq  *%rax
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  81139f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8113a3:	48 89 c7             	mov    %rax,%rdi
  8113a6:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  8113ad:	00 00 00 
  8113b0:	ff d0                	callq  *%rax
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
  8113b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8113b7:	48 83 c4 38          	add    $0x38,%rsp
  8113bb:	5b                   	pop    %rbx
  8113bc:	5d                   	pop    %rbp
  8113bd:	c3                   	retq   

00000000008113be <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  8113be:	55                   	push   %rbp
  8113bf:	48 89 e5             	mov    %rsp,%rbp
  8113c2:	53                   	push   %rbx
  8113c3:	48 83 ec 48          	sub    $0x48,%rsp
  8113c7:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8113cb:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8113cf:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8113d3:	89 c8                	mov    %ecx,%eax
  8113d5:	44 89 c1             	mov    %r8d,%ecx
  8113d8:	44 89 ca             	mov    %r9d,%edx
  8113db:	88 45 c4             	mov    %al,-0x3c(%rbp)
  8113de:	88 4d c0             	mov    %cl,-0x40(%rbp)
  8113e1:	88 55 bc             	mov    %dl,-0x44(%rbp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  8113e4:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8113e9:	0f 84 1a 02 00 00    	je     811609 <ip_output_if+0x24b>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  8113ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8113f3:	be 14 00 00 00       	mov    $0x14,%esi
  8113f8:	48 89 c7             	mov    %rax,%rdi
  8113fb:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  811402:	00 00 00 
  811405:	ff d0                	callq  *%rax
  811407:	84 c0                	test   %al,%al
  811409:	74 0a                	je     811415 <ip_output_if+0x57>
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  81140b:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  811410:	e9 64 02 00 00       	jmpq   811679 <ip_output_if+0x2bb>
    }

    iphdr = p->payload;
  811415:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811419:	48 8b 40 08          	mov    0x8(%rax),%rax
  81141d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  811421:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811425:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  811429:	66 83 f8 13          	cmp    $0x13,%ax
  81142d:	77 2a                	ja     811459 <ip_output_if+0x9b>
  81142f:	48 ba f0 28 82 00 00 	movabs $0x8228f0,%rdx
  811436:	00 00 00 
  811439:	be ef 01 00 00       	mov    $0x1ef,%esi
  81143e:	48 bf 1d 29 82 00 00 	movabs $0x82291d,%rdi
  811445:	00 00 00 
  811448:	b8 00 00 00 00       	mov    $0x0,%eax
  81144d:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  811454:	00 00 00 
  811457:	ff d1                	callq  *%rcx
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  811459:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81145d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811461:	0f b7 c0             	movzwl %ax,%eax
  811464:	89 c7                	mov    %eax,%edi
  811466:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81146d:	00 00 00 
  811470:	ff d0                	callq  *%rax
  811472:	0f b6 c0             	movzbl %al,%eax
  811475:	0f b6 55 c4          	movzbl -0x3c(%rbp),%edx
  811479:	c1 e2 08             	shl    $0x8,%edx
  81147c:	09 d0                	or     %edx,%eax
  81147e:	0f b7 c0             	movzwl %ax,%eax
  811481:	89 c7                	mov    %eax,%edi
  811483:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  81148a:	00 00 00 
  81148d:	ff d0                	callq  *%rax
  81148f:	89 c2                	mov    %eax,%edx
  811491:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811495:	66 89 50 08          	mov    %dx,0x8(%rax)
    IPH_PROTO_SET(iphdr, proto);
  811499:	0f b6 5d bc          	movzbl -0x44(%rbp),%ebx
  81149d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8114a1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8114a5:	0f b7 c0             	movzwl %ax,%eax
  8114a8:	89 c7                	mov    %eax,%edi
  8114aa:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  8114b1:	00 00 00 
  8114b4:	ff d0                	callq  *%rax
  8114b6:	66 c1 e8 08          	shr    $0x8,%ax
  8114ba:	0f b7 c0             	movzwl %ax,%eax
  8114bd:	c1 e0 08             	shl    $0x8,%eax
  8114c0:	09 d8                	or     %ebx,%eax
  8114c2:	0f b7 c0             	movzwl %ax,%eax
  8114c5:	89 c7                	mov    %eax,%edi
  8114c7:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8114ce:	00 00 00 
  8114d1:	ff d0                	callq  *%rax
  8114d3:	89 c2                	mov    %eax,%edx
  8114d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8114d9:	66 89 50 08          	mov    %dx,0x8(%rax)

    ip_addr_set(&(iphdr->dest), dest);
  8114dd:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8114e2:	74 08                	je     8114ec <ip_output_if+0x12e>
  8114e4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8114e8:	8b 00                	mov    (%rax),%eax
  8114ea:	eb 05                	jmp    8114f1 <ip_output_if+0x133>
  8114ec:	b8 00 00 00 00       	mov    $0x0,%eax
  8114f1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8114f5:	89 42 10             	mov    %eax,0x10(%rdx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  8114f8:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
  8114fc:	80 cc 45             	or     $0x45,%ah
  8114ff:	0f b7 c0             	movzwl %ax,%eax
  811502:	89 c7                	mov    %eax,%edi
  811504:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  81150b:	00 00 00 
  81150e:	ff d0                	callq  *%rax
  811510:	89 c2                	mov    %eax,%edx
  811512:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811516:	66 89 10             	mov    %dx,(%rax)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  811519:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81151d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  811521:	0f b7 c0             	movzwl %ax,%eax
  811524:	89 c7                	mov    %eax,%edi
  811526:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  81152d:	00 00 00 
  811530:	ff d0                	callq  *%rax
  811532:	89 c2                	mov    %eax,%edx
  811534:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811538:	66 89 50 02          	mov    %dx,0x2(%rax)
    IPH_OFFSET_SET(iphdr, 0);
  81153c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811540:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
    IPH_ID_SET(iphdr, htons(ip_id));
  811546:	48 b8 4e b0 b4 00 00 	movabs $0xb4b04e,%rax
  81154d:	00 00 00 
  811550:	0f b7 00             	movzwl (%rax),%eax
  811553:	0f b7 c0             	movzwl %ax,%eax
  811556:	89 c7                	mov    %eax,%edi
  811558:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  81155f:	00 00 00 
  811562:	ff d0                	callq  *%rax
  811564:	89 c2                	mov    %eax,%edx
  811566:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81156a:	66 89 50 04          	mov    %dx,0x4(%rax)
    ++ip_id;
  81156e:	48 b8 4e b0 b4 00 00 	movabs $0xb4b04e,%rax
  811575:	00 00 00 
  811578:	0f b7 00             	movzwl (%rax),%eax
  81157b:	8d 50 01             	lea    0x1(%rax),%edx
  81157e:	48 b8 4e b0 b4 00 00 	movabs $0xb4b04e,%rax
  811585:	00 00 00 
  811588:	66 89 10             	mov    %dx,(%rax)

    if (ip_addr_isany(src)) {
  81158b:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  811590:	74 0a                	je     81159c <ip_output_if+0x1de>
  811592:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811596:	8b 00                	mov    (%rax),%eax
  811598:	85 c0                	test   %eax,%eax
  81159a:	75 24                	jne    8115c0 <ip_output_if+0x202>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  81159c:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8115a0:	48 83 c0 08          	add    $0x8,%rax
  8115a4:	48 85 c0             	test   %rax,%rax
  8115a7:	74 09                	je     8115b2 <ip_output_if+0x1f4>
  8115a9:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8115ad:	8b 40 08             	mov    0x8(%rax),%eax
  8115b0:	eb 05                	jmp    8115b7 <ip_output_if+0x1f9>
  8115b2:	b8 00 00 00 00       	mov    $0x0,%eax
  8115b7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8115bb:	89 42 0c             	mov    %eax,0xc(%rdx)
  8115be:	eb 1b                	jmp    8115db <ip_output_if+0x21d>
    } else {
      ip_addr_set(&(iphdr->src), src);
  8115c0:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8115c5:	74 08                	je     8115cf <ip_output_if+0x211>
  8115c7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8115cb:	8b 00                	mov    (%rax),%eax
  8115cd:	eb 05                	jmp    8115d4 <ip_output_if+0x216>
  8115cf:	b8 00 00 00 00       	mov    $0x0,%eax
  8115d4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8115d8:	89 42 0c             	mov    %eax,0xc(%rdx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  8115db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8115df:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8115e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8115e9:	be 14 00 00 00       	mov    $0x14,%esi
  8115ee:	48 89 c7             	mov    %rax,%rdi
  8115f1:	48 b8 c9 2b 81 00 00 	movabs $0x812bc9,%rax
  8115f8:	00 00 00 
  8115fb:	ff d0                	callq  *%rax
  8115fd:	89 c2                	mov    %eax,%edx
  8115ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811603:	66 89 50 0a          	mov    %dx,0xa(%rax)
  811607:	eb 18                	jmp    811621 <ip_output_if+0x263>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
  811609:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81160d:	48 8b 40 08          	mov    0x8(%rax),%rax
  811611:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    dest = &(iphdr->dest);
  811615:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811619:	48 83 c0 10          	add    $0x10,%rax
  81161d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  811621:	48 8b 45 10          	mov    0x10(%rbp),%rax
  811625:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  811629:	66 85 c0             	test   %ax,%ax
  81162c:	74 32                	je     811660 <ip_output_if+0x2a2>
  81162e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811632:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  811636:	48 8b 45 10          	mov    0x10(%rbp),%rax
  81163a:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  81163e:	66 39 c2             	cmp    %ax,%dx
  811641:	76 1d                	jbe    811660 <ip_output_if+0x2a2>
    return ip_frag(p,netif,dest);
  811643:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  811647:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81164b:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  81164f:	48 89 c7             	mov    %rax,%rdi
  811652:	48 b8 f1 24 81 00 00 	movabs $0x8124f1,%rax
  811659:	00 00 00 
  81165c:	ff d0                	callq  *%rax
  81165e:	eb 19                	jmp    811679 <ip_output_if+0x2bb>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  811660:	48 8b 45 10          	mov    0x10(%rbp),%rax
  811664:	48 8b 40 20          	mov    0x20(%rax),%rax
  811668:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81166c:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  811670:	48 89 ce             	mov    %rcx,%rsi
  811673:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  811677:	ff d0                	callq  *%rax
  }
}
  811679:	48 83 c4 48          	add    $0x48,%rsp
  81167d:	5b                   	pop    %rbx
  81167e:	5d                   	pop    %rbp
  81167f:	c3                   	retq   

0000000000811680 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  811680:	55                   	push   %rbp
  811681:	48 89 e5             	mov    %rsp,%rbp
  811684:	48 83 ec 40          	sub    $0x40,%rsp
  811688:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81168c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  811690:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  811694:	89 c8                	mov    %ecx,%eax
  811696:	44 89 c1             	mov    %r8d,%ecx
  811699:	44 89 ca             	mov    %r9d,%edx
  81169c:	88 45 d4             	mov    %al,-0x2c(%rbp)
  81169f:	88 4d d0             	mov    %cl,-0x30(%rbp)
  8116a2:	88 55 cc             	mov    %dl,-0x34(%rbp)
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  8116a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8116a9:	48 89 c7             	mov    %rax,%rdi
  8116ac:	48 b8 88 0e 81 00 00 	movabs $0x810e88,%rax
  8116b3:	00 00 00 
  8116b6:	ff d0                	callq  *%rax
  8116b8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8116bc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8116c1:	75 07                	jne    8116ca <ip_output+0x4a>
    return ERR_RTE;
  8116c3:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8116c8:	eb 39                	jmp    811703 <ip_output+0x83>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  8116ca:	44 0f b6 45 cc       	movzbl -0x34(%rbp),%r8d
  8116cf:	0f b6 7d d0          	movzbl -0x30(%rbp),%edi
  8116d3:	0f b6 4d d4          	movzbl -0x2c(%rbp),%ecx
  8116d7:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8116db:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8116df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8116e3:	48 83 ec 08          	sub    $0x8,%rsp
  8116e7:	ff 75 f8             	pushq  -0x8(%rbp)
  8116ea:	45 89 c1             	mov    %r8d,%r9d
  8116ed:	41 89 f8             	mov    %edi,%r8d
  8116f0:	48 89 c7             	mov    %rax,%rdi
  8116f3:	48 b8 be 13 81 00 00 	movabs $0x8113be,%rax
  8116fa:	00 00 00 
  8116fd:	ff d0                	callq  *%rax
  8116ff:	48 83 c4 10          	add    $0x10,%rsp
}
  811703:	c9                   	leaveq 
  811704:	c3                   	retq   

0000000000811705 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  811705:	55                   	push   %rbp
  811706:	48 89 e5             	mov    %rsp,%rbp
  811709:	48 83 ec 20          	sub    $0x20,%rsp
  struct ip_reassdata *r, *prev = NULL;
  81170d:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  811714:	00 

  r = reassdatagrams;
  811715:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  81171c:	00 00 00 
  81171f:	48 8b 00             	mov    (%rax),%rax
  811722:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (r != NULL) {
  811726:	eb 60                	jmp    811788 <ip_reass_tmr+0x83>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  811728:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81172c:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  811730:	84 c0                	test   %al,%al
  811732:	74 27                	je     81175b <ip_reass_tmr+0x56>
      r->timer--;
  811734:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811738:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  81173c:	8d 50 ff             	lea    -0x1(%rax),%edx
  81173f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811743:	88 50 27             	mov    %dl,0x27(%rax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  811746:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81174a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      r = r->next;
  81174e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811752:	48 8b 00             	mov    (%rax),%rax
  811755:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  811759:	eb 2d                	jmp    811788 <ip_reass_tmr+0x83>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
  81175b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81175f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      /* get the next pointer before freeing */
      r = r->next;
  811763:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811767:	48 8b 00             	mov    (%rax),%rax
  81176a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  81176e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  811772:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811776:	48 89 d6             	mov    %rdx,%rsi
  811779:	48 89 c7             	mov    %rax,%rdi
  81177c:	48 b8 92 17 81 00 00 	movabs $0x811792,%rax
  811783:	00 00 00 
  811786:	ff d0                	callq  *%rax
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  811788:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81178d:	75 99                	jne    811728 <ip_reass_tmr+0x23>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  81178f:	90                   	nop
  811790:	c9                   	leaveq 
  811791:	c3                   	retq   

0000000000811792 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  811792:	55                   	push   %rbp
  811793:	48 89 e5             	mov    %rsp,%rbp
  811796:	48 83 ec 30          	sub    $0x30,%rsp
  81179a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81179e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  int pbufs_freed = 0;
  8117a2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  8117a9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8117ad:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8117b1:	75 2a                	jne    8117dd <ip_reass_free_complete_datagram+0x4b>
  8117b3:	48 ba 38 29 82 00 00 	movabs $0x822938,%rdx
  8117ba:	00 00 00 
  8117bd:	be 9a 00 00 00       	mov    $0x9a,%esi
  8117c2:	48 bf 44 29 82 00 00 	movabs $0x822944,%rdi
  8117c9:	00 00 00 
  8117cc:	b8 00 00 00 00       	mov    $0x0,%eax
  8117d1:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8117d8:	00 00 00 
  8117db:	ff d1                	callq  *%rcx
  if (prev != NULL) {
  8117dd:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8117e2:	74 37                	je     81181b <ip_reass_free_complete_datagram+0x89>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  8117e4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8117e8:	48 8b 00             	mov    (%rax),%rax
  8117eb:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8117ef:	74 2a                	je     81181b <ip_reass_free_complete_datagram+0x89>
  8117f1:	48 ba 61 29 82 00 00 	movabs $0x822961,%rdx
  8117f8:	00 00 00 
  8117fb:	be 9c 00 00 00       	mov    $0x9c,%esi
  811800:	48 bf 44 29 82 00 00 	movabs $0x822944,%rdi
  811807:	00 00 00 
  81180a:	b8 00 00 00 00       	mov    $0x0,%eax
  81180f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  811816:	00 00 00 
  811819:	ff d1                	callq  *%rcx
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  81181b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81181f:	48 8b 40 08          	mov    0x8(%rax),%rax
  811823:	48 8b 40 08          	mov    0x8(%rax),%rax
  811827:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (iprh->start == 0) {
  81182b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81182f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811833:	66 85 c0             	test   %ax,%ax
  811836:	0f 85 86 00 00 00    	jne    8118c2 <ip_reass_free_complete_datagram+0x130>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
  81183c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811840:	48 8b 40 08          	mov    0x8(%rax),%rax
  811844:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    ipr->p = iprh->next_pbuf;
  811848:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81184c:	48 8b 10             	mov    (%rax),%rdx
  81184f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811853:	48 89 50 08          	mov    %rdx,0x8(%rax)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  811857:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81185b:	48 8d 48 10          	lea    0x10(%rax),%rcx
  81185f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811863:	48 8b 40 08          	mov    0x8(%rax),%rax
  811867:	ba 14 00 00 00       	mov    $0x14,%edx
  81186c:	48 89 ce             	mov    %rcx,%rsi
  81186f:	48 89 c7             	mov    %rax,%rdi
  811872:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  811879:	00 00 00 
  81187c:	ff d0                	callq  *%rax
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  81187e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811882:	be 01 00 00 00       	mov    $0x1,%esi
  811887:	48 89 c7             	mov    %rax,%rdi
  81188a:	48 b8 fe 0a 82 00 00 	movabs $0x820afe,%rax
  811891:	00 00 00 
  811894:	ff d0                	callq  *%rax
    pbufs_freed += pbuf_clen(p);
  811896:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81189a:	48 89 c7             	mov    %rax,%rdi
  81189d:	48 b8 7d df 80 00 00 	movabs $0x80df7d,%rax
  8118a4:	00 00 00 
  8118a7:	ff d0                	callq  *%rax
  8118a9:	0f b6 c0             	movzbl %al,%eax
  8118ac:	01 45 fc             	add    %eax,-0x4(%rbp)
    pbuf_free(p);
  8118af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8118b3:	48 89 c7             	mov    %rax,%rdi
  8118b6:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  8118bd:	00 00 00 
  8118c0:	ff d0                	callq  *%rax
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  8118c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8118c6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8118ca:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  while (p != NULL) {
  8118ce:	eb 4b                	jmp    81191b <ip_reass_free_complete_datagram+0x189>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  8118d0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8118d4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8118d8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    pcur = p;
  8118dc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8118e0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  8118e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8118e8:	48 8b 00             	mov    (%rax),%rax
  8118eb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    pbufs_freed += pbuf_clen(pcur);
  8118ef:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8118f3:	48 89 c7             	mov    %rax,%rdi
  8118f6:	48 b8 7d df 80 00 00 	movabs $0x80df7d,%rax
  8118fd:	00 00 00 
  811900:	ff d0                	callq  *%rax
  811902:	0f b6 c0             	movzbl %al,%eax
  811905:	01 45 fc             	add    %eax,-0x4(%rbp)
    pbuf_free(pcur);    
  811908:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81190c:	48 89 c7             	mov    %rax,%rdi
  81190f:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  811916:	00 00 00 
  811919:	ff d0                	callq  *%rax
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  81191b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  811920:	75 ae                	jne    8118d0 <ip_reass_free_complete_datagram+0x13e>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  811922:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  811926:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81192a:	48 89 d6             	mov    %rdx,%rsi
  81192d:	48 89 c7             	mov    %rax,%rdi
  811930:	48 b8 97 1b 81 00 00 	movabs $0x811b97,%rax
  811937:	00 00 00 
  81193a:	ff d0                	callq  *%rax
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  81193c:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811943:	00 00 00 
  811946:	0f b7 00             	movzwl (%rax),%eax
  811949:	0f b7 c0             	movzwl %ax,%eax
  81194c:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  81194f:	7d 2a                	jge    81197b <ip_reass_free_complete_datagram+0x1e9>
  811951:	48 ba 73 29 82 00 00 	movabs $0x822973,%rdx
  811958:	00 00 00 
  81195b:	be bd 00 00 00       	mov    $0xbd,%esi
  811960:	48 bf 44 29 82 00 00 	movabs $0x822944,%rdi
  811967:	00 00 00 
  81196a:	b8 00 00 00 00       	mov    $0x0,%eax
  81196f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  811976:	00 00 00 
  811979:	ff d1                	callq  *%rcx
  ip_reass_pbufcount -= pbufs_freed;
  81197b:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811982:	00 00 00 
  811985:	0f b7 00             	movzwl (%rax),%eax
  811988:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81198b:	29 d0                	sub    %edx,%eax
  81198d:	89 c2                	mov    %eax,%edx
  81198f:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811996:	00 00 00 
  811999:	66 89 10             	mov    %dx,(%rax)

  return pbufs_freed;
  81199c:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  81199f:	c9                   	leaveq 
  8119a0:	c3                   	retq   

00000000008119a1 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  8119a1:	55                   	push   %rbp
  8119a2:	48 89 e5             	mov    %rsp,%rbp
  8119a5:	48 83 ec 40          	sub    $0x40,%rsp
  8119a9:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8119ad:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  8119b0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  8119b7:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8119be:	00 
    prev = NULL;
  8119bf:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8119c6:	00 
    other_datagrams = 0;
  8119c7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    r = reassdatagrams;
  8119ce:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  8119d5:	00 00 00 
  8119d8:	48 8b 00             	mov    (%rax),%rax
  8119db:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (r != NULL) {
  8119df:	e9 89 00 00 00       	jmpq   811a6d <ip_reass_remove_oldest_datagram+0xcc>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  8119e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8119e8:	8b 50 1c             	mov    0x1c(%rax),%edx
  8119eb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8119ef:	8b 40 0c             	mov    0xc(%rax),%eax
  8119f2:	39 c2                	cmp    %eax,%edx
  8119f4:	75 27                	jne    811a1d <ip_reass_remove_oldest_datagram+0x7c>
  8119f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8119fa:	8b 50 20             	mov    0x20(%rax),%edx
  8119fd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811a01:	8b 40 10             	mov    0x10(%rax),%eax
  811a04:	39 c2                	cmp    %eax,%edx
  811a06:	75 15                	jne    811a1d <ip_reass_remove_oldest_datagram+0x7c>
  811a08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811a0c:	0f b7 50 14          	movzwl 0x14(%rax),%edx
  811a10:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811a14:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  811a18:	66 39 c2             	cmp    %ax,%dx
  811a1b:	74 31                	je     811a4e <ip_reass_remove_oldest_datagram+0xad>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  811a1d:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
        if (oldest == NULL) {
  811a21:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  811a26:	75 0a                	jne    811a32 <ip_reass_remove_oldest_datagram+0x91>
          oldest = r;
  811a28:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811a2c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  811a30:	eb 1c                	jmp    811a4e <ip_reass_remove_oldest_datagram+0xad>
        } else if (r->timer <= oldest->timer) {
  811a32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811a36:	0f b6 50 27          	movzbl 0x27(%rax),%edx
  811a3a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811a3e:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  811a42:	38 c2                	cmp    %al,%dl
  811a44:	77 08                	ja     811a4e <ip_reass_remove_oldest_datagram+0xad>
          /* older than the previous oldest */
          oldest = r;
  811a46:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811a4a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        }
      }
      if (r->next != NULL) {
  811a4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811a52:	48 8b 00             	mov    (%rax),%rax
  811a55:	48 85 c0             	test   %rax,%rax
  811a58:	74 08                	je     811a62 <ip_reass_remove_oldest_datagram+0xc1>
        prev = r;
  811a5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811a5e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      }
      r = r->next;
  811a62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811a66:	48 8b 00             	mov    (%rax),%rax
  811a69:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  811a6d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  811a72:	0f 85 6c ff ff ff    	jne    8119e4 <ip_reass_remove_oldest_datagram+0x43>
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  811a78:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  811a7d:	74 23                	je     811aa2 <ip_reass_remove_oldest_datagram+0x101>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  811a7f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811a83:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811a87:	48 89 d6             	mov    %rdx,%rsi
  811a8a:	48 89 c7             	mov    %rax,%rdi
  811a8d:	48 b8 92 17 81 00 00 	movabs $0x811792,%rax
  811a94:	00 00 00 
  811a97:	ff d0                	callq  *%rax
  811a99:	89 45 dc             	mov    %eax,-0x24(%rbp)
      pbufs_freed += pbufs_freed_current;
  811a9c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  811a9f:	01 45 e4             	add    %eax,-0x1c(%rbp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  811aa2:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  811aa5:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  811aa8:	7d 0a                	jge    811ab4 <ip_reass_remove_oldest_datagram+0x113>
  811aaa:	83 7d e0 01          	cmpl   $0x1,-0x20(%rbp)
  811aae:	0f 8f 03 ff ff ff    	jg     8119b7 <ip_reass_remove_oldest_datagram+0x16>
  return pbufs_freed;
  811ab4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
}
  811ab7:	c9                   	leaveq 
  811ab8:	c3                   	retq   

0000000000811ab9 <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  811ab9:	55                   	push   %rbp
  811aba:	48 89 e5             	mov    %rsp,%rbp
  811abd:	48 83 ec 20          	sub    $0x20,%rsp
  811ac1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  811ac5:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  811ac8:	bf 05 00 00 00       	mov    $0x5,%edi
  811acd:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  811ad4:	00 00 00 
  811ad7:	ff d0                	callq  *%rax
  811ad9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (ipr == NULL) {
  811add:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  811ae2:	75 40                	jne    811b24 <ip_reass_enqueue_new_datagram+0x6b>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  811ae4:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  811ae7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811aeb:	89 d6                	mov    %edx,%esi
  811aed:	48 89 c7             	mov    %rax,%rdi
  811af0:	48 b8 a1 19 81 00 00 	movabs $0x8119a1,%rax
  811af7:	00 00 00 
  811afa:	ff d0                	callq  *%rax
  811afc:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  811aff:	7c 15                	jl     811b16 <ip_reass_enqueue_new_datagram+0x5d>
      ipr = memp_malloc(MEMP_REASSDATA);
  811b01:	bf 05 00 00 00       	mov    $0x5,%edi
  811b06:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  811b0d:	00 00 00 
  811b10:	ff d0                	callq  *%rax
  811b12:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    }
    if (ipr == NULL)
  811b16:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  811b1b:	75 07                	jne    811b24 <ip_reass_enqueue_new_datagram+0x6b>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
  811b1d:	b8 00 00 00 00       	mov    $0x0,%eax
  811b22:	eb 71                	jmp    811b95 <ip_reass_enqueue_new_datagram+0xdc>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  811b24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811b28:	ba 28 00 00 00       	mov    $0x28,%edx
  811b2d:	be 00 00 00 00       	mov    $0x0,%esi
  811b32:	48 89 c7             	mov    %rax,%rdi
  811b35:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  811b3c:	00 00 00 
  811b3f:	ff d0                	callq  *%rax
  ipr->timer = IP_REASS_MAXAGE;
  811b41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811b45:	c6 40 27 03          	movb   $0x3,0x27(%rax)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  811b49:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811b50:	00 00 00 
  811b53:	48 8b 10             	mov    (%rax),%rdx
  811b56:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811b5a:	48 89 10             	mov    %rdx,(%rax)
  reassdatagrams = ipr;
  811b5d:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811b64:	00 00 00 
  811b67:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  811b6b:	48 89 10             	mov    %rdx,(%rax)
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  811b6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811b72:	48 8d 48 10          	lea    0x10(%rax),%rcx
  811b76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811b7a:	ba 14 00 00 00       	mov    $0x14,%edx
  811b7f:	48 89 c6             	mov    %rax,%rsi
  811b82:	48 89 cf             	mov    %rcx,%rdi
  811b85:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  811b8c:	00 00 00 
  811b8f:	ff d0                	callq  *%rax
  return ipr;
  811b91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  811b95:	c9                   	leaveq 
  811b96:	c3                   	retq   

0000000000811b97 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  811b97:	55                   	push   %rbp
  811b98:	48 89 e5             	mov    %rsp,%rbp
  811b9b:	48 83 ec 10          	sub    $0x10,%rsp
  811b9f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  811ba3:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  811ba7:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811bae:	00 00 00 
  811bb1:	48 8b 00             	mov    (%rax),%rax
  811bb4:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  811bb8:	75 16                	jne    811bd0 <ip_reass_dequeue_datagram+0x39>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  811bba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811bbe:	48 8b 10             	mov    (%rax),%rdx
  811bc1:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811bc8:	00 00 00 
  811bcb:	48 89 10             	mov    %rdx,(%rax)
  811bce:	eb 3f                	jmp    811c0f <ip_reass_dequeue_datagram+0x78>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  811bd0:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  811bd5:	75 2a                	jne    811c01 <ip_reass_dequeue_datagram+0x6a>
  811bd7:	48 ba 8e 29 82 00 00 	movabs $0x82298e,%rdx
  811bde:	00 00 00 
  811be1:	be 2a 01 00 00       	mov    $0x12a,%esi
  811be6:	48 bf 44 29 82 00 00 	movabs $0x822944,%rdi
  811bed:	00 00 00 
  811bf0:	b8 00 00 00 00       	mov    $0x0,%eax
  811bf5:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  811bfc:	00 00 00 
  811bff:	ff d1                	callq  *%rcx
    prev->next = ipr->next;
  811c01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811c05:	48 8b 10             	mov    (%rax),%rdx
  811c08:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811c0c:	48 89 10             	mov    %rdx,(%rax)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  811c0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811c13:	48 89 c6             	mov    %rax,%rsi
  811c16:	bf 05 00 00 00       	mov    $0x5,%edi
  811c1b:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  811c22:	00 00 00 
  811c25:	ff d0                	callq  *%rax
}
  811c27:	90                   	nop
  811c28:	c9                   	leaveq 
  811c29:	c3                   	retq   

0000000000811c2a <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  811c2a:	55                   	push   %rbp
  811c2b:	48 89 e5             	mov    %rsp,%rbp
  811c2e:	53                   	push   %rbx
  811c2f:	48 83 ec 58          	sub    $0x58,%rsp
  811c33:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  811c37:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  811c3b:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  811c42:	00 
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  811c43:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  811c4a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811c4e:	48 8b 40 08          	mov    0x8(%rax),%rax
  811c52:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  811c56:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811c5a:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  811c5e:	0f b7 c0             	movzwl %ax,%eax
  811c61:	89 c7                	mov    %eax,%edi
  811c63:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  811c6a:	00 00 00 
  811c6d:	ff d0                	callq  *%rax
  811c6f:	89 c3                	mov    %eax,%ebx
  811c71:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811c75:	0f b7 00             	movzwl (%rax),%eax
  811c78:	0f b7 c0             	movzwl %ax,%eax
  811c7b:	89 c7                	mov    %eax,%edi
  811c7d:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  811c84:	00 00 00 
  811c87:	ff d0                	callq  *%rax
  811c89:	66 c1 e8 08          	shr    $0x8,%ax
  811c8d:	83 e0 0f             	and    $0xf,%eax
  811c90:	c1 e0 02             	shl    $0x2,%eax
  811c93:	29 c3                	sub    %eax,%ebx
  811c95:	89 d8                	mov    %ebx,%eax
  811c97:	66 89 45 c6          	mov    %ax,-0x3a(%rbp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  811c9b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811c9f:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  811ca3:	0f b7 c0             	movzwl %ax,%eax
  811ca6:	89 c7                	mov    %eax,%edi
  811ca8:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  811caf:	00 00 00 
  811cb2:	ff d0                	callq  *%rax
  811cb4:	66 25 ff 1f          	and    $0x1fff,%ax
  811cb8:	c1 e0 03             	shl    $0x3,%eax
  811cbb:	66 89 45 c4          	mov    %ax,-0x3c(%rbp)
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  811cbf:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811cc3:	48 8b 40 08          	mov    0x8(%rax),%rax
  811cc7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  iprh->next_pbuf = NULL;
  811ccb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811ccf:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  iprh->start = offset;
  811cd6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811cda:	0f b7 55 c4          	movzwl -0x3c(%rbp),%edx
  811cde:	66 89 50 08          	mov    %dx,0x8(%rax)
  iprh->end = offset + len;
  811ce2:	0f b7 55 c4          	movzwl -0x3c(%rbp),%edx
  811ce6:	0f b7 45 c6          	movzwl -0x3a(%rbp),%eax
  811cea:	01 c2                	add    %eax,%edx
  811cec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811cf0:	66 89 50 0a          	mov    %dx,0xa(%rax)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  811cf4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811cf8:	48 8b 40 08          	mov    0x8(%rax),%rax
  811cfc:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  811d00:	e9 eb 00 00 00       	jmpq   811df0 <ip_reass_chain_frag_into_datagram_and_validate+0x1c6>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  811d05:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811d09:	48 8b 40 08          	mov    0x8(%rax),%rax
  811d0d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    if (iprh->start < iprh_tmp->start) {
  811d11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811d15:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811d19:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811d1d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811d21:	66 39 c2             	cmp    %ax,%dx
  811d24:	73 62                	jae    811d88 <ip_reass_chain_frag_into_datagram_and_validate+0x15e>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  811d26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811d2a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  811d2e:	48 89 10             	mov    %rdx,(%rax)
      if (iprh_prev != NULL) {
  811d31:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811d36:	74 42                	je     811d7a <ip_reass_chain_frag_into_datagram_and_validate+0x150>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  811d38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811d3c:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811d40:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811d44:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  811d48:	66 39 c2             	cmp    %ax,%dx
  811d4b:	0f 82 03 03 00 00    	jb     812054 <ip_reass_chain_frag_into_datagram_and_validate+0x42a>
  811d51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811d55:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811d59:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811d5d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811d61:	66 39 c2             	cmp    %ax,%dx
  811d64:	0f 87 ea 02 00 00    	ja     812054 <ip_reass_chain_frag_into_datagram_and_validate+0x42a>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  811d6a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811d6e:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811d72:	48 89 10             	mov    %rdx,(%rax)
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
  811d75:	e9 81 00 00 00       	jmpq   811dfb <ip_reass_chain_frag_into_datagram_and_validate+0x1d1>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  811d7a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811d7e:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811d82:	48 89 50 08          	mov    %rdx,0x8(%rax)
      }
      break;
  811d86:	eb 73                	jmp    811dfb <ip_reass_chain_frag_into_datagram_and_validate+0x1d1>
    } else if(iprh->start == iprh_tmp->start) {
  811d88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811d8c:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811d90:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811d94:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811d98:	66 39 c2             	cmp    %ax,%dx
  811d9b:	0f 84 af 02 00 00    	je     812050 <ip_reass_chain_frag_into_datagram_and_validate+0x426>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  811da1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811da5:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811da9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811dad:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  811db1:	66 39 c2             	cmp    %ax,%dx
  811db4:	0f 82 99 02 00 00    	jb     812053 <ip_reass_chain_frag_into_datagram_and_validate+0x429>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  811dba:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811dbf:	74 1c                	je     811ddd <ip_reass_chain_frag_into_datagram_and_validate+0x1b3>
        if (iprh_prev->end != iprh_tmp->start) {
  811dc1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811dc5:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811dc9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811dcd:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811dd1:	66 39 c2             	cmp    %ax,%dx
  811dd4:	74 07                	je     811ddd <ip_reass_chain_frag_into_datagram_and_validate+0x1b3>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  811dd6:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  811ddd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811de1:	48 8b 00             	mov    (%rax),%rax
  811de4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    iprh_prev = iprh_tmp;
  811de8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811dec:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  811df0:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  811df5:	0f 85 0a ff ff ff    	jne    811d05 <ip_reass_chain_frag_into_datagram_and_validate+0xdb>
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
  811dfb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  811e00:	0f 85 b2 00 00 00    	jne    811eb8 <ip_reass_chain_frag_into_datagram_and_validate+0x28e>
    if (iprh_prev != NULL) {
  811e06:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811e0b:	74 68                	je     811e75 <ip_reass_chain_frag_into_datagram_and_validate+0x24b>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  811e0d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811e11:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811e15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811e19:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811e1d:	66 39 c2             	cmp    %ax,%dx
  811e20:	76 2a                	jbe    811e4c <ip_reass_chain_frag_into_datagram_and_validate+0x222>
  811e22:	48 ba a7 29 82 00 00 	movabs $0x8229a7,%rdx
  811e29:	00 00 00 
  811e2c:	be 84 01 00 00       	mov    $0x184,%esi
  811e31:	48 bf 44 29 82 00 00 	movabs $0x822944,%rdi
  811e38:	00 00 00 
  811e3b:	b8 00 00 00 00       	mov    $0x0,%eax
  811e40:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  811e47:	00 00 00 
  811e4a:	ff d1                	callq  *%rcx
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  811e4c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811e50:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811e54:	48 89 10             	mov    %rdx,(%rax)
      if (iprh_prev->end != iprh->start) {
  811e57:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811e5b:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811e5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811e63:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811e67:	66 39 c2             	cmp    %ax,%dx
  811e6a:	74 4c                	je     811eb8 <ip_reass_chain_frag_into_datagram_and_validate+0x28e>
        valid = 0;
  811e6c:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  811e73:	eb 43                	jmp    811eb8 <ip_reass_chain_frag_into_datagram_and_validate+0x28e>
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  811e75:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811e79:	48 8b 40 08          	mov    0x8(%rax),%rax
  811e7d:	48 85 c0             	test   %rax,%rax
  811e80:	74 2a                	je     811eac <ip_reass_chain_frag_into_datagram_and_validate+0x282>
  811e82:	48 ba c8 29 82 00 00 	movabs $0x8229c8,%rdx
  811e89:	00 00 00 
  811e8c:	be 8d 01 00 00       	mov    $0x18d,%esi
  811e91:	48 bf 44 29 82 00 00 	movabs $0x822944,%rdi
  811e98:	00 00 00 
  811e9b:	b8 00 00 00 00       	mov    $0x0,%eax
  811ea0:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  811ea7:	00 00 00 
  811eaa:	ff d1                	callq  *%rcx
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  811eac:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811eb0:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811eb4:	48 89 50 08          	mov    %rdx,0x8(%rax)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  811eb8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811ebc:	0f b6 40 26          	movzbl 0x26(%rax),%eax
  811ec0:	0f b6 c0             	movzbl %al,%eax
  811ec3:	83 e0 01             	and    $0x1,%eax
  811ec6:	85 c0                	test   %eax,%eax
  811ec8:	0f 84 7b 01 00 00    	je     812049 <ip_reass_chain_frag_into_datagram_and_validate+0x41f>
    /* and had no wholes so far */
    if (valid) {
  811ece:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  811ed2:	0f 84 6c 01 00 00    	je     812044 <ip_reass_chain_frag_into_datagram_and_validate+0x41a>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  811ed8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811edc:	48 8b 40 08          	mov    0x8(%rax),%rax
  811ee0:	48 8b 40 08          	mov    0x8(%rax),%rax
  811ee4:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811ee8:	66 85 c0             	test   %ax,%ax
  811eeb:	74 0c                	je     811ef9 <ip_reass_chain_frag_into_datagram_and_validate+0x2cf>
        valid = 0;
  811eed:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  811ef4:	e9 4b 01 00 00       	jmpq   812044 <ip_reass_chain_frag_into_datagram_and_validate+0x41a>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
  811ef9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811efd:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        q = iprh->next_pbuf;
  811f01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811f05:	48 8b 00             	mov    (%rax),%rax
  811f08:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        while (q != NULL) {
  811f0c:	eb 3d                	jmp    811f4b <ip_reass_chain_frag_into_datagram_and_validate+0x321>
          iprh = (struct ip_reass_helper*)q->payload;
  811f0e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811f12:	48 8b 40 08          	mov    0x8(%rax),%rax
  811f16:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
          if (iprh_prev->end != iprh->start) {
  811f1a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811f1e:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811f22:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811f26:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811f2a:	66 39 c2             	cmp    %ax,%dx
  811f2d:	74 09                	je     811f38 <ip_reass_chain_frag_into_datagram_and_validate+0x30e>
            valid = 0;
  811f2f:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
            break;
  811f36:	eb 1a                	jmp    811f52 <ip_reass_chain_frag_into_datagram_and_validate+0x328>
          }
          iprh_prev = iprh;
  811f38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811f3c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          q = iprh->next_pbuf;
  811f40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811f44:	48 8b 00             	mov    (%rax),%rax
  811f47:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  811f4b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  811f50:	75 bc                	jne    811f0e <ip_reass_chain_frag_into_datagram_and_validate+0x2e4>
          iprh_prev = iprh;
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
  811f52:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  811f56:	0f 84 e8 00 00 00    	je     812044 <ip_reass_chain_frag_into_datagram_and_validate+0x41a>
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  811f5c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811f60:	48 8b 40 08          	mov    0x8(%rax),%rax
  811f64:	48 85 c0             	test   %rax,%rax
  811f67:	75 2a                	jne    811f93 <ip_reass_chain_frag_into_datagram_and_validate+0x369>
  811f69:	48 ba ff 29 82 00 00 	movabs $0x8229ff,%rdx
  811f70:	00 00 00 
  811f73:	be ad 01 00 00       	mov    $0x1ad,%esi
  811f78:	48 bf 44 29 82 00 00 	movabs $0x822944,%rdi
  811f7f:	00 00 00 
  811f82:	b8 00 00 00 00       	mov    $0x0,%eax
  811f87:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  811f8e:	00 00 00 
  811f91:	ff d1                	callq  *%rcx
          LWIP_ASSERT("sanity check",
  811f93:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811f97:	48 8b 40 08          	mov    0x8(%rax),%rax
  811f9b:	48 8b 40 08          	mov    0x8(%rax),%rax
  811f9f:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  811fa3:	75 2a                	jne    811fcf <ip_reass_chain_frag_into_datagram_and_validate+0x3a5>
  811fa5:	48 ba ff 29 82 00 00 	movabs $0x8229ff,%rdx
  811fac:	00 00 00 
  811faf:	be af 01 00 00       	mov    $0x1af,%esi
  811fb4:	48 bf 44 29 82 00 00 	movabs $0x822944,%rdi
  811fbb:	00 00 00 
  811fbe:	b8 00 00 00 00       	mov    $0x0,%eax
  811fc3:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  811fca:	00 00 00 
  811fcd:	ff d1                	callq  *%rcx
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  811fcf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811fd3:	48 8b 00             	mov    (%rax),%rax
  811fd6:	48 85 c0             	test   %rax,%rax
  811fd9:	74 2a                	je     812005 <ip_reass_chain_frag_into_datagram_and_validate+0x3db>
  811fdb:	48 ba 10 2a 82 00 00 	movabs $0x822a10,%rdx
  811fe2:	00 00 00 
  811fe5:	be b1 01 00 00       	mov    $0x1b1,%esi
  811fea:	48 bf 44 29 82 00 00 	movabs $0x822944,%rdi
  811ff1:	00 00 00 
  811ff4:	b8 00 00 00 00       	mov    $0x0,%eax
  811ff9:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  812000:	00 00 00 
  812003:	ff d1                	callq  *%rcx
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  812005:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812009:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  81200d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812011:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  812015:	66 39 c2             	cmp    %ax,%dx
  812018:	74 2a                	je     812044 <ip_reass_chain_frag_into_datagram_and_validate+0x41a>
  81201a:	48 ba 38 2a 82 00 00 	movabs $0x822a38,%rdx
  812021:	00 00 00 
  812024:	be b3 01 00 00       	mov    $0x1b3,%esi
  812029:	48 bf 44 29 82 00 00 	movabs $0x822944,%rdi
  812030:	00 00 00 
  812033:	b8 00 00 00 00       	mov    $0x0,%eax
  812038:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81203f:	00 00 00 
  812042:	ff d1                	callq  *%rcx
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
  812044:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  812047:	eb 57                	jmp    8120a0 <ip_reass_chain_frag_into_datagram_and_validate+0x476>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
  812049:	b8 00 00 00 00       	mov    $0x0,%eax
  81204e:	eb 50                	jmp    8120a0 <ip_reass_chain_frag_into_datagram_and_validate+0x476>
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
  812050:	90                   	nop
  812051:	eb 01                	jmp    812054 <ip_reass_chain_frag_into_datagram_and_validate+0x42a>
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
  812053:	90                   	nop
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  812054:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  812058:	48 89 c7             	mov    %rax,%rdi
  81205b:	48 b8 7d df 80 00 00 	movabs $0x80df7d,%rax
  812062:	00 00 00 
  812065:	ff d0                	callq  *%rax
  812067:	89 c1                	mov    %eax,%ecx
  812069:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  812070:	00 00 00 
  812073:	0f b7 10             	movzwl (%rax),%edx
  812076:	0f b6 c1             	movzbl %cl,%eax
  812079:	29 c2                	sub    %eax,%edx
  81207b:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  812082:	00 00 00 
  812085:	66 89 10             	mov    %dx,(%rax)
  pbuf_free(new_p);
  812088:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  81208c:	48 89 c7             	mov    %rax,%rdi
  81208f:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  812096:	00 00 00 
  812099:	ff d0                	callq  *%rax
  return 0;
  81209b:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* IP_REASS_CHECK_OVERLAP */
}
  8120a0:	48 83 c4 58          	add    $0x58,%rsp
  8120a4:	5b                   	pop    %rbx
  8120a5:	5d                   	pop    %rbp
  8120a6:	c3                   	retq   

00000000008120a7 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  8120a7:	55                   	push   %rbp
  8120a8:	48 89 e5             	mov    %rsp,%rbp
  8120ab:	53                   	push   %rbx
  8120ac:	48 83 ec 48          	sub    $0x48,%rsp
  8120b0:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  8120b4:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8120bb:	00 

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  8120bc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8120c0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8120c4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  8120c8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8120cc:	0f b7 00             	movzwl (%rax),%eax
  8120cf:	0f b7 c0             	movzwl %ax,%eax
  8120d2:	89 c7                	mov    %eax,%edi
  8120d4:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  8120db:	00 00 00 
  8120de:	ff d0                	callq  *%rax
  8120e0:	66 c1 e8 08          	shr    $0x8,%ax
  8120e4:	0f b7 c0             	movzwl %ax,%eax
  8120e7:	83 e0 0f             	and    $0xf,%eax
  8120ea:	c1 e0 02             	shl    $0x2,%eax
  8120ed:	83 f8 14             	cmp    $0x14,%eax
  8120f0:	0f 85 d8 03 00 00    	jne    8124ce <ip_reass+0x427>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  8120f6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8120fa:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  8120fe:	0f b7 c0             	movzwl %ax,%eax
  812101:	89 c7                	mov    %eax,%edi
  812103:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81210a:	00 00 00 
  81210d:	ff d0                	callq  *%rax
  81210f:	66 25 ff 1f          	and    $0x1fff,%ax
  812113:	c1 e0 03             	shl    $0x3,%eax
  812116:	66 89 45 ce          	mov    %ax,-0x32(%rbp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  81211a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81211e:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  812122:	0f b7 c0             	movzwl %ax,%eax
  812125:	89 c7                	mov    %eax,%edi
  812127:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81212e:	00 00 00 
  812131:	ff d0                	callq  *%rax
  812133:	89 c3                	mov    %eax,%ebx
  812135:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812139:	0f b7 00             	movzwl (%rax),%eax
  81213c:	0f b7 c0             	movzwl %ax,%eax
  81213f:	89 c7                	mov    %eax,%edi
  812141:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  812148:	00 00 00 
  81214b:	ff d0                	callq  *%rax
  81214d:	66 c1 e8 08          	shr    $0x8,%ax
  812151:	83 e0 0f             	and    $0xf,%eax
  812154:	c1 e0 02             	shl    $0x2,%eax
  812157:	29 c3                	sub    %eax,%ebx
  812159:	89 d8                	mov    %ebx,%eax
  81215b:	66 89 45 cc          	mov    %ax,-0x34(%rbp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  81215f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  812163:	48 89 c7             	mov    %rax,%rdi
  812166:	48 b8 7d df 80 00 00 	movabs $0x80df7d,%rax
  81216d:	00 00 00 
  812170:	ff d0                	callq  *%rax
  812172:	88 45 cb             	mov    %al,-0x35(%rbp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  812175:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  81217c:	00 00 00 
  81217f:	0f b7 00             	movzwl (%rax),%eax
  812182:	0f b7 d0             	movzwl %ax,%edx
  812185:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  812189:	01 d0                	add    %edx,%eax
  81218b:	83 f8 0a             	cmp    $0xa,%eax
  81218e:	7e 40                	jle    8121d0 <ip_reass+0x129>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  812190:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  812194:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812198:	89 d6                	mov    %edx,%esi
  81219a:	48 89 c7             	mov    %rax,%rdi
  81219d:	48 b8 a1 19 81 00 00 	movabs $0x8119a1,%rax
  8121a4:	00 00 00 
  8121a7:	ff d0                	callq  *%rax
  8121a9:	85 c0                	test   %eax,%eax
  8121ab:	0f 84 20 03 00 00    	je     8124d1 <ip_reass+0x42a>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  8121b1:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8121b8:	00 00 00 
  8121bb:	0f b7 00             	movzwl (%rax),%eax
  8121be:	0f b7 d0             	movzwl %ax,%edx
  8121c1:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8121c5:	01 d0                	add    %edx,%eax

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  8121c7:	83 f8 0a             	cmp    $0xa,%eax
  8121ca:	0f 8f 01 03 00 00    	jg     8124d1 <ip_reass+0x42a>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  8121d0:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  8121d7:	00 00 00 
  8121da:	48 8b 00             	mov    (%rax),%rax
  8121dd:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8121e1:	eb 4c                	jmp    81222f <ip_reass+0x188>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  8121e3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8121e7:	8b 50 1c             	mov    0x1c(%rax),%edx
  8121ea:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8121ee:	8b 40 0c             	mov    0xc(%rax),%eax
  8121f1:	39 c2                	cmp    %eax,%edx
  8121f3:	75 27                	jne    81221c <ip_reass+0x175>
  8121f5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8121f9:	8b 50 20             	mov    0x20(%rax),%edx
  8121fc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812200:	8b 40 10             	mov    0x10(%rax),%eax
  812203:	39 c2                	cmp    %eax,%edx
  812205:	75 15                	jne    81221c <ip_reass+0x175>
  812207:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81220b:	0f b7 50 14          	movzwl 0x14(%rax),%edx
  81220f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812213:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  812217:	66 39 c2             	cmp    %ax,%dx
  81221a:	74 1c                	je     812238 <ip_reass+0x191>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
    }
    ipr_prev = ipr;
  81221c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812220:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  812224:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812228:	48 8b 00             	mov    (%rax),%rax
  81222b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  81222f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  812234:	75 ad                	jne    8121e3 <ip_reass+0x13c>
  812236:	eb 01                	jmp    812239 <ip_reass+0x192>
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
  812238:	90                   	nop
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
  812239:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81223e:	75 29                	jne    812269 <ip_reass+0x1c2>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
  812240:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  812244:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812248:	89 d6                	mov    %edx,%esi
  81224a:	48 89 c7             	mov    %rax,%rdi
  81224d:	48 b8 b9 1a 81 00 00 	movabs $0x811ab9,%rax
  812254:	00 00 00 
  812257:	ff d0                	callq  *%rax
  812259:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
  81225d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  812262:	75 72                	jne    8122d6 <ip_reass+0x22f>
      goto nullreturn;
  812264:	e9 69 02 00 00       	jmpq   8124d2 <ip_reass+0x42b>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  812269:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81226d:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  812271:	0f b7 c0             	movzwl %ax,%eax
  812274:	89 c7                	mov    %eax,%edi
  812276:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81227d:	00 00 00 
  812280:	ff d0                	callq  *%rax
  812282:	0f b7 c0             	movzwl %ax,%eax
  812285:	25 ff 1f 00 00       	and    $0x1fff,%eax
  81228a:	85 c0                	test   %eax,%eax
  81228c:	75 48                	jne    8122d6 <ip_reass+0x22f>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  81228e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812292:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  812296:	0f b7 c0             	movzwl %ax,%eax
  812299:	89 c7                	mov    %eax,%edi
  81229b:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  8122a2:	00 00 00 
  8122a5:	ff d0                	callq  *%rax
  8122a7:	0f b7 c0             	movzwl %ax,%eax
  8122aa:	25 ff 1f 00 00       	and    $0x1fff,%eax
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  8122af:	85 c0                	test   %eax,%eax
  8122b1:	74 23                	je     8122d6 <ip_reass+0x22f>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  8122b3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8122b7:	48 8d 48 10          	lea    0x10(%rax),%rcx
  8122bb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8122bf:	ba 14 00 00 00       	mov    $0x14,%edx
  8122c4:	48 89 c6             	mov    %rax,%rsi
  8122c7:	48 89 cf             	mov    %rcx,%rdi
  8122ca:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  8122d1:	00 00 00 
  8122d4:	ff d0                	callq  *%rax
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  8122d6:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  8122da:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8122e1:	00 00 00 
  8122e4:	0f b7 00             	movzwl (%rax),%eax
  8122e7:	01 c2                	add    %eax,%edx
  8122e9:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8122f0:	00 00 00 
  8122f3:	66 89 10             	mov    %dx,(%rax)

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  8122f6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8122fa:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  8122fe:	0f b7 c0             	movzwl %ax,%eax
  812301:	89 c7                	mov    %eax,%edi
  812303:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81230a:	00 00 00 
  81230d:	ff d0                	callq  *%rax
  81230f:	0f b7 c0             	movzwl %ax,%eax
  812312:	25 00 20 00 00       	and    $0x2000,%eax
  812317:	85 c0                	test   %eax,%eax
  812319:	75 26                	jne    812341 <ip_reass+0x29a>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  81231b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81231f:	0f b6 40 26          	movzbl 0x26(%rax),%eax
  812323:	83 c8 01             	or     $0x1,%eax
  812326:	89 c2                	mov    %eax,%edx
  812328:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81232c:	88 50 26             	mov    %dl,0x26(%rax)
    ipr->datagram_len = offset + len;
  81232f:	0f b7 55 ce          	movzwl -0x32(%rbp),%edx
  812333:	0f b7 45 cc          	movzwl -0x34(%rbp),%eax
  812337:	01 c2                	add    %eax,%edx
  812339:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81233d:	66 89 50 24          	mov    %dx,0x24(%rax)
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
  812341:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  812345:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812349:	48 89 d6             	mov    %rdx,%rsi
  81234c:	48 89 c7             	mov    %rax,%rdi
  81234f:	48 b8 2a 1c 81 00 00 	movabs $0x811c2a,%rax
  812356:	00 00 00 
  812359:	ff d0                	callq  *%rax
  81235b:	85 c0                	test   %eax,%eax
  81235d:	0f 84 64 01 00 00    	je     8124c7 <ip_reass+0x420>
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  812363:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812367:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  81236b:	8d 50 14             	lea    0x14(%rax),%edx
  81236e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812372:	66 89 50 24          	mov    %dx,0x24(%rax)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  812376:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81237a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81237e:	48 8b 40 08          	mov    0x8(%rax),%rax
  812382:	48 8b 00             	mov    (%rax),%rax
  812385:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
  812389:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81238d:	48 8b 40 08          	mov    0x8(%rax),%rax
  812391:	48 8b 40 08          	mov    0x8(%rax),%rax
  812395:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  812399:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81239d:	48 8d 48 10          	lea    0x10(%rax),%rcx
  8123a1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8123a5:	ba 14 00 00 00       	mov    $0x14,%edx
  8123aa:	48 89 ce             	mov    %rcx,%rsi
  8123ad:	48 89 c7             	mov    %rax,%rdi
  8123b0:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  8123b7:	00 00 00 
  8123ba:	ff d0                	callq  *%rax
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  8123bc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8123c0:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  8123c4:	0f b7 c0             	movzwl %ax,%eax
  8123c7:	89 c7                	mov    %eax,%edi
  8123c9:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8123d0:	00 00 00 
  8123d3:	ff d0                	callq  *%rax
  8123d5:	89 c2                	mov    %eax,%edx
  8123d7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8123db:	66 89 50 02          	mov    %dx,0x2(%rax)
    IPH_OFFSET_SET(fraghdr, 0);
  8123df:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8123e3:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
    IPH_CHKSUM_SET(fraghdr, 0);
  8123e9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8123ed:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  8123f3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8123f7:	be 14 00 00 00       	mov    $0x14,%esi
  8123fc:	48 89 c7             	mov    %rax,%rdi
  8123ff:	48 b8 c9 2b 81 00 00 	movabs $0x812bc9,%rax
  812406:	00 00 00 
  812409:	ff d0                	callq  *%rax
  81240b:	89 c2                	mov    %eax,%edx
  81240d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812411:	66 89 50 0a          	mov    %dx,0xa(%rax)

    p = ipr->p;
  812415:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812419:	48 8b 40 08          	mov    0x8(%rax),%rax
  81241d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  812421:	eb 49                	jmp    81246c <ip_reass+0x3c5>
      iprh = (struct ip_reass_helper*)r->payload;
  812423:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812427:	48 8b 40 08          	mov    0x8(%rax),%rax
  81242b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  81242f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812433:	be ec ff ff ff       	mov    $0xffffffec,%esi
  812438:	48 89 c7             	mov    %rax,%rdi
  81243b:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  812442:	00 00 00 
  812445:	ff d0                	callq  *%rax
      pbuf_cat(p, r);
  812447:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81244b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81244f:	48 89 d6             	mov    %rdx,%rsi
  812452:	48 89 c7             	mov    %rax,%rdi
  812455:	48 b8 d4 df 80 00 00 	movabs $0x80dfd4,%rax
  81245c:	00 00 00 
  81245f:	ff d0                	callq  *%rax
      r = iprh->next_pbuf;
  812461:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  812465:	48 8b 00             	mov    (%rax),%rax
  812468:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  81246c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  812471:	75 b0                	jne    812423 <ip_reass+0x37c>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  812473:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  812477:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81247b:	48 89 d6             	mov    %rdx,%rsi
  81247e:	48 89 c7             	mov    %rax,%rdi
  812481:	48 b8 97 1b 81 00 00 	movabs $0x811b97,%rax
  812488:	00 00 00 
  81248b:	ff d0                	callq  *%rax

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  81248d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  812491:	48 89 c7             	mov    %rax,%rdi
  812494:	48 b8 7d df 80 00 00 	movabs $0x80df7d,%rax
  81249b:	00 00 00 
  81249e:	ff d0                	callq  *%rax
  8124a0:	89 c1                	mov    %eax,%ecx
  8124a2:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8124a9:	00 00 00 
  8124ac:	0f b7 10             	movzwl (%rax),%edx
  8124af:	0f b6 c1             	movzbl %cl,%eax
  8124b2:	29 c2                	sub    %eax,%edx
  8124b4:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8124bb:	00 00 00 
  8124be:	66 89 10             	mov    %dx,(%rax)

    /* Return the pbuf chain */
    return p;
  8124c1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8124c5:	eb 23                	jmp    8124ea <ip_reass+0x443>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  8124c7:	b8 00 00 00 00       	mov    $0x0,%eax
  8124cc:	eb 1c                	jmp    8124ea <ip_reass+0x443>
  fraghdr = (struct ip_hdr*)p->payload;

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  8124ce:	90                   	nop
  8124cf:	eb 01                	jmp    8124d2 <ip_reass+0x42b>
      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
        ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
      IPFRAG_STATS_INC(ip_frag.memerr);
      /* @todo: send ICMP time exceeded here? */
      /* drop this pbuf */
      goto nullreturn;
  8124d1:	90                   	nop
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  8124d2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8124d6:	48 89 c7             	mov    %rax,%rdi
  8124d9:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  8124e0:	00 00 00 
  8124e3:	ff d0                	callq  *%rax
  return NULL;
  8124e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8124ea:	48 83 c4 48          	add    $0x48,%rsp
  8124ee:	5b                   	pop    %rbx
  8124ef:	5d                   	pop    %rbp
  8124f0:	c3                   	retq   

00000000008124f1 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  8124f1:	55                   	push   %rbp
  8124f2:	48 89 e5             	mov    %rsp,%rbp
  8124f5:	48 83 ec 50          	sub    $0x50,%rsp
  8124f9:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8124fd:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  812501:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  812505:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  812509:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  81250d:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  812511:	66 c7 45 fa 14 00    	movw   $0x14,-0x6(%rbp)
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  812517:	ba 02 00 00 00       	mov    $0x2,%edx
  81251c:	be 00 00 00 00       	mov    $0x0,%esi
  812521:	bf 02 00 00 00       	mov    $0x2,%edi
  812526:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  81252d:	00 00 00 
  812530:	ff d0                	callq  *%rax
  812532:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (rambuf == NULL) {
  812536:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81253b:	75 0a                	jne    812547 <ip_frag+0x56>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  81253d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  812542:	e9 85 02 00 00       	jmpq   8127cc <ip_frag+0x2db>
  }
  rambuf->tot_len = rambuf->len = mtu;
  812547:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81254b:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  81254f:	66 89 50 12          	mov    %dx,0x12(%rax)
  812553:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812557:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  81255b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81255f:	66 89 50 10          	mov    %dx,0x10(%rax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  812563:	48 b8 80 b0 b4 00 00 	movabs $0xb4b080,%rax
  81256a:	00 00 00 
  81256d:	48 83 c0 03          	add    $0x3,%rax
  812571:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  812575:	48 89 c2             	mov    %rax,%rdx
  812578:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81257c:	48 89 50 08          	mov    %rdx,0x8(%rax)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  812580:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812584:	48 8b 40 08          	mov    0x8(%rax),%rax
  812588:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  81258c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812590:	48 8b 48 08          	mov    0x8(%rax),%rcx
  812594:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812598:	ba 14 00 00 00       	mov    $0x14,%edx
  81259d:	48 89 ce             	mov    %rcx,%rsi
  8125a0:	48 89 c7             	mov    %rax,%rdi
  8125a3:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  8125aa:	00 00 00 
  8125ad:	ff d0                	callq  *%rax
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  8125af:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8125b3:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  8125b7:	0f b7 c0             	movzwl %ax,%eax
  8125ba:	89 c7                	mov    %eax,%edi
  8125bc:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  8125c3:	00 00 00 
  8125c6:	ff d0                	callq  *%rax
  8125c8:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
  ofo = tmp & IP_OFFMASK;
  8125cc:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  8125d0:	66 25 ff 1f          	and    $0x1fff,%ax
  8125d4:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  omf = tmp & IP_MF;
  8125d8:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  8125dc:	66 25 00 20          	and    $0x2000,%ax
  8125e0:	66 89 45 de          	mov    %ax,-0x22(%rbp)

  left = p->tot_len - IP_HLEN;
  8125e4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8125e8:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8125ec:	83 e8 14             	sub    $0x14,%eax
  8125ef:	66 89 45 fe          	mov    %ax,-0x2(%rbp)

  nfb = (mtu - IP_HLEN) / 8;
  8125f3:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8125f7:	83 e8 14             	sub    $0x14,%eax
  8125fa:	8d 50 07             	lea    0x7(%rax),%edx
  8125fd:	85 c0                	test   %eax,%eax
  8125ff:	0f 48 c2             	cmovs  %edx,%eax
  812602:	c1 f8 03             	sar    $0x3,%eax
  812605:	66 89 45 dc          	mov    %ax,-0x24(%rbp)

  while (left) {
  812609:	e9 9b 01 00 00       	jmpq   8127a9 <ip_frag+0x2b8>
    last = (left <= mtu - IP_HLEN);
  81260e:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  812612:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  812616:	83 ea 14             	sub    $0x14,%edx
  812619:	39 d0                	cmp    %edx,%eax
  81261b:	0f 9e c0             	setle  %al
  81261e:	0f b6 c0             	movzbl %al,%eax
  812621:	66 89 45 da          	mov    %ax,-0x26(%rbp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  812625:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  812629:	66 25 ff 1f          	and    $0x1fff,%ax
  81262d:	66 0b 45 de          	or     -0x22(%rbp),%ax
  812631:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
    if (!last)
  812635:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  81263a:	75 06                	jne    812642 <ip_frag+0x151>
      tmp = tmp | IP_MF;
  81263c:	66 81 4d f8 00 20    	orw    $0x2000,-0x8(%rbp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  812642:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  812647:	75 09                	jne    812652 <ip_frag+0x161>
  812649:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  81264d:	c1 e0 03             	shl    $0x3,%eax
  812650:	eb 04                	jmp    812656 <ip_frag+0x165>
  812652:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  812656:	66 89 45 d8          	mov    %ax,-0x28(%rbp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  81265a:	0f b7 4d fa          	movzwl -0x6(%rbp),%ecx
  81265e:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  812662:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812666:	48 8d 70 14          	lea    0x14(%rax),%rsi
  81266a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81266e:	48 89 c7             	mov    %rax,%rdi
  812671:	48 b8 d9 e4 80 00 00 	movabs $0x80e4d9,%rax
  812678:	00 00 00 
  81267b:	ff d0                	callq  *%rax
  81267d:	66 01 45 fa          	add    %ax,-0x6(%rbp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  812681:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  812685:	89 c7                	mov    %eax,%edi
  812687:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  81268e:	00 00 00 
  812691:	ff d0                	callq  *%rax
  812693:	89 c2                	mov    %eax,%edx
  812695:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812699:	66 89 50 06          	mov    %dx,0x6(%rax)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  81269d:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  8126a1:	83 c0 14             	add    $0x14,%eax
  8126a4:	0f b7 c0             	movzwl %ax,%eax
  8126a7:	89 c7                	mov    %eax,%edi
  8126a9:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8126b0:	00 00 00 
  8126b3:	ff d0                	callq  *%rax
  8126b5:	89 c2                	mov    %eax,%edx
  8126b7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8126bb:	66 89 50 02          	mov    %dx,0x2(%rax)
    IPH_CHKSUM_SET(iphdr, 0);
  8126bf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8126c3:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8126c9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8126cd:	be 14 00 00 00       	mov    $0x14,%esi
  8126d2:	48 89 c7             	mov    %rax,%rdi
  8126d5:	48 b8 c9 2b 81 00 00 	movabs $0x812bc9,%rax
  8126dc:	00 00 00 
  8126df:	ff d0                	callq  *%rax
  8126e1:	89 c2                	mov    %eax,%edx
  8126e3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8126e7:	66 89 50 0a          	mov    %dx,0xa(%rax)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  8126eb:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  8126f0:	74 1f                	je     812711 <ip_frag+0x220>
      pbuf_realloc(rambuf, left + IP_HLEN);
  8126f2:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  8126f6:	83 c0 14             	add    $0x14,%eax
  8126f9:	0f b7 d0             	movzwl %ax,%edx
  8126fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812700:	89 d6                	mov    %edx,%esi
  812702:	48 89 c7             	mov    %rax,%rdi
  812705:	48 b8 ba d9 80 00 00 	movabs $0x80d9ba,%rax
  81270c:	00 00 00 
  81270f:	ff d0                	callq  *%rax
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  812711:	ba 00 00 00 00       	mov    $0x0,%edx
  812716:	be 00 00 00 00       	mov    $0x0,%esi
  81271b:	bf 02 00 00 00       	mov    $0x2,%edi
  812720:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  812727:	00 00 00 
  81272a:	ff d0                	callq  *%rax
  81272c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (header != NULL) {
  812730:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  812735:	74 48                	je     81277f <ip_frag+0x28e>
      pbuf_chain(header, rambuf);
  812737:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81273b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81273f:	48 89 d6             	mov    %rdx,%rsi
  812742:	48 89 c7             	mov    %rax,%rdi
  812745:	48 b8 f4 e0 80 00 00 	movabs $0x80e0f4,%rax
  81274c:	00 00 00 
  81274f:	ff d0                	callq  *%rax
      netif->output(netif, header, dest);
  812751:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  812755:	48 8b 40 20          	mov    0x20(%rax),%rax
  812759:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  81275d:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  812761:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  812765:	48 89 cf             	mov    %rcx,%rdi
  812768:	ff d0                	callq  *%rax
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  81276a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81276e:	48 89 c7             	mov    %rax,%rdi
  812771:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  812778:	00 00 00 
  81277b:	ff d0                	callq  *%rax
  81277d:	eb 1a                	jmp    812799 <ip_frag+0x2a8>
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  81277f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812783:	48 89 c7             	mov    %rax,%rdi
  812786:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81278d:	00 00 00 
  812790:	ff d0                	callq  *%rax
      return ERR_MEM;
  812792:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  812797:	eb 33                	jmp    8127cc <ip_frag+0x2db>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  812799:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  81279d:	66 29 45 fe          	sub    %ax,-0x2(%rbp)
    ofo += nfb;
  8127a1:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8127a5:	66 01 45 fc          	add    %ax,-0x4(%rbp)

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  8127a9:	66 83 7d fe 00       	cmpw   $0x0,-0x2(%rbp)
  8127ae:	0f 85 5a fe ff ff    	jne    81260e <ip_frag+0x11d>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  8127b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8127b8:	48 89 c7             	mov    %rax,%rdi
  8127bb:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  8127c2:	00 00 00 
  8127c5:	ff d0                	callq  *%rax
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  8127c7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8127cc:	c9                   	leaveq 
  8127cd:	c3                   	retq   

00000000008127ce <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  8127ce:	55                   	push   %rbp
  8127cf:	48 89 e5             	mov    %rsp,%rbp
  8127d2:	48 83 ec 30          	sub    $0x30,%rsp
  8127d6:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8127da:	89 f0                	mov    %esi,%eax
  8127dc:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  8127e0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  8127e7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8127eb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  while (len > 1) {
  8127ef:	eb 35                	jmp    812826 <lwip_standard_chksum+0x58>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  8127f1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8127f5:	0f b6 00             	movzbl (%rax),%eax
  8127f8:	0f b6 c0             	movzbl %al,%eax
  8127fb:	c1 e0 08             	shl    $0x8,%eax
  8127fe:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    octetptr++;
  812802:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
    /* declare second octet as least significant */
    src |= (*octetptr);
  812807:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81280b:	0f b6 00             	movzbl (%rax),%eax
  81280e:	0f b6 c0             	movzbl %al,%eax
  812811:	66 09 45 ee          	or     %ax,-0x12(%rbp)
    octetptr++;
  812815:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
    acc += src;
  81281a:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  81281e:	01 45 fc             	add    %eax,-0x4(%rbp)
    len -= 2;
  812821:	66 83 6d d4 02       	subw   $0x2,-0x2c(%rbp)
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  812826:	66 83 7d d4 01       	cmpw   $0x1,-0x2c(%rbp)
  81282b:	77 c4                	ja     8127f1 <lwip_standard_chksum+0x23>
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  81282d:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%rbp)
  812832:	74 18                	je     81284c <lwip_standard_chksum+0x7e>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  812834:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812838:	0f b6 00             	movzbl (%rax),%eax
  81283b:	0f b6 c0             	movzbl %al,%eax
  81283e:	c1 e0 08             	shl    $0x8,%eax
  812841:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    acc += src;
  812845:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  812849:	01 45 fc             	add    %eax,-0x4(%rbp)
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  81284c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81284f:	c1 e8 10             	shr    $0x10,%eax
  812852:	89 c2                	mov    %eax,%edx
  812854:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812857:	0f b7 c0             	movzwl %ax,%eax
  81285a:	01 d0                	add    %edx,%eax
  81285c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  if ((acc & 0xffff0000) != 0) {
  81285f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812862:	66 b8 00 00          	mov    $0x0,%ax
  812866:	85 c0                	test   %eax,%eax
  812868:	74 13                	je     81287d <lwip_standard_chksum+0xaf>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  81286a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81286d:	c1 e8 10             	shr    $0x10,%eax
  812870:	89 c2                	mov    %eax,%edx
  812872:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812875:	0f b7 c0             	movzwl %ax,%eax
  812878:	01 d0                	add    %edx,%eax
  81287a:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  81287d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812880:	0f b7 c0             	movzwl %ax,%eax
  812883:	89 c7                	mov    %eax,%edi
  812885:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  81288c:	00 00 00 
  81288f:	ff d0                	callq  *%rax
}
  812891:	c9                   	leaveq 
  812892:	c3                   	retq   

0000000000812893 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  812893:	55                   	push   %rbp
  812894:	48 89 e5             	mov    %rsp,%rbp
  812897:	48 83 ec 40          	sub    $0x40,%rsp
  81289b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81289f:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8128a3:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8128a7:	89 c8                	mov    %ecx,%eax
  8128a9:	44 89 c2             	mov    %r8d,%edx
  8128ac:	88 45 c4             	mov    %al,-0x3c(%rbp)
  8128af:	66 89 55 c0          	mov    %dx,-0x40(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  8128b3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  8128ba:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  8128be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8128c2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8128c6:	eb 7d                	jmp    812945 <inet_chksum_pseudo+0xb2>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  8128c8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8128cc:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8128d0:	0f b7 d0             	movzwl %ax,%edx
  8128d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8128d7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8128db:	89 d6                	mov    %edx,%esi
  8128dd:	48 89 c7             	mov    %rax,%rdi
  8128e0:	48 b8 ce 27 81 00 00 	movabs $0x8127ce,%rax
  8128e7:	00 00 00 
  8128ea:	ff d0                	callq  *%rax
  8128ec:	0f b7 c0             	movzwl %ax,%eax
  8128ef:	01 45 fc             	add    %eax,-0x4(%rbp)
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  8128f2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8128f5:	c1 e8 10             	shr    $0x10,%eax
  8128f8:	89 c2                	mov    %eax,%edx
  8128fa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8128fd:	0f b7 c0             	movzwl %ax,%eax
  812900:	01 d0                	add    %edx,%eax
  812902:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  812905:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812909:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81290d:	83 e0 01             	and    $0x1,%eax
  812910:	66 85 c0             	test   %ax,%ax
  812913:	74 25                	je     81293a <inet_chksum_pseudo+0xa7>
      swapped = 1 - swapped;
  812915:	b8 01 00 00 00       	mov    $0x1,%eax
  81291a:	2a 45 ef             	sub    -0x11(%rbp),%al
  81291d:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  812920:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812923:	c1 e0 08             	shl    $0x8,%eax
  812926:	0f b7 c0             	movzwl %ax,%eax
  812929:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81292c:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  812932:	c1 ea 08             	shr    $0x8,%edx
  812935:	09 d0                	or     %edx,%eax
  812937:	89 45 fc             	mov    %eax,-0x4(%rbp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  81293a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81293e:	48 8b 00             	mov    (%rax),%rax
  812941:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  812945:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81294a:	0f 85 78 ff ff ff    	jne    8128c8 <inet_chksum_pseudo+0x35>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  812950:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  812954:	74 1a                	je     812970 <inet_chksum_pseudo+0xdd>
    acc = SWAP_BYTES_IN_WORD(acc);
  812956:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812959:	c1 e0 08             	shl    $0x8,%eax
  81295c:	0f b7 c0             	movzwl %ax,%eax
  81295f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812962:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  812968:	c1 ea 08             	shr    $0x8,%edx
  81296b:	09 d0                	or     %edx,%eax
  81296d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  acc += (src->addr & 0xffffUL);
  812970:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812974:	8b 00                	mov    (%rax),%eax
  812976:	0f b7 c0             	movzwl %ax,%eax
  812979:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((src->addr >> 16) & 0xffffUL);
  81297c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812980:	8b 00                	mov    (%rax),%eax
  812982:	c1 e8 10             	shr    $0x10,%eax
  812985:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (dest->addr & 0xffffUL);
  812988:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81298c:	8b 00                	mov    (%rax),%eax
  81298e:	0f b7 c0             	movzwl %ax,%eax
  812991:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((dest->addr >> 16) & 0xffffUL);
  812994:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812998:	8b 00                	mov    (%rax),%eax
  81299a:	c1 e8 10             	shr    $0x10,%eax
  81299d:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons((u16_t)proto);
  8129a0:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  8129a4:	89 c7                	mov    %eax,%edi
  8129a6:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8129ad:	00 00 00 
  8129b0:	ff d0                	callq  *%rax
  8129b2:	0f b7 c0             	movzwl %ax,%eax
  8129b5:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons(proto_len);
  8129b8:	0f b7 45 c0          	movzwl -0x40(%rbp),%eax
  8129bc:	89 c7                	mov    %eax,%edi
  8129be:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8129c5:	00 00 00 
  8129c8:	ff d0                	callq  *%rax
  8129ca:	0f b7 c0             	movzwl %ax,%eax
  8129cd:	01 45 fc             	add    %eax,-0x4(%rbp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  8129d0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8129d3:	c1 e8 10             	shr    $0x10,%eax
  8129d6:	89 c2                	mov    %eax,%edx
  8129d8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8129db:	0f b7 c0             	movzwl %ax,%eax
  8129de:	01 d0                	add    %edx,%eax
  8129e0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  acc = FOLD_U32T(acc);
  8129e3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8129e6:	c1 e8 10             	shr    $0x10,%eax
  8129e9:	89 c2                	mov    %eax,%edx
  8129eb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8129ee:	0f b7 c0             	movzwl %ax,%eax
  8129f1:	01 d0                	add    %edx,%eax
  8129f3:	89 45 fc             	mov    %eax,-0x4(%rbp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  8129f6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8129f9:	f7 d0                	not    %eax
}
  8129fb:	c9                   	leaveq 
  8129fc:	c3                   	retq   

00000000008129fd <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  8129fd:	55                   	push   %rbp
  8129fe:	48 89 e5             	mov    %rsp,%rbp
  812a01:	48 83 ec 50          	sub    $0x50,%rsp
  812a05:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  812a09:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  812a0d:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  812a11:	89 c8                	mov    %ecx,%eax
  812a13:	44 89 c1             	mov    %r8d,%ecx
  812a16:	44 89 ca             	mov    %r9d,%edx
  812a19:	88 45 c4             	mov    %al,-0x3c(%rbp)
  812a1c:	66 89 4d c0          	mov    %cx,-0x40(%rbp)
  812a20:	66 89 55 bc          	mov    %dx,-0x44(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  812a24:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  812a2b:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  812a2f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812a33:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  812a37:	e9 ce 00 00 00       	jmpq   812b0a <inet_chksum_pseudo_partial+0x10d>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  812a3c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812a40:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812a44:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    if (chklen > chksum_len) {
  812a48:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  812a4c:	66 3b 45 bc          	cmp    -0x44(%rbp),%ax
  812a50:	76 08                	jbe    812a5a <inet_chksum_pseudo_partial+0x5d>
      chklen = chksum_len;
  812a52:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  812a56:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  812a5a:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  812a5e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812a62:	48 8b 40 08          	mov    0x8(%rax),%rax
  812a66:	89 d6                	mov    %edx,%esi
  812a68:	48 89 c7             	mov    %rax,%rdi
  812a6b:	48 b8 ce 27 81 00 00 	movabs $0x8127ce,%rax
  812a72:	00 00 00 
  812a75:	ff d0                	callq  *%rax
  812a77:	0f b7 c0             	movzwl %ax,%eax
  812a7a:	01 45 fc             	add    %eax,-0x4(%rbp)
    chksum_len -= chklen;
  812a7d:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  812a81:	66 29 45 bc          	sub    %ax,-0x44(%rbp)
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  812a85:	66 81 7d bc fe 7f    	cmpw   $0x7ffe,-0x44(%rbp)
  812a8b:	76 2a                	jbe    812ab7 <inet_chksum_pseudo_partial+0xba>
  812a8d:	48 ba 68 2a 82 00 00 	movabs $0x822a68,%rdx
  812a94:	00 00 00 
  812a97:	be 61 01 00 00       	mov    $0x161,%esi
  812a9c:	48 bf 78 2a 82 00 00 	movabs $0x822a78,%rdi
  812aa3:	00 00 00 
  812aa6:	b8 00 00 00 00       	mov    $0x0,%eax
  812aab:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  812ab2:	00 00 00 
  812ab5:	ff d1                	callq  *%rcx
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  812ab7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812aba:	c1 e8 10             	shr    $0x10,%eax
  812abd:	89 c2                	mov    %eax,%edx
  812abf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812ac2:	0f b7 c0             	movzwl %ax,%eax
  812ac5:	01 d0                	add    %edx,%eax
  812ac7:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  812aca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812ace:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812ad2:	83 e0 01             	and    $0x1,%eax
  812ad5:	66 85 c0             	test   %ax,%ax
  812ad8:	74 25                	je     812aff <inet_chksum_pseudo_partial+0x102>
      swapped = 1 - swapped;
  812ada:	b8 01 00 00 00       	mov    $0x1,%eax
  812adf:	2a 45 ef             	sub    -0x11(%rbp),%al
  812ae2:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  812ae5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812ae8:	c1 e0 08             	shl    $0x8,%eax
  812aeb:	0f b7 c0             	movzwl %ax,%eax
  812aee:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812af1:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  812af7:	c1 ea 08             	shr    $0x8,%edx
  812afa:	09 d0                	or     %edx,%eax
  812afc:	89 45 fc             	mov    %eax,-0x4(%rbp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  812aff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812b03:	48 8b 00             	mov    (%rax),%rax
  812b06:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  812b0a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  812b0f:	74 0b                	je     812b1c <inet_chksum_pseudo_partial+0x11f>
  812b11:	66 83 7d bc 00       	cmpw   $0x0,-0x44(%rbp)
  812b16:	0f 85 20 ff ff ff    	jne    812a3c <inet_chksum_pseudo_partial+0x3f>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  812b1c:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  812b20:	74 1a                	je     812b3c <inet_chksum_pseudo_partial+0x13f>
    acc = SWAP_BYTES_IN_WORD(acc);
  812b22:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812b25:	c1 e0 08             	shl    $0x8,%eax
  812b28:	0f b7 c0             	movzwl %ax,%eax
  812b2b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812b2e:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  812b34:	c1 ea 08             	shr    $0x8,%edx
  812b37:	09 d0                	or     %edx,%eax
  812b39:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  acc += (src->addr & 0xffffUL);
  812b3c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812b40:	8b 00                	mov    (%rax),%eax
  812b42:	0f b7 c0             	movzwl %ax,%eax
  812b45:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((src->addr >> 16) & 0xffffUL);
  812b48:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812b4c:	8b 00                	mov    (%rax),%eax
  812b4e:	c1 e8 10             	shr    $0x10,%eax
  812b51:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (dest->addr & 0xffffUL);
  812b54:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812b58:	8b 00                	mov    (%rax),%eax
  812b5a:	0f b7 c0             	movzwl %ax,%eax
  812b5d:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((dest->addr >> 16) & 0xffffUL);
  812b60:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812b64:	8b 00                	mov    (%rax),%eax
  812b66:	c1 e8 10             	shr    $0x10,%eax
  812b69:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons((u16_t)proto);
  812b6c:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  812b70:	89 c7                	mov    %eax,%edi
  812b72:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  812b79:	00 00 00 
  812b7c:	ff d0                	callq  *%rax
  812b7e:	0f b7 c0             	movzwl %ax,%eax
  812b81:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons(proto_len);
  812b84:	0f b7 45 c0          	movzwl -0x40(%rbp),%eax
  812b88:	89 c7                	mov    %eax,%edi
  812b8a:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  812b91:	00 00 00 
  812b94:	ff d0                	callq  *%rax
  812b96:	0f b7 c0             	movzwl %ax,%eax
  812b99:	01 45 fc             	add    %eax,-0x4(%rbp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  812b9c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812b9f:	c1 e8 10             	shr    $0x10,%eax
  812ba2:	89 c2                	mov    %eax,%edx
  812ba4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812ba7:	0f b7 c0             	movzwl %ax,%eax
  812baa:	01 d0                	add    %edx,%eax
  812bac:	89 45 fc             	mov    %eax,-0x4(%rbp)
  acc = FOLD_U32T(acc);
  812baf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812bb2:	c1 e8 10             	shr    $0x10,%eax
  812bb5:	89 c2                	mov    %eax,%edx
  812bb7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812bba:	0f b7 c0             	movzwl %ax,%eax
  812bbd:	01 d0                	add    %edx,%eax
  812bbf:	89 45 fc             	mov    %eax,-0x4(%rbp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  812bc2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812bc5:	f7 d0                	not    %eax
}
  812bc7:	c9                   	leaveq 
  812bc8:	c3                   	retq   

0000000000812bc9 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  812bc9:	55                   	push   %rbp
  812bca:	48 89 e5             	mov    %rsp,%rbp
  812bcd:	48 83 ec 10          	sub    $0x10,%rsp
  812bd1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  812bd5:	89 f0                	mov    %esi,%eax
  812bd7:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  return ~LWIP_CHKSUM(dataptr, len);
  812bdb:	0f b7 55 f4          	movzwl -0xc(%rbp),%edx
  812bdf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812be3:	89 d6                	mov    %edx,%esi
  812be5:	48 89 c7             	mov    %rax,%rdi
  812be8:	48 b8 ce 27 81 00 00 	movabs $0x8127ce,%rax
  812bef:	00 00 00 
  812bf2:	ff d0                	callq  *%rax
  812bf4:	f7 d0                	not    %eax
}
  812bf6:	c9                   	leaveq 
  812bf7:	c3                   	retq   

0000000000812bf8 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  812bf8:	55                   	push   %rbp
  812bf9:	48 89 e5             	mov    %rsp,%rbp
  812bfc:	48 83 ec 30          	sub    $0x30,%rsp
  812c00:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  812c04:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  812c0b:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  for(q = p; q != NULL; q = q->next) {
  812c0f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812c13:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  812c17:	eb 7d                	jmp    812c96 <inet_chksum_pbuf+0x9e>
    acc += LWIP_CHKSUM(q->payload, q->len);
  812c19:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812c1d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812c21:	0f b7 d0             	movzwl %ax,%edx
  812c24:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812c28:	48 8b 40 08          	mov    0x8(%rax),%rax
  812c2c:	89 d6                	mov    %edx,%esi
  812c2e:	48 89 c7             	mov    %rax,%rdi
  812c31:	48 b8 ce 27 81 00 00 	movabs $0x8127ce,%rax
  812c38:	00 00 00 
  812c3b:	ff d0                	callq  *%rax
  812c3d:	0f b7 c0             	movzwl %ax,%eax
  812c40:	01 45 fc             	add    %eax,-0x4(%rbp)
    acc = FOLD_U32T(acc);
  812c43:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812c46:	c1 e8 10             	shr    $0x10,%eax
  812c49:	89 c2                	mov    %eax,%edx
  812c4b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812c4e:	0f b7 c0             	movzwl %ax,%eax
  812c51:	01 d0                	add    %edx,%eax
  812c53:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  812c56:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812c5a:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812c5e:	83 e0 01             	and    $0x1,%eax
  812c61:	66 85 c0             	test   %ax,%ax
  812c64:	74 25                	je     812c8b <inet_chksum_pbuf+0x93>
      swapped = 1 - swapped;
  812c66:	b8 01 00 00 00       	mov    $0x1,%eax
  812c6b:	2a 45 ef             	sub    -0x11(%rbp),%al
  812c6e:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  812c71:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812c74:	c1 e0 08             	shl    $0x8,%eax
  812c77:	0f b7 c0             	movzwl %ax,%eax
  812c7a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812c7d:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  812c83:	c1 ea 08             	shr    $0x8,%edx
  812c86:	09 d0                	or     %edx,%eax
  812c88:	89 45 fc             	mov    %eax,-0x4(%rbp)
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  812c8b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812c8f:	48 8b 00             	mov    (%rax),%rax
  812c92:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  812c96:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  812c9b:	0f 85 78 ff ff ff    	jne    812c19 <inet_chksum_pbuf+0x21>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  812ca1:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  812ca5:	74 1a                	je     812cc1 <inet_chksum_pbuf+0xc9>
    acc = SWAP_BYTES_IN_WORD(acc);
  812ca7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812caa:	c1 e0 08             	shl    $0x8,%eax
  812cad:	0f b7 c0             	movzwl %ax,%eax
  812cb0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812cb3:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  812cb9:	c1 ea 08             	shr    $0x8,%edx
  812cbc:	09 d0                	or     %edx,%eax
  812cbe:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  return (u16_t)~(acc & 0xffffUL);
  812cc1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812cc4:	f7 d0                	not    %eax
}
  812cc6:	c9                   	leaveq 
  812cc7:	c3                   	retq   

0000000000812cc8 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  812cc8:	55                   	push   %rbp
  812cc9:	48 89 e5             	mov    %rsp,%rbp
  812ccc:	48 83 ec 20          	sub    $0x20,%rsp
  812cd0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  812cd4:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  812cd8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812cdc:	48 89 d6             	mov    %rdx,%rsi
  812cdf:	48 89 c7             	mov    %rax,%rdi
  812ce2:	48 b8 fe 2c 81 00 00 	movabs $0x812cfe,%rax
  812ce9:	00 00 00 
  812cec:	ff d0                	callq  *%rax
  812cee:	85 c0                	test   %eax,%eax
  812cf0:	74 05                	je     812cf7 <inet_addr+0x2f>
    return (val.s_addr);
  812cf2:	8b 45 f0             	mov    -0x10(%rbp),%eax
  812cf5:	eb 05                	jmp    812cfc <inet_addr+0x34>
  }
  return (INADDR_NONE);
  812cf7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  812cfc:	c9                   	leaveq 
  812cfd:	c3                   	retq   

0000000000812cfe <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  812cfe:	55                   	push   %rbp
  812cff:	48 89 e5             	mov    %rsp,%rbp
  812d02:	48 83 ec 40          	sub    $0x40,%rsp
  812d06:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  812d0a:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  812d0e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  812d12:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  c = *cp;
  812d16:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812d1a:	0f b6 00             	movzbl (%rax),%eax
  812d1d:	0f be c0             	movsbl %al,%eax
  812d20:	89 45 f4             	mov    %eax,-0xc(%rbp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  812d23:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d26:	0f b6 c0             	movzbl %al,%eax
  812d29:	83 f8 2f             	cmp    $0x2f,%eax
  812d2c:	7e 0b                	jle    812d39 <inet_aton+0x3b>
  812d2e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d31:	0f b6 c0             	movzbl %al,%eax
  812d34:	83 f8 39             	cmp    $0x39,%eax
  812d37:	7e 0a                	jle    812d43 <inet_aton+0x45>
      return (0);
  812d39:	b8 00 00 00 00       	mov    $0x0,%eax
  812d3e:	e9 a1 02 00 00       	jmpq   812fe4 <inet_aton+0x2e6>
    val = 0;
  812d43:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    base = 10;
  812d4a:	c7 45 f8 0a 00 00 00 	movl   $0xa,-0x8(%rbp)
    if (c == '0') {
  812d51:	83 7d f4 30          	cmpl   $0x30,-0xc(%rbp)
  812d55:	75 40                	jne    812d97 <inet_aton+0x99>
      c = *++cp;
  812d57:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812d5c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812d60:	0f b6 00             	movzbl (%rax),%eax
  812d63:	0f be c0             	movsbl %al,%eax
  812d66:	89 45 f4             	mov    %eax,-0xc(%rbp)
      if (c == 'x' || c == 'X') {
  812d69:	83 7d f4 78          	cmpl   $0x78,-0xc(%rbp)
  812d6d:	74 06                	je     812d75 <inet_aton+0x77>
  812d6f:	83 7d f4 58          	cmpl   $0x58,-0xc(%rbp)
  812d73:	75 1b                	jne    812d90 <inet_aton+0x92>
        base = 16;
  812d75:	c7 45 f8 10 00 00 00 	movl   $0x10,-0x8(%rbp)
        c = *++cp;
  812d7c:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812d81:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812d85:	0f b6 00             	movzbl (%rax),%eax
  812d88:	0f be c0             	movsbl %al,%eax
  812d8b:	89 45 f4             	mov    %eax,-0xc(%rbp)
  812d8e:	eb 07                	jmp    812d97 <inet_aton+0x99>
      } else
        base = 8;
  812d90:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%rbp)
    }
    for (;;) {
      if (isdigit(c)) {
  812d97:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812d9a:	0f b6 c0             	movzbl %al,%eax
  812d9d:	83 f8 2f             	cmp    $0x2f,%eax
  812da0:	7e 36                	jle    812dd8 <inet_aton+0xda>
  812da2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812da5:	0f b6 c0             	movzbl %al,%eax
  812da8:	83 f8 39             	cmp    $0x39,%eax
  812dab:	7f 2b                	jg     812dd8 <inet_aton+0xda>
        val = (val * base) + (int)(c - '0');
  812dad:	8b 45 f8             	mov    -0x8(%rbp),%eax
  812db0:	0f af 45 fc          	imul   -0x4(%rbp),%eax
  812db4:	89 c2                	mov    %eax,%edx
  812db6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812db9:	01 d0                	add    %edx,%eax
  812dbb:	83 e8 30             	sub    $0x30,%eax
  812dbe:	89 45 fc             	mov    %eax,-0x4(%rbp)
        c = *++cp;
  812dc1:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812dc6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812dca:	0f b6 00             	movzbl (%rax),%eax
  812dcd:	0f be c0             	movsbl %al,%eax
  812dd0:	89 45 f4             	mov    %eax,-0xc(%rbp)
  812dd3:	e9 97 00 00 00       	jmpq   812e6f <inet_aton+0x171>
      } else if (base == 16 && isxdigit(c)) {
  812dd8:	83 7d f8 10          	cmpl   $0x10,-0x8(%rbp)
  812ddc:	0f 85 92 00 00 00    	jne    812e74 <inet_aton+0x176>
  812de2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812de5:	0f b6 c0             	movzbl %al,%eax
  812de8:	83 f8 2f             	cmp    $0x2f,%eax
  812deb:	7e 0b                	jle    812df8 <inet_aton+0xfa>
  812ded:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812df0:	0f b6 c0             	movzbl %al,%eax
  812df3:	83 f8 39             	cmp    $0x39,%eax
  812df6:	7e 2c                	jle    812e24 <inet_aton+0x126>
  812df8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812dfb:	0f b6 c0             	movzbl %al,%eax
  812dfe:	83 f8 60             	cmp    $0x60,%eax
  812e01:	7e 0b                	jle    812e0e <inet_aton+0x110>
  812e03:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812e06:	0f b6 c0             	movzbl %al,%eax
  812e09:	83 f8 66             	cmp    $0x66,%eax
  812e0c:	7e 16                	jle    812e24 <inet_aton+0x126>
  812e0e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812e11:	0f b6 c0             	movzbl %al,%eax
  812e14:	83 f8 40             	cmp    $0x40,%eax
  812e17:	7e 5b                	jle    812e74 <inet_aton+0x176>
  812e19:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812e1c:	0f b6 c0             	movzbl %al,%eax
  812e1f:	83 f8 46             	cmp    $0x46,%eax
  812e22:	7f 50                	jg     812e74 <inet_aton+0x176>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  812e24:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812e27:	c1 e0 04             	shl    $0x4,%eax
  812e2a:	89 c2                	mov    %eax,%edx
  812e2c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812e2f:	8d 48 0a             	lea    0xa(%rax),%ecx
  812e32:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812e35:	0f b6 c0             	movzbl %al,%eax
  812e38:	83 f8 60             	cmp    $0x60,%eax
  812e3b:	7e 12                	jle    812e4f <inet_aton+0x151>
  812e3d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812e40:	0f b6 c0             	movzbl %al,%eax
  812e43:	83 f8 7a             	cmp    $0x7a,%eax
  812e46:	7f 07                	jg     812e4f <inet_aton+0x151>
  812e48:	b8 61 00 00 00       	mov    $0x61,%eax
  812e4d:	eb 05                	jmp    812e54 <inet_aton+0x156>
  812e4f:	b8 41 00 00 00       	mov    $0x41,%eax
  812e54:	29 c1                	sub    %eax,%ecx
  812e56:	89 c8                	mov    %ecx,%eax
  812e58:	09 d0                	or     %edx,%eax
  812e5a:	89 45 fc             	mov    %eax,-0x4(%rbp)
        c = *++cp;
  812e5d:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812e62:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812e66:	0f b6 00             	movzbl (%rax),%eax
  812e69:	0f be c0             	movsbl %al,%eax
  812e6c:	89 45 f4             	mov    %eax,-0xc(%rbp)
      } else
        break;
    }
  812e6f:	e9 23 ff ff ff       	jmpq   812d97 <inet_aton+0x99>
    if (c == '.') {
  812e74:	83 7d f4 2e          	cmpl   $0x2e,-0xc(%rbp)
  812e78:	75 40                	jne    812eba <inet_aton+0x1bc>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  812e7a:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  812e7e:	48 83 c0 0c          	add    $0xc,%rax
  812e82:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  812e86:	77 0a                	ja     812e92 <inet_aton+0x194>
        return (0);
  812e88:	b8 00 00 00 00       	mov    $0x0,%eax
  812e8d:	e9 52 01 00 00       	jmpq   812fe4 <inet_aton+0x2e6>
      *pp++ = val;
  812e92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812e96:	48 8d 50 04          	lea    0x4(%rax),%rdx
  812e9a:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  812e9e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  812ea1:	89 10                	mov    %edx,(%rax)
      c = *++cp;
  812ea3:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  812ea8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812eac:	0f b6 00             	movzbl (%rax),%eax
  812eaf:	0f be c0             	movsbl %al,%eax
  812eb2:	89 45 f4             	mov    %eax,-0xc(%rbp)
    } else
      break;
  }
  812eb5:	e9 69 fe ff ff       	jmpq   812d23 <inet_aton+0x25>
      if (pp >= parts + 3)
        return (0);
      *pp++ = val;
      c = *++cp;
    } else
      break;
  812eba:	90                   	nop
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  812ebb:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  812ebf:	74 44                	je     812f05 <inet_aton+0x207>
  812ec1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812ec4:	0f b6 c0             	movzbl %al,%eax
  812ec7:	83 f8 1f             	cmp    $0x1f,%eax
  812eca:	7e 2f                	jle    812efb <inet_aton+0x1fd>
  812ecc:	8b 45 f4             	mov    -0xc(%rbp),%eax
  812ecf:	0f b6 c0             	movzbl %al,%eax
  812ed2:	83 f8 7f             	cmp    $0x7f,%eax
  812ed5:	7f 24                	jg     812efb <inet_aton+0x1fd>
  812ed7:	83 7d f4 20          	cmpl   $0x20,-0xc(%rbp)
  812edb:	74 28                	je     812f05 <inet_aton+0x207>
  812edd:	83 7d f4 0c          	cmpl   $0xc,-0xc(%rbp)
  812ee1:	74 22                	je     812f05 <inet_aton+0x207>
  812ee3:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  812ee7:	74 1c                	je     812f05 <inet_aton+0x207>
  812ee9:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  812eed:	74 16                	je     812f05 <inet_aton+0x207>
  812eef:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  812ef3:	74 10                	je     812f05 <inet_aton+0x207>
  812ef5:	83 7d f4 0b          	cmpl   $0xb,-0xc(%rbp)
  812ef9:	74 0a                	je     812f05 <inet_aton+0x207>
    return (0);
  812efb:	b8 00 00 00 00       	mov    $0x0,%eax
  812f00:	e9 df 00 00 00       	jmpq   812fe4 <inet_aton+0x2e6>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  812f05:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  812f09:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  812f0d:	48 29 c2             	sub    %rax,%rdx
  812f10:	48 89 d0             	mov    %rdx,%rax
  812f13:	48 c1 f8 02          	sar    $0x2,%rax
  812f17:	83 c0 01             	add    $0x1,%eax
  812f1a:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  switch (n) {
  812f1d:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  812f21:	0f 87 98 00 00 00    	ja     812fbf <inet_aton+0x2c1>
  812f27:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  812f2a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  812f31:	00 
  812f32:	48 b8 a0 2a 82 00 00 	movabs $0x822aa0,%rax
  812f39:	00 00 00 
  812f3c:	48 01 d0             	add    %rdx,%rax
  812f3f:	48 8b 00             	mov    (%rax),%rax
  812f42:	ff e0                	jmpq   *%rax

  case 0:
    return (0);       /* initial nondigit */
  812f44:	b8 00 00 00 00       	mov    $0x0,%eax
  812f49:	e9 96 00 00 00       	jmpq   812fe4 <inet_aton+0x2e6>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  812f4e:	81 7d fc ff ff ff 00 	cmpl   $0xffffff,-0x4(%rbp)
  812f55:	76 0a                	jbe    812f61 <inet_aton+0x263>
      return (0);
  812f57:	b8 00 00 00 00       	mov    $0x0,%eax
  812f5c:	e9 83 00 00 00       	jmpq   812fe4 <inet_aton+0x2e6>
    val |= parts[0] << 24;
  812f61:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812f64:	c1 e0 18             	shl    $0x18,%eax
  812f67:	09 45 fc             	or     %eax,-0x4(%rbp)
    break;
  812f6a:	eb 53                	jmp    812fbf <inet_aton+0x2c1>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  812f6c:	81 7d fc ff ff 00 00 	cmpl   $0xffff,-0x4(%rbp)
  812f73:	76 07                	jbe    812f7c <inet_aton+0x27e>
      return (0);
  812f75:	b8 00 00 00 00       	mov    $0x0,%eax
  812f7a:	eb 68                	jmp    812fe4 <inet_aton+0x2e6>
    val |= (parts[0] << 24) | (parts[1] << 16);
  812f7c:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812f7f:	c1 e0 18             	shl    $0x18,%eax
  812f82:	89 c2                	mov    %eax,%edx
  812f84:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  812f87:	c1 e0 10             	shl    $0x10,%eax
  812f8a:	09 d0                	or     %edx,%eax
  812f8c:	09 45 fc             	or     %eax,-0x4(%rbp)
    break;
  812f8f:	eb 2e                	jmp    812fbf <inet_aton+0x2c1>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  812f91:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%rbp)
  812f98:	76 07                	jbe    812fa1 <inet_aton+0x2a3>
      return (0);
  812f9a:	b8 00 00 00 00       	mov    $0x0,%eax
  812f9f:	eb 43                	jmp    812fe4 <inet_aton+0x2e6>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  812fa1:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812fa4:	c1 e0 18             	shl    $0x18,%eax
  812fa7:	89 c2                	mov    %eax,%edx
  812fa9:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  812fac:	c1 e0 10             	shl    $0x10,%eax
  812faf:	09 c2                	or     %eax,%edx
  812fb1:	8b 45 d8             	mov    -0x28(%rbp),%eax
  812fb4:	c1 e0 08             	shl    $0x8,%eax
  812fb7:	09 d0                	or     %edx,%eax
  812fb9:	09 45 fc             	or     %eax,-0x4(%rbp)
    break;
  812fbc:	eb 01                	jmp    812fbf <inet_aton+0x2c1>

  case 0:
    return (0);       /* initial nondigit */

  case 1:             /* a -- 32 bits */
    break;
  812fbe:	90                   	nop
    if (val > 0xff)
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
  812fbf:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  812fc4:	74 19                	je     812fdf <inet_aton+0x2e1>
    addr->s_addr = htonl(val);
  812fc6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812fc9:	89 c7                	mov    %eax,%edi
  812fcb:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  812fd2:	00 00 00 
  812fd5:	ff d0                	callq  *%rax
  812fd7:	89 c2                	mov    %eax,%edx
  812fd9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  812fdd:	89 10                	mov    %edx,(%rax)
  return (1);
  812fdf:	b8 01 00 00 00       	mov    $0x1,%eax
}
  812fe4:	c9                   	leaveq 
  812fe5:	c3                   	retq   

0000000000812fe6 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  812fe6:	55                   	push   %rbp
  812fe7:	48 89 e5             	mov    %rsp,%rbp
  812fea:	48 83 ec 30          	sub    $0x30,%rsp
  812fee:	89 7d d0             	mov    %edi,-0x30(%rbp)
  static char str[16];
  u32_t s_addr = addr.s_addr;
  812ff1:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812ff4:	89 45 e8             	mov    %eax,-0x18(%rbp)
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  812ff7:	48 b8 60 b6 b4 00 00 	movabs $0xb4b660,%rax
  812ffe:	00 00 00 
  813001:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  ap = (u8_t *)&s_addr;
  813005:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  813009:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  for(n = 0; n < 4; n++) {
  81300d:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  813011:	e9 e0 00 00 00       	jmpq   8130f6 <inet_ntoa+0x110>
    i = 0;
  813016:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)
    do {
      rem = *ap % (u8_t)10;
  81301a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81301e:	0f b6 08             	movzbl (%rax),%ecx
  813021:	0f b6 d1             	movzbl %cl,%edx
  813024:	89 d0                	mov    %edx,%eax
  813026:	c1 e0 02             	shl    $0x2,%eax
  813029:	01 d0                	add    %edx,%eax
  81302b:	c1 e0 03             	shl    $0x3,%eax
  81302e:	01 d0                	add    %edx,%eax
  813030:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
  813037:	01 d0                	add    %edx,%eax
  813039:	66 c1 e8 08          	shr    $0x8,%ax
  81303d:	c0 e8 03             	shr    $0x3,%al
  813040:	88 45 ed             	mov    %al,-0x13(%rbp)
  813043:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  813047:	89 d0                	mov    %edx,%eax
  813049:	c1 e0 02             	shl    $0x2,%eax
  81304c:	01 d0                	add    %edx,%eax
  81304e:	01 c0                	add    %eax,%eax
  813050:	29 c1                	sub    %eax,%ecx
  813052:	89 c8                	mov    %ecx,%eax
  813054:	88 45 ed             	mov    %al,-0x13(%rbp)
      *ap /= (u8_t)10;
  813057:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81305b:	0f b6 00             	movzbl (%rax),%eax
  81305e:	0f b6 d0             	movzbl %al,%edx
  813061:	89 d0                	mov    %edx,%eax
  813063:	c1 e0 02             	shl    $0x2,%eax
  813066:	01 d0                	add    %edx,%eax
  813068:	c1 e0 03             	shl    $0x3,%eax
  81306b:	01 d0                	add    %edx,%eax
  81306d:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
  813074:	01 d0                	add    %edx,%eax
  813076:	66 c1 e8 08          	shr    $0x8,%ax
  81307a:	89 c2                	mov    %eax,%edx
  81307c:	c0 ea 03             	shr    $0x3,%dl
  81307f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  813083:	88 10                	mov    %dl,(%rax)
      inv[i++] = '0' + rem;
  813085:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  813089:	8d 50 01             	lea    0x1(%rax),%edx
  81308c:	88 55 ee             	mov    %dl,-0x12(%rbp)
  81308f:	0f b6 c0             	movzbl %al,%eax
  813092:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  813096:	83 c2 30             	add    $0x30,%edx
  813099:	48 98                	cltq   
  81309b:	88 54 05 e0          	mov    %dl,-0x20(%rbp,%rax,1)
    } while(*ap);
  81309f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8130a3:	0f b6 00             	movzbl (%rax),%eax
  8130a6:	84 c0                	test   %al,%al
  8130a8:	0f 85 6c ff ff ff    	jne    81301a <inet_ntoa+0x34>
    while(i--)
  8130ae:	eb 1a                	jmp    8130ca <inet_ntoa+0xe4>
      *rp++ = inv[i];
  8130b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8130b4:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8130b8:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
  8130bc:	0f b6 55 ee          	movzbl -0x12(%rbp),%edx
  8130c0:	48 63 d2             	movslq %edx,%rdx
  8130c3:	0f b6 54 15 e0       	movzbl -0x20(%rbp,%rdx,1),%edx
  8130c8:	88 10                	mov    %dl,(%rax)
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  8130ca:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  8130ce:	8d 50 ff             	lea    -0x1(%rax),%edx
  8130d1:	88 55 ee             	mov    %dl,-0x12(%rbp)
  8130d4:	84 c0                	test   %al,%al
  8130d6:	75 d8                	jne    8130b0 <inet_ntoa+0xca>
      *rp++ = inv[i];
    *rp++ = '.';
  8130d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8130dc:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8130e0:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
  8130e4:	c6 00 2e             	movb   $0x2e,(%rax)
    ap++;
  8130e7:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  8130ec:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8130f0:	83 c0 01             	add    $0x1,%eax
  8130f3:	88 45 ef             	mov    %al,-0x11(%rbp)
  8130f6:	80 7d ef 03          	cmpb   $0x3,-0x11(%rbp)
  8130fa:	0f 86 16 ff ff ff    	jbe    813016 <inet_ntoa+0x30>
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
  813100:	48 83 6d f8 01       	subq   $0x1,-0x8(%rbp)
  813105:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813109:	c6 00 00             	movb   $0x0,(%rax)
  return str;
  81310c:	48 b8 60 b6 b4 00 00 	movabs $0xb4b660,%rax
  813113:	00 00 00 
}
  813116:	c9                   	leaveq 
  813117:	c3                   	retq   

0000000000813118 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  813118:	55                   	push   %rbp
  813119:	48 89 e5             	mov    %rsp,%rbp
  81311c:	48 83 ec 08          	sub    $0x8,%rsp
  813120:	89 f8                	mov    %edi,%eax
  813122:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  813126:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  81312a:	c1 e0 08             	shl    $0x8,%eax
  81312d:	89 c2                	mov    %eax,%edx
  81312f:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  813133:	66 c1 e8 08          	shr    $0x8,%ax
  813137:	09 d0                	or     %edx,%eax
}
  813139:	c9                   	leaveq 
  81313a:	c3                   	retq   

000000000081313b <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  81313b:	55                   	push   %rbp
  81313c:	48 89 e5             	mov    %rsp,%rbp
  81313f:	48 83 ec 08          	sub    $0x8,%rsp
  813143:	89 f8                	mov    %edi,%eax
  813145:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  return htons(n);
  813149:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  81314d:	89 c7                	mov    %eax,%edi
  81314f:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  813156:	00 00 00 
  813159:	ff d0                	callq  *%rax
}
  81315b:	c9                   	leaveq 
  81315c:	c3                   	retq   

000000000081315d <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  81315d:	55                   	push   %rbp
  81315e:	48 89 e5             	mov    %rsp,%rbp
  813161:	48 83 ec 08          	sub    $0x8,%rsp
  813165:	89 7d fc             	mov    %edi,-0x4(%rbp)
  return ((n & 0xff) << 24) |
  813168:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81316b:	c1 e0 18             	shl    $0x18,%eax
  81316e:	89 c2                	mov    %eax,%edx
    ((n & 0xff00) << 8) |
  813170:	8b 45 fc             	mov    -0x4(%rbp),%eax
  813173:	25 00 ff 00 00       	and    $0xff00,%eax
  813178:	c1 e0 08             	shl    $0x8,%eax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  81317b:	09 c2                	or     %eax,%edx
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
  81317d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  813180:	25 00 00 ff 00       	and    $0xff0000,%eax
  813185:	48 c1 e8 08          	shr    $0x8,%rax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  813189:	09 c2                	or     %eax,%edx
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  81318b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81318e:	c1 e8 18             	shr    $0x18,%eax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  813191:	09 d0                	or     %edx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  813193:	c9                   	leaveq 
  813194:	c3                   	retq   

0000000000813195 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  813195:	55                   	push   %rbp
  813196:	48 89 e5             	mov    %rsp,%rbp
  813199:	48 83 ec 08          	sub    $0x8,%rsp
  81319d:	89 7d fc             	mov    %edi,-0x4(%rbp)
  return htonl(n);
  8131a0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8131a3:	89 c7                	mov    %eax,%edi
  8131a5:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  8131ac:	00 00 00 
  8131af:	ff d0                	callq  *%rax
}
  8131b1:	c9                   	leaveq 
  8131b2:	c3                   	retq   

00000000008131b3 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  8131b3:	55                   	push   %rbp
  8131b4:	48 89 e5             	mov    %rsp,%rbp
  8131b7:	48 83 ec 10          	sub    $0x10,%rsp
  8131bb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8131bf:	89 f0                	mov    %esi,%eax
  8131c1:	88 45 f4             	mov    %al,-0xc(%rbp)
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  8131c4:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  8131c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8131cc:	48 83 ec 08          	sub    $0x8,%rsp
  8131d0:	6a 00                	pushq  $0x0
  8131d2:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8131d8:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8131de:	89 d1                	mov    %edx,%ecx
  8131e0:	ba 00 00 00 00       	mov    $0x0,%edx
  8131e5:	be 00 00 00 00       	mov    $0x0,%esi
  8131ea:	48 89 c7             	mov    %rax,%rdi
  8131ed:	48 b8 96 32 81 00 00 	movabs $0x813296,%rax
  8131f4:	00 00 00 
  8131f7:	ff d0                	callq  *%rax
  8131f9:	48 83 c4 10          	add    $0x10,%rsp
}
  8131fd:	c9                   	leaveq 
  8131fe:	c3                   	retq   

00000000008131ff <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  8131ff:	55                   	push   %rbp
  813200:	48 89 e5             	mov    %rsp,%rbp
  813203:	48 83 ec 20          	sub    $0x20,%rsp
  813207:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81320b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  81320f:	89 c8                	mov    %ecx,%eax
  813211:	66 89 55 ec          	mov    %dx,-0x14(%rbp)
  813215:	88 45 e8             	mov    %al,-0x18(%rbp)
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  813218:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81321c:	8b 40 18             	mov    0x18(%rax),%eax
  81321f:	83 f8 04             	cmp    $0x4,%eax
  813222:	74 24                	je     813248 <tcp_write+0x49>
     pcb->state == CLOSE_WAIT ||
  813224:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813228:	8b 40 18             	mov    0x18(%rax),%eax
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  81322b:	83 f8 07             	cmp    $0x7,%eax
  81322e:	74 18                	je     813248 <tcp_write+0x49>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
  813230:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813234:	8b 40 18             	mov    0x18(%rax),%eax
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
  813237:	83 f8 02             	cmp    $0x2,%eax
  81323a:	74 0c                	je     813248 <tcp_write+0x49>
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
  81323c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  813240:	8b 40 18             	mov    0x18(%rax),%eax
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
  813243:	83 f8 03             	cmp    $0x3,%eax
  813246:	75 47                	jne    81328f <tcp_write+0x90>
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  813248:	66 83 7d ec 00       	cmpw   $0x0,-0x14(%rbp)
  81324d:	74 39                	je     813288 <tcp_write+0x89>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  81324f:	0f b6 4d e8          	movzbl -0x18(%rbp),%ecx
  813253:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  813257:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  81325b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81325f:	48 83 ec 08          	sub    $0x8,%rsp
  813263:	6a 00                	pushq  $0x0
  813265:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  81326b:	41 89 c8             	mov    %ecx,%r8d
  81326e:	b9 00 00 00 00       	mov    $0x0,%ecx
  813273:	48 89 c7             	mov    %rax,%rdi
  813276:	48 b8 96 32 81 00 00 	movabs $0x813296,%rax
  81327d:	00 00 00 
  813280:	ff d0                	callq  *%rax
  813282:	48 83 c4 10          	add    $0x10,%rsp
  813286:	eb 0c                	jmp    813294 <tcp_write+0x95>
    }
    return ERR_OK;
  813288:	b8 00 00 00 00       	mov    $0x0,%eax
  81328d:	eb 05                	jmp    813294 <tcp_write+0x95>
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  81328f:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  }
}
  813294:	c9                   	leaveq 
  813295:	c3                   	retq   

0000000000813296 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  813296:	55                   	push   %rbp
  813297:	48 89 e5             	mov    %rsp,%rbp
  81329a:	41 54                	push   %r12
  81329c:	53                   	push   %rbx
  81329d:	48 83 ec 70          	sub    $0x70,%rsp
  8132a1:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8132a5:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8132a9:	89 d6                	mov    %edx,%esi
  8132ab:	89 ca                	mov    %ecx,%edx
  8132ad:	44 89 c1             	mov    %r8d,%ecx
  8132b0:	4c 89 4d 88          	mov    %r9,-0x78(%rbp)
  8132b4:	8b 45 10             	mov    0x10(%rbp),%eax
  8132b7:	66 89 75 9c          	mov    %si,-0x64(%rbp)
  8132bb:	88 55 98             	mov    %dl,-0x68(%rbp)
  8132be:	88 4d 94             	mov    %cl,-0x6c(%rbp)
  8132c1:	88 45 90             	mov    %al,-0x70(%rbp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  8132c4:	66 83 7d 9c 00       	cmpw   $0x0,-0x64(%rbp)
  8132c9:	74 30                	je     8132fb <tcp_enqueue+0x65>
  8132cb:	80 7d 90 00          	cmpb   $0x0,-0x70(%rbp)
  8132cf:	74 2a                	je     8132fb <tcp_enqueue+0x65>
  8132d1:	48 ba c8 2a 82 00 00 	movabs $0x822ac8,%rdx
  8132d8:	00 00 00 
  8132db:	be 91 00 00 00       	mov    $0x91,%esi
  8132e0:	48 bf 07 2b 82 00 00 	movabs $0x822b07,%rdi
  8132e7:	00 00 00 
  8132ea:	b8 00 00 00 00       	mov    $0x0,%eax
  8132ef:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8132f6:	00 00 00 
  8132f9:	ff d1                	callq  *%rcx
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  8132fb:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  813300:	74 31                	je     813333 <tcp_enqueue+0x9d>
  813302:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  813307:	74 2a                	je     813333 <tcp_enqueue+0x9d>
  813309:	48 ba 20 2b 82 00 00 	movabs $0x822b20,%rdx
  813310:	00 00 00 
  813313:	be 93 00 00 00       	mov    $0x93,%esi
  813318:	48 bf 07 2b 82 00 00 	movabs $0x822b07,%rdi
  81331f:	00 00 00 
  813322:	b8 00 00 00 00       	mov    $0x0,%eax
  813327:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81332e:	00 00 00 
  813331:	ff d1                	callq  *%rcx
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  813333:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813337:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81333b:	66 3b 45 9c          	cmp    -0x64(%rbp),%ax
  81333f:	73 1e                	jae    81335f <tcp_enqueue+0xc9>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  813341:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813345:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813349:	83 c8 80             	or     $0xffffff80,%eax
  81334c:	89 c2                	mov    %eax,%edx
  81334e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813352:	88 50 2c             	mov    %dl,0x2c(%rax)
    return ERR_MEM;
  813355:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81335a:	e9 fc 09 00 00       	jmpq   813d5b <tcp_enqueue+0xac5>
  }
  left = len;
  81335f:	0f b7 45 9c          	movzwl -0x64(%rbp),%eax
  813363:	66 89 45 d2          	mov    %ax,-0x2e(%rbp)
  ptr = arg;
  813367:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  81336b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  81336f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813373:	8b 40 74             	mov    0x74(%rax),%eax
  813376:	89 45 d4             	mov    %eax,-0x2c(%rbp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  813379:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81337d:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  813381:	66 89 45 c6          	mov    %ax,-0x3a(%rbp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  813385:	66 83 7d c6 1f       	cmpw   $0x1f,-0x3a(%rbp)
  81338a:	77 07                	ja     813393 <tcp_enqueue+0xfd>
  81338c:	66 83 7d c6 fc       	cmpw   $0xfffc,-0x3a(%rbp)
  813391:	76 1e                	jbe    8133b1 <tcp_enqueue+0x11b>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  813393:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813397:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81339b:	83 c8 80             	or     $0xffffff80,%eax
  81339e:	89 c2                	mov    %eax,%edx
  8133a0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8133a4:	88 50 2c             	mov    %dl,0x2c(%rax)
    return ERR_MEM;
  8133a7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8133ac:	e9 aa 09 00 00       	jmpq   813d5b <tcp_enqueue+0xac5>
  }
  if (queuelen != 0) {
  8133b1:	66 83 7d c6 00       	cmpw   $0x0,-0x3a(%rbp)
  8133b6:	74 4e                	je     813406 <tcp_enqueue+0x170>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  8133b8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8133bc:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8133c3:	48 85 c0             	test   %rax,%rax
  8133c6:	0f 85 84 00 00 00    	jne    813450 <tcp_enqueue+0x1ba>
  8133cc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8133d0:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8133d7:	48 85 c0             	test   %rax,%rax
  8133da:	75 74                	jne    813450 <tcp_enqueue+0x1ba>
  8133dc:	48 ba 68 2b 82 00 00 	movabs $0x822b68,%rdx
  8133e3:	00 00 00 
  8133e6:	be af 00 00 00       	mov    $0xaf,%esi
  8133eb:	48 bf 07 2b 82 00 00 	movabs $0x822b07,%rdi
  8133f2:	00 00 00 
  8133f5:	b8 00 00 00 00       	mov    $0x0,%eax
  8133fa:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  813401:	00 00 00 
  813404:	ff d1                	callq  *%rcx
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  813406:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81340a:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813411:	48 85 c0             	test   %rax,%rax
  813414:	75 10                	jne    813426 <tcp_enqueue+0x190>
  813416:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81341a:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813421:	48 85 c0             	test   %rax,%rax
  813424:	74 2a                	je     813450 <tcp_enqueue+0x1ba>
  813426:	48 ba a8 2b 82 00 00 	movabs $0x822ba8,%rdx
  81342d:	00 00 00 
  813430:	be b2 00 00 00       	mov    $0xb2,%esi
  813435:	48 bf 07 2b 82 00 00 	movabs $0x822b07,%rdi
  81343c:	00 00 00 
  81343f:	b8 00 00 00 00       	mov    $0x0,%eax
  813444:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81344b:	00 00 00 
  81344e:	ff d1                	callq  *%rcx
      pcb->unacked == NULL && pcb->unsent == NULL);
  }

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  813450:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  813457:	00 
  813458:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81345c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  813460:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813464:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  seglen = 0;
  813468:	66 c7 45 d0 00 00    	movw   $0x0,-0x30(%rbp)
  while (queue == NULL || left > 0) {
  81346e:	e9 00 05 00 00       	jmpq   813973 <tcp_enqueue+0x6dd>

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  813473:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813477:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81347b:	0f b7 45 d2          	movzwl -0x2e(%rbp),%eax
  81347f:	66 39 c2             	cmp    %ax,%dx
  813482:	0f 46 c2             	cmovbe %edx,%eax
  813485:	66 89 45 d0          	mov    %ax,-0x30(%rbp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  813489:	bf 04 00 00 00       	mov    $0x4,%edi
  81348e:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  813495:	00 00 00 
  813498:	ff d0                	callq  *%rax
  81349a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (seg == NULL) {
  81349e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8134a3:	0f 84 18 08 00 00    	je     813cc1 <tcp_enqueue+0xa2b>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  8134a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134ad:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    seg->p = NULL;
  8134b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134b8:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8134bf:	00 

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  8134c0:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8134c5:	75 0a                	jne    8134d1 <tcp_enqueue+0x23b>
      queue = seg;
  8134c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134cb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8134cf:	eb 3c                	jmp    81350d <tcp_enqueue+0x277>
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  8134d1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8134d6:	75 2a                	jne    813502 <tcp_enqueue+0x26c>
  8134d8:	48 ba dc 2b 82 00 00 	movabs $0x822bdc,%rdx
  8134df:	00 00 00 
  8134e2:	be cf 00 00 00       	mov    $0xcf,%esi
  8134e7:	48 bf 07 2b 82 00 00 	movabs $0x822b07,%rdi
  8134ee:	00 00 00 
  8134f1:	b8 00 00 00 00       	mov    $0x0,%eax
  8134f6:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8134fd:	00 00 00 
  813500:	ff d1                	callq  *%rcx
      useg->next = seg;
  813502:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813506:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81350a:	48 89 10             	mov    %rdx,(%rax)
    }
    /* remember last segment of to-be-queued data for next iteration */
    useg = seg;
  81350d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813511:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  813515:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  81351a:	0f 84 ae 00 00 00    	je     8135ce <tcp_enqueue+0x338>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  813520:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  813524:	ba 00 00 00 00       	mov    $0x0,%edx
  813529:	89 c6                	mov    %eax,%esi
  81352b:	bf 00 00 00 00       	mov    $0x0,%edi
  813530:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  813537:	00 00 00 
  81353a:	ff d0                	callq  *%rax
  81353c:	48 89 c2             	mov    %rax,%rdx
  81353f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813543:	48 89 50 08          	mov    %rdx,0x8(%rax)
  813547:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81354b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81354f:	48 85 c0             	test   %rax,%rax
  813552:	0f 84 6c 07 00 00    	je     813cc4 <tcp_enqueue+0xa2e>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  813558:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81355c:	48 8b 40 08          	mov    0x8(%rax),%rax
  813560:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  813564:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  813568:	66 39 c2             	cmp    %ax,%dx
  81356b:	73 2a                	jae    813597 <tcp_enqueue+0x301>
  81356d:	48 ba f0 2b 82 00 00 	movabs $0x822bf0,%rdx
  813574:	00 00 00 
  813577:	be e0 00 00 00       	mov    $0xe0,%esi
  81357c:	48 bf 07 2b 82 00 00 	movabs $0x822b07,%rdi
  813583:	00 00 00 
  813586:	b8 00 00 00 00       	mov    $0x0,%eax
  81358b:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  813592:	00 00 00 
  813595:	ff d1                	callq  *%rcx
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  813597:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81359b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81359f:	48 89 c7             	mov    %rax,%rdi
  8135a2:	48 b8 7d df 80 00 00 	movabs $0x80df7d,%rax
  8135a9:	00 00 00 
  8135ac:	ff d0                	callq  *%rax
  8135ae:	0f b6 c0             	movzbl %al,%eax
  8135b1:	66 01 45 c6          	add    %ax,-0x3a(%rbp)
      seg->dataptr = seg->p->payload;
  8135b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8135b9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8135bd:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8135c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8135c5:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8135c9:	e9 be 01 00 00       	jmpq   81378c <tcp_enqueue+0x4f6>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  8135ce:	0f b6 45 94          	movzbl -0x6c(%rbp),%eax
  8135d2:	83 e0 01             	and    $0x1,%eax
  8135d5:	85 c0                	test   %eax,%eax
  8135d7:	0f 84 d8 00 00 00    	je     8136b5 <tcp_enqueue+0x41f>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  8135dd:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8135e1:	ba 00 00 00 00       	mov    $0x0,%edx
  8135e6:	89 c6                	mov    %eax,%esi
  8135e8:	bf 00 00 00 00       	mov    $0x0,%edi
  8135ed:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  8135f4:	00 00 00 
  8135f7:	ff d0                	callq  *%rax
  8135f9:	48 89 c2             	mov    %rax,%rdx
  8135fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813600:	48 89 50 08          	mov    %rdx,0x8(%rax)
  813604:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813608:	48 8b 40 08          	mov    0x8(%rax),%rax
  81360c:	48 85 c0             	test   %rax,%rax
  81360f:	0f 84 b2 06 00 00    	je     813cc7 <tcp_enqueue+0xa31>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  813615:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813619:	48 8b 40 08          	mov    0x8(%rax),%rax
  81361d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  813621:	66 3b 45 d0          	cmp    -0x30(%rbp),%ax
  813625:	73 2a                	jae    813651 <tcp_enqueue+0x3bb>
  813627:	48 ba 18 2c 82 00 00 	movabs $0x822c18,%rdx
  81362e:	00 00 00 
  813631:	be eb 00 00 00       	mov    $0xeb,%esi
  813636:	48 bf 07 2b 82 00 00 	movabs $0x822b07,%rdi
  81363d:	00 00 00 
  813640:	b8 00 00 00 00       	mov    $0x0,%eax
  813645:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81364c:	00 00 00 
  81364f:	ff d1                	callq  *%rcx
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  813651:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813655:	48 8b 40 08          	mov    0x8(%rax),%rax
  813659:	48 89 c7             	mov    %rax,%rdi
  81365c:	48 b8 7d df 80 00 00 	movabs $0x80df7d,%rax
  813663:	00 00 00 
  813666:	ff d0                	callq  *%rax
  813668:	0f b6 c0             	movzbl %al,%eax
  81366b:	66 01 45 c6          	add    %ax,-0x3a(%rbp)
      if (arg != NULL) {
  81366f:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  813674:	74 26                	je     81369c <tcp_enqueue+0x406>
        MEMCPY(seg->p->payload, ptr, seglen);
  813676:	0f b7 55 d0          	movzwl -0x30(%rbp),%edx
  81367a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81367e:	48 8b 40 08          	mov    0x8(%rax),%rax
  813682:	48 8b 40 08          	mov    0x8(%rax),%rax
  813686:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  81368a:	48 89 ce             	mov    %rcx,%rsi
  81368d:	48 89 c7             	mov    %rax,%rdi
  813690:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  813697:	00 00 00 
  81369a:	ff d0                	callq  *%rax
      }
      seg->dataptr = seg->p->payload;
  81369c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8136a0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8136a4:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8136a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8136ac:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8136b0:	e9 d7 00 00 00       	jmpq   81378c <tcp_enqueue+0x4f6>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  8136b5:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8136b9:	ba 01 00 00 00       	mov    $0x1,%edx
  8136be:	89 c6                	mov    %eax,%esi
  8136c0:	bf 00 00 00 00       	mov    $0x0,%edi
  8136c5:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  8136cc:	00 00 00 
  8136cf:	ff d0                	callq  *%rax
  8136d1:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8136d5:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8136da:	0f 84 ea 05 00 00    	je     813cca <tcp_enqueue+0xa34>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
  8136e0:	66 83 45 c6 01       	addw   $0x1,-0x3a(%rbp)
      /* reference the non-volatile payload data */
      p->payload = ptr;
  8136e5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8136e9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8136ed:	48 89 50 08          	mov    %rdx,0x8(%rax)
      seg->dataptr = ptr;
  8136f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8136f5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8136f9:	48 89 50 10          	mov    %rdx,0x10(%rax)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  8136fd:	ba 00 00 00 00       	mov    $0x0,%edx
  813702:	be 00 00 00 00       	mov    $0x0,%esi
  813707:	bf 00 00 00 00       	mov    $0x0,%edi
  81370c:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  813713:	00 00 00 
  813716:	ff d0                	callq  *%rax
  813718:	48 89 c2             	mov    %rax,%rdx
  81371b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81371f:	48 89 50 08          	mov    %rdx,0x8(%rax)
  813723:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813727:	48 8b 40 08          	mov    0x8(%rax),%rax
  81372b:	48 85 c0             	test   %rax,%rax
  81372e:	75 18                	jne    813748 <tcp_enqueue+0x4b2>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  813730:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813734:	48 89 c7             	mov    %rax,%rdi
  813737:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81373e:	00 00 00 
  813741:	ff d0                	callq  *%rax
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  813743:	e9 89 05 00 00       	jmpq   813cd1 <tcp_enqueue+0xa3b>
      }
      queuelen += pbuf_clen(seg->p);
  813748:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81374c:	48 8b 40 08          	mov    0x8(%rax),%rax
  813750:	48 89 c7             	mov    %rax,%rdi
  813753:	48 b8 7d df 80 00 00 	movabs $0x80df7d,%rax
  81375a:	00 00 00 
  81375d:	ff d0                	callq  *%rax
  81375f:	0f b6 c0             	movzbl %al,%eax
  813762:	66 01 45 c6          	add    %ax,-0x3a(%rbp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  813766:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81376a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81376e:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  813772:	48 89 d6             	mov    %rdx,%rsi
  813775:	48 89 c7             	mov    %rax,%rdi
  813778:	48 b8 d4 df 80 00 00 	movabs $0x80dfd4,%rax
  81377f:	00 00 00 
  813782:	ff d0                	callq  *%rax
      p = NULL;
  813784:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  81378b:	00 
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  81378c:	66 83 7d c6 20       	cmpw   $0x20,-0x3a(%rbp)
  813791:	0f 87 36 05 00 00    	ja     813ccd <tcp_enqueue+0xa37>
  813797:	66 83 7d c6 fc       	cmpw   $0xfffc,-0x3a(%rbp)
  81379c:	0f 87 2b 05 00 00    	ja     813ccd <tcp_enqueue+0xa37>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  8137a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8137a6:	0f b7 55 d0          	movzwl -0x30(%rbp),%edx
  8137aa:	66 89 50 18          	mov    %dx,0x18(%rax)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  8137ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8137b2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8137b6:	be 14 00 00 00       	mov    $0x14,%esi
  8137bb:	48 89 c7             	mov    %rax,%rdi
  8137be:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  8137c5:	00 00 00 
  8137c8:	ff d0                	callq  *%rax
  8137ca:	84 c0                	test   %al,%al
  8137cc:	0f 85 fe 04 00 00    	jne    813cd0 <tcp_enqueue+0xa3a>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  8137d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8137d6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8137da:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8137de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8137e2:	48 89 50 20          	mov    %rdx,0x20(%rax)
    seg->tcphdr->src = htons(pcb->local_port);
  8137e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8137ea:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8137ee:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8137f2:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  8137f6:	0f b7 c0             	movzwl %ax,%eax
  8137f9:	89 c7                	mov    %eax,%edi
  8137fb:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  813802:	00 00 00 
  813805:	ff d0                	callq  *%rax
  813807:	66 89 03             	mov    %ax,(%rbx)
    seg->tcphdr->dest = htons(pcb->remote_port);
  81380a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81380e:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813812:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813816:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  81381a:	0f b7 c0             	movzwl %ax,%eax
  81381d:	89 c7                	mov    %eax,%edi
  81381f:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  813826:	00 00 00 
  813829:	ff d0                	callq  *%rax
  81382b:	66 89 43 02          	mov    %ax,0x2(%rbx)
    seg->tcphdr->seqno = htonl(seqno);
  81382f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813833:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813837:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  81383a:	89 c7                	mov    %eax,%edi
  81383c:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  813843:	00 00 00 
  813846:	ff d0                	callq  *%rax
  813848:	89 43 04             	mov    %eax,0x4(%rbx)
    seg->tcphdr->urgp = 0;
  81384b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81384f:	48 8b 40 20          	mov    0x20(%rax),%rax
  813853:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  813859:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81385d:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813861:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813865:	48 8b 40 20          	mov    0x20(%rax),%rax
  813869:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81386d:	0f b7 c0             	movzwl %ax,%eax
  813870:	89 c7                	mov    %eax,%edi
  813872:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  813879:	00 00 00 
  81387c:	ff d0                	callq  *%rax
  81387e:	83 e0 c0             	and    $0xffffffc0,%eax
  813881:	89 c2                	mov    %eax,%edx
  813883:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  813887:	09 d0                	or     %edx,%eax
  813889:	0f b7 c0             	movzwl %ax,%eax
  81388c:	89 c7                	mov    %eax,%edi
  81388e:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  813895:	00 00 00 
  813898:	ff d0                	callq  *%rax
  81389a:	66 89 43 0c          	mov    %ax,0xc(%rbx)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  81389e:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  8138a3:	75 42                	jne    8138e7 <tcp_enqueue+0x651>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  8138a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8138a9:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8138ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8138b1:	48 8b 40 20          	mov    0x20(%rax),%rax
  8138b5:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8138b9:	0f b7 c0             	movzwl %ax,%eax
  8138bc:	89 c7                	mov    %eax,%edi
  8138be:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  8138c5:	00 00 00 
  8138c8:	ff d0                	callq  *%rax
  8138ca:	83 e0 3f             	and    $0x3f,%eax
  8138cd:	80 cc 50             	or     $0x50,%ah
  8138d0:	0f b7 c0             	movzwl %ax,%eax
  8138d3:	89 c7                	mov    %eax,%edi
  8138d5:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8138dc:	00 00 00 
  8138df:	ff d0                	callq  *%rax
  8138e1:	66 89 43 0c          	mov    %ax,0xc(%rbx)
  8138e5:	eb 75                	jmp    81395c <tcp_enqueue+0x6c6>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  8138e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8138eb:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8138ef:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  8138f3:	c0 e8 02             	shr    $0x2,%al
  8138f6:	0f b6 c0             	movzbl %al,%eax
  8138f9:	83 c0 05             	add    $0x5,%eax
  8138fc:	c1 e0 0c             	shl    $0xc,%eax
  8138ff:	41 89 c4             	mov    %eax,%r12d
  813902:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813906:	48 8b 40 20          	mov    0x20(%rax),%rax
  81390a:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81390e:	0f b7 c0             	movzwl %ax,%eax
  813911:	89 c7                	mov    %eax,%edi
  813913:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81391a:	00 00 00 
  81391d:	ff d0                	callq  *%rax
  81391f:	83 e0 3f             	and    $0x3f,%eax
  813922:	44 09 e0             	or     %r12d,%eax
  813925:	0f b7 c0             	movzwl %ax,%eax
  813928:	89 c7                	mov    %eax,%edi
  81392a:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  813931:	00 00 00 
  813934:	ff d0                	callq  *%rax
  813936:	66 89 43 0c          	mov    %ax,0xc(%rbx)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  81393a:	0f b6 55 90          	movzbl -0x70(%rbp),%edx
  81393e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813942:	48 8b 40 10          	mov    0x10(%rax),%rax
  813946:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
  81394a:	48 89 ce             	mov    %rcx,%rsi
  81394d:	48 89 c7             	mov    %rax,%rdi
  813950:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  813957:	00 00 00 
  81395a:	ff d0                	callq  *%rax
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  81395c:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  813960:	66 29 45 d2          	sub    %ax,-0x2e(%rbp)
    seqno += seglen;
  813964:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  813968:	01 45 d4             	add    %eax,-0x2c(%rbp)
    ptr = (void *)((u8_t *)ptr + seglen);
  81396b:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  81396f:	48 01 45 c8          	add    %rax,-0x38(%rbp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  813973:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  813978:	0f 84 f5 fa ff ff    	je     813473 <tcp_enqueue+0x1dd>
  81397e:	66 83 7d d2 00       	cmpw   $0x0,-0x2e(%rbp)
  813983:	0f 85 ea fa ff ff    	jne    813473 <tcp_enqueue+0x1dd>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  813989:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81398d:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813994:	48 85 c0             	test   %rax,%rax
  813997:	75 0a                	jne    8139a3 <tcp_enqueue+0x70d>
    useg = NULL;
  813999:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8139a0:	00 
  8139a1:	eb 28                	jmp    8139cb <tcp_enqueue+0x735>
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  8139a3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8139a7:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8139ae:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8139b2:	eb 0b                	jmp    8139bf <tcp_enqueue+0x729>
  8139b4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8139b8:	48 8b 00             	mov    (%rax),%rax
  8139bb:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8139bf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8139c3:	48 8b 00             	mov    (%rax),%rax
  8139c6:	48 85 c0             	test   %rax,%rax
  8139c9:	75 e9                	jne    8139b4 <tcp_enqueue+0x71e>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  8139cb:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8139d0:	0f 84 94 01 00 00    	je     813b6a <tcp_enqueue+0x8d4>
    TCP_TCPLEN(useg) != 0 &&
  8139d6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8139da:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8139de:	0f b7 d8             	movzwl %ax,%ebx
  8139e1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8139e5:	48 8b 40 20          	mov    0x20(%rax),%rax
  8139e9:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8139ed:	0f b7 c0             	movzwl %ax,%eax
  8139f0:	89 c7                	mov    %eax,%edi
  8139f2:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  8139f9:	00 00 00 
  8139fc:	ff d0                	callq  *%rax
  8139fe:	0f b7 c0             	movzwl %ax,%eax
  813a01:	83 e0 01             	and    $0x1,%eax
  813a04:	85 c0                	test   %eax,%eax
  813a06:	75 27                	jne    813a2f <tcp_enqueue+0x799>
  813a08:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813a0c:	48 8b 40 20          	mov    0x20(%rax),%rax
  813a10:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813a14:	0f b7 c0             	movzwl %ax,%eax
  813a17:	89 c7                	mov    %eax,%edi
  813a19:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  813a20:	00 00 00 
  813a23:	ff d0                	callq  *%rax
  813a25:	0f b7 c0             	movzwl %ax,%eax
  813a28:	83 e0 02             	and    $0x2,%eax
  813a2b:	85 c0                	test   %eax,%eax
  813a2d:	74 07                	je     813a36 <tcp_enqueue+0x7a0>
  813a2f:	b8 01 00 00 00       	mov    $0x1,%eax
  813a34:	eb 05                	jmp    813a3b <tcp_enqueue+0x7a5>
  813a36:	b8 00 00 00 00       	mov    $0x0,%eax
  813a3b:	01 d8                	add    %ebx,%eax
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  813a3d:	85 c0                	test   %eax,%eax
  813a3f:	0f 84 25 01 00 00    	je     813b6a <tcp_enqueue+0x8d4>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  813a45:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813a49:	48 8b 40 20          	mov    0x20(%rax),%rax
  813a4d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813a51:	0f b7 c0             	movzwl %ax,%eax
  813a54:	89 c7                	mov    %eax,%edi
  813a56:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  813a5d:	00 00 00 
  813a60:	ff d0                	callq  *%rax
  813a62:	0f b7 c0             	movzwl %ax,%eax
  813a65:	83 e0 03             	and    $0x3,%eax
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  813a68:	85 c0                	test   %eax,%eax
  813a6a:	0f 85 fa 00 00 00    	jne    813b6a <tcp_enqueue+0x8d4>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  813a70:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  813a74:	83 e0 03             	and    $0x3,%eax

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  813a77:	85 c0                	test   %eax,%eax
  813a79:	0f 85 eb 00 00 00    	jne    813b6a <tcp_enqueue+0x8d4>
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  813a7f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813a83:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813a87:	0f b7 d0             	movzwl %ax,%edx
  813a8a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813a8e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813a92:	0f b7 c0             	movzwl %ax,%eax
  813a95:	01 c2                	add    %eax,%edx
  813a97:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813a9b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  813a9f:	0f b7 c0             	movzwl %ax,%eax
  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  813aa2:	39 c2                	cmp    %eax,%edx
  813aa4:	0f 8f c0 00 00 00    	jg     813b6a <tcp_enqueue+0x8d4>
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  813aaa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813aae:	48 8b 40 08          	mov    0x8(%rax),%rax
  813ab2:	be ec ff ff ff       	mov    $0xffffffec,%esi
  813ab7:	48 89 c7             	mov    %rax,%rdi
  813aba:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  813ac1:	00 00 00 
  813ac4:	ff d0                	callq  *%rax
  813ac6:	84 c0                	test   %al,%al
  813ac8:	74 2a                	je     813af4 <tcp_enqueue+0x85e>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  813aca:	48 ba 4b 2c 82 00 00 	movabs $0x822c4b,%rdx
  813ad1:	00 00 00 
  813ad4:	be 53 01 00 00       	mov    $0x153,%esi
  813ad9:	48 bf 07 2b 82 00 00 	movabs $0x822b07,%rdi
  813ae0:	00 00 00 
  813ae3:	b8 00 00 00 00       	mov    $0x0,%eax
  813ae8:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  813aef:	00 00 00 
  813af2:	ff d1                	callq  *%rcx
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  813af4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813af8:	48 8b 50 08          	mov    0x8(%rax),%rdx
  813afc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813b00:	48 8b 40 08          	mov    0x8(%rax),%rax
  813b04:	48 89 d6             	mov    %rdx,%rsi
  813b07:	48 89 c7             	mov    %rax,%rdi
  813b0a:	48 b8 d4 df 80 00 00 	movabs $0x80dfd4,%rax
  813b11:	00 00 00 
  813b14:	ff d0                	callq  *%rax
    useg->len += queue->len;
  813b16:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813b1a:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  813b1e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813b22:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813b26:	01 c2                	add    %eax,%edx
  813b28:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813b2c:	66 89 50 18          	mov    %dx,0x18(%rax)
    useg->next = queue->next;
  813b30:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813b34:	48 8b 10             	mov    (%rax),%rdx
  813b37:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813b3b:	48 89 10             	mov    %rdx,(%rax)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  813b3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813b42:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  813b46:	75 08                	jne    813b50 <tcp_enqueue+0x8ba>
      seg = NULL;
  813b48:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  813b4f:	00 
    }
    memp_free(MEMP_TCP_SEG, queue);
  813b50:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813b54:	48 89 c6             	mov    %rax,%rsi
  813b57:	bf 04 00 00 00       	mov    $0x4,%edi
  813b5c:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  813b63:	00 00 00 
  813b66:	ff d0                	callq  *%rax
  813b68:	eb 23                	jmp    813b8d <tcp_enqueue+0x8f7>
  }
  else {
    /* empty list */
    if (useg == NULL) {
  813b6a:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  813b6f:	75 11                	jne    813b82 <tcp_enqueue+0x8ec>
      /* initialize list with this segment */
      pcb->unsent = queue;
  813b71:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813b75:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  813b79:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  813b80:	eb 0b                	jmp    813b8d <tcp_enqueue+0x8f7>
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  813b82:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813b86:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  813b8a:	48 89 10             	mov    %rdx,(%rax)
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  813b8d:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  813b91:	83 e0 02             	and    $0x2,%eax
  813b94:	85 c0                	test   %eax,%eax
  813b96:	75 0b                	jne    813ba3 <tcp_enqueue+0x90d>
  813b98:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  813b9c:	83 e0 01             	and    $0x1,%eax
  813b9f:	85 c0                	test   %eax,%eax
  813ba1:	74 05                	je     813ba8 <tcp_enqueue+0x912>
    ++len;
  813ba3:	66 83 45 9c 01       	addw   $0x1,-0x64(%rbp)
  }
  if (flags & TCP_FIN) {
  813ba8:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  813bac:	83 e0 01             	and    $0x1,%eax
  813baf:	85 c0                	test   %eax,%eax
  813bb1:	74 14                	je     813bc7 <tcp_enqueue+0x931>
    pcb->flags |= TF_FIN;
  813bb3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813bb7:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813bbb:	83 c8 20             	or     $0x20,%eax
  813bbe:	89 c2                	mov    %eax,%edx
  813bc0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813bc4:	88 50 2c             	mov    %dl,0x2c(%rax)
  }
  pcb->snd_lbb += len;
  813bc7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813bcb:	8b 50 74             	mov    0x74(%rax),%edx
  813bce:	0f b7 45 9c          	movzwl -0x64(%rbp),%eax
  813bd2:	01 c2                	add    %eax,%edx
  813bd4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813bd8:	89 50 74             	mov    %edx,0x74(%rax)

  pcb->snd_buf -= len;
  813bdb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813bdf:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  813be3:	66 2b 45 9c          	sub    -0x64(%rbp),%ax
  813be7:	89 c2                	mov    %eax,%edx
  813be9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813bed:	66 89 50 7a          	mov    %dx,0x7a(%rax)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  813bf1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813bf5:	0f b7 55 c6          	movzwl -0x3a(%rbp),%edx
  813bf9:	66 89 50 7c          	mov    %dx,0x7c(%rax)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  813bfd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813c01:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  813c05:	66 85 c0             	test   %ax,%ax
  813c08:	74 4a                	je     813c54 <tcp_enqueue+0x9be>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  813c0a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813c0e:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813c15:	48 85 c0             	test   %rax,%rax
  813c18:	75 3a                	jne    813c54 <tcp_enqueue+0x9be>
  813c1a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813c1e:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813c25:	48 85 c0             	test   %rax,%rax
  813c28:	75 2a                	jne    813c54 <tcp_enqueue+0x9be>
  813c2a:	48 ba 60 2c 82 00 00 	movabs $0x822c60,%rdx
  813c31:	00 00 00 
  813c34:	be 7b 01 00 00       	mov    $0x17b,%esi
  813c39:	48 bf 07 2b 82 00 00 	movabs $0x822b07,%rdi
  813c40:	00 00 00 
  813c43:	b8 00 00 00 00       	mov    $0x0,%eax
  813c48:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  813c4f:	00 00 00 
  813c52:	ff d1                	callq  *%rcx
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  813c54:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813c59:	74 5c                	je     813cb7 <tcp_enqueue+0xa21>
  813c5b:	66 83 7d d0 00       	cmpw   $0x0,-0x30(%rbp)
  813c60:	74 55                	je     813cb7 <tcp_enqueue+0xa21>
  813c62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c66:	48 8b 40 20          	mov    0x20(%rax),%rax
  813c6a:	48 85 c0             	test   %rax,%rax
  813c6d:	74 48                	je     813cb7 <tcp_enqueue+0xa21>
  813c6f:	0f b6 45 94          	movzbl -0x6c(%rbp),%eax
  813c73:	83 e0 02             	and    $0x2,%eax
  813c76:	85 c0                	test   %eax,%eax
  813c78:	75 3d                	jne    813cb7 <tcp_enqueue+0xa21>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  813c7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c7e:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813c82:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c86:	48 8b 40 20          	mov    0x20(%rax),%rax
  813c8a:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813c8e:	0f b7 c0             	movzwl %ax,%eax
  813c91:	89 c7                	mov    %eax,%edi
  813c93:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  813c9a:	00 00 00 
  813c9d:	ff d0                	callq  *%rax
  813c9f:	83 c8 08             	or     $0x8,%eax
  813ca2:	0f b7 c0             	movzwl %ax,%eax
  813ca5:	89 c7                	mov    %eax,%edi
  813ca7:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  813cae:	00 00 00 
  813cb1:	ff d0                	callq  *%rax
  813cb3:	66 89 43 0c          	mov    %ax,0xc(%rbx)
  }

  return ERR_OK;
  813cb7:	b8 00 00 00 00       	mov    $0x0,%eax
  813cbc:	e9 9a 00 00 00       	jmpq   813d5b <tcp_enqueue+0xac5>

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
    if (seg == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
  813cc1:	90                   	nop
  813cc2:	eb 0d                	jmp    813cd1 <tcp_enqueue+0xa3b>
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
        goto memerr;
  813cc4:	90                   	nop
  813cc5:	eb 0a                	jmp    813cd1 <tcp_enqueue+0xa3b>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
  813cc7:	90                   	nop
  813cc8:	eb 07                	jmp    813cd1 <tcp_enqueue+0xa3b>
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
  813cca:	90                   	nop
  813ccb:	eb 04                	jmp    813cd1 <tcp_enqueue+0xa3b>

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
  813ccd:	90                   	nop
  813cce:	eb 01                	jmp    813cd1 <tcp_enqueue+0xa3b>

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
  813cd0:	90                   	nop
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  813cd1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813cd5:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813cd9:	83 c8 80             	or     $0xffffff80,%eax
  813cdc:	89 c2                	mov    %eax,%edx
  813cde:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813ce2:	88 50 2c             	mov    %dl,0x2c(%rax)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  813ce5:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  813cea:	74 13                	je     813cff <tcp_enqueue+0xa69>
    tcp_segs_free(queue);
  813cec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813cf0:	48 89 c7             	mov    %rax,%rdi
  813cf3:	48 b8 d3 04 81 00 00 	movabs $0x8104d3,%rax
  813cfa:	00 00 00 
  813cfd:	ff d0                	callq  *%rax
  }
  if (pcb->snd_queuelen != 0) {
  813cff:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813d03:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  813d07:	66 85 c0             	test   %ax,%ax
  813d0a:	74 4a                	je     813d56 <tcp_enqueue+0xac0>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  813d0c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813d10:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813d17:	48 85 c0             	test   %rax,%rax
  813d1a:	75 3a                	jne    813d56 <tcp_enqueue+0xac0>
  813d1c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813d20:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813d27:	48 85 c0             	test   %rax,%rax
  813d2a:	75 2a                	jne    813d56 <tcp_enqueue+0xac0>
  813d2c:	48 ba 60 2c 82 00 00 	movabs $0x822c60,%rdx
  813d33:	00 00 00 
  813d36:	be 8e 01 00 00       	mov    $0x18e,%esi
  813d3b:	48 bf 07 2b 82 00 00 	movabs $0x822b07,%rdi
  813d42:	00 00 00 
  813d45:	b8 00 00 00 00       	mov    $0x0,%eax
  813d4a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  813d51:	00 00 00 
  813d54:	ff d1                	callq  *%rcx
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  813d56:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  813d5b:	48 83 c4 70          	add    $0x70,%rsp
  813d5f:	5b                   	pop    %rbx
  813d60:	41 5c                	pop    %r12
  813d62:	5d                   	pop    %rbp
  813d63:	c3                   	retq   

0000000000813d64 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  813d64:	55                   	push   %rbp
  813d65:	48 89 e5             	mov    %rsp,%rbp
  813d68:	41 54                	push   %r12
  813d6a:	53                   	push   %rbx
  813d6b:	48 83 ec 40          	sub    $0x40,%rsp
  813d6f:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  813d73:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  813d7a:	00 00 00 
  813d7d:	48 8b 00             	mov    (%rax),%rax
  813d80:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  813d84:	75 0a                	jne    813d90 <tcp_output+0x2c>
    return ERR_OK;
  813d86:	b8 00 00 00 00       	mov    $0x0,%eax
  813d8b:	e9 cd 06 00 00       	jmpq   81445d <tcp_output+0x6f9>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  813d90:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d94:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  813d98:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d9c:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  813da0:	66 39 c2             	cmp    %ax,%dx
  813da3:	0f 46 c2             	cmovbe %edx,%eax
  813da6:	0f b7 c0             	movzwl %ax,%eax
  813da9:	89 45 dc             	mov    %eax,-0x24(%rbp)

  seg = pcb->unsent;
  813dac:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813db0:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813db7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  813dbb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813dbf:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813dc6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  if (useg != NULL) {
  813dca:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  813dcf:	74 19                	je     813dea <tcp_output+0x86>
    for (; useg->next != NULL; useg = useg->next);
  813dd1:	eb 0b                	jmp    813dde <tcp_output+0x7a>
  813dd3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813dd7:	48 8b 00             	mov    (%rax),%rax
  813dda:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  813dde:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813de2:	48 8b 00             	mov    (%rax),%rax
  813de5:	48 85 c0             	test   %rax,%rax
  813de8:	75 e9                	jne    813dd3 <tcp_output+0x6f>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  813dea:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813dee:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813df2:	0f b6 c0             	movzbl %al,%eax
  813df5:	83 e0 02             	and    $0x2,%eax
  813df8:	85 c0                	test   %eax,%eax
  813dfa:	0f 84 91 05 00 00    	je     814391 <tcp_output+0x62d>
  813e00:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813e05:	74 3a                	je     813e41 <tcp_output+0xdd>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  813e07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813e0b:	48 8b 40 20          	mov    0x20(%rax),%rax
  813e0f:	8b 40 04             	mov    0x4(%rax),%eax
  813e12:	89 c7                	mov    %eax,%edi
  813e14:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  813e1b:	00 00 00 
  813e1e:	ff d0                	callq  *%rax
  813e20:	89 c2                	mov    %eax,%edx
  813e22:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e26:	8b 40 54             	mov    0x54(%rax),%eax
  813e29:	29 c2                	sub    %eax,%edx
  813e2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813e2f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813e33:	0f b7 c0             	movzwl %ax,%eax
  813e36:	01 d0                	add    %edx,%eax
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
  813e38:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  813e3b:	0f 86 50 05 00 00    	jbe    814391 <tcp_output+0x62d>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  813e41:	ba 00 00 00 00       	mov    $0x0,%edx
  813e46:	be 14 00 00 00       	mov    $0x14,%esi
  813e4b:	bf 01 00 00 00       	mov    $0x1,%edi
  813e50:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  813e57:	00 00 00 
  813e5a:	ff d0                	callq  *%rax
  813e5c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (p == NULL) {
  813e60:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  813e65:	75 0a                	jne    813e71 <tcp_output+0x10d>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  813e67:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  813e6c:	e9 ec 05 00 00       	jmpq   81445d <tcp_output+0x6f9>
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  813e71:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e75:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813e79:	83 e0 fc             	and    $0xfffffffc,%eax
  813e7c:	89 c2                	mov    %eax,%edx
  813e7e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e82:	88 50 2c             	mov    %dl,0x2c(%rax)

    tcphdr = p->payload;
  813e85:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813e89:	48 8b 40 08          	mov    0x8(%rax),%rax
  813e8d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    tcphdr->src = htons(pcb->local_port);
  813e91:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e95:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  813e99:	0f b7 c0             	movzwl %ax,%eax
  813e9c:	89 c7                	mov    %eax,%edi
  813e9e:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  813ea5:	00 00 00 
  813ea8:	ff d0                	callq  *%rax
  813eaa:	89 c2                	mov    %eax,%edx
  813eac:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813eb0:	66 89 10             	mov    %dx,(%rax)
    tcphdr->dest = htons(pcb->remote_port);
  813eb3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813eb7:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  813ebb:	0f b7 c0             	movzwl %ax,%eax
  813ebe:	89 c7                	mov    %eax,%edi
  813ec0:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  813ec7:	00 00 00 
  813eca:	ff d0                	callq  *%rax
  813ecc:	89 c2                	mov    %eax,%edx
  813ece:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813ed2:	66 89 50 02          	mov    %dx,0x2(%rax)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  813ed6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813eda:	8b 40 60             	mov    0x60(%rax),%eax
  813edd:	89 c7                	mov    %eax,%edi
  813edf:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  813ee6:	00 00 00 
  813ee9:	ff d0                	callq  *%rax
  813eeb:	89 c2                	mov    %eax,%edx
  813eed:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813ef1:	89 50 04             	mov    %edx,0x4(%rax)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  813ef4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ef8:	8b 40 30             	mov    0x30(%rax),%eax
  813efb:	89 c7                	mov    %eax,%edi
  813efd:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  813f04:	00 00 00 
  813f07:	ff d0                	callq  *%rax
  813f09:	89 c2                	mov    %eax,%edx
  813f0b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813f0f:	89 50 08             	mov    %edx,0x8(%rax)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  813f12:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813f16:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813f1a:	0f b7 c0             	movzwl %ax,%eax
  813f1d:	89 c7                	mov    %eax,%edi
  813f1f:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  813f26:	00 00 00 
  813f29:	ff d0                	callq  *%rax
  813f2b:	83 e0 c0             	and    $0xffffffc0,%eax
  813f2e:	83 c8 10             	or     $0x10,%eax
  813f31:	0f b7 c0             	movzwl %ax,%eax
  813f34:	89 c7                	mov    %eax,%edi
  813f36:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  813f3d:	00 00 00 
  813f40:	ff d0                	callq  *%rax
  813f42:	89 c2                	mov    %eax,%edx
  813f44:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813f48:	66 89 50 0c          	mov    %dx,0xc(%rax)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  813f4c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813f50:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  813f54:	0f b7 c0             	movzwl %ax,%eax
  813f57:	89 c7                	mov    %eax,%edi
  813f59:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  813f60:	00 00 00 
  813f63:	ff d0                	callq  *%rax
  813f65:	89 c2                	mov    %eax,%edx
  813f67:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813f6b:	66 89 50 0e          	mov    %dx,0xe(%rax)
    tcphdr->urgp = 0;
  813f6f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813f73:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
    TCPH_HDRLEN_SET(tcphdr, 5);
  813f79:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813f7d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813f81:	0f b7 c0             	movzwl %ax,%eax
  813f84:	89 c7                	mov    %eax,%edi
  813f86:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  813f8d:	00 00 00 
  813f90:	ff d0                	callq  *%rax
  813f92:	83 e0 3f             	and    $0x3f,%eax
  813f95:	80 cc 50             	or     $0x50,%ah
  813f98:	0f b7 c0             	movzwl %ax,%eax
  813f9b:	89 c7                	mov    %eax,%edi
  813f9d:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  813fa4:	00 00 00 
  813fa7:	ff d0                	callq  *%rax
  813fa9:	89 c2                	mov    %eax,%edx
  813fab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813faf:	66 89 50 0c          	mov    %dx,0xc(%rax)

    tcphdr->chksum = 0;
  813fb3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813fb7:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
          IP_PROTO_TCP, p->tot_len);
  813fbd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813fc1:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    tcphdr->urgp = 0;
    TCPH_HDRLEN_SET(tcphdr, 5);

    tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  813fc5:	0f b7 c8             	movzwl %ax,%ecx
  813fc8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813fcc:	48 8d 50 04          	lea    0x4(%rax),%rdx
  813fd0:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  813fd4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813fd8:	41 89 c8             	mov    %ecx,%r8d
  813fdb:	b9 06 00 00 00       	mov    $0x6,%ecx
  813fe0:	48 89 c7             	mov    %rax,%rdi
  813fe3:	48 b8 93 28 81 00 00 	movabs $0x812893,%rax
  813fea:	00 00 00 
  813fed:	ff d0                	callq  *%rax
  813fef:	89 c2                	mov    %eax,%edx
  813ff1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813ff5:	66 89 50 10          	mov    %dx,0x10(%rax)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  813ff9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ffd:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  814001:	0f b6 c8             	movzbl %al,%ecx
  814004:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814008:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  81400c:	0f b6 d0             	movzbl %al,%edx
  81400f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814013:	48 8d 78 04          	lea    0x4(%rax),%rdi
  814017:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  81401b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81401f:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  814025:	41 89 c8             	mov    %ecx,%r8d
  814028:	89 d1                	mov    %edx,%ecx
  81402a:	48 89 fa             	mov    %rdi,%rdx
  81402d:	48 89 c7             	mov    %rax,%rdi
  814030:	48 b8 80 16 81 00 00 	movabs $0x811680,%rax
  814037:	00 00 00 
  81403a:	ff d0                	callq  *%rax
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  81403c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814040:	48 89 c7             	mov    %rax,%rdi
  814043:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81404a:	00 00 00 
  81404d:	ff d0                	callq  *%rax

    return ERR_OK;
  81404f:	b8 00 00 00 00       	mov    $0x0,%eax
  814054:	e9 04 04 00 00       	jmpq   81445d <tcp_output+0x6f9>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  814059:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81405d:	48 8b 40 20          	mov    0x20(%rax),%rax
  814061:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814065:	0f b7 c0             	movzwl %ax,%eax
  814068:	89 c7                	mov    %eax,%edi
  81406a:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  814071:	00 00 00 
  814074:	ff d0                	callq  *%rax
  814076:	0f b7 c0             	movzwl %ax,%eax
  814079:	83 e0 04             	and    $0x4,%eax
  81407c:	85 c0                	test   %eax,%eax
  81407e:	74 2a                	je     8140aa <tcp_output+0x346>
  814080:	48 ba 80 2c 82 00 00 	movabs $0x822c80,%rdx
  814087:	00 00 00 
  81408a:	be 06 02 00 00       	mov    $0x206,%esi
  81408f:	48 bf 07 2b 82 00 00 	movabs $0x822b07,%rdi
  814096:	00 00 00 
  814099:	b8 00 00 00 00       	mov    $0x0,%eax
  81409e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8140a5:	00 00 00 
  8140a8:	ff d1                	callq  *%rcx
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  8140aa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8140ae:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8140b5:	48 85 c0             	test   %rax,%rax
  8140b8:	74 35                	je     8140ef <tcp_output+0x38b>
  8140ba:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8140be:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8140c2:	0f b6 c0             	movzbl %al,%eax
  8140c5:	83 e0 40             	and    $0x40,%eax
  8140c8:	85 c0                	test   %eax,%eax
  8140ca:	75 23                	jne    8140ef <tcp_output+0x38b>
  8140cc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8140d0:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8140d7:	48 85 c0             	test   %rax,%rax
  8140da:	74 1a                	je     8140f6 <tcp_output+0x392>
  8140dc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8140e0:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8140e7:	48 8b 00             	mov    (%rax),%rax
  8140ea:	48 85 c0             	test   %rax,%rax
  8140ed:	74 07                	je     8140f6 <tcp_output+0x392>
  8140ef:	b8 01 00 00 00       	mov    $0x1,%eax
  8140f4:	eb 05                	jmp    8140fb <tcp_output+0x397>
  8140f6:	b8 00 00 00 00       	mov    $0x0,%eax
  8140fb:	85 c0                	test   %eax,%eax
  8140fd:	75 18                	jne    814117 <tcp_output+0x3b3>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
  8140ff:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814103:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  814107:	0f b6 c0             	movzbl %al,%eax
  81410a:	25 a0 00 00 00       	and    $0xa0,%eax
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  81410f:	85 c0                	test   %eax,%eax
  814111:	0f 84 bd 02 00 00    	je     8143d4 <tcp_output+0x670>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  814117:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81411b:	48 8b 10             	mov    (%rax),%rdx
  81411e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814122:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)

    if (pcb->state != SYN_SENT) {
  814129:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81412d:	8b 40 18             	mov    0x18(%rax),%eax
  814130:	83 f8 02             	cmp    $0x2,%eax
  814133:	74 51                	je     814186 <tcp_output+0x422>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  814135:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814139:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81413d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814141:	48 8b 40 20          	mov    0x20(%rax),%rax
  814145:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814149:	0f b7 c0             	movzwl %ax,%eax
  81414c:	89 c7                	mov    %eax,%edi
  81414e:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  814155:	00 00 00 
  814158:	ff d0                	callq  *%rax
  81415a:	83 c8 10             	or     $0x10,%eax
  81415d:	0f b7 c0             	movzwl %ax,%eax
  814160:	89 c7                	mov    %eax,%edi
  814162:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  814169:	00 00 00 
  81416c:	ff d0                	callq  *%rax
  81416e:	66 89 43 0c          	mov    %ax,0xc(%rbx)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  814172:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814176:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81417a:	83 e0 fc             	and    $0xfffffffc,%eax
  81417d:	89 c2                	mov    %eax,%edx
  81417f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814183:	88 50 2c             	mov    %dl,0x2c(%rax)
    }

    tcp_output_segment(seg, pcb);
  814186:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  81418a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81418e:	48 89 d6             	mov    %rdx,%rsi
  814191:	48 89 c7             	mov    %rax,%rdi
  814194:	48 b8 66 44 81 00 00 	movabs $0x814466,%rax
  81419b:	00 00 00 
  81419e:	ff d0                	callq  *%rax
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  8141a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8141a4:	48 8b 40 20          	mov    0x20(%rax),%rax
  8141a8:	8b 40 04             	mov    0x4(%rax),%eax
  8141ab:	89 c7                	mov    %eax,%edi
  8141ad:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  8141b4:	00 00 00 
  8141b7:	ff d0                	callq  *%rax
  8141b9:	41 89 c4             	mov    %eax,%r12d
  8141bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8141c0:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8141c4:	0f b7 d8             	movzwl %ax,%ebx
  8141c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8141cb:	48 8b 40 20          	mov    0x20(%rax),%rax
  8141cf:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8141d3:	0f b7 c0             	movzwl %ax,%eax
  8141d6:	89 c7                	mov    %eax,%edi
  8141d8:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  8141df:	00 00 00 
  8141e2:	ff d0                	callq  *%rax
  8141e4:	0f b7 c0             	movzwl %ax,%eax
  8141e7:	83 e0 01             	and    $0x1,%eax
  8141ea:	85 c0                	test   %eax,%eax
  8141ec:	75 27                	jne    814215 <tcp_output+0x4b1>
  8141ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8141f2:	48 8b 40 20          	mov    0x20(%rax),%rax
  8141f6:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8141fa:	0f b7 c0             	movzwl %ax,%eax
  8141fd:	89 c7                	mov    %eax,%edi
  8141ff:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  814206:	00 00 00 
  814209:	ff d0                	callq  *%rax
  81420b:	0f b7 c0             	movzwl %ax,%eax
  81420e:	83 e0 02             	and    $0x2,%eax
  814211:	85 c0                	test   %eax,%eax
  814213:	74 07                	je     81421c <tcp_output+0x4b8>
  814215:	b8 01 00 00 00       	mov    $0x1,%eax
  81421a:	eb 05                	jmp    814221 <tcp_output+0x4bd>
  81421c:	b8 00 00 00 00       	mov    $0x0,%eax
  814221:	01 d8                	add    %ebx,%eax
  814223:	41 8d 14 04          	lea    (%r12,%rax,1),%edx
  814227:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81422b:	89 50 60             	mov    %edx,0x60(%rax)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  81422e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814232:	8b 50 64             	mov    0x64(%rax),%edx
  814235:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814239:	8b 40 60             	mov    0x60(%rax),%eax
  81423c:	29 c2                	sub    %eax,%edx
  81423e:	89 d0                	mov    %edx,%eax
  814240:	85 c0                	test   %eax,%eax
  814242:	79 0e                	jns    814252 <tcp_output+0x4ee>
      pcb->snd_max = pcb->snd_nxt;
  814244:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814248:	8b 50 60             	mov    0x60(%rax),%edx
  81424b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81424f:	89 50 64             	mov    %edx,0x64(%rax)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  814252:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814256:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81425a:	0f b7 d8             	movzwl %ax,%ebx
  81425d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814261:	48 8b 40 20          	mov    0x20(%rax),%rax
  814265:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814269:	0f b7 c0             	movzwl %ax,%eax
  81426c:	89 c7                	mov    %eax,%edi
  81426e:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  814275:	00 00 00 
  814278:	ff d0                	callq  *%rax
  81427a:	0f b7 c0             	movzwl %ax,%eax
  81427d:	83 e0 01             	and    $0x1,%eax
  814280:	85 c0                	test   %eax,%eax
  814282:	75 27                	jne    8142ab <tcp_output+0x547>
  814284:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814288:	48 8b 40 20          	mov    0x20(%rax),%rax
  81428c:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814290:	0f b7 c0             	movzwl %ax,%eax
  814293:	89 c7                	mov    %eax,%edi
  814295:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81429c:	00 00 00 
  81429f:	ff d0                	callq  *%rax
  8142a1:	0f b7 c0             	movzwl %ax,%eax
  8142a4:	83 e0 02             	and    $0x2,%eax
  8142a7:	85 c0                	test   %eax,%eax
  8142a9:	74 07                	je     8142b2 <tcp_output+0x54e>
  8142ab:	b8 01 00 00 00       	mov    $0x1,%eax
  8142b0:	eb 05                	jmp    8142b7 <tcp_output+0x553>
  8142b2:	b8 00 00 00 00       	mov    $0x0,%eax
  8142b7:	01 d8                	add    %ebx,%eax
  8142b9:	85 c0                	test   %eax,%eax
  8142bb:	0f 8e ae 00 00 00    	jle    81436f <tcp_output+0x60b>
      seg->next = NULL;
  8142c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8142c5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  8142cc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8142d0:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8142d7:	48 85 c0             	test   %rax,%rax
  8142da:	75 1c                	jne    8142f8 <tcp_output+0x594>
        pcb->unacked = seg;
  8142dc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8142e0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8142e4:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
        useg = seg;
  8142eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8142ef:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8142f3:	e9 8a 00 00 00       	jmpq   814382 <tcp_output+0x61e>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  8142f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8142fc:	48 8b 40 20          	mov    0x20(%rax),%rax
  814300:	8b 40 04             	mov    0x4(%rax),%eax
  814303:	89 c7                	mov    %eax,%edi
  814305:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  81430c:	00 00 00 
  81430f:	ff d0                	callq  *%rax
  814311:	89 c3                	mov    %eax,%ebx
  814313:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  814317:	48 8b 40 20          	mov    0x20(%rax),%rax
  81431b:	8b 40 04             	mov    0x4(%rax),%eax
  81431e:	89 c7                	mov    %eax,%edi
  814320:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  814327:	00 00 00 
  81432a:	ff d0                	callq  *%rax
  81432c:	29 c3                	sub    %eax,%ebx
  81432e:	89 d8                	mov    %ebx,%eax
  814330:	85 c0                	test   %eax,%eax
  814332:	79 23                	jns    814357 <tcp_output+0x5f3>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  814334:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814338:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  81433f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814343:	48 89 10             	mov    %rdx,(%rax)
          pcb->unacked = seg;
  814346:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81434a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81434e:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
  814355:	eb 2b                	jmp    814382 <tcp_output+0x61e>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  814357:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81435b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81435f:	48 89 10             	mov    %rdx,(%rax)
          useg = useg->next;
  814362:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  814366:	48 8b 00             	mov    (%rax),%rax
  814369:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  81436d:	eb 13                	jmp    814382 <tcp_output+0x61e>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  81436f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814373:	48 89 c7             	mov    %rax,%rdi
  814376:	48 b8 1b 05 81 00 00 	movabs $0x81051b,%rax
  81437d:	00 00 00 
  814380:	ff d0                	callq  *%rax
    }
    seg = pcb->unsent;
  814382:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814386:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81438d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  814391:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814396:	74 3d                	je     8143d5 <tcp_output+0x671>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  814398:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81439c:	48 8b 40 20          	mov    0x20(%rax),%rax
  8143a0:	8b 40 04             	mov    0x4(%rax),%eax
  8143a3:	89 c7                	mov    %eax,%edi
  8143a5:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  8143ac:	00 00 00 
  8143af:	ff d0                	callq  *%rax
  8143b1:	89 c2                	mov    %eax,%edx
  8143b3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8143b7:	8b 40 54             	mov    0x54(%rax),%eax
  8143ba:	29 c2                	sub    %eax,%edx
  8143bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8143c0:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8143c4:	0f b7 c0             	movzwl %ax,%eax
  8143c7:	01 d0                	add    %edx,%eax
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  8143c9:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  8143cc:	0f 86 87 fc ff ff    	jbe    814059 <tcp_output+0x2f5>
  8143d2:	eb 01                	jmp    8143d5 <tcp_output+0x671>
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
      break;
  8143d4:	90                   	nop
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  8143d5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8143da:	74 68                	je     814444 <tcp_output+0x6e0>
  8143dc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8143e0:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  8143e7:	84 c0                	test   %al,%al
  8143e9:	75 59                	jne    814444 <tcp_output+0x6e0>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  8143eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8143ef:	48 8b 40 20          	mov    0x20(%rax),%rax
  8143f3:	8b 40 04             	mov    0x4(%rax),%eax
  8143f6:	89 c7                	mov    %eax,%edi
  8143f8:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  8143ff:	00 00 00 
  814402:	ff d0                	callq  *%rax
  814404:	89 c2                	mov    %eax,%edx
  814406:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81440a:	8b 40 54             	mov    0x54(%rax),%eax
  81440d:	29 c2                	sub    %eax,%edx
  81440f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814413:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  814417:	0f b7 c0             	movzwl %ax,%eax
  81441a:	01 c2                	add    %eax,%edx
  81441c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814420:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  814424:	0f b7 c0             	movzwl %ax,%eax
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  814427:	39 c2                	cmp    %eax,%edx
  814429:	76 19                	jbe    814444 <tcp_output+0x6e0>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  81442b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81442f:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  814436:	00 00 00 
    pcb->persist_backoff = 1;
  814439:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81443d:	c6 80 d8 00 00 00 01 	movb   $0x1,0xd8(%rax)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  814444:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814448:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81444c:	83 e0 7f             	and    $0x7f,%eax
  81444f:	89 c2                	mov    %eax,%edx
  814451:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814455:	88 50 2c             	mov    %dl,0x2c(%rax)
  return ERR_OK;
  814458:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81445d:	48 83 c4 40          	add    $0x40,%rsp
  814461:	5b                   	pop    %rbx
  814462:	41 5c                	pop    %r12
  814464:	5d                   	pop    %rbp
  814465:	c3                   	retq   

0000000000814466 <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
  814466:	55                   	push   %rbp
  814467:	48 89 e5             	mov    %rsp,%rbp
  81446a:	53                   	push   %rbx
  81446b:	48 83 ec 28          	sub    $0x28,%rsp
  81446f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  814473:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  814477:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81447b:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81447f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814483:	8b 40 30             	mov    0x30(%rax),%eax
  814486:	89 c7                	mov    %eax,%edi
  814488:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  81448f:	00 00 00 
  814492:	ff d0                	callq  *%rax
  814494:	89 43 08             	mov    %eax,0x8(%rbx)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  814497:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81449b:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81449f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8144a3:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  8144a7:	0f b7 c0             	movzwl %ax,%eax
  8144aa:	89 c7                	mov    %eax,%edi
  8144ac:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8144b3:	00 00 00 
  8144b6:	ff d0                	callq  *%rax
  8144b8:	66 89 43 0e          	mov    %ax,0xe(%rbx)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  8144bc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8144c0:	48 85 c0             	test   %rax,%rax
  8144c3:	74 0a                	je     8144cf <tcp_output_segment+0x69>
  8144c5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8144c9:	8b 00                	mov    (%rax),%eax
  8144cb:	85 c0                	test   %eax,%eax
  8144cd:	75 47                	jne    814516 <tcp_output_segment+0xb0>
    netif = ip_route(&(pcb->remote_ip));
  8144cf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8144d3:	48 83 c0 04          	add    $0x4,%rax
  8144d7:	48 89 c7             	mov    %rax,%rdi
  8144da:	48 b8 88 0e 81 00 00 	movabs $0x810e88,%rax
  8144e1:	00 00 00 
  8144e4:	ff d0                	callq  *%rax
  8144e6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (netif == NULL) {
  8144ea:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8144ef:	0f 84 83 01 00 00    	je     814678 <tcp_output_segment+0x212>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  8144f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8144f9:	48 83 c0 08          	add    $0x8,%rax
  8144fd:	48 85 c0             	test   %rax,%rax
  814500:	74 09                	je     81450b <tcp_output_segment+0xa5>
  814502:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814506:	8b 40 08             	mov    0x8(%rax),%eax
  814509:	eb 05                	jmp    814510 <tcp_output_segment+0xaa>
  81450b:	b8 00 00 00 00       	mov    $0x0,%eax
  814510:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  814514:	89 02                	mov    %eax,(%rdx)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  814516:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81451a:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  81451e:	66 83 f8 ff          	cmp    $0xffff,%ax
  814522:	75 0a                	jne    81452e <tcp_output_segment+0xc8>
    pcb->rtime = 0;
  814524:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814528:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

  if (pcb->rttest == 0) {
  81452e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814532:	8b 40 44             	mov    0x44(%rax),%eax
  814535:	85 c0                	test   %eax,%eax
  814537:	75 35                	jne    81456e <tcp_output_segment+0x108>
    pcb->rttest = tcp_ticks;
  814539:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  814540:	00 00 00 
  814543:	8b 10                	mov    (%rax),%edx
  814545:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814549:	89 50 44             	mov    %edx,0x44(%rax)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  81454c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814550:	48 8b 40 20          	mov    0x20(%rax),%rax
  814554:	8b 40 04             	mov    0x4(%rax),%eax
  814557:	89 c7                	mov    %eax,%edi
  814559:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  814560:	00 00 00 
  814563:	ff d0                	callq  *%rax
  814565:	89 c2                	mov    %eax,%edx
  814567:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81456b:	89 50 48             	mov    %edx,0x48(%rax)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  81456e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814572:	48 8b 40 20          	mov    0x20(%rax),%rax
  814576:	48 89 c2             	mov    %rax,%rdx
  814579:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81457d:	48 8b 40 08          	mov    0x8(%rax),%rax
  814581:	48 8b 40 08          	mov    0x8(%rax),%rax
  814585:	48 29 c2             	sub    %rax,%rdx
  814588:	48 89 d0             	mov    %rdx,%rax
  81458b:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)

  seg->p->len -= len;
  81458f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814593:	48 8b 40 08          	mov    0x8(%rax),%rax
  814597:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81459b:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81459f:	0f b7 52 12          	movzwl 0x12(%rdx),%edx
  8145a3:	66 2b 55 e6          	sub    -0x1a(%rbp),%dx
  8145a7:	66 89 50 12          	mov    %dx,0x12(%rax)
  seg->p->tot_len -= len;
  8145ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8145af:	48 8b 40 08          	mov    0x8(%rax),%rax
  8145b3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8145b7:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8145bb:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  8145bf:	66 2b 55 e6          	sub    -0x1a(%rbp),%dx
  8145c3:	66 89 50 10          	mov    %dx,0x10(%rax)

  seg->p->payload = seg->tcphdr;
  8145c7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8145cb:	48 8b 40 08          	mov    0x8(%rax),%rax
  8145cf:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8145d3:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  8145d7:	48 89 50 08          	mov    %rdx,0x8(%rax)

  seg->tcphdr->chksum = 0;
  8145db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8145df:	48 8b 40 20          	mov    0x20(%rax),%rax
  8145e3:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  8145e9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8145ed:	48 8b 58 20          	mov    0x20(%rax),%rbx
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  8145f1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8145f5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8145f9:	0f b7 40 10          	movzwl 0x10(%rax),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  8145fd:	0f b7 c8             	movzwl %ax,%ecx
  814600:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814604:	48 8d 50 04          	lea    0x4(%rax),%rdx
  814608:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  81460c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814610:	48 8b 40 08          	mov    0x8(%rax),%rax
  814614:	41 89 c8             	mov    %ecx,%r8d
  814617:	b9 06 00 00 00       	mov    $0x6,%ecx
  81461c:	48 89 c7             	mov    %rax,%rdi
  81461f:	48 b8 93 28 81 00 00 	movabs $0x812893,%rax
  814626:	00 00 00 
  814629:	ff d0                	callq  *%rax
  81462b:	66 89 43 10          	mov    %ax,0x10(%rbx)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  81462f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814633:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  814637:	0f b6 c8             	movzbl %al,%ecx
  81463a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81463e:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  814642:	0f b6 d0             	movzbl %al,%edx
  814645:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814649:	48 8d 78 04          	lea    0x4(%rax),%rdi
  81464d:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  814651:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814655:	48 8b 40 08          	mov    0x8(%rax),%rax
  814659:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  81465f:	41 89 c8             	mov    %ecx,%r8d
  814662:	89 d1                	mov    %edx,%ecx
  814664:	48 89 fa             	mov    %rdi,%rdx
  814667:	48 89 c7             	mov    %rax,%rdi
  81466a:	48 b8 80 16 81 00 00 	movabs $0x811680,%rax
  814671:	00 00 00 
  814674:	ff d0                	callq  *%rax
  814676:	eb 01                	jmp    814679 <tcp_output_segment+0x213>
  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
    netif = ip_route(&(pcb->remote_ip));
    if (netif == NULL) {
      return;
  814678:	90                   	nop
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
}
  814679:	48 83 c4 28          	add    $0x28,%rsp
  81467d:	5b                   	pop    %rbx
  81467e:	5d                   	pop    %rbp
  81467f:	c3                   	retq   

0000000000814680 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  814680:	55                   	push   %rbp
  814681:	48 89 e5             	mov    %rsp,%rbp
  814684:	48 83 ec 30          	sub    $0x30,%rsp
  814688:	89 7d ec             	mov    %edi,-0x14(%rbp)
  81468b:	89 75 e8             	mov    %esi,-0x18(%rbp)
  81468e:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  814692:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
  814696:	44 89 c2             	mov    %r8d,%edx
  814699:	44 89 c8             	mov    %r9d,%eax
  81469c:	66 89 55 d4          	mov    %dx,-0x2c(%rbp)
  8146a0:	66 89 45 d0          	mov    %ax,-0x30(%rbp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8146a4:	ba 00 00 00 00       	mov    $0x0,%edx
  8146a9:	be 14 00 00 00       	mov    $0x14,%esi
  8146ae:	bf 01 00 00 00       	mov    $0x1,%edi
  8146b3:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  8146ba:	00 00 00 
  8146bd:	ff d0                	callq  *%rax
  8146bf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (p == NULL) {
  8146c3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8146c8:	0f 84 cb 01 00 00    	je     814899 <tcp_rst+0x219>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8146ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8146d2:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8146d6:	66 83 f8 13          	cmp    $0x13,%ax
  8146da:	77 2a                	ja     814706 <tcp_rst+0x86>
  8146dc:	48 ba 98 2c 82 00 00 	movabs $0x822c98,%rdx
  8146e3:	00 00 00 
  8146e6:	be bf 02 00 00       	mov    $0x2bf,%esi
  8146eb:	48 bf 07 2b 82 00 00 	movabs $0x822b07,%rdi
  8146f2:	00 00 00 
  8146f5:	b8 00 00 00 00       	mov    $0x0,%eax
  8146fa:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  814701:	00 00 00 
  814704:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  814706:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81470a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81470e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  tcphdr->src = htons(local_port);
  814712:	0f b7 45 d4          	movzwl -0x2c(%rbp),%eax
  814716:	89 c7                	mov    %eax,%edi
  814718:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  81471f:	00 00 00 
  814722:	ff d0                	callq  *%rax
  814724:	89 c2                	mov    %eax,%edx
  814726:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81472a:	66 89 10             	mov    %dx,(%rax)
  tcphdr->dest = htons(remote_port);
  81472d:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  814731:	89 c7                	mov    %eax,%edi
  814733:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  81473a:	00 00 00 
  81473d:	ff d0                	callq  *%rax
  81473f:	89 c2                	mov    %eax,%edx
  814741:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814745:	66 89 50 02          	mov    %dx,0x2(%rax)
  tcphdr->seqno = htonl(seqno);
  814749:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81474c:	89 c7                	mov    %eax,%edi
  81474e:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  814755:	00 00 00 
  814758:	ff d0                	callq  *%rax
  81475a:	89 c2                	mov    %eax,%edx
  81475c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814760:	89 50 04             	mov    %edx,0x4(%rax)
  tcphdr->ackno = htonl(ackno);
  814763:	8b 45 e8             	mov    -0x18(%rbp),%eax
  814766:	89 c7                	mov    %eax,%edi
  814768:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  81476f:	00 00 00 
  814772:	ff d0                	callq  *%rax
  814774:	89 c2                	mov    %eax,%edx
  814776:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81477a:	89 50 08             	mov    %edx,0x8(%rax)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  81477d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814781:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814785:	0f b7 c0             	movzwl %ax,%eax
  814788:	89 c7                	mov    %eax,%edi
  81478a:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  814791:	00 00 00 
  814794:	ff d0                	callq  *%rax
  814796:	83 e0 c0             	and    $0xffffffc0,%eax
  814799:	83 c8 14             	or     $0x14,%eax
  81479c:	0f b7 c0             	movzwl %ax,%eax
  81479f:	89 c7                	mov    %eax,%edi
  8147a1:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8147a8:	00 00 00 
  8147ab:	ff d0                	callq  *%rax
  8147ad:	89 c2                	mov    %eax,%edx
  8147af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8147b3:	66 89 50 0c          	mov    %dx,0xc(%rax)
  tcphdr->wnd = htons(TCP_WND);
  8147b7:	bf c0 5d 00 00       	mov    $0x5dc0,%edi
  8147bc:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8147c3:	00 00 00 
  8147c6:	ff d0                	callq  *%rax
  8147c8:	89 c2                	mov    %eax,%edx
  8147ca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8147ce:	66 89 50 0e          	mov    %dx,0xe(%rax)
  tcphdr->urgp = 0;
  8147d2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8147d6:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  8147dc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8147e0:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8147e4:	0f b7 c0             	movzwl %ax,%eax
  8147e7:	89 c7                	mov    %eax,%edi
  8147e9:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  8147f0:	00 00 00 
  8147f3:	ff d0                	callq  *%rax
  8147f5:	83 e0 3f             	and    $0x3f,%eax
  8147f8:	80 cc 50             	or     $0x50,%ah
  8147fb:	0f b7 c0             	movzwl %ax,%eax
  8147fe:	89 c7                	mov    %eax,%edi
  814800:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  814807:	00 00 00 
  81480a:	ff d0                	callq  *%rax
  81480c:	89 c2                	mov    %eax,%edx
  81480e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814812:	66 89 50 0c          	mov    %dx,0xc(%rax)

  tcphdr->chksum = 0;
  814816:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81481a:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
  814820:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814824:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  tcphdr->urgp = 0;
  TCPH_HDRLEN_SET(tcphdr, 5);

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  814828:	0f b7 c8             	movzwl %ax,%ecx
  81482b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81482f:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  814833:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814837:	41 89 c8             	mov    %ecx,%r8d
  81483a:	b9 06 00 00 00       	mov    $0x6,%ecx
  81483f:	48 89 c7             	mov    %rax,%rdi
  814842:	48 b8 93 28 81 00 00 	movabs $0x812893,%rax
  814849:	00 00 00 
  81484c:	ff d0                	callq  *%rax
  81484e:	89 c2                	mov    %eax,%edx
  814850:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814854:	66 89 50 10          	mov    %dx,0x10(%rax)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  814858:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81485c:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  814860:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814864:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  81486a:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  814870:	b9 ff 00 00 00       	mov    $0xff,%ecx
  814875:	48 89 c7             	mov    %rax,%rdi
  814878:	48 b8 80 16 81 00 00 	movabs $0x811680,%rax
  81487f:	00 00 00 
  814882:	ff d0                	callq  *%rax
  pbuf_free(p);
  814884:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814888:	48 89 c7             	mov    %rax,%rdi
  81488b:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  814892:	00 00 00 
  814895:	ff d0                	callq  *%rax
  814897:	eb 01                	jmp    81489a <tcp_rst+0x21a>
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  if (p == NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  814899:	90                   	nop
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  81489a:	c9                   	leaveq 
  81489b:	c3                   	retq   

000000000081489c <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  81489c:	55                   	push   %rbp
  81489d:	48 89 e5             	mov    %rsp,%rbp
  8148a0:	48 83 ec 20          	sub    $0x20,%rsp
  8148a4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8148a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8148ac:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8148b3:	48 85 c0             	test   %rax,%rax
  8148b6:	0f 84 ba 00 00 00    	je     814976 <tcp_rexmit_rto+0xda>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  8148bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8148c0:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8148c7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8148cb:	eb 0b                	jmp    8148d8 <tcp_rexmit_rto+0x3c>
  8148cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8148d1:	48 8b 00             	mov    (%rax),%rax
  8148d4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8148d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8148dc:	48 8b 00             	mov    (%rax),%rax
  8148df:	48 85 c0             	test   %rax,%rax
  8148e2:	75 e9                	jne    8148cd <tcp_rexmit_rto+0x31>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  8148e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8148e8:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
  8148ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8148f3:	48 89 10             	mov    %rdx,(%rax)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  8148f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8148fa:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  814901:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814905:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  81490c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814910:	48 c7 80 88 00 00 00 	movq   $0x0,0x88(%rax)
  814917:	00 00 00 00 

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  81491b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81491f:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  814926:	48 8b 40 20          	mov    0x20(%rax),%rax
  81492a:	8b 40 04             	mov    0x4(%rax),%eax
  81492d:	89 c7                	mov    %eax,%edi
  81492f:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  814936:	00 00 00 
  814939:	ff d0                	callq  *%rax
  81493b:	89 c2                	mov    %eax,%edx
  81493d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814941:	89 50 60             	mov    %edx,0x60(%rax)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  814944:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814948:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  81494c:	8d 50 01             	lea    0x1(%rax),%edx
  81494f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814953:	88 50 52             	mov    %dl,0x52(%rax)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  814956:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81495a:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)

  /* Do the actual retransmission */
  tcp_output(pcb);
  814961:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814965:	48 89 c7             	mov    %rax,%rdi
  814968:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  81496f:	00 00 00 
  814972:	ff d0                	callq  *%rax
  814974:	eb 01                	jmp    814977 <tcp_rexmit_rto+0xdb>
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
  814976:	90                   	nop
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
}
  814977:	c9                   	leaveq 
  814978:	c3                   	retq   

0000000000814979 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  814979:	55                   	push   %rbp
  81497a:	48 89 e5             	mov    %rsp,%rbp
  81497d:	48 83 ec 20          	sub    $0x20,%rsp
  814981:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  814985:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814989:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814990:	48 85 c0             	test   %rax,%rax
  814993:	0f 84 ab 00 00 00    	je     814a44 <tcp_rexmit+0xcb>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  814999:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81499d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8149a4:	48 8b 00             	mov    (%rax),%rax
  8149a7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  pcb->unacked->next = pcb->unsent;
  8149ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8149af:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8149b6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8149ba:	48 8b 92 80 00 00 00 	mov    0x80(%rdx),%rdx
  8149c1:	48 89 10             	mov    %rdx,(%rax)
  pcb->unsent = pcb->unacked;
  8149c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8149c8:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  8149cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8149d3:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  pcb->unacked = seg;
  8149da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8149de:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8149e2:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  8149e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8149ed:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8149f4:	48 8b 40 20          	mov    0x20(%rax),%rax
  8149f8:	8b 40 04             	mov    0x4(%rax),%eax
  8149fb:	89 c7                	mov    %eax,%edi
  8149fd:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  814a04:	00 00 00 
  814a07:	ff d0                	callq  *%rax
  814a09:	89 c2                	mov    %eax,%edx
  814a0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814a0f:	89 50 60             	mov    %edx,0x60(%rax)

  ++pcb->nrtx;
  814a12:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814a16:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  814a1a:	8d 50 01             	lea    0x1(%rax),%edx
  814a1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814a21:	88 50 52             	mov    %dl,0x52(%rax)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  814a24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814a28:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  814a2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814a33:	48 89 c7             	mov    %rax,%rdi
  814a36:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  814a3d:	00 00 00 
  814a40:	ff d0                	callq  *%rax
  814a42:	eb 01                	jmp    814a45 <tcp_rexmit+0xcc>
tcp_rexmit(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
  814a44:	90                   	nop
  pcb->rttest = 0;

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
}
  814a45:	c9                   	leaveq 
  814a46:	c3                   	retq   

0000000000814a47 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  814a47:	55                   	push   %rbp
  814a48:	48 89 e5             	mov    %rsp,%rbp
  814a4b:	48 83 ec 20          	sub    $0x20,%rsp
  814a4f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  814a53:	ba 00 00 00 00       	mov    $0x0,%edx
  814a58:	be 14 00 00 00       	mov    $0x14,%esi
  814a5d:	bf 01 00 00 00       	mov    $0x1,%edi
  814a62:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  814a69:	00 00 00 
  814a6c:	ff d0                	callq  *%rax
  814a6e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
   
  if(p == NULL) {
  814a72:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814a77:	0f 84 fe 01 00 00    	je     814c7b <tcp_keepalive+0x234>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  814a7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814a81:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  814a85:	66 83 f8 13          	cmp    $0x13,%ax
  814a89:	77 2a                	ja     814ab5 <tcp_keepalive+0x6e>
  814a8b:	48 ba 98 2c 82 00 00 	movabs $0x822c98,%rdx
  814a92:	00 00 00 
  814a95:	be 3b 03 00 00       	mov    $0x33b,%esi
  814a9a:	48 bf 07 2b 82 00 00 	movabs $0x822b07,%rdi
  814aa1:	00 00 00 
  814aa4:	b8 00 00 00 00       	mov    $0x0,%eax
  814aa9:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  814ab0:	00 00 00 
  814ab3:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  814ab5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814ab9:	48 8b 40 08          	mov    0x8(%rax),%rax
  814abd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  tcphdr->src = htons(pcb->local_port);
  814ac1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814ac5:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  814ac9:	0f b7 c0             	movzwl %ax,%eax
  814acc:	89 c7                	mov    %eax,%edi
  814ace:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  814ad5:	00 00 00 
  814ad8:	ff d0                	callq  *%rax
  814ada:	89 c2                	mov    %eax,%edx
  814adc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814ae0:	66 89 10             	mov    %dx,(%rax)
  tcphdr->dest = htons(pcb->remote_port);
  814ae3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814ae7:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  814aeb:	0f b7 c0             	movzwl %ax,%eax
  814aee:	89 c7                	mov    %eax,%edi
  814af0:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  814af7:	00 00 00 
  814afa:	ff d0                	callq  *%rax
  814afc:	89 c2                	mov    %eax,%edx
  814afe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814b02:	66 89 50 02          	mov    %dx,0x2(%rax)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  814b06:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814b0a:	8b 40 60             	mov    0x60(%rax),%eax
  814b0d:	83 e8 01             	sub    $0x1,%eax
  814b10:	89 c7                	mov    %eax,%edi
  814b12:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  814b19:	00 00 00 
  814b1c:	ff d0                	callq  *%rax
  814b1e:	89 c2                	mov    %eax,%edx
  814b20:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814b24:	89 50 04             	mov    %edx,0x4(%rax)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  814b27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814b2b:	8b 40 30             	mov    0x30(%rax),%eax
  814b2e:	89 c7                	mov    %eax,%edi
  814b30:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  814b37:	00 00 00 
  814b3a:	ff d0                	callq  *%rax
  814b3c:	89 c2                	mov    %eax,%edx
  814b3e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814b42:	89 50 08             	mov    %edx,0x8(%rax)
  TCPH_FLAGS_SET(tcphdr, 0);
  814b45:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814b49:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814b4d:	0f b7 c0             	movzwl %ax,%eax
  814b50:	89 c7                	mov    %eax,%edi
  814b52:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  814b59:	00 00 00 
  814b5c:	ff d0                	callq  *%rax
  814b5e:	0f b7 c0             	movzwl %ax,%eax
  814b61:	25 c0 ff 00 00       	and    $0xffc0,%eax
  814b66:	89 c7                	mov    %eax,%edi
  814b68:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  814b6f:	00 00 00 
  814b72:	ff d0                	callq  *%rax
  814b74:	89 c2                	mov    %eax,%edx
  814b76:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814b7a:	66 89 50 0c          	mov    %dx,0xc(%rax)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  814b7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814b82:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  814b86:	0f b7 c0             	movzwl %ax,%eax
  814b89:	89 c7                	mov    %eax,%edi
  814b8b:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  814b92:	00 00 00 
  814b95:	ff d0                	callq  *%rax
  814b97:	89 c2                	mov    %eax,%edx
  814b99:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814b9d:	66 89 50 0e          	mov    %dx,0xe(%rax)
  tcphdr->urgp = 0;
  814ba1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814ba5:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  814bab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814baf:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814bb3:	0f b7 c0             	movzwl %ax,%eax
  814bb6:	89 c7                	mov    %eax,%edi
  814bb8:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  814bbf:	00 00 00 
  814bc2:	ff d0                	callq  *%rax
  814bc4:	83 e0 3f             	and    $0x3f,%eax
  814bc7:	80 cc 50             	or     $0x50,%ah
  814bca:	0f b7 c0             	movzwl %ax,%eax
  814bcd:	89 c7                	mov    %eax,%edi
  814bcf:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  814bd6:	00 00 00 
  814bd9:	ff d0                	callq  *%rax
  814bdb:	89 c2                	mov    %eax,%edx
  814bdd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814be1:	66 89 50 0c          	mov    %dx,0xc(%rax)

  tcphdr->chksum = 0;
  814be5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814be9:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
  814bef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814bf3:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  tcphdr->urgp = 0;
  TCPH_HDRLEN_SET(tcphdr, 5);

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  814bf7:	0f b7 c8             	movzwl %ax,%ecx
  814bfa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814bfe:	48 8d 50 04          	lea    0x4(%rax),%rdx
  814c02:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  814c06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814c0a:	41 89 c8             	mov    %ecx,%r8d
  814c0d:	b9 06 00 00 00       	mov    $0x6,%ecx
  814c12:	48 89 c7             	mov    %rax,%rdi
  814c15:	48 b8 93 28 81 00 00 	movabs $0x812893,%rax
  814c1c:	00 00 00 
  814c1f:	ff d0                	callq  *%rax
  814c21:	89 c2                	mov    %eax,%edx
  814c23:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814c27:	66 89 50 10          	mov    %dx,0x10(%rax)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  814c2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c2f:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  814c33:	0f b6 d0             	movzbl %al,%edx
  814c36:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c3a:	48 8d 78 04          	lea    0x4(%rax),%rdi
  814c3e:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  814c42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814c46:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  814c4c:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  814c52:	89 d1                	mov    %edx,%ecx
  814c54:	48 89 fa             	mov    %rdi,%rdx
  814c57:	48 89 c7             	mov    %rax,%rdi
  814c5a:	48 b8 80 16 81 00 00 	movabs $0x811680,%rax
  814c61:	00 00 00 
  814c64:	ff d0                	callq  *%rax
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  814c66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814c6a:	48 89 c7             	mov    %rax,%rdi
  814c6d:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  814c74:	00 00 00 
  814c77:	ff d0                	callq  *%rax
  814c79:	eb 01                	jmp    814c7c <tcp_keepalive+0x235>
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
   
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  814c7b:	90                   	nop

  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  814c7c:	c9                   	leaveq 
  814c7d:	c3                   	retq   

0000000000814c7e <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  814c7e:	55                   	push   %rbp
  814c7f:	48 89 e5             	mov    %rsp,%rbp
  814c82:	48 83 ec 30          	sub    $0x30,%rsp
  814c86:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  814c8a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814c8e:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814c95:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if(seg == NULL)
  814c99:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814c9e:	75 0f                	jne    814caf <tcp_zero_window_probe+0x31>
    seg = pcb->unsent;
  814ca0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814ca4:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  814cab:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if(seg == NULL)
  814caf:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814cb4:	0f 84 32 02 00 00    	je     814eec <tcp_zero_window_probe+0x26e>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  814cba:	ba 00 00 00 00       	mov    $0x0,%edx
  814cbf:	be 15 00 00 00       	mov    $0x15,%esi
  814cc4:	bf 01 00 00 00       	mov    $0x1,%edi
  814cc9:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  814cd0:	00 00 00 
  814cd3:	ff d0                	callq  *%rax
  814cd5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
   
  if(p == NULL) {
  814cd9:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  814cde:	0f 84 0b 02 00 00    	je     814eef <tcp_zero_window_probe+0x271>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  814ce4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814ce8:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  814cec:	66 83 f8 13          	cmp    $0x13,%ax
  814cf0:	77 2a                	ja     814d1c <tcp_zero_window_probe+0x9e>
  814cf2:	48 ba 98 2c 82 00 00 	movabs $0x822c98,%rdx
  814cf9:	00 00 00 
  814cfc:	be 8e 03 00 00       	mov    $0x38e,%esi
  814d01:	48 bf 07 2b 82 00 00 	movabs $0x822b07,%rdi
  814d08:	00 00 00 
  814d0b:	b8 00 00 00 00       	mov    $0x0,%eax
  814d10:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  814d17:	00 00 00 
  814d1a:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  814d1c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814d20:	48 8b 40 08          	mov    0x8(%rax),%rax
  814d24:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  tcphdr->src = htons(pcb->local_port);
  814d28:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814d2c:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  814d30:	0f b7 c0             	movzwl %ax,%eax
  814d33:	89 c7                	mov    %eax,%edi
  814d35:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  814d3c:	00 00 00 
  814d3f:	ff d0                	callq  *%rax
  814d41:	89 c2                	mov    %eax,%edx
  814d43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814d47:	66 89 10             	mov    %dx,(%rax)
  tcphdr->dest = htons(pcb->remote_port);
  814d4a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814d4e:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  814d52:	0f b7 c0             	movzwl %ax,%eax
  814d55:	89 c7                	mov    %eax,%edi
  814d57:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  814d5e:	00 00 00 
  814d61:	ff d0                	callq  *%rax
  814d63:	89 c2                	mov    %eax,%edx
  814d65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814d69:	66 89 50 02          	mov    %dx,0x2(%rax)
  tcphdr->seqno = seg->tcphdr->seqno;
  814d6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814d71:	48 8b 40 20          	mov    0x20(%rax),%rax
  814d75:	8b 50 04             	mov    0x4(%rax),%edx
  814d78:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814d7c:	89 50 04             	mov    %edx,0x4(%rax)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  814d7f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814d83:	8b 40 30             	mov    0x30(%rax),%eax
  814d86:	89 c7                	mov    %eax,%edi
  814d88:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  814d8f:	00 00 00 
  814d92:	ff d0                	callq  *%rax
  814d94:	89 c2                	mov    %eax,%edx
  814d96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814d9a:	89 50 08             	mov    %edx,0x8(%rax)
  TCPH_FLAGS_SET(tcphdr, 0);
  814d9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814da1:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814da5:	0f b7 c0             	movzwl %ax,%eax
  814da8:	89 c7                	mov    %eax,%edi
  814daa:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  814db1:	00 00 00 
  814db4:	ff d0                	callq  *%rax
  814db6:	0f b7 c0             	movzwl %ax,%eax
  814db9:	25 c0 ff 00 00       	and    $0xffc0,%eax
  814dbe:	89 c7                	mov    %eax,%edi
  814dc0:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  814dc7:	00 00 00 
  814dca:	ff d0                	callq  *%rax
  814dcc:	89 c2                	mov    %eax,%edx
  814dce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814dd2:	66 89 50 0c          	mov    %dx,0xc(%rax)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  814dd6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814dda:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  814dde:	0f b7 c0             	movzwl %ax,%eax
  814de1:	89 c7                	mov    %eax,%edi
  814de3:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  814dea:	00 00 00 
  814ded:	ff d0                	callq  *%rax
  814def:	89 c2                	mov    %eax,%edx
  814df1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814df5:	66 89 50 0e          	mov    %dx,0xe(%rax)
  tcphdr->urgp = 0;
  814df9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814dfd:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  814e03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814e07:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814e0b:	0f b7 c0             	movzwl %ax,%eax
  814e0e:	89 c7                	mov    %eax,%edi
  814e10:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  814e17:	00 00 00 
  814e1a:	ff d0                	callq  *%rax
  814e1c:	83 e0 3f             	and    $0x3f,%eax
  814e1f:	80 cc 50             	or     $0x50,%ah
  814e22:	0f b7 c0             	movzwl %ax,%eax
  814e25:	89 c7                	mov    %eax,%edi
  814e27:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  814e2e:	00 00 00 
  814e31:	ff d0                	callq  *%rax
  814e33:	89 c2                	mov    %eax,%edx
  814e35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814e39:	66 89 50 0c          	mov    %dx,0xc(%rax)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  814e3d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814e41:	48 8b 40 08          	mov    0x8(%rax),%rax
  814e45:	48 8d 50 14          	lea    0x14(%rax),%rdx
  814e49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814e4d:	48 8b 40 10          	mov    0x10(%rax),%rax
  814e51:	0f b6 00             	movzbl (%rax),%eax
  814e54:	88 02                	mov    %al,(%rdx)

  tcphdr->chksum = 0;
  814e56:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814e5a:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
  814e60:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814e64:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  814e68:	0f b7 c8             	movzwl %ax,%ecx
  814e6b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814e6f:	48 8d 50 04          	lea    0x4(%rax),%rdx
  814e73:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  814e77:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814e7b:	41 89 c8             	mov    %ecx,%r8d
  814e7e:	b9 06 00 00 00       	mov    $0x6,%ecx
  814e83:	48 89 c7             	mov    %rax,%rdi
  814e86:	48 b8 93 28 81 00 00 	movabs $0x812893,%rax
  814e8d:	00 00 00 
  814e90:	ff d0                	callq  *%rax
  814e92:	89 c2                	mov    %eax,%edx
  814e94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814e98:	66 89 50 10          	mov    %dx,0x10(%rax)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  814e9c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814ea0:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  814ea4:	0f b6 d0             	movzbl %al,%edx
  814ea7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814eab:	48 8d 78 04          	lea    0x4(%rax),%rdi
  814eaf:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  814eb3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814eb7:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  814ebd:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  814ec3:	89 d1                	mov    %edx,%ecx
  814ec5:	48 89 fa             	mov    %rdi,%rdx
  814ec8:	48 89 c7             	mov    %rax,%rdi
  814ecb:	48 b8 80 16 81 00 00 	movabs $0x811680,%rax
  814ed2:	00 00 00 
  814ed5:	ff d0                	callq  *%rax
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  814ed7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814edb:	48 89 c7             	mov    %rax,%rdi
  814ede:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  814ee5:	00 00 00 
  814ee8:	ff d0                	callq  *%rax
  814eea:	eb 04                	jmp    814ef0 <tcp_zero_window_probe+0x272>

  if(seg == NULL)
    seg = pcb->unsent;

  if(seg == NULL)
    return;
  814eec:	90                   	nop
  814eed:	eb 01                	jmp    814ef0 <tcp_zero_window_probe+0x272>

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
   
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  814eef:	90                   	nop
  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  814ef0:	c9                   	leaveq 
  814ef1:	c3                   	retq   

0000000000814ef2 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  814ef2:	55                   	push   %rbp
  814ef3:	48 89 e5             	mov    %rsp,%rbp
  814ef6:	53                   	push   %rbx
  814ef7:	48 83 ec 58          	sub    $0x58,%rsp
  814efb:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  814eff:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  814f03:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814f07:	48 8b 40 08          	mov    0x8(%rax),%rax
  814f0b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  814f0f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814f13:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  814f17:	0f b7 d8             	movzwl %ax,%ebx
  814f1a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814f1e:	0f b7 00             	movzwl (%rax),%eax
  814f21:	0f b7 c0             	movzwl %ax,%eax
  814f24:	89 c7                	mov    %eax,%edi
  814f26:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  814f2d:	00 00 00 
  814f30:	ff d0                	callq  *%rax
  814f32:	66 c1 e8 08          	shr    $0x8,%ax
  814f36:	0f b7 c0             	movzwl %ax,%eax
  814f39:	83 e0 0f             	and    $0xf,%eax
  814f3c:	83 c0 02             	add    $0x2,%eax
  814f3f:	c1 e0 02             	shl    $0x2,%eax
  814f42:	39 c3                	cmp    %eax,%ebx
  814f44:	7c 40                	jl     814f86 <udp_input+0x94>
  814f46:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814f4a:	0f b7 00             	movzwl (%rax),%eax
  814f4d:	0f b7 c0             	movzwl %ax,%eax
  814f50:	89 c7                	mov    %eax,%edi
  814f52:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  814f59:	00 00 00 
  814f5c:	ff d0                	callq  *%rax
  814f5e:	66 c1 e8 08          	shr    $0x8,%ax
  814f62:	83 e0 0f             	and    $0xf,%eax
  814f65:	c1 e0 02             	shl    $0x2,%eax
  814f68:	f7 d8                	neg    %eax
  814f6a:	0f bf d0             	movswl %ax,%edx
  814f6d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814f71:	89 d6                	mov    %edx,%esi
  814f73:	48 89 c7             	mov    %rax,%rdi
  814f76:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  814f7d:	00 00 00 
  814f80:	ff d0                	callq  *%rax
  814f82:	84 c0                	test   %al,%al
  814f84:	74 18                	je     814f9e <udp_input+0xac>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  814f86:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814f8a:	48 89 c7             	mov    %rax,%rdi
  814f8d:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  814f94:	00 00 00 
  814f97:	ff d0                	callq  *%rax
    goto end;
  814f99:	e9 65 04 00 00       	jmpq   815403 <udp_input+0x511>
  }

  udphdr = (struct udp_hdr *)p->payload;
  814f9e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814fa2:	48 8b 40 08          	mov    0x8(%rax),%rax
  814fa6:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  814faa:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  814fae:	0f b7 00             	movzwl (%rax),%eax
  814fb1:	0f b7 c0             	movzwl %ax,%eax
  814fb4:	89 c7                	mov    %eax,%edi
  814fb6:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  814fbd:	00 00 00 
  814fc0:	ff d0                	callq  *%rax
  814fc2:	66 89 45 be          	mov    %ax,-0x42(%rbp)
  dest = ntohs(udphdr->dest);
  814fc6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  814fca:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  814fce:	0f b7 c0             	movzwl %ax,%eax
  814fd1:	89 c7                	mov    %eax,%edi
  814fd3:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  814fda:	00 00 00 
  814fdd:	ff d0                	callq  *%rax
  814fdf:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
               ip4_addr3(&iphdr->dest), ip4_addr4(&iphdr->dest), ntohs(udphdr->dest),
               ip4_addr1(&iphdr->src), ip4_addr2(&iphdr->src),
               ip4_addr3(&iphdr->src), ip4_addr4(&iphdr->src), ntohs(udphdr->src)));

#if LWIP_DHCP
  pcb = NULL;
  814fe3:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  814fea:	00 
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  814feb:	66 83 7d bc 44       	cmpw   $0x44,-0x44(%rbp)
  814ff0:	0f 85 8c 00 00 00    	jne    815082 <udp_input+0x190>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  814ff6:	66 83 7d be 43       	cmpw   $0x43,-0x42(%rbp)
  814ffb:	0f 85 d6 01 00 00    	jne    8151d7 <udp_input+0x2e5>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  815001:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  815005:	48 8b 40 38          	mov    0x38(%rax),%rax
  815009:	48 85 c0             	test   %rax,%rax
  81500c:	0f 84 c5 01 00 00    	je     8151d7 <udp_input+0x2e5>
  815012:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  815016:	48 8b 40 38          	mov    0x38(%rax),%rax
  81501a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81501e:	48 85 c0             	test   %rax,%rax
  815021:	0f 84 b0 01 00 00    	je     8151d7 <udp_input+0x2e5>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  815027:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  81502b:	48 8b 40 38          	mov    0x38(%rax),%rax
  81502f:	48 8b 40 08          	mov    0x8(%rax),%rax
  815033:	48 83 c0 04          	add    $0x4,%rax
  815037:	48 85 c0             	test   %rax,%rax
  81503a:	74 31                	je     81506d <udp_input+0x17b>
  81503c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  815040:	48 8b 40 38          	mov    0x38(%rax),%rax
  815044:	48 8b 40 08          	mov    0x8(%rax),%rax
  815048:	8b 40 04             	mov    0x4(%rax),%eax
  81504b:	85 c0                	test   %eax,%eax
  81504d:	74 1e                	je     81506d <udp_input+0x17b>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
  81504f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  815053:	48 8b 40 38          	mov    0x38(%rax),%rax
  815057:	48 8b 40 08          	mov    0x8(%rax),%rax
  81505b:	8b 50 04             	mov    0x4(%rax),%edx
  81505e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815062:	8b 40 0c             	mov    0xc(%rax),%eax
    if (src == DHCP_SERVER_PORT) {
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  815065:	39 c2                	cmp    %eax,%edx
  815067:	0f 85 6a 01 00 00    	jne    8151d7 <udp_input+0x2e5>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
          pcb = inp->dhcp->pcb;
  81506d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  815071:	48 8b 40 38          	mov    0x38(%rax),%rax
  815075:	48 8b 40 08          	mov    0x8(%rax),%rax
  815079:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81507d:	e9 55 01 00 00       	jmpq   8151d7 <udp_input+0x2e5>
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  815082:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  815089:	00 
    local_match = 0;
  81508a:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
    uncon_pcb = NULL;
  81508e:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  815095:	00 
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  815096:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  81509d:	00 00 00 
  8150a0:	48 8b 00             	mov    (%rax),%rax
  8150a3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8150a7:	e9 0e 01 00 00       	jmpq   8151ba <udp_input+0x2c8>
      local_match = 0;
  8150ac:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  8150b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8150b4:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  8150b8:	66 3b 45 bc          	cmp    -0x44(%rbp),%ax
  8150bc:	75 6b                	jne    815129 <udp_input+0x237>
          (ip_addr_isany(&pcb->local_ip) ||
  8150be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  8150c2:	48 85 c0             	test   %rax,%rax
  8150c5:	74 3d                	je     815104 <udp_input+0x212>
          (ip_addr_isany(&pcb->local_ip) ||
  8150c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8150cb:	8b 00                	mov    (%rax),%eax
  8150cd:	85 c0                	test   %eax,%eax
  8150cf:	74 33                	je     815104 <udp_input+0x212>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  8150d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8150d5:	8b 10                	mov    (%rax),%edx
  8150d7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8150db:	8b 40 10             	mov    0x10(%rax),%eax
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
  8150de:	39 c2                	cmp    %eax,%edx
  8150e0:	74 22                	je     815104 <udp_input+0x212>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  8150e2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8150e6:	48 8d 50 10          	lea    0x10(%rax),%rdx
  8150ea:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8150ee:	48 89 c6             	mov    %rax,%rsi
  8150f1:	48 89 d7             	mov    %rdx,%rdi
  8150f4:	48 b8 eb 0d 81 00 00 	movabs $0x810deb,%rax
  8150fb:	00 00 00 
  8150fe:	ff d0                	callq  *%rax
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  815100:	84 c0                	test   %al,%al
  815102:	74 25                	je     815129 <udp_input+0x237>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
  815104:	c6 45 d7 01          	movb   $0x1,-0x29(%rbp)
        if ((uncon_pcb == NULL) && 
  815108:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81510d:	75 1a                	jne    815129 <udp_input+0x237>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
  81510f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815113:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  815117:	0f b6 c0             	movzbl %al,%eax
  81511a:	83 e0 04             	and    $0x4,%eax
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  81511d:	85 c0                	test   %eax,%eax
  81511f:	75 08                	jne    815129 <udp_input+0x237>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
  815121:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815125:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  815129:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81512d:	74 77                	je     8151a6 <udp_input+0x2b4>
          (pcb->remote_port == src) &&
  81512f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815133:	0f b7 40 1c          	movzwl 0x1c(%rax),%eax
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  815137:	66 3b 45 be          	cmp    -0x42(%rbp),%ax
  81513b:	75 69                	jne    8151a6 <udp_input+0x2b4>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  81513d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815141:	48 83 c0 04          	add    $0x4,%rax
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  815145:	48 85 c0             	test   %rax,%rax
  815148:	74 1d                	je     815167 <udp_input+0x275>
          (ip_addr_isany(&pcb->remote_ip) ||
  81514a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81514e:	8b 40 04             	mov    0x4(%rax),%eax
  815151:	85 c0                	test   %eax,%eax
  815153:	74 12                	je     815167 <udp_input+0x275>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
  815155:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815159:	8b 50 04             	mov    0x4(%rax),%edx
  81515c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815160:	8b 40 0c             	mov    0xc(%rax),%eax
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  815163:	39 c2                	cmp    %eax,%edx
  815165:	75 3f                	jne    8151a6 <udp_input+0x2b4>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  815167:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81516c:	74 59                	je     8151c7 <udp_input+0x2d5>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  81516e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815172:	48 8b 50 10          	mov    0x10(%rax),%rdx
  815176:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81517a:	48 89 50 10          	mov    %rdx,0x10(%rax)
          pcb->next = udp_pcbs;
  81517e:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815185:	00 00 00 
  815188:	48 8b 10             	mov    (%rax),%rdx
  81518b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81518f:	48 89 50 10          	mov    %rdx,0x10(%rax)
          udp_pcbs = pcb;
  815193:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  81519a:	00 00 00 
  81519d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8151a1:	48 89 10             	mov    %rdx,(%rax)
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
  8151a4:	eb 21                	jmp    8151c7 <udp_input+0x2d5>
      }
      prev = pcb;
  8151a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8151aa:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8151ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8151b2:	48 8b 40 10          	mov    0x10(%rax),%rax
  8151b6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8151ba:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8151bf:	0f 85 e7 fe ff ff    	jne    8150ac <udp_input+0x1ba>
  8151c5:	eb 01                	jmp    8151c8 <udp_input+0x2d6>
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
  8151c7:	90                   	nop
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
  8151c8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8151cd:	75 08                	jne    8151d7 <udp_input+0x2e5>
      pcb = uncon_pcb;
  8151cf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8151d3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  8151d7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8151dc:	75 16                	jne    8151f4 <udp_input+0x302>
  8151de:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8151e2:	8b 50 08             	mov    0x8(%rax),%edx
  8151e5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8151e9:	8b 40 10             	mov    0x10(%rax),%eax
  8151ec:	39 c2                	cmp    %eax,%edx
  8151ee:	0f 85 fc 01 00 00    	jne    8153f0 <udp_input+0x4fe>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  8151f4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8151f8:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  8151fc:	66 85 c0             	test   %ax,%ax
  8151ff:	74 53                	je     815254 <udp_input+0x362>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
                               (struct ip_addr *)&(iphdr->dest),
                               IP_PROTO_UDP, p->tot_len) != 0) {
  815201:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  815205:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  815209:	0f b7 c8             	movzwl %ax,%ecx
  81520c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815210:	48 8d 50 10          	lea    0x10(%rax),%rdx
  815214:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815218:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  81521c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  815220:	41 89 c8             	mov    %ecx,%r8d
  815223:	b9 11 00 00 00       	mov    $0x11,%ecx
  815228:	48 89 c7             	mov    %rax,%rdi
  81522b:	48 b8 93 28 81 00 00 	movabs $0x812893,%rax
  815232:	00 00 00 
  815235:	ff d0                	callq  *%rax
  815237:	66 85 c0             	test   %ax,%ax
  81523a:	74 18                	je     815254 <udp_input+0x362>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  81523c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  815240:	48 89 c7             	mov    %rax,%rdi
  815243:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81524a:	00 00 00 
  81524d:	ff d0                	callq  *%rax
          goto end;
  81524f:	e9 af 01 00 00       	jmpq   815403 <udp_input+0x511>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  815254:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  815258:	be f8 ff ff ff       	mov    $0xfffffff8,%esi
  81525d:	48 89 c7             	mov    %rax,%rdi
  815260:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  815267:	00 00 00 
  81526a:	ff d0                	callq  *%rax
  81526c:	84 c0                	test   %al,%al
  81526e:	74 2a                	je     81529a <udp_input+0x3a8>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  815270:	48 ba c8 2c 82 00 00 	movabs $0x822cc8,%rdx
  815277:	00 00 00 
  81527a:	be 0b 01 00 00       	mov    $0x10b,%esi
  81527f:	48 bf dc 2c 82 00 00 	movabs $0x822cdc,%rdi
  815286:	00 00 00 
  815289:	b8 00 00 00 00       	mov    $0x0,%eax
  81528e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  815295:	00 00 00 
  815298:	ff d1                	callq  *%rcx
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  81529a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81529f:	74 51                	je     8152f2 <udp_input+0x400>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  8152a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8152a5:	48 8b 40 20          	mov    0x20(%rax),%rax
  8152a9:	48 85 c0             	test   %rax,%rax
  8152ac:	74 2c                	je     8152da <udp_input+0x3e8>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  8152ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8152b2:	48 8b 40 20          	mov    0x20(%rax),%rax
  8152b6:	44 0f b7 45 be       	movzwl -0x42(%rbp),%r8d
  8152bb:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8152bf:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  8152c3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8152c7:	48 8b 7a 28          	mov    0x28(%rdx),%rdi
  8152cb:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8152cf:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8152d3:	ff d0                	callq  *%rax
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  8152d5:	e9 29 01 00 00       	jmpq   815403 <udp_input+0x511>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  8152da:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8152de:	48 89 c7             	mov    %rax,%rdi
  8152e1:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  8152e8:	00 00 00 
  8152eb:	ff d0                	callq  *%rax
        goto end;
  8152ed:	e9 11 01 00 00       	jmpq   815403 <udp_input+0x511>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  8152f2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8152f6:	48 8d 50 10          	lea    0x10(%rax),%rdx
  8152fa:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8152fe:	48 89 c6             	mov    %rax,%rsi
  815301:	48 89 d7             	mov    %rdx,%rdi
  815304:	48 b8 eb 0d 81 00 00 	movabs $0x810deb,%rax
  81530b:	00 00 00 
  81530e:	ff d0                	callq  *%rax
  815310:	84 c0                	test   %al,%al
  815312:	0f 85 c3 00 00 00    	jne    8153db <udp_input+0x4e9>
          !ip_addr_ismulticast(&iphdr->dest)) {
  815318:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81531c:	8b 58 10             	mov    0x10(%rax),%ebx
  81531f:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  815324:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  81532b:	00 00 00 
  81532e:	ff d0                	callq  *%rax
  815330:	21 c3                	and    %eax,%ebx
  815332:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  815337:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  81533e:	00 00 00 
  815341:	ff d0                	callq  *%rax
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  815343:	39 c3                	cmp    %eax,%ebx
  815345:	0f 84 90 00 00 00    	je     8153db <udp_input+0x4e9>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  81534b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81534f:	0f b7 00             	movzwl (%rax),%eax
  815352:	0f b7 c0             	movzwl %ax,%eax
  815355:	89 c7                	mov    %eax,%edi
  815357:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81535e:	00 00 00 
  815361:	ff d0                	callq  *%rax
  815363:	66 c1 e8 08          	shr    $0x8,%ax
  815367:	0f b7 c0             	movzwl %ax,%eax
  81536a:	83 e0 0f             	and    $0xf,%eax
  81536d:	83 c0 02             	add    $0x2,%eax
  815370:	c1 e0 02             	shl    $0x2,%eax
  815373:	0f bf d0             	movswl %ax,%edx
  815376:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81537a:	89 d6                	mov    %edx,%esi
  81537c:	48 89 c7             	mov    %rax,%rdi
  81537f:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  815386:	00 00 00 
  815389:	ff d0                	callq  *%rax
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  81538b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81538f:	48 8b 40 08          	mov    0x8(%rax),%rax
  815393:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  815397:	74 2a                	je     8153c3 <udp_input+0x4d1>
  815399:	48 ba f0 2c 82 00 00 	movabs $0x822cf0,%rdx
  8153a0:	00 00 00 
  8153a3:	be 26 01 00 00       	mov    $0x126,%esi
  8153a8:	48 bf dc 2c 82 00 00 	movabs $0x822cdc,%rdi
  8153af:	00 00 00 
  8153b2:	b8 00 00 00 00       	mov    $0x0,%eax
  8153b7:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8153be:	00 00 00 
  8153c1:	ff d1                	callq  *%rcx
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  8153c3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8153c7:	be 03 00 00 00       	mov    $0x3,%esi
  8153cc:	48 89 c7             	mov    %rax,%rdi
  8153cf:	48 b8 5a 09 82 00 00 	movabs $0x82095a,%rax
  8153d6:	00 00 00 
  8153d9:	ff d0                	callq  *%rax
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  8153db:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8153df:	48 89 c7             	mov    %rax,%rdi
  8153e2:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  8153e9:	00 00 00 
  8153ec:	ff d0                	callq  *%rax
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  8153ee:	eb 13                	jmp    815403 <udp_input+0x511>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
    }
  } else {
    pbuf_free(p);
  8153f0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8153f4:	48 89 c7             	mov    %rax,%rdi
  8153f7:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  8153fe:	00 00 00 
  815401:	ff d0                	callq  *%rax
  }
end:
  PERF_STOP("udp_input");
}
  815403:	90                   	nop
  815404:	48 83 c4 58          	add    $0x58,%rsp
  815408:	5b                   	pop    %rbx
  815409:	5d                   	pop    %rbp
  81540a:	c3                   	retq   

000000000081540b <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  81540b:	55                   	push   %rbp
  81540c:	48 89 e5             	mov    %rsp,%rbp
  81540f:	48 83 ec 10          	sub    $0x10,%rsp
  815413:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  815417:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  81541b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81541f:	0f b7 40 1c          	movzwl 0x1c(%rax),%eax
  815423:	0f b7 d0             	movzwl %ax,%edx
  815426:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81542a:	48 8d 78 04          	lea    0x4(%rax),%rdi
  81542e:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  815432:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815436:	89 d1                	mov    %edx,%ecx
  815438:	48 89 fa             	mov    %rdi,%rdx
  81543b:	48 89 c7             	mov    %rax,%rdi
  81543e:	48 b8 4c 54 81 00 00 	movabs $0x81544c,%rax
  815445:	00 00 00 
  815448:	ff d0                	callq  *%rax
}
  81544a:	c9                   	leaveq 
  81544b:	c3                   	retq   

000000000081544c <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  81544c:	55                   	push   %rbp
  81544d:	48 89 e5             	mov    %rsp,%rbp
  815450:	48 83 ec 30          	sub    $0x30,%rsp
  815454:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  815458:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81545c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  815460:	89 c8                	mov    %ecx,%eax
  815462:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  815466:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81546a:	48 89 c7             	mov    %rax,%rdi
  81546d:	48 b8 88 0e 81 00 00 	movabs $0x810e88,%rax
  815474:	00 00 00 
  815477:	ff d0                	callq  *%rax
  815479:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  81547d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815482:	75 07                	jne    81548b <udp_sendto+0x3f>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  815484:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  815489:	eb 26                	jmp    8154b1 <udp_sendto+0x65>
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  81548b:	0f b7 4d d4          	movzwl -0x2c(%rbp),%ecx
  81548f:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  815493:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  815497:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  81549b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81549f:	49 89 f8             	mov    %rdi,%r8
  8154a2:	48 89 c7             	mov    %rax,%rdi
  8154a5:	48 b8 b3 54 81 00 00 	movabs $0x8154b3,%rax
  8154ac:	00 00 00 
  8154af:	ff d0                	callq  *%rax
}
  8154b1:	c9                   	leaveq 
  8154b2:	c3                   	retq   

00000000008154b3 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  8154b3:	55                   	push   %rbp
  8154b4:	48 89 e5             	mov    %rsp,%rbp
  8154b7:	48 83 ec 50          	sub    $0x50,%rsp
  8154bb:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8154bf:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8154c3:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8154c7:	89 c8                	mov    %ecx,%eax
  8154c9:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  8154cd:	66 89 45 c4          	mov    %ax,-0x3c(%rbp)
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  8154d1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8154d5:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  8154d9:	66 85 c0             	test   %ax,%ax
  8154dc:	75 37                	jne    815515 <udp_sendto_if+0x62>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  8154de:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8154e2:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  8154e6:	0f b7 d0             	movzwl %ax,%edx
  8154e9:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8154ed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8154f1:	48 89 ce             	mov    %rcx,%rsi
  8154f4:	48 89 c7             	mov    %rax,%rdi
  8154f7:	48 b8 71 57 81 00 00 	movabs $0x815771,%rax
  8154fe:	00 00 00 
  815501:	ff d0                	callq  *%rax
  815503:	88 45 ef             	mov    %al,-0x11(%rbp)
    if (err != ERR_OK) {
  815506:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  81550a:	74 09                	je     815515 <udp_sendto_if+0x62>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: forced port bind failed\n"));
      return err;
  81550c:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  815510:	e9 5a 02 00 00       	jmpq   81576f <udp_sendto_if+0x2bc>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  815515:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  815519:	be 08 00 00 00       	mov    $0x8,%esi
  81551e:	48 89 c7             	mov    %rax,%rdi
  815521:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  815528:	00 00 00 
  81552b:	ff d0                	callq  *%rax
  81552d:	84 c0                	test   %al,%al
  81552f:	74 4c                	je     81557d <udp_sendto_if+0xca>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  815531:	ba 00 00 00 00       	mov    $0x0,%edx
  815536:	be 08 00 00 00       	mov    $0x8,%esi
  81553b:	bf 01 00 00 00       	mov    $0x1,%edi
  815540:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  815547:	00 00 00 
  81554a:	ff d0                	callq  *%rax
  81554c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  815550:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  815555:	75 0a                	jne    815561 <udp_sendto_if+0xae>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  815557:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81555c:	e9 0e 02 00 00       	jmpq   81576f <udp_sendto_if+0x2bc>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  815561:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  815565:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815569:	48 89 d6             	mov    %rdx,%rsi
  81556c:	48 89 c7             	mov    %rax,%rdi
  81556f:	48 b8 f4 e0 80 00 00 	movabs $0x80e0f4,%rax
  815576:	00 00 00 
  815579:	ff d0                	callq  *%rax
  81557b:	eb 08                	jmp    815585 <udp_sendto_if+0xd2>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  81557d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  815581:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  815585:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815589:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81558d:	66 83 f8 07          	cmp    $0x7,%ax
  815591:	77 2a                	ja     8155bd <udp_sendto_if+0x10a>
  815593:	48 ba 08 2d 82 00 00 	movabs $0x822d08,%rdx
  81559a:	00 00 00 
  81559d:	be b3 01 00 00       	mov    $0x1b3,%esi
  8155a2:	48 bf dc 2c 82 00 00 	movabs $0x822cdc,%rdi
  8155a9:	00 00 00 
  8155ac:	b8 00 00 00 00       	mov    $0x0,%eax
  8155b1:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8155b8:	00 00 00 
  8155bb:	ff d1                	callq  *%rcx
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  8155bd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8155c1:	48 8b 40 08          	mov    0x8(%rax),%rax
  8155c5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  udphdr->src = htons(pcb->local_port);
  8155c9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8155cd:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  8155d1:	0f b7 c0             	movzwl %ax,%eax
  8155d4:	89 c7                	mov    %eax,%edi
  8155d6:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8155dd:	00 00 00 
  8155e0:	ff d0                	callq  *%rax
  8155e2:	89 c2                	mov    %eax,%edx
  8155e4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8155e8:	66 89 10             	mov    %dx,(%rax)
  udphdr->dest = htons(dst_port);
  8155eb:	0f b7 45 c4          	movzwl -0x3c(%rbp),%eax
  8155ef:	89 c7                	mov    %eax,%edi
  8155f1:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8155f8:	00 00 00 
  8155fb:	ff d0                	callq  *%rax
  8155fd:	89 c2                	mov    %eax,%edx
  8155ff:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815603:	66 89 50 02          	mov    %dx,0x2(%rax)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  815607:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81560b:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  815611:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815615:	48 85 c0             	test   %rax,%rax
  815618:	74 0a                	je     815624 <udp_sendto_if+0x171>
  81561a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81561e:	8b 00                	mov    (%rax),%eax
  815620:	85 c0                	test   %eax,%eax
  815622:	75 0e                	jne    815632 <udp_sendto_if+0x17f>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  815624:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  815628:	48 83 c0 08          	add    $0x8,%rax
  81562c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  815630:	eb 48                	jmp    81567a <udp_sendto_if+0x1c7>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  815632:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815636:	8b 10                	mov    (%rax),%edx
  815638:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81563c:	8b 40 08             	mov    0x8(%rax),%eax
  81563f:	39 c2                	cmp    %eax,%edx
  815641:	74 2f                	je     815672 <udp_sendto_if+0x1bf>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  815643:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815647:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  81564b:	74 1b                	je     815668 <udp_sendto_if+0x1b5>
        /* free the header pbuf */
        pbuf_free(q);
  81564d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815651:	48 89 c7             	mov    %rax,%rdi
  815654:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81565b:	00 00 00 
  81565e:	ff d0                	callq  *%rax
        q = NULL;
  815660:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  815667:	00 
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  815668:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  81566d:	e9 fd 00 00 00       	jmpq   81576f <udp_sendto_if+0x2bc>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  815672:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815676:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  81567a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81567e:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  815682:	0f b7 c0             	movzwl %ax,%eax
  815685:	89 c7                	mov    %eax,%edi
  815687:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  81568e:	00 00 00 
  815691:	ff d0                	callq  *%rax
  815693:	89 c2                	mov    %eax,%edx
  815695:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815699:	66 89 50 04          	mov    %dx,0x4(%rax)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  81569d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8156a1:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8156a5:	0f b6 c0             	movzbl %al,%eax
  8156a8:	83 e0 01             	and    $0x1,%eax
  8156ab:	85 c0                	test   %eax,%eax
  8156ad:	75 4f                	jne    8156fe <udp_sendto_if+0x24b>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  8156af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8156b3:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8156b7:	0f b7 c8             	movzwl %ax,%ecx
  8156ba:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8156be:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8156c2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8156c6:	41 89 c8             	mov    %ecx,%r8d
  8156c9:	b9 11 00 00 00       	mov    $0x11,%ecx
  8156ce:	48 89 c7             	mov    %rax,%rdi
  8156d1:	48 b8 93 28 81 00 00 	movabs $0x812893,%rax
  8156d8:	00 00 00 
  8156db:	ff d0                	callq  *%rax
  8156dd:	89 c2                	mov    %eax,%edx
  8156df:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8156e3:	66 89 50 06          	mov    %dx,0x6(%rax)
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  8156e7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8156eb:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  8156ef:	66 85 c0             	test   %ax,%ax
  8156f2:	75 0a                	jne    8156fe <udp_sendto_if+0x24b>
  8156f4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8156f8:	66 c7 40 06 ff ff    	movw   $0xffff,0x6(%rax)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  8156fe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815702:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  815706:	0f b6 f8             	movzbl %al,%edi
  815709:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81570d:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  815711:	0f b6 c8             	movzbl %al,%ecx
  815714:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  815718:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81571c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815720:	48 83 ec 08          	sub    $0x8,%rsp
  815724:	ff 75 b8             	pushq  -0x48(%rbp)
  815727:	41 b9 11 00 00 00    	mov    $0x11,%r9d
  81572d:	41 89 f8             	mov    %edi,%r8d
  815730:	48 89 c7             	mov    %rax,%rdi
  815733:	48 b8 be 13 81 00 00 	movabs $0x8113be,%rax
  81573a:	00 00 00 
  81573d:	ff d0                	callq  *%rax
  81573f:	48 83 c4 10          	add    $0x10,%rsp
  815743:	88 45 ef             	mov    %al,-0x11(%rbp)
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  815746:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81574a:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  81574e:	74 1b                	je     81576b <udp_sendto_if+0x2b8>
    /* free the header pbuf */
    pbuf_free(q);
  815750:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815754:	48 89 c7             	mov    %rax,%rdi
  815757:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81575e:	00 00 00 
  815761:	ff d0                	callq  *%rax
    q = NULL;
  815763:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  81576a:	00 
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
  81576b:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  81576f:	c9                   	leaveq 
  815770:	c3                   	retq   

0000000000815771 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  815771:	55                   	push   %rbp
  815772:	48 89 e5             	mov    %rsp,%rbp
  815775:	48 83 ec 30          	sub    $0x30,%rsp
  815779:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81577d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  815781:	89 d0                	mov    %edx,%eax
  815783:	66 89 45 dc          	mov    %ax,-0x24(%rbp)

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  815787:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  81578b:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815792:	00 00 00 
  815795:	48 8b 00             	mov    (%rax),%rax
  815798:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81579c:	eb 4a                	jmp    8157e8 <udp_bind+0x77>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  81579e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8157a2:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8157a6:	75 34                	jne    8157dc <udp_bind+0x6b>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  8157a8:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  8157ac:	74 2a                	je     8157d8 <udp_bind+0x67>
  8157ae:	48 ba 36 2d 82 00 00 	movabs $0x822d36,%rdx
  8157b5:	00 00 00 
  8157b8:	be 42 02 00 00       	mov    $0x242,%esi
  8157bd:	48 bf dc 2c 82 00 00 	movabs $0x822cdc,%rdi
  8157c4:	00 00 00 
  8157c7:	b8 00 00 00 00       	mov    $0x0,%eax
  8157cc:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8157d3:	00 00 00 
  8157d6:	ff d1                	callq  *%rcx
      /* pcb already in list, just rebind */
      rebind = 1;
  8157d8:	c6 45 f7 01          	movb   $0x1,-0x9(%rbp)
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8157dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8157e0:	48 8b 40 10          	mov    0x10(%rax),%rax
  8157e4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8157e8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8157ed:	75 af                	jne    81579e <udp_bind+0x2d>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  8157ef:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8157f4:	74 08                	je     8157fe <udp_bind+0x8d>
  8157f6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8157fa:	8b 00                	mov    (%rax),%eax
  8157fc:	eb 05                	jmp    815803 <udp_bind+0x92>
  8157fe:	b8 00 00 00 00       	mov    $0x0,%eax
  815803:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  815807:	89 02                	mov    %eax,(%rdx)

  /* no port specified? */
  if (port == 0) {
  815809:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  81580e:	75 6e                	jne    81587e <udp_bind+0x10d>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  815810:	66 c7 45 dc 00 10    	movw   $0x1000,-0x24(%rbp)
    ipcb = udp_pcbs;
  815816:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  81581d:	00 00 00 
  815820:	48 8b 00             	mov    (%rax),%rax
  815823:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  815827:	eb 38                	jmp    815861 <udp_bind+0xf0>
      if (ipcb->local_port == port) {
  815829:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81582d:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815831:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  815835:	75 1e                	jne    815855 <udp_bind+0xe4>
        /* port is already used by another udp_pcb */
        port++;
  815837:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  81583b:	83 c0 01             	add    $0x1,%eax
  81583e:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  815842:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815849:	00 00 00 
  81584c:	48 8b 00             	mov    (%rax),%rax
  81584f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  815853:	eb 0c                	jmp    815861 <udp_bind+0xf0>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  815855:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815859:	48 8b 40 10          	mov    0x10(%rax),%rax
  81585d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  815861:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815866:	74 08                	je     815870 <udp_bind+0xff>
  815868:	66 81 7d dc ff 7f    	cmpw   $0x7fff,-0x24(%rbp)
  81586e:	75 b9                	jne    815829 <udp_bind+0xb8>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  815870:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815875:	74 07                	je     81587e <udp_bind+0x10d>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  815877:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  81587c:	eb 3d                	jmp    8158bb <udp_bind+0x14a>
    }
  }
  pcb->local_port = port;
  81587e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815882:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  815886:	66 89 50 1a          	mov    %dx,0x1a(%rax)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  81588a:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  81588e:	75 26                	jne    8158b6 <udp_bind+0x145>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  815890:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815897:	00 00 00 
  81589a:	48 8b 10             	mov    (%rax),%rdx
  81589d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8158a1:	48 89 50 10          	mov    %rdx,0x10(%rax)
    udp_pcbs = pcb;
  8158a5:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8158ac:	00 00 00 
  8158af:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8158b3:	48 89 10             	mov    %rdx,(%rax)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  8158b6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8158bb:	c9                   	leaveq 
  8158bc:	c3                   	retq   

00000000008158bd <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8158bd:	55                   	push   %rbp
  8158be:	48 89 e5             	mov    %rsp,%rbp
  8158c1:	48 83 ec 30          	sub    $0x30,%rsp
  8158c5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8158c9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8158cd:	89 d0                	mov    %edx,%eax
  8158cf:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  8158d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8158d7:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  8158db:	66 85 c0             	test   %ax,%ax
  8158de:	75 37                	jne    815917 <udp_connect+0x5a>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  8158e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8158e4:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  8158e8:	0f b7 d0             	movzwl %ax,%edx
  8158eb:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8158ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8158f3:	48 89 ce             	mov    %rcx,%rsi
  8158f6:	48 89 c7             	mov    %rax,%rdi
  8158f9:	48 b8 71 57 81 00 00 	movabs $0x815771,%rax
  815900:	00 00 00 
  815903:	ff d0                	callq  *%rax
  815905:	88 45 f7             	mov    %al,-0x9(%rbp)
    if (err != ERR_OK)
  815908:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  81590c:	74 09                	je     815917 <udp_connect+0x5a>
      return err;
  81590e:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  815912:	e9 9d 00 00 00       	jmpq   8159b4 <udp_connect+0xf7>
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  815917:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81591c:	74 08                	je     815926 <udp_connect+0x69>
  81591e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815922:	8b 00                	mov    (%rax),%eax
  815924:	eb 05                	jmp    81592b <udp_connect+0x6e>
  815926:	b8 00 00 00 00       	mov    $0x0,%eax
  81592b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81592f:	89 42 04             	mov    %eax,0x4(%rdx)
  pcb->remote_port = port;
  815932:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815936:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  81593a:	66 89 50 1c          	mov    %dx,0x1c(%rax)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  81593e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815942:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  815946:	83 c8 04             	or     $0x4,%eax
  815949:	89 c2                	mov    %eax,%edx
  81594b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81594f:	88 50 18             	mov    %dl,0x18(%rax)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  815952:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815959:	00 00 00 
  81595c:	48 8b 00             	mov    (%rax),%rax
  81595f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  815963:	eb 1d                	jmp    815982 <udp_connect+0xc5>
    if (pcb == ipcb) {
  815965:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815969:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  81596d:	75 07                	jne    815976 <udp_connect+0xb9>
      /* already on the list, just return */
      return ERR_OK;
  81596f:	b8 00 00 00 00       	mov    $0x0,%eax
  815974:	eb 3e                	jmp    8159b4 <udp_connect+0xf7>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  815976:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81597a:	48 8b 40 10          	mov    0x10(%rax),%rax
  81597e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  815982:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815987:	75 dc                	jne    815965 <udp_connect+0xa8>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  815989:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815990:	00 00 00 
  815993:	48 8b 10             	mov    (%rax),%rdx
  815996:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81599a:	48 89 50 10          	mov    %rdx,0x10(%rax)
  udp_pcbs = pcb;
  81599e:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8159a5:	00 00 00 
  8159a8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8159ac:	48 89 10             	mov    %rdx,(%rax)
  return ERR_OK;
  8159af:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8159b4:	c9                   	leaveq 
  8159b5:	c3                   	retq   

00000000008159b6 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  8159b6:	55                   	push   %rbp
  8159b7:	48 89 e5             	mov    %rsp,%rbp
  8159ba:	48 83 ec 08          	sub    $0x8,%rsp
  8159be:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  8159c2:	48 b8 e8 28 82 00 00 	movabs $0x8228e8,%rax
  8159c9:	00 00 00 
  8159cc:	8b 10                	mov    (%rax),%edx
  8159ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8159d2:	89 50 04             	mov    %edx,0x4(%rax)
  pcb->remote_port = 0;
  8159d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8159d9:	66 c7 40 1c 00 00    	movw   $0x0,0x1c(%rax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  8159df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8159e3:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8159e7:	83 e0 fb             	and    $0xfffffffb,%eax
  8159ea:	89 c2                	mov    %eax,%edx
  8159ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8159f0:	88 50 18             	mov    %dl,0x18(%rax)
}
  8159f3:	90                   	nop
  8159f4:	c9                   	leaveq 
  8159f5:	c3                   	retq   

00000000008159f6 <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  8159f6:	55                   	push   %rbp
  8159f7:	48 89 e5             	mov    %rsp,%rbp
  8159fa:	48 83 ec 18          	sub    $0x18,%rsp
  8159fe:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  815a02:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  815a06:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
  815a0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815a0e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  815a12:	48 89 50 20          	mov    %rdx,0x20(%rax)
  pcb->recv_arg = recv_arg;
  815a16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815a1a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  815a1e:	48 89 50 28          	mov    %rdx,0x28(%rax)
}
  815a22:	90                   	nop
  815a23:	c9                   	leaveq 
  815a24:	c3                   	retq   

0000000000815a25 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  815a25:	55                   	push   %rbp
  815a26:	48 89 e5             	mov    %rsp,%rbp
  815a29:	48 83 ec 20          	sub    $0x20,%rsp
  815a2d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  815a31:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815a38:	00 00 00 
  815a3b:	48 8b 00             	mov    (%rax),%rax
  815a3e:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  815a42:	75 20                	jne    815a64 <udp_remove+0x3f>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  815a44:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815a4b:	00 00 00 
  815a4e:	48 8b 00             	mov    (%rax),%rax
  815a51:	48 8b 50 10          	mov    0x10(%rax),%rdx
  815a55:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815a5c:	00 00 00 
  815a5f:	48 89 10             	mov    %rdx,(%rax)
  815a62:	eb 51                	jmp    815ab5 <udp_remove+0x90>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  815a64:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815a6b:	00 00 00 
  815a6e:	48 8b 00             	mov    (%rax),%rax
  815a71:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  815a75:	eb 37                	jmp    815aae <udp_remove+0x89>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  815a77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815a7b:	48 8b 40 10          	mov    0x10(%rax),%rax
  815a7f:	48 85 c0             	test   %rax,%rax
  815a82:	74 1e                	je     815aa2 <udp_remove+0x7d>
  815a84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815a88:	48 8b 40 10          	mov    0x10(%rax),%rax
  815a8c:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  815a90:	75 10                	jne    815aa2 <udp_remove+0x7d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  815a92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815a96:	48 8b 50 10          	mov    0x10(%rax),%rdx
  815a9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815a9e:	48 89 50 10          	mov    %rdx,0x10(%rax)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  815aa2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815aa6:	48 8b 40 10          	mov    0x10(%rax),%rax
  815aaa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  815aae:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815ab3:	75 c2                	jne    815a77 <udp_remove+0x52>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  815ab5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815ab9:	48 89 c6             	mov    %rax,%rsi
  815abc:	bf 01 00 00 00       	mov    $0x1,%edi
  815ac1:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  815ac8:	00 00 00 
  815acb:	ff d0                	callq  *%rax
}
  815acd:	90                   	nop
  815ace:	c9                   	leaveq 
  815acf:	c3                   	retq   

0000000000815ad0 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  815ad0:	55                   	push   %rbp
  815ad1:	48 89 e5             	mov    %rsp,%rbp
  815ad4:	48 83 ec 10          	sub    $0x10,%rsp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  815ad8:	bf 01 00 00 00       	mov    $0x1,%edi
  815add:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  815ae4:	00 00 00 
  815ae7:	ff d0                	callq  *%rax
  815ae9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  815aed:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815af2:	74 25                	je     815b19 <udp_new+0x49>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  815af4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815af8:	ba 30 00 00 00       	mov    $0x30,%edx
  815afd:	be 00 00 00 00       	mov    $0x0,%esi
  815b02:	48 89 c7             	mov    %rax,%rdi
  815b05:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  815b0c:	00 00 00 
  815b0f:	ff d0                	callq  *%rax
    pcb->ttl = UDP_TTL;
  815b11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815b15:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
  }
  return pcb;
  815b19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  815b1d:	c9                   	leaveq 
  815b1e:	c3                   	retq   

0000000000815b1f <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  815b1f:	55                   	push   %rbp
  815b20:	48 89 e5             	mov    %rsp,%rbp
  815b23:	48 83 ec 20          	sub    $0x20,%rsp
  815b27:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  815b2b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815b30:	75 2a                	jne    815b5c <free_etharp_q+0x3d>
  815b32:	48 ba 54 2d 82 00 00 	movabs $0x822d54,%rdx
  815b39:	00 00 00 
  815b3c:	be 94 00 00 00       	mov    $0x94,%esi
  815b41:	48 bf 5e 2d 82 00 00 	movabs $0x822d5e,%rdi
  815b48:	00 00 00 
  815b4b:	b8 00 00 00 00       	mov    $0x0,%eax
  815b50:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  815b57:	00 00 00 
  815b5a:	ff d1                	callq  *%rcx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  815b5c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815b60:	48 8b 40 08          	mov    0x8(%rax),%rax
  815b64:	48 85 c0             	test   %rax,%rax
  815b67:	0f 85 a3 00 00 00    	jne    815c10 <free_etharp_q+0xf1>
  815b6d:	48 ba 76 2d 82 00 00 	movabs $0x822d76,%rdx
  815b74:	00 00 00 
  815b77:	be 95 00 00 00       	mov    $0x95,%esi
  815b7c:	48 bf 5e 2d 82 00 00 	movabs $0x822d5e,%rdi
  815b83:	00 00 00 
  815b86:	b8 00 00 00 00       	mov    $0x0,%eax
  815b8b:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  815b92:	00 00 00 
  815b95:	ff d1                	callq  *%rcx
  while (q) {
    r = q;
  815b97:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815b9b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    q = q->next;
  815b9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815ba3:	48 8b 00             	mov    (%rax),%rax
  815ba6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  815baa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815bae:	48 8b 40 08          	mov    0x8(%rax),%rax
  815bb2:	48 85 c0             	test   %rax,%rax
  815bb5:	75 2a                	jne    815be1 <free_etharp_q+0xc2>
  815bb7:	48 ba 83 2d 82 00 00 	movabs $0x822d83,%rdx
  815bbe:	00 00 00 
  815bc1:	be 99 00 00 00       	mov    $0x99,%esi
  815bc6:	48 bf 5e 2d 82 00 00 	movabs $0x822d5e,%rdi
  815bcd:	00 00 00 
  815bd0:	b8 00 00 00 00       	mov    $0x0,%eax
  815bd5:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  815bdc:	00 00 00 
  815bdf:	ff d1                	callq  *%rcx
    pbuf_free(r->p);
  815be1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815be5:	48 8b 40 08          	mov    0x8(%rax),%rax
  815be9:	48 89 c7             	mov    %rax,%rdi
  815bec:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  815bf3:	00 00 00 
  815bf6:	ff d0                	callq  *%rax
    memp_free(MEMP_ARP_QUEUE, r);
  815bf8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815bfc:	48 89 c6             	mov    %rax,%rsi
  815bff:	bf 0a 00 00 00       	mov    $0xa,%edi
  815c04:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  815c0b:	00 00 00 
  815c0e:	ff d0                	callq  *%rax
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  815c10:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815c15:	75 80                	jne    815b97 <free_etharp_q+0x78>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  815c17:	90                   	nop
  815c18:	c9                   	leaveq 
  815c19:	c3                   	retq   

0000000000815c1a <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  815c1a:	55                   	push   %rbp
  815c1b:	48 89 e5             	mov    %rsp,%rbp
  815c1e:	48 83 ec 10          	sub    $0x10,%rsp
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815c22:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  815c26:	e9 d8 01 00 00       	jmpq   815e03 <etharp_tmr+0x1e9>
    arp_table[i].ctime++;
  815c2b:	0f b6 55 ff          	movzbl -0x1(%rbp),%edx
  815c2f:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815c36:	00 00 00 
  815c39:	48 63 ca             	movslq %edx,%rcx
  815c3c:	48 89 c8             	mov    %rcx,%rax
  815c3f:	48 c1 e0 02          	shl    $0x2,%rax
  815c43:	48 01 c8             	add    %rcx,%rax
  815c46:	48 c1 e0 03          	shl    $0x3,%rax
  815c4a:	48 01 f0             	add    %rsi,%rax
  815c4d:	48 83 c0 18          	add    $0x18,%rax
  815c51:	0f b6 00             	movzbl (%rax),%eax
  815c54:	8d 48 01             	lea    0x1(%rax),%ecx
  815c57:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815c5e:	00 00 00 
  815c61:	48 63 d2             	movslq %edx,%rdx
  815c64:	48 89 d0             	mov    %rdx,%rax
  815c67:	48 c1 e0 02          	shl    $0x2,%rax
  815c6b:	48 01 d0             	add    %rdx,%rax
  815c6e:	48 c1 e0 03          	shl    $0x3,%rax
  815c72:	48 01 f0             	add    %rsi,%rax
  815c75:	48 83 c0 18          	add    $0x18,%rax
  815c79:	88 08                	mov    %cl,(%rax)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  815c7b:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815c7f:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815c86:	00 00 00 
  815c89:	48 63 d0             	movslq %eax,%rdx
  815c8c:	48 89 d0             	mov    %rdx,%rax
  815c8f:	48 c1 e0 02          	shl    $0x2,%rax
  815c93:	48 01 d0             	add    %rdx,%rax
  815c96:	48 c1 e0 03          	shl    $0x3,%rax
  815c9a:	48 01 c8             	add    %rcx,%rax
  815c9d:	48 83 c0 14          	add    $0x14,%rax
  815ca1:	8b 00                	mov    (%rax),%eax
  815ca3:	83 f8 02             	cmp    $0x2,%eax
  815ca6:	75 2d                	jne    815cd5 <etharp_tmr+0xbb>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  815ca8:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815cac:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815cb3:	00 00 00 
  815cb6:	48 63 d0             	movslq %eax,%rdx
  815cb9:	48 89 d0             	mov    %rdx,%rax
  815cbc:	48 c1 e0 02          	shl    $0x2,%rax
  815cc0:	48 01 d0             	add    %rdx,%rax
  815cc3:	48 c1 e0 03          	shl    $0x3,%rax
  815cc7:	48 01 c8             	add    %rcx,%rax
  815cca:	48 83 c0 18          	add    $0x18,%rax
  815cce:	0f b6 00             	movzbl (%rax),%eax

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  815cd1:	3c ef                	cmp    $0xef,%al
  815cd3:	77 62                	ja     815d37 <etharp_tmr+0x11d>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  815cd5:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815cd9:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815ce0:	00 00 00 
  815ce3:	48 63 d0             	movslq %eax,%rdx
  815ce6:	48 89 d0             	mov    %rdx,%rax
  815ce9:	48 c1 e0 02          	shl    $0x2,%rax
  815ced:	48 01 d0             	add    %rdx,%rax
  815cf0:	48 c1 e0 03          	shl    $0x3,%rax
  815cf4:	48 01 c8             	add    %rcx,%rax
  815cf7:	48 83 c0 14          	add    $0x14,%rax
  815cfb:	8b 00                	mov    (%rax),%eax
  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  815cfd:	83 f8 01             	cmp    $0x1,%eax
  815d00:	0f 85 e4 00 00 00    	jne    815dea <etharp_tmr+0x1d0>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
         (arp_table[i].ctime >= ARP_MAXPENDING))) {
  815d06:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815d0a:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815d11:	00 00 00 
  815d14:	48 63 d0             	movslq %eax,%rdx
  815d17:	48 89 d0             	mov    %rdx,%rax
  815d1a:	48 c1 e0 02          	shl    $0x2,%rax
  815d1e:	48 01 d0             	add    %rdx,%rax
  815d21:	48 c1 e0 03          	shl    $0x3,%rax
  815d25:	48 01 c8             	add    %rcx,%rax
  815d28:	48 83 c0 18          	add    $0x18,%rax
  815d2c:	0f b6 00             	movzbl (%rax),%eax
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  815d2f:	3c 01                	cmp    $0x1,%al
  815d31:	0f 86 b3 00 00 00    	jbe    815dea <etharp_tmr+0x1d0>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  815d37:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815d3b:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815d42:	00 00 00 
  815d45:	48 63 d0             	movslq %eax,%rdx
  815d48:	48 89 d0             	mov    %rdx,%rax
  815d4b:	48 c1 e0 02          	shl    $0x2,%rax
  815d4f:	48 01 d0             	add    %rdx,%rax
  815d52:	48 c1 e0 03          	shl    $0x3,%rax
  815d56:	48 01 c8             	add    %rcx,%rax
  815d59:	48 8b 00             	mov    (%rax),%rax
  815d5c:	48 85 c0             	test   %rax,%rax
  815d5f:	74 5d                	je     815dbe <etharp_tmr+0x1a4>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  815d61:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815d65:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815d6c:	00 00 00 
  815d6f:	48 63 d0             	movslq %eax,%rdx
  815d72:	48 89 d0             	mov    %rdx,%rax
  815d75:	48 c1 e0 02          	shl    $0x2,%rax
  815d79:	48 01 d0             	add    %rdx,%rax
  815d7c:	48 c1 e0 03          	shl    $0x3,%rax
  815d80:	48 01 c8             	add    %rcx,%rax
  815d83:	48 8b 00             	mov    (%rax),%rax
  815d86:	48 89 c7             	mov    %rax,%rdi
  815d89:	48 b8 1f 5b 81 00 00 	movabs $0x815b1f,%rax
  815d90:	00 00 00 
  815d93:	ff d0                	callq  *%rax
        arp_table[i].q = NULL;
  815d95:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815d99:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815da0:	00 00 00 
  815da3:	48 63 d0             	movslq %eax,%rdx
  815da6:	48 89 d0             	mov    %rdx,%rax
  815da9:	48 c1 e0 02          	shl    $0x2,%rax
  815dad:	48 01 d0             	add    %rdx,%rax
  815db0:	48 c1 e0 03          	shl    $0x3,%rax
  815db4:	48 01 c8             	add    %rcx,%rax
  815db7:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  815dbe:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815dc2:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815dc9:	00 00 00 
  815dcc:	48 63 d0             	movslq %eax,%rdx
  815dcf:	48 89 d0             	mov    %rdx,%rax
  815dd2:	48 c1 e0 02          	shl    $0x2,%rax
  815dd6:	48 01 d0             	add    %rdx,%rax
  815dd9:	48 c1 e0 03          	shl    $0x3,%rax
  815ddd:	48 01 c8             	add    %rcx,%rax
  815de0:	48 83 c0 14          	add    $0x14,%rax
  815de4:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
    }
#if ARP_QUEUEING
    /* still pending entry? (not expired) */
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
  815dea:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815dee:	48 63 d0             	movslq %eax,%rdx
  815df1:	48 89 d0             	mov    %rdx,%rax
  815df4:	48 c1 e0 02          	shl    $0x2,%rax
  815df8:	48 01 d0             	add    %rdx,%rax
  815dfb:	48 c1 e0 03          	shl    $0x3,%rax
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815dff:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
  815e03:	80 7d ff 09          	cmpb   $0x9,-0x1(%rbp)
  815e07:	0f 86 1e fe ff ff    	jbe    815c2b <etharp_tmr+0x11>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  815e0d:	90                   	nop
  815e0e:	c9                   	leaveq 
  815e0f:	c3                   	retq   

0000000000815e10 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  815e10:	55                   	push   %rbp
  815e11:	48 89 e5             	mov    %rsp,%rbp
  815e14:	48 83 ec 20          	sub    $0x20,%rsp
  815e18:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  815e1c:	89 f0                	mov    %esi,%eax
  815e1e:	88 45 e4             	mov    %al,-0x1c(%rbp)
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  815e21:	c6 45 ff 0a          	movb   $0xa,-0x1(%rbp)
  815e25:	c6 45 fe 0a          	movb   $0xa,-0x2(%rbp)
  s8_t empty = ARP_TABLE_SIZE;
  815e29:	c6 45 fd 0a          	movb   $0xa,-0x3(%rbp)
  u8_t i = 0, age_pending = 0, age_stable = 0;
  815e2d:	c6 45 fc 00          	movb   $0x0,-0x4(%rbp)
  815e31:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  815e35:	c6 45 fa 00          	movb   $0x0,-0x6(%rbp)
#if ARP_QUEUEING
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  815e39:	c6 45 f9 0a          	movb   $0xa,-0x7(%rbp)
  /* its age */
  u8_t age_queue = 0;
  815e3d:	c6 45 f8 00          	movb   $0x0,-0x8(%rbp)
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  815e41:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815e46:	0f 84 89 00 00 00    	je     815ed5 <find_entry+0xc5>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  815e4c:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815e53:	00 00 00 
  815e56:	0f b6 00             	movzbl (%rax),%eax
  815e59:	0f b6 c0             	movzbl %al,%eax
  815e5c:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815e63:	00 00 00 
  815e66:	48 63 d0             	movslq %eax,%rdx
  815e69:	48 89 d0             	mov    %rdx,%rax
  815e6c:	48 c1 e0 02          	shl    $0x2,%rax
  815e70:	48 01 d0             	add    %rdx,%rax
  815e73:	48 c1 e0 03          	shl    $0x3,%rax
  815e77:	48 01 c8             	add    %rcx,%rax
  815e7a:	48 83 c0 14          	add    $0x14,%rax
  815e7e:	8b 00                	mov    (%rax),%eax
  815e80:	83 f8 02             	cmp    $0x2,%eax
  815e83:	75 50                	jne    815ed5 <find_entry+0xc5>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  815e85:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815e89:	8b 08                	mov    (%rax),%ecx
  815e8b:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815e92:	00 00 00 
  815e95:	0f b6 00             	movzbl (%rax),%eax
  815e98:	0f b6 c0             	movzbl %al,%eax
  815e9b:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815ea2:	00 00 00 
  815ea5:	48 63 d0             	movslq %eax,%rdx
  815ea8:	48 89 d0             	mov    %rdx,%rax
  815eab:	48 c1 e0 02          	shl    $0x2,%rax
  815eaf:	48 01 d0             	add    %rdx,%rax
  815eb2:	48 c1 e0 03          	shl    $0x3,%rax
  815eb6:	48 01 f0             	add    %rsi,%rax
  815eb9:	48 83 c0 08          	add    $0x8,%rax
  815ebd:	8b 00                	mov    (%rax),%eax
  815ebf:	39 c1                	cmp    %eax,%ecx
  815ec1:	75 12                	jne    815ed5 <find_entry+0xc5>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  815ec3:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815eca:	00 00 00 
  815ecd:	0f b6 00             	movzbl (%rax),%eax
  815ed0:	e9 cd 04 00 00       	jmpq   8163a2 <find_entry+0x592>
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815ed5:	c6 45 fc 00          	movb   $0x0,-0x4(%rbp)
  815ed9:	e9 a7 02 00 00       	jmpq   816185 <find_entry+0x375>
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  815ede:	80 7d fd 0a          	cmpb   $0xa,-0x3(%rbp)
  815ee2:	75 38                	jne    815f1c <find_entry+0x10c>
  815ee4:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815ee8:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815eef:	00 00 00 
  815ef2:	48 63 d0             	movslq %eax,%rdx
  815ef5:	48 89 d0             	mov    %rdx,%rax
  815ef8:	48 c1 e0 02          	shl    $0x2,%rax
  815efc:	48 01 d0             	add    %rdx,%rax
  815eff:	48 c1 e0 03          	shl    $0x3,%rax
  815f03:	48 01 c8             	add    %rcx,%rax
  815f06:	48 83 c0 14          	add    $0x14,%rax
  815f0a:	8b 00                	mov    (%rax),%eax
  815f0c:	85 c0                	test   %eax,%eax
  815f0e:	75 0c                	jne    815f1c <find_entry+0x10c>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  815f10:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815f14:	88 45 fd             	mov    %al,-0x3(%rbp)
  815f17:	e9 65 02 00 00       	jmpq   816181 <find_entry+0x371>
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  815f1c:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815f20:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815f27:	00 00 00 
  815f2a:	48 63 d0             	movslq %eax,%rdx
  815f2d:	48 89 d0             	mov    %rdx,%rax
  815f30:	48 c1 e0 02          	shl    $0x2,%rax
  815f34:	48 01 d0             	add    %rdx,%rax
  815f37:	48 c1 e0 03          	shl    $0x3,%rax
  815f3b:	48 01 c8             	add    %rcx,%rax
  815f3e:	48 83 c0 14          	add    $0x14,%rax
  815f42:	8b 00                	mov    (%rax),%eax
  815f44:	83 f8 01             	cmp    $0x1,%eax
  815f47:	0f 85 50 01 00 00    	jne    81609d <find_entry+0x28d>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  815f4d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815f52:	74 4b                	je     815f9f <find_entry+0x18f>
  815f54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815f58:	8b 08                	mov    (%rax),%ecx
  815f5a:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815f5e:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815f65:	00 00 00 
  815f68:	48 63 d0             	movslq %eax,%rdx
  815f6b:	48 89 d0             	mov    %rdx,%rax
  815f6e:	48 c1 e0 02          	shl    $0x2,%rax
  815f72:	48 01 d0             	add    %rdx,%rax
  815f75:	48 c1 e0 03          	shl    $0x3,%rax
  815f79:	48 01 f0             	add    %rsi,%rax
  815f7c:	48 83 c0 08          	add    $0x8,%rax
  815f80:	8b 00                	mov    (%rax),%eax
  815f82:	39 c1                	cmp    %eax,%ecx
  815f84:	75 19                	jne    815f9f <find_entry+0x18f>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  815f86:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815f8d:	00 00 00 
  815f90:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  815f94:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  815f96:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815f9a:	e9 03 04 00 00       	jmpq   8163a2 <find_entry+0x592>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  815f9f:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815fa3:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815faa:	00 00 00 
  815fad:	48 63 d0             	movslq %eax,%rdx
  815fb0:	48 89 d0             	mov    %rdx,%rax
  815fb3:	48 c1 e0 02          	shl    $0x2,%rax
  815fb7:	48 01 d0             	add    %rdx,%rax
  815fba:	48 c1 e0 03          	shl    $0x3,%rax
  815fbe:	48 01 c8             	add    %rcx,%rax
  815fc1:	48 8b 00             	mov    (%rax),%rax
  815fc4:	48 85 c0             	test   %rax,%rax
  815fc7:	74 6a                	je     816033 <find_entry+0x223>
        if (arp_table[i].ctime >= age_queue) {
  815fc9:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815fcd:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815fd4:	00 00 00 
  815fd7:	48 63 d0             	movslq %eax,%rdx
  815fda:	48 89 d0             	mov    %rdx,%rax
  815fdd:	48 c1 e0 02          	shl    $0x2,%rax
  815fe1:	48 01 d0             	add    %rdx,%rax
  815fe4:	48 c1 e0 03          	shl    $0x3,%rax
  815fe8:	48 01 c8             	add    %rcx,%rax
  815feb:	48 83 c0 18          	add    $0x18,%rax
  815fef:	0f b6 00             	movzbl (%rax),%eax
  815ff2:	3a 45 f8             	cmp    -0x8(%rbp),%al
  815ff5:	0f 82 86 01 00 00    	jb     816181 <find_entry+0x371>
          old_queue = i;
  815ffb:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815fff:	88 45 f9             	mov    %al,-0x7(%rbp)
          age_queue = arp_table[i].ctime;
  816002:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  816006:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81600d:	00 00 00 
  816010:	48 63 d0             	movslq %eax,%rdx
  816013:	48 89 d0             	mov    %rdx,%rax
  816016:	48 c1 e0 02          	shl    $0x2,%rax
  81601a:	48 01 d0             	add    %rdx,%rax
  81601d:	48 c1 e0 03          	shl    $0x3,%rax
  816021:	48 01 c8             	add    %rcx,%rax
  816024:	48 83 c0 18          	add    $0x18,%rax
  816028:	0f b6 00             	movzbl (%rax),%eax
  81602b:	88 45 f8             	mov    %al,-0x8(%rbp)
  81602e:	e9 4e 01 00 00       	jmpq   816181 <find_entry+0x371>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  816033:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  816037:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81603e:	00 00 00 
  816041:	48 63 d0             	movslq %eax,%rdx
  816044:	48 89 d0             	mov    %rdx,%rax
  816047:	48 c1 e0 02          	shl    $0x2,%rax
  81604b:	48 01 d0             	add    %rdx,%rax
  81604e:	48 c1 e0 03          	shl    $0x3,%rax
  816052:	48 01 c8             	add    %rcx,%rax
  816055:	48 83 c0 18          	add    $0x18,%rax
  816059:	0f b6 00             	movzbl (%rax),%eax
  81605c:	3a 45 fb             	cmp    -0x5(%rbp),%al
  81605f:	0f 82 1c 01 00 00    	jb     816181 <find_entry+0x371>
          old_pending = i;
  816065:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  816069:	88 45 ff             	mov    %al,-0x1(%rbp)
          age_pending = arp_table[i].ctime;
  81606c:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  816070:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816077:	00 00 00 
  81607a:	48 63 d0             	movslq %eax,%rdx
  81607d:	48 89 d0             	mov    %rdx,%rax
  816080:	48 c1 e0 02          	shl    $0x2,%rax
  816084:	48 01 d0             	add    %rdx,%rax
  816087:	48 c1 e0 03          	shl    $0x3,%rax
  81608b:	48 01 c8             	add    %rcx,%rax
  81608e:	48 83 c0 18          	add    $0x18,%rax
  816092:	0f b6 00             	movzbl (%rax),%eax
  816095:	88 45 fb             	mov    %al,-0x5(%rbp)
  816098:	e9 e4 00 00 00       	jmpq   816181 <find_entry+0x371>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  81609d:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8160a1:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8160a8:	00 00 00 
  8160ab:	48 63 d0             	movslq %eax,%rdx
  8160ae:	48 89 d0             	mov    %rdx,%rax
  8160b1:	48 c1 e0 02          	shl    $0x2,%rax
  8160b5:	48 01 d0             	add    %rdx,%rax
  8160b8:	48 c1 e0 03          	shl    $0x3,%rax
  8160bc:	48 01 c8             	add    %rcx,%rax
  8160bf:	48 83 c0 14          	add    $0x14,%rax
  8160c3:	8b 00                	mov    (%rax),%eax
  8160c5:	83 f8 02             	cmp    $0x2,%eax
  8160c8:	0f 85 b3 00 00 00    	jne    816181 <find_entry+0x371>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  8160ce:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8160d3:	74 4b                	je     816120 <find_entry+0x310>
  8160d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8160d9:	8b 08                	mov    (%rax),%ecx
  8160db:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8160df:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  8160e6:	00 00 00 
  8160e9:	48 63 d0             	movslq %eax,%rdx
  8160ec:	48 89 d0             	mov    %rdx,%rax
  8160ef:	48 c1 e0 02          	shl    $0x2,%rax
  8160f3:	48 01 d0             	add    %rdx,%rax
  8160f6:	48 c1 e0 03          	shl    $0x3,%rax
  8160fa:	48 01 f0             	add    %rsi,%rax
  8160fd:	48 83 c0 08          	add    $0x8,%rax
  816101:	8b 00                	mov    (%rax),%eax
  816103:	39 c1                	cmp    %eax,%ecx
  816105:	75 19                	jne    816120 <find_entry+0x310>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  816107:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  81610e:	00 00 00 
  816111:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  816115:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  816117:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  81611b:	e9 82 02 00 00       	jmpq   8163a2 <find_entry+0x592>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  816120:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  816124:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81612b:	00 00 00 
  81612e:	48 63 d0             	movslq %eax,%rdx
  816131:	48 89 d0             	mov    %rdx,%rax
  816134:	48 c1 e0 02          	shl    $0x2,%rax
  816138:	48 01 d0             	add    %rdx,%rax
  81613b:	48 c1 e0 03          	shl    $0x3,%rax
  81613f:	48 01 c8             	add    %rcx,%rax
  816142:	48 83 c0 18          	add    $0x18,%rax
  816146:	0f b6 00             	movzbl (%rax),%eax
  816149:	3a 45 fa             	cmp    -0x6(%rbp),%al
  81614c:	72 33                	jb     816181 <find_entry+0x371>
        old_stable = i;
  81614e:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  816152:	88 45 fe             	mov    %al,-0x2(%rbp)
        age_stable = arp_table[i].ctime;
  816155:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  816159:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816160:	00 00 00 
  816163:	48 63 d0             	movslq %eax,%rdx
  816166:	48 89 d0             	mov    %rdx,%rax
  816169:	48 c1 e0 02          	shl    $0x2,%rax
  81616d:	48 01 d0             	add    %rdx,%rax
  816170:	48 c1 e0 03          	shl    $0x3,%rax
  816174:	48 01 c8             	add    %rcx,%rax
  816177:	48 83 c0 18          	add    $0x18,%rax
  81617b:	0f b6 00             	movzbl (%rax),%eax
  81617e:	88 45 fa             	mov    %al,-0x6(%rbp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  816181:	80 45 fc 01          	addb   $0x1,-0x4(%rbp)
  816185:	80 7d fc 09          	cmpb   $0x9,-0x4(%rbp)
  816189:	0f 86 4f fd ff ff    	jbe    815ede <find_entry+0xce>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  81618f:	80 7d fd 0a          	cmpb   $0xa,-0x3(%rbp)
  816193:	75 0b                	jne    8161a0 <find_entry+0x390>
  816195:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
  816199:	83 e0 01             	and    $0x1,%eax
  81619c:	85 c0                	test   %eax,%eax
  81619e:	74 0b                	je     8161ab <find_entry+0x39b>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  8161a0:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
  8161a4:	83 e0 02             	and    $0x2,%eax
  8161a7:	85 c0                	test   %eax,%eax
  8161a9:	74 0a                	je     8161b5 <find_entry+0x3a5>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  8161ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8161b0:	e9 ed 01 00 00       	jmpq   8163a2 <find_entry+0x592>
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  8161b5:	80 7d fd 09          	cmpb   $0x9,-0x3(%rbp)
  8161b9:	7f 0c                	jg     8161c7 <find_entry+0x3b7>
    i = empty;
  8161bb:	0f b6 45 fd          	movzbl -0x3(%rbp),%eax
  8161bf:	88 45 fc             	mov    %al,-0x4(%rbp)
  8161c2:	e9 ea 00 00 00       	jmpq   8162b1 <find_entry+0x4a1>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  8161c7:	80 7d fe 09          	cmpb   $0x9,-0x2(%rbp)
  8161cb:	7f 5f                	jg     81622c <find_entry+0x41c>
    /* recycle oldest stable*/
    i = old_stable;
  8161cd:	0f b6 45 fe          	movzbl -0x2(%rbp),%eax
  8161d1:	88 45 fc             	mov    %al,-0x4(%rbp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  8161d4:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8161d8:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8161df:	00 00 00 
  8161e2:	48 63 d0             	movslq %eax,%rdx
  8161e5:	48 89 d0             	mov    %rdx,%rax
  8161e8:	48 c1 e0 02          	shl    $0x2,%rax
  8161ec:	48 01 d0             	add    %rdx,%rax
  8161ef:	48 c1 e0 03          	shl    $0x3,%rax
  8161f3:	48 01 c8             	add    %rcx,%rax
  8161f6:	48 8b 00             	mov    (%rax),%rax
  8161f9:	48 85 c0             	test   %rax,%rax
  8161fc:	0f 84 af 00 00 00    	je     8162b1 <find_entry+0x4a1>
  816202:	48 ba 90 2d 82 00 00 	movabs $0x822d90,%rdx
  816209:	00 00 00 
  81620c:	be 76 01 00 00       	mov    $0x176,%esi
  816211:	48 bf 5e 2d 82 00 00 	movabs $0x822d5e,%rdi
  816218:	00 00 00 
  81621b:	b8 00 00 00 00       	mov    $0x0,%eax
  816220:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  816227:	00 00 00 
  81622a:	ff d1                	callq  *%rcx
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  81622c:	80 7d ff 09          	cmpb   $0x9,-0x1(%rbp)
  816230:	7f 09                	jg     81623b <find_entry+0x42b>
    /* recycle oldest pending */
    i = old_pending;
  816232:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816236:	88 45 fc             	mov    %al,-0x4(%rbp)
  816239:	eb 76                	jmp    8162b1 <find_entry+0x4a1>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  81623b:	80 7d f9 09          	cmpb   $0x9,-0x7(%rbp)
  81623f:	7f 66                	jg     8162a7 <find_entry+0x497>
    /* recycle oldest pending */
    i = old_queue;
  816241:	0f b6 45 f9          	movzbl -0x7(%rbp),%eax
  816245:	88 45 fc             	mov    %al,-0x4(%rbp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  816248:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  81624c:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816253:	00 00 00 
  816256:	48 63 d0             	movslq %eax,%rdx
  816259:	48 89 d0             	mov    %rdx,%rax
  81625c:	48 c1 e0 02          	shl    $0x2,%rax
  816260:	48 01 d0             	add    %rdx,%rax
  816263:	48 c1 e0 03          	shl    $0x3,%rax
  816267:	48 01 c8             	add    %rcx,%rax
  81626a:	48 8b 00             	mov    (%rax),%rax
  81626d:	48 89 c7             	mov    %rax,%rdi
  816270:	48 b8 1f 5b 81 00 00 	movabs $0x815b1f,%rax
  816277:	00 00 00 
  81627a:	ff d0                	callq  *%rax
    arp_table[i].q = NULL;
  81627c:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  816280:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816287:	00 00 00 
  81628a:	48 63 d0             	movslq %eax,%rdx
  81628d:	48 89 d0             	mov    %rdx,%rax
  816290:	48 c1 e0 02          	shl    $0x2,%rax
  816294:	48 01 d0             	add    %rdx,%rax
  816297:	48 c1 e0 03          	shl    $0x3,%rax
  81629b:	48 01 c8             	add    %rcx,%rax
  81629e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  8162a5:	eb 0a                	jmp    8162b1 <find_entry+0x4a1>
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  8162a7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8162ac:	e9 f1 00 00 00       	jmpq   8163a2 <find_entry+0x592>
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  8162b1:	80 7d fc 09          	cmpb   $0x9,-0x4(%rbp)
  8162b5:	76 2a                	jbe    8162e1 <find_entry+0x4d1>
  8162b7:	48 ba a7 2d 82 00 00 	movabs $0x822da7,%rdx
  8162be:	00 00 00 
  8162c1:	be 8c 01 00 00       	mov    $0x18c,%esi
  8162c6:	48 bf 5e 2d 82 00 00 	movabs $0x822d5e,%rdi
  8162cd:	00 00 00 
  8162d0:	b8 00 00 00 00       	mov    $0x0,%eax
  8162d5:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8162dc:	00 00 00 
  8162df:	ff d1                	callq  *%rcx

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  8162e1:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8162e5:	48 63 d0             	movslq %eax,%rdx
  8162e8:	48 89 d0             	mov    %rdx,%rax
  8162eb:	48 c1 e0 02          	shl    $0x2,%rax
  8162ef:	48 01 d0             	add    %rdx,%rax
  8162f2:	48 c1 e0 03          	shl    $0x3,%rax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  8162f6:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8162fa:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816301:	00 00 00 
  816304:	48 63 d0             	movslq %eax,%rdx
  816307:	48 89 d0             	mov    %rdx,%rax
  81630a:	48 c1 e0 02          	shl    $0x2,%rax
  81630e:	48 01 d0             	add    %rdx,%rax
  816311:	48 c1 e0 03          	shl    $0x3,%rax
  816315:	48 01 c8             	add    %rcx,%rax
  816318:	48 83 c0 14          	add    $0x14,%rax
  81631c:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

  /* IP address given? */
  if (ipaddr != NULL) {
  816322:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  816327:	74 3c                	je     816365 <find_entry+0x555>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  816329:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  81632d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  816332:	74 08                	je     81633c <find_entry+0x52c>
  816334:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816338:	8b 08                	mov    (%rax),%ecx
  81633a:	eb 05                	jmp    816341 <find_entry+0x531>
  81633c:	b9 00 00 00 00       	mov    $0x0,%ecx
  816341:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  816348:	00 00 00 
  81634b:	48 63 d2             	movslq %edx,%rdx
  81634e:	48 89 d0             	mov    %rdx,%rax
  816351:	48 c1 e0 02          	shl    $0x2,%rax
  816355:	48 01 d0             	add    %rdx,%rax
  816358:	48 c1 e0 03          	shl    $0x3,%rax
  81635c:	48 01 f0             	add    %rsi,%rax
  81635f:	48 83 c0 08          	add    $0x8,%rax
  816363:	89 08                	mov    %ecx,(%rax)
  }
  arp_table[i].ctime = 0;
  816365:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  816369:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816370:	00 00 00 
  816373:	48 63 d0             	movslq %eax,%rdx
  816376:	48 89 d0             	mov    %rdx,%rax
  816379:	48 c1 e0 02          	shl    $0x2,%rax
  81637d:	48 01 d0             	add    %rdx,%rax
  816380:	48 c1 e0 03          	shl    $0x3,%rax
  816384:	48 01 c8             	add    %rcx,%rax
  816387:	48 83 c0 18          	add    $0x18,%rax
  81638b:	c6 00 00             	movb   $0x0,(%rax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  81638e:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  816395:	00 00 00 
  816398:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  81639c:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  81639e:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
}
  8163a2:	c9                   	leaveq 
  8163a3:	c3                   	retq   

00000000008163a4 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  8163a4:	55                   	push   %rbp
  8163a5:	48 89 e5             	mov    %rsp,%rbp
  8163a8:	48 83 ec 30          	sub    $0x30,%rsp
  8163ac:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8163b0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8163b4:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8163b8:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  struct eth_hdr *ethhdr = p->payload;
  8163bc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8163c0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8163c4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8163c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8163cc:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  8163d0:	3c 06                	cmp    $0x6,%al
  8163d2:	74 2a                	je     8163fe <etharp_send_ip+0x5a>
  8163d4:	48 ba c0 2d 82 00 00 	movabs $0x822dc0,%rdx
  8163db:	00 00 00 
  8163de:	be b4 01 00 00       	mov    $0x1b4,%esi
  8163e3:	48 bf 5e 2d 82 00 00 	movabs $0x822d5e,%rdi
  8163ea:	00 00 00 
  8163ed:	b8 00 00 00 00       	mov    $0x0,%eax
  8163f2:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8163f9:	00 00 00 
  8163fc:	ff d1                	callq  *%rcx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  8163fe:	c6 45 ff 06          	movb   $0x6,-0x1(%rbp)
  while(k > 0) {
  816402:	eb 43                	jmp    816447 <etharp_send_ip+0xa3>
    k--;
  816404:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816408:	83 e8 01             	sub    $0x1,%eax
  81640b:	88 45 ff             	mov    %al,-0x1(%rbp)
    ethhdr->dest.addr[k] = dst->addr[k];
  81640e:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  816412:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816416:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81641a:	48 98                	cltq   
  81641c:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816420:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  816424:	48 63 c6             	movslq %esi,%rax
  816427:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  81642a:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  81642e:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816432:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  816436:	48 98                	cltq   
  816438:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  81643c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  816440:	48 63 c6             	movslq %esi,%rax
  816443:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  816447:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  81644b:	75 b7                	jne    816404 <etharp_send_ip+0x60>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  81644d:	bf 00 08 00 00       	mov    $0x800,%edi
  816452:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  816459:	00 00 00 
  81645c:	ff d0                	callq  *%rax
  81645e:	89 c2                	mov    %eax,%edx
  816460:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  816464:	66 89 50 0c          	mov    %dx,0xc(%rax)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  816468:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81646c:	48 8b 40 28          	mov    0x28(%rax),%rax
  816470:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  816474:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816478:	48 89 ce             	mov    %rcx,%rsi
  81647b:	48 89 d7             	mov    %rdx,%rdi
  81647e:	ff d0                	callq  *%rax
}
  816480:	c9                   	leaveq 
  816481:	c3                   	retq   

0000000000816482 <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  816482:	55                   	push   %rbp
  816483:	48 89 e5             	mov    %rsp,%rbp
  816486:	53                   	push   %rbx
  816487:	48 83 ec 48          	sub    $0x48,%rsp
  81648b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81648f:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  816493:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  816497:	89 c8                	mov    %ecx,%eax
  816499:	88 45 b4             	mov    %al,-0x4c(%rbp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  81649c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8164a0:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  8164a4:	3c 06                	cmp    $0x6,%al
  8164a6:	74 2a                	je     8164d2 <update_arp_entry+0x50>
  8164a8:	48 ba 08 2e 82 00 00 	movabs $0x822e08,%rdx
  8164af:	00 00 00 
  8164b2:	be da 01 00 00       	mov    $0x1da,%esi
  8164b7:	48 bf 5e 2d 82 00 00 	movabs $0x822d5e,%rdi
  8164be:	00 00 00 
  8164c1:	b8 00 00 00 00       	mov    $0x0,%eax
  8164c6:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8164cd:	00 00 00 
  8164d0:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  8164d2:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8164d7:	74 56                	je     81652f <update_arp_entry+0xad>
  8164d9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8164dd:	8b 00                	mov    (%rax),%eax
  8164df:	85 c0                	test   %eax,%eax
  8164e1:	74 4c                	je     81652f <update_arp_entry+0xad>
      ip_addr_isbroadcast(ipaddr, netif) ||
  8164e3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8164e7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8164eb:	48 89 d6             	mov    %rdx,%rsi
  8164ee:	48 89 c7             	mov    %rax,%rdi
  8164f1:	48 b8 eb 0d 81 00 00 	movabs $0x810deb,%rax
  8164f8:	00 00 00 
  8164fb:	ff d0                	callq  *%rax
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  8164fd:	84 c0                	test   %al,%al
  8164ff:	75 2e                	jne    81652f <update_arp_entry+0xad>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  816501:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  816505:	8b 18                	mov    (%rax),%ebx
  816507:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  81650c:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  816513:	00 00 00 
  816516:	ff d0                	callq  *%rax
  816518:	21 c3                	and    %eax,%ebx
  81651a:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81651f:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  816526:	00 00 00 
  816529:	ff d0                	callq  *%rax
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
  81652b:	39 c3                	cmp    %eax,%ebx
  81652d:	75 0a                	jne    816539 <update_arp_entry+0xb7>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  81652f:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  816534:	e9 f1 01 00 00       	jmpq   81672a <update_arp_entry+0x2a8>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  816539:	0f b6 55 b4          	movzbl -0x4c(%rbp),%edx
  81653d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  816541:	89 d6                	mov    %edx,%esi
  816543:	48 89 c7             	mov    %rax,%rdi
  816546:	48 b8 10 5e 81 00 00 	movabs $0x815e10,%rax
  81654d:	00 00 00 
  816550:	ff d0                	callq  *%rax
  816552:	88 45 ee             	mov    %al,-0x12(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  816555:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  816559:	79 09                	jns    816564 <update_arp_entry+0xe2>
    return (err_t)i;
  81655b:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  81655f:	e9 c6 01 00 00       	jmpq   81672a <update_arp_entry+0x2a8>
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  816564:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  816568:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81656f:	00 00 00 
  816572:	48 63 d0             	movslq %eax,%rdx
  816575:	48 89 d0             	mov    %rdx,%rax
  816578:	48 c1 e0 02          	shl    $0x2,%rax
  81657c:	48 01 d0             	add    %rdx,%rax
  81657f:	48 c1 e0 03          	shl    $0x3,%rax
  816583:	48 01 c8             	add    %rcx,%rax
  816586:	48 83 c0 14          	add    $0x14,%rax
  81658a:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
  /* record network interface */
  arp_table[i].netif = netif;
  816590:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  816594:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81659b:	00 00 00 
  81659e:	48 63 d0             	movslq %eax,%rdx
  8165a1:	48 89 d0             	mov    %rdx,%rax
  8165a4:	48 c1 e0 02          	shl    $0x2,%rax
  8165a8:	48 01 d0             	add    %rdx,%rax
  8165ab:	48 c1 e0 03          	shl    $0x3,%rax
  8165af:	48 01 c8             	add    %rcx,%rax
  8165b2:	48 8d 50 20          	lea    0x20(%rax),%rdx
  8165b6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8165ba:	48 89 02             	mov    %rax,(%rdx)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  8165bd:	c6 45 ef 06          	movb   $0x6,-0x11(%rbp)
  while (k > 0) {
  8165c1:	eb 4b                	jmp    81660e <update_arp_entry+0x18c>
    k--;
  8165c3:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8165c7:	83 e8 01             	sub    $0x1,%eax
  8165ca:	88 45 ef             	mov    %al,-0x11(%rbp)
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  8165cd:	44 0f be 45 ee       	movsbl -0x12(%rbp),%r8d
  8165d2:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  8165d6:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8165da:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8165de:	48 98                	cltq   
  8165e0:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8165e4:	48 bf 80 b6 b4 00 00 	movabs $0xb4b680,%rdi
  8165eb:	00 00 00 
  8165ee:	48 63 f6             	movslq %esi,%rsi
  8165f1:	49 63 d0             	movslq %r8d,%rdx
  8165f4:	48 89 d0             	mov    %rdx,%rax
  8165f7:	48 c1 e0 02          	shl    $0x2,%rax
  8165fb:	48 01 d0             	add    %rdx,%rax
  8165fe:	48 c1 e0 03          	shl    $0x3,%rax
  816602:	48 01 f8             	add    %rdi,%rax
  816605:	48 01 f0             	add    %rsi,%rax
  816608:	48 83 c0 0c          	add    $0xc,%rax
  81660c:	88 08                	mov    %cl,(%rax)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
  81660e:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  816612:	75 af                	jne    8165c3 <update_arp_entry+0x141>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  816614:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  816618:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81661f:	00 00 00 
  816622:	48 63 d0             	movslq %eax,%rdx
  816625:	48 89 d0             	mov    %rdx,%rax
  816628:	48 c1 e0 02          	shl    $0x2,%rax
  81662c:	48 01 d0             	add    %rdx,%rax
  81662f:	48 c1 e0 03          	shl    $0x3,%rax
  816633:	48 01 c8             	add    %rcx,%rax
  816636:	48 83 c0 18          	add    $0x18,%rax
  81663a:	c6 00 00             	movb   $0x0,(%rax)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  81663d:	e9 b5 00 00 00       	jmpq   8166f7 <update_arp_entry+0x275>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
  816642:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  816646:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81664d:	00 00 00 
  816650:	48 63 d0             	movslq %eax,%rdx
  816653:	48 89 d0             	mov    %rdx,%rax
  816656:	48 c1 e0 02          	shl    $0x2,%rax
  81665a:	48 01 d0             	add    %rdx,%rax
  81665d:	48 c1 e0 03          	shl    $0x3,%rax
  816661:	48 01 c8             	add    %rcx,%rax
  816664:	48 8b 00             	mov    (%rax),%rax
  816667:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  81666b:	0f be 55 ee          	movsbl -0x12(%rbp),%edx
  81666f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816673:	48 8b 08             	mov    (%rax),%rcx
  816676:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  81667d:	00 00 00 
  816680:	48 63 d2             	movslq %edx,%rdx
  816683:	48 89 d0             	mov    %rdx,%rax
  816686:	48 c1 e0 02          	shl    $0x2,%rax
  81668a:	48 01 d0             	add    %rdx,%rax
  81668d:	48 c1 e0 03          	shl    $0x3,%rax
  816691:	48 01 f0             	add    %rsi,%rax
  816694:	48 89 08             	mov    %rcx,(%rax)
    /* get the packet pointer */
    p = q->p;
  816697:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81669b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81669f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  8166a3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8166a7:	48 89 c6             	mov    %rax,%rsi
  8166aa:	bf 0a 00 00 00       	mov    $0xa,%edi
  8166af:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  8166b6:	00 00 00 
  8166b9:	ff d0                	callq  *%rax
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  8166bb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8166bf:	48 8d 78 41          	lea    0x41(%rax),%rdi
  8166c3:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8166c7:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  8166cb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8166cf:	48 89 d1             	mov    %rdx,%rcx
  8166d2:	48 89 fa             	mov    %rdi,%rdx
  8166d5:	48 89 c7             	mov    %rax,%rdi
  8166d8:	48 b8 a4 63 81 00 00 	movabs $0x8163a4,%rax
  8166df:	00 00 00 
  8166e2:	ff d0                	callq  *%rax
    /* free the queued IP packet */
    pbuf_free(p);
  8166e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8166e8:	48 89 c7             	mov    %rax,%rdi
  8166eb:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  8166f2:	00 00 00 
  8166f5:	ff d0                	callq  *%rax
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  8166f7:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  8166fb:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816702:	00 00 00 
  816705:	48 63 d0             	movslq %eax,%rdx
  816708:	48 89 d0             	mov    %rdx,%rax
  81670b:	48 c1 e0 02          	shl    $0x2,%rax
  81670f:	48 01 d0             	add    %rdx,%rax
  816712:	48 c1 e0 03          	shl    $0x3,%rax
  816716:	48 01 c8             	add    %rcx,%rax
  816719:	48 8b 00             	mov    (%rax),%rax
  81671c:	48 85 c0             	test   %rax,%rax
  81671f:	0f 85 1d ff ff ff    	jne    816642 <update_arp_entry+0x1c0>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
  816725:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81672a:	48 83 c4 48          	add    $0x48,%rsp
  81672e:	5b                   	pop    %rbx
  81672f:	5d                   	pop    %rbp
  816730:	c3                   	retq   

0000000000816731 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  816731:	55                   	push   %rbp
  816732:	48 89 e5             	mov    %rsp,%rbp
  816735:	48 83 ec 30          	sub    $0x30,%rsp
  816739:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81673d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  816741:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  816745:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  816749:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81674d:	be 02 00 00 00       	mov    $0x2,%esi
  816752:	48 89 c7             	mov    %rax,%rdi
  816755:	48 b8 10 5e 81 00 00 	movabs $0x815e10,%rax
  81675c:	00 00 00 
  81675f:	ff d0                	callq  *%rax
  816761:	88 45 ff             	mov    %al,-0x1(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  816764:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  816768:	0f 88 8d 00 00 00    	js     8167fb <etharp_find_addr+0xca>
  81676e:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  816772:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816779:	00 00 00 
  81677c:	48 63 d0             	movslq %eax,%rdx
  81677f:	48 89 d0             	mov    %rdx,%rax
  816782:	48 c1 e0 02          	shl    $0x2,%rax
  816786:	48 01 d0             	add    %rdx,%rax
  816789:	48 c1 e0 03          	shl    $0x3,%rax
  81678d:	48 01 c8             	add    %rcx,%rax
  816790:	48 83 c0 14          	add    $0x14,%rax
  816794:	8b 00                	mov    (%rax),%eax
  816796:	83 f8 02             	cmp    $0x2,%eax
  816799:	75 60                	jne    8167fb <etharp_find_addr+0xca>
      *eth_ret = &arp_table[i].ethaddr;
  81679b:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  81679f:	48 63 d0             	movslq %eax,%rdx
  8167a2:	48 89 d0             	mov    %rdx,%rax
  8167a5:	48 c1 e0 02          	shl    $0x2,%rax
  8167a9:	48 01 d0             	add    %rdx,%rax
  8167ac:	48 c1 e0 03          	shl    $0x3,%rax
  8167b0:	48 ba 80 b6 b4 00 00 	movabs $0xb4b680,%rdx
  8167b7:	00 00 00 
  8167ba:	48 01 d0             	add    %rdx,%rax
  8167bd:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8167c1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8167c5:	48 89 10             	mov    %rdx,(%rax)
      *ip_ret = &arp_table[i].ipaddr;
  8167c8:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  8167cc:	48 63 d0             	movslq %eax,%rdx
  8167cf:	48 89 d0             	mov    %rdx,%rax
  8167d2:	48 c1 e0 02          	shl    $0x2,%rax
  8167d6:	48 01 d0             	add    %rdx,%rax
  8167d9:	48 c1 e0 03          	shl    $0x3,%rax
  8167dd:	48 ba 80 b6 b4 00 00 	movabs $0xb4b680,%rdx
  8167e4:	00 00 00 
  8167e7:	48 01 d0             	add    %rdx,%rax
  8167ea:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8167ee:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8167f2:	48 89 10             	mov    %rdx,(%rax)
      return i;
  8167f5:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8167f9:	eb 05                	jmp    816800 <etharp_find_addr+0xcf>
  }
  return -1;
  8167fb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  816800:	c9                   	leaveq 
  816801:	c3                   	retq   

0000000000816802 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  816802:	55                   	push   %rbp
  816803:	48 89 e5             	mov    %rsp,%rbp
  816806:	48 83 ec 20          	sub    $0x20,%rsp
  81680a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81680e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  816812:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  816817:	75 2a                	jne    816843 <etharp_ip_input+0x41>
  816819:	48 ba 2f 2e 82 00 00 	movabs $0x822e2f,%rdx
  816820:	00 00 00 
  816823:	be 49 02 00 00       	mov    $0x249,%esi
  816828:	48 bf 5e 2d 82 00 00 	movabs $0x822d5e,%rdi
  81682f:	00 00 00 
  816832:	b8 00 00 00 00       	mov    $0x0,%eax
  816837:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81683e:	00 00 00 
  816841:	ff d1                	callq  *%rcx
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  816843:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816847:	48 8b 40 08          	mov    0x8(%rax),%rax
  81684b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  81684f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816853:	8b 50 1c             	mov    0x1c(%rax),%edx
  816856:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81685a:	8b 40 08             	mov    0x8(%rax),%eax
  81685d:	31 c2                	xor    %eax,%edx
  81685f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816863:	8b 40 0c             	mov    0xc(%rax),%eax
  816866:	21 d0                	and    %edx,%eax
  816868:	85 c0                	test   %eax,%eax
  81686a:	75 2a                	jne    816896 <etharp_ip_input+0x94>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  81686c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816870:	48 8d 50 06          	lea    0x6(%rax),%rdx
  816874:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816878:	48 8d 70 1c          	lea    0x1c(%rax),%rsi
  81687c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816880:	b9 00 00 00 00       	mov    $0x0,%ecx
  816885:	48 89 c7             	mov    %rax,%rdi
  816888:	48 b8 82 64 81 00 00 	movabs $0x816482,%rax
  81688f:	00 00 00 
  816892:	ff d0                	callq  *%rax
  816894:	eb 01                	jmp    816897 <etharp_ip_input+0x95>
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
    /* do nothing */
    return;
  816896:	90                   	nop
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
}
  816897:	c9                   	leaveq 
  816898:	c3                   	retq   

0000000000816899 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  816899:	55                   	push   %rbp
  81689a:	48 89 e5             	mov    %rsp,%rbp
  81689d:	53                   	push   %rbx
  81689e:	48 83 ec 58          	sub    $0x58,%rsp
  8168a2:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8168a6:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8168aa:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8168ae:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8168b3:	75 2a                	jne    8168df <etharp_arp_input+0x46>
  8168b5:	48 ba 2f 2e 82 00 00 	movabs $0x822e2f,%rdx
  8168bc:	00 00 00 
  8168bf:	be 76 02 00 00       	mov    $0x276,%esi
  8168c4:	48 bf 5e 2d 82 00 00 	movabs $0x822d5e,%rdi
  8168cb:	00 00 00 
  8168ce:	b8 00 00 00 00       	mov    $0x0,%eax
  8168d3:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8168da:	00 00 00 
  8168dd:	ff d1                	callq  *%rcx
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  8168df:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8168e3:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8168e7:	66 83 f8 29          	cmp    $0x29,%ax
  8168eb:	77 18                	ja     816905 <etharp_arp_input+0x6c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  8168ed:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8168f1:	48 89 c7             	mov    %rax,%rdi
  8168f4:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  8168fb:	00 00 00 
  8168fe:	ff d0                	callq  *%rax
    return;
  816900:	e9 d7 02 00 00       	jmpq   816bdc <etharp_arp_input+0x343>
  }

  hdr = p->payload;
  816905:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816909:	48 8b 40 08          	mov    0x8(%rax),%rax
  81690d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  816911:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816915:	0f b7 58 0e          	movzwl 0xe(%rax),%ebx
  816919:	bf 01 00 00 00       	mov    $0x1,%edi
  81691e:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  816925:	00 00 00 
  816928:	ff d0                	callq  *%rax
  81692a:	66 39 c3             	cmp    %ax,%bx
  81692d:	75 5a                	jne    816989 <etharp_arp_input+0xf0>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  81692f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816933:	0f b7 58 12          	movzwl 0x12(%rax),%ebx
  816937:	bf 04 06 00 00       	mov    $0x604,%edi
  81693c:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  816943:	00 00 00 
  816946:	ff d0                	callq  *%rax
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  816948:	66 39 c3             	cmp    %ax,%bx
  81694b:	75 3c                	jne    816989 <etharp_arp_input+0xf0>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  81694d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816951:	0f b7 58 10          	movzwl 0x10(%rax),%ebx
  816955:	bf 00 08 00 00       	mov    $0x800,%edi
  81695a:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  816961:	00 00 00 
  816964:	ff d0                	callq  *%rax

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  816966:	66 39 c3             	cmp    %ax,%bx
  816969:	75 1e                	jne    816989 <etharp_arp_input+0xf0>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  81696b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81696f:	0f b7 58 0c          	movzwl 0xc(%rax),%ebx
  816973:	bf 06 08 00 00       	mov    $0x806,%edi
  816978:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  81697f:	00 00 00 
  816982:	ff d0                	callq  *%rax
  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  816984:	66 39 c3             	cmp    %ax,%bx
  816987:	74 18                	je     8169a1 <etharp_arp_input+0x108>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  816989:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81698d:	48 89 c7             	mov    %rax,%rdi
  816990:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  816997:	00 00 00 
  81699a:	ff d0                	callq  *%rax
    return;
  81699c:	e9 3b 02 00 00       	jmpq   816bdc <etharp_arp_input+0x343>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  8169a1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8169a5:	48 8d 48 1c          	lea    0x1c(%rax),%rcx
  8169a9:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8169ad:	ba 04 00 00 00       	mov    $0x4,%edx
  8169b2:	48 89 ce             	mov    %rcx,%rsi
  8169b5:	48 89 c7             	mov    %rax,%rdi
  8169b8:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  8169bf:	00 00 00 
  8169c2:	ff d0                	callq  *%rax
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  8169c4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8169c8:	48 8d 48 26          	lea    0x26(%rax),%rcx
  8169cc:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8169d0:	ba 04 00 00 00       	mov    $0x4,%edx
  8169d5:	48 89 ce             	mov    %rcx,%rsi
  8169d8:	48 89 c7             	mov    %rax,%rdi
  8169db:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  8169e2:	00 00 00 
  8169e5:	ff d0                	callq  *%rax

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  8169e7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8169eb:	8b 40 08             	mov    0x8(%rax),%eax
  8169ee:	85 c0                	test   %eax,%eax
  8169f0:	75 06                	jne    8169f8 <etharp_arp_input+0x15f>
    for_us = 0;
  8169f2:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)
  8169f6:	eb 12                	jmp    816a0a <etharp_arp_input+0x171>
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  8169f8:	8b 55 c0             	mov    -0x40(%rbp),%edx
  8169fb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8169ff:	8b 40 08             	mov    0x8(%rax),%eax
  816a02:	39 c2                	cmp    %eax,%edx
  816a04:	0f 94 c0             	sete   %al
  816a07:	88 45 ee             	mov    %al,-0x12(%rbp)
  }

  /* ARP message directed to us? */
  if (for_us) {
  816a0a:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  816a0e:	74 26                	je     816a36 <etharp_arp_input+0x19d>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  816a10:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816a14:	48 8d 50 16          	lea    0x16(%rax),%rdx
  816a18:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  816a1c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816a20:	b9 01 00 00 00       	mov    $0x1,%ecx
  816a25:	48 89 c7             	mov    %rax,%rdi
  816a28:	48 b8 82 64 81 00 00 	movabs $0x816482,%rax
  816a2f:	00 00 00 
  816a32:	ff d0                	callq  *%rax
  816a34:	eb 24                	jmp    816a5a <etharp_arp_input+0x1c1>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  816a36:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816a3a:	48 8d 50 16          	lea    0x16(%rax),%rdx
  816a3e:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  816a42:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816a46:	b9 00 00 00 00       	mov    $0x0,%ecx
  816a4b:	48 89 c7             	mov    %rax,%rdi
  816a4e:	48 b8 82 64 81 00 00 	movabs $0x816482,%rax
  816a55:	00 00 00 
  816a58:	ff d0                	callq  *%rax
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  816a5a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816a5e:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  816a62:	0f b7 c0             	movzwl %ax,%eax
  816a65:	89 c7                	mov    %eax,%edi
  816a67:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  816a6e:	00 00 00 
  816a71:	ff d0                	callq  *%rax
  816a73:	0f b7 c0             	movzwl %ax,%eax
  816a76:	83 f8 01             	cmp    $0x1,%eax
  816a79:	74 0e                	je     816a89 <etharp_arp_input+0x1f0>
  816a7b:	83 f8 02             	cmp    $0x2,%eax
  816a7e:	0f 84 28 01 00 00    	je     816bac <etharp_arp_input+0x313>
#endif
    break;
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  816a84:	e9 40 01 00 00       	jmpq   816bc9 <etharp_arp_input+0x330>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  816a89:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  816a8d:	0f 84 35 01 00 00    	je     816bc8 <etharp_arp_input+0x32f>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  816a93:	bf 02 00 00 00       	mov    $0x2,%edi
  816a98:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  816a9f:	00 00 00 
  816aa2:	ff d0                	callq  *%rax
  816aa4:	89 c2                	mov    %eax,%edx
  816aa6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816aaa:	66 89 50 14          	mov    %dx,0x14(%rax)

      hdr->dipaddr = hdr->sipaddr;
  816aae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816ab2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816ab6:	8b 52 1c             	mov    0x1c(%rdx),%edx
  816ab9:	89 50 26             	mov    %edx,0x26(%rax)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  816abc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816ac0:	48 8d 50 08          	lea    0x8(%rax),%rdx
  816ac4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816ac8:	8b 12                	mov    (%rdx),%edx
  816aca:	89 50 1c             	mov    %edx,0x1c(%rax)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  816acd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816ad1:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  816ad5:	3c 06                	cmp    $0x6,%al
  816ad7:	74 2a                	je     816b03 <etharp_arp_input+0x26a>
  816ad9:	48 ba c0 2d 82 00 00 	movabs $0x822dc0,%rdx
  816ae0:	00 00 00 
  816ae3:	be c8 02 00 00       	mov    $0x2c8,%esi
  816ae8:	48 bf 5e 2d 82 00 00 	movabs $0x822d5e,%rdi
  816aef:	00 00 00 
  816af2:	b8 00 00 00 00       	mov    $0x0,%eax
  816af7:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  816afe:	00 00 00 
  816b01:	ff d1                	callq  *%rcx
                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
      i = ETHARP_HWADDR_LEN;
  816b03:	c6 45 ef 06          	movb   $0x6,-0x11(%rbp)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  816b07:	eb 7f                	jmp    816b88 <etharp_arp_input+0x2ef>
        i--;
  816b09:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816b0d:	83 e8 01             	sub    $0x1,%eax
  816b10:	88 45 ef             	mov    %al,-0x11(%rbp)
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  816b13:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  816b17:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816b1b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816b1f:	48 98                	cltq   
  816b21:	0f b6 4c 02 16       	movzbl 0x16(%rdx,%rax,1),%ecx
  816b26:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816b2a:	48 63 c6             	movslq %esi,%rax
  816b2d:	88 4c 02 20          	mov    %cl,0x20(%rdx,%rax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  816b31:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  816b35:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816b39:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816b3d:	48 98                	cltq   
  816b3f:	0f b6 4c 02 16       	movzbl 0x16(%rdx,%rax,1),%ecx
  816b44:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816b48:	48 63 c6             	movslq %esi,%rax
  816b4b:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  816b4e:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  816b52:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816b56:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  816b5a:	48 98                	cltq   
  816b5c:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816b60:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816b64:	48 63 c6             	movslq %esi,%rax
  816b67:	88 4c 02 16          	mov    %cl,0x16(%rdx,%rax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  816b6b:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  816b6f:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816b73:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  816b77:	48 98                	cltq   
  816b79:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816b7d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816b81:	48 63 c6             	movslq %esi,%rax
  816b84:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  816b88:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  816b8c:	0f 85 77 ff ff ff    	jne    816b09 <etharp_arp_input+0x270>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  816b92:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816b96:	48 8b 40 28          	mov    0x28(%rax),%rax
  816b9a:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  816b9e:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  816ba2:	48 89 ce             	mov    %rcx,%rsi
  816ba5:	48 89 d7             	mov    %rdx,%rdi
  816ba8:	ff d0                	callq  *%rax
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
  816baa:	eb 1c                	jmp    816bc8 <etharp_arp_input+0x32f>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  816bac:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  816bb0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816bb4:	48 89 d6             	mov    %rdx,%rsi
  816bb7:	48 89 c7             	mov    %rax,%rdi
  816bba:	48 b8 b7 a3 80 00 00 	movabs $0x80a3b7,%rax
  816bc1:	00 00 00 
  816bc4:	ff d0                	callq  *%rax
#endif
    break;
  816bc6:	eb 01                	jmp    816bc9 <etharp_arp_input+0x330>
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
  816bc8:	90                   	nop
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  816bc9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816bcd:	48 89 c7             	mov    %rax,%rdi
  816bd0:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  816bd7:	00 00 00 
  816bda:	ff d0                	callq  *%rax
}
  816bdc:	48 83 c4 58          	add    $0x58,%rsp
  816be0:	5b                   	pop    %rbx
  816be1:	5d                   	pop    %rbp
  816be2:	c3                   	retq   

0000000000816be3 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  816be3:	55                   	push   %rbp
  816be4:	48 89 e5             	mov    %rsp,%rbp
  816be7:	53                   	push   %rbx
  816be8:	48 83 ec 38          	sub    $0x38,%rsp
  816bec:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  816bf0:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  816bf4:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  816bf8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816bfc:	be 0e 00 00 00       	mov    $0xe,%esi
  816c01:	48 89 c7             	mov    %rax,%rdi
  816c04:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  816c0b:	00 00 00 
  816c0e:	ff d0                	callq  *%rax
  816c10:	84 c0                	test   %al,%al
  816c12:	74 0a                	je     816c1e <etharp_output+0x3b>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  816c14:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  816c19:	e9 50 01 00 00       	jmpq   816d6e <etharp_output+0x18b>
  }

  /* assume unresolved Ethernet address */
  dest = NULL;
  816c1e:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  816c25:	00 
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  816c26:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  816c2a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816c2e:	48 89 d6             	mov    %rdx,%rsi
  816c31:	48 89 c7             	mov    %rax,%rdi
  816c34:	48 b8 eb 0d 81 00 00 	movabs $0x810deb,%rax
  816c3b:	00 00 00 
  816c3e:	ff d0                	callq  *%rax
  816c40:	84 c0                	test   %al,%al
  816c42:	74 13                	je     816c57 <etharp_output+0x74>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  816c44:	48 b8 48 2d 82 00 00 	movabs $0x822d48,%rax
  816c4b:	00 00 00 
  816c4e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  816c52:	e9 ee 00 00 00       	jmpq   816d45 <etharp_output+0x162>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  816c57:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816c5b:	8b 18                	mov    (%rax),%ebx
  816c5d:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  816c62:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  816c69:	00 00 00 
  816c6c:	ff d0                	callq  *%rax
  816c6e:	21 c3                	and    %eax,%ebx
  816c70:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  816c75:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  816c7c:	00 00 00 
  816c7f:	ff d0                	callq  *%rax
  816c81:	39 c3                	cmp    %eax,%ebx
  816c83:	75 64                	jne    816ce9 <etharp_output+0x106>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  816c85:	c6 45 e0 01          	movb   $0x1,-0x20(%rbp)
    mcastaddr.addr[1] = 0x00;
  816c89:	c6 45 e1 00          	movb   $0x0,-0x1f(%rbp)
    mcastaddr.addr[2] = 0x5e;
  816c8d:	c6 45 e2 5e          	movb   $0x5e,-0x1e(%rbp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  816c91:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816c95:	8b 00                	mov    (%rax),%eax
  816c97:	89 c7                	mov    %eax,%edi
  816c99:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  816ca0:	00 00 00 
  816ca3:	ff d0                	callq  *%rax
  816ca5:	c1 e8 10             	shr    $0x10,%eax
  816ca8:	83 e0 7f             	and    $0x7f,%eax
  816cab:	88 45 e3             	mov    %al,-0x1d(%rbp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  816cae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816cb2:	8b 00                	mov    (%rax),%eax
  816cb4:	89 c7                	mov    %eax,%edi
  816cb6:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  816cbd:	00 00 00 
  816cc0:	ff d0                	callq  *%rax
  816cc2:	c1 e8 08             	shr    $0x8,%eax
  816cc5:	88 45 e4             	mov    %al,-0x1c(%rbp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  816cc8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816ccc:	8b 00                	mov    (%rax),%eax
  816cce:	89 c7                	mov    %eax,%edi
  816cd0:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  816cd7:	00 00 00 
  816cda:	ff d0                	callq  *%rax
  816cdc:	88 45 e5             	mov    %al,-0x1b(%rbp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  816cdf:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  816ce3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  816ce7:	eb 5c                	jmp    816d45 <etharp_output+0x162>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  816ce9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816ced:	8b 10                	mov    (%rax),%edx
  816cef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816cf3:	8b 40 08             	mov    0x8(%rax),%eax
  816cf6:	31 c2                	xor    %eax,%edx
  816cf8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816cfc:	8b 40 0c             	mov    0xc(%rax),%eax
  816cff:	21 d0                	and    %edx,%eax
  816d01:	85 c0                	test   %eax,%eax
  816d03:	74 20                	je     816d25 <etharp_output+0x142>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  816d05:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816d09:	8b 40 10             	mov    0x10(%rax),%eax
  816d0c:	85 c0                	test   %eax,%eax
  816d0e:	74 0e                	je     816d1e <etharp_output+0x13b>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  816d10:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816d14:	48 83 c0 10          	add    $0x10,%rax
  816d18:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  816d1c:	eb 07                	jmp    816d25 <etharp_output+0x142>
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  816d1e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  816d23:	eb 49                	jmp    816d6e <etharp_output+0x18b>
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  816d25:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  816d29:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  816d2d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816d31:	48 89 ce             	mov    %rcx,%rsi
  816d34:	48 89 c7             	mov    %rax,%rdi
  816d37:	48 b8 75 6d 81 00 00 	movabs $0x816d75,%rax
  816d3e:	00 00 00 
  816d41:	ff d0                	callq  *%rax
  816d43:	eb 29                	jmp    816d6e <etharp_output+0x18b>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  816d45:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816d49:	48 8d 78 41          	lea    0x41(%rax),%rdi
  816d4d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816d51:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  816d55:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816d59:	48 89 d1             	mov    %rdx,%rcx
  816d5c:	48 89 fa             	mov    %rdi,%rdx
  816d5f:	48 89 c7             	mov    %rax,%rdi
  816d62:	48 b8 a4 63 81 00 00 	movabs $0x8163a4,%rax
  816d69:	00 00 00 
  816d6c:	ff d0                	callq  *%rax
}
  816d6e:	48 83 c4 38          	add    $0x38,%rsp
  816d72:	5b                   	pop    %rbx
  816d73:	5d                   	pop    %rbp
  816d74:	c3                   	retq   

0000000000816d75 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  816d75:	55                   	push   %rbp
  816d76:	48 89 e5             	mov    %rsp,%rbp
  816d79:	53                   	push   %rbx
  816d7a:	48 83 ec 68          	sub    $0x68,%rsp
  816d7e:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  816d82:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  816d86:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  816d8a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816d8e:	48 83 c0 41          	add    $0x41,%rax
  816d92:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  err_t result = ERR_MEM;
  816d96:	c6 45 ef ff          	movb   $0xff,-0x11(%rbp)
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  816d9a:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  816d9e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816da2:	48 89 d6             	mov    %rdx,%rsi
  816da5:	48 89 c7             	mov    %rax,%rdi
  816da8:	48 b8 eb 0d 81 00 00 	movabs $0x810deb,%rax
  816daf:	00 00 00 
  816db2:	ff d0                	callq  *%rax
  816db4:	84 c0                	test   %al,%al
  816db6:	75 3f                	jne    816df7 <etharp_query+0x82>
      ip_addr_ismulticast(ipaddr) ||
  816db8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816dbc:	8b 18                	mov    (%rax),%ebx
  816dbe:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  816dc3:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  816dca:	00 00 00 
  816dcd:	ff d0                	callq  *%rax
  816dcf:	21 c3                	and    %eax,%ebx
  816dd1:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  816dd6:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  816ddd:	00 00 00 
  816de0:	ff d0                	callq  *%rax
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  816de2:	39 c3                	cmp    %eax,%ebx
  816de4:	74 11                	je     816df7 <etharp_query+0x82>
      ip_addr_ismulticast(ipaddr) ||
  816de6:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  816deb:	74 0a                	je     816df7 <etharp_query+0x82>
      ip_addr_isany(ipaddr)) {
  816ded:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816df1:	8b 00                	mov    (%rax),%eax
  816df3:	85 c0                	test   %eax,%eax
  816df5:	75 0a                	jne    816e01 <etharp_query+0x8c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  816df7:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  816dfc:	e9 18 04 00 00       	jmpq   817219 <etharp_query+0x4a4>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  816e01:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816e05:	be 01 00 00 00       	mov    $0x1,%esi
  816e0a:	48 89 c7             	mov    %rax,%rdi
  816e0d:	48 b8 10 5e 81 00 00 	movabs $0x815e10,%rax
  816e14:	00 00 00 
  816e17:	ff d0                	callq  *%rax
  816e19:	88 45 c7             	mov    %al,-0x39(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  816e1c:	80 7d c7 00          	cmpb   $0x0,-0x39(%rbp)
  816e20:	79 09                	jns    816e2b <etharp_query+0xb6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
    }
    return (err_t)i;
  816e22:	0f b6 45 c7          	movzbl -0x39(%rbp),%eax
  816e26:	e9 ee 03 00 00       	jmpq   817219 <etharp_query+0x4a4>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  816e2b:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816e2f:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816e36:	00 00 00 
  816e39:	48 63 d0             	movslq %eax,%rdx
  816e3c:	48 89 d0             	mov    %rdx,%rax
  816e3f:	48 c1 e0 02          	shl    $0x2,%rax
  816e43:	48 01 d0             	add    %rdx,%rax
  816e46:	48 c1 e0 03          	shl    $0x3,%rax
  816e4a:	48 01 c8             	add    %rcx,%rax
  816e4d:	48 83 c0 14          	add    $0x14,%rax
  816e51:	8b 00                	mov    (%rax),%eax
  816e53:	85 c0                	test   %eax,%eax
  816e55:	75 2c                	jne    816e83 <etharp_query+0x10e>
    arp_table[i].state = ETHARP_STATE_PENDING;
  816e57:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816e5b:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816e62:	00 00 00 
  816e65:	48 63 d0             	movslq %eax,%rdx
  816e68:	48 89 d0             	mov    %rdx,%rax
  816e6b:	48 c1 e0 02          	shl    $0x2,%rax
  816e6f:	48 01 d0             	add    %rdx,%rax
  816e72:	48 c1 e0 03          	shl    $0x3,%rax
  816e76:	48 01 c8             	add    %rcx,%rax
  816e79:	48 83 c0 14          	add    $0x14,%rax
  816e7d:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  816e83:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816e87:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816e8e:	00 00 00 
  816e91:	48 63 d0             	movslq %eax,%rdx
  816e94:	48 89 d0             	mov    %rdx,%rax
  816e97:	48 c1 e0 02          	shl    $0x2,%rax
  816e9b:	48 01 d0             	add    %rdx,%rax
  816e9e:	48 c1 e0 03          	shl    $0x3,%rax
  816ea2:	48 01 c8             	add    %rcx,%rax
  816ea5:	48 83 c0 14          	add    $0x14,%rax
  816ea9:	8b 00                	mov    (%rax),%eax
  816eab:	83 f8 01             	cmp    $0x1,%eax
  816eae:	74 57                	je     816f07 <etharp_query+0x192>
  816eb0:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816eb4:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816ebb:	00 00 00 
  816ebe:	48 63 d0             	movslq %eax,%rdx
  816ec1:	48 89 d0             	mov    %rdx,%rax
  816ec4:	48 c1 e0 02          	shl    $0x2,%rax
  816ec8:	48 01 d0             	add    %rdx,%rax
  816ecb:	48 c1 e0 03          	shl    $0x3,%rax
  816ecf:	48 01 c8             	add    %rcx,%rax
  816ed2:	48 83 c0 14          	add    $0x14,%rax
  816ed6:	8b 00                	mov    (%rax),%eax
  816ed8:	83 f8 02             	cmp    $0x2,%eax
  816edb:	74 2a                	je     816f07 <etharp_query+0x192>
  816edd:	48 ba 40 2e 82 00 00 	movabs $0x822e40,%rdx
  816ee4:	00 00 00 
  816ee7:	be 93 03 00 00       	mov    $0x393,%esi
  816eec:	48 bf 5e 2d 82 00 00 	movabs $0x822d5e,%rdi
  816ef3:	00 00 00 
  816ef6:	b8 00 00 00 00       	mov    $0x0,%eax
  816efb:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  816f02:	00 00 00 
  816f05:	ff d1                	callq  *%rcx
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  816f07:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816f0b:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816f12:	00 00 00 
  816f15:	48 63 d0             	movslq %eax,%rdx
  816f18:	48 89 d0             	mov    %rdx,%rax
  816f1b:	48 c1 e0 02          	shl    $0x2,%rax
  816f1f:	48 01 d0             	add    %rdx,%rax
  816f22:	48 c1 e0 03          	shl    $0x3,%rax
  816f26:	48 01 c8             	add    %rcx,%rax
  816f29:	48 83 c0 14          	add    $0x14,%rax
  816f2d:	8b 00                	mov    (%rax),%eax
  816f2f:	83 f8 01             	cmp    $0x1,%eax
  816f32:	74 07                	je     816f3b <etharp_query+0x1c6>
  816f34:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  816f39:	75 1d                	jne    816f58 <etharp_query+0x1e3>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  816f3b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  816f3f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816f43:	48 89 d6             	mov    %rdx,%rsi
  816f46:	48 89 c7             	mov    %rax,%rdi
  816f49:	48 b8 60 74 81 00 00 	movabs $0x817460,%rax
  816f50:	00 00 00 
  816f53:	ff d0                	callq  *%rax
  816f55:	88 45 ef             	mov    %al,-0x11(%rbp)
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  816f58:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  816f5d:	0f 84 b2 02 00 00    	je     817215 <etharp_query+0x4a0>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  816f63:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816f67:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816f6e:	00 00 00 
  816f71:	48 63 d0             	movslq %eax,%rdx
  816f74:	48 89 d0             	mov    %rdx,%rax
  816f77:	48 c1 e0 02          	shl    $0x2,%rax
  816f7b:	48 01 d0             	add    %rdx,%rax
  816f7e:	48 c1 e0 03          	shl    $0x3,%rax
  816f82:	48 01 c8             	add    %rcx,%rax
  816f85:	48 83 c0 14          	add    $0x14,%rax
  816f89:	8b 00                	mov    (%rax),%eax
  816f8b:	83 f8 02             	cmp    $0x2,%eax
  816f8e:	75 49                	jne    816fd9 <etharp_query+0x264>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  816f90:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816f94:	48 63 d0             	movslq %eax,%rdx
  816f97:	48 89 d0             	mov    %rdx,%rax
  816f9a:	48 c1 e0 02          	shl    $0x2,%rax
  816f9e:	48 01 d0             	add    %rdx,%rax
  816fa1:	48 c1 e0 03          	shl    $0x3,%rax
  816fa5:	48 ba 80 b6 b4 00 00 	movabs $0xb4b680,%rdx
  816fac:	00 00 00 
  816faf:	48 01 d0             	add    %rdx,%rax
  816fb2:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  816fb6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  816fba:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  816fbe:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816fc2:	48 89 c7             	mov    %rax,%rdi
  816fc5:	48 b8 a4 63 81 00 00 	movabs $0x8163a4,%rax
  816fcc:	00 00 00 
  816fcf:	ff d0                	callq  *%rax
  816fd1:	88 45 ef             	mov    %al,-0x11(%rbp)
  816fd4:	e9 3c 02 00 00       	jmpq   817215 <etharp_query+0x4a0>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  816fd9:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816fdd:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816fe4:	00 00 00 
  816fe7:	48 63 d0             	movslq %eax,%rdx
  816fea:	48 89 d0             	mov    %rdx,%rax
  816fed:	48 c1 e0 02          	shl    $0x2,%rax
  816ff1:	48 01 d0             	add    %rdx,%rax
  816ff4:	48 c1 e0 03          	shl    $0x3,%rax
  816ff8:	48 01 c8             	add    %rcx,%rax
  816ffb:	48 83 c0 14          	add    $0x14,%rax
  816fff:	8b 00                	mov    (%rax),%eax
  817001:	83 f8 01             	cmp    $0x1,%eax
  817004:	0f 85 0b 02 00 00    	jne    817215 <etharp_query+0x4a0>
#if ARP_QUEUEING /* queue the given q packet */
      struct pbuf *p;
      int copy_needed = 0;
  81700a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
  817011:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  817015:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      while (p) {
  817019:	eb 6b                	jmp    817086 <etharp_query+0x311>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  81701b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81701f:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  817023:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817027:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81702b:	66 39 c2             	cmp    %ax,%dx
  81702e:	75 36                	jne    817066 <etharp_query+0x2f1>
  817030:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817034:	48 8b 00             	mov    (%rax),%rax
  817037:	48 85 c0             	test   %rax,%rax
  81703a:	74 2a                	je     817066 <etharp_query+0x2f1>
  81703c:	48 ba 68 2e 82 00 00 	movabs $0x822e68,%rdx
  817043:	00 00 00 
  817046:	be b2 03 00 00       	mov    $0x3b2,%esi
  81704b:	48 bf 5e 2d 82 00 00 	movabs $0x822d5e,%rdi
  817052:	00 00 00 
  817055:	b8 00 00 00 00       	mov    $0x0,%eax
  81705a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  817061:	00 00 00 
  817064:	ff d1                	callq  *%rcx
        if(p->type != PBUF_ROM) {
  817066:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81706a:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  81706e:	3c 01                	cmp    $0x1,%al
  817070:	74 09                	je     81707b <etharp_query+0x306>
          copy_needed = 1;
  817072:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)
          break;
  817079:	eb 12                	jmp    81708d <etharp_query+0x318>
        }
        p = p->next;
  81707b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81707f:	48 8b 00             	mov    (%rax),%rax
  817082:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  817086:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81708b:	75 8e                	jne    81701b <etharp_query+0x2a6>
          copy_needed = 1;
          break;
        }
        p = p->next;
      }
      if(copy_needed) {
  81708d:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  817091:	74 69                	je     8170fc <etharp_query+0x387>
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  817093:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817097:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81709b:	0f b7 c0             	movzwl %ax,%eax
  81709e:	ba 00 00 00 00       	mov    $0x0,%edx
  8170a3:	89 c6                	mov    %eax,%esi
  8170a5:	bf 03 00 00 00       	mov    $0x3,%edi
  8170aa:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  8170b1:	00 00 00 
  8170b4:	ff d0                	callq  *%rax
  8170b6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        if(p != NULL) {
  8170ba:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8170bf:	74 56                	je     817117 <etharp_query+0x3a2>
          if (pbuf_copy(p, q) != ERR_OK) {
  8170c1:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8170c5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8170c9:	48 89 d6             	mov    %rdx,%rsi
  8170cc:	48 89 c7             	mov    %rax,%rdi
  8170cf:	48 b8 4a e2 80 00 00 	movabs $0x80e24a,%rax
  8170d6:	00 00 00 
  8170d9:	ff d0                	callq  *%rax
  8170db:	84 c0                	test   %al,%al
  8170dd:	74 38                	je     817117 <etharp_query+0x3a2>
            pbuf_free(p);
  8170df:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8170e3:	48 89 c7             	mov    %rax,%rdi
  8170e6:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  8170ed:	00 00 00 
  8170f0:	ff d0                	callq  *%rax
            p = NULL;
  8170f2:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8170f9:	00 
  8170fa:	eb 1b                	jmp    817117 <etharp_query+0x3a2>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
  8170fc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  817100:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        pbuf_ref(p);
  817104:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817108:	48 89 c7             	mov    %rax,%rdi
  81710b:	48 b8 ab df 80 00 00 	movabs $0x80dfab,%rax
  817112:	00 00 00 
  817115:	ff d0                	callq  *%rax
      }
      /* packet could be taken over? */
      if (p != NULL) {
  817117:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81711c:	0f 84 f3 00 00 00    	je     817215 <etharp_query+0x4a0>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  817122:	bf 0a 00 00 00       	mov    $0xa,%edi
  817127:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  81712e:	00 00 00 
  817131:	ff d0                	callq  *%rax
  817133:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        if (new_entry != NULL) {
  817137:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  81713c:	0f 84 c0 00 00 00    	je     817202 <etharp_query+0x48d>
          new_entry->next = 0;
  817142:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  817146:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
          new_entry->p = p;
  81714d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  817151:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  817155:	48 89 50 08          	mov    %rdx,0x8(%rax)
          if(arp_table[i].q != NULL) {
  817159:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  81715d:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  817164:	00 00 00 
  817167:	48 63 d0             	movslq %eax,%rdx
  81716a:	48 89 d0             	mov    %rdx,%rax
  81716d:	48 c1 e0 02          	shl    $0x2,%rax
  817171:	48 01 d0             	add    %rdx,%rax
  817174:	48 c1 e0 03          	shl    $0x3,%rax
  817178:	48 01 c8             	add    %rcx,%rax
  81717b:	48 8b 00             	mov    (%rax),%rax
  81717e:	48 85 c0             	test   %rax,%rax
  817181:	74 4f                	je     8171d2 <etharp_query+0x45d>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
  817183:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  817187:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81718e:	00 00 00 
  817191:	48 63 d0             	movslq %eax,%rdx
  817194:	48 89 d0             	mov    %rdx,%rax
  817197:	48 c1 e0 02          	shl    $0x2,%rax
  81719b:	48 01 d0             	add    %rdx,%rax
  81719e:	48 c1 e0 03          	shl    $0x3,%rax
  8171a2:	48 01 c8             	add    %rcx,%rax
  8171a5:	48 8b 00             	mov    (%rax),%rax
  8171a8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
            while (r->next != NULL) {
  8171ac:	eb 0b                	jmp    8171b9 <etharp_query+0x444>
              r = r->next;
  8171ae:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8171b2:	48 8b 00             	mov    (%rax),%rax
  8171b5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  8171b9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8171bd:	48 8b 00             	mov    (%rax),%rax
  8171c0:	48 85 c0             	test   %rax,%rax
  8171c3:	75 e9                	jne    8171ae <etharp_query+0x439>
              r = r->next;
            }
            r->next = new_entry;
  8171c5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8171c9:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8171cd:	48 89 10             	mov    %rdx,(%rax)
  8171d0:	eb 2a                	jmp    8171fc <etharp_query+0x487>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  8171d2:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  8171d6:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8171dd:	00 00 00 
  8171e0:	48 63 d0             	movslq %eax,%rdx
  8171e3:	48 89 d0             	mov    %rdx,%rax
  8171e6:	48 c1 e0 02          	shl    $0x2,%rax
  8171ea:	48 01 d0             	add    %rdx,%rax
  8171ed:	48 c1 e0 03          	shl    $0x3,%rax
  8171f1:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8171f5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8171f9:	48 89 02             	mov    %rax,(%rdx)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  8171fc:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  817200:	eb 13                	jmp    817215 <etharp_query+0x4a0>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  817202:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817206:	48 89 c7             	mov    %rax,%rdi
  817209:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  817210:	00 00 00 
  817213:	ff d0                	callq  *%rax
      /* { result == ERR_MEM } through initialization */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
  817215:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  817219:	48 83 c4 68          	add    $0x68,%rsp
  81721d:	5b                   	pop    %rbx
  81721e:	5d                   	pop    %rbp
  81721f:	c3                   	retq   

0000000000817220 <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const struct ip_addr *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const struct ip_addr *ipdst_addr,
           const u16_t opcode)
{
  817220:	55                   	push   %rbp
  817221:	48 89 e5             	mov    %rsp,%rbp
  817224:	48 83 ec 60          	sub    $0x60,%rsp
  817228:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81722c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  817230:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  817234:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  817238:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  81723c:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
  817240:	8b 45 18             	mov    0x18(%rbp),%eax
  817243:	66 89 45 ac          	mov    %ax,-0x54(%rbp)
  struct pbuf *p;
  err_t result = ERR_OK;
  817247:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  81724b:	ba 00 00 00 00       	mov    $0x0,%edx
  817250:	be 2a 00 00 00       	mov    $0x2a,%esi
  817255:	bf 02 00 00 00       	mov    $0x2,%edi
  81725a:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  817261:	00 00 00 
  817264:	ff d0                	callq  *%rax
  817266:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  81726a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81726f:	75 0a                	jne    81727b <etharp_raw+0x5b>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  817271:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817276:	e9 e3 01 00 00       	jmpq   81745e <etharp_raw+0x23e>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  81727b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81727f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  817283:	66 83 f8 29          	cmp    $0x29,%ax
  817287:	77 2a                	ja     8172b3 <etharp_raw+0x93>
  817289:	48 ba 88 2e 82 00 00 	movabs $0x822e88,%rdx
  817290:	00 00 00 
  817293:	be 1d 04 00 00       	mov    $0x41d,%esi
  817298:	48 bf 5e 2d 82 00 00 	movabs $0x822d5e,%rdi
  81729f:	00 00 00 
  8172a2:	b8 00 00 00 00       	mov    $0x0,%eax
  8172a7:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8172ae:	00 00 00 
  8172b1:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  8172b3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8172b7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8172bb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  8172bf:	0f b7 45 ac          	movzwl -0x54(%rbp),%eax
  8172c3:	89 c7                	mov    %eax,%edi
  8172c5:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8172cc:	00 00 00 
  8172cf:	ff d0                	callq  *%rax
  8172d1:	89 c2                	mov    %eax,%edx
  8172d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8172d7:	66 89 50 14          	mov    %dx,0x14(%rax)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8172db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8172df:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  8172e3:	3c 06                	cmp    $0x6,%al
  8172e5:	74 2a                	je     817311 <etharp_raw+0xf1>
  8172e7:	48 ba c0 2d 82 00 00 	movabs $0x822dc0,%rdx
  8172ee:	00 00 00 
  8172f1:	be 24 04 00 00       	mov    $0x424,%esi
  8172f6:	48 bf 5e 2d 82 00 00 	movabs $0x822d5e,%rdi
  8172fd:	00 00 00 
  817300:	b8 00 00 00 00       	mov    $0x0,%eax
  817305:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81730c:	00 00 00 
  81730f:	ff d1                	callq  *%rcx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  817311:	c6 45 ff 06          	movb   $0x6,-0x1(%rbp)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  817315:	eb 7d                	jmp    817394 <etharp_raw+0x174>
    k--;
  817317:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81731b:	83 e8 01             	sub    $0x1,%eax
  81731e:	88 45 ff             	mov    %al,-0x1(%rbp)
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  817321:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  817325:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  817329:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  81732d:	48 98                	cltq   
  81732f:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  817333:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  817337:	48 63 c6             	movslq %esi,%rax
  81733a:	88 4c 02 16          	mov    %cl,0x16(%rdx,%rax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  81733e:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  817342:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  817346:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  81734a:	48 98                	cltq   
  81734c:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  817350:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  817354:	48 63 c6             	movslq %esi,%rax
  817357:	88 4c 02 20          	mov    %cl,0x20(%rdx,%rax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  81735b:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  81735f:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  817363:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  817367:	48 98                	cltq   
  817369:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  81736d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  817371:	48 63 c6             	movslq %esi,%rax
  817374:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  817377:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  81737b:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81737f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  817383:	48 98                	cltq   
  817385:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  817389:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81738d:	48 63 c6             	movslq %esi,%rax
  817390:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  817394:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  817398:	0f 85 79 ff ff ff    	jne    817317 <etharp_raw+0xf7>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  81739e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8173a2:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8173a6:	8b 12                	mov    (%rdx),%edx
  8173a8:	89 50 1c             	mov    %edx,0x1c(%rax)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  8173ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8173af:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8173b3:	8b 12                	mov    (%rdx),%edx
  8173b5:	89 50 26             	mov    %edx,0x26(%rax)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  8173b8:	bf 01 00 00 00       	mov    $0x1,%edi
  8173bd:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8173c4:	00 00 00 
  8173c7:	ff d0                	callq  *%rax
  8173c9:	89 c2                	mov    %eax,%edx
  8173cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8173cf:	66 89 50 0e          	mov    %dx,0xe(%rax)
  hdr->proto = htons(ETHTYPE_IP);
  8173d3:	bf 00 08 00 00       	mov    $0x800,%edi
  8173d8:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8173df:	00 00 00 
  8173e2:	ff d0                	callq  *%rax
  8173e4:	89 c2                	mov    %eax,%edx
  8173e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8173ea:	66 89 50 10          	mov    %dx,0x10(%rax)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  8173ee:	bf 04 06 00 00       	mov    $0x604,%edi
  8173f3:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8173fa:	00 00 00 
  8173fd:	ff d0                	callq  *%rax
  8173ff:	89 c2                	mov    %eax,%edx
  817401:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817405:	66 89 50 12          	mov    %dx,0x12(%rax)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  817409:	bf 06 08 00 00       	mov    $0x806,%edi
  81740e:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  817415:	00 00 00 
  817418:	ff d0                	callq  *%rax
  81741a:	89 c2                	mov    %eax,%edx
  81741c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817420:	66 89 50 0c          	mov    %dx,0xc(%rax)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  817424:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  817428:	48 8b 40 28          	mov    0x28(%rax),%rax
  81742c:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  817430:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  817434:	48 89 ce             	mov    %rcx,%rsi
  817437:	48 89 d7             	mov    %rdx,%rdi
  81743a:	ff d0                	callq  *%rax
  81743c:	88 45 fe             	mov    %al,-0x2(%rbp)
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  81743f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  817443:	48 89 c7             	mov    %rax,%rdi
  817446:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81744d:	00 00 00 
  817450:	ff d0                	callq  *%rax
  p = NULL;
  817452:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  817459:	00 
  /* could not allocate pbuf for ARP request */

  return result;
  81745a:	0f b6 45 fe          	movzbl -0x2(%rbp),%eax
}
  81745e:	c9                   	leaveq 
  81745f:	c3                   	retq   

0000000000817460 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  817460:	55                   	push   %rbp
  817461:	48 89 e5             	mov    %rsp,%rbp
  817464:	48 83 ec 10          	sub    $0x10,%rsp
  817468:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81746c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
  817470:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817474:	48 8d 48 08          	lea    0x8(%rax),%rcx
  817478:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81747c:	48 8d 50 41          	lea    0x41(%rax),%rdx
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  817480:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817484:	48 8d 70 41          	lea    0x41(%rax),%rsi
  817488:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81748c:	6a 01                	pushq  $0x1
  81748e:	ff 75 f0             	pushq  -0x10(%rbp)
  817491:	49 b9 4e 2d 82 00 00 	movabs $0x822d4e,%r9
  817498:	00 00 00 
  81749b:	49 89 c8             	mov    %rcx,%r8
  81749e:	48 89 d1             	mov    %rdx,%rcx
  8174a1:	48 ba 48 2d 82 00 00 	movabs $0x822d48,%rdx
  8174a8:	00 00 00 
  8174ab:	48 89 c7             	mov    %rax,%rdi
  8174ae:	48 b8 20 72 81 00 00 	movabs $0x817220,%rax
  8174b5:	00 00 00 
  8174b8:	ff d0                	callq  *%rax
  8174ba:	48 83 c4 10          	add    $0x10,%rsp
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  8174be:	c9                   	leaveq 
  8174bf:	c3                   	retq   

00000000008174c0 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  8174c0:	55                   	push   %rbp
  8174c1:	48 89 e5             	mov    %rsp,%rbp
  8174c4:	48 83 ec 20          	sub    $0x20,%rsp
  8174c8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8174cc:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct eth_hdr* ethhdr;

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
  8174d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8174d4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8174d8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  8174dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8174e0:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8174e4:	0f b7 c0             	movzwl %ax,%eax
  8174e7:	89 c7                	mov    %eax,%edi
  8174e9:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8174f0:	00 00 00 
  8174f3:	ff d0                	callq  *%rax
  8174f5:	0f b7 c0             	movzwl %ax,%eax
  8174f8:	3d 00 08 00 00       	cmp    $0x800,%eax
  8174fd:	74 10                	je     81750f <ethernet_input+0x4f>
  8174ff:	3d 06 08 00 00       	cmp    $0x806,%eax
  817504:	0f 84 81 00 00 00    	je     81758b <ethernet_input+0xcb>
  81750a:	e9 a0 00 00 00       	jmpq   8175af <ethernet_input+0xef>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  81750f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  817513:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817517:	48 89 d6             	mov    %rdx,%rsi
  81751a:	48 89 c7             	mov    %rax,%rdi
  81751d:	48 b8 02 68 81 00 00 	movabs $0x816802,%rax
  817524:	00 00 00 
  817527:	ff d0                	callq  *%rax
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  817529:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81752d:	be f2 ff ff ff       	mov    $0xfffffff2,%esi
  817532:	48 89 c7             	mov    %rax,%rdi
  817535:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  81753c:	00 00 00 
  81753f:	ff d0                	callq  *%rax
  817541:	84 c0                	test   %al,%al
  817543:	74 2a                	je     81756f <ethernet_input+0xaf>
        LWIP_ASSERT("Can't move over header in packet", 0);
  817545:	48 ba c0 2e 82 00 00 	movabs $0x822ec0,%rdx
  81754c:	00 00 00 
  81754f:	be 7f 04 00 00       	mov    $0x47f,%esi
  817554:	48 bf 5e 2d 82 00 00 	movabs $0x822d5e,%rdi
  81755b:	00 00 00 
  81755e:	b8 00 00 00 00       	mov    $0x0,%eax
  817563:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81756a:	00 00 00 
  81756d:	ff d1                	callq  *%rcx
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  81756f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  817573:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817577:	48 89 d6             	mov    %rdx,%rsi
  81757a:	48 89 c7             	mov    %rax,%rdi
  81757d:	48 b8 3a 0f 81 00 00 	movabs $0x810f3a,%rax
  817584:	00 00 00 
  817587:	ff d0                	callq  *%rax
      }
      break;
  817589:	eb 40                	jmp    8175cb <ethernet_input+0x10b>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  81758b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81758f:	48 8d 48 41          	lea    0x41(%rax),%rcx
  817593:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  817597:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81759b:	48 89 ce             	mov    %rcx,%rsi
  81759e:	48 89 c7             	mov    %rax,%rdi
  8175a1:	48 b8 99 68 81 00 00 	movabs $0x816899,%rax
  8175a8:	00 00 00 
  8175ab:	ff d0                	callq  *%rax
      break;
  8175ad:	eb 1c                	jmp    8175cb <ethernet_input+0x10b>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  8175af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8175b3:	48 89 c7             	mov    %rax,%rdi
  8175b6:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  8175bd:	00 00 00 
  8175c0:	ff d0                	callq  *%rax
      p = NULL;
  8175c2:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8175c9:	00 
      break;
  8175ca:	90                   	nop
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
  8175cb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8175d0:	c9                   	leaveq 
  8175d1:	c3                   	retq   

00000000008175d2 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  8175d2:	55                   	push   %rbp
  8175d3:	48 89 e5             	mov    %rsp,%rbp
  8175d6:	48 83 ec 10          	sub    $0x10,%rsp
    int i = 0;
  8175da:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    for (i = 0; i < NSEM; i++) {
  8175e1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8175e8:	e9 e9 00 00 00       	jmpq   8176d6 <sys_init+0x104>
	sems[i].freed = 1;
  8175ed:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8175f4:	00 00 00 
  8175f7:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8175fa:	48 63 d2             	movslq %edx,%rdx
  8175fd:	48 c1 e2 05          	shl    $0x5,%rdx
  817601:	48 01 d0             	add    %rdx,%rax
  817604:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  81760a:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817611:	00 00 00 
  817614:	48 8b 00             	mov    (%rax),%rax
  817617:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  81761e:	00 00 00 
  817621:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  817624:	48 63 c9             	movslq %ecx,%rcx
  817627:	48 c1 e1 05          	shl    $0x5,%rcx
  81762b:	48 01 ca             	add    %rcx,%rdx
  81762e:	48 83 c2 10          	add    $0x10,%rdx
  817632:	48 89 02             	mov    %rax,(%rdx)
  817635:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  81763c:	00 00 00 
  81763f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817642:	48 63 d2             	movslq %edx,%rdx
  817645:	48 c1 e2 05          	shl    $0x5,%rdx
  817649:	48 01 d0             	add    %rdx,%rax
  81764c:	48 83 c0 10          	add    $0x10,%rax
  817650:	48 8b 00             	mov    (%rax),%rax
  817653:	48 85 c0             	test   %rax,%rax
  817656:	74 2c                	je     817684 <sys_init+0xb2>
  817658:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  81765f:	00 00 00 
  817662:	48 8b 00             	mov    (%rax),%rax
  817665:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817668:	48 63 d2             	movslq %edx,%rdx
  81766b:	48 c1 e2 05          	shl    $0x5,%rdx
  81766f:	48 8d 4a 10          	lea    0x10(%rdx),%rcx
  817673:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  81767a:	00 00 00 
  81767d:	48 01 ca             	add    %rcx,%rdx
  817680:	48 89 50 18          	mov    %rdx,0x18(%rax)
  817684:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817687:	48 98                	cltq   
  817689:	48 c1 e0 05          	shl    $0x5,%rax
  81768d:	48 89 c2             	mov    %rax,%rdx
  817690:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817697:	00 00 00 
  81769a:	48 01 c2             	add    %rax,%rdx
  81769d:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  8176a4:	00 00 00 
  8176a7:	48 89 10             	mov    %rdx,(%rax)
  8176aa:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8176b1:	00 00 00 
  8176b4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8176b7:	48 63 d2             	movslq %edx,%rdx
  8176ba:	48 c1 e2 05          	shl    $0x5,%rdx
  8176be:	48 01 d0             	add    %rdx,%rax
  8176c1:	48 83 c0 18          	add    $0x18,%rax
  8176c5:	48 bf 20 d8 b4 00 00 	movabs $0xb4d820,%rdi
  8176cc:	00 00 00 
  8176cf:	48 89 38             	mov    %rdi,(%rax)

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  8176d2:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8176d6:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%rbp)
  8176dd:	0f 8e 0a ff ff ff    	jle    8175ed <sys_init+0x1b>
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  8176e3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8176ea:	e9 5d 01 00 00       	jmpq   81784c <sys_init+0x27a>
	mboxes[i].freed = 1;
  8176ef:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8176f6:	00 00 00 
  8176f9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8176fc:	48 63 d0             	movslq %eax,%rdx
  8176ff:	48 89 d0             	mov    %rdx,%rax
  817702:	48 c1 e0 03          	shl    $0x3,%rax
  817706:	48 01 d0             	add    %rdx,%rax
  817709:	48 c1 e0 02          	shl    $0x2,%rax
  81770d:	48 01 d0             	add    %rdx,%rax
  817710:	48 c1 e0 03          	shl    $0x3,%rax
  817714:	48 01 c8             	add    %rcx,%rax
  817717:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  81771d:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817724:	00 00 00 
  817727:	48 8b 08             	mov    (%rax),%rcx
  81772a:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  817731:	00 00 00 
  817734:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817737:	48 63 d0             	movslq %eax,%rdx
  81773a:	48 89 d0             	mov    %rdx,%rax
  81773d:	48 c1 e0 03          	shl    $0x3,%rax
  817741:	48 01 d0             	add    %rdx,%rax
  817744:	48 c1 e0 02          	shl    $0x2,%rax
  817748:	48 01 d0             	add    %rdx,%rax
  81774b:	48 c1 e0 03          	shl    $0x3,%rax
  81774f:	48 01 f0             	add    %rsi,%rax
  817752:	48 05 18 01 00 00    	add    $0x118,%rax
  817758:	48 89 08             	mov    %rcx,(%rax)
  81775b:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817762:	00 00 00 
  817765:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817768:	48 63 d0             	movslq %eax,%rdx
  81776b:	48 89 d0             	mov    %rdx,%rax
  81776e:	48 c1 e0 03          	shl    $0x3,%rax
  817772:	48 01 d0             	add    %rdx,%rax
  817775:	48 c1 e0 02          	shl    $0x2,%rax
  817779:	48 01 d0             	add    %rdx,%rax
  81777c:	48 c1 e0 03          	shl    $0x3,%rax
  817780:	48 01 c8             	add    %rcx,%rax
  817783:	48 05 18 01 00 00    	add    $0x118,%rax
  817789:	48 8b 00             	mov    (%rax),%rax
  81778c:	48 85 c0             	test   %rax,%rax
  81778f:	74 47                	je     8177d8 <sys_init+0x206>
  817791:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817798:	00 00 00 
  81779b:	48 8b 08             	mov    (%rax),%rcx
  81779e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8177a1:	48 63 d0             	movslq %eax,%rdx
  8177a4:	48 89 d0             	mov    %rdx,%rax
  8177a7:	48 c1 e0 03          	shl    $0x3,%rax
  8177ab:	48 01 d0             	add    %rdx,%rax
  8177ae:	48 c1 e0 02          	shl    $0x2,%rax
  8177b2:	48 01 d0             	add    %rdx,%rax
  8177b5:	48 c1 e0 03          	shl    $0x3,%rax
  8177b9:	48 8d 90 10 01 00 00 	lea    0x110(%rax),%rdx
  8177c0:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  8177c7:	00 00 00 
  8177ca:	48 01 d0             	add    %rdx,%rax
  8177cd:	48 83 c0 08          	add    $0x8,%rax
  8177d1:	48 89 81 20 01 00 00 	mov    %rax,0x120(%rcx)
  8177d8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8177db:	48 63 d0             	movslq %eax,%rdx
  8177de:	48 89 d0             	mov    %rdx,%rax
  8177e1:	48 c1 e0 03          	shl    $0x3,%rax
  8177e5:	48 01 d0             	add    %rdx,%rax
  8177e8:	48 c1 e0 02          	shl    $0x2,%rax
  8177ec:	48 01 d0             	add    %rdx,%rax
  8177ef:	48 c1 e0 03          	shl    $0x3,%rax
  8177f3:	48 ba 40 d8 b4 00 00 	movabs $0xb4d840,%rdx
  8177fa:	00 00 00 
  8177fd:	48 01 c2             	add    %rax,%rdx
  817800:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817807:	00 00 00 
  81780a:	48 89 10             	mov    %rdx,(%rax)
  81780d:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817814:	00 00 00 
  817817:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81781a:	48 63 d0             	movslq %eax,%rdx
  81781d:	48 89 d0             	mov    %rdx,%rax
  817820:	48 c1 e0 03          	shl    $0x3,%rax
  817824:	48 01 d0             	add    %rdx,%rax
  817827:	48 c1 e0 02          	shl    $0x2,%rax
  81782b:	48 01 d0             	add    %rdx,%rax
  81782e:	48 c1 e0 03          	shl    $0x3,%rax
  817832:	48 01 c8             	add    %rcx,%rax
  817835:	48 05 20 01 00 00    	add    $0x120,%rax
  81783b:	48 be 40 6c b5 00 00 	movabs $0xb56c40,%rsi
  817842:	00 00 00 
  817845:	48 89 30             	mov    %rsi,(%rax)
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  817848:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  81784c:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%rbp)
  817850:	0f 8e 99 fe ff ff    	jle    8176ef <sys_init+0x11d>
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  817856:	90                   	nop
  817857:	c9                   	leaveq 
  817858:	c3                   	retq   

0000000000817859 <sys_mbox_new>:

sys_mbox_t
sys_mbox_new(int size)
{
  817859:	55                   	push   %rbp
  81785a:	48 89 e5             	mov    %rsp,%rbp
  81785d:	48 83 ec 20          	sub    $0x20,%rsp
  817861:	89 7d ec             	mov    %edi,-0x14(%rbp)
    assert(size < MBOXSLOTS);
  817864:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  817868:	7e 35                	jle    81789f <sys_mbox_new+0x46>
  81786a:	48 b9 e8 2e 82 00 00 	movabs $0x822ee8,%rcx
  817871:	00 00 00 
  817874:	48 ba f9 2e 82 00 00 	movabs $0x822ef9,%rdx
  81787b:	00 00 00 
  81787e:	be 46 00 00 00       	mov    $0x46,%esi
  817883:	48 bf 0e 2f 82 00 00 	movabs $0x822f0e,%rdi
  81788a:	00 00 00 
  81788d:	b8 00 00 00 00       	mov    $0x0,%eax
  817892:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  817899:	00 00 00 
  81789c:	41 ff d0             	callq  *%r8
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  81789f:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  8178a6:	00 00 00 
  8178a9:	48 8b 00             	mov    (%rax),%rax
  8178ac:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!mbe) {
  8178b0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8178b5:	75 25                	jne    8178dc <sys_mbox_new+0x83>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  8178b7:	48 bf 30 2f 82 00 00 	movabs $0x822f30,%rdi
  8178be:	00 00 00 
  8178c1:	b8 00 00 00 00       	mov    $0x0,%eax
  8178c6:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8178cd:	00 00 00 
  8178d0:	ff d2                	callq  *%rdx
	return SYS_MBOX_NULL;
  8178d2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8178d7:	e9 5f 01 00 00       	jmpq   817a3b <sys_mbox_new+0x1e2>
    }
    LIST_REMOVE(mbe, link);
  8178dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8178e0:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  8178e7:	48 85 c0             	test   %rax,%rax
  8178ea:	74 1d                	je     817909 <sys_mbox_new+0xb0>
  8178ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8178f0:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  8178f7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8178fb:	48 8b 92 20 01 00 00 	mov    0x120(%rdx),%rdx
  817902:	48 89 90 20 01 00 00 	mov    %rdx,0x120(%rax)
  817909:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81790d:	48 8b 80 20 01 00 00 	mov    0x120(%rax),%rax
  817914:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817918:	48 8b 92 18 01 00 00 	mov    0x118(%rdx),%rdx
  81791f:	48 89 10             	mov    %rdx,(%rax)
    assert(mbe->freed);
  817922:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817926:	8b 00                	mov    (%rax),%eax
  817928:	85 c0                	test   %eax,%eax
  81792a:	75 35                	jne    817961 <sys_mbox_new+0x108>
  81792c:	48 b9 56 2f 82 00 00 	movabs $0x822f56,%rcx
  817933:	00 00 00 
  817936:	48 ba f9 2e 82 00 00 	movabs $0x822ef9,%rdx
  81793d:	00 00 00 
  817940:	be 4d 00 00 00       	mov    $0x4d,%esi
  817945:	48 bf 0e 2f 82 00 00 	movabs $0x822f0e,%rdi
  81794c:	00 00 00 
  81794f:	b8 00 00 00 00       	mov    $0x0,%eax
  817954:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  81795b:	00 00 00 
  81795e:	41 ff d0             	callq  *%r8
    mbe->freed = 0;
  817961:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817965:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

    int i = mbe - &mboxes[0];
  81796b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81796f:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  817976:	00 00 00 
  817979:	48 29 c2             	sub    %rax,%rdx
  81797c:	48 89 d0             	mov    %rdx,%rax
  81797f:	48 c1 f8 03          	sar    $0x3,%rax
  817983:	48 89 c2             	mov    %rax,%rdx
  817986:	48 b8 ad 1b 4c 91 cf 	movabs $0x14c1bacf914c1bad,%rax
  81798d:	ba c1 14 
  817990:	48 0f af c2          	imul   %rdx,%rax
  817994:	89 45 f4             	mov    %eax,-0xc(%rbp)
    mbe->head = -1;
  817997:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81799b:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%rax)
    mbe->nextq = 0;
  8179a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8179a6:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
    mbe->queued_msg = sys_sem_new(0);
  8179ad:	bf 00 00 00 00       	mov    $0x0,%edi
  8179b2:	48 b8 5c 7f 81 00 00 	movabs $0x817f5c,%rax
  8179b9:	00 00 00 
  8179bc:	ff d0                	callq  *%rax
  8179be:	89 c2                	mov    %eax,%edx
  8179c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8179c4:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  8179ca:	bf 20 00 00 00       	mov    $0x20,%edi
  8179cf:	48 b8 5c 7f 81 00 00 	movabs $0x817f5c,%rax
  8179d6:	00 00 00 
  8179d9:	ff d0                	callq  *%rax
  8179db:	89 c2                	mov    %eax,%edx
  8179dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8179e1:	89 90 14 01 00 00    	mov    %edx,0x114(%rax)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  8179e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8179eb:	8b 80 10 01 00 00    	mov    0x110(%rax),%eax
  8179f1:	83 f8 ff             	cmp    $0xffffffff,%eax
  8179f4:	74 0f                	je     817a05 <sys_mbox_new+0x1ac>
	mbe->free_msg == SYS_SEM_NULL)
  8179f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8179fa:	8b 80 14 01 00 00    	mov    0x114(%rax),%eax
    mbe->head = -1;
    mbe->nextq = 0;
    mbe->queued_msg = sys_sem_new(0);
    mbe->free_msg = sys_sem_new(MBOXSLOTS);

    if (mbe->queued_msg == SYS_SEM_NULL ||
  817a00:	83 f8 ff             	cmp    $0xffffffff,%eax
  817a03:	75 33                	jne    817a38 <sys_mbox_new+0x1df>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  817a05:	8b 45 f4             	mov    -0xc(%rbp),%eax
  817a08:	89 c7                	mov    %eax,%edi
  817a0a:	48 b8 3d 7a 81 00 00 	movabs $0x817a3d,%rax
  817a11:	00 00 00 
  817a14:	ff d0                	callq  *%rax
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  817a16:	48 bf 68 2f 82 00 00 	movabs $0x822f68,%rdi
  817a1d:	00 00 00 
  817a20:	b8 00 00 00 00       	mov    $0x0,%eax
  817a25:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  817a2c:	00 00 00 
  817a2f:	ff d2                	callq  *%rdx
	return SYS_MBOX_NULL;
  817a31:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817a36:	eb 03                	jmp    817a3b <sys_mbox_new+0x1e2>
    }
    return i;
  817a38:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  817a3b:	c9                   	leaveq 
  817a3c:	c3                   	retq   

0000000000817a3d <sys_mbox_free>:

void
sys_mbox_free(sys_mbox_t mbox)
{
  817a3d:	55                   	push   %rbp
  817a3e:	48 89 e5             	mov    %rsp,%rbp
  817a41:	48 83 ec 10          	sub    $0x10,%rsp
  817a45:	89 7d fc             	mov    %edi,-0x4(%rbp)
    assert(!mboxes[mbox].freed);
  817a48:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817a4f:	00 00 00 
  817a52:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817a55:	48 63 d0             	movslq %eax,%rdx
  817a58:	48 89 d0             	mov    %rdx,%rax
  817a5b:	48 c1 e0 03          	shl    $0x3,%rax
  817a5f:	48 01 d0             	add    %rdx,%rax
  817a62:	48 c1 e0 02          	shl    $0x2,%rax
  817a66:	48 01 d0             	add    %rdx,%rax
  817a69:	48 c1 e0 03          	shl    $0x3,%rax
  817a6d:	48 01 c8             	add    %rcx,%rax
  817a70:	8b 00                	mov    (%rax),%eax
  817a72:	85 c0                	test   %eax,%eax
  817a74:	74 35                	je     817aab <sys_mbox_free+0x6e>
  817a76:	48 b9 91 2f 82 00 00 	movabs $0x822f91,%rcx
  817a7d:	00 00 00 
  817a80:	48 ba f9 2e 82 00 00 	movabs $0x822ef9,%rdx
  817a87:	00 00 00 
  817a8a:	be 63 00 00 00       	mov    $0x63,%esi
  817a8f:	48 bf 0e 2f 82 00 00 	movabs $0x822f0e,%rdi
  817a96:	00 00 00 
  817a99:	b8 00 00 00 00       	mov    $0x0,%eax
  817a9e:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  817aa5:	00 00 00 
  817aa8:	41 ff d0             	callq  *%r8
    sys_sem_free(mboxes[mbox].queued_msg);
  817aab:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817ab2:	00 00 00 
  817ab5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817ab8:	48 63 d0             	movslq %eax,%rdx
  817abb:	48 89 d0             	mov    %rdx,%rax
  817abe:	48 c1 e0 03          	shl    $0x3,%rax
  817ac2:	48 01 d0             	add    %rdx,%rax
  817ac5:	48 c1 e0 02          	shl    $0x2,%rax
  817ac9:	48 01 d0             	add    %rdx,%rax
  817acc:	48 c1 e0 03          	shl    $0x3,%rax
  817ad0:	48 01 c8             	add    %rcx,%rax
  817ad3:	48 05 10 01 00 00    	add    $0x110,%rax
  817ad9:	8b 00                	mov    (%rax),%eax
  817adb:	89 c7                	mov    %eax,%edi
  817add:	48 b8 5a 80 81 00 00 	movabs $0x81805a,%rax
  817ae4:	00 00 00 
  817ae7:	ff d0                	callq  *%rax
    sys_sem_free(mboxes[mbox].free_msg);
  817ae9:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817af0:	00 00 00 
  817af3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817af6:	48 63 d0             	movslq %eax,%rdx
  817af9:	48 89 d0             	mov    %rdx,%rax
  817afc:	48 c1 e0 03          	shl    $0x3,%rax
  817b00:	48 01 d0             	add    %rdx,%rax
  817b03:	48 c1 e0 02          	shl    $0x2,%rax
  817b07:	48 01 d0             	add    %rdx,%rax
  817b0a:	48 c1 e0 03          	shl    $0x3,%rax
  817b0e:	48 01 c8             	add    %rcx,%rax
  817b11:	48 05 14 01 00 00    	add    $0x114,%rax
  817b17:	8b 00                	mov    (%rax),%eax
  817b19:	89 c7                	mov    %eax,%edi
  817b1b:	48 b8 5a 80 81 00 00 	movabs $0x81805a,%rax
  817b22:	00 00 00 
  817b25:	ff d0                	callq  *%rax
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  817b27:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817b2e:	00 00 00 
  817b31:	48 8b 08             	mov    (%rax),%rcx
  817b34:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  817b3b:	00 00 00 
  817b3e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817b41:	48 63 d0             	movslq %eax,%rdx
  817b44:	48 89 d0             	mov    %rdx,%rax
  817b47:	48 c1 e0 03          	shl    $0x3,%rax
  817b4b:	48 01 d0             	add    %rdx,%rax
  817b4e:	48 c1 e0 02          	shl    $0x2,%rax
  817b52:	48 01 d0             	add    %rdx,%rax
  817b55:	48 c1 e0 03          	shl    $0x3,%rax
  817b59:	48 01 f0             	add    %rsi,%rax
  817b5c:	48 05 18 01 00 00    	add    $0x118,%rax
  817b62:	48 89 08             	mov    %rcx,(%rax)
  817b65:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817b6c:	00 00 00 
  817b6f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817b72:	48 63 d0             	movslq %eax,%rdx
  817b75:	48 89 d0             	mov    %rdx,%rax
  817b78:	48 c1 e0 03          	shl    $0x3,%rax
  817b7c:	48 01 d0             	add    %rdx,%rax
  817b7f:	48 c1 e0 02          	shl    $0x2,%rax
  817b83:	48 01 d0             	add    %rdx,%rax
  817b86:	48 c1 e0 03          	shl    $0x3,%rax
  817b8a:	48 01 c8             	add    %rcx,%rax
  817b8d:	48 05 18 01 00 00    	add    $0x118,%rax
  817b93:	48 8b 00             	mov    (%rax),%rax
  817b96:	48 85 c0             	test   %rax,%rax
  817b99:	74 47                	je     817be2 <sys_mbox_free+0x1a5>
  817b9b:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817ba2:	00 00 00 
  817ba5:	48 8b 08             	mov    (%rax),%rcx
  817ba8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817bab:	48 63 d0             	movslq %eax,%rdx
  817bae:	48 89 d0             	mov    %rdx,%rax
  817bb1:	48 c1 e0 03          	shl    $0x3,%rax
  817bb5:	48 01 d0             	add    %rdx,%rax
  817bb8:	48 c1 e0 02          	shl    $0x2,%rax
  817bbc:	48 01 d0             	add    %rdx,%rax
  817bbf:	48 c1 e0 03          	shl    $0x3,%rax
  817bc3:	48 8d 90 10 01 00 00 	lea    0x110(%rax),%rdx
  817bca:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  817bd1:	00 00 00 
  817bd4:	48 01 d0             	add    %rdx,%rax
  817bd7:	48 83 c0 08          	add    $0x8,%rax
  817bdb:	48 89 81 20 01 00 00 	mov    %rax,0x120(%rcx)
  817be2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817be5:	48 63 d0             	movslq %eax,%rdx
  817be8:	48 89 d0             	mov    %rdx,%rax
  817beb:	48 c1 e0 03          	shl    $0x3,%rax
  817bef:	48 01 d0             	add    %rdx,%rax
  817bf2:	48 c1 e0 02          	shl    $0x2,%rax
  817bf6:	48 01 d0             	add    %rdx,%rax
  817bf9:	48 c1 e0 03          	shl    $0x3,%rax
  817bfd:	48 ba 40 d8 b4 00 00 	movabs $0xb4d840,%rdx
  817c04:	00 00 00 
  817c07:	48 01 c2             	add    %rax,%rdx
  817c0a:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817c11:	00 00 00 
  817c14:	48 89 10             	mov    %rdx,(%rax)
  817c17:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817c1e:	00 00 00 
  817c21:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817c24:	48 63 d0             	movslq %eax,%rdx
  817c27:	48 89 d0             	mov    %rdx,%rax
  817c2a:	48 c1 e0 03          	shl    $0x3,%rax
  817c2e:	48 01 d0             	add    %rdx,%rax
  817c31:	48 c1 e0 02          	shl    $0x2,%rax
  817c35:	48 01 d0             	add    %rdx,%rax
  817c38:	48 c1 e0 03          	shl    $0x3,%rax
  817c3c:	48 01 c8             	add    %rcx,%rax
  817c3f:	48 05 20 01 00 00    	add    $0x120,%rax
  817c45:	48 be 40 6c b5 00 00 	movabs $0xb56c40,%rsi
  817c4c:	00 00 00 
  817c4f:	48 89 30             	mov    %rsi,(%rax)
    mboxes[mbox].freed = 1;
  817c52:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817c59:	00 00 00 
  817c5c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817c5f:	48 63 d0             	movslq %eax,%rdx
  817c62:	48 89 d0             	mov    %rdx,%rax
  817c65:	48 c1 e0 03          	shl    $0x3,%rax
  817c69:	48 01 d0             	add    %rdx,%rax
  817c6c:	48 c1 e0 02          	shl    $0x2,%rax
  817c70:	48 01 d0             	add    %rdx,%rax
  817c73:	48 c1 e0 03          	shl    $0x3,%rax
  817c77:	48 01 c8             	add    %rcx,%rax
  817c7a:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
}
  817c80:	90                   	nop
  817c81:	c9                   	leaveq 
  817c82:	c3                   	retq   

0000000000817c83 <sys_mbox_post>:

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  817c83:	55                   	push   %rbp
  817c84:	48 89 e5             	mov    %rsp,%rbp
  817c87:	48 83 ec 10          	sub    $0x10,%rsp
  817c8b:	89 7d fc             	mov    %edi,-0x4(%rbp)
  817c8e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  817c92:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  817c96:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817c99:	48 89 d6             	mov    %rdx,%rsi
  817c9c:	89 c7                	mov    %eax,%edi
  817c9e:	48 b8 e6 7c 81 00 00 	movabs $0x817ce6,%rax
  817ca5:	00 00 00 
  817ca8:	ff d0                	callq  *%rax
  817caa:	84 c0                	test   %al,%al
  817cac:	74 35                	je     817ce3 <sys_mbox_post+0x60>
  817cae:	48 b9 a8 2f 82 00 00 	movabs $0x822fa8,%rcx
  817cb5:	00 00 00 
  817cb8:	48 ba f9 2e 82 00 00 	movabs $0x822ef9,%rdx
  817cbf:	00 00 00 
  817cc2:	be 6d 00 00 00       	mov    $0x6d,%esi
  817cc7:	48 bf 0e 2f 82 00 00 	movabs $0x822f0e,%rdi
  817cce:	00 00 00 
  817cd1:	b8 00 00 00 00       	mov    $0x0,%eax
  817cd6:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  817cdd:	00 00 00 
  817ce0:	41 ff d0             	callq  *%r8
}
  817ce3:	90                   	nop
  817ce4:	c9                   	leaveq 
  817ce5:	c3                   	retq   

0000000000817ce6 <sys_mbox_trypost>:

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  817ce6:	55                   	push   %rbp
  817ce7:	48 89 e5             	mov    %rsp,%rbp
  817cea:	48 83 ec 20          	sub    $0x20,%rsp
  817cee:	89 7d ec             	mov    %edi,-0x14(%rbp)
  817cf1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    assert(!mboxes[mbox].freed);
  817cf5:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817cfc:	00 00 00 
  817cff:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817d02:	48 63 d0             	movslq %eax,%rdx
  817d05:	48 89 d0             	mov    %rdx,%rax
  817d08:	48 c1 e0 03          	shl    $0x3,%rax
  817d0c:	48 01 d0             	add    %rdx,%rax
  817d0f:	48 c1 e0 02          	shl    $0x2,%rax
  817d13:	48 01 d0             	add    %rdx,%rax
  817d16:	48 c1 e0 03          	shl    $0x3,%rax
  817d1a:	48 01 c8             	add    %rcx,%rax
  817d1d:	8b 00                	mov    (%rax),%eax
  817d1f:	85 c0                	test   %eax,%eax
  817d21:	74 35                	je     817d58 <sys_mbox_trypost+0x72>
  817d23:	48 b9 91 2f 82 00 00 	movabs $0x822f91,%rcx
  817d2a:	00 00 00 
  817d2d:	48 ba f9 2e 82 00 00 	movabs $0x822ef9,%rdx
  817d34:	00 00 00 
  817d37:	be 73 00 00 00       	mov    $0x73,%esi
  817d3c:	48 bf 0e 2f 82 00 00 	movabs $0x822f0e,%rdi
  817d43:	00 00 00 
  817d46:	b8 00 00 00 00       	mov    $0x0,%eax
  817d4b:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  817d52:	00 00 00 
  817d55:	41 ff d0             	callq  *%r8

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  817d58:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817d5f:	00 00 00 
  817d62:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817d65:	48 63 d0             	movslq %eax,%rdx
  817d68:	48 89 d0             	mov    %rdx,%rax
  817d6b:	48 c1 e0 03          	shl    $0x3,%rax
  817d6f:	48 01 d0             	add    %rdx,%rax
  817d72:	48 c1 e0 02          	shl    $0x2,%rax
  817d76:	48 01 d0             	add    %rdx,%rax
  817d79:	48 c1 e0 03          	shl    $0x3,%rax
  817d7d:	48 01 c8             	add    %rcx,%rax
  817d80:	48 05 14 01 00 00    	add    $0x114,%rax
  817d86:	8b 00                	mov    (%rax),%eax
  817d88:	be 00 00 00 00       	mov    $0x0,%esi
  817d8d:	89 c7                	mov    %eax,%edi
  817d8f:	48 b8 ea 82 81 00 00 	movabs $0x8182ea,%rax
  817d96:	00 00 00 
  817d99:	ff d0                	callq  *%rax
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  817d9b:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817da2:	00 00 00 
  817da5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817da8:	48 63 d0             	movslq %eax,%rdx
  817dab:	48 89 d0             	mov    %rdx,%rax
  817dae:	48 c1 e0 03          	shl    $0x3,%rax
  817db2:	48 01 d0             	add    %rdx,%rax
  817db5:	48 c1 e0 02          	shl    $0x2,%rax
  817db9:	48 01 d0             	add    %rdx,%rax
  817dbc:	48 c1 e0 03          	shl    $0x3,%rax
  817dc0:	48 01 c8             	add    %rcx,%rax
  817dc3:	48 83 c0 08          	add    $0x8,%rax
  817dc7:	8b 08                	mov    (%rax),%ecx
  817dc9:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  817dd0:	00 00 00 
  817dd3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817dd6:	48 63 d0             	movslq %eax,%rdx
  817dd9:	48 89 d0             	mov    %rdx,%rax
  817ddc:	48 c1 e0 03          	shl    $0x3,%rax
  817de0:	48 01 d0             	add    %rdx,%rax
  817de3:	48 c1 e0 02          	shl    $0x2,%rax
  817de7:	48 01 d0             	add    %rdx,%rax
  817dea:	48 c1 e0 03          	shl    $0x3,%rax
  817dee:	48 01 f0             	add    %rsi,%rax
  817df1:	48 83 c0 04          	add    $0x4,%rax
  817df5:	8b 00                	mov    (%rax),%eax
  817df7:	39 c1                	cmp    %eax,%ecx
  817df9:	75 0a                	jne    817e05 <sys_mbox_trypost+0x11f>
	return ERR_MEM;
  817dfb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817e00:	e9 55 01 00 00       	jmpq   817f5a <sys_mbox_trypost+0x274>

    int slot = mboxes[mbox].nextq;
  817e05:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817e0c:	00 00 00 
  817e0f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817e12:	48 63 d0             	movslq %eax,%rdx
  817e15:	48 89 d0             	mov    %rdx,%rax
  817e18:	48 c1 e0 03          	shl    $0x3,%rax
  817e1c:	48 01 d0             	add    %rdx,%rax
  817e1f:	48 c1 e0 02          	shl    $0x2,%rax
  817e23:	48 01 d0             	add    %rdx,%rax
  817e26:	48 c1 e0 03          	shl    $0x3,%rax
  817e2a:	48 01 c8             	add    %rcx,%rax
  817e2d:	48 83 c0 08          	add    $0x8,%rax
  817e31:	8b 00                	mov    (%rax),%eax
  817e33:	89 45 fc             	mov    %eax,-0x4(%rbp)
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  817e36:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817e39:	8d 50 01             	lea    0x1(%rax),%edx
  817e3c:	89 d0                	mov    %edx,%eax
  817e3e:	c1 f8 1f             	sar    $0x1f,%eax
  817e41:	c1 e8 1b             	shr    $0x1b,%eax
  817e44:	01 c2                	add    %eax,%edx
  817e46:	83 e2 1f             	and    $0x1f,%edx
  817e49:	29 c2                	sub    %eax,%edx
  817e4b:	89 d0                	mov    %edx,%eax
  817e4d:	89 c6                	mov    %eax,%esi
  817e4f:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817e56:	00 00 00 
  817e59:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817e5c:	48 63 d0             	movslq %eax,%rdx
  817e5f:	48 89 d0             	mov    %rdx,%rax
  817e62:	48 c1 e0 03          	shl    $0x3,%rax
  817e66:	48 01 d0             	add    %rdx,%rax
  817e69:	48 c1 e0 02          	shl    $0x2,%rax
  817e6d:	48 01 d0             	add    %rdx,%rax
  817e70:	48 c1 e0 03          	shl    $0x3,%rax
  817e74:	48 01 c8             	add    %rcx,%rax
  817e77:	48 83 c0 08          	add    $0x8,%rax
  817e7b:	89 30                	mov    %esi,(%rax)
    mboxes[mbox].msg[slot] = msg;
  817e7d:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817e84:	00 00 00 
  817e87:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817e8a:	48 63 f0             	movslq %eax,%rsi
  817e8d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817e90:	48 63 d0             	movslq %eax,%rdx
  817e93:	48 89 d0             	mov    %rdx,%rax
  817e96:	48 c1 e0 03          	shl    $0x3,%rax
  817e9a:	48 01 d0             	add    %rdx,%rax
  817e9d:	48 c1 e0 02          	shl    $0x2,%rax
  817ea1:	48 01 d0             	add    %rdx,%rax
  817ea4:	48 01 f0             	add    %rsi,%rax
  817ea7:	48 8d 50 02          	lea    0x2(%rax),%rdx
  817eab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817eaf:	48 89 04 d1          	mov    %rax,(%rcx,%rdx,8)

    if (mboxes[mbox].head == -1)
  817eb3:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817eba:	00 00 00 
  817ebd:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817ec0:	48 63 d0             	movslq %eax,%rdx
  817ec3:	48 89 d0             	mov    %rdx,%rax
  817ec6:	48 c1 e0 03          	shl    $0x3,%rax
  817eca:	48 01 d0             	add    %rdx,%rax
  817ecd:	48 c1 e0 02          	shl    $0x2,%rax
  817ed1:	48 01 d0             	add    %rdx,%rax
  817ed4:	48 c1 e0 03          	shl    $0x3,%rax
  817ed8:	48 01 c8             	add    %rcx,%rax
  817edb:	48 83 c0 04          	add    $0x4,%rax
  817edf:	8b 00                	mov    (%rax),%eax
  817ee1:	83 f8 ff             	cmp    $0xffffffff,%eax
  817ee4:	75 31                	jne    817f17 <sys_mbox_trypost+0x231>
	mboxes[mbox].head = slot;
  817ee6:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817eed:	00 00 00 
  817ef0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817ef3:	48 63 d0             	movslq %eax,%rdx
  817ef6:	48 89 d0             	mov    %rdx,%rax
  817ef9:	48 c1 e0 03          	shl    $0x3,%rax
  817efd:	48 01 d0             	add    %rdx,%rax
  817f00:	48 c1 e0 02          	shl    $0x2,%rax
  817f04:	48 01 d0             	add    %rdx,%rax
  817f07:	48 c1 e0 03          	shl    $0x3,%rax
  817f0b:	48 01 c8             	add    %rcx,%rax
  817f0e:	48 8d 50 04          	lea    0x4(%rax),%rdx
  817f12:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817f15:	89 02                	mov    %eax,(%rdx)

    sys_sem_signal(mboxes[mbox].queued_msg);
  817f17:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817f1e:	00 00 00 
  817f21:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817f24:	48 63 d0             	movslq %eax,%rdx
  817f27:	48 89 d0             	mov    %rdx,%rax
  817f2a:	48 c1 e0 03          	shl    $0x3,%rax
  817f2e:	48 01 d0             	add    %rdx,%rax
  817f31:	48 c1 e0 02          	shl    $0x2,%rax
  817f35:	48 01 d0             	add    %rdx,%rax
  817f38:	48 c1 e0 03          	shl    $0x3,%rax
  817f3c:	48 01 c8             	add    %rcx,%rax
  817f3f:	48 05 10 01 00 00    	add    $0x110,%rax
  817f45:	8b 00                	mov    (%rax),%eax
  817f47:	89 c7                	mov    %eax,%edi
  817f49:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  817f50:	00 00 00 
  817f53:	ff d0                	callq  *%rax

    return ERR_OK;
  817f55:	b8 00 00 00 00       	mov    $0x0,%eax
}
  817f5a:	c9                   	leaveq 
  817f5b:	c3                   	retq   

0000000000817f5c <sys_sem_new>:

sys_sem_t
sys_sem_new(u8_t count)
{
  817f5c:	55                   	push   %rbp
  817f5d:	48 89 e5             	mov    %rsp,%rbp
  817f60:	48 83 ec 20          	sub    $0x20,%rsp
  817f64:	89 f8                	mov    %edi,%eax
  817f66:	88 45 ec             	mov    %al,-0x14(%rbp)
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  817f69:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817f70:	00 00 00 
  817f73:	48 8b 00             	mov    (%rax),%rax
  817f76:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!se) {
  817f7a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  817f7f:	75 25                	jne    817fa6 <sys_sem_new+0x4a>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  817f81:	48 bf d0 2f 82 00 00 	movabs $0x822fd0,%rdi
  817f88:	00 00 00 
  817f8b:	b8 00 00 00 00       	mov    $0x0,%eax
  817f90:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  817f97:	00 00 00 
  817f9a:	ff d2                	callq  *%rdx
	return SYS_SEM_NULL;
  817f9c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817fa1:	e9 b2 00 00 00       	jmpq   818058 <sys_sem_new+0xfc>
    }
    LIST_REMOVE(se, link);
  817fa6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817faa:	48 8b 40 10          	mov    0x10(%rax),%rax
  817fae:	48 85 c0             	test   %rax,%rax
  817fb1:	74 14                	je     817fc7 <sys_sem_new+0x6b>
  817fb3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817fb7:	48 8b 40 10          	mov    0x10(%rax),%rax
  817fbb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817fbf:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  817fc3:	48 89 50 18          	mov    %rdx,0x18(%rax)
  817fc7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817fcb:	48 8b 40 18          	mov    0x18(%rax),%rax
  817fcf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817fd3:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  817fd7:	48 89 10             	mov    %rdx,(%rax)
    assert(se->freed);
  817fda:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817fde:	8b 00                	mov    (%rax),%eax
  817fe0:	85 c0                	test   %eax,%eax
  817fe2:	75 35                	jne    818019 <sys_sem_new+0xbd>
  817fe4:	48 b9 f6 2f 82 00 00 	movabs $0x822ff6,%rcx
  817feb:	00 00 00 
  817fee:	48 ba f9 2e 82 00 00 	movabs $0x822ef9,%rdx
  817ff5:	00 00 00 
  817ff8:	be 8e 00 00 00       	mov    $0x8e,%esi
  817ffd:	48 bf 0e 2f 82 00 00 	movabs $0x822f0e,%rdi
  818004:	00 00 00 
  818007:	b8 00 00 00 00       	mov    $0x0,%eax
  81800c:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  818013:	00 00 00 
  818016:	41 ff d0             	callq  *%r8
    se->freed = 0;
  818019:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81801d:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

    se->counter = count;
  818023:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  818027:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81802b:	66 89 50 08          	mov    %dx,0x8(%rax)
    se->gen++;
  81802f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818033:	8b 40 04             	mov    0x4(%rax),%eax
  818036:	8d 50 01             	lea    0x1(%rax),%edx
  818039:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81803d:	89 50 04             	mov    %edx,0x4(%rax)
    return se - &sems[0];
  818040:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818044:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  81804b:	00 00 00 
  81804e:	48 29 c2             	sub    %rax,%rdx
  818051:	48 89 d0             	mov    %rdx,%rax
  818054:	48 c1 f8 05          	sar    $0x5,%rax
}
  818058:	c9                   	leaveq 
  818059:	c3                   	retq   

000000000081805a <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  81805a:	55                   	push   %rbp
  81805b:	48 89 e5             	mov    %rsp,%rbp
  81805e:	48 83 ec 10          	sub    $0x10,%rsp
  818062:	89 7d fc             	mov    %edi,-0x4(%rbp)
    assert(!sems[sem].freed);
  818065:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  81806c:	00 00 00 
  81806f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  818072:	48 63 d2             	movslq %edx,%rdx
  818075:	48 c1 e2 05          	shl    $0x5,%rdx
  818079:	48 01 d0             	add    %rdx,%rax
  81807c:	8b 00                	mov    (%rax),%eax
  81807e:	85 c0                	test   %eax,%eax
  818080:	74 35                	je     8180b7 <sys_sem_free+0x5d>
  818082:	48 b9 00 30 82 00 00 	movabs $0x823000,%rcx
  818089:	00 00 00 
  81808c:	48 ba f9 2e 82 00 00 	movabs $0x822ef9,%rdx
  818093:	00 00 00 
  818096:	be 99 00 00 00       	mov    $0x99,%esi
  81809b:	48 bf 0e 2f 82 00 00 	movabs $0x822f0e,%rdi
  8180a2:	00 00 00 
  8180a5:	b8 00 00 00 00       	mov    $0x0,%eax
  8180aa:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  8180b1:	00 00 00 
  8180b4:	41 ff d0             	callq  *%r8
    sems[sem].freed = 1;
  8180b7:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8180be:	00 00 00 
  8180c1:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8180c4:	48 63 d2             	movslq %edx,%rdx
  8180c7:	48 c1 e2 05          	shl    $0x5,%rdx
  8180cb:	48 01 d0             	add    %rdx,%rax
  8180ce:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    sems[sem].gen++;
  8180d4:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8180db:	00 00 00 
  8180de:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8180e1:	48 63 d2             	movslq %edx,%rdx
  8180e4:	48 c1 e2 05          	shl    $0x5,%rdx
  8180e8:	48 01 d0             	add    %rdx,%rax
  8180eb:	48 83 c0 04          	add    $0x4,%rax
  8180ef:	8b 00                	mov    (%rax),%eax
  8180f1:	8d 50 01             	lea    0x1(%rax),%edx
  8180f4:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8180fb:	00 00 00 
  8180fe:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  818101:	48 63 c9             	movslq %ecx,%rcx
  818104:	48 c1 e1 05          	shl    $0x5,%rcx
  818108:	48 01 c8             	add    %rcx,%rax
  81810b:	48 83 c0 04          	add    $0x4,%rax
  81810f:	89 10                	mov    %edx,(%rax)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  818111:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  818118:	00 00 00 
  81811b:	48 8b 00             	mov    (%rax),%rax
  81811e:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  818125:	00 00 00 
  818128:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  81812b:	48 63 c9             	movslq %ecx,%rcx
  81812e:	48 c1 e1 05          	shl    $0x5,%rcx
  818132:	48 01 ca             	add    %rcx,%rdx
  818135:	48 83 c2 10          	add    $0x10,%rdx
  818139:	48 89 02             	mov    %rax,(%rdx)
  81813c:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818143:	00 00 00 
  818146:	8b 55 fc             	mov    -0x4(%rbp),%edx
  818149:	48 63 d2             	movslq %edx,%rdx
  81814c:	48 c1 e2 05          	shl    $0x5,%rdx
  818150:	48 01 d0             	add    %rdx,%rax
  818153:	48 83 c0 10          	add    $0x10,%rax
  818157:	48 8b 00             	mov    (%rax),%rax
  81815a:	48 85 c0             	test   %rax,%rax
  81815d:	74 2c                	je     81818b <sys_sem_free+0x131>
  81815f:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  818166:	00 00 00 
  818169:	48 8b 00             	mov    (%rax),%rax
  81816c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81816f:	48 63 d2             	movslq %edx,%rdx
  818172:	48 c1 e2 05          	shl    $0x5,%rdx
  818176:	48 8d 4a 10          	lea    0x10(%rdx),%rcx
  81817a:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  818181:	00 00 00 
  818184:	48 01 ca             	add    %rcx,%rdx
  818187:	48 89 50 18          	mov    %rdx,0x18(%rax)
  81818b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81818e:	48 98                	cltq   
  818190:	48 c1 e0 05          	shl    $0x5,%rax
  818194:	48 89 c2             	mov    %rax,%rdx
  818197:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  81819e:	00 00 00 
  8181a1:	48 01 c2             	add    %rax,%rdx
  8181a4:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  8181ab:	00 00 00 
  8181ae:	48 89 10             	mov    %rdx,(%rax)
  8181b1:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8181b8:	00 00 00 
  8181bb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8181be:	48 63 d2             	movslq %edx,%rdx
  8181c1:	48 c1 e2 05          	shl    $0x5,%rdx
  8181c5:	48 01 d0             	add    %rdx,%rax
  8181c8:	48 83 c0 18          	add    $0x18,%rax
  8181cc:	48 be 20 d8 b4 00 00 	movabs $0xb4d820,%rsi
  8181d3:	00 00 00 
  8181d6:	48 89 30             	mov    %rsi,(%rax)
}
  8181d9:	90                   	nop
  8181da:	c9                   	leaveq 
  8181db:	c3                   	retq   

00000000008181dc <sys_sem_signal>:

void
sys_sem_signal(sys_sem_t sem)
{
  8181dc:	55                   	push   %rbp
  8181dd:	48 89 e5             	mov    %rsp,%rbp
  8181e0:	48 83 ec 10          	sub    $0x10,%rsp
  8181e4:	89 7d fc             	mov    %edi,-0x4(%rbp)
    assert(!sems[sem].freed);
  8181e7:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8181ee:	00 00 00 
  8181f1:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8181f4:	48 63 d2             	movslq %edx,%rdx
  8181f7:	48 c1 e2 05          	shl    $0x5,%rdx
  8181fb:	48 01 d0             	add    %rdx,%rax
  8181fe:	8b 00                	mov    (%rax),%eax
  818200:	85 c0                	test   %eax,%eax
  818202:	74 35                	je     818239 <sys_sem_signal+0x5d>
  818204:	48 b9 00 30 82 00 00 	movabs $0x823000,%rcx
  81820b:	00 00 00 
  81820e:	48 ba f9 2e 82 00 00 	movabs $0x822ef9,%rdx
  818215:	00 00 00 
  818218:	be a2 00 00 00       	mov    $0xa2,%esi
  81821d:	48 bf 0e 2f 82 00 00 	movabs $0x822f0e,%rdi
  818224:	00 00 00 
  818227:	b8 00 00 00 00       	mov    $0x0,%eax
  81822c:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  818233:	00 00 00 
  818236:	41 ff d0             	callq  *%r8
    sems[sem].counter++;
  818239:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818240:	00 00 00 
  818243:	8b 55 fc             	mov    -0x4(%rbp),%edx
  818246:	48 63 d2             	movslq %edx,%rdx
  818249:	48 c1 e2 05          	shl    $0x5,%rdx
  81824d:	48 01 d0             	add    %rdx,%rax
  818250:	48 83 c0 08          	add    $0x8,%rax
  818254:	0f b7 00             	movzwl (%rax),%eax
  818257:	8d 50 01             	lea    0x1(%rax),%edx
  81825a:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818261:	00 00 00 
  818264:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  818267:	48 63 c9             	movslq %ecx,%rcx
  81826a:	48 c1 e1 05          	shl    $0x5,%rcx
  81826e:	48 01 c8             	add    %rcx,%rax
  818271:	48 83 c0 08          	add    $0x8,%rax
  818275:	66 89 10             	mov    %dx,(%rax)
    if (sems[sem].waiters) {
  818278:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  81827f:	00 00 00 
  818282:	8b 55 fc             	mov    -0x4(%rbp),%edx
  818285:	48 63 d2             	movslq %edx,%rdx
  818288:	48 c1 e2 05          	shl    $0x5,%rdx
  81828c:	48 01 d0             	add    %rdx,%rax
  81828f:	48 83 c0 0a          	add    $0xa,%rax
  818293:	0f b7 00             	movzwl (%rax),%eax
  818296:	66 85 c0             	test   %ax,%ax
  818299:	74 4c                	je     8182e7 <sys_sem_signal+0x10b>
	sems[sem].waiters = 0;
  81829b:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8182a2:	00 00 00 
  8182a5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8182a8:	48 63 d2             	movslq %edx,%rdx
  8182ab:	48 c1 e2 05          	shl    $0x5,%rdx
  8182af:	48 01 d0             	add    %rdx,%rax
  8182b2:	48 83 c0 0a          	add    $0xa,%rax
  8182b6:	66 c7 00 00 00       	movw   $0x0,(%rax)
	thread_wakeup(&sems[sem].v);
  8182bb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8182be:	48 98                	cltq   
  8182c0:	48 c1 e0 05          	shl    $0x5,%rax
  8182c4:	48 89 c2             	mov    %rax,%rdx
  8182c7:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8182ce:	00 00 00 
  8182d1:	48 01 d0             	add    %rdx,%rax
  8182d4:	48 83 c0 08          	add    $0x8,%rax
  8182d8:	48 89 c7             	mov    %rax,%rdi
  8182db:	48 b8 8b 8d 81 00 00 	movabs $0x818d8b,%rax
  8182e2:	00 00 00 
  8182e5:	ff d0                	callq  *%rax
    }
}
  8182e7:	90                   	nop
  8182e8:	c9                   	leaveq 
  8182e9:	c3                   	retq   

00000000008182ea <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  8182ea:	55                   	push   %rbp
  8182eb:	48 89 e5             	mov    %rsp,%rbp
  8182ee:	48 83 ec 30          	sub    $0x30,%rsp
  8182f2:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8182f5:	89 75 d8             	mov    %esi,-0x28(%rbp)
    assert(!sems[sem].freed);
  8182f8:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8182ff:	00 00 00 
  818302:	8b 55 dc             	mov    -0x24(%rbp),%edx
  818305:	48 63 d2             	movslq %edx,%rdx
  818308:	48 c1 e2 05          	shl    $0x5,%rdx
  81830c:	48 01 d0             	add    %rdx,%rax
  81830f:	8b 00                	mov    (%rax),%eax
  818311:	85 c0                	test   %eax,%eax
  818313:	74 35                	je     81834a <sys_arch_sem_wait+0x60>
  818315:	48 b9 00 30 82 00 00 	movabs $0x823000,%rcx
  81831c:	00 00 00 
  81831f:	48 ba f9 2e 82 00 00 	movabs $0x822ef9,%rdx
  818326:	00 00 00 
  818329:	be ad 00 00 00       	mov    $0xad,%esi
  81832e:	48 bf 0e 2f 82 00 00 	movabs $0x822f0e,%rdi
  818335:	00 00 00 
  818338:	b8 00 00 00 00       	mov    $0x0,%eax
  81833d:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  818344:	00 00 00 
  818347:	41 ff d0             	callq  *%r8
    u32_t waited = 0;
  81834a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

    int gen = sems[sem].gen;
  818351:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818358:	00 00 00 
  81835b:	8b 55 dc             	mov    -0x24(%rbp),%edx
  81835e:	48 63 d2             	movslq %edx,%rdx
  818361:	48 c1 e2 05          	shl    $0x5,%rdx
  818365:	48 01 d0             	add    %rdx,%rax
  818368:	48 83 c0 04          	add    $0x4,%rax
  81836c:	8b 00                	mov    (%rax),%eax
  81836e:	89 45 f8             	mov    %eax,-0x8(%rbp)

    while (tm_msec == 0 || waited < tm_msec) {
  818371:	e9 8e 01 00 00       	jmpq   818504 <sys_arch_sem_wait+0x21a>
	if (sems[sem].counter > 0) {
  818376:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  81837d:	00 00 00 
  818380:	8b 55 dc             	mov    -0x24(%rbp),%edx
  818383:	48 63 d2             	movslq %edx,%rdx
  818386:	48 c1 e2 05          	shl    $0x5,%rdx
  81838a:	48 01 d0             	add    %rdx,%rax
  81838d:	48 83 c0 08          	add    $0x8,%rax
  818391:	0f b7 00             	movzwl (%rax),%eax
  818394:	66 85 c0             	test   %ax,%ax
  818397:	74 47                	je     8183e0 <sys_arch_sem_wait+0xf6>
	    sems[sem].counter--;
  818399:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8183a0:	00 00 00 
  8183a3:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8183a6:	48 63 d2             	movslq %edx,%rdx
  8183a9:	48 c1 e2 05          	shl    $0x5,%rdx
  8183ad:	48 01 d0             	add    %rdx,%rax
  8183b0:	48 83 c0 08          	add    $0x8,%rax
  8183b4:	0f b7 00             	movzwl (%rax),%eax
  8183b7:	8d 50 ff             	lea    -0x1(%rax),%edx
  8183ba:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8183c1:	00 00 00 
  8183c4:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  8183c7:	48 63 c9             	movslq %ecx,%rcx
  8183ca:	48 c1 e1 05          	shl    $0x5,%rcx
  8183ce:	48 01 c8             	add    %rcx,%rax
  8183d1:	48 83 c0 08          	add    $0x8,%rax
  8183d5:	66 89 10             	mov    %dx,(%rax)
	    return waited;
  8183d8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8183db:	e9 3f 01 00 00       	jmpq   81851f <sys_arch_sem_wait+0x235>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  8183e0:	83 7d d8 fe          	cmpl   $0xfffffffe,-0x28(%rbp)
  8183e4:	75 0a                	jne    8183f0 <sys_arch_sem_wait+0x106>
	    return SYS_ARCH_TIMEOUT;
  8183e6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8183eb:	e9 2f 01 00 00       	jmpq   81851f <sys_arch_sem_wait+0x235>
	} else {
	    uint32_t a = sys_time_msec();
  8183f0:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  8183f7:	00 00 00 
  8183fa:	ff d0                	callq  *%rax
  8183fc:	89 45 f4             	mov    %eax,-0xc(%rbp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  8183ff:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  818403:	74 0f                	je     818414 <sys_arch_sem_wait+0x12a>
  818405:	8b 45 d8             	mov    -0x28(%rbp),%eax
  818408:	2b 45 fc             	sub    -0x4(%rbp),%eax
  81840b:	89 c2                	mov    %eax,%edx
  81840d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  818410:	01 d0                	add    %edx,%eax
  818412:	eb 05                	jmp    818419 <sys_arch_sem_wait+0x12f>
  818414:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  818419:	89 45 f0             	mov    %eax,-0x10(%rbp)
	    sems[sem].waiters = 1;
  81841c:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818423:	00 00 00 
  818426:	8b 55 dc             	mov    -0x24(%rbp),%edx
  818429:	48 63 d2             	movslq %edx,%rdx
  81842c:	48 c1 e2 05          	shl    $0x5,%rdx
  818430:	48 01 d0             	add    %rdx,%rax
  818433:	48 83 c0 0a          	add    $0xa,%rax
  818437:	66 c7 00 01 00       	movw   $0x1,(%rax)
	    uint32_t cur_v = sems[sem].v;
  81843c:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  818443:	00 00 00 
  818446:	8b 55 dc             	mov    -0x24(%rbp),%edx
  818449:	48 63 d2             	movslq %edx,%rdx
  81844c:	48 c1 e2 05          	shl    $0x5,%rdx
  818450:	48 01 d0             	add    %rdx,%rax
  818453:	48 83 c0 08          	add    $0x8,%rax
  818457:	8b 00                	mov    (%rax),%eax
  818459:	89 45 ec             	mov    %eax,-0x14(%rbp)
	    lwip_core_unlock();
  81845c:	48 b8 65 8c 81 00 00 	movabs $0x818c65,%rax
  818463:	00 00 00 
  818466:	ff d0                	callq  *%rax
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  818468:	8b 45 dc             	mov    -0x24(%rbp),%eax
  81846b:	48 98                	cltq   
  81846d:	48 c1 e0 05          	shl    $0x5,%rax
  818471:	48 89 c2             	mov    %rax,%rdx
  818474:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  81847b:	00 00 00 
  81847e:	48 01 d0             	add    %rdx,%rax
  818481:	48 8d 48 08          	lea    0x8(%rax),%rcx
  818485:	8b 55 f0             	mov    -0x10(%rbp),%edx
  818488:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81848b:	89 c6                	mov    %eax,%esi
  81848d:	48 89 cf             	mov    %rcx,%rdi
  818490:	48 b8 df 8d 81 00 00 	movabs $0x818ddf,%rax
  818497:	00 00 00 
  81849a:	ff d0                	callq  *%rax
	    lwip_core_lock();
  81849c:	48 b8 5e 8c 81 00 00 	movabs $0x818c5e,%rax
  8184a3:	00 00 00 
  8184a6:	ff d0                	callq  *%rax
	    if (gen != sems[sem].gen) {
  8184a8:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8184af:	00 00 00 
  8184b2:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8184b5:	48 63 d2             	movslq %edx,%rdx
  8184b8:	48 c1 e2 05          	shl    $0x5,%rdx
  8184bc:	48 01 d0             	add    %rdx,%rax
  8184bf:	48 83 c0 04          	add    $0x4,%rax
  8184c3:	8b 00                	mov    (%rax),%eax
  8184c5:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  8184c8:	74 22                	je     8184ec <sys_arch_sem_wait+0x202>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  8184ca:	48 bf 18 30 82 00 00 	movabs $0x823018,%rdi
  8184d1:	00 00 00 
  8184d4:	b8 00 00 00 00       	mov    $0x0,%eax
  8184d9:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8184e0:	00 00 00 
  8184e3:	ff d2                	callq  *%rdx
		return SYS_ARCH_TIMEOUT;
  8184e5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8184ea:	eb 33                	jmp    81851f <sys_arch_sem_wait+0x235>
	    }
	    uint32_t b = sys_time_msec();
  8184ec:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  8184f3:	00 00 00 
  8184f6:	ff d0                	callq  *%rax
  8184f8:	89 45 e8             	mov    %eax,-0x18(%rbp)
	    waited += (b - a);
  8184fb:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8184fe:	2b 45 f4             	sub    -0xc(%rbp),%eax
  818501:	01 45 fc             	add    %eax,-0x4(%rbp)
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  818504:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  818508:	0f 84 68 fe ff ff    	je     818376 <sys_arch_sem_wait+0x8c>
  81850e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818511:	3b 45 d8             	cmp    -0x28(%rbp),%eax
  818514:	0f 82 5c fe ff ff    	jb     818376 <sys_arch_sem_wait+0x8c>
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
  81851a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  81851f:	c9                   	leaveq 
  818520:	c3                   	retq   

0000000000818521 <sys_arch_mbox_fetch>:

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  818521:	55                   	push   %rbp
  818522:	48 89 e5             	mov    %rsp,%rbp
  818525:	48 83 ec 20          	sub    $0x20,%rsp
  818529:	89 7d ec             	mov    %edi,-0x14(%rbp)
  81852c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  818530:	89 55 e8             	mov    %edx,-0x18(%rbp)
    assert(!mboxes[mbox].freed);
  818533:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81853a:	00 00 00 
  81853d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818540:	48 63 d0             	movslq %eax,%rdx
  818543:	48 89 d0             	mov    %rdx,%rax
  818546:	48 c1 e0 03          	shl    $0x3,%rax
  81854a:	48 01 d0             	add    %rdx,%rax
  81854d:	48 c1 e0 02          	shl    $0x2,%rax
  818551:	48 01 d0             	add    %rdx,%rax
  818554:	48 c1 e0 03          	shl    $0x3,%rax
  818558:	48 01 c8             	add    %rcx,%rax
  81855b:	8b 00                	mov    (%rax),%eax
  81855d:	85 c0                	test   %eax,%eax
  81855f:	74 35                	je     818596 <sys_arch_mbox_fetch+0x75>
  818561:	48 b9 91 2f 82 00 00 	movabs $0x822f91,%rcx
  818568:	00 00 00 
  81856b:	48 ba f9 2e 82 00 00 	movabs $0x822ef9,%rdx
  818572:	00 00 00 
  818575:	be cf 00 00 00       	mov    $0xcf,%esi
  81857a:	48 bf 0e 2f 82 00 00 	movabs $0x822f0e,%rdi
  818581:	00 00 00 
  818584:	b8 00 00 00 00       	mov    $0x0,%eax
  818589:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  818590:	00 00 00 
  818593:	41 ff d0             	callq  *%r8

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  818596:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81859d:	00 00 00 
  8185a0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8185a3:	48 63 d0             	movslq %eax,%rdx
  8185a6:	48 89 d0             	mov    %rdx,%rax
  8185a9:	48 c1 e0 03          	shl    $0x3,%rax
  8185ad:	48 01 d0             	add    %rdx,%rax
  8185b0:	48 c1 e0 02          	shl    $0x2,%rax
  8185b4:	48 01 d0             	add    %rdx,%rax
  8185b7:	48 c1 e0 03          	shl    $0x3,%rax
  8185bb:	48 01 c8             	add    %rcx,%rax
  8185be:	48 05 10 01 00 00    	add    $0x110,%rax
  8185c4:	8b 00                	mov    (%rax),%eax
  8185c6:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8185c9:	89 d6                	mov    %edx,%esi
  8185cb:	89 c7                	mov    %eax,%edi
  8185cd:	48 b8 ea 82 81 00 00 	movabs $0x8182ea,%rax
  8185d4:	00 00 00 
  8185d7:	ff d0                	callq  *%rax
  8185d9:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (waited == SYS_ARCH_TIMEOUT)
  8185dc:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  8185e0:	75 08                	jne    8185ea <sys_arch_mbox_fetch+0xc9>
	return waited;
  8185e2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8185e5:	e9 bb 01 00 00       	jmpq   8187a5 <sys_arch_mbox_fetch+0x284>

    int slot = mboxes[mbox].head;
  8185ea:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8185f1:	00 00 00 
  8185f4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8185f7:	48 63 d0             	movslq %eax,%rdx
  8185fa:	48 89 d0             	mov    %rdx,%rax
  8185fd:	48 c1 e0 03          	shl    $0x3,%rax
  818601:	48 01 d0             	add    %rdx,%rax
  818604:	48 c1 e0 02          	shl    $0x2,%rax
  818608:	48 01 d0             	add    %rdx,%rax
  81860b:	48 c1 e0 03          	shl    $0x3,%rax
  81860f:	48 01 c8             	add    %rcx,%rax
  818612:	48 83 c0 04          	add    $0x4,%rax
  818616:	8b 00                	mov    (%rax),%eax
  818618:	89 45 f8             	mov    %eax,-0x8(%rbp)
    if (slot == -1)
  81861b:	83 7d f8 ff          	cmpl   $0xffffffff,-0x8(%rbp)
  81861f:	75 2a                	jne    81864b <sys_arch_mbox_fetch+0x12a>
	panic("lwip: sys_arch_mbox_fetch: no message");
  818621:	48 ba 48 30 82 00 00 	movabs $0x823048,%rdx
  818628:	00 00 00 
  81862b:	be d7 00 00 00       	mov    $0xd7,%esi
  818630:	48 bf 0e 2f 82 00 00 	movabs $0x822f0e,%rdi
  818637:	00 00 00 
  81863a:	b8 00 00 00 00       	mov    $0x0,%eax
  81863f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  818646:	00 00 00 
  818649:	ff d1                	callq  *%rcx
    if (msg)
  81864b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  818650:	74 39                	je     81868b <sys_arch_mbox_fetch+0x16a>
	*msg = mboxes[mbox].msg[slot];
  818652:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  818659:	00 00 00 
  81865c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  81865f:	48 63 f0             	movslq %eax,%rsi
  818662:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818665:	48 63 d0             	movslq %eax,%rdx
  818668:	48 89 d0             	mov    %rdx,%rax
  81866b:	48 c1 e0 03          	shl    $0x3,%rax
  81866f:	48 01 d0             	add    %rdx,%rax
  818672:	48 c1 e0 02          	shl    $0x2,%rax
  818676:	48 01 d0             	add    %rdx,%rax
  818679:	48 01 f0             	add    %rsi,%rax
  81867c:	48 83 c0 02          	add    $0x2,%rax
  818680:	48 8b 14 c1          	mov    (%rcx,%rax,8),%rdx
  818684:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  818688:	48 89 10             	mov    %rdx,(%rax)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  81868b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  81868e:	8d 50 01             	lea    0x1(%rax),%edx
  818691:	89 d0                	mov    %edx,%eax
  818693:	c1 f8 1f             	sar    $0x1f,%eax
  818696:	c1 e8 1b             	shr    $0x1b,%eax
  818699:	01 c2                	add    %eax,%edx
  81869b:	83 e2 1f             	and    $0x1f,%edx
  81869e:	29 c2                	sub    %eax,%edx
  8186a0:	89 d0                	mov    %edx,%eax
  8186a2:	89 c6                	mov    %eax,%esi
  8186a4:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8186ab:	00 00 00 
  8186ae:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8186b1:	48 63 d0             	movslq %eax,%rdx
  8186b4:	48 89 d0             	mov    %rdx,%rax
  8186b7:	48 c1 e0 03          	shl    $0x3,%rax
  8186bb:	48 01 d0             	add    %rdx,%rax
  8186be:	48 c1 e0 02          	shl    $0x2,%rax
  8186c2:	48 01 d0             	add    %rdx,%rax
  8186c5:	48 c1 e0 03          	shl    $0x3,%rax
  8186c9:	48 01 c8             	add    %rcx,%rax
  8186cc:	48 83 c0 04          	add    $0x4,%rax
  8186d0:	89 30                	mov    %esi,(%rax)
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  8186d2:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8186d9:	00 00 00 
  8186dc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8186df:	48 63 d0             	movslq %eax,%rdx
  8186e2:	48 89 d0             	mov    %rdx,%rax
  8186e5:	48 c1 e0 03          	shl    $0x3,%rax
  8186e9:	48 01 d0             	add    %rdx,%rax
  8186ec:	48 c1 e0 02          	shl    $0x2,%rax
  8186f0:	48 01 d0             	add    %rdx,%rax
  8186f3:	48 c1 e0 03          	shl    $0x3,%rax
  8186f7:	48 01 c8             	add    %rcx,%rax
  8186fa:	48 83 c0 04          	add    $0x4,%rax
  8186fe:	8b 08                	mov    (%rax),%ecx
  818700:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  818707:	00 00 00 
  81870a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81870d:	48 63 d0             	movslq %eax,%rdx
  818710:	48 89 d0             	mov    %rdx,%rax
  818713:	48 c1 e0 03          	shl    $0x3,%rax
  818717:	48 01 d0             	add    %rdx,%rax
  81871a:	48 c1 e0 02          	shl    $0x2,%rax
  81871e:	48 01 d0             	add    %rdx,%rax
  818721:	48 c1 e0 03          	shl    $0x3,%rax
  818725:	48 01 f0             	add    %rsi,%rax
  818728:	48 83 c0 08          	add    $0x8,%rax
  81872c:	8b 00                	mov    (%rax),%eax
  81872e:	39 c1                	cmp    %eax,%ecx
  818730:	75 32                	jne    818764 <sys_arch_mbox_fetch+0x243>
	mboxes[mbox].head = -1;
  818732:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  818739:	00 00 00 
  81873c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81873f:	48 63 d0             	movslq %eax,%rdx
  818742:	48 89 d0             	mov    %rdx,%rax
  818745:	48 c1 e0 03          	shl    $0x3,%rax
  818749:	48 01 d0             	add    %rdx,%rax
  81874c:	48 c1 e0 02          	shl    $0x2,%rax
  818750:	48 01 d0             	add    %rdx,%rax
  818753:	48 c1 e0 03          	shl    $0x3,%rax
  818757:	48 01 c8             	add    %rcx,%rax
  81875a:	48 83 c0 04          	add    $0x4,%rax
  81875e:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%rax)

    sys_sem_signal(mboxes[mbox].free_msg);
  818764:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81876b:	00 00 00 
  81876e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818771:	48 63 d0             	movslq %eax,%rdx
  818774:	48 89 d0             	mov    %rdx,%rax
  818777:	48 c1 e0 03          	shl    $0x3,%rax
  81877b:	48 01 d0             	add    %rdx,%rax
  81877e:	48 c1 e0 02          	shl    $0x2,%rax
  818782:	48 01 d0             	add    %rdx,%rax
  818785:	48 c1 e0 03          	shl    $0x3,%rax
  818789:	48 01 c8             	add    %rcx,%rax
  81878c:	48 05 14 01 00 00    	add    $0x114,%rax
  818792:	8b 00                	mov    (%rax),%eax
  818794:	89 c7                	mov    %eax,%edi
  818796:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  81879d:	00 00 00 
  8187a0:	ff d0                	callq  *%rax
    return waited;
  8187a2:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8187a5:	c9                   	leaveq 
  8187a6:	c3                   	retq   

00000000008187a7 <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  8187a7:	55                   	push   %rbp
  8187a8:	48 89 e5             	mov    %rsp,%rbp
  8187ab:	48 83 ec 10          	sub    $0x10,%rsp
  8187af:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8187b2:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  8187b6:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8187ba:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8187bd:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
  8187c2:	48 89 ce             	mov    %rcx,%rsi
  8187c5:	89 c7                	mov    %eax,%edi
  8187c7:	48 b8 21 85 81 00 00 	movabs $0x818521,%rax
  8187ce:	00 00 00 
  8187d1:	ff d0                	callq  *%rax
}
  8187d3:	c9                   	leaveq 
  8187d4:	c3                   	retq   

00000000008187d5 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint64_t arg)
{
  8187d5:	55                   	push   %rbp
  8187d6:	48 89 e5             	mov    %rsp,%rbp
  8187d9:	48 83 ec 20          	sub    $0x20,%rsp
  8187dd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct lwip_thread *lt = (struct lwip_thread *)arg;
  8187e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8187e5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    lwip_core_lock();
  8187e9:	48 b8 5e 8c 81 00 00 	movabs $0x818c5e,%rax
  8187f0:	00 00 00 
  8187f3:	ff d0                	callq  *%rax
    lt->func(lt->arg);
  8187f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8187f9:	48 8b 00             	mov    (%rax),%rax
  8187fc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818800:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  818804:	48 89 d7             	mov    %rdx,%rdi
  818807:	ff d0                	callq  *%rax
    lwip_core_unlock();
  818809:	48 b8 65 8c 81 00 00 	movabs $0x818c65,%rax
  818810:	00 00 00 
  818813:	ff d0                	callq  *%rax
    free(lt);
  818815:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818819:	48 89 c7             	mov    %rax,%rdi
  81881c:	48 b8 9a 51 80 00 00 	movabs $0x80519a,%rax
  818823:	00 00 00 
  818826:	ff d0                	callq  *%rax
}
  818828:	90                   	nop
  818829:	c9                   	leaveq 
  81882a:	c3                   	retq   

000000000081882b <sys_thread_new>:

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  81882b:	55                   	push   %rbp
  81882c:	48 89 e5             	mov    %rsp,%rbp
  81882f:	48 83 ec 30          	sub    $0x30,%rsp
  818833:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  818837:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81883b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81883f:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  818842:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
    struct lwip_thread *lt = malloc(sizeof(*lt));
  818846:	bf 10 00 00 00       	mov    $0x10,%edi
  81884b:	48 b8 29 4e 80 00 00 	movabs $0x804e29,%rax
  818852:	00 00 00 
  818855:	ff d0                	callq  *%rax
  818857:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (lt == 0)
  81885b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818860:	75 2a                	jne    81888c <sys_thread_new+0x61>
	panic("sys_thread_new: cannot allocate thread struct");
  818862:	48 ba 70 30 82 00 00 	movabs $0x823070,%rdx
  818869:	00 00 00 
  81886c:	be fe 00 00 00       	mov    $0xfe,%esi
  818871:	48 bf 0e 2f 82 00 00 	movabs $0x822f0e,%rdi
  818878:	00 00 00 
  81887b:	b8 00 00 00 00       	mov    $0x0,%eax
  818880:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  818887:	00 00 00 
  81888a:	ff d1                	callq  *%rcx

    if (stacksize > PGSIZE)
  81888c:	81 7d d4 00 10 00 00 	cmpl   $0x1000,-0x2c(%rbp)
  818893:	7e 30                	jle    8188c5 <sys_thread_new+0x9a>
	panic("large stack %d", stacksize);
  818895:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  818898:	89 c1                	mov    %eax,%ecx
  81889a:	48 ba 9e 30 82 00 00 	movabs $0x82309e,%rdx
  8188a1:	00 00 00 
  8188a4:	be 01 01 00 00       	mov    $0x101,%esi
  8188a9:	48 bf 0e 2f 82 00 00 	movabs $0x822f0e,%rdi
  8188b0:	00 00 00 
  8188b3:	b8 00 00 00 00       	mov    $0x0,%eax
  8188b8:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  8188bf:	00 00 00 
  8188c2:	41 ff d0             	callq  *%r8

    lt->func = thread;
  8188c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8188c9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8188cd:	48 89 10             	mov    %rdx,(%rax)
    lt->arg = arg;
  8188d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8188d4:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8188d8:	48 89 50 08          	mov    %rdx,0x8(%rax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint64_t)lt);
  8188dc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8188e0:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8188e4:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8188e8:	48 89 d1             	mov    %rdx,%rcx
  8188eb:	48 ba d5 87 81 00 00 	movabs $0x8187d5,%rdx
  8188f2:	00 00 00 
  8188f5:	48 89 c7             	mov    %rax,%rdi
  8188f8:	48 b8 5a 90 81 00 00 	movabs $0x81905a,%rax
  8188ff:	00 00 00 
  818902:	ff d0                	callq  *%rax
  818904:	89 45 f4             	mov    %eax,-0xc(%rbp)

    if (r < 0)
  818907:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  81890b:	79 3f                	jns    81894c <sys_thread_new+0x121>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  81890d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  818910:	89 c7                	mov    %eax,%edi
  818912:	48 b8 f6 96 81 00 00 	movabs $0x8196f6,%rax
  818919:	00 00 00 
  81891c:	ff d0                	callq  *%rax
  81891e:	48 89 c1             	mov    %rax,%rcx
  818921:	48 ba b0 30 82 00 00 	movabs $0x8230b0,%rdx
  818928:	00 00 00 
  81892b:	be 0a 01 00 00       	mov    $0x10a,%esi
  818930:	48 bf 0e 2f 82 00 00 	movabs $0x822f0e,%rdi
  818937:	00 00 00 
  81893a:	b8 00 00 00 00       	mov    $0x0,%eax
  81893f:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  818946:	00 00 00 
  818949:	41 ff d0             	callq  *%r8

    return tid;
  81894c:	8b 45 f0             	mov    -0x10(%rbp),%eax
}
  81894f:	c9                   	leaveq 
  818950:	c3                   	retq   

0000000000818951 <timeout_cleanup>:

static void
timeout_cleanup(thread_id_t tid)
{
  818951:	55                   	push   %rbp
  818952:	48 89 e5             	mov    %rsp,%rbp
  818955:	48 83 ec 20          	sub    $0x20,%rsp
  818959:	89 7d ec             	mov    %edi,-0x14(%rbp)
    lwip_core_lock();
  81895c:	48 b8 5e 8c 81 00 00 	movabs $0x818c5e,%rax
  818963:	00 00 00 
  818966:	ff d0                	callq  *%rax

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  818968:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  81896b:	89 ca                	mov    %ecx,%edx
  81896d:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818972:	48 0f af c2          	imul   %rdx,%rax
  818976:	48 c1 e8 20          	shr    $0x20,%rax
  81897a:	89 c2                	mov    %eax,%edx
  81897c:	c1 ea 08             	shr    $0x8,%edx
  81897f:	89 d0                	mov    %edx,%eax
  818981:	c1 e0 08             	shl    $0x8,%eax
  818984:	01 d0                	add    %edx,%eax
  818986:	29 c1                	sub    %eax,%ecx
  818988:	89 ca                	mov    %ecx,%edx
  81898a:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818991:	00 00 00 
  818994:	89 d2                	mov    %edx,%edx
  818996:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  81899a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81899e:	eb 60                	jmp    818a00 <timeout_cleanup+0xaf>
	if (t->tid == tid) {
  8189a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189a4:	8b 00                	mov    (%rax),%eax
  8189a6:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8189a9:	75 49                	jne    8189f4 <timeout_cleanup+0xa3>
	    LIST_REMOVE(t, link);
  8189ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189af:	48 8b 40 10          	mov    0x10(%rax),%rax
  8189b3:	48 85 c0             	test   %rax,%rax
  8189b6:	74 14                	je     8189cc <timeout_cleanup+0x7b>
  8189b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189bc:	48 8b 40 10          	mov    0x10(%rax),%rax
  8189c0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8189c4:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  8189c8:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8189cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189d0:	48 8b 40 18          	mov    0x18(%rax),%rax
  8189d4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8189d8:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8189dc:	48 89 10             	mov    %rdx,(%rax)
	    free(t);
  8189df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189e3:	48 89 c7             	mov    %rax,%rdi
  8189e6:	48 b8 9a 51 80 00 00 	movabs $0x80519a,%rax
  8189ed:	00 00 00 
  8189f0:	ff d0                	callq  *%rax
	    goto done;
  8189f2:	eb 13                	jmp    818a07 <timeout_cleanup+0xb6>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  8189f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189f8:	48 8b 40 10          	mov    0x10(%rax),%rax
  8189fc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  818a00:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818a05:	75 99                	jne    8189a0 <timeout_cleanup+0x4f>
	    goto done;
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
  818a07:	48 b8 65 8c 81 00 00 	movabs $0x818c65,%rax
  818a0e:	00 00 00 
  818a11:	ff d0                	callq  *%rax
}
  818a13:	90                   	nop
  818a14:	c9                   	leaveq 
  818a15:	c3                   	retq   

0000000000818a16 <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  818a16:	55                   	push   %rbp
  818a17:	48 89 e5             	mov    %rsp,%rbp
  818a1a:	48 83 ec 10          	sub    $0x10,%rsp
    thread_id_t tid = thread_id();
  818a1e:	48 b8 76 8d 81 00 00 	movabs $0x818d76,%rax
  818a25:	00 00 00 
  818a28:	ff d0                	callq  *%rax
  818a2a:	89 45 f4             	mov    %eax,-0xc(%rbp)

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  818a2d:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818a30:	89 ca                	mov    %ecx,%edx
  818a32:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818a37:	48 0f af c2          	imul   %rdx,%rax
  818a3b:	48 c1 e8 20          	shr    $0x20,%rax
  818a3f:	89 c2                	mov    %eax,%edx
  818a41:	c1 ea 08             	shr    $0x8,%edx
  818a44:	89 d0                	mov    %edx,%eax
  818a46:	c1 e0 08             	shl    $0x8,%eax
  818a49:	01 d0                	add    %edx,%eax
  818a4b:	29 c1                	sub    %eax,%ecx
  818a4d:	89 ca                	mov    %ecx,%edx
  818a4f:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818a56:	00 00 00 
  818a59:	89 d2                	mov    %edx,%edx
  818a5b:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  818a5f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  818a63:	eb 1b                	jmp    818a80 <sys_arch_timeouts+0x6a>
	if (t->tid == tid)
  818a65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818a69:	8b 00                	mov    (%rax),%eax
  818a6b:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  818a6e:	0f 84 df 01 00 00    	je     818c53 <sys_arch_timeouts+0x23d>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  818a74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818a78:	48 8b 40 10          	mov    0x10(%rax),%rax
  818a7c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  818a80:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818a85:	75 de                	jne    818a65 <sys_arch_timeouts+0x4f>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  818a87:	bf 20 00 00 00       	mov    $0x20,%edi
  818a8c:	48 b8 29 4e 80 00 00 	movabs $0x804e29,%rax
  818a93:	00 00 00 
  818a96:	ff d0                	callq  *%rax
  818a98:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (t == 0)
  818a9c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818aa1:	75 2a                	jne    818acd <sys_arch_timeouts+0xb7>
	panic("sys_arch_timeouts: cannot malloc");
  818aa3:	48 ba e0 30 82 00 00 	movabs $0x8230e0,%rdx
  818aaa:	00 00 00 
  818aad:	be 2d 01 00 00       	mov    $0x12d,%esi
  818ab2:	48 bf 0e 2f 82 00 00 	movabs $0x822f0e,%rdi
  818ab9:	00 00 00 
  818abc:	b8 00 00 00 00       	mov    $0x0,%eax
  818ac1:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  818ac8:	00 00 00 
  818acb:	ff d1                	callq  *%rcx

    int r = thread_onhalt(timeout_cleanup);
  818acd:	48 bf 51 89 81 00 00 	movabs $0x818951,%rdi
  818ad4:	00 00 00 
  818ad7:	48 b8 11 8f 81 00 00 	movabs $0x818f11,%rax
  818ade:	00 00 00 
  818ae1:	ff d0                	callq  *%rax
  818ae3:	89 45 f0             	mov    %eax,-0x10(%rbp)
    if (r < 0)
  818ae6:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  818aea:	79 3f                	jns    818b2b <sys_arch_timeouts+0x115>
	panic("thread_onhalt failed: %s", e2s(r));
  818aec:	8b 45 f0             	mov    -0x10(%rbp),%eax
  818aef:	89 c7                	mov    %eax,%edi
  818af1:	48 b8 f6 96 81 00 00 	movabs $0x8196f6,%rax
  818af8:	00 00 00 
  818afb:	ff d0                	callq  *%rax
  818afd:	48 89 c1             	mov    %rax,%rcx
  818b00:	48 ba 01 31 82 00 00 	movabs $0x823101,%rdx
  818b07:	00 00 00 
  818b0a:	be 31 01 00 00       	mov    $0x131,%esi
  818b0f:	48 bf 0e 2f 82 00 00 	movabs $0x822f0e,%rdi
  818b16:	00 00 00 
  818b19:	b8 00 00 00 00       	mov    $0x0,%eax
  818b1e:	49 b8 f8 10 80 00 00 	movabs $0x8010f8,%r8
  818b25:	00 00 00 
  818b28:	41 ff d0             	callq  *%r8

    t->tid = tid;
  818b2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818b2f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  818b32:	89 10                	mov    %edx,(%rax)
    memset(&t->tmo, 0, sizeof(t->tmo));
  818b34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818b38:	48 83 c0 08          	add    $0x8,%rax
  818b3c:	ba 08 00 00 00       	mov    $0x8,%edx
  818b41:	be 00 00 00 00       	mov    $0x0,%esi
  818b46:	48 89 c7             	mov    %rax,%rdi
  818b49:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  818b50:	00 00 00 
  818b53:	ff d0                	callq  *%rax
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  818b55:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818b58:	89 ca                	mov    %ecx,%edx
  818b5a:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818b5f:	48 0f af c2          	imul   %rdx,%rax
  818b63:	48 c1 e8 20          	shr    $0x20,%rax
  818b67:	89 c2                	mov    %eax,%edx
  818b69:	c1 ea 08             	shr    $0x8,%edx
  818b6c:	89 d0                	mov    %edx,%eax
  818b6e:	c1 e0 08             	shl    $0x8,%eax
  818b71:	01 d0                	add    %edx,%eax
  818b73:	29 c1                	sub    %eax,%ecx
  818b75:	89 ca                	mov    %ecx,%edx
  818b77:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818b7e:	00 00 00 
  818b81:	89 d2                	mov    %edx,%edx
  818b83:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  818b87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818b8b:	48 89 50 10          	mov    %rdx,0x10(%rax)
  818b8f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818b93:	48 8b 40 10          	mov    0x10(%rax),%rax
  818b97:	48 85 c0             	test   %rax,%rax
  818b9a:	74 3e                	je     818bda <sys_arch_timeouts+0x1c4>
  818b9c:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818b9f:	89 ca                	mov    %ecx,%edx
  818ba1:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818ba6:	48 0f af c2          	imul   %rdx,%rax
  818baa:	48 c1 e8 20          	shr    $0x20,%rax
  818bae:	89 c2                	mov    %eax,%edx
  818bb0:	c1 ea 08             	shr    $0x8,%edx
  818bb3:	89 d0                	mov    %edx,%eax
  818bb5:	c1 e0 08             	shl    $0x8,%eax
  818bb8:	01 d0                	add    %edx,%eax
  818bba:	29 c1                	sub    %eax,%ecx
  818bbc:	89 ca                	mov    %ecx,%edx
  818bbe:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818bc5:	00 00 00 
  818bc8:	89 d2                	mov    %edx,%edx
  818bca:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  818bce:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818bd2:	48 83 c2 10          	add    $0x10,%rdx
  818bd6:	48 89 50 18          	mov    %rdx,0x18(%rax)
  818bda:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818bdd:	89 ca                	mov    %ecx,%edx
  818bdf:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818be4:	48 0f af c2          	imul   %rdx,%rax
  818be8:	48 c1 e8 20          	shr    $0x20,%rax
  818bec:	89 c2                	mov    %eax,%edx
  818bee:	c1 ea 08             	shr    $0x8,%edx
  818bf1:	89 d0                	mov    %edx,%eax
  818bf3:	c1 e0 08             	shl    $0x8,%eax
  818bf6:	01 d0                	add    %edx,%eax
  818bf8:	29 c1                	sub    %eax,%ecx
  818bfa:	89 ca                	mov    %ecx,%edx
  818bfc:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818c03:	00 00 00 
  818c06:	89 d1                	mov    %edx,%ecx
  818c08:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818c0c:	48 89 14 c8          	mov    %rdx,(%rax,%rcx,8)
  818c10:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818c13:	89 ca                	mov    %ecx,%edx
  818c15:	b8 01 ff 00 ff       	mov    $0xff00ff01,%eax
  818c1a:	48 0f af c2          	imul   %rdx,%rax
  818c1e:	48 c1 e8 20          	shr    $0x20,%rax
  818c22:	89 c2                	mov    %eax,%edx
  818c24:	c1 ea 08             	shr    $0x8,%edx
  818c27:	89 d0                	mov    %edx,%eax
  818c29:	c1 e0 08             	shl    $0x8,%eax
  818c2c:	01 d0                	add    %edx,%eax
  818c2e:	29 c1                	sub    %eax,%ecx
  818c30:	89 ca                	mov    %ecx,%edx
  818c32:	89 d0                	mov    %edx,%eax
  818c34:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  818c3b:	00 
  818c3c:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  818c43:	00 00 00 
  818c46:	48 01 c2             	add    %rax,%rdx
  818c49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c4d:	48 89 50 18          	mov    %rdx,0x18(%rax)
  818c51:	eb 01                	jmp    818c54 <sys_arch_timeouts+0x23e>
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
	if (t->tid == tid)
	    goto out;
  818c53:	90                   	nop
    t->tid = tid;
    memset(&t->tmo, 0, sizeof(t->tmo));
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);

out:
    return &t->tmo;
  818c54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c58:	48 83 c0 08          	add    $0x8,%rax
}
  818c5c:	c9                   	leaveq 
  818c5d:	c3                   	retq   

0000000000818c5e <lwip_core_lock>:

void
lwip_core_lock(void)
{
  818c5e:	55                   	push   %rbp
  818c5f:	48 89 e5             	mov    %rsp,%rbp
}
  818c62:	90                   	nop
  818c63:	5d                   	pop    %rbp
  818c64:	c3                   	retq   

0000000000818c65 <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  818c65:	55                   	push   %rbp
  818c66:	48 89 e5             	mov    %rsp,%rbp
}
  818c69:	90                   	nop
  818c6a:	5d                   	pop    %rbp
  818c6b:	c3                   	retq   

0000000000818c6c <threadq_init>:
    struct thread_context *tc_queue_link;
};

static inline void 
threadq_init(struct thread_queue *tq)
{
  818c6c:	55                   	push   %rbp
  818c6d:	48 89 e5             	mov    %rsp,%rbp
  818c70:	48 83 ec 08          	sub    $0x8,%rsp
  818c74:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    tq->tq_first = 0;
  818c78:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c7c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    tq->tq_last = 0;
  818c83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c87:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  818c8e:	00 
}
  818c8f:	90                   	nop
  818c90:	c9                   	leaveq 
  818c91:	c3                   	retq   

0000000000818c92 <threadq_push>:

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
  818c92:	55                   	push   %rbp
  818c93:	48 89 e5             	mov    %rsp,%rbp
  818c96:	48 83 ec 10          	sub    $0x10,%rsp
  818c9a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  818c9e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    tc->tc_queue_link = 0;
  818ca2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818ca6:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  818cad:	00 00 00 00 
    if (!tq->tq_first) {
  818cb1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818cb5:	48 8b 00             	mov    (%rax),%rax
  818cb8:	48 85 c0             	test   %rax,%rax
  818cbb:	75 19                	jne    818cd6 <threadq_push+0x44>
	tq->tq_first = tc;
  818cbd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818cc1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818cc5:	48 89 10             	mov    %rdx,(%rax)
	tq->tq_last = tc;
  818cc8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ccc:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818cd0:	48 89 50 08          	mov    %rdx,0x8(%rax)
    } else {
	tq->tq_last->tc_queue_link = tc;
	tq->tq_last = tc;
    }
}
  818cd4:	eb 1f                	jmp    818cf5 <threadq_push+0x63>
    tc->tc_queue_link = 0;
    if (!tq->tq_first) {
	tq->tq_first = tc;
	tq->tq_last = tc;
    } else {
	tq->tq_last->tc_queue_link = tc;
  818cd6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818cda:	48 8b 40 08          	mov    0x8(%rax),%rax
  818cde:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818ce2:	48 89 90 e8 00 00 00 	mov    %rdx,0xe8(%rax)
	tq->tq_last = tc;
  818ce9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ced:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818cf1:	48 89 50 08          	mov    %rdx,0x8(%rax)
    }
}
  818cf5:	90                   	nop
  818cf6:	c9                   	leaveq 
  818cf7:	c3                   	retq   

0000000000818cf8 <threadq_pop>:

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
  818cf8:	55                   	push   %rbp
  818cf9:	48 89 e5             	mov    %rsp,%rbp
  818cfc:	48 83 ec 18          	sub    $0x18,%rsp
  818d00:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    if (!tq->tq_first)
  818d04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818d08:	48 8b 00             	mov    (%rax),%rax
  818d0b:	48 85 c0             	test   %rax,%rax
  818d0e:	75 07                	jne    818d17 <threadq_pop+0x1f>
	return 0;
  818d10:	b8 00 00 00 00       	mov    $0x0,%eax
  818d15:	eb 30                	jmp    818d47 <threadq_pop+0x4f>

    struct thread_context *tc = tq->tq_first;
  818d17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818d1b:	48 8b 00             	mov    (%rax),%rax
  818d1e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    tq->tq_first = tc->tc_queue_link;
  818d22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818d26:	48 8b 90 e8 00 00 00 	mov    0xe8(%rax),%rdx
  818d2d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818d31:	48 89 10             	mov    %rdx,(%rax)
    tc->tc_queue_link = 0;
  818d34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818d38:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  818d3f:	00 00 00 00 
    return tc;
  818d43:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  818d47:	c9                   	leaveq 
  818d48:	c3                   	retq   

0000000000818d49 <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  818d49:	55                   	push   %rbp
  818d4a:	48 89 e5             	mov    %rsp,%rbp
    threadq_init(&thread_queue);
  818d4d:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  818d54:	00 00 00 
  818d57:	48 b8 6c 8c 81 00 00 	movabs $0x818c6c,%rax
  818d5e:	00 00 00 
  818d61:	ff d0                	callq  *%rax
    max_tid = 0;
  818d63:	48 b8 70 74 b5 00 00 	movabs $0xb57470,%rax
  818d6a:	00 00 00 
  818d6d:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
  818d73:	90                   	nop
  818d74:	5d                   	pop    %rbp
  818d75:	c3                   	retq   

0000000000818d76 <thread_id>:

uint32_t
thread_id(void) {
  818d76:	55                   	push   %rbp
  818d77:	48 89 e5             	mov    %rsp,%rbp
    return cur_tc->tc_tid;
  818d7a:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818d81:	00 00 00 
  818d84:	48 8b 00             	mov    (%rax),%rax
  818d87:	8b 00                	mov    (%rax),%eax
}
  818d89:	5d                   	pop    %rbp
  818d8a:	c3                   	retq   

0000000000818d8b <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  818d8b:	55                   	push   %rbp
  818d8c:	48 89 e5             	mov    %rsp,%rbp
  818d8f:	48 83 ec 18          	sub    $0x18,%rsp
  818d93:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct thread_context *tc = thread_queue.tq_first;
  818d97:	48 b8 80 74 b5 00 00 	movabs $0xb57480,%rax
  818d9e:	00 00 00 
  818da1:	48 8b 00             	mov    (%rax),%rax
  818da4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (tc) {
  818da8:	eb 2b                	jmp    818dd5 <thread_wakeup+0x4a>
	if (tc->tc_wait_addr == addr)
  818daa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818dae:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  818db5:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  818db9:	75 0b                	jne    818dc6 <thread_wakeup+0x3b>
	    tc->tc_wakeup = 1;
  818dbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818dbf:	c6 80 b8 00 00 00 01 	movb   $0x1,0xb8(%rax)
	tc = tc->tc_queue_link;
  818dc6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818dca:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  818dd1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  818dd5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818dda:	75 ce                	jne    818daa <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  818ddc:	90                   	nop
  818ddd:	c9                   	leaveq 
  818dde:	c3                   	retq   

0000000000818ddf <thread_wait>:

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  818ddf:	55                   	push   %rbp
  818de0:	48 89 e5             	mov    %rsp,%rbp
  818de3:	48 83 ec 20          	sub    $0x20,%rsp
  818de7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  818deb:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  818dee:	89 55 e0             	mov    %edx,-0x20(%rbp)
    uint32_t s = sys_time_msec();
  818df1:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  818df8:	00 00 00 
  818dfb:	ff d0                	callq  *%rax
  818dfd:	89 45 f8             	mov    %eax,-0x8(%rbp)
    uint32_t p = s;
  818e00:	8b 45 f8             	mov    -0x8(%rbp),%eax
  818e03:	89 45 fc             	mov    %eax,-0x4(%rbp)

    cur_tc->tc_wait_addr = addr;
  818e06:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818e0d:	00 00 00 
  818e10:	48 8b 00             	mov    (%rax),%rax
  818e13:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  818e17:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
    cur_tc->tc_wakeup = 0;
  818e1e:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818e25:	00 00 00 
  818e28:	48 8b 00             	mov    (%rax),%rax
  818e2b:	c6 80 b8 00 00 00 00 	movb   $0x0,0xb8(%rax)

    while (p < msec) {
  818e32:	eb 4d                	jmp    818e81 <thread_wait+0xa2>
	if (p < s)
  818e34:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818e37:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  818e3a:	72 4f                	jb     818e8b <thread_wait+0xac>
	    break;
	if (addr && *addr != val)
  818e3c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  818e41:	74 0b                	je     818e4e <thread_wait+0x6f>
  818e43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818e47:	8b 00                	mov    (%rax),%eax
  818e49:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  818e4c:	75 40                	jne    818e8e <thread_wait+0xaf>
	    break;
	if (cur_tc->tc_wakeup)
  818e4e:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818e55:	00 00 00 
  818e58:	48 8b 00             	mov    (%rax),%rax
  818e5b:	0f b6 80 b8 00 00 00 	movzbl 0xb8(%rax),%eax
  818e62:	84 c0                	test   %al,%al
  818e64:	75 2b                	jne    818e91 <thread_wait+0xb2>
	    break;

	thread_yield();
  818e66:	48 b8 e1 92 81 00 00 	movabs $0x8192e1,%rax
  818e6d:	00 00 00 
  818e70:	ff d0                	callq  *%rax
	p = sys_time_msec();
  818e72:	48 b8 78 2a 80 00 00 	movabs $0x802a78,%rax
  818e79:	00 00 00 
  818e7c:	ff d0                	callq  *%rax
  818e7e:	89 45 fc             	mov    %eax,-0x4(%rbp)
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  818e81:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818e84:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  818e87:	72 ab                	jb     818e34 <thread_wait+0x55>
  818e89:	eb 07                	jmp    818e92 <thread_wait+0xb3>
	if (p < s)
	    break;
  818e8b:	90                   	nop
  818e8c:	eb 04                	jmp    818e92 <thread_wait+0xb3>
	if (addr && *addr != val)
	    break;
  818e8e:	90                   	nop
  818e8f:	eb 01                	jmp    818e92 <thread_wait+0xb3>
	if (cur_tc->tc_wakeup)
	    break;
  818e91:	90                   	nop

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  818e92:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818e99:	00 00 00 
  818e9c:	48 8b 00             	mov    (%rax),%rax
  818e9f:	48 c7 80 b0 00 00 00 	movq   $0x0,0xb0(%rax)
  818ea6:	00 00 00 00 
    cur_tc->tc_wakeup = 0;
  818eaa:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818eb1:	00 00 00 
  818eb4:	48 8b 00             	mov    (%rax),%rax
  818eb7:	c6 80 b8 00 00 00 00 	movb   $0x0,0xb8(%rax)
}
  818ebe:	90                   	nop
  818ebf:	c9                   	leaveq 
  818ec0:	c3                   	retq   

0000000000818ec1 <thread_wakeups_pending>:

int
thread_wakeups_pending(void)
{
  818ec1:	55                   	push   %rbp
  818ec2:	48 89 e5             	mov    %rsp,%rbp
  818ec5:	48 83 ec 10          	sub    $0x10,%rsp
    struct thread_context *tc = thread_queue.tq_first;
  818ec9:	48 b8 80 74 b5 00 00 	movabs $0xb57480,%rax
  818ed0:	00 00 00 
  818ed3:	48 8b 00             	mov    (%rax),%rax
  818ed6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    int n = 0;
  818eda:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    while (tc) {
  818ee1:	eb 22                	jmp    818f05 <thread_wakeups_pending+0x44>
	if (tc->tc_wakeup)
  818ee3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ee7:	0f b6 80 b8 00 00 00 	movzbl 0xb8(%rax),%eax
  818eee:	84 c0                	test   %al,%al
  818ef0:	74 04                	je     818ef6 <thread_wakeups_pending+0x35>
	    ++n;
  818ef2:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
	tc = tc->tc_queue_link;
  818ef6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818efa:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  818f01:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  818f05:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818f0a:	75 d7                	jne    818ee3 <thread_wakeups_pending+0x22>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
  818f0c:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  818f0f:	c9                   	leaveq 
  818f10:	c3                   	retq   

0000000000818f11 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  818f11:	55                   	push   %rbp
  818f12:	48 89 e5             	mov    %rsp,%rbp
  818f15:	48 83 ec 08          	sub    $0x8,%rsp
  818f19:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  818f1d:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818f24:	00 00 00 
  818f27:	48 8b 00             	mov    (%rax),%rax
  818f2a:	8b 80 e0 00 00 00    	mov    0xe0(%rax),%eax
  818f30:	83 f8 03             	cmp    $0x3,%eax
  818f33:	7e 07                	jle    818f3c <thread_onhalt+0x2b>
	return -E_NO_MEM;
  818f35:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  818f3a:	eb 3d                	jmp    818f79 <thread_onhalt+0x68>

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  818f3c:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818f43:	00 00 00 
  818f46:	48 8b 08             	mov    (%rax),%rcx
  818f49:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818f50:	00 00 00 
  818f53:	48 8b 00             	mov    (%rax),%rax
  818f56:	8b 90 e0 00 00 00    	mov    0xe0(%rax),%edx
  818f5c:	8d 72 01             	lea    0x1(%rdx),%esi
  818f5f:	89 b0 e0 00 00 00    	mov    %esi,0xe0(%rax)
  818f65:	48 63 c2             	movslq %edx,%rax
  818f68:	48 8d 50 18          	lea    0x18(%rax),%rdx
  818f6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f70:	48 89 04 d1          	mov    %rax,(%rcx,%rdx,8)
    return 0;
  818f74:	b8 00 00 00 00       	mov    $0x0,%eax
}
  818f79:	c9                   	leaveq 
  818f7a:	c3                   	retq   

0000000000818f7b <alloc_tid>:

static thread_id_t
alloc_tid(void) {
  818f7b:	55                   	push   %rbp
  818f7c:	48 89 e5             	mov    %rsp,%rbp
  818f7f:	48 83 ec 10          	sub    $0x10,%rsp
    int tid = max_tid++;
  818f83:	48 b8 70 74 b5 00 00 	movabs $0xb57470,%rax
  818f8a:	00 00 00 
  818f8d:	8b 00                	mov    (%rax),%eax
  818f8f:	8d 48 01             	lea    0x1(%rax),%ecx
  818f92:	48 ba 70 74 b5 00 00 	movabs $0xb57470,%rdx
  818f99:	00 00 00 
  818f9c:	89 0a                	mov    %ecx,(%rdx)
  818f9e:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (max_tid == (uint32_t)~0)
  818fa1:	48 b8 70 74 b5 00 00 	movabs $0xb57470,%rax
  818fa8:	00 00 00 
  818fab:	8b 00                	mov    (%rax),%eax
  818fad:	83 f8 ff             	cmp    $0xffffffff,%eax
  818fb0:	75 2a                	jne    818fdc <alloc_tid+0x61>
	panic("alloc_tid: no more thread ids");
  818fb2:	48 ba 1a 31 82 00 00 	movabs $0x82311a,%rdx
  818fb9:	00 00 00 
  818fbc:	be 55 00 00 00       	mov    $0x55,%esi
  818fc1:	48 bf 38 31 82 00 00 	movabs $0x823138,%rdi
  818fc8:	00 00 00 
  818fcb:	b8 00 00 00 00       	mov    $0x0,%eax
  818fd0:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  818fd7:	00 00 00 
  818fda:	ff d1                	callq  *%rcx
    return tid;
  818fdc:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  818fdf:	c9                   	leaveq 
  818fe0:	c3                   	retq   

0000000000818fe1 <thread_set_name>:

static void
thread_set_name(struct thread_context *tc, const char *name)
{
  818fe1:	55                   	push   %rbp
  818fe2:	48 89 e5             	mov    %rsp,%rbp
  818fe5:	48 83 ec 10          	sub    $0x10,%rsp
  818fe9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  818fed:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    strncpy(tc->tc_name, name, name_size - 1);
  818ff1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ff5:	48 8d 48 10          	lea    0x10(%rax),%rcx
  818ff9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818ffd:	ba 1f 00 00 00       	mov    $0x1f,%edx
  819002:	48 89 c6             	mov    %rax,%rsi
  819005:	48 89 cf             	mov    %rcx,%rdi
  819008:	48 b8 54 1f 80 00 00 	movabs $0x801f54,%rax
  81900f:	00 00 00 
  819012:	ff d0                	callq  *%rax
    tc->tc_name[name_size - 1] = 0;
  819014:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819018:	c6 40 2f 00          	movb   $0x0,0x2f(%rax)
}
  81901c:	90                   	nop
  81901d:	c9                   	leaveq 
  81901e:	c3                   	retq   

000000000081901f <thread_entry>:

static void
thread_entry(void) {
  81901f:	55                   	push   %rbp
  819020:	48 89 e5             	mov    %rsp,%rbp
    cur_tc->tc_entry(cur_tc->tc_arg);
  819023:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  81902a:	00 00 00 
  81902d:	48 8b 00             	mov    (%rax),%rax
  819030:	48 8b 40 30          	mov    0x30(%rax),%rax
  819034:	48 ba 78 74 b5 00 00 	movabs $0xb57478,%rdx
  81903b:	00 00 00 
  81903e:	48 8b 12             	mov    (%rdx),%rdx
  819041:	8b 52 38             	mov    0x38(%rdx),%edx
  819044:	89 d2                	mov    %edx,%edx
  819046:	48 89 d7             	mov    %rdx,%rdi
  819049:	ff d0                	callq  *%rax
    thread_halt();
  81904b:	48 b8 66 92 81 00 00 	movabs $0x819266,%rax
  819052:	00 00 00 
  819055:	ff d0                	callq  *%rax
}
  819057:	90                   	nop
  819058:	5d                   	pop    %rbp
  819059:	c3                   	retq   

000000000081905a <thread_create>:

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint64_t), uint64_t arg) {
  81905a:	55                   	push   %rbp
  81905b:	48 89 e5             	mov    %rsp,%rbp
  81905e:	48 83 ec 30          	sub    $0x30,%rsp
  819062:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  819066:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81906a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81906e:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  819072:	bf f0 00 00 00       	mov    $0xf0,%edi
  819077:	48 b8 29 4e 80 00 00 	movabs $0x804e29,%rax
  81907e:	00 00 00 
  819081:	ff d0                	callq  *%rax
  819083:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!tc)
  819087:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81908c:	75 0a                	jne    819098 <thread_create+0x3e>
	return -E_NO_MEM;
  81908e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  819093:	e9 52 01 00 00       	jmpq   8191ea <thread_create+0x190>

    memset(tc, 0, sizeof(struct thread_context));
  819098:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81909c:	ba f0 00 00 00       	mov    $0xf0,%edx
  8190a1:	be 00 00 00 00       	mov    $0x0,%esi
  8190a6:	48 89 c7             	mov    %rax,%rdi
  8190a9:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  8190b0:	00 00 00 
  8190b3:	ff d0                	callq  *%rax
    
    thread_set_name(tc, name);
  8190b5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8190b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8190bd:	48 89 d6             	mov    %rdx,%rsi
  8190c0:	48 89 c7             	mov    %rax,%rdi
  8190c3:	48 b8 e1 8f 81 00 00 	movabs $0x818fe1,%rax
  8190ca:	00 00 00 
  8190cd:	ff d0                	callq  *%rax
    tc->tc_tid = alloc_tid();
  8190cf:	48 b8 7b 8f 81 00 00 	movabs $0x818f7b,%rax
  8190d6:	00 00 00 
  8190d9:	ff d0                	callq  *%rax
  8190db:	89 c2                	mov    %eax,%edx
  8190dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8190e1:	89 10                	mov    %edx,(%rax)

    tc->tc_stack_bottom = malloc(stack_size);
  8190e3:	bf 00 10 00 00       	mov    $0x1000,%edi
  8190e8:	48 b8 29 4e 80 00 00 	movabs $0x804e29,%rax
  8190ef:	00 00 00 
  8190f2:	ff d0                	callq  *%rax
  8190f4:	48 89 c2             	mov    %rax,%rdx
  8190f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8190fb:	48 89 50 08          	mov    %rdx,0x8(%rax)
    if (!tc->tc_stack_bottom) {
  8190ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819103:	48 8b 40 08          	mov    0x8(%rax),%rax
  819107:	48 85 c0             	test   %rax,%rax
  81910a:	75 1d                	jne    819129 <thread_create+0xcf>
	free(tc);
  81910c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819110:	48 89 c7             	mov    %rax,%rdi
  819113:	48 b8 9a 51 80 00 00 	movabs $0x80519a,%rax
  81911a:	00 00 00 
  81911d:	ff d0                	callq  *%rax
	return -E_NO_MEM;
  81911f:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  819124:	e9 c1 00 00 00       	jmpq   8191ea <thread_create+0x190>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
  819129:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81912d:	48 8b 40 08          	mov    0x8(%rax),%rax
  819131:	48 05 00 10 00 00    	add    $0x1000,%rax
  819137:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    // Terminate stack unwinding
    stacktop = stacktop - 8;
  81913b:	48 83 6d f0 08       	subq   $0x8,-0x10(%rbp)
    memset(stacktop, 0, 8);
  819140:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819144:	ba 08 00 00 00       	mov    $0x8,%edx
  819149:	be 00 00 00 00       	mov    $0x0,%esi
  81914e:	48 89 c7             	mov    %rax,%rdi
  819151:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  819158:	00 00 00 
  81915b:	ff d0                	callq  *%rax
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  81915d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819161:	48 83 c0 40          	add    $0x40,%rax
  819165:	ba 70 00 00 00       	mov    $0x70,%edx
  81916a:	be 00 00 00 00       	mov    $0x0,%esi
  81916f:	48 89 c7             	mov    %rax,%rdi
  819172:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  819179:	00 00 00 
  81917c:	ff d0                	callq  *%rax
    tc->tc_jb.jb_rsp = (uint64_t)stacktop;
  81917e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  819182:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819186:	48 89 50 48          	mov    %rdx,0x48(%rax)
    tc->tc_jb.jb_rip = (uint64_t)&thread_entry;
  81918a:	48 ba 1f 90 81 00 00 	movabs $0x81901f,%rdx
  819191:	00 00 00 
  819194:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819198:	48 89 50 40          	mov    %rdx,0x40(%rax)
    tc->tc_entry = entry;
  81919c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8191a0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8191a4:	48 89 50 30          	mov    %rdx,0x30(%rax)
    tc->tc_arg = arg;
  8191a8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8191ac:	89 c2                	mov    %eax,%edx
  8191ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8191b2:	89 50 38             	mov    %edx,0x38(%rax)

    threadq_push(&thread_queue, tc);
  8191b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8191b9:	48 89 c6             	mov    %rax,%rsi
  8191bc:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  8191c3:	00 00 00 
  8191c6:	48 b8 92 8c 81 00 00 	movabs $0x818c92,%rax
  8191cd:	00 00 00 
  8191d0:	ff d0                	callq  *%rax

    if (tid)
  8191d2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8191d7:	74 0c                	je     8191e5 <thread_create+0x18b>
	*tid = tc->tc_tid;
  8191d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8191dd:	8b 10                	mov    (%rax),%edx
  8191df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8191e3:	89 10                	mov    %edx,(%rax)
    return 0;
  8191e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8191ea:	c9                   	leaveq 
  8191eb:	c3                   	retq   

00000000008191ec <thread_clean>:

static void
thread_clean(struct thread_context *tc) {
  8191ec:	55                   	push   %rbp
  8191ed:	48 89 e5             	mov    %rsp,%rbp
  8191f0:	48 83 ec 20          	sub    $0x20,%rsp
  8191f4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    if (!tc) return;
  8191f8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8191fd:	74 64                	je     819263 <thread_clean+0x77>

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  8191ff:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  819206:	eb 20                	jmp    819228 <thread_clean+0x3c>
	tc->tc_onhalt[i](tc->tc_tid);
  819208:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81920c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81920f:	48 63 d2             	movslq %edx,%rdx
  819212:	48 83 c2 18          	add    $0x18,%rdx
  819216:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  81921a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81921e:	8b 12                	mov    (%rdx),%edx
  819220:	89 d7                	mov    %edx,%edi
  819222:	ff d0                	callq  *%rax
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  819224:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  819228:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81922c:	8b 80 e0 00 00 00    	mov    0xe0(%rax),%eax
  819232:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  819235:	7f d1                	jg     819208 <thread_clean+0x1c>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  819237:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81923b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81923f:	48 89 c7             	mov    %rax,%rdi
  819242:	48 b8 9a 51 80 00 00 	movabs $0x80519a,%rax
  819249:	00 00 00 
  81924c:	ff d0                	callq  *%rax
    free(tc);
  81924e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819252:	48 89 c7             	mov    %rax,%rdi
  819255:	48 b8 9a 51 80 00 00 	movabs $0x80519a,%rax
  81925c:	00 00 00 
  81925f:	ff d0                	callq  *%rax
  819261:	eb 01                	jmp    819264 <thread_clean+0x78>
    return 0;
}

static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;
  819263:	90                   	nop
    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
    free(tc);
}
  819264:	c9                   	leaveq 
  819265:	c3                   	retq   

0000000000819266 <thread_halt>:

void
thread_halt() {
  819266:	55                   	push   %rbp
  819267:	48 89 e5             	mov    %rsp,%rbp
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));
  81926a:	48 bf 90 74 b5 00 00 	movabs $0xb57490,%rdi
  819271:	00 00 00 
  819274:	48 b8 f8 8c 81 00 00 	movabs $0x818cf8,%rax
  81927b:	00 00 00 
  81927e:	ff d0                	callq  *%rax
  819280:	48 89 c7             	mov    %rax,%rdi
  819283:	48 b8 ec 91 81 00 00 	movabs $0x8191ec,%rax
  81928a:	00 00 00 
  81928d:	ff d0                	callq  *%rax

    threadq_push(&kill_queue, cur_tc);
  81928f:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  819296:	00 00 00 
  819299:	48 8b 00             	mov    (%rax),%rax
  81929c:	48 89 c6             	mov    %rax,%rsi
  81929f:	48 bf 90 74 b5 00 00 	movabs $0xb57490,%rdi
  8192a6:	00 00 00 
  8192a9:	48 b8 92 8c 81 00 00 	movabs $0x818c92,%rax
  8192b0:	00 00 00 
  8192b3:	ff d0                	callq  *%rax
    cur_tc = NULL;
  8192b5:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  8192bc:	00 00 00 
  8192bf:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    thread_yield();
  8192c6:	48 b8 e1 92 81 00 00 	movabs $0x8192e1,%rax
  8192cd:	00 00 00 
  8192d0:	ff d0                	callq  *%rax
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  8192d2:	48 b8 d4 10 80 00 00 	movabs $0x8010d4,%rax
  8192d9:	00 00 00 
  8192dc:	ff d0                	callq  *%rax
}
  8192de:	90                   	nop
  8192df:	5d                   	pop    %rbp
  8192e0:	c3                   	retq   

00000000008192e1 <thread_yield>:

void
thread_yield(void) {
  8192e1:	55                   	push   %rbp
  8192e2:	48 89 e5             	mov    %rsp,%rbp
  8192e5:	48 83 ec 10          	sub    $0x10,%rsp
    struct thread_context *next_tc = threadq_pop(&thread_queue);
  8192e9:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  8192f0:	00 00 00 
  8192f3:	48 b8 f8 8c 81 00 00 	movabs $0x818cf8,%rax
  8192fa:	00 00 00 
  8192fd:	ff d0                	callq  *%rax
  8192ff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    if (!next_tc)
  819303:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819308:	0f 84 92 00 00 00    	je     8193a0 <thread_yield+0xbf>
	return;

    if (cur_tc) {
  81930e:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  819315:	00 00 00 
  819318:	48 8b 00             	mov    (%rax),%rax
  81931b:	48 85 c0             	test   %rax,%rax
  81931e:	74 4a                	je     81936a <thread_yield+0x89>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  819320:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  819327:	00 00 00 
  81932a:	48 8b 00             	mov    (%rax),%rax
  81932d:	48 83 c0 40          	add    $0x40,%rax
  819331:	48 89 c7             	mov    %rax,%rdi
  819334:	48 b8 10 96 81 00 00 	movabs $0x819610,%rax
  81933b:	00 00 00 
  81933e:	ff d0                	callq  *%rax
  819340:	85 c0                	test   %eax,%eax
  819342:	75 5f                	jne    8193a3 <thread_yield+0xc2>
	    return;
	threadq_push(&thread_queue, cur_tc);
  819344:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  81934b:	00 00 00 
  81934e:	48 8b 00             	mov    (%rax),%rax
  819351:	48 89 c6             	mov    %rax,%rsi
  819354:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  81935b:	00 00 00 
  81935e:	48 b8 92 8c 81 00 00 	movabs $0x818c92,%rax
  819365:	00 00 00 
  819368:	ff d0                	callq  *%rax
    }

    cur_tc = next_tc;
  81936a:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  819371:	00 00 00 
  819374:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  819378:	48 89 10             	mov    %rdx,(%rax)
    jos_longjmp(&cur_tc->tc_jb, 1);
  81937b:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  819382:	00 00 00 
  819385:	48 8b 00             	mov    (%rax),%rax
  819388:	48 83 c0 40          	add    $0x40,%rax
  81938c:	be 01 00 00 00       	mov    $0x1,%esi
  819391:	48 89 c7             	mov    %rax,%rdi
  819394:	48 b8 60 96 81 00 00 	movabs $0x819660,%rax
  81939b:	00 00 00 
  81939e:	ff d0                	callq  *%rax
void
thread_yield(void) {
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;
  8193a0:	90                   	nop
  8193a1:	eb 01                	jmp    8193a4 <thread_yield+0xc3>

    if (cur_tc) {
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
	    return;
  8193a3:	90                   	nop
	threadq_push(&thread_queue, cur_tc);
    }

    cur_tc = next_tc;
    jos_longjmp(&cur_tc->tc_jb, 1);
}
  8193a4:	c9                   	leaveq 
  8193a5:	c3                   	retq   

00000000008193a6 <print_jb>:

static void
print_jb(struct thread_context *tc) {
  8193a6:	55                   	push   %rbp
  8193a7:	48 89 e5             	mov    %rsp,%rbp
  8193aa:	48 83 ec 10          	sub    $0x10,%rsp
  8193ae:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    cprintf("jump buffer for thread %s:\n", tc->tc_name);
  8193b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8193b6:	48 83 c0 10          	add    $0x10,%rax
  8193ba:	48 89 c6             	mov    %rax,%rsi
  8193bd:	48 bf 53 31 82 00 00 	movabs $0x823153,%rdi
  8193c4:	00 00 00 
  8193c7:	b8 00 00 00 00       	mov    $0x0,%eax
  8193cc:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8193d3:	00 00 00 
  8193d6:	ff d2                	callq  *%rdx
    cprintf("\trip: %x\n", tc->tc_jb.jb_rip);
  8193d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8193dc:	48 8b 40 40          	mov    0x40(%rax),%rax
  8193e0:	48 89 c6             	mov    %rax,%rsi
  8193e3:	48 bf 6f 31 82 00 00 	movabs $0x82316f,%rdi
  8193ea:	00 00 00 
  8193ed:	b8 00 00 00 00       	mov    $0x0,%eax
  8193f2:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8193f9:	00 00 00 
  8193fc:	ff d2                	callq  *%rdx
    cprintf("\trsp: %x\n", tc->tc_jb.jb_rsp);
  8193fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819402:	48 8b 40 48          	mov    0x48(%rax),%rax
  819406:	48 89 c6             	mov    %rax,%rsi
  819409:	48 bf 79 31 82 00 00 	movabs $0x823179,%rdi
  819410:	00 00 00 
  819413:	b8 00 00 00 00       	mov    $0x0,%eax
  819418:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  81941f:	00 00 00 
  819422:	ff d2                	callq  *%rdx
    cprintf("\trbp: %x\n", tc->tc_jb.jb_rbp);
  819424:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819428:	48 8b 40 50          	mov    0x50(%rax),%rax
  81942c:	48 89 c6             	mov    %rax,%rsi
  81942f:	48 bf 83 31 82 00 00 	movabs $0x823183,%rdi
  819436:	00 00 00 
  819439:	b8 00 00 00 00       	mov    $0x0,%eax
  81943e:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  819445:	00 00 00 
  819448:	ff d2                	callq  *%rdx
    cprintf("\trbx: %x\n", tc->tc_jb.jb_rbx);
  81944a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81944e:	48 8b 40 58          	mov    0x58(%rax),%rax
  819452:	48 89 c6             	mov    %rax,%rsi
  819455:	48 bf 8d 31 82 00 00 	movabs $0x82318d,%rdi
  81945c:	00 00 00 
  81945f:	b8 00 00 00 00       	mov    $0x0,%eax
  819464:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  81946b:	00 00 00 
  81946e:	ff d2                	callq  *%rdx
    cprintf("\trsi: %x\n", tc->tc_jb.jb_rsi);
  819470:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819474:	48 8b 40 60          	mov    0x60(%rax),%rax
  819478:	48 89 c6             	mov    %rax,%rsi
  81947b:	48 bf 97 31 82 00 00 	movabs $0x823197,%rdi
  819482:	00 00 00 
  819485:	b8 00 00 00 00       	mov    $0x0,%eax
  81948a:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  819491:	00 00 00 
  819494:	ff d2                	callq  *%rdx
    cprintf("\trdi: %x\n", tc->tc_jb.jb_rdi);
  819496:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81949a:	48 8b 40 68          	mov    0x68(%rax),%rax
  81949e:	48 89 c6             	mov    %rax,%rsi
  8194a1:	48 bf a1 31 82 00 00 	movabs $0x8231a1,%rdi
  8194a8:	00 00 00 
  8194ab:	b8 00 00 00 00       	mov    $0x0,%eax
  8194b0:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8194b7:	00 00 00 
  8194ba:	ff d2                	callq  *%rdx
    cprintf("\tr15: %x\n", tc->tc_jb.jb_r15);
  8194bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8194c0:	48 8b 40 70          	mov    0x70(%rax),%rax
  8194c4:	48 89 c6             	mov    %rax,%rsi
  8194c7:	48 bf ab 31 82 00 00 	movabs $0x8231ab,%rdi
  8194ce:	00 00 00 
  8194d1:	b8 00 00 00 00       	mov    $0x0,%eax
  8194d6:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8194dd:	00 00 00 
  8194e0:	ff d2                	callq  *%rdx
    cprintf("\tr14: %x\n", tc->tc_jb.jb_r14);
  8194e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8194e6:	48 8b 40 78          	mov    0x78(%rax),%rax
  8194ea:	48 89 c6             	mov    %rax,%rsi
  8194ed:	48 bf b5 31 82 00 00 	movabs $0x8231b5,%rdi
  8194f4:	00 00 00 
  8194f7:	b8 00 00 00 00       	mov    $0x0,%eax
  8194fc:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  819503:	00 00 00 
  819506:	ff d2                	callq  *%rdx
    cprintf("\tr13: %x\n", tc->tc_jb.jb_r13);
  819508:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81950c:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  819513:	48 89 c6             	mov    %rax,%rsi
  819516:	48 bf bf 31 82 00 00 	movabs $0x8231bf,%rdi
  81951d:	00 00 00 
  819520:	b8 00 00 00 00       	mov    $0x0,%eax
  819525:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  81952c:	00 00 00 
  81952f:	ff d2                	callq  *%rdx
    cprintf("\tr12: %x\n", tc->tc_jb.jb_r12);
  819531:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819535:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81953c:	48 89 c6             	mov    %rax,%rsi
  81953f:	48 bf c9 31 82 00 00 	movabs $0x8231c9,%rdi
  819546:	00 00 00 
  819549:	b8 00 00 00 00       	mov    $0x0,%eax
  81954e:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  819555:	00 00 00 
  819558:	ff d2                	callq  *%rdx
    cprintf("\tr11: %x\n", tc->tc_jb.jb_r11);
  81955a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81955e:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  819565:	48 89 c6             	mov    %rax,%rsi
  819568:	48 bf d3 31 82 00 00 	movabs $0x8231d3,%rdi
  81956f:	00 00 00 
  819572:	b8 00 00 00 00       	mov    $0x0,%eax
  819577:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  81957e:	00 00 00 
  819581:	ff d2                	callq  *%rdx
    cprintf("\tr10: %x\n", tc->tc_jb.jb_r10);
  819583:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819587:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81958e:	48 89 c6             	mov    %rax,%rsi
  819591:	48 bf dd 31 82 00 00 	movabs $0x8231dd,%rdi
  819598:	00 00 00 
  81959b:	b8 00 00 00 00       	mov    $0x0,%eax
  8195a0:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8195a7:	00 00 00 
  8195aa:	ff d2                	callq  *%rdx
    cprintf("\tr9: %x\n", tc->tc_jb.jb_r9);
  8195ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8195b0:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  8195b7:	48 89 c6             	mov    %rax,%rsi
  8195ba:	48 bf e7 31 82 00 00 	movabs $0x8231e7,%rdi
  8195c1:	00 00 00 
  8195c4:	b8 00 00 00 00       	mov    $0x0,%eax
  8195c9:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8195d0:	00 00 00 
  8195d3:	ff d2                	callq  *%rdx
    cprintf("\tr8: %x\n", tc->tc_jb.jb_r8);
  8195d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8195d9:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8195e0:	48 89 c6             	mov    %rax,%rsi
  8195e3:	48 bf f0 31 82 00 00 	movabs $0x8231f0,%rdi
  8195ea:	00 00 00 
  8195ed:	b8 00 00 00 00       	mov    $0x0,%eax
  8195f2:	48 ba 32 13 80 00 00 	movabs $0x801332,%rdx
  8195f9:	00 00 00 
  8195fc:	ff d2                	callq  *%rdx
}
  8195fe:	90                   	nop
  8195ff:	c9                   	leaveq 
  819600:	c3                   	retq   
  819601:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  819608:	00 00 00 
  81960b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000819610 <jos_setjmp>:


ENTRY(jos_setjmp)
	//movq	4(%esp), %ecx	// jos_jmp_buf

	movq	%rdi, %rcx	// jos_jmp_buf
  819610:	48 89 f9             	mov    %rdi,%rcx
	movq	0(%rsp), %rdx	// %rip as pushed by call
  819613:	48 8b 14 24          	mov    (%rsp),%rdx
	movq	%rdx,  0(%rcx)
  819617:	48 89 11             	mov    %rdx,(%rcx)

	leaq	8(%rsp), %rdx	// where %esp will point when we return
  81961a:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
	movq	%rdx,  8(%rcx)
  81961f:	48 89 51 08          	mov    %rdx,0x8(%rcx)

	movq	%rbp,  16(%rcx)
  819623:	48 89 69 10          	mov    %rbp,0x10(%rcx)
	movq	%rbx, 24(%rcx)
  819627:	48 89 59 18          	mov    %rbx,0x18(%rcx)
	movq	%rsi, 32(%rcx)
  81962b:	48 89 71 20          	mov    %rsi,0x20(%rcx)
	movq	%rdi, 40(%rcx)
  81962f:	48 89 79 28          	mov    %rdi,0x28(%rcx)
	movq	%r15, 48(%rcx)
  819633:	4c 89 79 30          	mov    %r15,0x30(%rcx)
	movq	%r14, 56(%rcx)
  819637:	4c 89 71 38          	mov    %r14,0x38(%rcx)
	movq	%r13, 64(%rcx)
  81963b:	4c 89 69 40          	mov    %r13,0x40(%rcx)
	movq	%r12, 72(%rcx)
  81963f:	4c 89 61 48          	mov    %r12,0x48(%rcx)
	movq	%r11, 80(%rcx)
  819643:	4c 89 59 50          	mov    %r11,0x50(%rcx)
	movq	%r10, 88(%rcx)
  819647:	4c 89 51 58          	mov    %r10,0x58(%rcx)
	movq	%r9, 96(%rcx)
  81964b:	4c 89 49 60          	mov    %r9,0x60(%rcx)
	movq	%r8, 104(%rcx)
  81964f:	4c 89 41 68          	mov    %r8,0x68(%rcx)

	movq	$0, %rax
  819653:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
	ret
  81965a:	c3                   	retq   
  81965b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000819660 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value
	movq     %rdi, %rax
  819660:	48 89 f8             	mov    %rdi,%rax
	movq	 %rsi, %rdx
  819663:	48 89 f2             	mov    %rsi,%rdx
	movq	 0(%rax), %rcx	// %rip
  819666:	48 8b 08             	mov    (%rax),%rcx
	movq	 8(%rax), %rsp
  819669:	48 8b 60 08          	mov    0x8(%rax),%rsp
	movq	 16(%rax), %rbp
  81966d:	48 8b 68 10          	mov    0x10(%rax),%rbp
	movq	24(%rax), %rbx
  819671:	48 8b 58 18          	mov    0x18(%rax),%rbx
	movq	32(%rax), %rsi
  819675:	48 8b 70 20          	mov    0x20(%rax),%rsi
	movq	40(%rax), %rdi
  819679:	48 8b 78 28          	mov    0x28(%rax),%rdi
	movq	48(%rax), %r15
  81967d:	4c 8b 78 30          	mov    0x30(%rax),%r15
	movq	56(%rax), %r14
  819681:	4c 8b 70 38          	mov    0x38(%rax),%r14
	movq	64(%rax), %r13
  819685:	4c 8b 68 40          	mov    0x40(%rax),%r13
	movq	72(%rax), %r12
  819689:	4c 8b 60 48          	mov    0x48(%rax),%r12
	movq	80(%rax), %r11
  81968d:	4c 8b 58 50          	mov    0x50(%rax),%r11
	movq	88(%rax), %r10
  819691:	4c 8b 50 58          	mov    0x58(%rax),%r10
	movq	96(%rax), %r9
  819695:	4c 8b 48 60          	mov    0x60(%rax),%r9
	movq	104(%rax), %r8
  819699:	4c 8b 40 68          	mov    0x68(%rax),%r8

	movq	%rdx, %rax
  81969d:	48 89 d0             	mov    %rdx,%rax
	jmp	*%rcx
  8196a0:	ff e1                	jmpq   *%rcx

00000000008196a2 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  8196a2:	55                   	push   %rbp
  8196a3:	48 89 e5             	mov    %rsp,%rbp
  8196a6:	48 83 ec 20          	sub    $0x20,%rsp
  8196aa:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int err = errno;
  8196ae:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8196b5:	00 00 00 
  8196b8:	8b 00                	mov    (%rax),%eax
  8196ba:	89 45 fc             	mov    %eax,-0x4(%rbp)
	cprintf("%s: %s\n", s, e2s(err));
  8196bd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8196c0:	89 c7                	mov    %eax,%edi
  8196c2:	48 b8 f6 96 81 00 00 	movabs $0x8196f6,%rax
  8196c9:	00 00 00 
  8196cc:	ff d0                	callq  *%rax
  8196ce:	48 89 c2             	mov    %rax,%rdx
  8196d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8196d5:	48 89 c6             	mov    %rax,%rsi
  8196d8:	48 bf dd 36 82 00 00 	movabs $0x8236dd,%rdi
  8196df:	00 00 00 
  8196e2:	b8 00 00 00 00       	mov    $0x0,%eax
  8196e7:	48 b9 32 13 80 00 00 	movabs $0x801332,%rcx
  8196ee:	00 00 00 
  8196f1:	ff d1                	callq  *%rcx
}
  8196f3:	90                   	nop
  8196f4:	c9                   	leaveq 
  8196f5:	c3                   	retq   

00000000008196f6 <e2s>:

const char *
e2s(int err) {
  8196f6:	55                   	push   %rbp
  8196f7:	48 89 e5             	mov    %rsp,%rbp
  8196fa:	48 83 ec 08          	sub    $0x8,%rsp
  8196fe:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return sys_errlist[err];
  819701:	48 b8 00 82 82 00 00 	movabs $0x828200,%rax
  819708:	00 00 00 
  81970b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81970e:	48 63 d2             	movslq %edx,%rdx
  819711:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
}
  819715:	c9                   	leaveq 
  819716:	c3                   	retq   

0000000000819717 <low_level_init>:
    envid_t envid;
};

static void
low_level_init(struct netif *netif)
{
  819717:	55                   	push   %rbp
  819718:	48 89 e5             	mov    %rsp,%rbp
  81971b:	48 83 ec 08          	sub    $0x8,%rsp
  81971f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    int r;

    netif->hwaddr_len = 6;
  819723:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819727:	c6 40 40 06          	movb   $0x6,0x40(%rax)
    netif->mtu = 1500;
  81972b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81972f:	66 c7 40 48 dc 05    	movw   $0x5dc,0x48(%rax)
    netif->flags = NETIF_FLAG_BROADCAST;
  819735:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819739:	c6 40 4a 02          	movb   $0x2,0x4a(%rax)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  81973d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819741:	c6 40 41 52          	movb   $0x52,0x41(%rax)
    netif->hwaddr[1] = 0x54;
  819745:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819749:	c6 40 42 54          	movb   $0x54,0x42(%rax)
    netif->hwaddr[2] = 0x00;
  81974d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819751:	c6 40 43 00          	movb   $0x0,0x43(%rax)
    netif->hwaddr[3] = 0x12;
  819755:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819759:	c6 40 44 12          	movb   $0x12,0x44(%rax)
    netif->hwaddr[4] = 0x34;
  81975d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819761:	c6 40 45 34          	movb   $0x34,0x45(%rax)
    netif->hwaddr[5] = 0x56;
  819765:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819769:	c6 40 46 56          	movb   $0x56,0x46(%rax)
}
  81976d:	90                   	nop
  81976e:	c9                   	leaveq 
  81976f:	c3                   	retq   

0000000000819770 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  819770:	55                   	push   %rbp
  819771:	48 89 e5             	mov    %rsp,%rbp
  819774:	48 83 ec 40          	sub    $0x40,%rsp
  819778:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81977c:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  819780:	ba 07 00 00 00       	mov    $0x7,%edx
  819785:	be 00 00 00 10       	mov    $0x10000000,%esi
  81978a:	bf 00 00 00 00       	mov    $0x0,%edi
  81978f:	48 b8 f8 27 80 00 00 	movabs $0x8027f8,%rax
  819796:	00 00 00 
  819799:	ff d0                	callq  *%rax
  81979b:	89 45 ec             	mov    %eax,-0x14(%rbp)
    if (r < 0)
  81979e:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8197a2:	79 2a                	jns    8197ce <low_level_output+0x5e>
	panic("jif: could not allocate page of memory");
  8197a4:	48 ba e8 36 82 00 00 	movabs $0x8236e8,%rdx
  8197ab:	00 00 00 
  8197ae:	be 56 00 00 00       	mov    $0x56,%esi
  8197b3:	48 bf 0f 37 82 00 00 	movabs $0x82370f,%rdi
  8197ba:	00 00 00 
  8197bd:	b8 00 00 00 00       	mov    $0x0,%eax
  8197c2:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8197c9:	00 00 00 
  8197cc:	ff d1                	callq  *%rcx
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;
  8197ce:	48 c7 45 e0 00 00 00 	movq   $0x10000000,-0x20(%rbp)
  8197d5:	10 

    struct jif *jif;
    jif = netif->state;
  8197d6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8197da:	48 8b 40 30          	mov    0x30(%rax),%rax
  8197de:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    char *txbuf = pkt->jp_data;
  8197e2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8197e6:	48 83 c0 04          	add    $0x4,%rax
  8197ea:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    int txsize = 0;
  8197ee:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  8197f5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8197f9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8197fd:	e9 a0 00 00 00       	jmpq   8198a2 <low_level_output+0x132>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  819802:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819806:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81980a:	0f b7 d0             	movzwl %ax,%edx
  81980d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  819810:	01 d0                	add    %edx,%eax
  819812:	3d d0 07 00 00       	cmp    $0x7d0,%eax
  819817:	7e 3e                	jle    819857 <low_level_output+0xe7>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  819819:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81981d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  819821:	0f b7 c0             	movzwl %ax,%eax
  819824:	8b 55 fc             	mov    -0x4(%rbp),%edx
  819827:	41 89 d0             	mov    %edx,%r8d
  81982a:	89 c1                	mov    %eax,%ecx
  81982c:	48 ba 28 37 82 00 00 	movabs $0x823728,%rdx
  819833:	00 00 00 
  819836:	be 65 00 00 00       	mov    $0x65,%esi
  81983b:	48 bf 0f 37 82 00 00 	movabs $0x82370f,%rdi
  819842:	00 00 00 
  819845:	b8 00 00 00 00       	mov    $0x0,%eax
  81984a:	49 b9 f8 10 80 00 00 	movabs $0x8010f8,%r9
  819851:	00 00 00 
  819854:	41 ff d1             	callq  *%r9
	memcpy(&txbuf[txsize], q->payload, q->len);
  819857:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81985b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81985f:	0f b7 d0             	movzwl %ax,%edx
  819862:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819866:	48 8b 40 08          	mov    0x8(%rax),%rax
  81986a:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  81986d:	48 63 f1             	movslq %ecx,%rsi
  819870:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  819874:	48 01 f1             	add    %rsi,%rcx
  819877:	48 89 c6             	mov    %rax,%rsi
  81987a:	48 89 cf             	mov    %rcx,%rdi
  81987d:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  819884:	00 00 00 
  819887:	ff d0                	callq  *%rax
	txsize += q->len;
  819889:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81988d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  819891:	0f b7 c0             	movzwl %ax,%eax
  819894:	01 45 fc             	add    %eax,-0x4(%rbp)
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  819897:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81989b:	48 8b 00             	mov    (%rax),%rax
  81989e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8198a2:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8198a7:	0f 85 55 ff ff ff    	jne    819802 <low_level_output+0x92>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  8198ad:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8198b1:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8198b4:	89 10                	mov    %edx,(%rax)

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  8198b6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8198ba:	8b 40 08             	mov    0x8(%rax),%eax
  8198bd:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8198c1:	b9 07 00 00 00       	mov    $0x7,%ecx
  8198c6:	be 0b 00 00 00       	mov    $0xb,%esi
  8198cb:	89 c7                	mov    %eax,%edi
  8198cd:	48 b8 cd 32 80 00 00 	movabs $0x8032cd,%rax
  8198d4:	00 00 00 
  8198d7:	ff d0                	callq  *%rax
    sys_page_unmap(0, (void *)pkt);
  8198d9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8198dd:	48 89 c6             	mov    %rax,%rsi
  8198e0:	bf 00 00 00 00       	mov    $0x0,%edi
  8198e5:	48 b8 aa 28 80 00 00 	movabs $0x8028aa,%rax
  8198ec:	00 00 00 
  8198ef:	ff d0                	callq  *%rax

    return ERR_OK;
  8198f1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8198f6:	c9                   	leaveq 
  8198f7:	c3                   	retq   

00000000008198f8 <low_level_input>:
 * packet from the interface into the pbuf.
 *
 */
static struct pbuf *
low_level_input(void *va)
{
  8198f8:	55                   	push   %rbp
  8198f9:	48 89 e5             	mov    %rsp,%rbp
  8198fc:	48 83 ec 50          	sub    $0x50,%rsp
  819900:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    struct jif_pkt *pkt = (struct jif_pkt *)va;
  819904:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819908:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    s16_t len = pkt->jp_len;
  81990c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  819910:	8b 00                	mov    (%rax),%eax
  819912:	66 89 45 de          	mov    %ax,-0x22(%rbp)

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  819916:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
  81991a:	0f b7 c0             	movzwl %ax,%eax
  81991d:	ba 03 00 00 00       	mov    $0x3,%edx
  819922:	89 c6                	mov    %eax,%esi
  819924:	bf 03 00 00 00       	mov    $0x3,%edi
  819929:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  819930:	00 00 00 
  819933:	ff d0                	callq  *%rax
  819935:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (p == 0)
  819939:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81993e:	75 0a                	jne    81994a <low_level_input+0x52>
	return 0;
  819940:	b8 00 00 00 00       	mov    $0x0,%eax
  819945:	e9 8a 00 00 00       	jmpq   8199d4 <low_level_input+0xdc>

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  81994a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81994e:	48 83 c0 04          	add    $0x4,%rax
  819952:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    int copied = 0;
  819956:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  81995d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  819961:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  819965:	eb 62                	jmp    8199c9 <low_level_input+0xd1>
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  819967:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81996b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81996f:	0f b7 c0             	movzwl %ax,%eax
  819972:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if (bytes > (len - copied))
  819975:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  819979:	2b 45 fc             	sub    -0x4(%rbp),%eax
  81997c:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  81997f:	7d 0a                	jge    81998b <low_level_input+0x93>
	    bytes = len - copied;
  819981:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  819985:	2b 45 fc             	sub    -0x4(%rbp),%eax
  819988:	89 45 ec             	mov    %eax,-0x14(%rbp)
	memcpy(q->payload, rxbuf + copied, bytes);
  81998b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81998e:	48 63 d0             	movslq %eax,%rdx
  819991:	8b 45 fc             	mov    -0x4(%rbp),%eax
  819994:	48 63 c8             	movslq %eax,%rcx
  819997:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81999b:	48 01 c1             	add    %rax,%rcx
  81999e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8199a2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8199a6:	48 89 ce             	mov    %rcx,%rsi
  8199a9:	48 89 c7             	mov    %rax,%rdi
  8199ac:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  8199b3:	00 00 00 
  8199b6:	ff d0                	callq  *%rax
	copied += bytes;
  8199b8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8199bb:	01 45 fc             	add    %eax,-0x4(%rbp)
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  8199be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8199c2:	48 8b 00             	mov    (%rax),%rax
  8199c5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8199c9:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8199ce:	75 97                	jne    819967 <low_level_input+0x6f>
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
	copied += bytes;
    }

    return p;
  8199d0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
}
  8199d4:	c9                   	leaveq 
  8199d5:	c3                   	retq   

00000000008199d6 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  8199d6:	55                   	push   %rbp
  8199d7:	48 89 e5             	mov    %rsp,%rbp
  8199da:	48 83 ec 20          	sub    $0x20,%rsp
  8199de:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8199e2:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8199e6:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  8199ea:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8199ee:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8199f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8199f6:	48 89 ce             	mov    %rcx,%rsi
  8199f9:	48 89 c7             	mov    %rax,%rdi
  8199fc:	48 b8 e3 6b 81 00 00 	movabs $0x816be3,%rax
  819a03:	00 00 00 
  819a06:	ff d0                	callq  *%rax
}
  819a08:	c9                   	leaveq 
  819a09:	c3                   	retq   

0000000000819a0a <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  819a0a:	55                   	push   %rbp
  819a0b:	48 89 e5             	mov    %rsp,%rbp
  819a0e:	48 83 ec 30          	sub    $0x30,%rsp
  819a12:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  819a16:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  819a1a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819a1e:	48 8b 40 30          	mov    0x30(%rax),%rax
  819a22:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
    /* move received packet into a new pbuf */
    p = low_level_input(va);
  819a26:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  819a2a:	48 89 c7             	mov    %rax,%rdi
  819a2d:	48 b8 f8 98 81 00 00 	movabs $0x8198f8,%rax
  819a34:	00 00 00 
  819a37:	ff d0                	callq  *%rax
  819a39:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
  819a3d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  819a42:	0f 84 bc 00 00 00    	je     819b04 <jif_input+0xfa>
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;
  819a48:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819a4c:	48 8b 40 08          	mov    0x8(%rax),%rax
  819a50:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    switch (htons(ethhdr->type)) {
  819a54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819a58:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  819a5c:	0f b7 c0             	movzwl %ax,%eax
  819a5f:	89 c7                	mov    %eax,%edi
  819a61:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  819a68:	00 00 00 
  819a6b:	ff d0                	callq  *%rax
  819a6d:	0f b7 c0             	movzwl %ax,%eax
  819a70:	3d 00 08 00 00       	cmp    $0x800,%eax
  819a75:	74 09                	je     819a80 <jif_input+0x76>
  819a77:	3d 06 08 00 00       	cmp    $0x806,%eax
  819a7c:	74 4e                	je     819acc <jif_input+0xc2>
  819a7e:	eb 6f                	jmp    819aef <jif_input+0xe5>
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  819a80:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  819a84:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819a88:	48 89 d6             	mov    %rdx,%rsi
  819a8b:	48 89 c7             	mov    %rax,%rdi
  819a8e:	48 b8 02 68 81 00 00 	movabs $0x816802,%rax
  819a95:	00 00 00 
  819a98:	ff d0                	callq  *%rax
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  819a9a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819a9e:	be f2 ff ff ff       	mov    $0xfffffff2,%esi
  819aa3:	48 89 c7             	mov    %rax,%rdi
  819aa6:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  819aad:	00 00 00 
  819ab0:	ff d0                	callq  *%rax
	/* pass to network layer */
	netif->input(p, netif);
  819ab2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819ab6:	48 8b 40 18          	mov    0x18(%rax),%rax
  819aba:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  819abe:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  819ac2:	48 89 ce             	mov    %rcx,%rsi
  819ac5:	48 89 d7             	mov    %rdx,%rdi
  819ac8:	ff d0                	callq  *%rax
	break;
  819aca:	eb 39                	jmp    819b05 <jif_input+0xfb>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  819acc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819ad0:	48 8b 08             	mov    (%rax),%rcx
  819ad3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  819ad7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819adb:	48 89 ce             	mov    %rcx,%rsi
  819ade:	48 89 c7             	mov    %rax,%rdi
  819ae1:	48 b8 99 68 81 00 00 	movabs $0x816899,%rax
  819ae8:	00 00 00 
  819aeb:	ff d0                	callq  *%rax
	break;
  819aed:	eb 16                	jmp    819b05 <jif_input+0xfb>

    default:
	pbuf_free(p);
  819aef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819af3:	48 89 c7             	mov    %rax,%rdi
  819af6:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  819afd:	00 00 00 
  819b00:	ff d0                	callq  *%rax
  819b02:	eb 01                	jmp    819b05 <jif_input+0xfb>
  
    /* move received packet into a new pbuf */
    p = low_level_input(va);

    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
  819b04:	90                   	nop
	break;

    default:
	pbuf_free(p);
    }
}
  819b05:	c9                   	leaveq 
  819b06:	c3                   	retq   

0000000000819b07 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  819b07:	55                   	push   %rbp
  819b08:	48 89 e5             	mov    %rsp,%rbp
  819b0b:	48 83 ec 30          	sub    $0x30,%rsp
  819b0f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  819b13:	bf 10 00 00 00       	mov    $0x10,%edi
  819b18:	48 b8 10 ca 80 00 00 	movabs $0x80ca10,%rax
  819b1f:	00 00 00 
  819b22:	ff d0                	callq  *%rax
  819b24:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    if (jif == NULL) {
  819b28:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819b2d:	75 0a                	jne    819b39 <jif_init+0x32>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  819b2f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  819b34:	e9 ce 00 00 00       	jmpq   819c07 <jif_init+0x100>
    }

    output_envid = (envid_t *)netif->state;
  819b39:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819b3d:	48 8b 40 30          	mov    0x30(%rax),%rax
  819b41:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

    netif->state = jif;
  819b45:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819b49:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  819b4d:	48 89 50 30          	mov    %rdx,0x30(%rax)
    netif->output = jif_output;
  819b51:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819b55:	48 b9 d6 99 81 00 00 	movabs $0x8199d6,%rcx
  819b5c:	00 00 00 
  819b5f:	48 89 48 20          	mov    %rcx,0x20(%rax)
    netif->linkoutput = low_level_output;
  819b63:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819b67:	48 be 70 97 81 00 00 	movabs $0x819770,%rsi
  819b6e:	00 00 00 
  819b71:	48 89 70 28          	mov    %rsi,0x28(%rax)
    memcpy(&netif->name[0], "en", 2);
  819b75:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819b79:	48 83 c0 4b          	add    $0x4b,%rax
  819b7d:	ba 02 00 00 00       	mov    $0x2,%edx
  819b82:	48 be 51 37 82 00 00 	movabs $0x823751,%rsi
  819b89:	00 00 00 
  819b8c:	48 89 c7             	mov    %rax,%rdi
  819b8f:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  819b96:	00 00 00 
  819b99:	ff d0                	callq  *%rax

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  819b9b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819b9f:	48 8d 50 41          	lea    0x41(%rax),%rdx
  819ba3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819ba7:	48 89 10             	mov    %rdx,(%rax)
    jif->envid = *output_envid; 
  819baa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819bae:	8b 10                	mov    (%rax),%edx
  819bb0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819bb4:	89 50 08             	mov    %edx,0x8(%rax)

    low_level_init(netif);
  819bb7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819bbb:	48 89 c7             	mov    %rax,%rdi
  819bbe:	48 b8 17 97 81 00 00 	movabs $0x819717,%rax
  819bc5:	00 00 00 
  819bc8:	ff d0                	callq  *%rax
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  819bca:	48 bf 54 37 82 00 00 	movabs $0x823754,%rdi
  819bd1:	00 00 00 
  819bd4:	48 b8 c8 2c 81 00 00 	movabs $0x812cc8,%rax
  819bdb:	00 00 00 
  819bde:	ff d0                	callq  *%rax
  819be0:	89 45 ec             	mov    %eax,-0x14(%rbp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  819be3:	48 8d 4d ec          	lea    -0x14(%rbp),%rcx
  819be7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819beb:	ba 00 00 00 00       	mov    $0x0,%edx
  819bf0:	48 89 ce             	mov    %rcx,%rsi
  819bf3:	48 89 c7             	mov    %rax,%rdi
  819bf6:	48 b8 75 6d 81 00 00 	movabs $0x816d75,%rax
  819bfd:	00 00 00 
  819c00:	ff d0                	callq  *%rax

    return ERR_OK;
  819c02:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819c07:	c9                   	leaveq 
  819c08:	c3                   	retq   

0000000000819c09 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  819c09:	55                   	push   %rbp
  819c0a:	48 89 e5             	mov    %rsp,%rbp
  819c0d:	48 83 ec 40          	sub    $0x40,%rsp
  819c11:	89 7d cc             	mov    %edi,-0x34(%rbp)
  819c14:	89 f0                	mov    %esi,%eax
  819c16:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  819c1a:	88 45 c8             	mov    %al,-0x38(%rbp)
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  819c1d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  819c21:	8b 45 cc             	mov    -0x34(%rbp),%eax
  819c24:	48 89 d6             	mov    %rdx,%rsi
  819c27:	89 c7                	mov    %eax,%edi
  819c29:	48 b8 8e b2 81 00 00 	movabs $0x81b28e,%rax
  819c30:	00 00 00 
  819c33:	ff d0                	callq  *%rax
  819c35:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
  if (conn != NULL ) {
  819c39:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819c3e:	0f 84 62 01 00 00    	je     819da6 <netconn_new_with_proto_and_callback+0x19d>
    msg.function = do_newconn;
  819c44:	48 b8 44 b2 81 00 00 	movabs $0x81b244,%rax
  819c4b:	00 00 00 
  819c4e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    msg.msg.msg.n.proto = proto;
  819c52:	0f b6 45 c8          	movzbl -0x38(%rbp),%eax
  819c56:	88 45 e0             	mov    %al,-0x20(%rbp)
    msg.msg.conn = conn;
  819c59:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819c5d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    TCPIP_APIMSG(&msg);
  819c61:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819c65:	48 89 c7             	mov    %rax,%rdi
  819c68:	48 b8 f0 8c 80 00 00 	movabs $0x808cf0,%rax
  819c6f:	00 00 00 
  819c72:	ff d0                	callq  *%rax

    if (conn->err != ERR_OK) {
  819c74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819c78:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  819c7c:	84 c0                	test   %al,%al
  819c7e:	0f 84 22 01 00 00    	je     819da6 <netconn_new_with_proto_and_callback+0x19d>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  819c84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819c88:	48 8b 40 08          	mov    0x8(%rax),%rax
  819c8c:	48 85 c0             	test   %rax,%rax
  819c8f:	74 2a                	je     819cbb <netconn_new_with_proto_and_callback+0xb2>
  819c91:	48 ba 60 37 82 00 00 	movabs $0x823760,%rdx
  819c98:	00 00 00 
  819c9b:	be 53 00 00 00       	mov    $0x53,%esi
  819ca0:	48 bf 81 37 82 00 00 	movabs $0x823781,%rdi
  819ca7:	00 00 00 
  819caa:	b8 00 00 00 00       	mov    $0x0,%eax
  819caf:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819cb6:	00 00 00 
  819cb9:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  819cbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819cbf:	8b 40 14             	mov    0x14(%rax),%eax
  819cc2:	83 f8 ff             	cmp    $0xffffffff,%eax
  819cc5:	75 2a                	jne    819cf1 <netconn_new_with_proto_and_callback+0xe8>
  819cc7:	48 ba 98 37 82 00 00 	movabs $0x823798,%rdx
  819cce:	00 00 00 
  819cd1:	be 54 00 00 00       	mov    $0x54,%esi
  819cd6:	48 bf 81 37 82 00 00 	movabs $0x823781,%rdi
  819cdd:	00 00 00 
  819ce0:	b8 00 00 00 00       	mov    $0x0,%eax
  819ce5:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819cec:	00 00 00 
  819cef:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  819cf1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819cf5:	8b 40 18             	mov    0x18(%rax),%eax
  819cf8:	83 f8 ff             	cmp    $0xffffffff,%eax
  819cfb:	75 2a                	jne    819d27 <netconn_new_with_proto_and_callback+0x11e>
  819cfd:	48 ba b1 37 82 00 00 	movabs $0x8237b1,%rdx
  819d04:	00 00 00 
  819d07:	be 55 00 00 00       	mov    $0x55,%esi
  819d0c:	48 bf 81 37 82 00 00 	movabs $0x823781,%rdi
  819d13:	00 00 00 
  819d16:	b8 00 00 00 00       	mov    $0x0,%eax
  819d1b:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819d22:	00 00 00 
  819d25:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  819d27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819d2b:	8b 40 1c             	mov    0x1c(%rax),%eax
  819d2e:	83 f8 ff             	cmp    $0xffffffff,%eax
  819d31:	74 2a                	je     819d5d <netconn_new_with_proto_and_callback+0x154>
  819d33:	48 ba c8 37 82 00 00 	movabs $0x8237c8,%rdx
  819d3a:	00 00 00 
  819d3d:	be 56 00 00 00       	mov    $0x56,%esi
  819d42:	48 bf 81 37 82 00 00 	movabs $0x823781,%rdi
  819d49:	00 00 00 
  819d4c:	b8 00 00 00 00       	mov    $0x0,%eax
  819d51:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819d58:	00 00 00 
  819d5b:	ff d1                	callq  *%rcx
      sys_sem_free(conn->op_completed);
  819d5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819d61:	8b 40 14             	mov    0x14(%rax),%eax
  819d64:	89 c7                	mov    %eax,%edi
  819d66:	48 b8 5a 80 81 00 00 	movabs $0x81805a,%rax
  819d6d:	00 00 00 
  819d70:	ff d0                	callq  *%rax
      sys_mbox_free(conn->recvmbox);
  819d72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819d76:	8b 40 18             	mov    0x18(%rax),%eax
  819d79:	89 c7                	mov    %eax,%edi
  819d7b:	48 b8 3d 7a 81 00 00 	movabs $0x817a3d,%rax
  819d82:	00 00 00 
  819d85:	ff d0                	callq  *%rax
      memp_free(MEMP_NETCONN, conn);
  819d87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819d8b:	48 89 c6             	mov    %rax,%rsi
  819d8e:	bf 07 00 00 00       	mov    $0x7,%edi
  819d93:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  819d9a:	00 00 00 
  819d9d:	ff d0                	callq  *%rax
      return NULL;
  819d9f:	b8 00 00 00 00       	mov    $0x0,%eax
  819da4:	eb 04                	jmp    819daa <netconn_new_with_proto_and_callback+0x1a1>
    }
  }
  return conn;
  819da6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  819daa:	c9                   	leaveq 
  819dab:	c3                   	retq   

0000000000819dac <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  819dac:	55                   	push   %rbp
  819dad:	48 89 e5             	mov    %rsp,%rbp
  819db0:	48 83 ec 40          	sub    $0x40,%rsp
  819db4:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  819db8:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819dbd:	75 07                	jne    819dc6 <netconn_delete+0x1a>
    return ERR_OK;
  819dbf:	b8 00 00 00 00       	mov    $0x0,%eax
  819dc4:	eb 4d                	jmp    819e13 <netconn_delete+0x67>
  }

  msg.function = do_delconn;
  819dc6:	48 b8 5e b8 81 00 00 	movabs $0x81b85e,%rax
  819dcd:	00 00 00 
  819dd0:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819dd4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819dd8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  tcpip_apimsg(&msg);
  819ddc:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819de0:	48 89 c7             	mov    %rax,%rdi
  819de3:	48 b8 f0 8c 80 00 00 	movabs $0x808cf0,%rax
  819dea:	00 00 00 
  819ded:	ff d0                	callq  *%rax

  conn->pcb.tcp = NULL;
  819def:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819df3:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  819dfa:	00 
  netconn_free(conn);
  819dfb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819dff:	48 89 c7             	mov    %rax,%rdi
  819e02:	48 b8 c6 b3 81 00 00 	movabs $0x81b3c6,%rax
  819e09:	00 00 00 
  819e0c:	ff d0                	callq  *%rax

  return ERR_OK;
  819e0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819e13:	c9                   	leaveq 
  819e14:	c3                   	retq   

0000000000819e15 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  819e15:	55                   	push   %rbp
  819e16:	48 89 e5             	mov    %rsp,%rbp
  819e19:	48 83 ec 10          	sub    $0x10,%rsp
  819e1d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  819e21:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819e26:	75 2a                	jne    819e52 <netconn_type+0x3d>
  819e28:	48 ba e9 37 82 00 00 	movabs $0x8237e9,%rdx
  819e2f:	00 00 00 
  819e32:	be 85 00 00 00       	mov    $0x85,%esi
  819e37:	48 bf 81 37 82 00 00 	movabs $0x823781,%rdi
  819e3e:	00 00 00 
  819e41:	b8 00 00 00 00       	mov    $0x0,%eax
  819e46:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819e4d:	00 00 00 
  819e50:	ff d1                	callq  *%rcx
  return conn->type;
  819e52:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819e56:	8b 00                	mov    (%rax),%eax
}
  819e58:	c9                   	leaveq 
  819e59:	c3                   	retq   

0000000000819e5a <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  819e5a:	55                   	push   %rbp
  819e5b:	48 89 e5             	mov    %rsp,%rbp
  819e5e:	48 83 ec 50          	sub    $0x50,%rsp
  819e62:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819e66:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819e6a:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  819e6e:	89 c8                	mov    %ecx,%eax
  819e70:	88 45 b4             	mov    %al,-0x4c(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  819e73:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819e78:	75 2a                	jne    819ea4 <netconn_getaddr+0x4a>
  819e7a:	48 ba 04 38 82 00 00 	movabs $0x823804,%rdx
  819e81:	00 00 00 
  819e84:	be 99 00 00 00       	mov    $0x99,%esi
  819e89:	48 bf 81 37 82 00 00 	movabs $0x823781,%rdi
  819e90:	00 00 00 
  819e93:	b8 00 00 00 00       	mov    $0x0,%eax
  819e98:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819e9f:	00 00 00 
  819ea2:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  819ea4:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  819ea9:	75 2a                	jne    819ed5 <netconn_getaddr+0x7b>
  819eab:	48 ba 22 38 82 00 00 	movabs $0x823822,%rdx
  819eb2:	00 00 00 
  819eb5:	be 9a 00 00 00       	mov    $0x9a,%esi
  819eba:	48 bf 81 37 82 00 00 	movabs $0x823781,%rdi
  819ec1:	00 00 00 
  819ec4:	b8 00 00 00 00       	mov    $0x0,%eax
  819ec9:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819ed0:	00 00 00 
  819ed3:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  819ed5:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  819eda:	75 2a                	jne    819f06 <netconn_getaddr+0xac>
  819edc:	48 ba 40 38 82 00 00 	movabs $0x823840,%rdx
  819ee3:	00 00 00 
  819ee6:	be 9b 00 00 00       	mov    $0x9b,%esi
  819eeb:	48 bf 81 37 82 00 00 	movabs $0x823781,%rdi
  819ef2:	00 00 00 
  819ef5:	b8 00 00 00 00       	mov    $0x0,%eax
  819efa:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819f01:	00 00 00 
  819f04:	ff d1                	callq  *%rcx

  msg.function = do_getaddr;
  819f06:	48 b8 0b c4 81 00 00 	movabs $0x81c40b,%rax
  819f0d:	00 00 00 
  819f10:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819f14:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819f18:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.ad.ipaddr = addr;
  819f1c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819f20:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.ad.port = port;
  819f24:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819f28:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  msg.msg.msg.ad.local = local;
  819f2c:	0f b6 45 b4          	movzbl -0x4c(%rbp),%eax
  819f30:	88 45 f0             	mov    %al,-0x10(%rbp)
  TCPIP_APIMSG(&msg);
  819f33:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819f37:	48 89 c7             	mov    %rax,%rdi
  819f3a:	48 b8 f0 8c 80 00 00 	movabs $0x808cf0,%rax
  819f41:	00 00 00 
  819f44:	ff d0                	callq  *%rax

  return conn->err;
  819f46:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819f4a:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819f4e:	c9                   	leaveq 
  819f4f:	c3                   	retq   

0000000000819f50 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  819f50:	55                   	push   %rbp
  819f51:	48 89 e5             	mov    %rsp,%rbp
  819f54:	48 83 ec 50          	sub    $0x50,%rsp
  819f58:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819f5c:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819f60:	89 d0                	mov    %edx,%eax
  819f62:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  819f66:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819f6b:	75 2a                	jne    819f97 <netconn_bind+0x47>
  819f6d:	48 ba 5e 38 82 00 00 	movabs $0x82385e,%rdx
  819f74:	00 00 00 
  819f77:	be b6 00 00 00       	mov    $0xb6,%esi
  819f7c:	48 bf 81 37 82 00 00 	movabs $0x823781,%rdi
  819f83:	00 00 00 
  819f86:	b8 00 00 00 00       	mov    $0x0,%eax
  819f8b:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  819f92:	00 00 00 
  819f95:	ff d1                	callq  *%rcx

  msg.function = do_bind;
  819f97:	48 b8 9c b9 81 00 00 	movabs $0x81b99c,%rax
  819f9e:	00 00 00 
  819fa1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819fa5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819fa9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.bc.ipaddr = addr;
  819fad:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819fb1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.bc.port = port;
  819fb5:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  819fb9:	66 89 45 e8          	mov    %ax,-0x18(%rbp)
  TCPIP_APIMSG(&msg);
  819fbd:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819fc1:	48 89 c7             	mov    %rax,%rdi
  819fc4:	48 b8 f0 8c 80 00 00 	movabs $0x808cf0,%rax
  819fcb:	00 00 00 
  819fce:	ff d0                	callq  *%rax
  return conn->err;
  819fd0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819fd4:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819fd8:	c9                   	leaveq 
  819fd9:	c3                   	retq   

0000000000819fda <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  819fda:	55                   	push   %rbp
  819fdb:	48 89 e5             	mov    %rsp,%rbp
  819fde:	48 83 ec 50          	sub    $0x50,%rsp
  819fe2:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819fe6:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819fea:	89 d0                	mov    %edx,%eax
  819fec:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  819ff0:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819ff5:	75 2a                	jne    81a021 <netconn_connect+0x47>
  819ff7:	48 ba 79 38 82 00 00 	movabs $0x823879,%rdx
  819ffe:	00 00 00 
  81a001:	be cd 00 00 00       	mov    $0xcd,%esi
  81a006:	48 bf 81 37 82 00 00 	movabs $0x823781,%rdi
  81a00d:	00 00 00 
  81a010:	b8 00 00 00 00       	mov    $0x0,%eax
  81a015:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a01c:	00 00 00 
  81a01f:	ff d1                	callq  *%rcx

  msg.function = do_connect;
  81a021:	48 b8 4a bb 81 00 00 	movabs $0x81bb4a,%rax
  81a028:	00 00 00 
  81a02b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a02f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a033:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.bc.ipaddr = addr;
  81a037:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a03b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.bc.port = port;
  81a03f:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  81a043:	66 89 45 e8          	mov    %ax,-0x18(%rbp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  81a047:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a04b:	48 89 c7             	mov    %rax,%rdi
  81a04e:	48 b8 f0 8c 80 00 00 	movabs $0x808cf0,%rax
  81a055:	00 00 00 
  81a058:	ff d0                	callq  *%rax
  return conn->err;
  81a05a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a05e:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a062:	c9                   	leaveq 
  81a063:	c3                   	retq   

000000000081a064 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  81a064:	55                   	push   %rbp
  81a065:	48 89 e5             	mov    %rsp,%rbp
  81a068:	48 83 ec 40          	sub    $0x40,%rsp
  81a06c:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  81a070:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81a075:	75 2a                	jne    81a0a1 <netconn_disconnect+0x3d>
  81a077:	48 ba 98 38 82 00 00 	movabs $0x823898,%rdx
  81a07e:	00 00 00 
  81a081:	be e3 00 00 00       	mov    $0xe3,%esi
  81a086:	48 bf 81 37 82 00 00 	movabs $0x823781,%rdi
  81a08d:	00 00 00 
  81a090:	b8 00 00 00 00       	mov    $0x0,%eax
  81a095:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a09c:	00 00 00 
  81a09f:	ff d1                	callq  *%rcx

  msg.function = do_disconnect;
  81a0a1:	48 b8 b7 bc 81 00 00 	movabs $0x81bcb7,%rax
  81a0a8:	00 00 00 
  81a0ab:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a0af:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a0b3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  TCPIP_APIMSG(&msg);
  81a0b7:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a0bb:	48 89 c7             	mov    %rax,%rdi
  81a0be:	48 b8 f0 8c 80 00 00 	movabs $0x808cf0,%rax
  81a0c5:	00 00 00 
  81a0c8:	ff d0                	callq  *%rax
  return conn->err;
  81a0ca:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a0ce:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a0d2:	c9                   	leaveq 
  81a0d3:	c3                   	retq   

000000000081a0d4 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  81a0d4:	55                   	push   %rbp
  81a0d5:	48 89 e5             	mov    %rsp,%rbp
  81a0d8:	48 83 ec 40          	sub    $0x40,%rsp
  81a0dc:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81a0e0:	89 f0                	mov    %esi,%eax
  81a0e2:	88 45 c4             	mov    %al,-0x3c(%rbp)
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  81a0e5:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81a0ea:	75 2a                	jne    81a116 <netconn_listen_with_backlog+0x42>
  81a0ec:	48 ba b9 38 82 00 00 	movabs $0x8238b9,%rdx
  81a0f3:	00 00 00 
  81a0f6:	be fb 00 00 00       	mov    $0xfb,%esi
  81a0fb:	48 bf 81 37 82 00 00 	movabs $0x823781,%rdi
  81a102:	00 00 00 
  81a105:	b8 00 00 00 00       	mov    $0x0,%eax
  81a10a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a111:	00 00 00 
  81a114:	ff d1                	callq  *%rcx

  msg.function = do_listen;
  81a116:	48 b8 0b bd 81 00 00 	movabs $0x81bd0b,%rax
  81a11d:	00 00 00 
  81a120:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a124:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a128:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  81a12c:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a130:	48 89 c7             	mov    %rax,%rdi
  81a133:	48 b8 f0 8c 80 00 00 	movabs $0x808cf0,%rax
  81a13a:	00 00 00 
  81a13d:	ff d0                	callq  *%rax
  return conn->err;
  81a13f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a143:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a147:	c9                   	leaveq 
  81a148:	c3                   	retq   

000000000081a149 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  81a149:	55                   	push   %rbp
  81a14a:	48 89 e5             	mov    %rsp,%rbp
  81a14d:	48 83 ec 20          	sub    $0x20,%rsp
  81a151:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  81a155:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a15a:	75 2a                	jne    81a186 <netconn_accept+0x3d>
  81a15c:	48 ba d6 38 82 00 00 	movabs $0x8238d6,%rdx
  81a163:	00 00 00 
  81a166:	be 11 01 00 00       	mov    $0x111,%esi
  81a16b:	48 bf 81 37 82 00 00 	movabs $0x823781,%rdi
  81a172:	00 00 00 
  81a175:	b8 00 00 00 00       	mov    $0x0,%eax
  81a17a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a181:	00 00 00 
  81a184:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  81a186:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a18a:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a18d:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a190:	75 2a                	jne    81a1bc <netconn_accept+0x73>
  81a192:	48 ba f8 38 82 00 00 	movabs $0x8238f8,%rdx
  81a199:	00 00 00 
  81a19c:	be 12 01 00 00       	mov    $0x112,%esi
  81a1a1:	48 bf 81 37 82 00 00 	movabs $0x823781,%rdi
  81a1a8:	00 00 00 
  81a1ab:	b8 00 00 00 00       	mov    $0x0,%eax
  81a1b0:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a1b7:	00 00 00 
  81a1ba:	ff d1                	callq  *%rcx
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  81a1bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a1c0:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a1c3:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  81a1c7:	ba 00 00 00 00       	mov    $0x0,%edx
  81a1cc:	48 89 ce             	mov    %rcx,%rsi
  81a1cf:	89 c7                	mov    %eax,%edi
  81a1d1:	48 b8 21 85 81 00 00 	movabs $0x818521,%rax
  81a1d8:	00 00 00 
  81a1db:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  81a1dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a1e1:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a1e5:	48 85 c0             	test   %rax,%rax
  81a1e8:	74 1b                	je     81a205 <netconn_accept+0xbc>
  81a1ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a1ee:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a1f2:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81a1f6:	ba 00 00 00 00       	mov    $0x0,%edx
  81a1fb:	be 01 00 00 00       	mov    $0x1,%esi
  81a200:	48 89 cf             	mov    %rcx,%rdi
  81a203:	ff d0                	callq  *%rax
      TCPIP_APIMSG(&msg);
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
  81a205:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81a209:	c9                   	leaveq 
  81a20a:	c3                   	retq   

000000000081a20b <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  81a20b:	55                   	push   %rbp
  81a20c:	48 89 e5             	mov    %rsp,%rbp
  81a20f:	48 83 ec 50          	sub    $0x50,%rsp
  81a213:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  struct api_msg msg;
  struct netbuf *buf = NULL;
  81a217:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  81a21e:	00 
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  81a21f:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  81a224:	75 2a                	jne    81a250 <netconn_recv+0x45>
  81a226:	48 ba 1b 39 82 00 00 	movabs $0x82391b,%rdx
  81a22d:	00 00 00 
  81a230:	be 3b 01 00 00       	mov    $0x13b,%esi
  81a235:	48 bf 81 37 82 00 00 	movabs $0x823781,%rdi
  81a23c:	00 00 00 
  81a23f:	b8 00 00 00 00       	mov    $0x0,%eax
  81a244:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a24b:	00 00 00 
  81a24e:	ff d1                	callq  *%rcx

  if (conn->recvmbox == SYS_MBOX_NULL) {
  81a250:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a254:	8b 40 18             	mov    0x18(%rax),%eax
  81a257:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a25a:	75 12                	jne    81a26e <netconn_recv+0x63>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  81a25c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a260:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
    return NULL;
  81a264:	b8 00 00 00 00       	mov    $0x0,%eax
  81a269:	e9 21 02 00 00       	jmpq   81a48f <netconn_recv+0x284>
  }

  if (ERR_IS_FATAL(conn->err)) {
  81a26e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a272:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81a276:	3c fc                	cmp    $0xfc,%al
  81a278:	7d 0a                	jge    81a284 <netconn_recv+0x79>
    return NULL;
  81a27a:	b8 00 00 00 00       	mov    $0x0,%eax
  81a27f:	e9 0b 02 00 00       	jmpq   81a48f <netconn_recv+0x284>
  }

  if (conn->type == NETCONN_TCP) {
  81a284:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a288:	8b 00                	mov    (%rax),%eax
  81a28a:	83 f8 10             	cmp    $0x10,%eax
  81a28d:	0f 85 80 01 00 00    	jne    81a413 <netconn_recv+0x208>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  81a293:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a297:	8b 40 04             	mov    0x4(%rax),%eax
  81a29a:	83 f8 02             	cmp    $0x2,%eax
  81a29d:	75 12                	jne    81a2b1 <netconn_recv+0xa6>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  81a29f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a2a3:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
      return NULL;
  81a2a7:	b8 00 00 00 00       	mov    $0x0,%eax
  81a2ac:	e9 de 01 00 00       	jmpq   81a48f <netconn_recv+0x284>
    }

    buf = memp_malloc(MEMP_NETBUF);
  81a2b1:	bf 06 00 00 00       	mov    $0x6,%edi
  81a2b6:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  81a2bd:	00 00 00 
  81a2c0:	ff d0                	callq  *%rax
  81a2c2:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

    if (buf == NULL) {
  81a2c6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a2ca:	48 85 c0             	test   %rax,%rax
  81a2cd:	75 12                	jne    81a2e1 <netconn_recv+0xd6>
      conn->err = ERR_MEM;
  81a2cf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a2d3:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
      return NULL;
  81a2d7:	b8 00 00 00 00       	mov    $0x0,%eax
  81a2dc:	e9 ae 01 00 00       	jmpq   81a48f <netconn_recv+0x284>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  81a2e1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a2e5:	8b 40 18             	mov    0x18(%rax),%eax
  81a2e8:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  81a2ec:	ba 00 00 00 00       	mov    $0x0,%edx
  81a2f1:	48 89 ce             	mov    %rcx,%rsi
  81a2f4:	89 c7                	mov    %eax,%edi
  81a2f6:	48 b8 21 85 81 00 00 	movabs $0x818521,%rax
  81a2fd:	00 00 00 
  81a300:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  81a302:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a306:	48 85 c0             	test   %rax,%rax
  81a309:	74 24                	je     81a32f <netconn_recv+0x124>
      len = p->tot_len;
  81a30b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a30f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a313:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
      SYS_ARCH_DEC(conn->recv_avail, len);
  81a317:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a31b:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  81a31f:	66 2b 45 fe          	sub    -0x2(%rbp),%ax
  81a323:	89 c2                	mov    %eax,%edx
  81a325:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a329:	66 89 50 24          	mov    %dx,0x24(%rax)
  81a32d:	eb 06                	jmp    81a335 <netconn_recv+0x12a>
    } else {
      len = 0;
  81a32f:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  81a335:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a339:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a33d:	48 85 c0             	test   %rax,%rax
  81a340:	74 1a                	je     81a35c <netconn_recv+0x151>
  81a342:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a346:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a34a:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81a34e:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  81a352:	be 01 00 00 00       	mov    $0x1,%esi
  81a357:	48 89 cf             	mov    %rcx,%rdi
  81a35a:	ff d0                	callq  *%rax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  81a35c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a360:	48 85 c0             	test   %rax,%rax
  81a363:	75 36                	jne    81a39b <netconn_recv+0x190>
      memp_free(MEMP_NETBUF, buf);
  81a365:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a369:	48 89 c6             	mov    %rax,%rsi
  81a36c:	bf 06 00 00 00       	mov    $0x6,%edi
  81a371:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  81a378:	00 00 00 
  81a37b:	ff d0                	callq  *%rax
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  81a37d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a381:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81a385:	84 c0                	test   %al,%al
  81a387:	75 08                	jne    81a391 <netconn_recv+0x186>
        conn->err = ERR_CLSD;
  81a389:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a38d:	c6 40 10 f9          	movb   $0xf9,0x10(%rax)
      }
      return NULL;
  81a391:	b8 00 00 00 00       	mov    $0x0,%eax
  81a396:	e9 f4 00 00 00       	jmpq   81a48f <netconn_recv+0x284>
    }

    buf->p = p;
  81a39b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a39f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  81a3a3:	48 89 10             	mov    %rdx,(%rax)
    buf->ptr = p;
  81a3a6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a3aa:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  81a3ae:	48 89 50 08          	mov    %rdx,0x8(%rax)
    buf->port = 0;
  81a3b2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a3b6:	66 c7 40 18 00 00    	movw   $0x0,0x18(%rax)
    buf->addr = NULL;
  81a3bc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a3c0:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81a3c7:	00 

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  81a3c8:	48 b8 44 c0 81 00 00 	movabs $0x81c044,%rax
  81a3cf:	00 00 00 
  81a3d2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    msg.msg.conn = conn;
  81a3d6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a3da:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    if (buf != NULL) {
  81a3de:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a3e2:	48 85 c0             	test   %rax,%rax
  81a3e5:	74 11                	je     81a3f8 <netconn_recv+0x1ed>
      msg.msg.msg.r.len = buf->p->tot_len;
  81a3e7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a3eb:	48 8b 00             	mov    (%rax),%rax
  81a3ee:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a3f2:	66 89 45 e0          	mov    %ax,-0x20(%rbp)
  81a3f6:	eb 06                	jmp    81a3fe <netconn_recv+0x1f3>
    } else {
      msg.msg.msg.r.len = 1;
  81a3f8:	66 c7 45 e0 01 00    	movw   $0x1,-0x20(%rbp)
    }
    TCPIP_APIMSG(&msg);
  81a3fe:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a402:	48 89 c7             	mov    %rax,%rdi
  81a405:	48 b8 f0 8c 80 00 00 	movabs $0x808cf0,%rax
  81a40c:	00 00 00 
  81a40f:	ff d0                	callq  *%rax
  81a411:	eb 78                	jmp    81a48b <netconn_recv+0x280>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  81a413:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a417:	8b 40 18             	mov    0x18(%rax),%eax
  81a41a:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
  81a41e:	ba 00 00 00 00       	mov    $0x0,%edx
  81a423:	48 89 ce             	mov    %rcx,%rsi
  81a426:	89 c7                	mov    %eax,%edi
  81a428:	48 b8 21 85 81 00 00 	movabs $0x818521,%rax
  81a42f:	00 00 00 
  81a432:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  81a434:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a438:	48 85 c0             	test   %rax,%rax
  81a43b:	74 4e                	je     81a48b <netconn_recv+0x280>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  81a43d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a441:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a445:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a449:	48 8b 00             	mov    (%rax),%rax
  81a44c:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a450:	29 c2                	sub    %eax,%edx
  81a452:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a456:	66 89 50 24          	mov    %dx,0x24(%rax)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  81a45a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a45e:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a462:	48 85 c0             	test   %rax,%rax
  81a465:	74 24                	je     81a48b <netconn_recv+0x280>
  81a467:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81a46b:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a46f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81a473:	48 8b 12             	mov    (%rdx),%rdx
  81a476:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  81a47a:	0f b7 d2             	movzwl %dx,%edx
  81a47d:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  81a481:	be 01 00 00 00       	mov    $0x1,%esi
  81a486:	48 89 cf             	mov    %rcx,%rdi
  81a489:	ff d0                	callq  *%rax
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  81a48b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  81a48f:	c9                   	leaveq 
  81a490:	c3                   	retq   

000000000081a491 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  81a491:	55                   	push   %rbp
  81a492:	48 89 e5             	mov    %rsp,%rbp
  81a495:	48 83 ec 20          	sub    $0x20,%rsp
  81a499:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81a49d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  81a4a1:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  81a4a5:	89 c8                	mov    %ecx,%eax
  81a4a7:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  if (buf != NULL) {
  81a4ab:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a4b0:	74 34                	je     81a4e6 <netconn_sendto+0x55>
    buf->addr = addr;
  81a4b2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a4b6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81a4ba:	48 89 50 10          	mov    %rdx,0x10(%rax)
    buf->port = port;
  81a4be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a4c2:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  81a4c6:	66 89 50 18          	mov    %dx,0x18(%rax)
    return netconn_send(conn, buf);
  81a4ca:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81a4ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a4d2:	48 89 d6             	mov    %rdx,%rsi
  81a4d5:	48 89 c7             	mov    %rax,%rdi
  81a4d8:	48 b8 ed a4 81 00 00 	movabs $0x81a4ed,%rax
  81a4df:	00 00 00 
  81a4e2:	ff d0                	callq  *%rax
  81a4e4:	eb 05                	jmp    81a4eb <netconn_sendto+0x5a>
  }
  return ERR_VAL;
  81a4e6:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  81a4eb:	c9                   	leaveq 
  81a4ec:	c3                   	retq   

000000000081a4ed <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  81a4ed:	55                   	push   %rbp
  81a4ee:	48 89 e5             	mov    %rsp,%rbp
  81a4f1:	48 83 ec 40          	sub    $0x40,%rsp
  81a4f5:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81a4f9:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  81a4fd:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81a502:	75 2a                	jne    81a52e <netconn_send+0x41>
  81a504:	48 ba 36 39 82 00 00 	movabs $0x823936,%rdx
  81a50b:	00 00 00 
  81a50e:	be ba 01 00 00       	mov    $0x1ba,%esi
  81a513:	48 bf 81 37 82 00 00 	movabs $0x823781,%rdi
  81a51a:	00 00 00 
  81a51d:	b8 00 00 00 00       	mov    $0x0,%eax
  81a522:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a529:	00 00 00 
  81a52c:	ff d1                	callq  *%rcx

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  81a52e:	48 b8 b4 be 81 00 00 	movabs $0x81beb4,%rax
  81a535:	00 00 00 
  81a538:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a53c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a540:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.b = buf;
  81a544:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a548:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  TCPIP_APIMSG(&msg);
  81a54c:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a550:	48 89 c7             	mov    %rax,%rdi
  81a553:	48 b8 f0 8c 80 00 00 	movabs $0x808cf0,%rax
  81a55a:	00 00 00 
  81a55d:	ff d0                	callq  *%rax
  return conn->err;
  81a55f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a563:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a567:	c9                   	leaveq 
  81a568:	c3                   	retq   

000000000081a569 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  81a569:	55                   	push   %rbp
  81a56a:	48 89 e5             	mov    %rsp,%rbp
  81a56d:	48 83 ec 50          	sub    $0x50,%rsp
  81a571:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81a575:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  81a579:	89 55 bc             	mov    %edx,-0x44(%rbp)
  81a57c:	89 c8                	mov    %ecx,%eax
  81a57e:	88 45 b8             	mov    %al,-0x48(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  81a581:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81a586:	75 2a                	jne    81a5b2 <netconn_write+0x49>
  81a588:	48 ba 51 39 82 00 00 	movabs $0x823951,%rdx
  81a58f:	00 00 00 
  81a592:	be d4 01 00 00       	mov    $0x1d4,%esi
  81a597:	48 bf 81 37 82 00 00 	movabs $0x823781,%rdi
  81a59e:	00 00 00 
  81a5a1:	b8 00 00 00 00       	mov    $0x0,%eax
  81a5a6:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a5ad:	00 00 00 
  81a5b0:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  81a5b2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a5b6:	8b 00                	mov    (%rax),%eax
  81a5b8:	83 f8 10             	cmp    $0x10,%eax
  81a5bb:	74 2a                	je     81a5e7 <netconn_write+0x7e>
  81a5bd:	48 ba 70 39 82 00 00 	movabs $0x823970,%rdx
  81a5c4:	00 00 00 
  81a5c7:	be d5 01 00 00       	mov    $0x1d5,%esi
  81a5cc:	48 bf 81 37 82 00 00 	movabs $0x823781,%rdi
  81a5d3:	00 00 00 
  81a5d6:	b8 00 00 00 00       	mov    $0x0,%eax
  81a5db:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a5e2:	00 00 00 
  81a5e5:	ff d1                	callq  *%rcx

  msg.function = do_write;
  81a5e7:	48 b8 6a c3 81 00 00 	movabs $0x81c36a,%rax
  81a5ee:	00 00 00 
  81a5f1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a5f5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a5f9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.w.dataptr = dataptr;
  81a5fd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a601:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.w.apiflags = apiflags;
  81a605:	0f b6 45 b8          	movzbl -0x48(%rbp),%eax
  81a609:	88 45 ec             	mov    %al,-0x14(%rbp)
  msg.msg.msg.w.len = size;
  81a60c:	8b 45 bc             	mov    -0x44(%rbp),%eax
  81a60f:	89 45 e8             	mov    %eax,-0x18(%rbp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  81a612:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a616:	48 89 c7             	mov    %rax,%rdi
  81a619:	48 b8 f0 8c 80 00 00 	movabs $0x808cf0,%rax
  81a620:	00 00 00 
  81a623:	ff d0                	callq  *%rax
  return conn->err;
  81a625:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a629:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a62d:	c9                   	leaveq 
  81a62e:	c3                   	retq   

000000000081a62f <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  81a62f:	55                   	push   %rbp
  81a630:	48 89 e5             	mov    %rsp,%rbp
  81a633:	48 83 ec 40          	sub    $0x40,%rsp
  81a637:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  81a63b:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81a640:	75 2a                	jne    81a66c <netconn_close+0x3d>
  81a642:	48 ba 92 39 82 00 00 	movabs $0x823992,%rdx
  81a649:	00 00 00 
  81a64c:	be ee 01 00 00       	mov    $0x1ee,%esi
  81a651:	48 bf 81 37 82 00 00 	movabs $0x823781,%rdi
  81a658:	00 00 00 
  81a65b:	b8 00 00 00 00       	mov    $0x0,%eax
  81a660:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a667:	00 00 00 
  81a66a:	ff d1                	callq  *%rcx

  msg.function = do_close;
  81a66c:	48 b8 91 c5 81 00 00 	movabs $0x81c591,%rax
  81a673:	00 00 00 
  81a676:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a67a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a67e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  tcpip_apimsg(&msg);
  81a682:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a686:	48 89 c7             	mov    %rax,%rdi
  81a689:	48 b8 f0 8c 80 00 00 	movabs $0x808cf0,%rax
  81a690:	00 00 00 
  81a693:	ff d0                	callq  *%rax
  return conn->err;
  81a695:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a699:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a69d:	c9                   	leaveq 
  81a69e:	c3                   	retq   

000000000081a69f <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  81a69f:	55                   	push   %rbp
  81a6a0:	48 89 e5             	mov    %rsp,%rbp
  81a6a3:	48 83 ec 40          	sub    $0x40,%rsp
  81a6a7:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81a6ab:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  81a6af:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  81a6b3:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(addr);
  conn = arg;
  81a6b7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a6bb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  81a6bf:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a6c4:	0f 84 74 01 00 00    	je     81a83e <recv_raw+0x19f>
  81a6ca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a6ce:	8b 40 18             	mov    0x18(%rax),%eax
  81a6d1:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a6d4:	0f 84 64 01 00 00    	je     81a83e <recv_raw+0x19f>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  81a6da:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a6de:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a6e2:	0f b7 c0             	movzwl %ax,%eax
  81a6e5:	ba 00 00 00 00       	mov    $0x0,%edx
  81a6ea:	89 c6                	mov    %eax,%esi
  81a6ec:	bf 03 00 00 00       	mov    $0x3,%edi
  81a6f1:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  81a6f8:	00 00 00 
  81a6fb:	ff d0                	callq  *%rax
  81a6fd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if(q != NULL) {
  81a701:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a706:	74 39                	je     81a741 <recv_raw+0xa2>
      if (pbuf_copy(q, p) != ERR_OK) {
  81a708:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81a70c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a710:	48 89 d6             	mov    %rdx,%rsi
  81a713:	48 89 c7             	mov    %rax,%rdi
  81a716:	48 b8 4a e2 80 00 00 	movabs $0x80e24a,%rax
  81a71d:	00 00 00 
  81a720:	ff d0                	callq  *%rax
  81a722:	84 c0                	test   %al,%al
  81a724:	74 1b                	je     81a741 <recv_raw+0xa2>
        pbuf_free(q);
  81a726:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a72a:	48 89 c7             	mov    %rax,%rdi
  81a72d:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81a734:	00 00 00 
  81a737:	ff d0                	callq  *%rax
        q = NULL;
  81a739:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  81a740:	00 
      }
    }

    if(q != NULL) {
  81a741:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a746:	0f 84 f2 00 00 00    	je     81a83e <recv_raw+0x19f>
      buf = memp_malloc(MEMP_NETBUF);
  81a74c:	bf 06 00 00 00       	mov    $0x6,%edi
  81a751:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  81a758:	00 00 00 
  81a75b:	ff d0                	callq  *%rax
  81a75d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      if (buf == NULL) {
  81a761:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a766:	75 1d                	jne    81a785 <recv_raw+0xe6>
        pbuf_free(q);
  81a768:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a76c:	48 89 c7             	mov    %rax,%rdi
  81a76f:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81a776:	00 00 00 
  81a779:	ff d0                	callq  *%rax
        return 0;
  81a77b:	b8 00 00 00 00       	mov    $0x0,%eax
  81a780:	e9 be 00 00 00       	jmpq   81a843 <recv_raw+0x1a4>
      }

      buf->p = q;
  81a785:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a789:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81a78d:	48 89 10             	mov    %rdx,(%rax)
      buf->ptr = q;
  81a790:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a794:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81a798:	48 89 50 08          	mov    %rdx,0x8(%rax)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  81a79c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7a0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a7a4:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  81a7a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a7ac:	48 89 50 10          	mov    %rdx,0x10(%rax)
      buf->port = pcb->protocol;
  81a7b0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81a7b4:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81a7b8:	0f b6 d0             	movzbl %al,%edx
  81a7bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a7bf:	66 89 50 18          	mov    %dx,0x18(%rax)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  81a7c3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a7c7:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a7cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7cf:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a7d3:	01 c2                	add    %eax,%edx
  81a7d5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a7d9:	66 89 50 24          	mov    %dx,0x24(%rax)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  81a7dd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a7e1:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a7e5:	48 85 c0             	test   %rax,%rax
  81a7e8:	74 21                	je     81a80b <recv_raw+0x16c>
  81a7ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a7ee:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a7f2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81a7f6:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  81a7fa:	0f b7 d2             	movzwl %dx,%edx
  81a7fd:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81a801:	be 00 00 00 00       	mov    $0x0,%esi
  81a806:	48 89 cf             	mov    %rcx,%rdi
  81a809:	ff d0                	callq  *%rax
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  81a80b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a80f:	8b 40 18             	mov    0x18(%rax),%eax
  81a812:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81a816:	48 89 d6             	mov    %rdx,%rsi
  81a819:	89 c7                	mov    %eax,%edi
  81a81b:	48 b8 e6 7c 81 00 00 	movabs $0x817ce6,%rax
  81a822:	00 00 00 
  81a825:	ff d0                	callq  *%rax
  81a827:	84 c0                	test   %al,%al
  81a829:	74 13                	je     81a83e <recv_raw+0x19f>
        netbuf_delete(buf);
  81a82b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a82f:	48 89 c7             	mov    %rax,%rdi
  81a832:	48 b8 d7 8e 80 00 00 	movabs $0x808ed7,%rax
  81a839:	00 00 00 
  81a83c:	ff d0                	callq  *%rax
      }
    }
  }

  return 0; /* do not eat the packet */
  81a83e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a843:	c9                   	leaveq 
  81a844:	c3                   	retq   

000000000081a845 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  81a845:	55                   	push   %rbp
  81a846:	48 89 e5             	mov    %rsp,%rbp
  81a849:	48 83 ec 40          	sub    $0x40,%rsp
  81a84d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a851:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a855:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81a859:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  81a85d:	44 89 c0             	mov    %r8d,%eax
  81a860:	66 89 45 cc          	mov    %ax,-0x34(%rbp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  81a864:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81a869:	75 2a                	jne    81a895 <recv_udp+0x50>
  81a86b:	48 ba b0 39 82 00 00 	movabs $0x8239b0,%rdx
  81a872:	00 00 00 
  81a875:	be 8f 00 00 00       	mov    $0x8f,%esi
  81a87a:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81a881:	00 00 00 
  81a884:	b8 00 00 00 00       	mov    $0x0,%eax
  81a889:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a890:	00 00 00 
  81a893:	ff d1                	callq  *%rcx
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  81a895:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a89a:	75 2a                	jne    81a8c6 <recv_udp+0x81>
  81a89c:	48 ba f0 39 82 00 00 	movabs $0x8239f0,%rdx
  81a8a3:	00 00 00 
  81a8a6:	be 90 00 00 00       	mov    $0x90,%esi
  81a8ab:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81a8b2:	00 00 00 
  81a8b5:	b8 00 00 00 00       	mov    $0x0,%eax
  81a8ba:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a8c1:	00 00 00 
  81a8c4:	ff d1                	callq  *%rcx
  conn = arg;
  81a8c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a8ca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  81a8ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a8d2:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a8d6:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  81a8da:	74 2a                	je     81a906 <recv_udp+0xc1>
  81a8dc:	48 ba 0f 3a 82 00 00 	movabs $0x823a0f,%rdx
  81a8e3:	00 00 00 
  81a8e6:	be 92 00 00 00       	mov    $0x92,%esi
  81a8eb:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81a8f2:	00 00 00 
  81a8f5:	b8 00 00 00 00       	mov    $0x0,%eax
  81a8fa:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81a901:	00 00 00 
  81a904:	ff d1                	callq  *%rcx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  81a906:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a90b:	74 0c                	je     81a919 <recv_udp+0xd4>
  81a90d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a911:	8b 40 18             	mov    0x18(%rax),%eax
  81a914:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a917:	75 18                	jne    81a931 <recv_udp+0xec>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  81a919:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a91d:	48 89 c7             	mov    %rax,%rdi
  81a920:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81a927:	00 00 00 
  81a92a:	ff d0                	callq  *%rax
    return;
  81a92c:	e9 df 00 00 00       	jmpq   81aa10 <recv_udp+0x1cb>
  }

  buf = memp_malloc(MEMP_NETBUF);
  81a931:	bf 06 00 00 00       	mov    $0x6,%edi
  81a936:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  81a93d:	00 00 00 
  81a940:	ff d0                	callq  *%rax
  81a942:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (buf == NULL) {
  81a946:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a94b:	75 18                	jne    81a965 <recv_udp+0x120>
    pbuf_free(p);
  81a94d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a951:	48 89 c7             	mov    %rax,%rdi
  81a954:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81a95b:	00 00 00 
  81a95e:	ff d0                	callq  *%rax
    return;
  81a960:	e9 ab 00 00 00       	jmpq   81aa10 <recv_udp+0x1cb>
  } else {
    buf->p = p;
  81a965:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a969:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a96d:	48 89 10             	mov    %rdx,(%rax)
    buf->ptr = p;
  81a970:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a974:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a978:	48 89 50 08          	mov    %rdx,0x8(%rax)
    buf->addr = addr;
  81a97c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a980:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81a984:	48 89 50 10          	mov    %rdx,0x10(%rax)
    buf->port = port;
  81a988:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a98c:	0f b7 55 cc          	movzwl -0x34(%rbp),%edx
  81a990:	66 89 50 18          	mov    %dx,0x18(%rax)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  81a994:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a998:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a99c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a9a0:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a9a4:	01 c2                	add    %eax,%edx
  81a9a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a9aa:	66 89 50 24          	mov    %dx,0x24(%rax)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  81a9ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a9b2:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a9b6:	48 85 c0             	test   %rax,%rax
  81a9b9:	74 21                	je     81a9dc <recv_udp+0x197>
  81a9bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a9bf:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a9c3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a9c7:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  81a9cb:	0f b7 d2             	movzwl %dx,%edx
  81a9ce:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81a9d2:	be 00 00 00 00       	mov    $0x0,%esi
  81a9d7:	48 89 cf             	mov    %rcx,%rdi
  81a9da:	ff d0                	callq  *%rax
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  81a9dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a9e0:	8b 40 18             	mov    0x18(%rax),%eax
  81a9e3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81a9e7:	48 89 d6             	mov    %rdx,%rsi
  81a9ea:	89 c7                	mov    %eax,%edi
  81a9ec:	48 b8 e6 7c 81 00 00 	movabs $0x817ce6,%rax
  81a9f3:	00 00 00 
  81a9f6:	ff d0                	callq  *%rax
  81a9f8:	84 c0                	test   %al,%al
  81a9fa:	74 14                	je     81aa10 <recv_udp+0x1cb>
    netbuf_delete(buf);
  81a9fc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aa00:	48 89 c7             	mov    %rax,%rdi
  81aa03:	48 b8 d7 8e 80 00 00 	movabs $0x808ed7,%rax
  81aa0a:	00 00 00 
  81aa0d:	ff d0                	callq  *%rax
    return;
  81aa0f:	90                   	nop
  }
}
  81aa10:	c9                   	leaveq 
  81aa11:	c3                   	retq   

000000000081aa12 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  81aa12:	55                   	push   %rbp
  81aa13:	48 89 e5             	mov    %rsp,%rbp
  81aa16:	48 83 ec 30          	sub    $0x30,%rsp
  81aa1a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81aa1e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81aa22:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81aa26:	89 c8                	mov    %ecx,%eax
  81aa28:	88 45 d4             	mov    %al,-0x2c(%rbp)
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  81aa2b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81aa30:	75 2a                	jne    81aa5c <recv_tcp+0x4a>
  81aa32:	48 ba 30 3a 82 00 00 	movabs $0x823a30,%rdx
  81aa39:	00 00 00 
  81aa3c:	be c2 00 00 00       	mov    $0xc2,%esi
  81aa41:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81aa48:	00 00 00 
  81aa4b:	b8 00 00 00 00       	mov    $0x0,%eax
  81aa50:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81aa57:	00 00 00 
  81aa5a:	ff d1                	callq  *%rcx
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  81aa5c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81aa61:	75 2a                	jne    81aa8d <recv_tcp+0x7b>
  81aa63:	48 ba 58 3a 82 00 00 	movabs $0x823a58,%rdx
  81aa6a:	00 00 00 
  81aa6d:	be c3 00 00 00       	mov    $0xc3,%esi
  81aa72:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81aa79:	00 00 00 
  81aa7c:	b8 00 00 00 00       	mov    $0x0,%eax
  81aa81:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81aa88:	00 00 00 
  81aa8b:	ff d1                	callq  *%rcx
  conn = arg;
  81aa8d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aa91:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  81aa95:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aa99:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aa9d:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  81aaa1:	74 2a                	je     81aacd <recv_tcp+0xbb>
  81aaa3:	48 ba 77 3a 82 00 00 	movabs $0x823a77,%rdx
  81aaaa:	00 00 00 
  81aaad:	be c5 00 00 00       	mov    $0xc5,%esi
  81aab2:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81aab9:	00 00 00 
  81aabc:	b8 00 00 00 00       	mov    $0x0,%eax
  81aac1:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81aac8:	00 00 00 
  81aacb:	ff d1                	callq  *%rcx

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  81aacd:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81aad2:	74 0c                	je     81aae0 <recv_tcp+0xce>
  81aad4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aad8:	8b 40 18             	mov    0x18(%rax),%eax
  81aadb:	83 f8 ff             	cmp    $0xffffffff,%eax
  81aade:	75 0a                	jne    81aaea <recv_tcp+0xd8>
    return ERR_VAL;
  81aae0:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  81aae5:	e9 8f 00 00 00       	jmpq   81ab79 <recv_tcp+0x167>
  }

  conn->err = err;
  81aaea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aaee:	0f b6 55 d4          	movzbl -0x2c(%rbp),%edx
  81aaf2:	88 50 10             	mov    %dl,0x10(%rax)
  if (p != NULL) {
  81aaf5:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81aafa:	74 24                	je     81ab20 <recv_tcp+0x10e>
    len = p->tot_len;
  81aafc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ab00:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81ab04:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    SYS_ARCH_INC(conn->recv_avail, len);
  81ab08:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ab0c:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81ab10:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81ab14:	01 c2                	add    %eax,%edx
  81ab16:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ab1a:	66 89 50 24          	mov    %dx,0x24(%rax)
  81ab1e:	eb 06                	jmp    81ab26 <recv_tcp+0x114>
  } else {
    len = 0;
  81ab20:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  81ab26:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ab2a:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ab2e:	48 85 c0             	test   %rax,%rax
  81ab31:	74 1a                	je     81ab4d <recv_tcp+0x13b>
  81ab33:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ab37:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ab3b:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81ab3f:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81ab43:	be 00 00 00 00       	mov    $0x0,%esi
  81ab48:	48 89 cf             	mov    %rcx,%rdi
  81ab4b:	ff d0                	callq  *%rax
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  81ab4d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81ab51:	8b 40 18             	mov    0x18(%rax),%eax
  81ab54:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81ab58:	48 89 d6             	mov    %rdx,%rsi
  81ab5b:	89 c7                	mov    %eax,%edi
  81ab5d:	48 b8 e6 7c 81 00 00 	movabs $0x817ce6,%rax
  81ab64:	00 00 00 
  81ab67:	ff d0                	callq  *%rax
  81ab69:	84 c0                	test   %al,%al
  81ab6b:	74 07                	je     81ab74 <recv_tcp+0x162>
    return ERR_MEM;
  81ab6d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81ab72:	eb 05                	jmp    81ab79 <recv_tcp+0x167>
  }

  return ERR_OK;
  81ab74:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81ab79:	c9                   	leaveq 
  81ab7a:	c3                   	retq   

000000000081ab7b <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  81ab7b:	55                   	push   %rbp
  81ab7c:	48 89 e5             	mov    %rsp,%rbp
  81ab7f:	48 83 ec 20          	sub    $0x20,%rsp
  81ab83:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81ab87:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct netconn *conn = arg;
  81ab8b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ab8f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81ab93:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81ab98:	75 2a                	jne    81abc4 <poll_tcp+0x49>
  81ab9a:	48 ba 95 3a 82 00 00 	movabs $0x823a95,%rdx
  81aba1:	00 00 00 
  81aba4:	be ec 00 00 00       	mov    $0xec,%esi
  81aba9:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81abb0:	00 00 00 
  81abb3:	b8 00 00 00 00       	mov    $0x0,%eax
  81abb8:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81abbf:	00 00 00 
  81abc2:	ff d1                	callq  *%rcx

  if (conn->state == NETCONN_WRITE) {
  81abc4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abc8:	8b 40 04             	mov    0x4(%rax),%eax
  81abcb:	83 f8 01             	cmp    $0x1,%eax
  81abce:	75 15                	jne    81abe5 <poll_tcp+0x6a>
    do_writemore(conn);
  81abd0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abd4:	48 89 c7             	mov    %rax,%rdi
  81abd7:	48 b8 bf c0 81 00 00 	movabs $0x81c0bf,%rax
  81abde:	00 00 00 
  81abe1:	ff d0                	callq  *%rax
  81abe3:	eb 1f                	jmp    81ac04 <poll_tcp+0x89>
  } else if (conn->state == NETCONN_CLOSE) {
  81abe5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abe9:	8b 40 04             	mov    0x4(%rax),%eax
  81abec:	83 f8 04             	cmp    $0x4,%eax
  81abef:	75 13                	jne    81ac04 <poll_tcp+0x89>
    do_close_internal(conn);
  81abf1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abf5:	48 89 c7             	mov    %rax,%rdi
  81abf8:	48 b8 31 b5 81 00 00 	movabs $0x81b531,%rax
  81abff:	00 00 00 
  81ac02:	ff d0                	callq  *%rax
  }

  return ERR_OK;
  81ac04:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81ac09:	c9                   	leaveq 
  81ac0a:	c3                   	retq   

000000000081ac0b <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  81ac0b:	55                   	push   %rbp
  81ac0c:	48 89 e5             	mov    %rsp,%rbp
  81ac0f:	48 83 ec 30          	sub    $0x30,%rsp
  81ac13:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81ac17:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81ac1b:	89 d0                	mov    %edx,%eax
  81ac1d:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct netconn *conn = arg;
  81ac21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac25:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81ac29:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81ac2e:	75 2a                	jne    81ac5a <sent_tcp+0x4f>
  81ac30:	48 ba 95 3a 82 00 00 	movabs $0x823a95,%rdx
  81ac37:	00 00 00 
  81ac3a:	be 04 01 00 00       	mov    $0x104,%esi
  81ac3f:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81ac46:	00 00 00 
  81ac49:	b8 00 00 00 00       	mov    $0x0,%eax
  81ac4e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81ac55:	00 00 00 
  81ac58:	ff d1                	callq  *%rcx

  if (conn->state == NETCONN_WRITE) {
  81ac5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac5e:	8b 40 04             	mov    0x4(%rax),%eax
  81ac61:	83 f8 01             	cmp    $0x1,%eax
  81ac64:	75 4c                	jne    81acb2 <sent_tcp+0xa7>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  81ac66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac6a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ac6e:	48 85 c0             	test   %rax,%rax
  81ac71:	75 2a                	jne    81ac9d <sent_tcp+0x92>
  81ac73:	48 ba a2 3a 82 00 00 	movabs $0x823aa2,%rdx
  81ac7a:	00 00 00 
  81ac7d:	be 07 01 00 00       	mov    $0x107,%esi
  81ac82:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81ac89:	00 00 00 
  81ac8c:	b8 00 00 00 00       	mov    $0x0,%eax
  81ac91:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81ac98:	00 00 00 
  81ac9b:	ff d1                	callq  *%rcx
    do_writemore(conn);
  81ac9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aca1:	48 89 c7             	mov    %rax,%rdi
  81aca4:	48 b8 bf c0 81 00 00 	movabs $0x81c0bf,%rax
  81acab:	00 00 00 
  81acae:	ff d0                	callq  *%rax
  81acb0:	eb 1f                	jmp    81acd1 <sent_tcp+0xc6>
  } else if (conn->state == NETCONN_CLOSE) {
  81acb2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81acb6:	8b 40 04             	mov    0x4(%rax),%eax
  81acb9:	83 f8 04             	cmp    $0x4,%eax
  81acbc:	75 13                	jne    81acd1 <sent_tcp+0xc6>
    do_close_internal(conn);
  81acbe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81acc2:	48 89 c7             	mov    %rax,%rdi
  81acc5:	48 b8 31 b5 81 00 00 	movabs $0x81b531,%rax
  81accc:	00 00 00 
  81accf:	ff d0                	callq  *%rax
  }

  if (conn) {
  81acd1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81acd6:	74 46                	je     81ad1e <sent_tcp+0x113>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  81acd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81acdc:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ace0:	48 85 c0             	test   %rax,%rax
  81ace3:	74 39                	je     81ad1e <sent_tcp+0x113>
  81ace5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ace9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aced:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81acf1:	66 3d a0 2d          	cmp    $0x2da0,%ax
  81acf5:	76 27                	jbe    81ad1e <sent_tcp+0x113>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  81acf7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81acfb:	48 8b 40 38          	mov    0x38(%rax),%rax
  81acff:	48 85 c0             	test   %rax,%rax
  81ad02:	74 1a                	je     81ad1e <sent_tcp+0x113>
  81ad04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad08:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ad0c:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  81ad10:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81ad14:	be 02 00 00 00       	mov    $0x2,%esi
  81ad19:	48 89 cf             	mov    %rcx,%rdi
  81ad1c:	ff d0                	callq  *%rax
    }
  }
  
  return ERR_OK;
  81ad1e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81ad23:	c9                   	leaveq 
  81ad24:	c3                   	retq   

000000000081ad25 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  81ad25:	55                   	push   %rbp
  81ad26:	48 89 e5             	mov    %rsp,%rbp
  81ad29:	48 83 ec 20          	sub    $0x20,%rsp
  81ad2d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81ad31:	89 f0                	mov    %esi,%eax
  81ad33:	88 45 e4             	mov    %al,-0x1c(%rbp)
  struct netconn *conn;

  conn = arg;
  81ad36:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ad3a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81ad3e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81ad43:	75 2a                	jne    81ad6f <err_tcp+0x4a>
  81ad45:	48 ba 95 3a 82 00 00 	movabs $0x823a95,%rdx
  81ad4c:	00 00 00 
  81ad4f:	be 23 01 00 00       	mov    $0x123,%esi
  81ad54:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81ad5b:	00 00 00 
  81ad5e:	b8 00 00 00 00       	mov    $0x0,%eax
  81ad63:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81ad6a:	00 00 00 
  81ad6d:	ff d1                	callq  *%rcx

  conn->pcb.tcp = NULL;
  81ad6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad73:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81ad7a:	00 

  conn->err = err;
  81ad7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad7f:	0f b6 55 e4          	movzbl -0x1c(%rbp),%edx
  81ad83:	88 50 10             	mov    %dl,0x10(%rax)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  81ad86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad8a:	8b 40 18             	mov    0x18(%rax),%eax
  81ad8d:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ad90:	74 42                	je     81add4 <err_tcp+0xaf>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81ad92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad96:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ad9a:	48 85 c0             	test   %rax,%rax
  81ad9d:	74 1b                	je     81adba <err_tcp+0x95>
  81ad9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ada3:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ada7:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81adab:	ba 00 00 00 00       	mov    $0x0,%edx
  81adb0:	be 00 00 00 00       	mov    $0x0,%esi
  81adb5:	48 89 cf             	mov    %rcx,%rdi
  81adb8:	ff d0                	callq  *%rax
    sys_mbox_post(conn->recvmbox, NULL);
  81adba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81adbe:	8b 40 18             	mov    0x18(%rax),%eax
  81adc1:	be 00 00 00 00       	mov    $0x0,%esi
  81adc6:	89 c7                	mov    %eax,%edi
  81adc8:	48 b8 83 7c 81 00 00 	movabs $0x817c83,%rax
  81adcf:	00 00 00 
  81add2:	ff d0                	callq  *%rax
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  81add4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81add8:	8b 40 14             	mov    0x14(%rax),%eax
  81addb:	83 f8 ff             	cmp    $0xffffffff,%eax
  81adde:	74 2c                	je     81ae0c <err_tcp+0xe7>
  81ade0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ade4:	8b 40 04             	mov    0x4(%rax),%eax
  81ade7:	83 f8 03             	cmp    $0x3,%eax
  81adea:	75 20                	jne    81ae0c <err_tcp+0xe7>
    conn->state = NETCONN_NONE;
  81adec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81adf0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    sys_sem_signal(conn->op_completed);
  81adf7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81adfb:	8b 40 14             	mov    0x14(%rax),%eax
  81adfe:	89 c7                	mov    %eax,%edi
  81ae00:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  81ae07:	00 00 00 
  81ae0a:	ff d0                	callq  *%rax
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  81ae0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae10:	8b 40 1c             	mov    0x1c(%rax),%eax
  81ae13:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ae16:	74 42                	je     81ae5a <err_tcp+0x135>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81ae18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae1c:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ae20:	48 85 c0             	test   %rax,%rax
  81ae23:	74 1b                	je     81ae40 <err_tcp+0x11b>
  81ae25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae29:	48 8b 40 38          	mov    0x38(%rax),%rax
  81ae2d:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81ae31:	ba 00 00 00 00       	mov    $0x0,%edx
  81ae36:	be 00 00 00 00       	mov    $0x0,%esi
  81ae3b:	48 89 cf             	mov    %rcx,%rdi
  81ae3e:	ff d0                	callq  *%rax
    sys_mbox_post(conn->acceptmbox, NULL);
  81ae40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae44:	8b 40 1c             	mov    0x1c(%rax),%eax
  81ae47:	be 00 00 00 00       	mov    $0x0,%esi
  81ae4c:	89 c7                	mov    %eax,%edi
  81ae4e:	48 b8 83 7c 81 00 00 	movabs $0x817c83,%rax
  81ae55:	00 00 00 
  81ae58:	ff d0                	callq  *%rax
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  81ae5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae5e:	8b 40 04             	mov    0x4(%rax),%eax
  81ae61:	83 f8 01             	cmp    $0x1,%eax
  81ae64:	74 0c                	je     81ae72 <err_tcp+0x14d>
  81ae66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae6a:	8b 40 04             	mov    0x4(%rax),%eax
  81ae6d:	83 f8 04             	cmp    $0x4,%eax
  81ae70:	75 20                	jne    81ae92 <err_tcp+0x16d>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  81ae72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae76:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  81ae7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae81:	8b 40 14             	mov    0x14(%rax),%eax
  81ae84:	89 c7                	mov    %eax,%edi
  81ae86:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  81ae8d:	00 00 00 
  81ae90:	ff d0                	callq  *%rax
  }
}
  81ae92:	90                   	nop
  81ae93:	c9                   	leaveq 
  81ae94:	c3                   	retq   

000000000081ae95 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  81ae95:	55                   	push   %rbp
  81ae96:	48 89 e5             	mov    %rsp,%rbp
  81ae99:	48 83 ec 20          	sub    $0x20,%rsp
  81ae9d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  81aea1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aea5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aea9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  tcp_arg(pcb, conn);
  81aead:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81aeb1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aeb5:	48 89 d6             	mov    %rdx,%rsi
  81aeb8:	48 89 c7             	mov    %rax,%rdi
  81aebb:	48 b8 79 09 81 00 00 	movabs $0x810979,%rax
  81aec2:	00 00 00 
  81aec5:	ff d0                	callq  *%rax
  tcp_recv(pcb, recv_tcp);
  81aec7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aecb:	48 be 12 aa 81 00 00 	movabs $0x81aa12,%rsi
  81aed2:	00 00 00 
  81aed5:	48 89 c7             	mov    %rax,%rdi
  81aed8:	48 b8 98 09 81 00 00 	movabs $0x810998,%rax
  81aedf:	00 00 00 
  81aee2:	ff d0                	callq  *%rax
  tcp_sent(pcb, sent_tcp);
  81aee4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aee8:	48 be 0b ac 81 00 00 	movabs $0x81ac0b,%rsi
  81aeef:	00 00 00 
  81aef2:	48 89 c7             	mov    %rax,%rdi
  81aef5:	48 b8 ba 09 81 00 00 	movabs $0x8109ba,%rax
  81aefc:	00 00 00 
  81aeff:	ff d0                	callq  *%rax
  tcp_poll(pcb, poll_tcp, 4);
  81af01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81af05:	ba 04 00 00 00       	mov    $0x4,%edx
  81af0a:	48 be 7b ab 81 00 00 	movabs $0x81ab7b,%rsi
  81af11:	00 00 00 
  81af14:	48 89 c7             	mov    %rax,%rdi
  81af17:	48 b8 1d 0a 81 00 00 	movabs $0x810a1d,%rax
  81af1e:	00 00 00 
  81af21:	ff d0                	callq  *%rax
  tcp_err(pcb, err_tcp);
  81af23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81af27:	48 be 25 ad 81 00 00 	movabs $0x81ad25,%rsi
  81af2e:	00 00 00 
  81af31:	48 89 c7             	mov    %rax,%rdi
  81af34:	48 b8 dc 09 81 00 00 	movabs $0x8109dc,%rax
  81af3b:	00 00 00 
  81af3e:	ff d0                	callq  *%rax
}
  81af40:	90                   	nop
  81af41:	c9                   	leaveq 
  81af42:	c3                   	retq   

000000000081af43 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  81af43:	55                   	push   %rbp
  81af44:	48 89 e5             	mov    %rsp,%rbp
  81af47:	48 83 ec 30          	sub    $0x30,%rsp
  81af4b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81af4f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81af53:	89 d0                	mov    %edx,%eax
  81af55:	88 45 dc             	mov    %al,-0x24(%rbp)
#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
  81af58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af5c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  81af60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81af64:	8b 40 1c             	mov    0x1c(%rax),%eax
  81af67:	83 f8 ff             	cmp    $0xffffffff,%eax
  81af6a:	75 2a                	jne    81af96 <accept_function+0x53>
  81af6c:	48 ba b8 3a 82 00 00 	movabs $0x823ab8,%rdx
  81af73:	00 00 00 
  81af76:	be 66 01 00 00       	mov    $0x166,%esi
  81af7b:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81af82:	00 00 00 
  81af85:	b8 00 00 00 00       	mov    $0x0,%eax
  81af8a:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81af91:	00 00 00 
  81af94:	ff d1                	callq  *%rcx
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  81af96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81af9a:	48 8b 50 38          	mov    0x38(%rax),%rdx
  81af9e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81afa2:	8b 00                	mov    (%rax),%eax
  81afa4:	48 89 d6             	mov    %rdx,%rsi
  81afa7:	89 c7                	mov    %eax,%edi
  81afa9:	48 b8 8e b2 81 00 00 	movabs $0x81b28e,%rax
  81afb0:	00 00 00 
  81afb3:	ff d0                	callq  *%rax
  81afb5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (newconn == NULL) {
  81afb9:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81afbe:	75 0a                	jne    81afca <accept_function+0x87>
    return ERR_MEM;
  81afc0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81afc5:	e9 9d 00 00 00       	jmpq   81b067 <accept_function+0x124>
  }
  newconn->pcb.tcp = newpcb;
  81afca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81afce:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81afd2:	48 89 50 08          	mov    %rdx,0x8(%rax)
  setup_tcp(newconn);
  81afd6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81afda:	48 89 c7             	mov    %rax,%rdi
  81afdd:	48 b8 95 ae 81 00 00 	movabs $0x81ae95,%rax
  81afe4:	00 00 00 
  81afe7:	ff d0                	callq  *%rax
  newconn->err = err;
  81afe9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81afed:	0f b6 55 dc          	movzbl -0x24(%rbp),%edx
  81aff1:	88 50 10             	mov    %dl,0x10(%rax)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81aff4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aff8:	48 8b 40 38          	mov    0x38(%rax),%rax
  81affc:	48 85 c0             	test   %rax,%rax
  81afff:	74 1b                	je     81b01c <accept_function+0xd9>
  81b001:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b005:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b009:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  81b00d:	ba 00 00 00 00       	mov    $0x0,%edx
  81b012:	be 00 00 00 00       	mov    $0x0,%esi
  81b017:	48 89 cf             	mov    %rcx,%rdi
  81b01a:	ff d0                	callq  *%rax

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  81b01c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b020:	8b 40 1c             	mov    0x1c(%rax),%eax
  81b023:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81b027:	48 89 d6             	mov    %rdx,%rsi
  81b02a:	89 c7                	mov    %eax,%edi
  81b02c:	48 b8 e6 7c 81 00 00 	movabs $0x817ce6,%rax
  81b033:	00 00 00 
  81b036:	ff d0                	callq  *%rax
  81b038:	84 c0                	test   %al,%al
  81b03a:	74 26                	je     81b062 <accept_function+0x11f>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  81b03c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81b040:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81b047:	00 
    netconn_free(newconn);
  81b048:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81b04c:	48 89 c7             	mov    %rax,%rdi
  81b04f:	48 b8 c6 b3 81 00 00 	movabs $0x81b3c6,%rax
  81b056:	00 00 00 
  81b059:	ff d0                	callq  *%rax
    return ERR_MEM;
  81b05b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81b060:	eb 05                	jmp    81b067 <accept_function+0x124>
  }
  return ERR_OK;
  81b062:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81b067:	c9                   	leaveq 
  81b068:	c3                   	retq   

000000000081b069 <pcb_new>:
 * @param msg the api_msg_msg describing the connection type
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
  81b069:	55                   	push   %rbp
  81b06a:	48 89 e5             	mov    %rsp,%rbp
  81b06d:	53                   	push   %rbx
  81b06e:	48 83 ec 18          	sub    $0x18,%rsp
  81b072:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   msg->conn->err = ERR_OK;
  81b076:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b07a:	48 8b 00             	mov    (%rax),%rax
  81b07d:	c6 40 10 00          	movb   $0x0,0x10(%rax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  81b081:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b085:	48 8b 00             	mov    (%rax),%rax
  81b088:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b08c:	48 85 c0             	test   %rax,%rax
  81b08f:	74 2a                	je     81b0bb <pcb_new+0x52>
  81b091:	48 ba e8 3a 82 00 00 	movabs $0x823ae8,%rdx
  81b098:	00 00 00 
  81b09b:	be 8b 01 00 00       	mov    $0x18b,%esi
  81b0a0:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81b0a7:	00 00 00 
  81b0aa:	b8 00 00 00 00       	mov    $0x0,%eax
  81b0af:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81b0b6:	00 00 00 
  81b0b9:	ff d1                	callq  *%rcx

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  81b0bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b0bf:	48 8b 00             	mov    (%rax),%rax
  81b0c2:	8b 00                	mov    (%rax),%eax
  81b0c4:	25 f0 00 00 00       	and    $0xf0,%eax
  81b0c9:	83 f8 20             	cmp    $0x20,%eax
  81b0cc:	0f 84 87 00 00 00    	je     81b159 <pcb_new+0xf0>
  81b0d2:	83 f8 40             	cmp    $0x40,%eax
  81b0d5:	74 0e                	je     81b0e5 <pcb_new+0x7c>
  81b0d7:	83 f8 10             	cmp    $0x10,%eax
  81b0da:	0f 84 fa 00 00 00    	je     81b1da <pcb_new+0x171>
  81b0e0:	e9 41 01 00 00       	jmpq   81b226 <pcb_new+0x1bd>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  81b0e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b0e9:	48 8b 18             	mov    (%rax),%rbx
  81b0ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b0f0:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  81b0f4:	0f b6 c0             	movzbl %al,%eax
  81b0f7:	89 c7                	mov    %eax,%edi
  81b0f9:	48 b8 a1 03 82 00 00 	movabs $0x8203a1,%rax
  81b100:	00 00 00 
  81b103:	ff d0                	callq  *%rax
  81b105:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.raw == NULL) {
  81b109:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b10d:	48 8b 00             	mov    (%rax),%rax
  81b110:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b114:	48 85 c0             	test   %rax,%rax
  81b117:	75 10                	jne    81b129 <pcb_new+0xc0>
       msg->conn->err = ERR_MEM;
  81b119:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b11d:	48 8b 00             	mov    (%rax),%rax
  81b120:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81b124:	e9 09 01 00 00       	jmpq   81b232 <pcb_new+0x1c9>
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  81b129:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b12d:	48 8b 10             	mov    (%rax),%rdx
  81b130:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b134:	48 8b 00             	mov    (%rax),%rax
  81b137:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b13b:	48 be 9f a6 81 00 00 	movabs $0x81a69f,%rsi
  81b142:	00 00 00 
  81b145:	48 89 c7             	mov    %rax,%rdi
  81b148:	48 b8 e7 00 82 00 00 	movabs $0x8200e7,%rax
  81b14f:	00 00 00 
  81b152:	ff d0                	callq  *%rax
     break;
  81b154:	e9 d9 00 00 00       	jmpq   81b232 <pcb_new+0x1c9>
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  81b159:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b15d:	48 8b 18             	mov    (%rax),%rbx
  81b160:	48 b8 d0 5a 81 00 00 	movabs $0x815ad0,%rax
  81b167:	00 00 00 
  81b16a:	ff d0                	callq  *%rax
  81b16c:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.udp == NULL) {
  81b170:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b174:	48 8b 00             	mov    (%rax),%rax
  81b177:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b17b:	48 85 c0             	test   %rax,%rax
  81b17e:	75 10                	jne    81b190 <pcb_new+0x127>
       msg->conn->err = ERR_MEM;
  81b180:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b184:	48 8b 00             	mov    (%rax),%rax
  81b187:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81b18b:	e9 a2 00 00 00       	jmpq   81b232 <pcb_new+0x1c9>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  81b190:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b194:	48 8b 00             	mov    (%rax),%rax
  81b197:	8b 00                	mov    (%rax),%eax
  81b199:	83 f8 22             	cmp    $0x22,%eax
  81b19c:	75 0f                	jne    81b1ad <pcb_new+0x144>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  81b19e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1a2:	48 8b 00             	mov    (%rax),%rax
  81b1a5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b1a9:	c6 40 18 01          	movb   $0x1,0x18(%rax)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  81b1ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1b1:	48 8b 10             	mov    (%rax),%rdx
  81b1b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1b8:	48 8b 00             	mov    (%rax),%rax
  81b1bb:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b1bf:	48 be 45 a8 81 00 00 	movabs $0x81a845,%rsi
  81b1c6:	00 00 00 
  81b1c9:	48 89 c7             	mov    %rax,%rdi
  81b1cc:	48 b8 f6 59 81 00 00 	movabs $0x8159f6,%rax
  81b1d3:	00 00 00 
  81b1d6:	ff d0                	callq  *%rax
     break;
  81b1d8:	eb 58                	jmp    81b232 <pcb_new+0x1c9>
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  81b1da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1de:	48 8b 18             	mov    (%rax),%rbx
  81b1e1:	48 b8 62 09 81 00 00 	movabs $0x810962,%rax
  81b1e8:	00 00 00 
  81b1eb:	ff d0                	callq  *%rax
  81b1ed:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.tcp == NULL) {
  81b1f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1f5:	48 8b 00             	mov    (%rax),%rax
  81b1f8:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b1fc:	48 85 c0             	test   %rax,%rax
  81b1ff:	75 0d                	jne    81b20e <pcb_new+0x1a5>
       msg->conn->err = ERR_MEM;
  81b201:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b205:	48 8b 00             	mov    (%rax),%rax
  81b208:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81b20c:	eb 24                	jmp    81b232 <pcb_new+0x1c9>
     }
     setup_tcp(msg->conn);
  81b20e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b212:	48 8b 00             	mov    (%rax),%rax
  81b215:	48 89 c7             	mov    %rax,%rdi
  81b218:	48 b8 95 ae 81 00 00 	movabs $0x81ae95,%rax
  81b21f:	00 00 00 
  81b222:	ff d0                	callq  *%rax
     break;
  81b224:	eb 0c                	jmp    81b232 <pcb_new+0x1c9>
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  81b226:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b22a:	48 8b 00             	mov    (%rax),%rax
  81b22d:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
     break;
  81b231:	90                   	nop
   }

  return msg->conn->err;
  81b232:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b236:	48 8b 00             	mov    (%rax),%rax
  81b239:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81b23d:	48 83 c4 18          	add    $0x18,%rsp
  81b241:	5b                   	pop    %rbx
  81b242:	5d                   	pop    %rbp
  81b243:	c3                   	retq   

000000000081b244 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  81b244:	55                   	push   %rbp
  81b245:	48 89 e5             	mov    %rsp,%rbp
  81b248:	48 83 ec 10          	sub    $0x10,%rsp
  81b24c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   if(msg->conn->pcb.tcp == NULL) {
  81b250:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b254:	48 8b 00             	mov    (%rax),%rax
  81b257:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b25b:	48 85 c0             	test   %rax,%rax
  81b25e:	75 13                	jne    81b273 <do_newconn+0x2f>
     pcb_new(msg);
  81b260:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b264:	48 89 c7             	mov    %rax,%rdi
  81b267:	48 b8 69 b0 81 00 00 	movabs $0x81b069,%rax
  81b26e:	00 00 00 
  81b271:	ff d0                	callq  *%rax
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  81b273:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b277:	48 8b 00             	mov    (%rax),%rax
  81b27a:	8b 40 14             	mov    0x14(%rax),%eax
  81b27d:	89 c7                	mov    %eax,%edi
  81b27f:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  81b286:	00 00 00 
  81b289:	ff d0                	callq  *%rax
}
  81b28b:	90                   	nop
  81b28c:	c9                   	leaveq 
  81b28d:	c3                   	retq   

000000000081b28e <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  81b28e:	55                   	push   %rbp
  81b28f:	48 89 e5             	mov    %rsp,%rbp
  81b292:	48 83 ec 20          	sub    $0x20,%rsp
  81b296:	89 7d ec             	mov    %edi,-0x14(%rbp)
  81b299:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  81b29d:	bf 07 00 00 00       	mov    $0x7,%edi
  81b2a2:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  81b2a9:	00 00 00 
  81b2ac:	ff d0                	callq  *%rax
  81b2ae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (conn == NULL) {
  81b2b2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81b2b7:	75 0a                	jne    81b2c3 <netconn_alloc+0x35>
    return NULL;
  81b2b9:	b8 00 00 00 00       	mov    $0x0,%eax
  81b2be:	e9 01 01 00 00       	jmpq   81b3c4 <netconn_alloc+0x136>
  }

  conn->err = ERR_OK;
  81b2c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b2c7:	c6 40 10 00          	movb   $0x0,0x10(%rax)
  conn->type = t;
  81b2cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b2cf:	8b 55 ec             	mov    -0x14(%rbp),%edx
  81b2d2:	89 10                	mov    %edx,(%rax)
  conn->pcb.tcp = NULL;
  81b2d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b2d8:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81b2df:	00 

#if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
    (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
  size = DEFAULT_RAW_RECVMBOX_SIZE;
  81b2e0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  81b2e7:	bf 00 00 00 00       	mov    $0x0,%edi
  81b2ec:	48 b8 5c 7f 81 00 00 	movabs $0x817f5c,%rax
  81b2f3:	00 00 00 
  81b2f6:	ff d0                	callq  *%rax
  81b2f8:	89 c2                	mov    %eax,%edx
  81b2fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b2fe:	89 50 14             	mov    %edx,0x14(%rax)
  81b301:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b305:	8b 40 14             	mov    0x14(%rax),%eax
  81b308:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b30b:	75 22                	jne    81b32f <netconn_alloc+0xa1>
    memp_free(MEMP_NETCONN, conn);
  81b30d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b311:	48 89 c6             	mov    %rax,%rsi
  81b314:	bf 07 00 00 00       	mov    $0x7,%edi
  81b319:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  81b320:	00 00 00 
  81b323:	ff d0                	callq  *%rax
    return NULL;
  81b325:	b8 00 00 00 00       	mov    $0x0,%eax
  81b32a:	e9 95 00 00 00       	jmpq   81b3c4 <netconn_alloc+0x136>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  81b32f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81b332:	89 c7                	mov    %eax,%edi
  81b334:	48 b8 59 78 81 00 00 	movabs $0x817859,%rax
  81b33b:	00 00 00 
  81b33e:	ff d0                	callq  *%rax
  81b340:	89 c2                	mov    %eax,%edx
  81b342:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b346:	89 50 18             	mov    %edx,0x18(%rax)
  81b349:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b34d:	8b 40 18             	mov    0x18(%rax),%eax
  81b350:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b353:	75 34                	jne    81b389 <netconn_alloc+0xfb>
    sys_sem_free(conn->op_completed);
  81b355:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b359:	8b 40 14             	mov    0x14(%rax),%eax
  81b35c:	89 c7                	mov    %eax,%edi
  81b35e:	48 b8 5a 80 81 00 00 	movabs $0x81805a,%rax
  81b365:	00 00 00 
  81b368:	ff d0                	callq  *%rax
    memp_free(MEMP_NETCONN, conn);
  81b36a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b36e:	48 89 c6             	mov    %rax,%rsi
  81b371:	bf 07 00 00 00       	mov    $0x7,%edi
  81b376:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  81b37d:	00 00 00 
  81b380:	ff d0                	callq  *%rax
    return NULL;
  81b382:	b8 00 00 00 00       	mov    $0x0,%eax
  81b387:	eb 3b                	jmp    81b3c4 <netconn_alloc+0x136>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  81b389:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b38d:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%rax)
  conn->state        = NETCONN_NONE;
  81b394:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b398:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  81b39f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b3a3:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%rax)
  conn->callback     = callback;
  81b3aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b3ae:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81b3b2:	48 89 50 38          	mov    %rdx,0x38(%rax)
  conn->recv_avail   = 0;
  81b3b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b3ba:	66 c7 40 24 00 00    	movw   $0x0,0x24(%rax)
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
  81b3c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81b3c4:	c9                   	leaveq 
  81b3c5:	c3                   	retq   

000000000081b3c6 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  81b3c6:	55                   	push   %rbp
  81b3c7:	48 89 e5             	mov    %rsp,%rbp
  81b3ca:	48 83 ec 20          	sub    $0x20,%rsp
  81b3ce:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  81b3d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b3d6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b3da:	48 85 c0             	test   %rax,%rax
  81b3dd:	74 2a                	je     81b409 <netconn_free+0x43>
  81b3df:	48 ba 08 3b 82 00 00 	movabs $0x823b08,%rdx
  81b3e6:	00 00 00 
  81b3e9:	be 27 02 00 00       	mov    $0x227,%esi
  81b3ee:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81b3f5:	00 00 00 
  81b3f8:	b8 00 00 00 00       	mov    $0x0,%eax
  81b3fd:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81b404:	00 00 00 
  81b407:	ff d1                	callq  *%rcx

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  81b409:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b40d:	8b 40 18             	mov    0x18(%rax),%eax
  81b410:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b413:	74 7f                	je     81b494 <netconn_free+0xce>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  81b415:	eb 3c                	jmp    81b453 <netconn_free+0x8d>
      if (conn->type == NETCONN_TCP) {
  81b417:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b41b:	8b 00                	mov    (%rax),%eax
  81b41d:	83 f8 10             	cmp    $0x10,%eax
  81b420:	75 1e                	jne    81b440 <netconn_free+0x7a>
        if(mem != NULL) {
  81b422:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b426:	48 85 c0             	test   %rax,%rax
  81b429:	74 28                	je     81b453 <netconn_free+0x8d>
          pbuf_free((struct pbuf *)mem);
  81b42b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b42f:	48 89 c7             	mov    %rax,%rdi
  81b432:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81b439:	00 00 00 
  81b43c:	ff d0                	callq  *%rax
  81b43e:	eb 13                	jmp    81b453 <netconn_free+0x8d>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  81b440:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b444:	48 89 c7             	mov    %rax,%rdi
  81b447:	48 b8 d7 8e 80 00 00 	movabs $0x808ed7,%rax
  81b44e:	00 00 00 
  81b451:	ff d0                	callq  *%rax
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  81b453:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b457:	8b 40 18             	mov    0x18(%rax),%eax
  81b45a:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  81b45e:	48 89 d6             	mov    %rdx,%rsi
  81b461:	89 c7                	mov    %eax,%edi
  81b463:	48 b8 a7 87 81 00 00 	movabs $0x8187a7,%rax
  81b46a:	00 00 00 
  81b46d:	ff d0                	callq  *%rax
  81b46f:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b472:	75 a3                	jne    81b417 <netconn_free+0x51>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  81b474:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b478:	8b 40 18             	mov    0x18(%rax),%eax
  81b47b:	89 c7                	mov    %eax,%edi
  81b47d:	48 b8 3d 7a 81 00 00 	movabs $0x817a3d,%rax
  81b484:	00 00 00 
  81b487:	ff d0                	callq  *%rax
    conn->recvmbox = SYS_MBOX_NULL;
  81b489:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b48d:	c7 40 18 ff ff ff ff 	movl   $0xffffffff,0x18(%rax)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  81b494:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b498:	8b 40 1c             	mov    0x1c(%rax),%eax
  81b49b:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b49e:	74 56                	je     81b4f6 <netconn_free+0x130>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  81b4a0:	eb 13                	jmp    81b4b5 <netconn_free+0xef>
      netconn_delete((struct netconn *)mem);
  81b4a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b4a6:	48 89 c7             	mov    %rax,%rdi
  81b4a9:	48 b8 ac 9d 81 00 00 	movabs $0x819dac,%rax
  81b4b0:	00 00 00 
  81b4b3:	ff d0                	callq  *%rax
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  81b4b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4b9:	8b 40 1c             	mov    0x1c(%rax),%eax
  81b4bc:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  81b4c0:	48 89 d6             	mov    %rdx,%rsi
  81b4c3:	89 c7                	mov    %eax,%edi
  81b4c5:	48 b8 a7 87 81 00 00 	movabs $0x8187a7,%rax
  81b4cc:	00 00 00 
  81b4cf:	ff d0                	callq  *%rax
  81b4d1:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b4d4:	75 cc                	jne    81b4a2 <netconn_free+0xdc>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  81b4d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4da:	8b 40 1c             	mov    0x1c(%rax),%eax
  81b4dd:	89 c7                	mov    %eax,%edi
  81b4df:	48 b8 3d 7a 81 00 00 	movabs $0x817a3d,%rax
  81b4e6:	00 00 00 
  81b4e9:	ff d0                	callq  *%rax
    conn->acceptmbox = SYS_MBOX_NULL;
  81b4eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4ef:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%rax)
  }

  sys_sem_free(conn->op_completed);
  81b4f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4fa:	8b 40 14             	mov    0x14(%rax),%eax
  81b4fd:	89 c7                	mov    %eax,%edi
  81b4ff:	48 b8 5a 80 81 00 00 	movabs $0x81805a,%rax
  81b506:	00 00 00 
  81b509:	ff d0                	callq  *%rax
  conn->op_completed = SYS_SEM_NULL;
  81b50b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b50f:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%rax)

  memp_free(MEMP_NETCONN, conn);
  81b516:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b51a:	48 89 c6             	mov    %rax,%rsi
  81b51d:	bf 07 00 00 00       	mov    $0x7,%edi
  81b522:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  81b529:	00 00 00 
  81b52c:	ff d0                	callq  *%rax
}
  81b52e:	90                   	nop
  81b52f:	c9                   	leaveq 
  81b530:	c3                   	retq   

000000000081b531 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  81b531:	55                   	push   %rbp
  81b532:	48 89 e5             	mov    %rsp,%rbp
  81b535:	48 83 ec 20          	sub    $0x20,%rsp
  81b539:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  81b53d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81b542:	75 2a                	jne    81b56e <do_close_internal+0x3d>
  81b544:	48 ba 36 3b 82 00 00 	movabs $0x823b36,%rdx
  81b54b:	00 00 00 
  81b54e:	be 54 02 00 00       	mov    $0x254,%esi
  81b553:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81b55a:	00 00 00 
  81b55d:	b8 00 00 00 00       	mov    $0x0,%eax
  81b562:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81b569:	00 00 00 
  81b56c:	ff d1                	callq  *%rcx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  81b56e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b572:	8b 00                	mov    (%rax),%eax
  81b574:	83 f8 10             	cmp    $0x10,%eax
  81b577:	74 2a                	je     81b5a3 <do_close_internal+0x72>
  81b579:	48 ba 43 3b 82 00 00 	movabs $0x823b43,%rdx
  81b580:	00 00 00 
  81b583:	be 55 02 00 00       	mov    $0x255,%esi
  81b588:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81b58f:	00 00 00 
  81b592:	b8 00 00 00 00       	mov    $0x0,%eax
  81b597:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81b59e:	00 00 00 
  81b5a1:	ff d1                	callq  *%rcx
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  81b5a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b5a7:	8b 40 04             	mov    0x4(%rax),%eax
  81b5aa:	83 f8 04             	cmp    $0x4,%eax
  81b5ad:	74 2a                	je     81b5d9 <do_close_internal+0xa8>
  81b5af:	48 ba 68 3b 82 00 00 	movabs $0x823b68,%rdx
  81b5b6:	00 00 00 
  81b5b9:	be 56 02 00 00       	mov    $0x256,%esi
  81b5be:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81b5c5:	00 00 00 
  81b5c8:	b8 00 00 00 00       	mov    $0x0,%eax
  81b5cd:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81b5d4:	00 00 00 
  81b5d7:	ff d1                	callq  *%rcx
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  81b5d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b5dd:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b5e1:	48 85 c0             	test   %rax,%rax
  81b5e4:	75 2a                	jne    81b610 <do_close_internal+0xdf>
  81b5e6:	48 ba 8c 3b 82 00 00 	movabs $0x823b8c,%rdx
  81b5ed:	00 00 00 
  81b5f0:	be 57 02 00 00       	mov    $0x257,%esi
  81b5f5:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81b5fc:	00 00 00 
  81b5ff:	b8 00 00 00 00       	mov    $0x0,%eax
  81b604:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81b60b:	00 00 00 
  81b60e:	ff d1                	callq  *%rcx

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  81b610:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b614:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b618:	be 00 00 00 00       	mov    $0x0,%esi
  81b61d:	48 89 c7             	mov    %rax,%rdi
  81b620:	48 b8 79 09 81 00 00 	movabs $0x810979,%rax
  81b627:	00 00 00 
  81b62a:	ff d0                	callq  *%rax
  if (conn->pcb.tcp->state == LISTEN) {
  81b62c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b630:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b634:	8b 40 18             	mov    0x18(%rax),%eax
  81b637:	83 f8 01             	cmp    $0x1,%eax
  81b63a:	75 21                	jne    81b65d <do_close_internal+0x12c>
    tcp_accept(conn->pcb.tcp, NULL);
  81b63c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b640:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b644:	be 00 00 00 00       	mov    $0x0,%esi
  81b649:	48 89 c7             	mov    %rax,%rdi
  81b64c:	48 b8 fe 09 81 00 00 	movabs $0x8109fe,%rax
  81b653:	00 00 00 
  81b656:	ff d0                	callq  *%rax
  81b658:	e9 91 00 00 00       	jmpq   81b6ee <do_close_internal+0x1bd>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  81b65d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b661:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b665:	be 00 00 00 00       	mov    $0x0,%esi
  81b66a:	48 89 c7             	mov    %rax,%rdi
  81b66d:	48 b8 98 09 81 00 00 	movabs $0x810998,%rax
  81b674:	00 00 00 
  81b677:	ff d0                	callq  *%rax
    tcp_accept(conn->pcb.tcp, NULL);
  81b679:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b67d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b681:	be 00 00 00 00       	mov    $0x0,%esi
  81b686:	48 89 c7             	mov    %rax,%rdi
  81b689:	48 b8 fe 09 81 00 00 	movabs $0x8109fe,%rax
  81b690:	00 00 00 
  81b693:	ff d0                	callq  *%rax
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  81b695:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b699:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b69d:	be 00 00 00 00       	mov    $0x0,%esi
  81b6a2:	48 89 c7             	mov    %rax,%rdi
  81b6a5:	48 b8 ba 09 81 00 00 	movabs $0x8109ba,%rax
  81b6ac:	00 00 00 
  81b6af:	ff d0                	callq  *%rax
    tcp_poll(conn->pcb.tcp, NULL, 4);
  81b6b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6b5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b6b9:	ba 04 00 00 00       	mov    $0x4,%edx
  81b6be:	be 00 00 00 00       	mov    $0x0,%esi
  81b6c3:	48 89 c7             	mov    %rax,%rdi
  81b6c6:	48 b8 1d 0a 81 00 00 	movabs $0x810a1d,%rax
  81b6cd:	00 00 00 
  81b6d0:	ff d0                	callq  *%rax
    tcp_err(conn->pcb.tcp, NULL);
  81b6d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6d6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b6da:	be 00 00 00 00       	mov    $0x0,%esi
  81b6df:	48 89 c7             	mov    %rax,%rdi
  81b6e2:	48 b8 dc 09 81 00 00 	movabs $0x8109dc,%rax
  81b6e9:	00 00 00 
  81b6ec:	ff d0                	callq  *%rax
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  81b6ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6f2:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b6f6:	48 89 c7             	mov    %rax,%rdi
  81b6f9:	48 b8 0f ed 80 00 00 	movabs $0x80ed0f,%rax
  81b700:	00 00 00 
  81b703:	ff d0                	callq  *%rax
  81b705:	88 45 ff             	mov    %al,-0x1(%rbp)
  if (err == ERR_OK) {
  81b708:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  81b70c:	0f 85 89 00 00 00    	jne    81b79b <do_close_internal+0x26a>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  81b712:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b716:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  81b71d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b721:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81b728:	00 
    conn->err = ERR_OK;
  81b729:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b72d:	c6 40 10 00          	movb   $0x0,0x10(%rax)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81b731:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b735:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b739:	48 85 c0             	test   %rax,%rax
  81b73c:	74 1b                	je     81b759 <do_close_internal+0x228>
  81b73e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b742:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b746:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81b74a:	ba 00 00 00 00       	mov    $0x0,%edx
  81b74f:	be 00 00 00 00       	mov    $0x0,%esi
  81b754:	48 89 cf             	mov    %rcx,%rdi
  81b757:	ff d0                	callq  *%rax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  81b759:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b75d:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b761:	48 85 c0             	test   %rax,%rax
  81b764:	74 1b                	je     81b781 <do_close_internal+0x250>
  81b766:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b76a:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b76e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81b772:	ba 00 00 00 00       	mov    $0x0,%edx
  81b777:	be 02 00 00 00       	mov    $0x2,%esi
  81b77c:	48 89 cf             	mov    %rcx,%rdi
  81b77f:	ff d0                	callq  *%rax
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  81b781:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b785:	8b 40 14             	mov    0x14(%rax),%eax
  81b788:	89 c7                	mov    %eax,%edi
  81b78a:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  81b791:	00 00 00 
  81b794:	ff d0                	callq  *%rax
    tcp_err(conn->pcb.tcp, err_tcp);
    tcp_arg(conn->pcb.tcp, conn);
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  81b796:	e9 c0 00 00 00       	jmpq   81b85b <do_close_internal+0x32a>
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  81b79b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b79f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b7a3:	8b 40 18             	mov    0x18(%rax),%eax
  81b7a6:	83 f8 01             	cmp    $0x1,%eax
  81b7a9:	75 2a                	jne    81b7d5 <do_close_internal+0x2a4>
  81b7ab:	48 ba a0 3b 82 00 00 	movabs $0x823ba0,%rdx
  81b7b2:	00 00 00 
  81b7b5:	be 76 02 00 00       	mov    $0x276,%esi
  81b7ba:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81b7c1:	00 00 00 
  81b7c4:	b8 00 00 00 00       	mov    $0x0,%eax
  81b7c9:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81b7d0:	00 00 00 
  81b7d3:	ff d1                	callq  *%rcx
    tcp_sent(conn->pcb.tcp, sent_tcp);
  81b7d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b7d9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b7dd:	48 be 0b ac 81 00 00 	movabs $0x81ac0b,%rsi
  81b7e4:	00 00 00 
  81b7e7:	48 89 c7             	mov    %rax,%rdi
  81b7ea:	48 b8 ba 09 81 00 00 	movabs $0x8109ba,%rax
  81b7f1:	00 00 00 
  81b7f4:	ff d0                	callq  *%rax
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  81b7f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b7fa:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b7fe:	ba 04 00 00 00       	mov    $0x4,%edx
  81b803:	48 be 7b ab 81 00 00 	movabs $0x81ab7b,%rsi
  81b80a:	00 00 00 
  81b80d:	48 89 c7             	mov    %rax,%rdi
  81b810:	48 b8 1d 0a 81 00 00 	movabs $0x810a1d,%rax
  81b817:	00 00 00 
  81b81a:	ff d0                	callq  *%rax
    tcp_err(conn->pcb.tcp, err_tcp);
  81b81c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b820:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b824:	48 be 25 ad 81 00 00 	movabs $0x81ad25,%rsi
  81b82b:	00 00 00 
  81b82e:	48 89 c7             	mov    %rax,%rdi
  81b831:	48 b8 dc 09 81 00 00 	movabs $0x8109dc,%rax
  81b838:	00 00 00 
  81b83b:	ff d0                	callq  *%rax
    tcp_arg(conn->pcb.tcp, conn);
  81b83d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b841:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b845:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81b849:	48 89 d6             	mov    %rdx,%rsi
  81b84c:	48 89 c7             	mov    %rax,%rdi
  81b84f:	48 b8 79 09 81 00 00 	movabs $0x810979,%rax
  81b856:	00 00 00 
  81b859:	ff d0                	callq  *%rax
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  81b85b:	90                   	nop
  81b85c:	c9                   	leaveq 
  81b85d:	c3                   	retq   

000000000081b85e <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  81b85e:	55                   	push   %rbp
  81b85f:	48 89 e5             	mov    %rsp,%rbp
  81b862:	48 83 ec 10          	sub    $0x10,%rsp
  81b866:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (msg->conn->pcb.tcp != NULL) {
  81b86a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b86e:	48 8b 00             	mov    (%rax),%rax
  81b871:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b875:	48 85 c0             	test   %rax,%rax
  81b878:	0f 84 93 00 00 00    	je     81b911 <do_delconn+0xb3>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b87e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b882:	48 8b 00             	mov    (%rax),%rax
  81b885:	8b 00                	mov    (%rax),%eax
  81b887:	25 f0 00 00 00       	and    $0xf0,%eax
  81b88c:	83 f8 20             	cmp    $0x20,%eax
  81b88f:	74 28                	je     81b8b9 <do_delconn+0x5b>
  81b891:	83 f8 40             	cmp    $0x40,%eax
  81b894:	74 07                	je     81b89d <do_delconn+0x3f>
  81b896:	83 f8 10             	cmp    $0x10,%eax
  81b899:	74 4d                	je     81b8e8 <do_delconn+0x8a>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
#endif /* LWIP_TCP */
    default:
      break;
  81b89b:	eb 74                	jmp    81b911 <do_delconn+0xb3>
{
  if (msg->conn->pcb.tcp != NULL) {
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  81b89d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b8a1:	48 8b 00             	mov    (%rax),%rax
  81b8a4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b8a8:	48 89 c7             	mov    %rax,%rdi
  81b8ab:	48 b8 f6 02 82 00 00 	movabs $0x8202f6,%rax
  81b8b2:	00 00 00 
  81b8b5:	ff d0                	callq  *%rax
      break;
  81b8b7:	eb 58                	jmp    81b911 <do_delconn+0xb3>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  81b8b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b8bd:	48 8b 00             	mov    (%rax),%rax
  81b8c0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b8c4:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  81b8cb:	00 
      udp_remove(msg->conn->pcb.udp);
  81b8cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b8d0:	48 8b 00             	mov    (%rax),%rax
  81b8d3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b8d7:	48 89 c7             	mov    %rax,%rdi
  81b8da:	48 b8 25 5a 81 00 00 	movabs $0x815a25,%rax
  81b8e1:	00 00 00 
  81b8e4:	ff d0                	callq  *%rax
      break;
  81b8e6:	eb 29                	jmp    81b911 <do_delconn+0xb3>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  81b8e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b8ec:	48 8b 00             	mov    (%rax),%rax
  81b8ef:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%rax)
      do_close_internal(msg->conn);
  81b8f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b8fa:	48 8b 00             	mov    (%rax),%rax
  81b8fd:	48 89 c7             	mov    %rax,%rdi
  81b900:	48 b8 31 b5 81 00 00 	movabs $0x81b531,%rax
  81b907:	00 00 00 
  81b90a:	ff d0                	callq  *%rax
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  81b90c:	e9 89 00 00 00       	jmpq   81b99a <do_delconn+0x13c>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  81b911:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b915:	48 8b 00             	mov    (%rax),%rax
  81b918:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b91c:	48 85 c0             	test   %rax,%rax
  81b91f:	74 21                	je     81b942 <do_delconn+0xe4>
  81b921:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b925:	48 8b 00             	mov    (%rax),%rax
  81b928:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b92c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b930:	48 8b 0a             	mov    (%rdx),%rcx
  81b933:	ba 00 00 00 00       	mov    $0x0,%edx
  81b938:	be 00 00 00 00       	mov    $0x0,%esi
  81b93d:	48 89 cf             	mov    %rcx,%rdi
  81b940:	ff d0                	callq  *%rax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  81b942:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b946:	48 8b 00             	mov    (%rax),%rax
  81b949:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b94d:	48 85 c0             	test   %rax,%rax
  81b950:	74 21                	je     81b973 <do_delconn+0x115>
  81b952:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b956:	48 8b 00             	mov    (%rax),%rax
  81b959:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b95d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81b961:	48 8b 0a             	mov    (%rdx),%rcx
  81b964:	ba 00 00 00 00       	mov    $0x0,%edx
  81b969:	be 02 00 00 00       	mov    $0x2,%esi
  81b96e:	48 89 cf             	mov    %rcx,%rdi
  81b971:	ff d0                	callq  *%rax

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  81b973:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b977:	48 8b 00             	mov    (%rax),%rax
  81b97a:	8b 40 14             	mov    0x14(%rax),%eax
  81b97d:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b980:	74 18                	je     81b99a <do_delconn+0x13c>
    sys_sem_signal(msg->conn->op_completed);
  81b982:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b986:	48 8b 00             	mov    (%rax),%rax
  81b989:	8b 40 14             	mov    0x14(%rax),%eax
  81b98c:	89 c7                	mov    %eax,%edi
  81b98e:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  81b995:	00 00 00 
  81b998:	ff d0                	callq  *%rax
  }
}
  81b99a:	c9                   	leaveq 
  81b99b:	c3                   	retq   

000000000081b99c <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  81b99c:	55                   	push   %rbp
  81b99d:	48 89 e5             	mov    %rsp,%rbp
  81b9a0:	53                   	push   %rbx
  81b9a1:	48 83 ec 18          	sub    $0x18,%rsp
  81b9a5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81b9a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9ad:	48 8b 00             	mov    (%rax),%rax
  81b9b0:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b9b4:	3c fc                	cmp    $0xfc,%al
  81b9b6:	0f 8c ed 00 00 00    	jl     81baa9 <do_bind+0x10d>
    if (msg->conn->pcb.tcp != NULL) {
  81b9bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9c0:	48 8b 00             	mov    (%rax),%rax
  81b9c3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b9c7:	48 85 c0             	test   %rax,%rax
  81b9ca:	0f 84 ce 00 00 00    	je     81ba9e <do_bind+0x102>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b9d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9d4:	48 8b 00             	mov    (%rax),%rax
  81b9d7:	8b 00                	mov    (%rax),%eax
  81b9d9:	25 f0 00 00 00       	and    $0xf0,%eax
  81b9de:	83 f8 20             	cmp    $0x20,%eax
  81b9e1:	74 43                	je     81ba26 <do_bind+0x8a>
  81b9e3:	83 f8 40             	cmp    $0x40,%eax
  81b9e6:	74 0a                	je     81b9f2 <do_bind+0x56>
  81b9e8:	83 f8 10             	cmp    $0x10,%eax
  81b9eb:	74 75                	je     81ba62 <do_bind+0xc6>
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
        break;
#endif /* LWIP_TCP */
      default:
        break;
  81b9ed:	e9 b7 00 00 00       	jmpq   81baa9 <do_bind+0x10d>
  if (!ERR_IS_FATAL(msg->conn->err)) {
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  81b9f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9f6:	48 8b 18             	mov    (%rax),%rbx
  81b9f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9fd:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81ba01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba05:	48 8b 00             	mov    (%rax),%rax
  81ba08:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba0c:	48 89 d6             	mov    %rdx,%rsi
  81ba0f:	48 89 c7             	mov    %rax,%rdi
  81ba12:	48 b8 84 00 82 00 00 	movabs $0x820084,%rax
  81ba19:	00 00 00 
  81ba1c:	ff d0                	callq  *%rax
  81ba1e:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81ba21:	e9 83 00 00 00       	jmpq   81baa9 <do_bind+0x10d>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81ba26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba2a:	48 8b 18             	mov    (%rax),%rbx
  81ba2d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba31:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81ba35:	0f b7 d0             	movzwl %ax,%edx
  81ba38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba3c:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81ba40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba44:	48 8b 00             	mov    (%rax),%rax
  81ba47:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba4b:	48 89 ce             	mov    %rcx,%rsi
  81ba4e:	48 89 c7             	mov    %rax,%rdi
  81ba51:	48 b8 71 57 81 00 00 	movabs $0x815771,%rax
  81ba58:	00 00 00 
  81ba5b:	ff d0                	callq  *%rax
  81ba5d:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81ba60:	eb 47                	jmp    81baa9 <do_bind+0x10d>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81ba62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba66:	48 8b 18             	mov    (%rax),%rbx
  81ba69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba6d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81ba71:	0f b7 d0             	movzwl %ax,%edx
  81ba74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba78:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81ba7c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba80:	48 8b 00             	mov    (%rax),%rax
  81ba83:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba87:	48 89 ce             	mov    %rcx,%rsi
  81ba8a:	48 89 c7             	mov    %rax,%rdi
  81ba8d:	48 b8 61 f1 80 00 00 	movabs $0x80f161,%rax
  81ba94:	00 00 00 
  81ba97:	ff d0                	callq  *%rax
  81ba99:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81ba9c:	eb 0b                	jmp    81baa9 <do_bind+0x10d>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  81ba9e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81baa2:	48 8b 00             	mov    (%rax),%rax
  81baa5:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81baa9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81baad:	48 8b 00             	mov    (%rax),%rax
  81bab0:	8b 40 14             	mov    0x14(%rax),%eax
  81bab3:	89 c7                	mov    %eax,%edi
  81bab5:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  81babc:	00 00 00 
  81babf:	ff d0                	callq  *%rax
}
  81bac1:	90                   	nop
  81bac2:	48 83 c4 18          	add    $0x18,%rsp
  81bac6:	5b                   	pop    %rbx
  81bac7:	5d                   	pop    %rbp
  81bac8:	c3                   	retq   

000000000081bac9 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  81bac9:	55                   	push   %rbp
  81baca:	48 89 e5             	mov    %rsp,%rbp
  81bacd:	48 83 ec 30          	sub    $0x30,%rsp
  81bad1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81bad5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81bad9:	89 d0                	mov    %edx,%eax
  81badb:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct netconn *conn;

  LWIP_UNUSED_ARG(pcb);

  conn = arg;
  81bade:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bae2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if (conn == NULL) {
  81bae6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81baeb:	75 07                	jne    81baf4 <do_connected+0x2b>
    return ERR_VAL;
  81baed:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  81baf2:	eb 54                	jmp    81bb48 <do_connected+0x7f>
  }

  conn->err = err;
  81baf4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81baf8:	0f b6 55 dc          	movzbl -0x24(%rbp),%edx
  81bafc:	88 50 10             	mov    %dl,0x10(%rax)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  81baff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bb03:	8b 00                	mov    (%rax),%eax
  81bb05:	83 f8 10             	cmp    $0x10,%eax
  81bb08:	75 19                	jne    81bb23 <do_connected+0x5a>
  81bb0a:	80 7d dc 00          	cmpb   $0x0,-0x24(%rbp)
  81bb0e:	75 13                	jne    81bb23 <do_connected+0x5a>
    setup_tcp(conn);
  81bb10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bb14:	48 89 c7             	mov    %rax,%rdi
  81bb17:	48 b8 95 ae 81 00 00 	movabs $0x81ae95,%rax
  81bb1e:	00 00 00 
  81bb21:	ff d0                	callq  *%rax
  }
  conn->state = NETCONN_NONE;
  81bb23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bb27:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  sys_sem_signal(conn->op_completed);
  81bb2e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bb32:	8b 40 14             	mov    0x14(%rax),%eax
  81bb35:	89 c7                	mov    %eax,%edi
  81bb37:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  81bb3e:	00 00 00 
  81bb41:	ff d0                	callq  *%rax
  return ERR_OK;
  81bb43:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81bb48:	c9                   	leaveq 
  81bb49:	c3                   	retq   

000000000081bb4a <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  81bb4a:	55                   	push   %rbp
  81bb4b:	48 89 e5             	mov    %rsp,%rbp
  81bb4e:	53                   	push   %rbx
  81bb4f:	48 83 ec 18          	sub    $0x18,%rsp
  81bb53:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (msg->conn->pcb.tcp == NULL) {
  81bb57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bb5b:	48 8b 00             	mov    (%rax),%rax
  81bb5e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bb62:	48 85 c0             	test   %rax,%rax
  81bb65:	75 1d                	jne    81bb84 <do_connect+0x3a>
    sys_sem_signal(msg->conn->op_completed);
  81bb67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bb6b:	48 8b 00             	mov    (%rax),%rax
  81bb6e:	8b 40 14             	mov    0x14(%rax),%eax
  81bb71:	89 c7                	mov    %eax,%edi
  81bb73:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  81bb7a:	00 00 00 
  81bb7d:	ff d0                	callq  *%rax
    return;
  81bb7f:	e9 2c 01 00 00       	jmpq   81bcb0 <do_connect+0x166>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81bb84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bb88:	48 8b 00             	mov    (%rax),%rax
  81bb8b:	8b 00                	mov    (%rax),%eax
  81bb8d:	25 f0 00 00 00       	and    $0xf0,%eax
  81bb92:	83 f8 20             	cmp    $0x20,%eax
  81bb95:	74 5f                	je     81bbf6 <do_connect+0xac>
  81bb97:	83 f8 40             	cmp    $0x40,%eax
  81bb9a:	74 0e                	je     81bbaa <do_connect+0x60>
  81bb9c:	83 f8 10             	cmp    $0x10,%eax
  81bb9f:	0f 84 a5 00 00 00    	je     81bc4a <do_connect+0x100>
    /* sys_sem_signal() is called from do_connected (or err_tcp()),
     * when the connection is established! */
    break;
#endif /* LWIP_TCP */
  default:
    break;
  81bba5:	e9 06 01 00 00       	jmpq   81bcb0 <do_connect+0x166>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  81bbaa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bbae:	48 8b 18             	mov    (%rax),%rbx
  81bbb1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bbb5:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81bbb9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bbbd:	48 8b 00             	mov    (%rax),%rax
  81bbc0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bbc4:	48 89 d6             	mov    %rdx,%rsi
  81bbc7:	48 89 c7             	mov    %rax,%rdi
  81bbca:	48 b8 b5 00 82 00 00 	movabs $0x8200b5,%rax
  81bbd1:	00 00 00 
  81bbd4:	ff d0                	callq  *%rax
  81bbd6:	88 43 10             	mov    %al,0x10(%rbx)
    sys_sem_signal(msg->conn->op_completed);
  81bbd9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bbdd:	48 8b 00             	mov    (%rax),%rax
  81bbe0:	8b 40 14             	mov    0x14(%rax),%eax
  81bbe3:	89 c7                	mov    %eax,%edi
  81bbe5:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  81bbec:	00 00 00 
  81bbef:	ff d0                	callq  *%rax
    break;
  81bbf1:	e9 ba 00 00 00       	jmpq   81bcb0 <do_connect+0x166>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81bbf6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bbfa:	48 8b 18             	mov    (%rax),%rbx
  81bbfd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc01:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81bc05:	0f b7 d0             	movzwl %ax,%edx
  81bc08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc0c:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81bc10:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc14:	48 8b 00             	mov    (%rax),%rax
  81bc17:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bc1b:	48 89 ce             	mov    %rcx,%rsi
  81bc1e:	48 89 c7             	mov    %rax,%rdi
  81bc21:	48 b8 bd 58 81 00 00 	movabs $0x8158bd,%rax
  81bc28:	00 00 00 
  81bc2b:	ff d0                	callq  *%rax
  81bc2d:	88 43 10             	mov    %al,0x10(%rbx)
    sys_sem_signal(msg->conn->op_completed);
  81bc30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc34:	48 8b 00             	mov    (%rax),%rax
  81bc37:	8b 40 14             	mov    0x14(%rax),%eax
  81bc3a:	89 c7                	mov    %eax,%edi
  81bc3c:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  81bc43:	00 00 00 
  81bc46:	ff d0                	callq  *%rax
    break;
  81bc48:	eb 66                	jmp    81bcb0 <do_connect+0x166>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  81bc4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc4e:	48 8b 00             	mov    (%rax),%rax
  81bc51:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%rax)
    setup_tcp(msg->conn);
  81bc58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc5c:	48 8b 00             	mov    (%rax),%rax
  81bc5f:	48 89 c7             	mov    %rax,%rdi
  81bc62:	48 b8 95 ae 81 00 00 	movabs $0x81ae95,%rax
  81bc69:	00 00 00 
  81bc6c:	ff d0                	callq  *%rax
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  81bc6e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc72:	48 8b 18             	mov    (%rax),%rbx
  81bc75:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc79:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81bc7d:	0f b7 d0             	movzwl %ax,%edx
  81bc80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc84:	48 8b 70 08          	mov    0x8(%rax),%rsi
  81bc88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bc8c:	48 8b 00             	mov    (%rax),%rax
  81bc8f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bc93:	48 b9 c9 ba 81 00 00 	movabs $0x81bac9,%rcx
  81bc9a:	00 00 00 
  81bc9d:	48 89 c7             	mov    %rax,%rdi
  81bca0:	48 b8 96 f8 80 00 00 	movabs $0x80f896,%rax
  81bca7:	00 00 00 
  81bcaa:	ff d0                	callq  *%rax
  81bcac:	88 43 10             	mov    %al,0x10(%rbx)
                                 do_connected);
    /* sys_sem_signal() is called from do_connected (or err_tcp()),
     * when the connection is established! */
    break;
  81bcaf:	90                   	nop
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  81bcb0:	48 83 c4 18          	add    $0x18,%rsp
  81bcb4:	5b                   	pop    %rbx
  81bcb5:	5d                   	pop    %rbp
  81bcb6:	c3                   	retq   

000000000081bcb7 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  81bcb7:	55                   	push   %rbp
  81bcb8:	48 89 e5             	mov    %rsp,%rbp
  81bcbb:	48 83 ec 10          	sub    $0x10,%rsp
  81bcbf:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  81bcc3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bcc7:	48 8b 00             	mov    (%rax),%rax
  81bcca:	8b 00                	mov    (%rax),%eax
  81bccc:	25 f0 00 00 00       	and    $0xf0,%eax
  81bcd1:	83 f8 20             	cmp    $0x20,%eax
  81bcd4:	75 1a                	jne    81bcf0 <do_disconnect+0x39>
    udp_disconnect(msg->conn->pcb.udp);
  81bcd6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bcda:	48 8b 00             	mov    (%rax),%rax
  81bcdd:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bce1:	48 89 c7             	mov    %rax,%rdi
  81bce4:	48 b8 b6 59 81 00 00 	movabs $0x8159b6,%rax
  81bceb:	00 00 00 
  81bcee:	ff d0                	callq  *%rax
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  81bcf0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bcf4:	48 8b 00             	mov    (%rax),%rax
  81bcf7:	8b 40 14             	mov    0x14(%rax),%eax
  81bcfa:	89 c7                	mov    %eax,%edi
  81bcfc:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  81bd03:	00 00 00 
  81bd06:	ff d0                	callq  *%rax
}
  81bd08:	90                   	nop
  81bd09:	c9                   	leaveq 
  81bd0a:	c3                   	retq   

000000000081bd0b <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  81bd0b:	55                   	push   %rbp
  81bd0c:	48 89 e5             	mov    %rsp,%rbp
  81bd0f:	53                   	push   %rbx
  81bd10:	48 83 ec 28          	sub    $0x28,%rsp
  81bd14:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81bd18:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd1c:	48 8b 00             	mov    (%rax),%rax
  81bd1f:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81bd23:	3c fc                	cmp    $0xfc,%al
  81bd25:	0f 8c 69 01 00 00    	jl     81be94 <do_listen+0x189>
    if (msg->conn->pcb.tcp != NULL) {
  81bd2b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd2f:	48 8b 00             	mov    (%rax),%rax
  81bd32:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd36:	48 85 c0             	test   %rax,%rax
  81bd39:	0f 84 55 01 00 00    	je     81be94 <do_listen+0x189>
      if (msg->conn->type == NETCONN_TCP) {
  81bd3f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd43:	48 8b 00             	mov    (%rax),%rax
  81bd46:	8b 00                	mov    (%rax),%eax
  81bd48:	83 f8 10             	cmp    $0x10,%eax
  81bd4b:	0f 85 43 01 00 00    	jne    81be94 <do_listen+0x189>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  81bd51:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd55:	48 8b 00             	mov    (%rax),%rax
  81bd58:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd5c:	8b 40 18             	mov    0x18(%rax),%eax
  81bd5f:	85 c0                	test   %eax,%eax
  81bd61:	0f 85 22 01 00 00    	jne    81be89 <do_listen+0x17e>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  81bd67:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd6b:	48 8b 00             	mov    (%rax),%rax
  81bd6e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd72:	be ff 00 00 00       	mov    $0xff,%esi
  81bd77:	48 89 c7             	mov    %rax,%rdi
  81bd7a:	48 b8 e2 f3 80 00 00 	movabs $0x80f3e2,%rax
  81bd81:	00 00 00 
  81bd84:	ff d0                	callq  *%rax
  81bd86:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  81bd8a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81bd8f:	75 10                	jne    81bda1 <do_listen+0x96>
            msg->conn->err = ERR_MEM;
  81bd91:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd95:	48 8b 00             	mov    (%rax),%rax
  81bd98:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
  81bd9c:	e9 f3 00 00 00       	jmpq   81be94 <do_listen+0x189>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  81bda1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bda5:	48 8b 00             	mov    (%rax),%rax
  81bda8:	8b 40 18             	mov    0x18(%rax),%eax
  81bdab:	83 f8 ff             	cmp    $0xffffffff,%eax
  81bdae:	74 26                	je     81bdd6 <do_listen+0xcb>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  81bdb0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bdb4:	48 8b 00             	mov    (%rax),%rax
  81bdb7:	8b 40 18             	mov    0x18(%rax),%eax
  81bdba:	89 c7                	mov    %eax,%edi
  81bdbc:	48 b8 3d 7a 81 00 00 	movabs $0x817a3d,%rax
  81bdc3:	00 00 00 
  81bdc6:	ff d0                	callq  *%rax
              msg->conn->recvmbox = SYS_MBOX_NULL;
  81bdc8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bdcc:	48 8b 00             	mov    (%rax),%rax
  81bdcf:	c7 40 18 ff ff ff ff 	movl   $0xffffffff,0x18(%rax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  81bdd6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bdda:	48 8b 00             	mov    (%rax),%rax
  81bddd:	8b 40 1c             	mov    0x1c(%rax),%eax
  81bde0:	83 f8 ff             	cmp    $0xffffffff,%eax
  81bde3:	75 2e                	jne    81be13 <do_listen+0x108>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  81bde5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bde9:	48 8b 18             	mov    (%rax),%rbx
  81bdec:	bf 00 00 00 00       	mov    $0x0,%edi
  81bdf1:	48 b8 59 78 81 00 00 	movabs $0x817859,%rax
  81bdf8:	00 00 00 
  81bdfb:	ff d0                	callq  *%rax
  81bdfd:	89 43 1c             	mov    %eax,0x1c(%rbx)
  81be00:	8b 43 1c             	mov    0x1c(%rbx),%eax
  81be03:	83 f8 ff             	cmp    $0xffffffff,%eax
  81be06:	75 0b                	jne    81be13 <do_listen+0x108>
                msg->conn->err = ERR_MEM;
  81be08:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be0c:	48 8b 00             	mov    (%rax),%rax
  81be0f:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  81be13:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be17:	48 8b 00             	mov    (%rax),%rax
  81be1a:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81be1e:	84 c0                	test   %al,%al
  81be20:	75 72                	jne    81be94 <do_listen+0x189>
              msg->conn->state = NETCONN_LISTEN;
  81be22:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be26:	48 8b 00             	mov    (%rax),%rax
  81be29:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%rax)
              msg->conn->pcb.tcp = lpcb;
  81be30:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be34:	48 8b 00             	mov    (%rax),%rax
  81be37:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81be3b:	48 89 50 08          	mov    %rdx,0x8(%rax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  81be3f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be43:	48 8b 10             	mov    (%rax),%rdx
  81be46:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be4a:	48 8b 00             	mov    (%rax),%rax
  81be4d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81be51:	48 89 d6             	mov    %rdx,%rsi
  81be54:	48 89 c7             	mov    %rax,%rdi
  81be57:	48 b8 79 09 81 00 00 	movabs $0x810979,%rax
  81be5e:	00 00 00 
  81be61:	ff d0                	callq  *%rax
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  81be63:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be67:	48 8b 00             	mov    (%rax),%rax
  81be6a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81be6e:	48 be 43 af 81 00 00 	movabs $0x81af43,%rsi
  81be75:	00 00 00 
  81be78:	48 89 c7             	mov    %rax,%rdi
  81be7b:	48 b8 fe 09 81 00 00 	movabs $0x8109fe,%rax
  81be82:	00 00 00 
  81be85:	ff d0                	callq  *%rax
  81be87:	eb 0b                	jmp    81be94 <do_listen+0x189>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  81be89:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be8d:	48 8b 00             	mov    (%rax),%rax
  81be90:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  81be94:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81be98:	48 8b 00             	mov    (%rax),%rax
  81be9b:	8b 40 14             	mov    0x14(%rax),%eax
  81be9e:	89 c7                	mov    %eax,%edi
  81bea0:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  81bea7:	00 00 00 
  81beaa:	ff d0                	callq  *%rax
}
  81beac:	90                   	nop
  81bead:	48 83 c4 28          	add    $0x28,%rsp
  81beb1:	5b                   	pop    %rbx
  81beb2:	5d                   	pop    %rbp
  81beb3:	c3                   	retq   

000000000081beb4 <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  81beb4:	55                   	push   %rbp
  81beb5:	48 89 e5             	mov    %rsp,%rbp
  81beb8:	53                   	push   %rbx
  81beb9:	48 83 ec 18          	sub    $0x18,%rsp
  81bebd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81bec1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bec5:	48 8b 00             	mov    (%rax),%rax
  81bec8:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81becc:	3c fc                	cmp    $0xfc,%al
  81bece:	0f 8c 50 01 00 00    	jl     81c024 <do_send+0x170>
    if (msg->conn->pcb.tcp != NULL) {
  81bed4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bed8:	48 8b 00             	mov    (%rax),%rax
  81bedb:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bedf:	48 85 c0             	test   %rax,%rax
  81bee2:	0f 84 3c 01 00 00    	je     81c024 <do_send+0x170>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81bee8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81beec:	48 8b 00             	mov    (%rax),%rax
  81beef:	8b 00                	mov    (%rax),%eax
  81bef1:	25 f0 00 00 00       	and    $0xf0,%eax
  81bef6:	83 f8 20             	cmp    $0x20,%eax
  81bef9:	0f 84 95 00 00 00    	je     81bf94 <do_send+0xe0>
  81beff:	83 f8 40             	cmp    $0x40,%eax
  81bf02:	74 05                	je     81bf09 <do_send+0x55>
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
        }
        break;
#endif /* LWIP_UDP */
      default:
        break;
  81bf04:	e9 1b 01 00 00       	jmpq   81c024 <do_send+0x170>
  if (!ERR_IS_FATAL(msg->conn->err)) {
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  81bf09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf0d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf11:	48 8b 40 10          	mov    0x10(%rax),%rax
  81bf15:	48 85 c0             	test   %rax,%rax
  81bf18:	75 37                	jne    81bf51 <do_send+0x9d>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  81bf1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf1e:	48 8b 18             	mov    (%rax),%rbx
  81bf21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf25:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf29:	48 8b 10             	mov    (%rax),%rdx
  81bf2c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf30:	48 8b 00             	mov    (%rax),%rax
  81bf33:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf37:	48 89 d6             	mov    %rdx,%rsi
  81bf3a:	48 89 c7             	mov    %rax,%rdi
  81bf3d:	48 b8 c2 02 82 00 00 	movabs $0x8202c2,%rax
  81bf44:	00 00 00 
  81bf47:	ff d0                	callq  *%rax
  81bf49:	88 43 10             	mov    %al,0x10(%rbx)
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
        }
        break;
  81bf4c:	e9 d3 00 00 00       	jmpq   81c024 <do_send+0x170>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  81bf51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf55:	48 8b 18             	mov    (%rax),%rbx
  81bf58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf5c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf60:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81bf64:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf68:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf6c:	48 8b 08             	mov    (%rax),%rcx
  81bf6f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf73:	48 8b 00             	mov    (%rax),%rax
  81bf76:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf7a:	48 89 ce             	mov    %rcx,%rsi
  81bf7d:	48 89 c7             	mov    %rax,%rdi
  81bf80:	48 b8 16 01 82 00 00 	movabs $0x820116,%rax
  81bf87:	00 00 00 
  81bf8a:	ff d0                	callq  *%rax
  81bf8c:	88 43 10             	mov    %al,0x10(%rbx)
        }
        break;
  81bf8f:	e9 90 00 00 00       	jmpq   81c024 <do_send+0x170>
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  81bf94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bf98:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf9c:	48 8b 40 10          	mov    0x10(%rax),%rax
  81bfa0:	48 85 c0             	test   %rax,%rax
  81bfa3:	75 34                	jne    81bfd9 <do_send+0x125>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  81bfa5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bfa9:	48 8b 18             	mov    (%rax),%rbx
  81bfac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bfb0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bfb4:	48 8b 10             	mov    (%rax),%rdx
  81bfb7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bfbb:	48 8b 00             	mov    (%rax),%rax
  81bfbe:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bfc2:	48 89 d6             	mov    %rdx,%rsi
  81bfc5:	48 89 c7             	mov    %rax,%rdi
  81bfc8:	48 b8 0b 54 81 00 00 	movabs $0x81540b,%rax
  81bfcf:	00 00 00 
  81bfd2:	ff d0                	callq  *%rax
  81bfd4:	88 43 10             	mov    %al,0x10(%rbx)
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
        }
        break;
  81bfd7:	eb 4a                	jmp    81c023 <do_send+0x16f>
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  81bfd9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bfdd:	48 8b 18             	mov    (%rax),%rbx
  81bfe0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bfe4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bfe8:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81bfec:	0f b7 c8             	movzwl %ax,%ecx
  81bfef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bff3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bff7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81bffb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81bfff:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c003:	48 8b 30             	mov    (%rax),%rsi
  81c006:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c00a:	48 8b 00             	mov    (%rax),%rax
  81c00d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c011:	48 89 c7             	mov    %rax,%rdi
  81c014:	48 b8 4c 54 81 00 00 	movabs $0x81544c,%rax
  81c01b:	00 00 00 
  81c01e:	ff d0                	callq  *%rax
  81c020:	88 43 10             	mov    %al,0x10(%rbx)
        }
        break;
  81c023:	90                   	nop
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81c024:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c028:	48 8b 00             	mov    (%rax),%rax
  81c02b:	8b 40 14             	mov    0x14(%rax),%eax
  81c02e:	89 c7                	mov    %eax,%edi
  81c030:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  81c037:	00 00 00 
  81c03a:	ff d0                	callq  *%rax
}
  81c03c:	90                   	nop
  81c03d:	48 83 c4 18          	add    $0x18,%rsp
  81c041:	5b                   	pop    %rbx
  81c042:	5d                   	pop    %rbp
  81c043:	c3                   	retq   

000000000081c044 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  81c044:	55                   	push   %rbp
  81c045:	48 89 e5             	mov    %rsp,%rbp
  81c048:	48 83 ec 10          	sub    $0x10,%rsp
  81c04c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81c050:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c054:	48 8b 00             	mov    (%rax),%rax
  81c057:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81c05b:	3c fc                	cmp    $0xfc,%al
  81c05d:	7c 45                	jl     81c0a4 <do_recv+0x60>
    if (msg->conn->pcb.tcp != NULL) {
  81c05f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c063:	48 8b 00             	mov    (%rax),%rax
  81c066:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c06a:	48 85 c0             	test   %rax,%rax
  81c06d:	74 35                	je     81c0a4 <do_recv+0x60>
      if (msg->conn->type == NETCONN_TCP) {
  81c06f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c073:	48 8b 00             	mov    (%rax),%rax
  81c076:	8b 00                	mov    (%rax),%eax
  81c078:	83 f8 10             	cmp    $0x10,%eax
  81c07b:	75 27                	jne    81c0a4 <do_recv+0x60>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  81c07d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c081:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81c085:	0f b7 d0             	movzwl %ax,%edx
  81c088:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c08c:	48 8b 00             	mov    (%rax),%rax
  81c08f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c093:	89 d6                	mov    %edx,%esi
  81c095:	48 89 c7             	mov    %rax,%rdi
  81c098:	48 b8 25 f6 80 00 00 	movabs $0x80f625,%rax
  81c09f:	00 00 00 
  81c0a2:	ff d0                	callq  *%rax
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  81c0a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c0a8:	48 8b 00             	mov    (%rax),%rax
  81c0ab:	8b 40 14             	mov    0x14(%rax),%eax
  81c0ae:	89 c7                	mov    %eax,%edi
  81c0b0:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  81c0b7:	00 00 00 
  81c0ba:	ff d0                	callq  *%rax
}
  81c0bc:	90                   	nop
  81c0bd:	c9                   	leaveq 
  81c0be:	c3                   	retq   

000000000081c0bf <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  81c0bf:	55                   	push   %rbp
  81c0c0:	48 89 e5             	mov    %rsp,%rbp
  81c0c3:	48 83 ec 30          	sub    $0x30,%rsp
  81c0c7:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  81c0cb:	c6 45 fd 00          	movb   $0x0,-0x3(%rbp)

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  81c0cf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c0d3:	8b 40 04             	mov    0x4(%rax),%eax
  81c0d6:	83 f8 01             	cmp    $0x1,%eax
  81c0d9:	74 2a                	je     81c105 <do_writemore+0x46>
  81c0db:	48 ba c3 3b 82 00 00 	movabs $0x823bc3,%rdx
  81c0e2:	00 00 00 
  81c0e5:	be b9 03 00 00       	mov    $0x3b9,%esi
  81c0ea:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81c0f1:	00 00 00 
  81c0f4:	b8 00 00 00 00       	mov    $0x0,%eax
  81c0f9:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81c100:	00 00 00 
  81c103:	ff d1                	callq  *%rcx

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  81c105:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c109:	48 8b 40 28          	mov    0x28(%rax),%rax
  81c10d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81c111:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c115:	8b 40 30             	mov    0x30(%rax),%eax
  81c118:	48 98                	cltq   
  81c11a:	48 01 d0             	add    %rdx,%rax
  81c11d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  81c121:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c125:	48 8b 40 28          	mov    0x28(%rax),%rax
  81c129:	8b 50 10             	mov    0x10(%rax),%edx
  81c12c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c130:	8b 40 30             	mov    0x30(%rax),%eax
  81c133:	29 c2                	sub    %eax,%edx
  81c135:	89 d0                	mov    %edx,%eax
  81c137:	3d ff ff 00 00       	cmp    $0xffff,%eax
  81c13c:	7e 08                	jle    81c146 <do_writemore+0x87>
    len = 0xffff;
  81c13e:	66 c7 45 fe ff ff    	movw   $0xffff,-0x2(%rbp)
  81c144:	eb 1c                	jmp    81c162 <do_writemore+0xa3>
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  81c146:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c14a:	48 8b 40 28          	mov    0x28(%rax),%rax
  81c14e:	8b 40 10             	mov    0x10(%rax),%eax
  81c151:	89 c2                	mov    %eax,%edx
  81c153:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c157:	8b 40 30             	mov    0x30(%rax),%eax
  81c15a:	29 c2                	sub    %eax,%edx
  81c15c:	89 d0                	mov    %edx,%eax
  81c15e:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  81c162:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c166:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c16a:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81c16e:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  if (available < len) {
  81c172:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  81c176:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  81c17a:	73 08                	jae    81c184 <do_writemore+0xc5>
    /* don't try to write more than sendbuf */
    len = available;
  81c17c:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  81c180:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  81c184:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c188:	48 8b 40 28          	mov    0x28(%rax),%rax
  81c18c:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  81c190:	0f b6 c8             	movzbl %al,%ecx
  81c193:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81c197:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c19b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c19f:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  81c1a3:	48 89 c7             	mov    %rax,%rdi
  81c1a6:	48 b8 ff 31 81 00 00 	movabs $0x8131ff,%rax
  81c1ad:	00 00 00 
  81c1b0:	ff d0                	callq  *%rax
  81c1b2:	88 45 ed             	mov    %al,-0x13(%rbp)
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  81c1b5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c1b9:	8b 50 30             	mov    0x30(%rax),%edx
  81c1bc:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81c1c0:	01 c2                	add    %eax,%edx
  81c1c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c1c6:	48 8b 40 28          	mov    0x28(%rax),%rax
  81c1ca:	8b 40 10             	mov    0x10(%rax),%eax
  81c1cd:	39 c2                	cmp    %eax,%edx
  81c1cf:	7e 2a                	jle    81c1fb <do_writemore+0x13c>
  81c1d1:	48 ba e0 3b 82 00 00 	movabs $0x823be0,%rdx
  81c1d8:	00 00 00 
  81c1db:	be ce 03 00 00       	mov    $0x3ce,%esi
  81c1e0:	48 bf d2 39 82 00 00 	movabs $0x8239d2,%rdi
  81c1e7:	00 00 00 
  81c1ea:	b8 00 00 00 00       	mov    $0x0,%eax
  81c1ef:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81c1f6:	00 00 00 
  81c1f9:	ff d1                	callq  *%rcx
  if (err == ERR_OK) {
  81c1fb:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81c1ff:	0f 85 07 01 00 00    	jne    81c30c <do_writemore+0x24d>
    conn->write_offset += len;
  81c205:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c209:	8b 50 30             	mov    0x30(%rax),%edx
  81c20c:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81c210:	01 c2                	add    %eax,%edx
  81c212:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c216:	89 50 30             	mov    %edx,0x30(%rax)
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  81c219:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c21d:	8b 50 30             	mov    0x30(%rax),%edx
  81c220:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c224:	48 8b 40 28          	mov    0x28(%rax),%rax
  81c228:	8b 40 10             	mov    0x10(%rax),%eax
  81c22b:	39 c2                	cmp    %eax,%edx
  81c22d:	75 1b                	jne    81c24a <do_writemore+0x18b>
      /* everything was written */
      write_finished = 1;
  81c22f:	c6 45 fd 01          	movb   $0x1,-0x3(%rbp)
      conn->write_msg = NULL;
  81c233:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c237:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  81c23e:	00 
      conn->write_offset = 0;
  81c23f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c243:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  81c24a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c24e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c252:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81c259:	48 85 c0             	test   %rax,%rax
  81c25c:	74 41                	je     81c29f <do_writemore+0x1e0>
  81c25e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c262:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c266:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81c26a:	0f b6 c0             	movzbl %al,%eax
  81c26d:	83 e0 40             	and    $0x40,%eax
  81c270:	85 c0                	test   %eax,%eax
  81c272:	75 2b                	jne    81c29f <do_writemore+0x1e0>
  81c274:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c278:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c27c:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81c283:	48 85 c0             	test   %rax,%rax
  81c286:	74 30                	je     81c2b8 <do_writemore+0x1f9>
  81c288:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c28c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c290:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81c297:	48 8b 00             	mov    (%rax),%rax
  81c29a:	48 85 c0             	test   %rax,%rax
  81c29d:	74 19                	je     81c2b8 <do_writemore+0x1f9>
  81c29f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c2a3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c2a7:	48 89 c7             	mov    %rax,%rdi
  81c2aa:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  81c2b1:	00 00 00 
  81c2b4:	ff d0                	callq  *%rax
  81c2b6:	eb 05                	jmp    81c2bd <do_writemore+0x1fe>
  81c2b8:	b8 00 00 00 00       	mov    $0x0,%eax
  81c2bd:	88 45 ed             	mov    %al,-0x13(%rbp)
    conn->err = err;
  81c2c0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c2c4:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  81c2c8:	88 50 10             	mov    %dl,0x10(%rax)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  81c2cb:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81c2cf:	75 6c                	jne    81c33d <do_writemore+0x27e>
  81c2d1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c2d5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c2d9:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81c2dd:	66 3d a0 2d          	cmp    $0x2da0,%ax
  81c2e1:	77 5a                	ja     81c33d <do_writemore+0x27e>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  81c2e3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c2e7:	48 8b 40 38          	mov    0x38(%rax),%rax
  81c2eb:	48 85 c0             	test   %rax,%rax
  81c2ee:	74 4d                	je     81c33d <do_writemore+0x27e>
  81c2f0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c2f4:	48 8b 40 38          	mov    0x38(%rax),%rax
  81c2f8:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81c2fc:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  81c300:	be 03 00 00 00       	mov    $0x3,%esi
  81c305:	48 89 cf             	mov    %rcx,%rdi
  81c308:	ff d0                	callq  *%rax
  81c30a:	eb 31                	jmp    81c33d <do_writemore+0x27e>
    }
  } else if (err == ERR_MEM) {
  81c30c:	80 7d ed ff          	cmpb   $0xff,-0x13(%rbp)
  81c310:	75 1c                	jne    81c32e <do_writemore+0x26f>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  81c312:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c316:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c31a:	48 89 c7             	mov    %rax,%rdi
  81c31d:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  81c324:	00 00 00 
  81c327:	ff d0                	callq  *%rax
  81c329:	88 45 ed             	mov    %al,-0x13(%rbp)
  81c32c:	eb 0f                	jmp    81c33d <do_writemore+0x27e>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  81c32e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c332:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  81c336:	88 50 10             	mov    %dl,0x10(%rax)
    write_finished = 1;
  81c339:	c6 45 fd 01          	movb   $0x1,-0x3(%rbp)
  }

  if (write_finished) {
  81c33d:	80 7d fd 00          	cmpb   $0x0,-0x3(%rbp)
  81c341:	74 20                	je     81c363 <do_writemore+0x2a4>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  81c343:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c347:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  81c34e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c352:	8b 40 14             	mov    0x14(%rax),%eax
  81c355:	89 c7                	mov    %eax,%edi
  81c357:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  81c35e:	00 00 00 
  81c361:	ff d0                	callq  *%rax
  }
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
  81c363:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81c368:	c9                   	leaveq 
  81c369:	c3                   	retq   

000000000081c36a <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  81c36a:	55                   	push   %rbp
  81c36b:	48 89 e5             	mov    %rsp,%rbp
  81c36e:	48 83 ec 10          	sub    $0x10,%rsp
  81c372:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81c376:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c37a:	48 8b 00             	mov    (%rax),%rax
  81c37d:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81c381:	3c fc                	cmp    $0xfc,%al
  81c383:	7c 6c                	jl     81c3f1 <do_write+0x87>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  81c385:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c389:	48 8b 00             	mov    (%rax),%rax
  81c38c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c390:	48 85 c0             	test   %rax,%rax
  81c393:	74 51                	je     81c3e6 <do_write+0x7c>
  81c395:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c399:	48 8b 00             	mov    (%rax),%rax
  81c39c:	8b 00                	mov    (%rax),%eax
  81c39e:	83 f8 10             	cmp    $0x10,%eax
  81c3a1:	75 43                	jne    81c3e6 <do_write+0x7c>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  81c3a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c3a7:	48 8b 00             	mov    (%rax),%rax
  81c3aa:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  81c3b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c3b5:	48 8b 00             	mov    (%rax),%rax
  81c3b8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c3bc:	48 89 50 28          	mov    %rdx,0x28(%rax)
      msg->conn->write_offset = 0;
  81c3c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c3c4:	48 8b 00             	mov    (%rax),%rax
  81c3c7:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  81c3ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c3d2:	48 8b 00             	mov    (%rax),%rax
  81c3d5:	48 89 c7             	mov    %rax,%rdi
  81c3d8:	48 b8 bf c0 81 00 00 	movabs $0x81c0bf,%rax
  81c3df:	00 00 00 
  81c3e2:	ff d0                	callq  *%rax
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  81c3e4:	eb 23                	jmp    81c409 <do_write+0x9f>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  81c3e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c3ea:	48 8b 00             	mov    (%rax),%rax
  81c3ed:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81c3f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c3f5:	48 8b 00             	mov    (%rax),%rax
  81c3f8:	8b 40 14             	mov    0x14(%rax),%eax
  81c3fb:	89 c7                	mov    %eax,%edi
  81c3fd:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  81c404:	00 00 00 
  81c407:	ff d0                	callq  *%rax
}
  81c409:	c9                   	leaveq 
  81c40a:	c3                   	retq   

000000000081c40b <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  81c40b:	55                   	push   %rbp
  81c40c:	48 89 e5             	mov    %rsp,%rbp
  81c40f:	48 83 ec 10          	sub    $0x10,%rsp
  81c413:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (msg->conn->pcb.ip != NULL) {
  81c417:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c41b:	48 8b 00             	mov    (%rax),%rax
  81c41e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c422:	48 85 c0             	test   %rax,%rax
  81c425:	0f 84 40 01 00 00    	je     81c56b <do_getaddr+0x160>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  81c42b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c42f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c433:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c437:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  81c43b:	84 d2                	test   %dl,%dl
  81c43d:	74 11                	je     81c450 <do_getaddr+0x45>
  81c43f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c443:	48 8b 12             	mov    (%rdx),%rdx
  81c446:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c44a:	8b 12                	mov    (%rdx),%edx
  81c44c:	89 10                	mov    %edx,(%rax)
  81c44e:	eb 10                	jmp    81c460 <do_getaddr+0x55>
  81c450:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c454:	48 8b 12             	mov    (%rdx),%rdx
  81c457:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c45b:	8b 52 04             	mov    0x4(%rdx),%edx
  81c45e:	89 10                	mov    %edx,(%rax)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81c460:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c464:	48 8b 00             	mov    (%rax),%rax
  81c467:	8b 00                	mov    (%rax),%eax
  81c469:	25 f0 00 00 00       	and    $0xf0,%eax
  81c46e:	83 f8 20             	cmp    $0x20,%eax
  81c471:	74 51                	je     81c4c4 <do_getaddr+0xb9>
  81c473:	83 f8 40             	cmp    $0x40,%eax
  81c476:	74 0e                	je     81c486 <do_getaddr+0x7b>
  81c478:	83 f8 10             	cmp    $0x10,%eax
  81c47b:	0f 84 b0 00 00 00    	je     81c531 <do_getaddr+0x126>
  81c481:	e9 f0 00 00 00       	jmpq   81c576 <do_getaddr+0x16b>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  81c486:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c48a:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81c48e:	84 c0                	test   %al,%al
  81c490:	74 22                	je     81c4b4 <do_getaddr+0xa9>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  81c492:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c496:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c49a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c49e:	48 8b 12             	mov    (%rdx),%rdx
  81c4a1:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c4a5:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  81c4a9:	0f b6 d2             	movzbl %dl,%edx
  81c4ac:	66 89 10             	mov    %dx,(%rax)
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
      }
      break;
  81c4af:	e9 c2 00 00 00       	jmpq   81c576 <do_getaddr+0x16b>
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  81c4b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c4b8:	48 8b 00             	mov    (%rax),%rax
  81c4bb:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
      }
      break;
  81c4bf:	e9 b2 00 00 00       	jmpq   81c576 <do_getaddr+0x16b>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  81c4c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c4c8:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81c4cc:	84 c0                	test   %al,%al
  81c4ce:	74 1f                	je     81c4ef <do_getaddr+0xe4>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  81c4d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c4d4:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c4d8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c4dc:	48 8b 12             	mov    (%rdx),%rdx
  81c4df:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c4e3:	0f b7 52 1a          	movzwl 0x1a(%rdx),%edx
  81c4e7:	66 89 10             	mov    %dx,(%rax)
          msg->conn->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
  81c4ea:	e9 87 00 00 00       	jmpq   81c576 <do_getaddr+0x16b>
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  81c4ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c4f3:	48 8b 00             	mov    (%rax),%rax
  81c4f6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c4fa:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81c4fe:	0f b6 c0             	movzbl %al,%eax
  81c501:	83 e0 04             	and    $0x4,%eax
  81c504:	85 c0                	test   %eax,%eax
  81c506:	75 0d                	jne    81c515 <do_getaddr+0x10a>
          msg->conn->err = ERR_CONN;
  81c508:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c50c:	48 8b 00             	mov    (%rax),%rax
  81c50f:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
  81c513:	eb 61                	jmp    81c576 <do_getaddr+0x16b>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
          msg->conn->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  81c515:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c519:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c51d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81c521:	48 8b 12             	mov    (%rdx),%rdx
  81c524:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81c528:	0f b7 52 1c          	movzwl 0x1c(%rdx),%edx
  81c52c:	66 89 10             	mov    %dx,(%rax)
        }
      }
      break;
  81c52f:	eb 45                	jmp    81c576 <do_getaddr+0x16b>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  81c531:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c535:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81c539:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c53d:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81c541:	84 c0                	test   %al,%al
  81c543:	74 11                	je     81c556 <do_getaddr+0x14b>
  81c545:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c549:	48 8b 00             	mov    (%rax),%rax
  81c54c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c550:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  81c554:	eb 0f                	jmp    81c565 <do_getaddr+0x15a>
  81c556:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c55a:	48 8b 00             	mov    (%rax),%rax
  81c55d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c561:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  81c565:	66 89 02             	mov    %ax,(%rdx)
      break;
  81c568:	90                   	nop
  81c569:	eb 0b                	jmp    81c576 <do_getaddr+0x16b>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  81c56b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c56f:	48 8b 00             	mov    (%rax),%rax
  81c572:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
  }
  TCPIP_APIMSG_ACK(msg);
  81c576:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c57a:	48 8b 00             	mov    (%rax),%rax
  81c57d:	8b 40 14             	mov    0x14(%rax),%eax
  81c580:	89 c7                	mov    %eax,%edi
  81c582:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  81c589:	00 00 00 
  81c58c:	ff d0                	callq  *%rax
}
  81c58e:	90                   	nop
  81c58f:	c9                   	leaveq 
  81c590:	c3                   	retq   

000000000081c591 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  81c591:	55                   	push   %rbp
  81c592:	48 89 e5             	mov    %rsp,%rbp
  81c595:	48 83 ec 10          	sub    $0x10,%rsp
  81c599:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  81c59d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c5a1:	48 8b 00             	mov    (%rax),%rax
  81c5a4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81c5a8:	48 85 c0             	test   %rax,%rax
  81c5ab:	74 34                	je     81c5e1 <do_close+0x50>
  81c5ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c5b1:	48 8b 00             	mov    (%rax),%rax
  81c5b4:	8b 00                	mov    (%rax),%eax
  81c5b6:	83 f8 10             	cmp    $0x10,%eax
  81c5b9:	75 26                	jne    81c5e1 <do_close+0x50>
      msg->conn->state = NETCONN_CLOSE;
  81c5bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c5bf:	48 8b 00             	mov    (%rax),%rax
  81c5c2:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%rax)
      do_close_internal(msg->conn);
  81c5c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c5cd:	48 8b 00             	mov    (%rax),%rax
  81c5d0:	48 89 c7             	mov    %rax,%rdi
  81c5d3:	48 b8 31 b5 81 00 00 	movabs $0x81b531,%rax
  81c5da:	00 00 00 
  81c5dd:	ff d0                	callq  *%rax
  81c5df:	eb 23                	jmp    81c604 <do_close+0x73>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  81c5e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c5e5:	48 8b 00             	mov    (%rax),%rax
  81c5e8:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
    TCPIP_APIMSG_ACK(msg);
  81c5ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c5f0:	48 8b 00             	mov    (%rax),%rax
  81c5f3:	8b 40 14             	mov    0x14(%rax),%eax
  81c5f6:	89 c7                	mov    %eax,%edi
  81c5f8:	48 b8 dc 81 81 00 00 	movabs $0x8181dc,%rax
  81c5ff:	00 00 00 
  81c602:	ff d0                	callq  *%rax
  }
}
  81c604:	90                   	nop
  81c605:	c9                   	leaveq 
  81c606:	c3                   	retq   

000000000081c607 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  81c607:	55                   	push   %rbp
  81c608:	48 89 e5             	mov    %rsp,%rbp
  81c60b:	53                   	push   %rbx
  81c60c:	48 83 ec 38          	sub    $0x38,%rsp
  81c610:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81c614:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  81c618:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c61c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81c620:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c627:	00 00 00 
  81c62a:	48 89 10             	mov    %rdx,(%rax)
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  81c62d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c631:	48 8b 58 08          	mov    0x8(%rax),%rbx
  81c635:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c63c:	00 00 00 
  81c63f:	48 8b 00             	mov    (%rax),%rax
  81c642:	0f b7 00             	movzwl (%rax),%eax
  81c645:	0f b7 c0             	movzwl %ax,%eax
  81c648:	89 c7                	mov    %eax,%edi
  81c64a:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81c651:	00 00 00 
  81c654:	ff d0                	callq  *%rax
  81c656:	66 c1 e8 08          	shr    $0x8,%ax
  81c65a:	0f b7 c0             	movzwl %ax,%eax
  81c65d:	83 e0 0f             	and    $0xf,%eax
  81c660:	c1 e0 02             	shl    $0x2,%eax
  81c663:	48 98                	cltq   
  81c665:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  81c669:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c670:	00 00 00 
  81c673:	48 89 10             	mov    %rdx,(%rax)
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  81c676:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c67d:	00 00 00 
  81c680:	48 8b 00             	mov    (%rax),%rax
  81c683:	0f b7 00             	movzwl (%rax),%eax
  81c686:	0f b7 c0             	movzwl %ax,%eax
  81c689:	89 c7                	mov    %eax,%edi
  81c68b:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81c692:	00 00 00 
  81c695:	ff d0                	callq  *%rax
  81c697:	66 c1 e8 08          	shr    $0x8,%ax
  81c69b:	83 e0 0f             	and    $0xf,%eax
  81c69e:	c1 e0 02             	shl    $0x2,%eax
  81c6a1:	f7 d8                	neg    %eax
  81c6a3:	0f bf d0             	movswl %ax,%edx
  81c6a6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c6aa:	89 d6                	mov    %edx,%esi
  81c6ac:	48 89 c7             	mov    %rax,%rdi
  81c6af:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  81c6b6:	00 00 00 
  81c6b9:	ff d0                	callq  *%rax
  81c6bb:	84 c0                	test   %al,%al
  81c6bd:	75 0e                	jne    81c6cd <tcp_input+0xc6>
  81c6bf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c6c3:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81c6c7:	66 83 f8 13          	cmp    $0x13,%ax
  81c6cb:	77 18                	ja     81c6e5 <tcp_input+0xde>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c6cd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c6d1:	48 89 c7             	mov    %rax,%rdi
  81c6d4:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81c6db:	00 00 00 
  81c6de:	ff d0                	callq  *%rax
    return;
  81c6e0:	e9 ec 0b 00 00       	jmpq   81d2d1 <tcp_input+0xcca>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  81c6e5:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c6ec:	00 00 00 
  81c6ef:	48 8b 00             	mov    (%rax),%rax
  81c6f2:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81c6f6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81c6fa:	48 89 c6             	mov    %rax,%rsi
  81c6fd:	48 89 d7             	mov    %rdx,%rdi
  81c700:	48 b8 eb 0d 81 00 00 	movabs $0x810deb,%rax
  81c707:	00 00 00 
  81c70a:	ff d0                	callq  *%rax
  81c70c:	84 c0                	test   %al,%al
  81c70e:	75 38                	jne    81c748 <tcp_input+0x141>
      ip_addr_ismulticast(&(iphdr->dest))) {
  81c710:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c717:	00 00 00 
  81c71a:	48 8b 00             	mov    (%rax),%rax
  81c71d:	8b 58 10             	mov    0x10(%rax),%ebx
  81c720:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  81c725:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  81c72c:	00 00 00 
  81c72f:	ff d0                	callq  *%rax
  81c731:	21 c3                	and    %eax,%ebx
  81c733:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81c738:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  81c73f:	00 00 00 
  81c742:	ff d0                	callq  *%rax
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  81c744:	39 c3                	cmp    %eax,%ebx
  81c746:	75 18                	jne    81c760 <tcp_input+0x159>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c748:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c74c:	48 89 c7             	mov    %rax,%rdi
  81c74f:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81c756:	00 00 00 
  81c759:	ff d0                	callq  *%rax
    return;
  81c75b:	e9 71 0b 00 00       	jmpq   81d2d1 <tcp_input+0xcca>

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len) != 0) {
  81c760:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c764:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81c768:	0f b7 c8             	movzwl %ax,%ecx
      (struct ip_addr *)&(iphdr->dest),
  81c76b:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c772:	00 00 00 
  81c775:	48 8b 00             	mov    (%rax),%rax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81c778:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81c77c:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c783:	00 00 00 
  81c786:	48 8b 00             	mov    (%rax),%rax
  81c789:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  81c78d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c791:	41 89 c8             	mov    %ecx,%r8d
  81c794:	b9 06 00 00 00       	mov    $0x6,%ecx
  81c799:	48 89 c7             	mov    %rax,%rdi
  81c79c:	48 b8 93 28 81 00 00 	movabs $0x812893,%rax
  81c7a3:	00 00 00 
  81c7a6:	ff d0                	callq  *%rax
  81c7a8:	66 85 c0             	test   %ax,%ax
  81c7ab:	74 18                	je     81c7c5 <tcp_input+0x1be>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c7ad:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c7b1:	48 89 c7             	mov    %rax,%rdi
  81c7b4:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81c7bb:	00 00 00 
  81c7be:	ff d0                	callq  *%rax
    return;
  81c7c0:	e9 0c 0b 00 00       	jmpq   81d2d1 <tcp_input+0xcca>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  81c7c5:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c7cc:	00 00 00 
  81c7cf:	48 8b 00             	mov    (%rax),%rax
  81c7d2:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81c7d6:	0f b7 c0             	movzwl %ax,%eax
  81c7d9:	89 c7                	mov    %eax,%edi
  81c7db:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81c7e2:	00 00 00 
  81c7e5:	ff d0                	callq  *%rax
  81c7e7:	66 c1 e8 0c          	shr    $0xc,%ax
  81c7eb:	88 45 d6             	mov    %al,-0x2a(%rbp)
  if(pbuf_header(p, -(hdrlen * 4))){
  81c7ee:	0f b6 55 d6          	movzbl -0x2a(%rbp),%edx
  81c7f2:	b8 00 00 00 00       	mov    $0x0,%eax
  81c7f7:	29 d0                	sub    %edx,%eax
  81c7f9:	c1 e0 02             	shl    $0x2,%eax
  81c7fc:	0f bf d0             	movswl %ax,%edx
  81c7ff:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c803:	89 d6                	mov    %edx,%esi
  81c805:	48 89 c7             	mov    %rax,%rdi
  81c808:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  81c80f:	00 00 00 
  81c812:	ff d0                	callq  *%rax
  81c814:	84 c0                	test   %al,%al
  81c816:	74 18                	je     81c830 <tcp_input+0x229>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c818:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c81c:	48 89 c7             	mov    %rax,%rdi
  81c81f:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81c826:	00 00 00 
  81c829:	ff d0                	callq  *%rax
    return;
  81c82b:	e9 a1 0a 00 00       	jmpq   81d2d1 <tcp_input+0xcca>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  81c830:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c837:	00 00 00 
  81c83a:	48 8b 18             	mov    (%rax),%rbx
  81c83d:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c844:	00 00 00 
  81c847:	48 8b 00             	mov    (%rax),%rax
  81c84a:	0f b7 00             	movzwl (%rax),%eax
  81c84d:	0f b7 c0             	movzwl %ax,%eax
  81c850:	89 c7                	mov    %eax,%edi
  81c852:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81c859:	00 00 00 
  81c85c:	ff d0                	callq  *%rax
  81c85e:	66 89 03             	mov    %ax,(%rbx)
  tcphdr->dest = ntohs(tcphdr->dest);
  81c861:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c868:	00 00 00 
  81c86b:	48 8b 18             	mov    (%rax),%rbx
  81c86e:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c875:	00 00 00 
  81c878:	48 8b 00             	mov    (%rax),%rax
  81c87b:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  81c87f:	0f b7 c0             	movzwl %ax,%eax
  81c882:	89 c7                	mov    %eax,%edi
  81c884:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81c88b:	00 00 00 
  81c88e:	ff d0                	callq  *%rax
  81c890:	66 89 43 02          	mov    %ax,0x2(%rbx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  81c894:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c89b:	00 00 00 
  81c89e:	48 8b 18             	mov    (%rax),%rbx
  81c8a1:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c8a8:	00 00 00 
  81c8ab:	48 8b 00             	mov    (%rax),%rax
  81c8ae:	8b 40 04             	mov    0x4(%rax),%eax
  81c8b1:	89 c7                	mov    %eax,%edi
  81c8b3:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  81c8ba:	00 00 00 
  81c8bd:	ff d0                	callq  *%rax
  81c8bf:	89 43 04             	mov    %eax,0x4(%rbx)
  81c8c2:	8b 53 04             	mov    0x4(%rbx),%edx
  81c8c5:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81c8cc:	00 00 00 
  81c8cf:	89 10                	mov    %edx,(%rax)
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  81c8d1:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c8d8:	00 00 00 
  81c8db:	48 8b 18             	mov    (%rax),%rbx
  81c8de:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c8e5:	00 00 00 
  81c8e8:	48 8b 00             	mov    (%rax),%rax
  81c8eb:	8b 40 08             	mov    0x8(%rax),%eax
  81c8ee:	89 c7                	mov    %eax,%edi
  81c8f0:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  81c8f7:	00 00 00 
  81c8fa:	ff d0                	callq  *%rax
  81c8fc:	89 43 08             	mov    %eax,0x8(%rbx)
  81c8ff:	8b 53 08             	mov    0x8(%rbx),%edx
  81c902:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81c909:	00 00 00 
  81c90c:	89 10                	mov    %edx,(%rax)
  tcphdr->wnd = ntohs(tcphdr->wnd);
  81c90e:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c915:	00 00 00 
  81c918:	48 8b 18             	mov    (%rax),%rbx
  81c91b:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c922:	00 00 00 
  81c925:	48 8b 00             	mov    (%rax),%rax
  81c928:	0f b7 40 0e          	movzwl 0xe(%rax),%eax
  81c92c:	0f b7 c0             	movzwl %ax,%eax
  81c92f:	89 c7                	mov    %eax,%edi
  81c931:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81c938:	00 00 00 
  81c93b:	ff d0                	callq  *%rax
  81c93d:	66 89 43 0e          	mov    %ax,0xe(%rbx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  81c941:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c948:	00 00 00 
  81c94b:	48 8b 00             	mov    (%rax),%rax
  81c94e:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81c952:	0f b7 c0             	movzwl %ax,%eax
  81c955:	89 c7                	mov    %eax,%edi
  81c957:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81c95e:	00 00 00 
  81c961:	ff d0                	callq  *%rax
  81c963:	83 e0 3f             	and    $0x3f,%eax
  81c966:	89 c2                	mov    %eax,%edx
  81c968:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81c96f:	00 00 00 
  81c972:	88 10                	mov    %dl,(%rax)
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  81c974:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c978:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81c97c:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81c983:	00 00 00 
  81c986:	0f b6 00             	movzbl (%rax),%eax
  81c989:	0f b6 c0             	movzbl %al,%eax
  81c98c:	83 e0 01             	and    $0x1,%eax
  81c98f:	85 c0                	test   %eax,%eax
  81c991:	75 17                	jne    81c9aa <tcp_input+0x3a3>
  81c993:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81c99a:	00 00 00 
  81c99d:	0f b6 00             	movzbl (%rax),%eax
  81c9a0:	0f b6 c0             	movzbl %al,%eax
  81c9a3:	83 e0 02             	and    $0x2,%eax
  81c9a6:	85 c0                	test   %eax,%eax
  81c9a8:	74 07                	je     81c9b1 <tcp_input+0x3aa>
  81c9aa:	b8 01 00 00 00       	mov    $0x1,%eax
  81c9af:	eb 05                	jmp    81c9b6 <tcp_input+0x3af>
  81c9b1:	b8 00 00 00 00       	mov    $0x0,%eax
  81c9b6:	01 c2                	add    %eax,%edx
  81c9b8:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81c9bf:	00 00 00 
  81c9c2:	66 89 10             	mov    %dx,(%rax)

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  81c9c5:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81c9cc:	00 

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81c9cd:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81c9d4:	00 00 00 
  81c9d7:	48 8b 00             	mov    (%rax),%rax
  81c9da:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c9de:	e9 e2 01 00 00       	jmpq   81cbc5 <tcp_input+0x5be>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  81c9e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c9e7:	8b 40 18             	mov    0x18(%rax),%eax
  81c9ea:	85 c0                	test   %eax,%eax
  81c9ec:	75 2a                	jne    81ca18 <tcp_input+0x411>
  81c9ee:	48 ba 00 3c 82 00 00 	movabs $0x823c00,%rdx
  81c9f5:	00 00 00 
  81c9f8:	be b6 00 00 00       	mov    $0xb6,%esi
  81c9fd:	48 bf 27 3c 82 00 00 	movabs $0x823c27,%rdi
  81ca04:	00 00 00 
  81ca07:	b8 00 00 00 00       	mov    $0x0,%eax
  81ca0c:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81ca13:	00 00 00 
  81ca16:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  81ca18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca1c:	8b 40 18             	mov    0x18(%rax),%eax
  81ca1f:	83 f8 0a             	cmp    $0xa,%eax
  81ca22:	75 2a                	jne    81ca4e <tcp_input+0x447>
  81ca24:	48 ba 40 3c 82 00 00 	movabs $0x823c40,%rdx
  81ca2b:	00 00 00 
  81ca2e:	be b7 00 00 00       	mov    $0xb7,%esi
  81ca33:	48 bf 27 3c 82 00 00 	movabs $0x823c27,%rdi
  81ca3a:	00 00 00 
  81ca3d:	b8 00 00 00 00       	mov    $0x0,%eax
  81ca42:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81ca49:	00 00 00 
  81ca4c:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  81ca4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca52:	8b 40 18             	mov    0x18(%rax),%eax
  81ca55:	83 f8 01             	cmp    $0x1,%eax
  81ca58:	75 2a                	jne    81ca84 <tcp_input+0x47d>
  81ca5a:	48 ba 70 3c 82 00 00 	movabs $0x823c70,%rdx
  81ca61:	00 00 00 
  81ca64:	be b8 00 00 00       	mov    $0xb8,%esi
  81ca69:	48 bf 27 3c 82 00 00 	movabs $0x823c27,%rdi
  81ca70:	00 00 00 
  81ca73:	b8 00 00 00 00       	mov    $0x0,%eax
  81ca78:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81ca7f:	00 00 00 
  81ca82:	ff d1                	callq  *%rcx
    if (pcb->remote_port == tcphdr->src &&
  81ca84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca88:	0f b7 50 2a          	movzwl 0x2a(%rax),%edx
  81ca8c:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81ca93:	00 00 00 
  81ca96:	48 8b 00             	mov    (%rax),%rax
  81ca99:	0f b7 00             	movzwl (%rax),%eax
  81ca9c:	66 39 c2             	cmp    %ax,%dx
  81ca9f:	0f 85 0c 01 00 00    	jne    81cbb1 <tcp_input+0x5aa>
       pcb->local_port == tcphdr->dest &&
  81caa5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81caa9:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81caad:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cab4:	00 00 00 
  81cab7:	48 8b 00             	mov    (%rax),%rax
  81caba:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  81cabe:	66 39 c2             	cmp    %ax,%dx
  81cac1:	0f 85 ea 00 00 00    	jne    81cbb1 <tcp_input+0x5aa>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81cac7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cacb:	8b 50 04             	mov    0x4(%rax),%edx
  81cace:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cad5:	00 00 00 
  81cad8:	48 8b 00             	mov    (%rax),%rax
  81cadb:	8b 40 0c             	mov    0xc(%rax),%eax
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
  81cade:	39 c2                	cmp    %eax,%edx
  81cae0:	0f 85 cb 00 00 00    	jne    81cbb1 <tcp_input+0x5aa>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  81cae6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81caea:	8b 10                	mov    (%rax),%edx
  81caec:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81caf3:	00 00 00 
  81caf6:	48 8b 00             	mov    (%rax),%rax
  81caf9:	8b 40 10             	mov    0x10(%rax),%eax
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81cafc:	39 c2                	cmp    %eax,%edx
  81cafe:	0f 85 ad 00 00 00    	jne    81cbb1 <tcp_input+0x5aa>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  81cb04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb08:	48 8b 40 10          	mov    0x10(%rax),%rax
  81cb0c:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81cb10:	75 2a                	jne    81cb3c <tcp_input+0x535>
  81cb12:	48 ba 98 3c 82 00 00 	movabs $0x823c98,%rdx
  81cb19:	00 00 00 
  81cb1c:	be c1 00 00 00       	mov    $0xc1,%esi
  81cb21:	48 bf 27 3c 82 00 00 	movabs $0x823c27,%rdi
  81cb28:	00 00 00 
  81cb2b:	b8 00 00 00 00       	mov    $0x0,%eax
  81cb30:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81cb37:	00 00 00 
  81cb3a:	ff d1                	callq  *%rcx
      if (prev != NULL) {
  81cb3c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81cb41:	74 36                	je     81cb79 <tcp_input+0x572>
        prev->next = pcb->next;
  81cb43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb47:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81cb4b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81cb4f:	48 89 50 10          	mov    %rdx,0x10(%rax)
        pcb->next = tcp_active_pcbs;
  81cb53:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81cb5a:	00 00 00 
  81cb5d:	48 8b 10             	mov    (%rax),%rdx
  81cb60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb64:	48 89 50 10          	mov    %rdx,0x10(%rax)
        tcp_active_pcbs = pcb;
  81cb68:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81cb6f:	00 00 00 
  81cb72:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81cb76:	48 89 10             	mov    %rdx,(%rax)
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  81cb79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb7d:	48 8b 40 10          	mov    0x10(%rax),%rax
  81cb81:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81cb85:	75 4b                	jne    81cbd2 <tcp_input+0x5cb>
  81cb87:	48 ba c8 3c 82 00 00 	movabs $0x823cc8,%rdx
  81cb8e:	00 00 00 
  81cb91:	be c7 00 00 00       	mov    $0xc7,%esi
  81cb96:	48 bf 27 3c 82 00 00 	movabs $0x823c27,%rdi
  81cb9d:	00 00 00 
  81cba0:	b8 00 00 00 00       	mov    $0x0,%eax
  81cba5:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81cbac:	00 00 00 
  81cbaf:	ff d1                	callq  *%rcx
      break;
    }
    prev = pcb;
  81cbb1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cbb5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81cbb9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cbbd:	48 8b 40 10          	mov    0x10(%rax),%rax
  81cbc1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81cbc5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81cbca:	0f 85 13 fe ff ff    	jne    81c9e3 <tcp_input+0x3dc>
  81cbd0:	eb 01                	jmp    81cbd3 <tcp_input+0x5cc>
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
  81cbd2:	90                   	nop
    }
    prev = pcb;
  }

  if (pcb == NULL) {
  81cbd3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81cbd8:	0f 85 f2 01 00 00    	jne    81cdd0 <tcp_input+0x7c9>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  81cbde:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81cbe5:	00 00 00 
  81cbe8:	48 8b 00             	mov    (%rax),%rax
  81cbeb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81cbef:	e9 dd 00 00 00       	jmpq   81ccd1 <tcp_input+0x6ca>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  81cbf4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cbf8:	8b 40 18             	mov    0x18(%rax),%eax
  81cbfb:	83 f8 0a             	cmp    $0xa,%eax
  81cbfe:	74 2a                	je     81cc2a <tcp_input+0x623>
  81cc00:	48 ba f8 3c 82 00 00 	movabs $0x823cf8,%rdx
  81cc07:	00 00 00 
  81cc0a:	be d1 00 00 00       	mov    $0xd1,%esi
  81cc0f:	48 bf 27 3c 82 00 00 	movabs $0x823c27,%rdi
  81cc16:	00 00 00 
  81cc19:	b8 00 00 00 00       	mov    $0x0,%eax
  81cc1e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81cc25:	00 00 00 
  81cc28:	ff d1                	callq  *%rcx
      if (pcb->remote_port == tcphdr->src &&
  81cc2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc2e:	0f b7 50 2a          	movzwl 0x2a(%rax),%edx
  81cc32:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cc39:	00 00 00 
  81cc3c:	48 8b 00             	mov    (%rax),%rax
  81cc3f:	0f b7 00             	movzwl (%rax),%eax
  81cc42:	66 39 c2             	cmp    %ax,%dx
  81cc45:	75 7e                	jne    81ccc5 <tcp_input+0x6be>
         pcb->local_port == tcphdr->dest &&
  81cc47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc4b:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81cc4f:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cc56:	00 00 00 
  81cc59:	48 8b 00             	mov    (%rax),%rax
  81cc5c:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
  81cc60:	66 39 c2             	cmp    %ax,%dx
  81cc63:	75 60                	jne    81ccc5 <tcp_input+0x6be>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81cc65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc69:	8b 50 04             	mov    0x4(%rax),%edx
  81cc6c:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cc73:	00 00 00 
  81cc76:	48 8b 00             	mov    (%rax),%rax
  81cc79:	8b 40 0c             	mov    0xc(%rax),%eax
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
  81cc7c:	39 c2                	cmp    %eax,%edx
  81cc7e:	75 45                	jne    81ccc5 <tcp_input+0x6be>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  81cc80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc84:	8b 10                	mov    (%rax),%edx
  81cc86:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cc8d:	00 00 00 
  81cc90:	48 8b 00             	mov    (%rax),%rax
  81cc93:	8b 40 10             	mov    0x10(%rax),%eax
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81cc96:	39 c2                	cmp    %eax,%edx
  81cc98:	75 2b                	jne    81ccc5 <tcp_input+0x6be>
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
  81cc9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc9e:	48 89 c7             	mov    %rax,%rdi
  81cca1:	48 b8 dc d5 81 00 00 	movabs $0x81d5dc,%rax
  81cca8:	00 00 00 
  81ccab:	ff d0                	callq  *%rax
        pbuf_free(p);
  81ccad:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ccb1:	48 89 c7             	mov    %rax,%rdi
  81ccb4:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81ccbb:	00 00 00 
  81ccbe:	ff d0                	callq  *%rax
        return;
  81ccc0:	e9 0c 06 00 00       	jmpq   81d2d1 <tcp_input+0xcca>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  81ccc5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ccc9:	48 8b 40 10          	mov    0x10(%rax),%rax
  81cccd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81ccd1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81ccd6:	0f 85 18 ff ff ff    	jne    81cbf4 <tcp_input+0x5ed>
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  81ccdc:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81cce3:	00 
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  81cce4:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81cceb:	00 00 00 
  81ccee:	48 8b 00             	mov    (%rax),%rax
  81ccf1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81ccf5:	e9 cb 00 00 00       	jmpq   81cdc5 <tcp_input+0x7be>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  81ccfa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ccfe:	48 85 c0             	test   %rax,%rax
  81cd01:	74 28                	je     81cd2b <tcp_input+0x724>
  81cd03:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cd07:	8b 00                	mov    (%rax),%eax
  81cd09:	85 c0                	test   %eax,%eax
  81cd0b:	74 1e                	je     81cd2b <tcp_input+0x724>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  81cd0d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cd11:	8b 10                	mov    (%rax),%edx
  81cd13:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cd1a:	00 00 00 
  81cd1d:	48 8b 00             	mov    (%rax),%rax
  81cd20:	8b 40 10             	mov    0x10(%rax),%eax

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  81cd23:	39 c2                	cmp    %eax,%edx
  81cd25:	0f 85 86 00 00 00    	jne    81cdb1 <tcp_input+0x7aa>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
        lpcb->local_port == tcphdr->dest) {
  81cd2b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cd2f:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81cd33:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cd3a:	00 00 00 
  81cd3d:	48 8b 00             	mov    (%rax),%rax
  81cd40:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  81cd44:	66 39 c2             	cmp    %ax,%dx
  81cd47:	75 68                	jne    81cdb1 <tcp_input+0x7aa>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  81cd49:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81cd4e:	74 36                	je     81cd86 <tcp_input+0x77f>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  81cd50:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cd54:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81cd58:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81cd5c:	48 89 50 10          	mov    %rdx,0x10(%rax)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  81cd60:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81cd67:	00 00 00 
  81cd6a:	48 8b 10             	mov    (%rax),%rdx
  81cd6d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cd71:	48 89 50 10          	mov    %rdx,0x10(%rax)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  81cd75:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81cd7c:	00 00 00 
  81cd7f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81cd83:	48 89 10             	mov    %rdx,(%rax)
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
  81cd86:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cd8a:	48 89 c7             	mov    %rax,%rdi
  81cd8d:	48 b8 d8 d2 81 00 00 	movabs $0x81d2d8,%rax
  81cd94:	00 00 00 
  81cd97:	ff d0                	callq  *%rax
        pbuf_free(p);
  81cd99:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81cd9d:	48 89 c7             	mov    %rax,%rdi
  81cda0:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81cda7:	00 00 00 
  81cdaa:	ff d0                	callq  *%rax
        return;
  81cdac:	e9 20 05 00 00       	jmpq   81d2d1 <tcp_input+0xcca>
      }
      prev = (struct tcp_pcb *)lpcb;
  81cdb1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cdb5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  81cdb9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cdbd:	48 8b 40 10          	mov    0x10(%rax),%rax
  81cdc1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81cdc5:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81cdca:	0f 85 2a ff ff ff    	jne    81ccfa <tcp_input+0x6f3>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  81cdd0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81cdd5:	0f 84 2b 04 00 00    	je     81d206 <tcp_input+0xbff>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  81cddb:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cde2:	00 00 00 
  81cde5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    inseg.len = p->tot_len;
  81cdec:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81cdf0:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81cdf4:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81cdfb:	00 00 00 
  81cdfe:	66 89 50 18          	mov    %dx,0x18(%rax)
    inseg.dataptr = p->payload;
  81ce02:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ce06:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81ce0a:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ce11:	00 00 00 
  81ce14:	48 89 50 10          	mov    %rdx,0x10(%rax)
    inseg.p = p;
  81ce18:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ce1f:	00 00 00 
  81ce22:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81ce26:	48 89 50 08          	mov    %rdx,0x8(%rax)
    inseg.tcphdr = tcphdr;
  81ce2a:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81ce31:	00 00 00 
  81ce34:	48 8b 10             	mov    (%rax),%rdx
  81ce37:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ce3e:	00 00 00 
  81ce41:	48 89 50 20          	mov    %rdx,0x20(%rax)

    recv_data = NULL;
  81ce45:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81ce4c:	00 00 00 
  81ce4f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    recv_flags = 0;
  81ce56:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81ce5d:	00 00 00 
  81ce60:	c6 00 00             	movb   $0x0,(%rax)

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  81ce63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce67:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81ce6e:	48 85 c0             	test   %rax,%rax
  81ce71:	0f 84 9b 00 00 00    	je     81cf12 <tcp_input+0x90b>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  81ce77:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce7b:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81ce82:	48 85 c0             	test   %rax,%rax
  81ce85:	74 2e                	je     81ceb5 <tcp_input+0x8ae>
  81ce87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce8b:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81ce92:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81ce96:	48 8b 92 98 00 00 00 	mov    0x98(%rdx),%rdx
  81ce9d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81cea1:	48 8b 79 20          	mov    0x20(%rcx),%rdi
  81cea5:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81cea9:	b9 00 00 00 00       	mov    $0x0,%ecx
  81ceae:	ff d0                	callq  *%rax
  81ceb0:	88 45 d7             	mov    %al,-0x29(%rbp)
  81ceb3:	eb 2e                	jmp    81cee3 <tcp_input+0x8dc>
  81ceb5:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
  81ceb9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cebd:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81cec4:	48 85 c0             	test   %rax,%rax
  81cec7:	74 1a                	je     81cee3 <tcp_input+0x8dc>
  81cec9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cecd:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81ced4:	48 89 c7             	mov    %rax,%rdi
  81ced7:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81cede:	00 00 00 
  81cee1:	ff d0                	callq  *%rax
      if (err == ERR_OK) {
  81cee3:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81cee7:	75 11                	jne    81cefa <tcp_input+0x8f3>
        pcb->refused_data = NULL;
  81cee9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ceed:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  81cef4:	00 00 00 00 
  81cef8:	eb 18                	jmp    81cf12 <tcp_input+0x90b>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  81cefa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81cefe:	48 89 c7             	mov    %rax,%rdi
  81cf01:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81cf08:	00 00 00 
  81cf0b:	ff d0                	callq  *%rax
        return;
  81cf0d:	e9 bf 03 00 00       	jmpq   81d2d1 <tcp_input+0xcca>
      }
    }

    tcp_input_pcb = pcb;
  81cf12:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  81cf19:	00 00 00 
  81cf1c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81cf20:	48 89 10             	mov    %rdx,(%rax)
    err = tcp_process(pcb);
  81cf23:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cf27:	48 89 c7             	mov    %rax,%rdi
  81cf2a:	48 b8 88 d6 81 00 00 	movabs $0x81d688,%rax
  81cf31:	00 00 00 
  81cf34:	ff d0                	callq  *%rax
  81cf36:	88 45 d7             	mov    %al,-0x29(%rbp)
    tcp_input_pcb = NULL;
  81cf39:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  81cf40:	00 00 00 
  81cf43:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
  81cf4a:	80 7d d7 fb          	cmpb   $0xfb,-0x29(%rbp)
  81cf4e:	0f 84 67 02 00 00    	je     81d1bb <tcp_input+0xbb4>
      if (recv_flags & TF_RESET) {
  81cf54:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81cf5b:	00 00 00 
  81cf5e:	0f b6 00             	movzbl (%rax),%eax
  81cf61:	0f b6 c0             	movzbl %al,%eax
  81cf64:	83 e0 08             	and    $0x8,%eax
  81cf67:	85 c0                	test   %eax,%eax
  81cf69:	74 67                	je     81cfd2 <tcp_input+0x9cb>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  81cf6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cf6f:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  81cf76:	48 85 c0             	test   %rax,%rax
  81cf79:	74 1d                	je     81cf98 <tcp_input+0x991>
  81cf7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cf7f:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  81cf86:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81cf8a:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  81cf8e:	be fa ff ff ff       	mov    $0xfffffffa,%esi
  81cf93:	48 89 d7             	mov    %rdx,%rdi
  81cf96:	ff d0                	callq  *%rax
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81cf98:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cf9c:	48 89 c6             	mov    %rax,%rsi
  81cf9f:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  81cfa6:	00 00 00 
  81cfa9:	48 b8 52 0b 81 00 00 	movabs $0x810b52,%rax
  81cfb0:	00 00 00 
  81cfb3:	ff d0                	callq  *%rax
        memp_free(MEMP_TCP_PCB, pcb);
  81cfb5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cfb9:	48 89 c6             	mov    %rax,%rsi
  81cfbc:	bf 02 00 00 00       	mov    $0x2,%edi
  81cfc1:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  81cfc8:	00 00 00 
  81cfcb:	ff d0                	callq  *%rax
  81cfcd:	e9 e9 01 00 00       	jmpq   81d1bb <tcp_input+0xbb4>
      } else if (recv_flags & TF_CLOSED) {
  81cfd2:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81cfd9:	00 00 00 
  81cfdc:	0f b6 00             	movzbl (%rax),%eax
  81cfdf:	0f b6 c0             	movzbl %al,%eax
  81cfe2:	83 e0 10             	and    $0x10,%eax
  81cfe5:	85 c0                	test   %eax,%eax
  81cfe7:	74 3a                	je     81d023 <tcp_input+0xa1c>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81cfe9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cfed:	48 89 c6             	mov    %rax,%rsi
  81cff0:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  81cff7:	00 00 00 
  81cffa:	48 b8 52 0b 81 00 00 	movabs $0x810b52,%rax
  81d001:	00 00 00 
  81d004:	ff d0                	callq  *%rax
        memp_free(MEMP_TCP_PCB, pcb);
  81d006:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d00a:	48 89 c6             	mov    %rax,%rsi
  81d00d:	bf 02 00 00 00       	mov    $0x2,%edi
  81d012:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  81d019:	00 00 00 
  81d01c:	ff d0                	callq  *%rax
  81d01e:	e9 98 01 00 00       	jmpq   81d1bb <tcp_input+0xbb4>
      } else {
        err = ERR_OK;
  81d023:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  81d027:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d02b:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  81d02f:	66 85 c0             	test   %ax,%ax
  81d032:	74 3a                	je     81d06e <tcp_input+0xa67>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  81d034:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d038:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  81d03f:	48 85 c0             	test   %rax,%rax
  81d042:	74 2a                	je     81d06e <tcp_input+0xa67>
  81d044:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d048:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  81d04f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81d053:	0f b7 52 78          	movzwl 0x78(%rdx),%edx
  81d057:	0f b7 d2             	movzwl %dx,%edx
  81d05a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81d05e:	48 8b 49 20          	mov    0x20(%rcx),%rcx
  81d062:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81d066:	48 89 cf             	mov    %rcx,%rdi
  81d069:	ff d0                	callq  *%rax
  81d06b:	88 45 d7             	mov    %al,-0x29(%rbp)
        }
      
        if (recv_data != NULL) {
  81d06e:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81d075:	00 00 00 
  81d078:	48 8b 00             	mov    (%rax),%rax
  81d07b:	48 85 c0             	test   %rax,%rax
  81d07e:	0f 84 cb 00 00 00    	je     81d14f <tcp_input+0xb48>
          if(flags & TCP_PSH) {
  81d084:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d08b:	00 00 00 
  81d08e:	0f b6 00             	movzbl (%rax),%eax
  81d091:	0f b6 c0             	movzbl %al,%eax
  81d094:	83 e0 08             	and    $0x8,%eax
  81d097:	85 c0                	test   %eax,%eax
  81d099:	74 24                	je     81d0bf <tcp_input+0xab8>
            recv_data->flags |= PBUF_FLAG_PUSH;
  81d09b:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81d0a2:	00 00 00 
  81d0a5:	48 8b 00             	mov    (%rax),%rax
  81d0a8:	48 ba e8 74 b5 00 00 	movabs $0xb574e8,%rdx
  81d0af:	00 00 00 
  81d0b2:	48 8b 12             	mov    (%rdx),%rdx
  81d0b5:	0f b6 52 15          	movzbl 0x15(%rdx),%edx
  81d0b9:	83 ca 01             	or     $0x1,%edx
  81d0bc:	88 50 15             	mov    %dl,0x15(%rax)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  81d0bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d0c3:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81d0ca:	48 85 c0             	test   %rax,%rax
  81d0cd:	74 30                	je     81d0ff <tcp_input+0xaf8>
  81d0cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d0d3:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81d0da:	48 ba e8 74 b5 00 00 	movabs $0xb574e8,%rdx
  81d0e1:	00 00 00 
  81d0e4:	48 8b 12             	mov    (%rdx),%rdx
  81d0e7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81d0eb:	48 8b 79 20          	mov    0x20(%rcx),%rdi
  81d0ef:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81d0f3:	b9 00 00 00 00       	mov    $0x0,%ecx
  81d0f8:	ff d0                	callq  *%rax
  81d0fa:	88 45 d7             	mov    %al,-0x29(%rbp)
  81d0fd:	eb 32                	jmp    81d131 <tcp_input+0xb2a>
  81d0ff:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
  81d103:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81d10a:	00 00 00 
  81d10d:	48 8b 00             	mov    (%rax),%rax
  81d110:	48 85 c0             	test   %rax,%rax
  81d113:	74 1c                	je     81d131 <tcp_input+0xb2a>
  81d115:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81d11c:	00 00 00 
  81d11f:	48 8b 00             	mov    (%rax),%rax
  81d122:	48 89 c7             	mov    %rax,%rdi
  81d125:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81d12c:	00 00 00 
  81d12f:	ff d0                	callq  *%rax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  81d131:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81d135:	74 18                	je     81d14f <tcp_input+0xb48>
            pcb->refused_data = recv_data;
  81d137:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81d13e:	00 00 00 
  81d141:	48 8b 10             	mov    (%rax),%rdx
  81d144:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d148:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  81d14f:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81d156:	00 00 00 
  81d159:	0f b6 00             	movzbl (%rax),%eax
  81d15c:	0f b6 c0             	movzbl %al,%eax
  81d15f:	83 e0 20             	and    $0x20,%eax
  81d162:	85 c0                	test   %eax,%eax
  81d164:	74 3c                	je     81d1a2 <tcp_input+0xb9b>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  81d166:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d16a:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81d171:	48 85 c0             	test   %rax,%rax
  81d174:	74 28                	je     81d19e <tcp_input+0xb97>
  81d176:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d17a:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81d181:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81d185:	48 8b 7a 20          	mov    0x20(%rdx),%rdi
  81d189:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81d18d:	b9 00 00 00 00       	mov    $0x0,%ecx
  81d192:	ba 00 00 00 00       	mov    $0x0,%edx
  81d197:	ff d0                	callq  *%rax
  81d199:	88 45 d7             	mov    %al,-0x29(%rbp)
  81d19c:	eb 04                	jmp    81d1a2 <tcp_input+0xb9b>
  81d19e:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  81d1a2:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81d1a6:	75 13                	jne    81d1bb <tcp_input+0xbb4>
          tcp_output(pcb);
  81d1a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d1ac:	48 89 c7             	mov    %rax,%rdi
  81d1af:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  81d1b6:	00 00 00 
  81d1b9:	ff d0                	callq  *%rax
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  81d1bb:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81d1c2:	00 00 00 
  81d1c5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81d1c9:	48 85 c0             	test   %rax,%rax
  81d1cc:	0f 84 ff 00 00 00    	je     81d2d1 <tcp_input+0xcca>
    {
      pbuf_free(inseg.p);
  81d1d2:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81d1d9:	00 00 00 
  81d1dc:	48 8b 40 08          	mov    0x8(%rax),%rax
  81d1e0:	48 89 c7             	mov    %rax,%rdi
  81d1e3:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81d1ea:	00 00 00 
  81d1ed:	ff d0                	callq  *%rax
      inseg.p = NULL;
  81d1ef:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81d1f6:	00 00 00 
  81d1f9:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81d200:	00 
  81d201:	e9 cb 00 00 00       	jmpq   81d2d1 <tcp_input+0xcca>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  81d206:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d20d:	00 00 00 
  81d210:	48 8b 00             	mov    (%rax),%rax
  81d213:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81d217:	0f b7 c0             	movzwl %ax,%eax
  81d21a:	89 c7                	mov    %eax,%edi
  81d21c:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81d223:	00 00 00 
  81d226:	ff d0                	callq  *%rax
  81d228:	0f b7 c0             	movzwl %ax,%eax
  81d22b:	83 e0 04             	and    $0x4,%eax
  81d22e:	85 c0                	test   %eax,%eax
  81d230:	0f 85 88 00 00 00    	jne    81d2be <tcp_input+0xcb7>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81d236:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d23d:	00 00 00 
  81d240:	48 8b 00             	mov    (%rax),%rax
  81d243:	0f b7 00             	movzwl (%rax),%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81d246:	44 0f b7 c0          	movzwl %ax,%r8d
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81d24a:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d251:	00 00 00 
  81d254:	48 8b 00             	mov    (%rax),%rax
  81d257:	0f b7 40 02          	movzwl 0x2(%rax),%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81d25b:	0f b7 f8             	movzwl %ax,%edi
        &(iphdr->dest), &(iphdr->src),
  81d25e:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d265:	00 00 00 
  81d268:	48 8b 00             	mov    (%rax),%rax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81d26b:	48 8d 48 0c          	lea    0xc(%rax),%rcx
        &(iphdr->dest), &(iphdr->src),
  81d26f:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d276:	00 00 00 
  81d279:	48 8b 00             	mov    (%rax),%rax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81d27c:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81d280:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d287:	00 00 00 
  81d28a:	0f b7 00             	movzwl (%rax),%eax
  81d28d:	0f b7 f0             	movzwl %ax,%esi
  81d290:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d297:	00 00 00 
  81d29a:	8b 00                	mov    (%rax),%eax
  81d29c:	01 c6                	add    %eax,%esi
  81d29e:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d2a5:	00 00 00 
  81d2a8:	8b 00                	mov    (%rax),%eax
  81d2aa:	45 89 c1             	mov    %r8d,%r9d
  81d2ad:	41 89 f8             	mov    %edi,%r8d
  81d2b0:	89 c7                	mov    %eax,%edi
  81d2b2:	48 b8 80 46 81 00 00 	movabs $0x814680,%rax
  81d2b9:	00 00 00 
  81d2bc:	ff d0                	callq  *%rax
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  81d2be:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81d2c2:	48 89 c7             	mov    %rax,%rdi
  81d2c5:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  81d2cc:	00 00 00 
  81d2cf:	ff d0                	callq  *%rax
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  81d2d1:	48 83 c4 38          	add    $0x38,%rsp
  81d2d5:	5b                   	pop    %rbx
  81d2d6:	5d                   	pop    %rbp
  81d2d7:	c3                   	retq   

000000000081d2d8 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
  81d2d8:	55                   	push   %rbp
  81d2d9:	48 89 e5             	mov    %rsp,%rbp
  81d2dc:	48 83 ec 20          	sub    $0x20,%rsp
  81d2e0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  81d2e4:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d2eb:	00 00 00 
  81d2ee:	0f b6 00             	movzbl (%rax),%eax
  81d2f1:	0f b6 c0             	movzbl %al,%eax
  81d2f4:	83 e0 10             	and    $0x10,%eax
  81d2f7:	85 c0                	test   %eax,%eax
  81d2f9:	0f 84 90 00 00 00    	je     81d38f <tcp_listen_input+0xb7>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  81d2ff:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d306:	00 00 00 
  81d309:	48 8b 00             	mov    (%rax),%rax
  81d30c:	0f b7 00             	movzwl (%rax),%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81d30f:	44 0f b7 c0          	movzwl %ax,%r8d
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  81d313:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d31a:	00 00 00 
  81d31d:	48 8b 00             	mov    (%rax),%rax
  81d320:	0f b7 40 02          	movzwl 0x2(%rax),%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81d324:	0f b7 f8             	movzwl %ax,%edi
      &(iphdr->dest), &(iphdr->src),
  81d327:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d32e:	00 00 00 
  81d331:	48 8b 00             	mov    (%rax),%rax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81d334:	48 8d 48 0c          	lea    0xc(%rax),%rcx
      &(iphdr->dest), &(iphdr->src),
  81d338:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d33f:	00 00 00 
  81d342:	48 8b 00             	mov    (%rax),%rax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81d345:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81d349:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d350:	00 00 00 
  81d353:	0f b7 00             	movzwl (%rax),%eax
  81d356:	0f b7 f0             	movzwl %ax,%esi
  81d359:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d360:	00 00 00 
  81d363:	8b 00                	mov    (%rax),%eax
  81d365:	01 c6                	add    %eax,%esi
  81d367:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d36e:	00 00 00 
  81d371:	8b 00                	mov    (%rax),%eax
  81d373:	83 c0 01             	add    $0x1,%eax
  81d376:	45 89 c1             	mov    %r8d,%r9d
  81d379:	41 89 f8             	mov    %edi,%r8d
  81d37c:	89 c7                	mov    %eax,%edi
  81d37e:	48 b8 80 46 81 00 00 	movabs $0x814680,%rax
  81d385:	00 00 00 
  81d388:	ff d0                	callq  *%rax
  81d38a:	e9 46 02 00 00       	jmpq   81d5d5 <tcp_listen_input+0x2fd>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  81d38f:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d396:	00 00 00 
  81d399:	0f b6 00             	movzbl (%rax),%eax
  81d39c:	0f b6 c0             	movzbl %al,%eax
  81d39f:	83 e0 02             	and    $0x2,%eax
  81d3a2:	85 c0                	test   %eax,%eax
  81d3a4:	0f 84 2b 02 00 00    	je     81d5d5 <tcp_listen_input+0x2fd>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  81d3aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d3ae:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  81d3b2:	0f b6 c0             	movzbl %al,%eax
  81d3b5:	89 c7                	mov    %eax,%edi
  81d3b7:	48 b8 b6 07 81 00 00 	movabs $0x8107b6,%rax
  81d3be:	00 00 00 
  81d3c1:	ff d0                	callq  *%rax
  81d3c3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  81d3c7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81d3cc:	75 0a                	jne    81d3d8 <tcp_listen_input+0x100>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
      return ERR_MEM;
  81d3ce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81d3d3:	e9 02 02 00 00       	jmpq   81d5da <tcp_listen_input+0x302>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  81d3d8:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d3df:	00 00 00 
  81d3e2:	48 8b 00             	mov    (%rax),%rax
  81d3e5:	48 83 c0 10          	add    $0x10,%rax
  81d3e9:	48 85 c0             	test   %rax,%rax
  81d3ec:	74 12                	je     81d400 <tcp_listen_input+0x128>
  81d3ee:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d3f5:	00 00 00 
  81d3f8:	48 8b 00             	mov    (%rax),%rax
  81d3fb:	8b 40 10             	mov    0x10(%rax),%eax
  81d3fe:	eb 05                	jmp    81d405 <tcp_listen_input+0x12d>
  81d400:	b8 00 00 00 00       	mov    $0x0,%eax
  81d405:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81d409:	89 02                	mov    %eax,(%rdx)
    npcb->local_port = pcb->local_port;
  81d40b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d40f:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81d413:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d417:	66 89 50 28          	mov    %dx,0x28(%rax)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  81d41b:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d422:	00 00 00 
  81d425:	48 8b 00             	mov    (%rax),%rax
  81d428:	48 83 c0 0c          	add    $0xc,%rax
  81d42c:	48 85 c0             	test   %rax,%rax
  81d42f:	74 12                	je     81d443 <tcp_listen_input+0x16b>
  81d431:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d438:	00 00 00 
  81d43b:	48 8b 00             	mov    (%rax),%rax
  81d43e:	8b 40 0c             	mov    0xc(%rax),%eax
  81d441:	eb 05                	jmp    81d448 <tcp_listen_input+0x170>
  81d443:	b8 00 00 00 00       	mov    $0x0,%eax
  81d448:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81d44c:	89 42 04             	mov    %eax,0x4(%rdx)
    npcb->remote_port = tcphdr->src;
  81d44f:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d456:	00 00 00 
  81d459:	48 8b 00             	mov    (%rax),%rax
  81d45c:	0f b7 10             	movzwl (%rax),%edx
  81d45f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d463:	66 89 50 2a          	mov    %dx,0x2a(%rax)
    npcb->state = SYN_RCVD;
  81d467:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d46b:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%rax)
    npcb->rcv_nxt = seqno + 1;
  81d472:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d479:	00 00 00 
  81d47c:	8b 00                	mov    (%rax),%eax
  81d47e:	8d 50 01             	lea    0x1(%rax),%edx
  81d481:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d485:	89 50 30             	mov    %edx,0x30(%rax)
    npcb->snd_wnd = tcphdr->wnd;
  81d488:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d48f:	00 00 00 
  81d492:	48 8b 00             	mov    (%rax),%rax
  81d495:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81d499:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d49d:	66 89 50 68          	mov    %dx,0x68(%rax)
    npcb->ssthresh = npcb->snd_wnd;
  81d4a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d4a5:	0f b7 50 68          	movzwl 0x68(%rax),%edx
  81d4a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d4ad:	66 89 50 5c          	mov    %dx,0x5c(%rax)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  81d4b1:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d4b8:	00 00 00 
  81d4bb:	8b 00                	mov    (%rax),%eax
  81d4bd:	8d 50 ff             	lea    -0x1(%rax),%edx
  81d4c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d4c4:	89 50 6c             	mov    %edx,0x6c(%rax)
    npcb->callback_arg = pcb->callback_arg;
  81d4c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d4cb:	48 8b 50 20          	mov    0x20(%rax),%rdx
  81d4cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d4d3:	48 89 50 20          	mov    %rdx,0x20(%rax)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  81d4d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d4db:	48 8b 50 30          	mov    0x30(%rax),%rdx
  81d4df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d4e3:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  81d4ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d4ee:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81d4f2:	66 25 99 01          	and    $0x199,%ax
  81d4f6:	89 c2                	mov    %eax,%edx
  81d4f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d4fc:	66 89 50 08          	mov    %dx,0x8(%rax)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  81d500:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d507:	00 00 00 
  81d50a:	48 8b 10             	mov    (%rax),%rdx
  81d50d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d511:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81d515:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d51c:	00 00 00 
  81d51f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81d523:	48 89 10             	mov    %rdx,(%rax)
  81d526:	48 b8 0a 87 80 00 00 	movabs $0x80870a,%rax
  81d52d:	00 00 00 
  81d530:	ff d0                	callq  *%rax

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  81d532:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d536:	48 89 c7             	mov    %rax,%rdi
  81d539:	48 b8 fd fd 81 00 00 	movabs $0x81fdfd,%rax
  81d540:	00 00 00 
  81d543:	ff d0                	callq  *%rax
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  81d545:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d549:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81d54d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d551:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d555:	0f b7 c0             	movzwl %ax,%eax
  81d558:	48 89 d6             	mov    %rdx,%rsi
  81d55b:	89 c7                	mov    %eax,%edi
  81d55d:	48 b8 88 0d 81 00 00 	movabs $0x810d88,%rax
  81d564:	00 00 00 
  81d567:	ff d0                	callq  *%rax
  81d569:	89 c2                	mov    %eax,%edx
  81d56b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d56f:	66 89 50 40          	mov    %dx,0x40(%rax)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  81d573:	bf b4 05 04 02       	mov    $0x20405b4,%edi
  81d578:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  81d57f:	00 00 00 
  81d582:	ff d0                	callq  *%rax
  81d584:	89 45 f4             	mov    %eax,-0xc(%rbp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  81d587:	48 8d 55 f4          	lea    -0xc(%rbp),%rdx
  81d58b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d58f:	48 83 ec 08          	sub    $0x8,%rsp
  81d593:	6a 04                	pushq  $0x4
  81d595:	49 89 d1             	mov    %rdx,%r9
  81d598:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  81d59e:	b9 12 00 00 00       	mov    $0x12,%ecx
  81d5a3:	ba 00 00 00 00       	mov    $0x0,%edx
  81d5a8:	be 00 00 00 00       	mov    $0x0,%esi
  81d5ad:	48 89 c7             	mov    %rax,%rdi
  81d5b0:	48 b8 96 32 81 00 00 	movabs $0x813296,%rax
  81d5b7:	00 00 00 
  81d5ba:	ff d0                	callq  *%rax
  81d5bc:	48 83 c4 10          	add    $0x10,%rsp
    return tcp_output(npcb);
  81d5c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d5c4:	48 89 c7             	mov    %rax,%rdi
  81d5c7:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  81d5ce:	00 00 00 
  81d5d1:	ff d0                	callq  *%rax
  81d5d3:	eb 05                	jmp    81d5da <tcp_listen_input+0x302>
  }
  return ERR_OK;
  81d5d5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81d5da:	c9                   	leaveq 
  81d5db:	c3                   	retq   

000000000081d5dc <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  81d5dc:	55                   	push   %rbp
  81d5dd:	48 89 e5             	mov    %rsp,%rbp
  81d5e0:	48 83 ec 10          	sub    $0x10,%rsp
  81d5e4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  81d5e8:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d5ef:	00 00 00 
  81d5f2:	0f b7 00             	movzwl (%rax),%eax
  81d5f5:	0f b7 d0             	movzwl %ax,%edx
  81d5f8:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d5ff:	00 00 00 
  81d602:	8b 00                	mov    (%rax),%eax
  81d604:	01 c2                	add    %eax,%edx
  81d606:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d60a:	8b 40 30             	mov    0x30(%rax),%eax
  81d60d:	29 c2                	sub    %eax,%edx
  81d60f:	89 d0                	mov    %edx,%eax
  81d611:	85 c0                	test   %eax,%eax
  81d613:	7e 25                	jle    81d63a <tcp_timewait_input+0x5e>
    pcb->rcv_nxt = seqno + tcplen;
  81d615:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d61c:	00 00 00 
  81d61f:	0f b7 00             	movzwl (%rax),%eax
  81d622:	0f b7 d0             	movzwl %ax,%edx
  81d625:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d62c:	00 00 00 
  81d62f:	8b 00                	mov    (%rax),%eax
  81d631:	01 c2                	add    %eax,%edx
  81d633:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d637:	89 50 30             	mov    %edx,0x30(%rax)
  }
  if (tcplen > 0) {
  81d63a:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d641:	00 00 00 
  81d644:	0f b7 00             	movzwl (%rax),%eax
  81d647:	66 85 c0             	test   %ax,%ax
  81d64a:	74 27                	je     81d673 <tcp_timewait_input+0x97>
    tcp_ack_now(pcb);
  81d64c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d650:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d654:	83 c8 02             	or     $0x2,%eax
  81d657:	89 c2                	mov    %eax,%edx
  81d659:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d65d:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d660:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d664:	48 89 c7             	mov    %rax,%rdi
  81d667:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  81d66e:	00 00 00 
  81d671:	ff d0                	callq  *%rax
  }
  return tcp_output(pcb);
  81d673:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d677:	48 89 c7             	mov    %rax,%rdi
  81d67a:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  81d681:	00 00 00 
  81d684:	ff d0                	callq  *%rax
}
  81d686:	c9                   	leaveq 
  81d687:	c3                   	retq   

000000000081d688 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
  81d688:	55                   	push   %rbp
  81d689:	48 89 e5             	mov    %rsp,%rbp
  81d68c:	48 83 ec 20          	sub    $0x20,%rsp
  81d690:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
  81d694:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  err_t err;
  u8_t accepted_inseq;

  err = ERR_OK;
  81d698:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  81d69c:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d6a3:	00 00 00 
  81d6a6:	0f b6 00             	movzbl (%rax),%eax
  81d6a9:	0f b6 c0             	movzbl %al,%eax
  81d6ac:	83 e0 04             	and    $0x4,%eax
  81d6af:	85 c0                	test   %eax,%eax
  81d6b1:	0f 84 e0 00 00 00    	je     81d797 <tcp_process+0x10f>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  81d6b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d6bb:	8b 40 18             	mov    0x18(%rax),%eax
  81d6be:	83 f8 02             	cmp    $0x2,%eax
  81d6c1:	75 1d                	jne    81d6e0 <tcp_process+0x58>
      if (ackno == pcb->snd_nxt) {
  81d6c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d6c7:	8b 50 60             	mov    0x60(%rax),%edx
  81d6ca:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d6d1:	00 00 00 
  81d6d4:	8b 00                	mov    (%rax),%eax
  81d6d6:	39 c2                	cmp    %eax,%edx
  81d6d8:	75 4d                	jne    81d727 <tcp_process+0x9f>
        acceptable = 1;
  81d6da:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  81d6de:	eb 47                	jmp    81d727 <tcp_process+0x9f>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  81d6e0:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d6e7:	00 00 00 
  81d6ea:	8b 10                	mov    (%rax),%edx
  81d6ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d6f0:	8b 40 30             	mov    0x30(%rax),%eax
  81d6f3:	29 c2                	sub    %eax,%edx
  81d6f5:	89 d0                	mov    %edx,%eax
  81d6f7:	85 c0                	test   %eax,%eax
  81d6f9:	78 2c                	js     81d727 <tcp_process+0x9f>
  81d6fb:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d702:	00 00 00 
  81d705:	8b 10                	mov    (%rax),%edx
  81d707:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d70b:	8b 48 30             	mov    0x30(%rax),%ecx
  81d70e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d712:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81d716:	0f b7 c0             	movzwl %ax,%eax
  81d719:	01 c8                	add    %ecx,%eax
  81d71b:	29 c2                	sub    %eax,%edx
  81d71d:	89 d0                	mov    %edx,%eax
  81d71f:	85 c0                	test   %eax,%eax
  81d721:	7f 04                	jg     81d727 <tcp_process+0x9f>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
  81d723:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
      }
    }

    if (acceptable) {
  81d727:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  81d72b:	74 60                	je     81d78d <tcp_process+0x105>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  81d72d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d731:	8b 40 18             	mov    0x18(%rax),%eax
  81d734:	85 c0                	test   %eax,%eax
  81d736:	75 2a                	jne    81d762 <tcp_process+0xda>
  81d738:	48 ba 28 3d 82 00 00 	movabs $0x823d28,%rdx
  81d73f:	00 00 00 
  81d742:	be 0a 02 00 00       	mov    $0x20a,%esi
  81d747:	48 bf 27 3c 82 00 00 	movabs $0x823c27,%rdi
  81d74e:	00 00 00 
  81d751:	b8 00 00 00 00       	mov    $0x0,%eax
  81d756:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81d75d:	00 00 00 
  81d760:	ff d1                	callq  *%rcx
      recv_flags = TF_RESET;
  81d762:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81d769:	00 00 00 
  81d76c:	c6 00 08             	movb   $0x8,(%rax)
      pcb->flags &= ~TF_ACK_DELAY;
  81d76f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d773:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d777:	83 e0 fe             	and    $0xfffffffe,%eax
  81d77a:	89 c2                	mov    %eax,%edx
  81d77c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d780:	88 50 2c             	mov    %dl,0x2c(%rax)
      return ERR_RST;
  81d783:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  81d788:	e9 e0 0b 00 00       	jmpq   81e36d <tcp_process+0xce5>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
  81d78d:	b8 00 00 00 00       	mov    $0x0,%eax
  81d792:	e9 d6 0b 00 00       	jmpq   81e36d <tcp_process+0xce5>
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  81d797:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81d79e:	00 00 00 
  81d7a1:	8b 10                	mov    (%rax),%edx
  81d7a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d7a7:	89 50 38             	mov    %edx,0x38(%rax)
  pcb->keep_cnt_sent = 0;
  81d7aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d7ae:	c6 80 d9 00 00 00 00 	movb   $0x0,0xd9(%rax)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  81d7b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d7b9:	8b 40 18             	mov    0x18(%rax),%eax
  81d7bc:	83 f8 09             	cmp    $0x9,%eax
  81d7bf:	0f 87 8d 0b 00 00    	ja     81e352 <tcp_process+0xcca>
  81d7c5:	89 c0                	mov    %eax,%eax
  81d7c7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  81d7ce:	00 
  81d7cf:	48 b8 78 3d 82 00 00 	movabs $0x823d78,%rax
  81d7d6:	00 00 00 
  81d7d9:	48 01 d0             	add    %rdx,%rax
  81d7dc:	48 8b 00             	mov    (%rax),%rax
  81d7df:	ff e0                	jmpq   *%rax
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  81d7e1:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d7e8:	00 00 00 
  81d7eb:	0f b6 00             	movzbl (%rax),%eax
  81d7ee:	0f b6 c0             	movzbl %al,%eax
  81d7f1:	83 e0 10             	and    $0x10,%eax
  81d7f4:	85 c0                	test   %eax,%eax
  81d7f6:	0f 84 5a 02 00 00    	je     81da56 <tcp_process+0x3ce>
  81d7fc:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d803:	00 00 00 
  81d806:	0f b6 00             	movzbl (%rax),%eax
  81d809:	0f b6 c0             	movzbl %al,%eax
  81d80c:	83 e0 02             	and    $0x2,%eax
  81d80f:	85 c0                	test   %eax,%eax
  81d811:	0f 84 3f 02 00 00    	je     81da56 <tcp_process+0x3ce>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  81d817:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d81b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d822:	48 8b 40 20          	mov    0x20(%rax),%rax
  81d826:	8b 40 04             	mov    0x4(%rax),%eax
  81d829:	89 c7                	mov    %eax,%edi
  81d82b:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  81d832:	00 00 00 
  81d835:	ff d0                	callq  *%rax
  81d837:	8d 50 01             	lea    0x1(%rax),%edx
  81d83a:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d841:	00 00 00 
  81d844:	8b 00                	mov    (%rax),%eax
  81d846:	39 c2                	cmp    %eax,%edx
  81d848:	0f 85 08 02 00 00    	jne    81da56 <tcp_process+0x3ce>
      pcb->snd_buf++;
  81d84e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d852:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81d856:	8d 50 01             	lea    0x1(%rax),%edx
  81d859:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d85d:	66 89 50 7a          	mov    %dx,0x7a(%rax)
      pcb->rcv_nxt = seqno + 1;
  81d861:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d868:	00 00 00 
  81d86b:	8b 00                	mov    (%rax),%eax
  81d86d:	8d 50 01             	lea    0x1(%rax),%edx
  81d870:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d874:	89 50 30             	mov    %edx,0x30(%rax)
      pcb->lastack = ackno;
  81d877:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d87e:	00 00 00 
  81d881:	8b 10                	mov    (%rax),%edx
  81d883:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d887:	89 50 54             	mov    %edx,0x54(%rax)
      pcb->snd_wnd = tcphdr->wnd;
  81d88a:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d891:	00 00 00 
  81d894:	48 8b 00             	mov    (%rax),%rax
  81d897:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81d89b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d89f:	66 89 50 68          	mov    %dx,0x68(%rax)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  81d8a3:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d8aa:	00 00 00 
  81d8ad:	8b 00                	mov    (%rax),%eax
  81d8af:	8d 50 ff             	lea    -0x1(%rax),%edx
  81d8b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d8b6:	89 50 6c             	mov    %edx,0x6c(%rax)
      pcb->state = ESTABLISHED;
  81d8b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d8bd:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%rax)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  81d8c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d8c8:	48 89 c7             	mov    %rax,%rdi
  81d8cb:	48 b8 fd fd 81 00 00 	movabs $0x81fdfd,%rax
  81d8d2:	00 00 00 
  81d8d5:	ff d0                	callq  *%rax
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  81d8d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d8db:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81d8df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d8e3:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d8e7:	0f b7 c0             	movzwl %ax,%eax
  81d8ea:	48 89 d6             	mov    %rdx,%rsi
  81d8ed:	89 c7                	mov    %eax,%edi
  81d8ef:	48 b8 88 0d 81 00 00 	movabs $0x810d88,%rax
  81d8f6:	00 00 00 
  81d8f9:	ff d0                	callq  *%rax
  81d8fb:	89 c2                	mov    %eax,%edx
  81d8fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d901:	66 89 50 40          	mov    %dx,0x40(%rax)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  81d905:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d909:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81d90d:	89 d0                	mov    %edx,%eax
  81d90f:	c1 e0 02             	shl    $0x2,%eax
  81d912:	01 d0                	add    %edx,%eax
  81d914:	01 c0                	add    %eax,%eax
  81d916:	89 c2                	mov    %eax,%edx
  81d918:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d91c:	66 89 50 5c          	mov    %dx,0x5c(%rax)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  81d920:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d924:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81d928:	66 83 f8 01          	cmp    $0x1,%ax
  81d92c:	75 0c                	jne    81d93a <tcp_process+0x2b2>
  81d92e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d932:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d936:	01 c0                	add    %eax,%eax
  81d938:	eb 08                	jmp    81d942 <tcp_process+0x2ba>
  81d93a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d93e:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d942:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81d946:	66 89 42 5a          	mov    %ax,0x5a(%rdx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  81d94a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d94e:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81d952:	66 85 c0             	test   %ax,%ax
  81d955:	75 2a                	jne    81d981 <tcp_process+0x2f9>
  81d957:	48 ba 48 3d 82 00 00 	movabs $0x823d48,%rdx
  81d95e:	00 00 00 
  81d961:	be 36 02 00 00       	mov    $0x236,%esi
  81d966:	48 bf 27 3c 82 00 00 	movabs $0x823c27,%rdi
  81d96d:	00 00 00 
  81d970:	b8 00 00 00 00       	mov    $0x0,%eax
  81d975:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81d97c:	00 00 00 
  81d97f:	ff d1                	callq  *%rcx
      --pcb->snd_queuelen;
  81d981:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d985:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81d989:	8d 50 ff             	lea    -0x1(%rax),%edx
  81d98c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d990:	66 89 50 7c          	mov    %dx,0x7c(%rax)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  81d994:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d998:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d99f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb->unacked = rseg->next;
  81d9a3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81d9a7:	48 8b 10             	mov    (%rax),%rdx
  81d9aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d9ae:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  81d9b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d9b9:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d9c0:	48 85 c0             	test   %rax,%rax
  81d9c3:	75 0c                	jne    81d9d1 <tcp_process+0x349>
        pcb->rtime = -1;
  81d9c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d9c9:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
  81d9cf:	eb 12                	jmp    81d9e3 <tcp_process+0x35b>
      else {
        pcb->rtime = 0;
  81d9d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d9d5:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)
        pcb->nrtx = 0;
  81d9db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d9df:	c6 40 52 00          	movb   $0x0,0x52(%rax)
      }

      tcp_seg_free(rseg);
  81d9e3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81d9e7:	48 89 c7             	mov    %rax,%rdi
  81d9ea:	48 b8 1b 05 81 00 00 	movabs $0x81051b,%rax
  81d9f1:	00 00 00 
  81d9f4:	ff d0                	callq  *%rax

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  81d9f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81d9fa:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  81da01:	48 85 c0             	test   %rax,%rax
  81da04:	74 24                	je     81da2a <tcp_process+0x3a2>
  81da06:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81da0a:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  81da11:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81da15:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  81da19:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81da1d:	ba 00 00 00 00       	mov    $0x0,%edx
  81da22:	48 89 cf             	mov    %rcx,%rdi
  81da25:	ff d0                	callq  *%rax
  81da27:	88 45 fe             	mov    %al,-0x2(%rbp)
      tcp_ack_now(pcb);
  81da2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81da2e:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81da32:	83 c8 02             	or     $0x2,%eax
  81da35:	89 c2                	mov    %eax,%edx
  81da37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81da3b:	88 50 2c             	mov    %dl,0x2c(%rax)
  81da3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81da42:	48 89 c7             	mov    %rax,%rdi
  81da45:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  81da4c:	00 00 00 
  81da4f:	ff d0                	callq  *%rax
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
  81da51:	e9 ff 08 00 00       	jmpq   81e355 <tcp_process+0xccd>
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  81da56:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81da5d:	00 00 00 
  81da60:	0f b6 00             	movzbl (%rax),%eax
  81da63:	0f b6 c0             	movzbl %al,%eax
  81da66:	83 e0 10             	and    $0x10,%eax
  81da69:	85 c0                	test   %eax,%eax
  81da6b:	0f 84 e4 08 00 00    	je     81e355 <tcp_process+0xccd>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81da71:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81da78:	00 00 00 
  81da7b:	48 8b 00             	mov    (%rax),%rax
  81da7e:	0f b7 00             	movzwl (%rax),%eax
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81da81:	44 0f b7 c0          	movzwl %ax,%r8d
        tcphdr->dest, tcphdr->src);
  81da85:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81da8c:	00 00 00 
  81da8f:	48 8b 00             	mov    (%rax),%rax
  81da92:	0f b7 40 02          	movzwl 0x2(%rax),%eax
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81da96:	0f b7 f8             	movzwl %ax,%edi
  81da99:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81daa0:	00 00 00 
  81daa3:	48 8b 00             	mov    (%rax),%rax
  81daa6:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  81daaa:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81dab1:	00 00 00 
  81dab4:	48 8b 00             	mov    (%rax),%rax
  81dab7:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81dabb:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81dac2:	00 00 00 
  81dac5:	0f b7 00             	movzwl (%rax),%eax
  81dac8:	0f b7 f0             	movzwl %ax,%esi
  81dacb:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81dad2:	00 00 00 
  81dad5:	8b 00                	mov    (%rax),%eax
  81dad7:	01 c6                	add    %eax,%esi
  81dad9:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81dae0:	00 00 00 
  81dae3:	8b 00                	mov    (%rax),%eax
  81dae5:	45 89 c1             	mov    %r8d,%r9d
  81dae8:	41 89 f8             	mov    %edi,%r8d
  81daeb:	89 c7                	mov    %eax,%edi
  81daed:	48 b8 80 46 81 00 00 	movabs $0x814680,%rax
  81daf4:	00 00 00 
  81daf7:	ff d0                	callq  *%rax
        tcphdr->dest, tcphdr->src);
    }
    break;
  81daf9:	e9 57 08 00 00       	jmpq   81e355 <tcp_process+0xccd>
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  81dafe:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81db05:	00 00 00 
  81db08:	0f b6 00             	movzbl (%rax),%eax
  81db0b:	0f b6 c0             	movzbl %al,%eax
  81db0e:	83 e0 10             	and    $0x10,%eax
  81db11:	85 c0                	test   %eax,%eax
  81db13:	0f 84 3f 08 00 00    	je     81e358 <tcp_process+0xcd0>
       !(flags & TCP_RST)) {
  81db19:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81db20:	00 00 00 
  81db23:	0f b6 00             	movzbl (%rax),%eax
  81db26:	0f b6 c0             	movzbl %al,%eax
  81db29:	83 e0 04             	and    $0x4,%eax
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  81db2c:	85 c0                	test   %eax,%eax
  81db2e:	0f 85 24 08 00 00    	jne    81e358 <tcp_process+0xcd0>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81db34:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81db3b:	00 00 00 
  81db3e:	8b 10                	mov    (%rax),%edx
  81db40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81db44:	8b 40 54             	mov    0x54(%rax),%eax
  81db47:	29 c2                	sub    %eax,%edx
  81db49:	89 d0                	mov    %edx,%eax
  81db4b:	83 e8 01             	sub    $0x1,%eax
  81db4e:	85 c0                	test   %eax,%eax
  81db50:	0f 88 5c 01 00 00    	js     81dcb2 <tcp_process+0x62a>
  81db56:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81db5d:	00 00 00 
  81db60:	8b 10                	mov    (%rax),%edx
  81db62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81db66:	8b 40 60             	mov    0x60(%rax),%eax
  81db69:	29 c2                	sub    %eax,%edx
  81db6b:	89 d0                	mov    %edx,%eax
  81db6d:	85 c0                	test   %eax,%eax
  81db6f:	0f 8f 3d 01 00 00    	jg     81dcb2 <tcp_process+0x62a>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  81db75:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81db79:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%rax)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  81db80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81db84:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81db8b:	48 85 c0             	test   %rax,%rax
  81db8e:	75 2a                	jne    81dbba <tcp_process+0x532>
  81db90:	48 ba 5e 3d 82 00 00 	movabs $0x823d5e,%rdx
  81db97:	00 00 00 
  81db9a:	be 5c 02 00 00       	mov    $0x25c,%esi
  81db9f:	48 bf 27 3c 82 00 00 	movabs $0x823c27,%rdi
  81dba6:	00 00 00 
  81dba9:	b8 00 00 00 00       	mov    $0x0,%eax
  81dbae:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81dbb5:	00 00 00 
  81dbb8:	ff d1                	callq  *%rcx
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  81dbba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dbbe:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81dbc5:	48 85 c0             	test   %rax,%rax
  81dbc8:	74 24                	je     81dbee <tcp_process+0x566>
  81dbca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dbce:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81dbd5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81dbd9:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  81dbdd:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81dbe1:	ba 00 00 00 00       	mov    $0x0,%edx
  81dbe6:	48 89 cf             	mov    %rcx,%rdi
  81dbe9:	ff d0                	callq  *%rax
  81dbeb:	88 45 fe             	mov    %al,-0x2(%rbp)
        if (err != ERR_OK) {
  81dbee:	80 7d fe 00          	cmpb   $0x0,-0x2(%rbp)
  81dbf2:	74 1d                	je     81dc11 <tcp_process+0x589>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  81dbf4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dbf8:	48 89 c7             	mov    %rax,%rdi
  81dbfb:	48 b8 97 ef 80 00 00 	movabs $0x80ef97,%rax
  81dc02:	00 00 00 
  81dc05:	ff d0                	callq  *%rax
          return ERR_ABRT;
  81dc07:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  81dc0c:	e9 5c 07 00 00       	jmpq   81e36d <tcp_process+0xce5>
        }
        old_cwnd = pcb->cwnd;
  81dc11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dc15:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81dc19:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  81dc1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dc21:	48 89 c7             	mov    %rax,%rdi
  81dc24:	48 b8 6f e3 81 00 00 	movabs $0x81e36f,%rax
  81dc2b:	00 00 00 
  81dc2e:	ff d0                	callq  *%rax
  81dc30:	88 45 fb             	mov    %al,-0x5(%rbp)

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  81dc33:	66 83 7d fc 01       	cmpw   $0x1,-0x4(%rbp)
  81dc38:	75 0c                	jne    81dc46 <tcp_process+0x5be>
  81dc3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dc3e:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81dc42:	01 c0                	add    %eax,%eax
  81dc44:	eb 08                	jmp    81dc4e <tcp_process+0x5c6>
  81dc46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dc4a:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81dc4e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81dc52:	66 89 42 5a          	mov    %ax,0x5a(%rdx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  81dc56:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81dc5d:	00 00 00 
  81dc60:	0f b6 00             	movzbl (%rax),%eax
  81dc63:	0f b6 c0             	movzbl %al,%eax
  81dc66:	83 e0 01             	and    $0x1,%eax
  81dc69:	85 c0                	test   %eax,%eax
  81dc6b:	0f 84 ce 00 00 00    	je     81dd3f <tcp_process+0x6b7>
  81dc71:	80 7d fb 00          	cmpb   $0x0,-0x5(%rbp)
  81dc75:	0f 84 c4 00 00 00    	je     81dd3f <tcp_process+0x6b7>
          tcp_ack_now(pcb);
  81dc7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dc7f:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81dc83:	83 c8 02             	or     $0x2,%eax
  81dc86:	89 c2                	mov    %eax,%edx
  81dc88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dc8c:	88 50 2c             	mov    %dl,0x2c(%rax)
  81dc8f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dc93:	48 89 c7             	mov    %rax,%rdi
  81dc96:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  81dc9d:	00 00 00 
  81dca0:	ff d0                	callq  *%rax
          pcb->state = CLOSE_WAIT;
  81dca2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dca6:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81dcad:	e9 8d 00 00 00       	jmpq   81dd3f <tcp_process+0x6b7>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  81dcb2:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81dcb9:	00 00 00 
  81dcbc:	48 8b 00             	mov    (%rax),%rax
  81dcbf:	0f b7 00             	movzwl (%rax),%eax
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81dcc2:	44 0f b7 c0          	movzwl %ax,%r8d
                tcphdr->dest, tcphdr->src);
  81dcc6:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81dccd:	00 00 00 
  81dcd0:	48 8b 00             	mov    (%rax),%rax
  81dcd3:	0f b7 40 02          	movzwl 0x2(%rax),%eax
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81dcd7:	0f b7 f8             	movzwl %ax,%edi
  81dcda:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81dce1:	00 00 00 
  81dce4:	48 8b 00             	mov    (%rax),%rax
  81dce7:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  81dceb:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81dcf2:	00 00 00 
  81dcf5:	48 8b 00             	mov    (%rax),%rax
  81dcf8:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81dcfc:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81dd03:	00 00 00 
  81dd06:	0f b7 00             	movzwl (%rax),%eax
  81dd09:	0f b7 f0             	movzwl %ax,%esi
  81dd0c:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81dd13:	00 00 00 
  81dd16:	8b 00                	mov    (%rax),%eax
  81dd18:	01 c6                	add    %eax,%esi
  81dd1a:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81dd21:	00 00 00 
  81dd24:	8b 00                	mov    (%rax),%eax
  81dd26:	45 89 c1             	mov    %r8d,%r9d
  81dd29:	41 89 f8             	mov    %edi,%r8d
  81dd2c:	89 c7                	mov    %eax,%edi
  81dd2e:	48 b8 80 46 81 00 00 	movabs $0x814680,%rax
  81dd35:	00 00 00 
  81dd38:	ff d0                	callq  *%rax
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
  81dd3a:	e9 19 06 00 00       	jmpq   81e358 <tcp_process+0xcd0>
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81dd3f:	90                   	nop
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
  81dd40:	e9 13 06 00 00       	jmpq   81e358 <tcp_process+0xcd0>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  81dd45:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dd49:	48 89 c7             	mov    %rax,%rdi
  81dd4c:	48 b8 6f e3 81 00 00 	movabs $0x81e36f,%rax
  81dd53:	00 00 00 
  81dd56:	ff d0                	callq  *%rax
  81dd58:	88 45 fb             	mov    %al,-0x5(%rbp)
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  81dd5b:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81dd62:	00 00 00 
  81dd65:	0f b6 00             	movzbl (%rax),%eax
  81dd68:	0f b6 c0             	movzbl %al,%eax
  81dd6b:	83 e0 01             	and    $0x1,%eax
  81dd6e:	85 c0                	test   %eax,%eax
  81dd70:	0f 84 e5 05 00 00    	je     81e35b <tcp_process+0xcd3>
  81dd76:	80 7d fb 00          	cmpb   $0x0,-0x5(%rbp)
  81dd7a:	0f 84 db 05 00 00    	je     81e35b <tcp_process+0xcd3>
      tcp_ack_now(pcb);
  81dd80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dd84:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81dd88:	83 c8 02             	or     $0x2,%eax
  81dd8b:	89 c2                	mov    %eax,%edx
  81dd8d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dd91:	88 50 2c             	mov    %dl,0x2c(%rax)
  81dd94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dd98:	48 89 c7             	mov    %rax,%rdi
  81dd9b:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  81dda2:	00 00 00 
  81dda5:	ff d0                	callq  *%rax
      pcb->state = CLOSE_WAIT;
  81dda7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ddab:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
    }
    break;
  81ddb2:	e9 a4 05 00 00       	jmpq   81e35b <tcp_process+0xcd3>
  case FIN_WAIT_1:
    tcp_receive(pcb);
  81ddb7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ddbb:	48 89 c7             	mov    %rax,%rdi
  81ddbe:	48 b8 6f e3 81 00 00 	movabs $0x81e36f,%rax
  81ddc5:	00 00 00 
  81ddc8:	ff d0                	callq  *%rax
    if (flags & TCP_FIN) {
  81ddca:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81ddd1:	00 00 00 
  81ddd4:	0f b6 00             	movzbl (%rax),%eax
  81ddd7:	0f b6 c0             	movzbl %al,%eax
  81ddda:	83 e0 01             	and    $0x1,%eax
  81dddd:	85 c0                	test   %eax,%eax
  81dddf:	0f 84 bf 01 00 00    	je     81dfa4 <tcp_process+0x91c>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81dde5:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81ddec:	00 00 00 
  81ddef:	0f b6 00             	movzbl (%rax),%eax
  81ddf2:	0f b6 c0             	movzbl %al,%eax
  81ddf5:	83 e0 10             	and    $0x10,%eax
  81ddf8:	85 c0                	test   %eax,%eax
  81ddfa:	0f 84 6d 01 00 00    	je     81df6d <tcp_process+0x8e5>
  81de00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81de04:	8b 50 60             	mov    0x60(%rax),%edx
  81de07:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81de0e:	00 00 00 
  81de11:	8b 00                	mov    (%rax),%eax
  81de13:	39 c2                	cmp    %eax,%edx
  81de15:	0f 85 52 01 00 00    	jne    81df6d <tcp_process+0x8e5>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  81de1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81de1f:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81de23:	83 c8 02             	or     $0x2,%eax
  81de26:	89 c2                	mov    %eax,%edx
  81de28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81de2c:	88 50 2c             	mov    %dl,0x2c(%rax)
  81de2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81de33:	48 89 c7             	mov    %rax,%rdi
  81de36:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  81de3d:	00 00 00 
  81de40:	ff d0                	callq  *%rax
        tcp_pcb_purge(pcb);
  81de42:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81de46:	48 89 c7             	mov    %rax,%rdi
  81de49:	48 b8 4f 0a 81 00 00 	movabs $0x810a4f,%rax
  81de50:	00 00 00 
  81de53:	ff d0                	callq  *%rax
        TCP_RMV(&tcp_active_pcbs, pcb);
  81de55:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81de5c:	00 00 00 
  81de5f:	48 8b 00             	mov    (%rax),%rax
  81de62:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81de66:	75 23                	jne    81de8b <tcp_process+0x803>
  81de68:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81de6f:	00 00 00 
  81de72:	48 8b 00             	mov    (%rax),%rax
  81de75:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81de79:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81de80:	00 00 00 
  81de83:	48 89 10             	mov    %rdx,(%rax)
  81de86:	e9 94 00 00 00       	jmpq   81df1f <tcp_process+0x897>
  81de8b:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81de92:	00 00 00 
  81de95:	48 8b 10             	mov    (%rax),%rdx
  81de98:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81de9f:	00 00 00 
  81dea2:	48 89 10             	mov    %rdx,(%rax)
  81dea5:	eb 66                	jmp    81df0d <tcp_process+0x885>
  81dea7:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81deae:	00 00 00 
  81deb1:	48 8b 00             	mov    (%rax),%rax
  81deb4:	48 8b 40 10          	mov    0x10(%rax),%rax
  81deb8:	48 85 c0             	test   %rax,%rax
  81debb:	74 32                	je     81deef <tcp_process+0x867>
  81debd:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dec4:	00 00 00 
  81dec7:	48 8b 00             	mov    (%rax),%rax
  81deca:	48 8b 40 10          	mov    0x10(%rax),%rax
  81dece:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81ded2:	75 1b                	jne    81deef <tcp_process+0x867>
  81ded4:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dedb:	00 00 00 
  81dede:	48 8b 00             	mov    (%rax),%rax
  81dee1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81dee5:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81dee9:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81deed:	eb 30                	jmp    81df1f <tcp_process+0x897>
  81deef:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81def6:	00 00 00 
  81def9:	48 8b 00             	mov    (%rax),%rax
  81defc:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81df00:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81df07:	00 00 00 
  81df0a:	48 89 10             	mov    %rdx,(%rax)
  81df0d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81df14:	00 00 00 
  81df17:	48 8b 00             	mov    (%rax),%rax
  81df1a:	48 85 c0             	test   %rax,%rax
  81df1d:	75 88                	jne    81dea7 <tcp_process+0x81f>
  81df1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81df23:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81df2a:	00 
        pcb->state = TIME_WAIT;
  81df2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81df2f:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
        TCP_REG(&tcp_tw_pcbs, pcb);
  81df36:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81df3d:	00 00 00 
  81df40:	48 8b 10             	mov    (%rax),%rdx
  81df43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81df47:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81df4b:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81df52:	00 00 00 
  81df55:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81df59:	48 89 10             	mov    %rdx,(%rax)
  81df5c:	48 b8 0a 87 80 00 00 	movabs $0x80870a,%rax
  81df63:	00 00 00 
  81df66:	ff d0                	callq  *%rax
        pcb->state = CLOSING;
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      pcb->state = FIN_WAIT_2;
    }
    break;
  81df68:	e9 f1 03 00 00       	jmpq   81e35e <tcp_process+0xcd6>
        tcp_pcb_purge(pcb);
        TCP_RMV(&tcp_active_pcbs, pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
  81df6d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81df71:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81df75:	83 c8 02             	or     $0x2,%eax
  81df78:	89 c2                	mov    %eax,%edx
  81df7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81df7e:	88 50 2c             	mov    %dl,0x2c(%rax)
  81df81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81df85:	48 89 c7             	mov    %rax,%rdi
  81df88:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  81df8f:	00 00 00 
  81df92:	ff d0                	callq  *%rax
        pcb->state = CLOSING;
  81df94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81df98:	c7 40 18 08 00 00 00 	movl   $0x8,0x18(%rax)
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      pcb->state = FIN_WAIT_2;
    }
    break;
  81df9f:	e9 ba 03 00 00       	jmpq   81e35e <tcp_process+0xcd6>
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
        pcb->state = CLOSING;
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81dfa4:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81dfab:	00 00 00 
  81dfae:	0f b6 00             	movzbl (%rax),%eax
  81dfb1:	0f b6 c0             	movzbl %al,%eax
  81dfb4:	83 e0 10             	and    $0x10,%eax
  81dfb7:	85 c0                	test   %eax,%eax
  81dfb9:	0f 84 9f 03 00 00    	je     81e35e <tcp_process+0xcd6>
  81dfbf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dfc3:	8b 50 60             	mov    0x60(%rax),%edx
  81dfc6:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81dfcd:	00 00 00 
  81dfd0:	8b 00                	mov    (%rax),%eax
  81dfd2:	39 c2                	cmp    %eax,%edx
  81dfd4:	0f 85 84 03 00 00    	jne    81e35e <tcp_process+0xcd6>
      pcb->state = FIN_WAIT_2;
  81dfda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dfde:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%rax)
    }
    break;
  81dfe5:	e9 74 03 00 00       	jmpq   81e35e <tcp_process+0xcd6>
  case FIN_WAIT_2:
    tcp_receive(pcb);
  81dfea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81dfee:	48 89 c7             	mov    %rax,%rdi
  81dff1:	48 b8 6f e3 81 00 00 	movabs $0x81e36f,%rax
  81dff8:	00 00 00 
  81dffb:	ff d0                	callq  *%rax
    if (flags & TCP_FIN) {
  81dffd:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81e004:	00 00 00 
  81e007:	0f b6 00             	movzbl (%rax),%eax
  81e00a:	0f b6 c0             	movzbl %al,%eax
  81e00d:	83 e0 01             	and    $0x1,%eax
  81e010:	85 c0                	test   %eax,%eax
  81e012:	0f 84 49 03 00 00    	je     81e361 <tcp_process+0xcd9>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  81e018:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e01c:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e020:	83 c8 02             	or     $0x2,%eax
  81e023:	89 c2                	mov    %eax,%edx
  81e025:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e029:	88 50 2c             	mov    %dl,0x2c(%rax)
  81e02c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e030:	48 89 c7             	mov    %rax,%rdi
  81e033:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  81e03a:	00 00 00 
  81e03d:	ff d0                	callq  *%rax
      tcp_pcb_purge(pcb);
  81e03f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e043:	48 89 c7             	mov    %rax,%rdi
  81e046:	48 b8 4f 0a 81 00 00 	movabs $0x810a4f,%rax
  81e04d:	00 00 00 
  81e050:	ff d0                	callq  *%rax
      TCP_RMV(&tcp_active_pcbs, pcb);
  81e052:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81e059:	00 00 00 
  81e05c:	48 8b 00             	mov    (%rax),%rax
  81e05f:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81e063:	75 23                	jne    81e088 <tcp_process+0xa00>
  81e065:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81e06c:	00 00 00 
  81e06f:	48 8b 00             	mov    (%rax),%rax
  81e072:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81e076:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81e07d:	00 00 00 
  81e080:	48 89 10             	mov    %rdx,(%rax)
  81e083:	e9 94 00 00 00       	jmpq   81e11c <tcp_process+0xa94>
  81e088:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81e08f:	00 00 00 
  81e092:	48 8b 10             	mov    (%rax),%rdx
  81e095:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e09c:	00 00 00 
  81e09f:	48 89 10             	mov    %rdx,(%rax)
  81e0a2:	eb 66                	jmp    81e10a <tcp_process+0xa82>
  81e0a4:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e0ab:	00 00 00 
  81e0ae:	48 8b 00             	mov    (%rax),%rax
  81e0b1:	48 8b 40 10          	mov    0x10(%rax),%rax
  81e0b5:	48 85 c0             	test   %rax,%rax
  81e0b8:	74 32                	je     81e0ec <tcp_process+0xa64>
  81e0ba:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e0c1:	00 00 00 
  81e0c4:	48 8b 00             	mov    (%rax),%rax
  81e0c7:	48 8b 40 10          	mov    0x10(%rax),%rax
  81e0cb:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81e0cf:	75 1b                	jne    81e0ec <tcp_process+0xa64>
  81e0d1:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e0d8:	00 00 00 
  81e0db:	48 8b 00             	mov    (%rax),%rax
  81e0de:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81e0e2:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81e0e6:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81e0ea:	eb 30                	jmp    81e11c <tcp_process+0xa94>
  81e0ec:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e0f3:	00 00 00 
  81e0f6:	48 8b 00             	mov    (%rax),%rax
  81e0f9:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81e0fd:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e104:	00 00 00 
  81e107:	48 89 10             	mov    %rdx,(%rax)
  81e10a:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e111:	00 00 00 
  81e114:	48 8b 00             	mov    (%rax),%rax
  81e117:	48 85 c0             	test   %rax,%rax
  81e11a:	75 88                	jne    81e0a4 <tcp_process+0xa1c>
  81e11c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e120:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81e127:	00 
      pcb->state = TIME_WAIT;
  81e128:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e12c:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81e133:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81e13a:	00 00 00 
  81e13d:	48 8b 10             	mov    (%rax),%rdx
  81e140:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e144:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81e148:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81e14f:	00 00 00 
  81e152:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81e156:	48 89 10             	mov    %rdx,(%rax)
  81e159:	48 b8 0a 87 80 00 00 	movabs $0x80870a,%rax
  81e160:	00 00 00 
  81e163:	ff d0                	callq  *%rax
    }
    break;
  81e165:	e9 f7 01 00 00       	jmpq   81e361 <tcp_process+0xcd9>
  case CLOSING:
    tcp_receive(pcb);
  81e16a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e16e:	48 89 c7             	mov    %rax,%rdi
  81e171:	48 b8 6f e3 81 00 00 	movabs $0x81e36f,%rax
  81e178:	00 00 00 
  81e17b:	ff d0                	callq  *%rax
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81e17d:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81e184:	00 00 00 
  81e187:	0f b6 00             	movzbl (%rax),%eax
  81e18a:	0f b6 c0             	movzbl %al,%eax
  81e18d:	83 e0 10             	and    $0x10,%eax
  81e190:	85 c0                	test   %eax,%eax
  81e192:	0f 84 cc 01 00 00    	je     81e364 <tcp_process+0xcdc>
  81e198:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e19c:	8b 50 60             	mov    0x60(%rax),%edx
  81e19f:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e1a6:	00 00 00 
  81e1a9:	8b 00                	mov    (%rax),%eax
  81e1ab:	39 c2                	cmp    %eax,%edx
  81e1ad:	0f 85 b1 01 00 00    	jne    81e364 <tcp_process+0xcdc>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  81e1b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e1b7:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e1bb:	83 c8 02             	or     $0x2,%eax
  81e1be:	89 c2                	mov    %eax,%edx
  81e1c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e1c4:	88 50 2c             	mov    %dl,0x2c(%rax)
  81e1c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e1cb:	48 89 c7             	mov    %rax,%rdi
  81e1ce:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  81e1d5:	00 00 00 
  81e1d8:	ff d0                	callq  *%rax
      tcp_pcb_purge(pcb);
  81e1da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e1de:	48 89 c7             	mov    %rax,%rdi
  81e1e1:	48 b8 4f 0a 81 00 00 	movabs $0x810a4f,%rax
  81e1e8:	00 00 00 
  81e1eb:	ff d0                	callq  *%rax
      TCP_RMV(&tcp_active_pcbs, pcb);
  81e1ed:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81e1f4:	00 00 00 
  81e1f7:	48 8b 00             	mov    (%rax),%rax
  81e1fa:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81e1fe:	75 23                	jne    81e223 <tcp_process+0xb9b>
  81e200:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81e207:	00 00 00 
  81e20a:	48 8b 00             	mov    (%rax),%rax
  81e20d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81e211:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81e218:	00 00 00 
  81e21b:	48 89 10             	mov    %rdx,(%rax)
  81e21e:	e9 94 00 00 00       	jmpq   81e2b7 <tcp_process+0xc2f>
  81e223:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81e22a:	00 00 00 
  81e22d:	48 8b 10             	mov    (%rax),%rdx
  81e230:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e237:	00 00 00 
  81e23a:	48 89 10             	mov    %rdx,(%rax)
  81e23d:	eb 66                	jmp    81e2a5 <tcp_process+0xc1d>
  81e23f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e246:	00 00 00 
  81e249:	48 8b 00             	mov    (%rax),%rax
  81e24c:	48 8b 40 10          	mov    0x10(%rax),%rax
  81e250:	48 85 c0             	test   %rax,%rax
  81e253:	74 32                	je     81e287 <tcp_process+0xbff>
  81e255:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e25c:	00 00 00 
  81e25f:	48 8b 00             	mov    (%rax),%rax
  81e262:	48 8b 40 10          	mov    0x10(%rax),%rax
  81e266:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81e26a:	75 1b                	jne    81e287 <tcp_process+0xbff>
  81e26c:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e273:	00 00 00 
  81e276:	48 8b 00             	mov    (%rax),%rax
  81e279:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81e27d:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81e281:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81e285:	eb 30                	jmp    81e2b7 <tcp_process+0xc2f>
  81e287:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e28e:	00 00 00 
  81e291:	48 8b 00             	mov    (%rax),%rax
  81e294:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81e298:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e29f:	00 00 00 
  81e2a2:	48 89 10             	mov    %rdx,(%rax)
  81e2a5:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81e2ac:	00 00 00 
  81e2af:	48 8b 00             	mov    (%rax),%rax
  81e2b2:	48 85 c0             	test   %rax,%rax
  81e2b5:	75 88                	jne    81e23f <tcp_process+0xbb7>
  81e2b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e2bb:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81e2c2:	00 
      pcb->state = TIME_WAIT;
  81e2c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e2c7:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81e2ce:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81e2d5:	00 00 00 
  81e2d8:	48 8b 10             	mov    (%rax),%rdx
  81e2db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e2df:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81e2e3:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81e2ea:	00 00 00 
  81e2ed:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81e2f1:	48 89 10             	mov    %rdx,(%rax)
  81e2f4:	48 b8 0a 87 80 00 00 	movabs $0x80870a,%rax
  81e2fb:	00 00 00 
  81e2fe:	ff d0                	callq  *%rax
    }
    break;
  81e300:	eb 62                	jmp    81e364 <tcp_process+0xcdc>
  case LAST_ACK:
    tcp_receive(pcb);
  81e302:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e306:	48 89 c7             	mov    %rax,%rdi
  81e309:	48 b8 6f e3 81 00 00 	movabs $0x81e36f,%rax
  81e310:	00 00 00 
  81e313:	ff d0                	callq  *%rax
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81e315:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81e31c:	00 00 00 
  81e31f:	0f b6 00             	movzbl (%rax),%eax
  81e322:	0f b6 c0             	movzbl %al,%eax
  81e325:	83 e0 10             	and    $0x10,%eax
  81e328:	85 c0                	test   %eax,%eax
  81e32a:	74 3b                	je     81e367 <tcp_process+0xcdf>
  81e32c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81e330:	8b 50 60             	mov    0x60(%rax),%edx
  81e333:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e33a:	00 00 00 
  81e33d:	8b 00                	mov    (%rax),%eax
  81e33f:	39 c2                	cmp    %eax,%edx
  81e341:	75 24                	jne    81e367 <tcp_process+0xcdf>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  81e343:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81e34a:	00 00 00 
  81e34d:	c6 00 10             	movb   $0x10,(%rax)
    }
    break;
  81e350:	eb 15                	jmp    81e367 <tcp_process+0xcdf>
  default:
    break;
  81e352:	90                   	nop
  81e353:	eb 13                	jmp    81e368 <tcp_process+0xce0>
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
  81e355:	90                   	nop
  81e356:	eb 10                	jmp    81e368 <tcp_process+0xce0>
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
  81e358:	90                   	nop
  81e359:	eb 0d                	jmp    81e368 <tcp_process+0xce0>
    accepted_inseq = tcp_receive(pcb);
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
      tcp_ack_now(pcb);
      pcb->state = CLOSE_WAIT;
    }
    break;
  81e35b:	90                   	nop
  81e35c:	eb 0a                	jmp    81e368 <tcp_process+0xce0>
        pcb->state = CLOSING;
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      pcb->state = FIN_WAIT_2;
    }
    break;
  81e35e:	90                   	nop
  81e35f:	eb 07                	jmp    81e368 <tcp_process+0xce0>
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
  81e361:	90                   	nop
  81e362:	eb 04                	jmp    81e368 <tcp_process+0xce0>
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
  81e364:	90                   	nop
  81e365:	eb 01                	jmp    81e368 <tcp_process+0xce0>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
    }
    break;
  81e367:	90                   	nop
  default:
    break;
  }
  return ERR_OK;
  81e368:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81e36d:	c9                   	leaveq 
  81e36e:	c3                   	retq   

000000000081e36f <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  81e36f:	55                   	push   %rbp
  81e370:	48 89 e5             	mov    %rsp,%rbp
  81e373:	41 55                	push   %r13
  81e375:	41 54                	push   %r12
  81e377:	53                   	push   %rbx
  81e378:	48 83 ec 58          	sub    $0x58,%rsp
  81e37c:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  81e380:	c6 45 c1 00          	movb   $0x0,-0x3f(%rbp)

  if (flags & TCP_ACK) {
  81e384:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81e38b:	00 00 00 
  81e38e:	0f b6 00             	movzbl (%rax),%eax
  81e391:	0f b6 c0             	movzbl %al,%eax
  81e394:	83 e0 10             	and    $0x10,%eax
  81e397:	85 c0                	test   %eax,%eax
  81e399:	0f 84 85 09 00 00    	je     81ed24 <tcp_receive+0x9b5>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  81e39f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3a3:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e3a7:	0f b7 d0             	movzwl %ax,%edx
  81e3aa:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3ae:	8b 40 6c             	mov    0x6c(%rax),%eax
  81e3b1:	01 d0                	add    %edx,%eax
  81e3b3:	89 45 bc             	mov    %eax,-0x44(%rbp)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  81e3b6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3ba:	8b 50 6c             	mov    0x6c(%rax),%edx
  81e3bd:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e3c4:	00 00 00 
  81e3c7:	8b 00                	mov    (%rax),%eax
  81e3c9:	29 c2                	sub    %eax,%edx
  81e3cb:	89 d0                	mov    %edx,%eax
  81e3cd:	85 c0                	test   %eax,%eax
  81e3cf:	78 6b                	js     81e43c <tcp_receive+0xcd>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81e3d1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3d5:	8b 50 6c             	mov    0x6c(%rax),%edx
  81e3d8:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e3df:	00 00 00 
  81e3e2:	8b 00                	mov    (%rax),%eax

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  81e3e4:	39 c2                	cmp    %eax,%edx
  81e3e6:	75 1b                	jne    81e403 <tcp_receive+0x94>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81e3e8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3ec:	8b 50 70             	mov    0x70(%rax),%edx
  81e3ef:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e3f6:	00 00 00 
  81e3f9:	8b 00                	mov    (%rax),%eax
  81e3fb:	29 c2                	sub    %eax,%edx
  81e3fd:	89 d0                	mov    %edx,%eax
  81e3ff:	85 c0                	test   %eax,%eax
  81e401:	78 39                	js     81e43c <tcp_receive+0xcd>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  81e403:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e407:	8b 50 70             	mov    0x70(%rax),%edx
  81e40a:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e411:	00 00 00 
  81e414:	8b 00                	mov    (%rax),%eax
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81e416:	39 c2                	cmp    %eax,%edx
  81e418:	0f 85 84 00 00 00    	jne    81e4a2 <tcp_receive+0x133>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  81e41e:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81e425:	00 00 00 
  81e428:	48 8b 00             	mov    (%rax),%rax
  81e42b:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81e42f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e433:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e437:	66 39 c2             	cmp    %ax,%dx
  81e43a:	76 66                	jbe    81e4a2 <tcp_receive+0x133>
      pcb->snd_wnd = tcphdr->wnd;
  81e43c:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81e443:	00 00 00 
  81e446:	48 8b 00             	mov    (%rax),%rax
  81e449:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81e44d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e451:	66 89 50 68          	mov    %dx,0x68(%rax)
      pcb->snd_wl1 = seqno;
  81e455:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e45c:	00 00 00 
  81e45f:	8b 10                	mov    (%rax),%edx
  81e461:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e465:	89 50 6c             	mov    %edx,0x6c(%rax)
      pcb->snd_wl2 = ackno;
  81e468:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e46f:	00 00 00 
  81e472:	8b 10                	mov    (%rax),%edx
  81e474:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e478:	89 50 70             	mov    %edx,0x70(%rax)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  81e47b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e47f:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e483:	66 85 c0             	test   %ax,%ax
  81e486:	74 1a                	je     81e4a2 <tcp_receive+0x133>
  81e488:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e48c:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  81e493:	84 c0                	test   %al,%al
  81e495:	74 0b                	je     81e4a2 <tcp_receive+0x133>
          pcb->persist_backoff = 0;
  81e497:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e49b:	c6 80 d8 00 00 00 00 	movb   $0x0,0xd8(%rax)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  81e4a2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4a6:	8b 50 54             	mov    0x54(%rax),%edx
  81e4a9:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e4b0:	00 00 00 
  81e4b3:	8b 00                	mov    (%rax),%eax
  81e4b5:	39 c2                	cmp    %eax,%edx
  81e4b7:	0f 85 72 01 00 00    	jne    81e62f <tcp_receive+0x2c0>
      pcb->acked = 0;
  81e4bd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4c1:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  81e4c7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4cb:	8b 50 6c             	mov    0x6c(%rax),%edx
  81e4ce:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4d2:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e4d6:	0f b7 c0             	movzwl %ax,%eax
  81e4d9:	01 d0                	add    %edx,%eax
  81e4db:	3b 45 bc             	cmp    -0x44(%rbp),%eax
  81e4de:	0f 85 68 06 00 00    	jne    81eb4c <tcp_receive+0x7dd>
        ++pcb->dupacks;
  81e4e4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4e8:	0f b6 40 58          	movzbl 0x58(%rax),%eax
  81e4ec:	8d 50 01             	lea    0x1(%rax),%edx
  81e4ef:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4f3:	88 50 58             	mov    %dl,0x58(%rax)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  81e4f6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4fa:	0f b6 40 58          	movzbl 0x58(%rax),%eax
  81e4fe:	3c 02                	cmp    $0x2,%al
  81e500:	0f 86 46 06 00 00    	jbe    81eb4c <tcp_receive+0x7dd>
  81e506:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e50a:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e511:	48 85 c0             	test   %rax,%rax
  81e514:	0f 84 32 06 00 00    	je     81eb4c <tcp_receive+0x7dd>
          if (!(pcb->flags & TF_INFR)) {
  81e51a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e51e:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e522:	0f b6 c0             	movzbl %al,%eax
  81e525:	83 e0 04             	and    $0x4,%eax
  81e528:	85 c0                	test   %eax,%eax
  81e52a:	0f 85 bd 00 00 00    	jne    81e5ed <tcp_receive+0x27e>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  81e530:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e534:	48 89 c7             	mov    %rax,%rdi
  81e537:	48 b8 79 49 81 00 00 	movabs $0x814979,%rax
  81e53e:	00 00 00 
  81e541:	ff d0                	callq  *%rax
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  81e543:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e547:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e54b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e54f:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e553:	66 39 c2             	cmp    %ax,%dx
  81e556:	76 17                	jbe    81e56f <tcp_receive+0x200>
              pcb->ssthresh = pcb->snd_wnd / 2;
  81e558:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e55c:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81e560:	66 d1 e8             	shr    %ax
  81e563:	89 c2                	mov    %eax,%edx
  81e565:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e569:	66 89 50 5c          	mov    %dx,0x5c(%rax)
  81e56d:	eb 15                	jmp    81e584 <tcp_receive+0x215>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  81e56f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e573:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e577:	66 d1 e8             	shr    %ax
  81e57a:	89 c2                	mov    %eax,%edx
  81e57c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e580:	66 89 50 5c          	mov    %dx,0x5c(%rax)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  81e584:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e588:	0f b7 40 5c          	movzwl 0x5c(%rax),%eax
  81e58c:	0f b7 d0             	movzwl %ax,%edx
  81e58f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e593:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e597:	0f b7 c0             	movzwl %ax,%eax
  81e59a:	01 c0                	add    %eax,%eax
  81e59c:	39 c2                	cmp    %eax,%edx
  81e59e:	7d 13                	jge    81e5b3 <tcp_receive+0x244>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  81e5a0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5a4:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e5a8:	8d 14 00             	lea    (%rax,%rax,1),%edx
  81e5ab:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5af:	66 89 50 5c          	mov    %dx,0x5c(%rax)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  81e5b3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5b7:	0f b7 48 5c          	movzwl 0x5c(%rax),%ecx
  81e5bb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5bf:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81e5c3:	89 d0                	mov    %edx,%eax
  81e5c5:	01 c0                	add    %eax,%eax
  81e5c7:	01 d0                	add    %edx,%eax
  81e5c9:	8d 14 01             	lea    (%rcx,%rax,1),%edx
  81e5cc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5d0:	66 89 50 5a          	mov    %dx,0x5a(%rax)
            pcb->flags |= TF_INFR;
  81e5d4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5d8:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e5dc:	83 c8 04             	or     $0x4,%eax
  81e5df:	89 c2                	mov    %eax,%edx
  81e5e1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5e5:	88 50 2c             	mov    %dl,0x2c(%rax)
  81e5e8:	e9 5f 05 00 00       	jmpq   81eb4c <tcp_receive+0x7dd>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81e5ed:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5f1:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e5f5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5f9:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e5fd:	01 c2                	add    %eax,%edx
  81e5ff:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e603:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e607:	66 39 c2             	cmp    %ax,%dx
  81e60a:	0f 86 3c 05 00 00    	jbe    81eb4c <tcp_receive+0x7dd>
              pcb->cwnd += pcb->mss;
  81e610:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e614:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e618:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e61c:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e620:	01 c2                	add    %eax,%edx
  81e622:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e626:	66 89 50 5a          	mov    %dx,0x5a(%rax)
  81e62a:	e9 1d 05 00 00       	jmpq   81eb4c <tcp_receive+0x7dd>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  81e62f:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e636:	00 00 00 
  81e639:	8b 10                	mov    (%rax),%edx
  81e63b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e63f:	8b 40 54             	mov    0x54(%rax),%eax
  81e642:	29 c2                	sub    %eax,%edx
  81e644:	89 d0                	mov    %edx,%eax
  81e646:	83 e8 01             	sub    $0x1,%eax
  81e649:	85 c0                	test   %eax,%eax
  81e64b:	0f 88 a2 03 00 00    	js     81e9f3 <tcp_receive+0x684>
  81e651:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e658:	00 00 00 
  81e65b:	8b 10                	mov    (%rax),%edx
  81e65d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e661:	8b 40 64             	mov    0x64(%rax),%eax
  81e664:	29 c2                	sub    %eax,%edx
  81e666:	89 d0                	mov    %edx,%eax
  81e668:	85 c0                	test   %eax,%eax
  81e66a:	0f 8f 83 03 00 00    	jg     81e9f3 <tcp_receive+0x684>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  81e670:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e674:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e678:	0f b6 c0             	movzbl %al,%eax
  81e67b:	83 e0 04             	and    $0x4,%eax
  81e67e:	85 c0                	test   %eax,%eax
  81e680:	74 24                	je     81e6a6 <tcp_receive+0x337>
        pcb->flags &= ~TF_INFR;
  81e682:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e686:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e68a:	83 e0 fb             	and    $0xfffffffb,%eax
  81e68d:	89 c2                	mov    %eax,%edx
  81e68f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e693:	88 50 2c             	mov    %dl,0x2c(%rax)
        pcb->cwnd = pcb->ssthresh;
  81e696:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e69a:	0f b7 50 5c          	movzwl 0x5c(%rax),%edx
  81e69e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6a2:	66 89 50 5a          	mov    %dx,0x5a(%rax)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  81e6a6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6aa:	c6 40 52 00          	movb   $0x0,0x52(%rax)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  81e6ae:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6b2:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81e6b6:	66 c1 f8 03          	sar    $0x3,%ax
  81e6ba:	89 c2                	mov    %eax,%edx
  81e6bc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6c0:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81e6c4:	01 d0                	add    %edx,%eax
  81e6c6:	89 c2                	mov    %eax,%edx
  81e6c8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6cc:	66 89 50 50          	mov    %dx,0x50(%rax)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  81e6d0:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e6d7:	00 00 00 
  81e6da:	8b 00                	mov    (%rax),%eax
  81e6dc:	89 c2                	mov    %eax,%edx
  81e6de:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6e2:	8b 40 54             	mov    0x54(%rax),%eax
  81e6e5:	29 c2                	sub    %eax,%edx
  81e6e7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6eb:	66 89 50 78          	mov    %dx,0x78(%rax)

      pcb->snd_buf += pcb->acked;
  81e6ef:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6f3:	0f b7 50 7a          	movzwl 0x7a(%rax),%edx
  81e6f7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6fb:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  81e6ff:	01 c2                	add    %eax,%edx
  81e701:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e705:	66 89 50 7a          	mov    %dx,0x7a(%rax)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  81e709:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e70d:	c6 40 58 00          	movb   $0x0,0x58(%rax)
      pcb->lastack = ackno;
  81e711:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e718:	00 00 00 
  81e71b:	8b 10                	mov    (%rax),%edx
  81e71d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e721:	89 50 54             	mov    %edx,0x54(%rax)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  81e724:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e728:	8b 40 18             	mov    0x18(%rax),%eax
  81e72b:	83 f8 03             	cmp    $0x3,%eax
  81e72e:	0f 86 c0 01 00 00    	jbe    81e8f4 <tcp_receive+0x585>
        if (pcb->cwnd < pcb->ssthresh) {
  81e734:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e738:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e73c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e740:	0f b7 40 5c          	movzwl 0x5c(%rax),%eax
  81e744:	66 39 c2             	cmp    %ax,%dx
  81e747:	73 42                	jae    81e78b <tcp_receive+0x41c>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81e749:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e74d:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e751:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e755:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e759:	01 c2                	add    %eax,%edx
  81e75b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e75f:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e763:	66 39 c2             	cmp    %ax,%dx
  81e766:	0f 86 88 01 00 00    	jbe    81e8f4 <tcp_receive+0x585>
            pcb->cwnd += pcb->mss;
  81e76c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e770:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e774:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e778:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e77c:	01 c2                	add    %eax,%edx
  81e77e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e782:	66 89 50 5a          	mov    %dx,0x5a(%rax)
  81e786:	e9 69 01 00 00       	jmpq   81e8f4 <tcp_receive+0x585>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  81e78b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e78f:	0f b7 48 5a          	movzwl 0x5a(%rax),%ecx
  81e793:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e797:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e79b:	0f b7 d0             	movzwl %ax,%edx
  81e79e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7a2:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e7a6:	0f b7 c0             	movzwl %ax,%eax
  81e7a9:	0f af c2             	imul   %edx,%eax
  81e7ac:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81e7b0:	0f b7 52 5a          	movzwl 0x5a(%rdx),%edx
  81e7b4:	0f b7 f2             	movzwl %dx,%esi
  81e7b7:	99                   	cltd   
  81e7b8:	f7 fe                	idiv   %esi
  81e7ba:	01 c8                	add    %ecx,%eax
  81e7bc:	66 89 45 ba          	mov    %ax,-0x46(%rbp)
          if (new_cwnd > pcb->cwnd) {
  81e7c0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7c4:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e7c8:	66 3b 45 ba          	cmp    -0x46(%rbp),%ax
  81e7cc:	0f 83 22 01 00 00    	jae    81e8f4 <tcp_receive+0x585>
            pcb->cwnd = new_cwnd;
  81e7d2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7d6:	0f b7 55 ba          	movzwl -0x46(%rbp),%edx
  81e7da:	66 89 50 5a          	mov    %dx,0x5a(%rax)
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e7de:	e9 11 01 00 00       	jmpq   81e8f4 <tcp_receive+0x585>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  81e7e3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7e7:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e7ee:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        pcb->unacked = pcb->unacked->next;
  81e7f2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7f6:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e7fd:	48 8b 10             	mov    (%rax),%rdx
  81e800:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e804:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  81e80b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e80f:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e813:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e817:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e81b:	48 89 c7             	mov    %rax,%rdi
  81e81e:	48 b8 7d df 80 00 00 	movabs $0x80df7d,%rax
  81e825:	00 00 00 
  81e828:	ff d0                	callq  *%rax
  81e82a:	0f b6 c0             	movzbl %al,%eax
  81e82d:	66 39 c3             	cmp    %ax,%bx
  81e830:	73 2a                	jae    81e85c <tcp_receive+0x4ed>
  81e832:	48 ba c8 3d 82 00 00 	movabs $0x823dc8,%rdx
  81e839:	00 00 00 
  81e83c:	be 56 03 00 00       	mov    $0x356,%esi
  81e841:	48 bf 27 3c 82 00 00 	movabs $0x823c27,%rdi
  81e848:	00 00 00 
  81e84b:	b8 00 00 00 00       	mov    $0x0,%eax
  81e850:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81e857:	00 00 00 
  81e85a:	ff d1                	callq  *%rcx
        pcb->snd_queuelen -= pbuf_clen(next->p);
  81e85c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e860:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e864:	48 89 c7             	mov    %rax,%rdi
  81e867:	48 b8 7d df 80 00 00 	movabs $0x80df7d,%rax
  81e86e:	00 00 00 
  81e871:	ff d0                	callq  *%rax
  81e873:	89 c1                	mov    %eax,%ecx
  81e875:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e879:	0f b7 50 7c          	movzwl 0x7c(%rax),%edx
  81e87d:	0f b6 c1             	movzbl %cl,%eax
  81e880:	29 c2                	sub    %eax,%edx
  81e882:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e886:	66 89 50 7c          	mov    %dx,0x7c(%rax)
        tcp_seg_free(next);
  81e88a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e88e:	48 89 c7             	mov    %rax,%rdi
  81e891:	48 b8 1b 05 81 00 00 	movabs $0x81051b,%rax
  81e898:	00 00 00 
  81e89b:	ff d0                	callq  *%rax

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  81e89d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e8a1:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81e8a5:	66 85 c0             	test   %ax,%ax
  81e8a8:	74 4a                	je     81e8f4 <tcp_receive+0x585>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  81e8aa:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e8ae:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e8b5:	48 85 c0             	test   %rax,%rax
  81e8b8:	75 3a                	jne    81e8f4 <tcp_receive+0x585>
  81e8ba:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e8be:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e8c5:	48 85 c0             	test   %rax,%rax
  81e8c8:	75 2a                	jne    81e8f4 <tcp_receive+0x585>
  81e8ca:	48 ba f0 3d 82 00 00 	movabs $0x823df0,%rdx
  81e8d1:	00 00 00 
  81e8d4:	be 5d 03 00 00       	mov    $0x35d,%esi
  81e8d9:	48 bf 27 3c 82 00 00 	movabs $0x823c27,%rdi
  81e8e0:	00 00 00 
  81e8e3:	b8 00 00 00 00       	mov    $0x0,%eax
  81e8e8:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81e8ef:	00 00 00 
  81e8f2:	ff d1                	callq  *%rcx
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e8f4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e8f8:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e8ff:	48 85 c0             	test   %rax,%rax
  81e902:	0f 84 bb 00 00 00    	je     81e9c3 <tcp_receive+0x654>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  81e908:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e90c:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e913:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e917:	8b 40 04             	mov    0x4(%rax),%eax
  81e91a:	89 c7                	mov    %eax,%edi
  81e91c:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  81e923:	00 00 00 
  81e926:	ff d0                	callq  *%rax
  81e928:	41 89 c4             	mov    %eax,%r12d
  81e92b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e92f:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e936:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e93a:	0f b7 d8             	movzwl %ax,%ebx
  81e93d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e941:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e948:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e94c:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e950:	0f b7 c0             	movzwl %ax,%eax
  81e953:	89 c7                	mov    %eax,%edi
  81e955:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81e95c:	00 00 00 
  81e95f:	ff d0                	callq  *%rax
  81e961:	0f b7 c0             	movzwl %ax,%eax
  81e964:	83 e0 01             	and    $0x1,%eax
  81e967:	85 c0                	test   %eax,%eax
  81e969:	75 2e                	jne    81e999 <tcp_receive+0x62a>
  81e96b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e96f:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e976:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e97a:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e97e:	0f b7 c0             	movzwl %ax,%eax
  81e981:	89 c7                	mov    %eax,%edi
  81e983:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81e98a:	00 00 00 
  81e98d:	ff d0                	callq  *%rax
  81e98f:	0f b7 c0             	movzwl %ax,%eax
  81e992:	83 e0 02             	and    $0x2,%eax
  81e995:	85 c0                	test   %eax,%eax
  81e997:	74 07                	je     81e9a0 <tcp_receive+0x631>
  81e999:	b8 01 00 00 00       	mov    $0x1,%eax
  81e99e:	eb 05                	jmp    81e9a5 <tcp_receive+0x636>
  81e9a0:	b8 00 00 00 00       	mov    $0x0,%eax
  81e9a5:	01 d8                	add    %ebx,%eax
  81e9a7:	41 8d 14 04          	lea    (%r12,%rax,1),%edx
  81e9ab:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e9b2:	00 00 00 
  81e9b5:	8b 00                	mov    (%rax),%eax
  81e9b7:	29 c2                	sub    %eax,%edx
  81e9b9:	89 d0                	mov    %edx,%eax
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e9bb:	85 c0                	test   %eax,%eax
  81e9bd:	0f 8e 20 fe ff ff    	jle    81e7e3 <tcp_receive+0x474>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  81e9c3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9c7:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e9ce:	48 85 c0             	test   %rax,%rax
  81e9d1:	75 0c                	jne    81e9df <tcp_receive+0x670>
        pcb->rtime = -1;
  81e9d3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9d7:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
  81e9dd:	eb 0a                	jmp    81e9e9 <tcp_receive+0x67a>
      else
        pcb->rtime = 0;
  81e9df:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9e3:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

      pcb->polltmr = 0;
  81e9e9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9ed:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)
  81e9f1:	eb 0a                	jmp    81e9fd <tcp_receive+0x68e>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  81e9f3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9f7:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e9fd:	e9 4a 01 00 00       	jmpq   81eb4c <tcp_receive+0x7dd>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  81ea02:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea06:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81ea0d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      pcb->unsent = pcb->unsent->next;
  81ea11:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea15:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81ea1c:	48 8b 10             	mov    (%rax),%rdx
  81ea1f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea23:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  81ea2a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea2e:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81ea32:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ea36:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ea3a:	48 89 c7             	mov    %rax,%rdi
  81ea3d:	48 b8 7d df 80 00 00 	movabs $0x80df7d,%rax
  81ea44:	00 00 00 
  81ea47:	ff d0                	callq  *%rax
  81ea49:	0f b6 c0             	movzbl %al,%eax
  81ea4c:	66 39 c3             	cmp    %ax,%bx
  81ea4f:	73 2a                	jae    81ea7b <tcp_receive+0x70c>
  81ea51:	48 ba c8 3d 82 00 00 	movabs $0x823dc8,%rdx
  81ea58:	00 00 00 
  81ea5b:	be 80 03 00 00       	mov    $0x380,%esi
  81ea60:	48 bf 27 3c 82 00 00 	movabs $0x823c27,%rdi
  81ea67:	00 00 00 
  81ea6a:	b8 00 00 00 00       	mov    $0x0,%eax
  81ea6f:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81ea76:	00 00 00 
  81ea79:	ff d1                	callq  *%rcx
      pcb->snd_queuelen -= pbuf_clen(next->p);
  81ea7b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ea7f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ea83:	48 89 c7             	mov    %rax,%rdi
  81ea86:	48 b8 7d df 80 00 00 	movabs $0x80df7d,%rax
  81ea8d:	00 00 00 
  81ea90:	ff d0                	callq  *%rax
  81ea92:	89 c1                	mov    %eax,%ecx
  81ea94:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea98:	0f b7 50 7c          	movzwl 0x7c(%rax),%edx
  81ea9c:	0f b6 c1             	movzbl %cl,%eax
  81ea9f:	29 c2                	sub    %eax,%edx
  81eaa1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eaa5:	66 89 50 7c          	mov    %dx,0x7c(%rax)
      tcp_seg_free(next);
  81eaa9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81eaad:	48 89 c7             	mov    %rax,%rdi
  81eab0:	48 b8 1b 05 81 00 00 	movabs $0x81051b,%rax
  81eab7:	00 00 00 
  81eaba:	ff d0                	callq  *%rax
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  81eabc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eac0:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81eac4:	66 85 c0             	test   %ax,%ax
  81eac7:	74 4a                	je     81eb13 <tcp_receive+0x7a4>
        LWIP_ASSERT("tcp_receive: valid queue length",
  81eac9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eacd:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81ead4:	48 85 c0             	test   %rax,%rax
  81ead7:	75 3a                	jne    81eb13 <tcp_receive+0x7a4>
  81ead9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eadd:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81eae4:	48 85 c0             	test   %rax,%rax
  81eae7:	75 2a                	jne    81eb13 <tcp_receive+0x7a4>
  81eae9:	48 ba f0 3d 82 00 00 	movabs $0x823df0,%rdx
  81eaf0:	00 00 00 
  81eaf3:	be 86 03 00 00       	mov    $0x386,%esi
  81eaf8:	48 bf 27 3c 82 00 00 	movabs $0x823c27,%rdi
  81eaff:	00 00 00 
  81eb02:	b8 00 00 00 00       	mov    $0x0,%eax
  81eb07:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81eb0e:	00 00 00 
  81eb11:	ff d1                	callq  *%rcx
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  81eb13:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb17:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81eb1e:	48 85 c0             	test   %rax,%rax
  81eb21:	74 29                	je     81eb4c <tcp_receive+0x7dd>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  81eb23:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb27:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81eb2e:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eb32:	8b 40 04             	mov    0x4(%rax),%eax
  81eb35:	89 c7                	mov    %eax,%edi
  81eb37:	48 b8 5d 31 81 00 00 	movabs $0x81315d,%rax
  81eb3e:	00 00 00 
  81eb41:	ff d0                	callq  *%rax
  81eb43:	89 c2                	mov    %eax,%edx
  81eb45:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb49:	89 50 60             	mov    %edx,0x60(%rax)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81eb4c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb50:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81eb57:	48 85 c0             	test   %rax,%rax
  81eb5a:	0f 84 d7 00 00 00    	je     81ec37 <tcp_receive+0x8c8>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  81eb60:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81eb67:	00 00 00 
  81eb6a:	8b 18                	mov    (%rax),%ebx
  81eb6c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb70:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81eb77:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eb7b:	8b 40 04             	mov    0x4(%rax),%eax
  81eb7e:	89 c7                	mov    %eax,%edi
  81eb80:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  81eb87:	00 00 00 
  81eb8a:	ff d0                	callq  *%rax
  81eb8c:	41 89 c5             	mov    %eax,%r13d
  81eb8f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb93:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81eb9a:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81eb9e:	44 0f b7 e0          	movzwl %ax,%r12d
  81eba2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eba6:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81ebad:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ebb1:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ebb5:	0f b7 c0             	movzwl %ax,%eax
  81ebb8:	89 c7                	mov    %eax,%edi
  81ebba:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81ebc1:	00 00 00 
  81ebc4:	ff d0                	callq  *%rax
  81ebc6:	0f b7 c0             	movzwl %ax,%eax
  81ebc9:	83 e0 01             	and    $0x1,%eax
  81ebcc:	85 c0                	test   %eax,%eax
  81ebce:	75 2e                	jne    81ebfe <tcp_receive+0x88f>
  81ebd0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ebd4:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81ebdb:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ebdf:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ebe3:	0f b7 c0             	movzwl %ax,%eax
  81ebe6:	89 c7                	mov    %eax,%edi
  81ebe8:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81ebef:	00 00 00 
  81ebf2:	ff d0                	callq  *%rax
  81ebf4:	0f b7 c0             	movzwl %ax,%eax
  81ebf7:	83 e0 02             	and    $0x2,%eax
  81ebfa:	85 c0                	test   %eax,%eax
  81ebfc:	74 07                	je     81ec05 <tcp_receive+0x896>
  81ebfe:	b8 01 00 00 00       	mov    $0x1,%eax
  81ec03:	eb 05                	jmp    81ec0a <tcp_receive+0x89b>
  81ec05:	b8 00 00 00 00       	mov    $0x0,%eax
  81ec0a:	44 01 e0             	add    %r12d,%eax
  81ec0d:	44 01 e8             	add    %r13d,%eax
  81ec10:	29 c3                	sub    %eax,%ebx
  81ec12:	89 d8                	mov    %ebx,%eax
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81ec14:	85 c0                	test   %eax,%eax
  81ec16:	78 1f                	js     81ec37 <tcp_receive+0x8c8>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  81ec18:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81ec1f:	00 00 00 
  81ec22:	8b 10                	mov    (%rax),%edx
  81ec24:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec28:	8b 40 64             	mov    0x64(%rax),%eax
  81ec2b:	29 c2                	sub    %eax,%edx
  81ec2d:	89 d0                	mov    %edx,%eax
  81ec2f:	85 c0                	test   %eax,%eax
  81ec31:	0f 8e cb fd ff ff    	jle    81ea02 <tcp_receive+0x693>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  81ec37:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec3b:	8b 40 44             	mov    0x44(%rax),%eax
  81ec3e:	85 c0                	test   %eax,%eax
  81ec40:	0f 84 de 00 00 00    	je     81ed24 <tcp_receive+0x9b5>
  81ec46:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec4a:	8b 50 48             	mov    0x48(%rax),%edx
  81ec4d:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81ec54:	00 00 00 
  81ec57:	8b 00                	mov    (%rax),%eax
  81ec59:	29 c2                	sub    %eax,%edx
  81ec5b:	89 d0                	mov    %edx,%eax
  81ec5d:	85 c0                	test   %eax,%eax
  81ec5f:	0f 89 bf 00 00 00    	jns    81ed24 <tcp_receive+0x9b5>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
  81ec65:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81ec6c:	00 00 00 
  81ec6f:	8b 00                	mov    (%rax),%eax
  81ec71:	89 c2                	mov    %eax,%edx
  81ec73:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec77:	8b 40 44             	mov    0x44(%rax),%eax
  81ec7a:	29 c2                	sub    %eax,%edx
  81ec7c:	89 d0                	mov    %edx,%eax
  81ec7e:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  81ec82:	0f b7 55 c2          	movzwl -0x3e(%rbp),%edx
  81ec86:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec8a:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81ec8e:	66 c1 f8 03          	sar    $0x3,%ax
  81ec92:	29 c2                	sub    %eax,%edx
  81ec94:	89 d0                	mov    %edx,%eax
  81ec96:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      pcb->sa += m;
  81ec9a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec9e:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81eca2:	89 c2                	mov    %eax,%edx
  81eca4:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81eca8:	01 d0                	add    %edx,%eax
  81ecaa:	89 c2                	mov    %eax,%edx
  81ecac:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ecb0:	66 89 50 4c          	mov    %dx,0x4c(%rax)
      if (m < 0) {
  81ecb4:	66 83 7d c2 00       	cmpw   $0x0,-0x3e(%rbp)
  81ecb9:	79 0a                	jns    81ecc5 <tcp_receive+0x956>
        m = -m;
  81ecbb:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81ecbf:	f7 d8                	neg    %eax
  81ecc1:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      }
      m = m - (pcb->sv >> 2);
  81ecc5:	0f b7 55 c2          	movzwl -0x3e(%rbp),%edx
  81ecc9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eccd:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81ecd1:	66 c1 f8 02          	sar    $0x2,%ax
  81ecd5:	29 c2                	sub    %eax,%edx
  81ecd7:	89 d0                	mov    %edx,%eax
  81ecd9:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      pcb->sv += m;
  81ecdd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ece1:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81ece5:	89 c2                	mov    %eax,%edx
  81ece7:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81eceb:	01 d0                	add    %edx,%eax
  81eced:	89 c2                	mov    %eax,%edx
  81ecef:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ecf3:	66 89 50 4e          	mov    %dx,0x4e(%rax)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  81ecf7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ecfb:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81ecff:	66 c1 f8 03          	sar    $0x3,%ax
  81ed03:	89 c2                	mov    %eax,%edx
  81ed05:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed09:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81ed0d:	01 d0                	add    %edx,%eax
  81ed0f:	89 c2                	mov    %eax,%edx
  81ed11:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed15:	66 89 50 50          	mov    %dx,0x50(%rax)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  81ed19:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed1d:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  81ed24:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81ed2b:	00 00 00 
  81ed2e:	0f b7 00             	movzwl (%rax),%eax
  81ed31:	66 85 c0             	test   %ax,%ax
  81ed34:	0f 84 47 10 00 00    	je     81fd81 <tcp_receive+0x1a12>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  81ed3a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed3e:	8b 50 30             	mov    0x30(%rax),%edx
  81ed41:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ed48:	00 00 00 
  81ed4b:	8b 00                	mov    (%rax),%eax
  81ed4d:	29 c2                	sub    %eax,%edx
  81ed4f:	89 d0                	mov    %edx,%eax
  81ed51:	83 e8 01             	sub    $0x1,%eax
  81ed54:	85 c0                	test   %eax,%eax
  81ed56:	0f 88 ad 02 00 00    	js     81f009 <tcp_receive+0xc9a>
  81ed5c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed60:	8b 50 30             	mov    0x30(%rax),%edx
  81ed63:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81ed6a:	00 00 00 
  81ed6d:	0f b7 00             	movzwl (%rax),%eax
  81ed70:	0f b7 c8             	movzwl %ax,%ecx
  81ed73:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ed7a:	00 00 00 
  81ed7d:	8b 00                	mov    (%rax),%eax
  81ed7f:	01 c8                	add    %ecx,%eax
  81ed81:	29 c2                	sub    %eax,%edx
  81ed83:	89 d0                	mov    %edx,%eax
  81ed85:	83 c0 01             	add    $0x1,%eax
  81ed88:	85 c0                	test   %eax,%eax
  81ed8a:	0f 8f 79 02 00 00    	jg     81f009 <tcp_receive+0xc9a>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  81ed90:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed94:	8b 50 30             	mov    0x30(%rax),%edx
  81ed97:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ed9e:	00 00 00 
  81eda1:	8b 00                	mov    (%rax),%eax
  81eda3:	29 c2                	sub    %eax,%edx
  81eda5:	89 d0                	mov    %edx,%eax
  81eda7:	89 45 c4             	mov    %eax,-0x3c(%rbp)
      p = inseg.p;
  81edaa:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81edb1:	00 00 00 
  81edb4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81edb8:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  81edbc:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81edc3:	00 00 00 
  81edc6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81edca:	48 85 c0             	test   %rax,%rax
  81edcd:	75 2a                	jne    81edf9 <tcp_receive+0xa8a>
  81edcf:	48 ba 10 3e 82 00 00 	movabs $0x823e10,%rdx
  81edd6:	00 00 00 
  81edd9:	be e6 03 00 00       	mov    $0x3e6,%esi
  81edde:	48 bf 27 3c 82 00 00 	movabs $0x823c27,%rdi
  81ede5:	00 00 00 
  81ede8:	b8 00 00 00 00       	mov    $0x0,%eax
  81eded:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81edf4:	00 00 00 
  81edf7:	ff d1                	callq  *%rcx
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  81edf9:	81 7d c4 fe 7f 00 00 	cmpl   $0x7ffe,-0x3c(%rbp)
  81ee00:	7e 2a                	jle    81ee2c <tcp_receive+0xabd>
  81ee02:	48 ba 20 3e 82 00 00 	movabs $0x823e20,%rdx
  81ee09:	00 00 00 
  81ee0c:	be e7 03 00 00       	mov    $0x3e7,%esi
  81ee11:	48 bf 27 3c 82 00 00 	movabs $0x823c27,%rdi
  81ee18:	00 00 00 
  81ee1b:	b8 00 00 00 00       	mov    $0x0,%eax
  81ee20:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81ee27:	00 00 00 
  81ee2a:	ff d1                	callq  *%rcx
      if (inseg.p->len < off) {
  81ee2c:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ee33:	00 00 00 
  81ee36:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ee3a:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81ee3e:	0f b7 c0             	movzwl %ax,%eax
  81ee41:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81ee44:	0f 8d eb 00 00 00    	jge    81ef35 <tcp_receive+0xbc6>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  81ee4a:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ee51:	00 00 00 
  81ee54:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ee58:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81ee5c:	0f b7 c0             	movzwl %ax,%eax
  81ee5f:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81ee62:	7d 2a                	jge    81ee8e <tcp_receive+0xb1f>
  81ee64:	48 ba 2f 3e 82 00 00 	movabs $0x823e2f,%rdx
  81ee6b:	00 00 00 
  81ee6e:	be e9 03 00 00       	mov    $0x3e9,%esi
  81ee73:	48 bf 27 3c 82 00 00 	movabs $0x823c27,%rdi
  81ee7a:	00 00 00 
  81ee7d:	b8 00 00 00 00       	mov    $0x0,%eax
  81ee82:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81ee89:	00 00 00 
  81ee8c:	ff d1                	callq  *%rcx
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  81ee8e:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ee95:	00 00 00 
  81ee98:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ee9c:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81eea0:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  81eea3:	29 d0                	sub    %edx,%eax
  81eea5:	66 89 45 b8          	mov    %ax,-0x48(%rbp)
        while (p->len < off) {
  81eea9:	eb 2f                	jmp    81eeda <tcp_receive+0xb6b>
          off -= p->len;
  81eeab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81eeaf:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81eeb3:	0f b7 c0             	movzwl %ax,%eax
  81eeb6:	29 45 c4             	sub    %eax,-0x3c(%rbp)
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  81eeb9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81eebd:	0f b7 55 b8          	movzwl -0x48(%rbp),%edx
  81eec1:	66 89 50 10          	mov    %dx,0x10(%rax)
          p->len = 0;
  81eec5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81eec9:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
          p = p->next;
  81eecf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81eed3:	48 8b 00             	mov    (%rax),%rax
  81eed6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  81eeda:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81eede:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81eee2:	0f b7 c0             	movzwl %ax,%eax
  81eee5:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81eee8:	7c c1                	jl     81eeab <tcp_receive+0xb3c>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  81eeea:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81eeed:	f7 d8                	neg    %eax
  81eeef:	0f bf d0             	movswl %ax,%edx
  81eef2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81eef6:	89 d6                	mov    %edx,%esi
  81eef8:	48 89 c7             	mov    %rax,%rdi
  81eefb:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  81ef02:	00 00 00 
  81ef05:	ff d0                	callq  *%rax
  81ef07:	84 c0                	test   %al,%al
  81ef09:	74 7f                	je     81ef8a <tcp_receive+0xc1b>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  81ef0b:	48 ba 3f 3e 82 00 00 	movabs $0x823e3f,%rdx
  81ef12:	00 00 00 
  81ef15:	be f6 03 00 00       	mov    $0x3f6,%esi
  81ef1a:	48 bf 27 3c 82 00 00 	movabs $0x823c27,%rdi
  81ef21:	00 00 00 
  81ef24:	b8 00 00 00 00       	mov    $0x0,%eax
  81ef29:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81ef30:	00 00 00 
  81ef33:	ff d1                	callq  *%rcx
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  81ef35:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81ef38:	f7 d8                	neg    %eax
  81ef3a:	0f bf d0             	movswl %ax,%edx
  81ef3d:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ef44:	00 00 00 
  81ef47:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ef4b:	89 d6                	mov    %edx,%esi
  81ef4d:	48 89 c7             	mov    %rax,%rdi
  81ef50:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  81ef57:	00 00 00 
  81ef5a:	ff d0                	callq  *%rax
  81ef5c:	84 c0                	test   %al,%al
  81ef5e:	74 2a                	je     81ef8a <tcp_receive+0xc1b>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  81ef60:	48 ba 3f 3e 82 00 00 	movabs $0x823e3f,%rdx
  81ef67:	00 00 00 
  81ef6a:	be fb 03 00 00       	mov    $0x3fb,%esi
  81ef6f:	48 bf 27 3c 82 00 00 	movabs $0x823c27,%rdi
  81ef76:	00 00 00 
  81ef79:	b8 00 00 00 00       	mov    $0x0,%eax
  81ef7e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  81ef85:	00 00 00 
  81ef88:	ff d1                	callq  *%rcx
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  81ef8a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ef8e:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81ef92:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ef99:	00 00 00 
  81ef9c:	48 89 50 10          	mov    %rdx,0x10(%rax)
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  81efa0:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81efa7:	00 00 00 
  81efaa:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  81efae:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81efb5:	00 00 00 
  81efb8:	8b 00                	mov    (%rax),%eax
  81efba:	89 c1                	mov    %eax,%ecx
  81efbc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efc0:	8b 40 30             	mov    0x30(%rax),%eax
  81efc3:	29 c1                	sub    %eax,%ecx
  81efc5:	89 c8                	mov    %ecx,%eax
  81efc7:	01 c2                	add    %eax,%edx
  81efc9:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81efd0:	00 00 00 
  81efd3:	66 89 50 18          	mov    %dx,0x18(%rax)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  81efd7:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81efde:	00 00 00 
  81efe1:	48 8b 40 20          	mov    0x20(%rax),%rax
  81efe5:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81efe9:	8b 4a 30             	mov    0x30(%rdx),%ecx
  81efec:	48 ba d8 74 b5 00 00 	movabs $0xb574d8,%rdx
  81eff3:	00 00 00 
  81eff6:	89 0a                	mov    %ecx,(%rdx)
  81eff8:	48 ba d8 74 b5 00 00 	movabs $0xb574d8,%rdx
  81efff:	00 00 00 
  81f002:	8b 12                	mov    (%rdx),%edx
  81f004:	89 50 04             	mov    %edx,0x4(%rax)
  81f007:	eb 42                	jmp    81f04b <tcp_receive+0xcdc>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  81f009:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f010:	00 00 00 
  81f013:	8b 10                	mov    (%rax),%edx
  81f015:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f019:	8b 40 30             	mov    0x30(%rax),%eax
  81f01c:	29 c2                	sub    %eax,%edx
  81f01e:	89 d0                	mov    %edx,%eax
  81f020:	85 c0                	test   %eax,%eax
  81f022:	79 27                	jns    81f04b <tcp_receive+0xcdc>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  81f024:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f028:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f02c:	83 c8 02             	or     $0x2,%eax
  81f02f:	89 c2                	mov    %eax,%edx
  81f031:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f035:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f038:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f03c:	48 89 c7             	mov    %rax,%rdi
  81f03f:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  81f046:	00 00 00 
  81f049:	ff d0                	callq  *%rax
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  81f04b:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f052:	00 00 00 
  81f055:	8b 10                	mov    (%rax),%edx
  81f057:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f05b:	8b 40 30             	mov    0x30(%rax),%eax
  81f05e:	29 c2                	sub    %eax,%edx
  81f060:	89 d0                	mov    %edx,%eax
  81f062:	85 c0                	test   %eax,%eax
  81f064:	0f 88 ee 0c 00 00    	js     81fd58 <tcp_receive+0x19e9>
  81f06a:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f071:	00 00 00 
  81f074:	8b 10                	mov    (%rax),%edx
  81f076:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f07a:	8b 48 30             	mov    0x30(%rax),%ecx
  81f07d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f081:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81f085:	0f b7 c0             	movzwl %ax,%eax
  81f088:	01 c8                	add    %ecx,%eax
  81f08a:	29 c2                	sub    %eax,%edx
  81f08c:	89 d0                	mov    %edx,%eax
  81f08e:	83 c0 01             	add    $0x1,%eax
  81f091:	85 c0                	test   %eax,%eax
  81f093:	0f 8f bf 0c 00 00    	jg     81fd58 <tcp_receive+0x19e9>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f099:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f09d:	8b 50 30             	mov    0x30(%rax),%edx
  81f0a0:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f0a7:	00 00 00 
  81f0aa:	8b 00                	mov    (%rax),%eax
  81f0ac:	39 c2                	cmp    %eax,%edx
  81f0ae:	0f 85 42 07 00 00    	jne    81f7f6 <tcp_receive+0x1487>
        accepted_inseq = 1; 
  81f0b4:	c6 45 c1 01          	movb   $0x1,-0x3f(%rbp)
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  81f0b8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f0bc:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f0c3:	48 85 c0             	test   %rax,%rax
  81f0c6:	0f 84 4b 01 00 00    	je     81f217 <tcp_receive+0xea8>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  81f0cc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f0d0:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f0d7:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f0db:	8b 50 04             	mov    0x4(%rax),%edx
  81f0de:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f0e5:	00 00 00 
  81f0e8:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f0ec:	0f b7 c8             	movzwl %ax,%ecx
  81f0ef:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f0f6:	00 00 00 
  81f0f9:	8b 00                	mov    (%rax),%eax
  81f0fb:	01 c8                	add    %ecx,%eax
  81f0fd:	29 c2                	sub    %eax,%edx
  81f0ff:	89 d0                	mov    %edx,%eax
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  81f101:	85 c0                	test   %eax,%eax
  81f103:	0f 8f 0e 01 00 00    	jg     81f217 <tcp_receive+0xea8>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  81f109:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f10d:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f114:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f118:	66 85 c0             	test   %ax,%ax
  81f11b:	74 65                	je     81f182 <tcp_receive+0xe13>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  81f11d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f121:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f128:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f12c:	8b 40 04             	mov    0x4(%rax),%eax
  81f12f:	89 c2                	mov    %eax,%edx
  81f131:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f138:	00 00 00 
  81f13b:	8b 00                	mov    (%rax),%eax
  81f13d:	29 c2                	sub    %eax,%edx
  81f13f:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f146:	00 00 00 
  81f149:	66 89 50 18          	mov    %dx,0x18(%rax)
            pbuf_realloc(inseg.p, inseg.len);
  81f14d:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f154:	00 00 00 
  81f157:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f15b:	0f b7 d0             	movzwl %ax,%edx
  81f15e:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f165:	00 00 00 
  81f168:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f16c:	89 d6                	mov    %edx,%esi
  81f16e:	48 89 c7             	mov    %rax,%rdi
  81f171:	48 b8 ba d9 80 00 00 	movabs $0x80d9ba,%rax
  81f178:	00 00 00 
  81f17b:	ff d0                	callq  *%rax
  81f17d:	e9 95 00 00 00       	jmpq   81f217 <tcp_receive+0xea8>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81f182:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f189:	00 00 00 
  81f18c:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f190:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f194:	0f b7 c0             	movzwl %ax,%eax
  81f197:	89 c7                	mov    %eax,%edi
  81f199:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81f1a0:	00 00 00 
  81f1a3:	ff d0                	callq  *%rax
  81f1a5:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  81f1a7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f1ab:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f1b2:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f1b6:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f1ba:	0f b7 c0             	movzwl %ax,%eax
  81f1bd:	89 c7                	mov    %eax,%edi
  81f1bf:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81f1c6:	00 00 00 
  81f1c9:	ff d0                	callq  *%rax
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81f1cb:	31 d8                	xor    %ebx,%eax
  81f1cd:	0f b7 c0             	movzwl %ax,%eax
  81f1d0:	83 e0 03             	and    $0x3,%eax
  81f1d3:	85 c0                	test   %eax,%eax
  81f1d5:	75 40                	jne    81f217 <tcp_receive+0xea8>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  81f1d7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f1db:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f1e2:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
              pcb->ooseq = pcb->ooseq->next;
  81f1e6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f1ea:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f1f1:	48 8b 10             	mov    (%rax),%rdx
  81f1f4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f1f8:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  81f1ff:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  81f203:	48 89 c6             	mov    %rax,%rsi
  81f206:	bf 04 00 00 00       	mov    $0x4,%edi
  81f20b:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  81f212:	00 00 00 
  81f215:	ff d0                	callq  *%rax
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  81f217:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f21e:	00 00 00 
  81f221:	0f b7 58 18          	movzwl 0x18(%rax),%ebx
  81f225:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f22c:	00 00 00 
  81f22f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f233:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f237:	0f b7 c0             	movzwl %ax,%eax
  81f23a:	89 c7                	mov    %eax,%edi
  81f23c:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81f243:	00 00 00 
  81f246:	ff d0                	callq  *%rax
  81f248:	0f b7 c0             	movzwl %ax,%eax
  81f24b:	83 e0 01             	and    $0x1,%eax
  81f24e:	85 c0                	test   %eax,%eax
  81f250:	75 2d                	jne    81f27f <tcp_receive+0xf10>
  81f252:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f259:	00 00 00 
  81f25c:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f260:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f264:	0f b7 c0             	movzwl %ax,%eax
  81f267:	89 c7                	mov    %eax,%edi
  81f269:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81f270:	00 00 00 
  81f273:	ff d0                	callq  *%rax
  81f275:	0f b7 c0             	movzwl %ax,%eax
  81f278:	83 e0 02             	and    $0x2,%eax
  81f27b:	85 c0                	test   %eax,%eax
  81f27d:	74 07                	je     81f286 <tcp_receive+0xf17>
  81f27f:	b8 01 00 00 00       	mov    $0x1,%eax
  81f284:	eb 05                	jmp    81f28b <tcp_receive+0xf1c>
  81f286:	b8 00 00 00 00       	mov    $0x0,%eax
  81f28b:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81f28e:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81f295:	00 00 00 
  81f298:	66 89 10             	mov    %dx,(%rax)

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  81f29b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f29f:	8b 40 18             	mov    0x18(%rax),%eax
  81f2a2:	83 f8 07             	cmp    $0x7,%eax
  81f2a5:	74 20                	je     81f2c7 <tcp_receive+0xf58>
          pcb->rcv_nxt += tcplen;
  81f2a7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2ab:	8b 50 30             	mov    0x30(%rax),%edx
  81f2ae:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81f2b5:	00 00 00 
  81f2b8:	0f b7 00             	movzwl (%rax),%eax
  81f2bb:	0f b7 c0             	movzwl %ax,%eax
  81f2be:	01 c2                	add    %eax,%edx
  81f2c0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2c4:	89 50 30             	mov    %edx,0x30(%rax)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  81f2c7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2cb:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  81f2cf:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81f2d6:	00 00 00 
  81f2d9:	0f b7 00             	movzwl (%rax),%eax
  81f2dc:	66 39 c2             	cmp    %ax,%dx
  81f2df:	73 0c                	jae    81f2ed <tcp_receive+0xf7e>
          pcb->rcv_wnd = 0;
  81f2e1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2e5:	66 c7 40 34 00 00    	movw   $0x0,0x34(%rax)
  81f2eb:	eb 1f                	jmp    81f30c <tcp_receive+0xf9d>
        } else {
          pcb->rcv_wnd -= tcplen;
  81f2ed:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2f1:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  81f2f5:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81f2fc:	00 00 00 
  81f2ff:	0f b7 00             	movzwl (%rax),%eax
  81f302:	29 c2                	sub    %eax,%edx
  81f304:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f308:	66 89 50 34          	mov    %dx,0x34(%rax)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  81f30c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f310:	0f b7 50 36          	movzwl 0x36(%rax),%edx
  81f314:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81f31b:	00 00 00 
  81f31e:	0f b7 00             	movzwl (%rax),%eax
  81f321:	66 39 c2             	cmp    %ax,%dx
  81f324:	73 0c                	jae    81f332 <tcp_receive+0xfc3>
          pcb->rcv_ann_wnd = 0;
  81f326:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f32a:	66 c7 40 36 00 00    	movw   $0x0,0x36(%rax)
  81f330:	eb 1f                	jmp    81f351 <tcp_receive+0xfe2>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  81f332:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f336:	0f b7 50 36          	movzwl 0x36(%rax),%edx
  81f33a:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81f341:	00 00 00 
  81f344:	0f b7 00             	movzwl (%rax),%eax
  81f347:	29 c2                	sub    %eax,%edx
  81f349:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f34d:	66 89 50 36          	mov    %dx,0x36(%rax)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  81f351:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f358:	00 00 00 
  81f35b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f35f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81f363:	66 85 c0             	test   %ax,%ax
  81f366:	74 2d                	je     81f395 <tcp_receive+0x1026>
          recv_data = inseg.p;
  81f368:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f36f:	00 00 00 
  81f372:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81f376:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81f37d:	00 00 00 
  81f380:	48 89 10             	mov    %rdx,(%rax)
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  81f383:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f38a:	00 00 00 
  81f38d:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81f394:	00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  81f395:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f39c:	00 00 00 
  81f39f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f3a3:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f3a7:	0f b7 c0             	movzwl %ax,%eax
  81f3aa:	89 c7                	mov    %eax,%edi
  81f3ac:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81f3b3:	00 00 00 
  81f3b6:	ff d0                	callq  *%rax
  81f3b8:	0f b7 c0             	movzwl %ax,%eax
  81f3bb:	83 e0 01             	and    $0x1,%eax
  81f3be:	85 c0                	test   %eax,%eax
  81f3c0:	0f 84 94 03 00 00    	je     81f75a <tcp_receive+0x13eb>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  81f3c6:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81f3cd:	00 00 00 
  81f3d0:	c6 00 20             	movb   $0x20,(%rax)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81f3d3:	e9 82 03 00 00       	jmpq   81f75a <tcp_receive+0x13eb>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
  81f3d8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f3dc:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f3e3:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
          seqno = pcb->ooseq->tcphdr->seqno;
  81f3e7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f3eb:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f3f2:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f3f6:	8b 50 04             	mov    0x4(%rax),%edx
  81f3f9:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f400:	00 00 00 
  81f403:	89 10                	mov    %edx,(%rax)

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  81f405:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f409:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f40d:	0f b7 d8             	movzwl %ax,%ebx
  81f410:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f414:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f418:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f41c:	0f b7 c0             	movzwl %ax,%eax
  81f41f:	89 c7                	mov    %eax,%edi
  81f421:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81f428:	00 00 00 
  81f42b:	ff d0                	callq  *%rax
  81f42d:	0f b7 c0             	movzwl %ax,%eax
  81f430:	83 e0 01             	and    $0x1,%eax
  81f433:	85 c0                	test   %eax,%eax
  81f435:	75 27                	jne    81f45e <tcp_receive+0x10ef>
  81f437:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f43b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f43f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f443:	0f b7 c0             	movzwl %ax,%eax
  81f446:	89 c7                	mov    %eax,%edi
  81f448:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81f44f:	00 00 00 
  81f452:	ff d0                	callq  *%rax
  81f454:	0f b7 c0             	movzwl %ax,%eax
  81f457:	83 e0 02             	and    $0x2,%eax
  81f45a:	85 c0                	test   %eax,%eax
  81f45c:	74 07                	je     81f465 <tcp_receive+0x10f6>
  81f45e:	b8 01 00 00 00       	mov    $0x1,%eax
  81f463:	eb 05                	jmp    81f46a <tcp_receive+0x10fb>
  81f465:	b8 00 00 00 00       	mov    $0x0,%eax
  81f46a:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81f46d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f471:	8b 40 30             	mov    0x30(%rax),%eax
  81f474:	01 c2                	add    %eax,%edx
  81f476:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f47a:	89 50 30             	mov    %edx,0x30(%rax)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  81f47d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f481:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81f485:	0f b7 d8             	movzwl %ax,%ebx
  81f488:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f48c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f490:	44 0f b7 e0          	movzwl %ax,%r12d
  81f494:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f498:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f49c:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f4a0:	0f b7 c0             	movzwl %ax,%eax
  81f4a3:	89 c7                	mov    %eax,%edi
  81f4a5:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81f4ac:	00 00 00 
  81f4af:	ff d0                	callq  *%rax
  81f4b1:	0f b7 c0             	movzwl %ax,%eax
  81f4b4:	83 e0 01             	and    $0x1,%eax
  81f4b7:	85 c0                	test   %eax,%eax
  81f4b9:	75 27                	jne    81f4e2 <tcp_receive+0x1173>
  81f4bb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f4bf:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f4c3:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f4c7:	0f b7 c0             	movzwl %ax,%eax
  81f4ca:	89 c7                	mov    %eax,%edi
  81f4cc:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81f4d3:	00 00 00 
  81f4d6:	ff d0                	callq  *%rax
  81f4d8:	0f b7 c0             	movzwl %ax,%eax
  81f4db:	83 e0 02             	and    $0x2,%eax
  81f4de:	85 c0                	test   %eax,%eax
  81f4e0:	74 07                	je     81f4e9 <tcp_receive+0x117a>
  81f4e2:	b8 01 00 00 00       	mov    $0x1,%eax
  81f4e7:	eb 05                	jmp    81f4ee <tcp_receive+0x117f>
  81f4e9:	b8 00 00 00 00       	mov    $0x0,%eax
  81f4ee:	44 01 e0             	add    %r12d,%eax
  81f4f1:	39 c3                	cmp    %eax,%ebx
  81f4f3:	7d 0c                	jge    81f501 <tcp_receive+0x1192>
            pcb->rcv_wnd = 0;
  81f4f5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f4f9:	66 c7 40 34 00 00    	movw   $0x0,0x34(%rax)
  81f4ff:	eb 7c                	jmp    81f57d <tcp_receive+0x120e>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  81f501:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f505:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f509:	0f b7 d8             	movzwl %ax,%ebx
  81f50c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f510:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f514:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f518:	0f b7 c0             	movzwl %ax,%eax
  81f51b:	89 c7                	mov    %eax,%edi
  81f51d:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81f524:	00 00 00 
  81f527:	ff d0                	callq  *%rax
  81f529:	0f b7 c0             	movzwl %ax,%eax
  81f52c:	83 e0 01             	and    $0x1,%eax
  81f52f:	85 c0                	test   %eax,%eax
  81f531:	75 27                	jne    81f55a <tcp_receive+0x11eb>
  81f533:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f537:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f53b:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f53f:	0f b7 c0             	movzwl %ax,%eax
  81f542:	89 c7                	mov    %eax,%edi
  81f544:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81f54b:	00 00 00 
  81f54e:	ff d0                	callq  *%rax
  81f550:	0f b7 c0             	movzwl %ax,%eax
  81f553:	83 e0 02             	and    $0x2,%eax
  81f556:	85 c0                	test   %eax,%eax
  81f558:	74 07                	je     81f561 <tcp_receive+0x11f2>
  81f55a:	b8 01 00 00 00       	mov    $0x1,%eax
  81f55f:	eb 05                	jmp    81f566 <tcp_receive+0x11f7>
  81f561:	b8 00 00 00 00       	mov    $0x0,%eax
  81f566:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81f569:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f56d:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81f571:	29 d0                	sub    %edx,%eax
  81f573:	89 c2                	mov    %eax,%edx
  81f575:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f579:	66 89 50 34          	mov    %dx,0x34(%rax)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  81f57d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f581:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  81f585:	0f b7 d8             	movzwl %ax,%ebx
  81f588:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f58c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f590:	44 0f b7 e0          	movzwl %ax,%r12d
  81f594:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f598:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f59c:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f5a0:	0f b7 c0             	movzwl %ax,%eax
  81f5a3:	89 c7                	mov    %eax,%edi
  81f5a5:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81f5ac:	00 00 00 
  81f5af:	ff d0                	callq  *%rax
  81f5b1:	0f b7 c0             	movzwl %ax,%eax
  81f5b4:	83 e0 01             	and    $0x1,%eax
  81f5b7:	85 c0                	test   %eax,%eax
  81f5b9:	75 27                	jne    81f5e2 <tcp_receive+0x1273>
  81f5bb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f5bf:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f5c3:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f5c7:	0f b7 c0             	movzwl %ax,%eax
  81f5ca:	89 c7                	mov    %eax,%edi
  81f5cc:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81f5d3:	00 00 00 
  81f5d6:	ff d0                	callq  *%rax
  81f5d8:	0f b7 c0             	movzwl %ax,%eax
  81f5db:	83 e0 02             	and    $0x2,%eax
  81f5de:	85 c0                	test   %eax,%eax
  81f5e0:	74 07                	je     81f5e9 <tcp_receive+0x127a>
  81f5e2:	b8 01 00 00 00       	mov    $0x1,%eax
  81f5e7:	eb 05                	jmp    81f5ee <tcp_receive+0x127f>
  81f5e9:	b8 00 00 00 00       	mov    $0x0,%eax
  81f5ee:	44 01 e0             	add    %r12d,%eax
  81f5f1:	39 c3                	cmp    %eax,%ebx
  81f5f3:	7d 0c                	jge    81f601 <tcp_receive+0x1292>
            pcb->rcv_ann_wnd = 0;
  81f5f5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f5f9:	66 c7 40 36 00 00    	movw   $0x0,0x36(%rax)
  81f5ff:	eb 7c                	jmp    81f67d <tcp_receive+0x130e>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  81f601:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f605:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f609:	0f b7 d8             	movzwl %ax,%ebx
  81f60c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f610:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f614:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f618:	0f b7 c0             	movzwl %ax,%eax
  81f61b:	89 c7                	mov    %eax,%edi
  81f61d:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81f624:	00 00 00 
  81f627:	ff d0                	callq  *%rax
  81f629:	0f b7 c0             	movzwl %ax,%eax
  81f62c:	83 e0 01             	and    $0x1,%eax
  81f62f:	85 c0                	test   %eax,%eax
  81f631:	75 27                	jne    81f65a <tcp_receive+0x12eb>
  81f633:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f637:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f63b:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f63f:	0f b7 c0             	movzwl %ax,%eax
  81f642:	89 c7                	mov    %eax,%edi
  81f644:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81f64b:	00 00 00 
  81f64e:	ff d0                	callq  *%rax
  81f650:	0f b7 c0             	movzwl %ax,%eax
  81f653:	83 e0 02             	and    $0x2,%eax
  81f656:	85 c0                	test   %eax,%eax
  81f658:	74 07                	je     81f661 <tcp_receive+0x12f2>
  81f65a:	b8 01 00 00 00       	mov    $0x1,%eax
  81f65f:	eb 05                	jmp    81f666 <tcp_receive+0x12f7>
  81f661:	b8 00 00 00 00       	mov    $0x0,%eax
  81f666:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81f669:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f66d:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  81f671:	29 d0                	sub    %edx,%eax
  81f673:	89 c2                	mov    %eax,%edx
  81f675:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f679:	66 89 50 36          	mov    %dx,0x36(%rax)
          }

          if (cseg->p->tot_len > 0) {
  81f67d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f681:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f685:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81f689:	66 85 c0             	test   %ax,%ax
  81f68c:	74 5c                	je     81f6ea <tcp_receive+0x137b>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  81f68e:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81f695:	00 00 00 
  81f698:	48 8b 00             	mov    (%rax),%rax
  81f69b:	48 85 c0             	test   %rax,%rax
  81f69e:	74 29                	je     81f6c9 <tcp_receive+0x135a>
              pbuf_cat(recv_data, cseg->p);
  81f6a0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f6a4:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81f6a8:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81f6af:	00 00 00 
  81f6b2:	48 8b 00             	mov    (%rax),%rax
  81f6b5:	48 89 d6             	mov    %rdx,%rsi
  81f6b8:	48 89 c7             	mov    %rax,%rdi
  81f6bb:	48 b8 d4 df 80 00 00 	movabs $0x80dfd4,%rax
  81f6c2:	00 00 00 
  81f6c5:	ff d0                	callq  *%rax
  81f6c7:	eb 15                	jmp    81f6de <tcp_receive+0x136f>
            } else {
              recv_data = cseg->p;
  81f6c9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f6cd:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81f6d1:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81f6d8:	00 00 00 
  81f6db:	48 89 10             	mov    %rdx,(%rax)
            }
            cseg->p = NULL;
  81f6de:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f6e2:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81f6e9:	00 
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  81f6ea:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f6ee:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f6f2:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f6f6:	0f b7 c0             	movzwl %ax,%eax
  81f6f9:	89 c7                	mov    %eax,%edi
  81f6fb:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81f702:	00 00 00 
  81f705:	ff d0                	callq  *%rax
  81f707:	0f b7 c0             	movzwl %ax,%eax
  81f70a:	83 e0 01             	and    $0x1,%eax
  81f70d:	85 c0                	test   %eax,%eax
  81f70f:	74 24                	je     81f735 <tcp_receive+0x13c6>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  81f711:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81f718:	00 00 00 
  81f71b:	c6 00 20             	movb   $0x20,(%rax)
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  81f71e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f722:	8b 40 18             	mov    0x18(%rax),%eax
  81f725:	83 f8 04             	cmp    $0x4,%eax
  81f728:	75 0b                	jne    81f735 <tcp_receive+0x13c6>
              pcb->state = CLOSE_WAIT;
  81f72a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f72e:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
            } 
          }


          pcb->ooseq = cseg->next;
  81f735:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f739:	48 8b 10             	mov    (%rax),%rdx
  81f73c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f740:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
          tcp_seg_free(cseg);
  81f747:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f74b:	48 89 c7             	mov    %rax,%rdi
  81f74e:	48 b8 1b 05 81 00 00 	movabs $0x81051b,%rax
  81f755:	00 00 00 
  81f758:	ff d0                	callq  *%rax
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81f75a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f75e:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f765:	48 85 c0             	test   %rax,%rax
  81f768:	74 21                	je     81f78b <tcp_receive+0x141c>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  81f76a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f76e:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f775:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f779:	8b 50 04             	mov    0x4(%rax),%edx
  81f77c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f780:	8b 40 30             	mov    0x30(%rax),%eax
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81f783:	39 c2                	cmp    %eax,%edx
  81f785:	0f 84 4d fc ff ff    	je     81f3d8 <tcp_receive+0x1069>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  81f78b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f78f:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f793:	0f b6 c0             	movzbl %al,%eax
  81f796:	83 e0 01             	and    $0x1,%eax
  81f799:	85 c0                	test   %eax,%eax
  81f79b:	74 40                	je     81f7dd <tcp_receive+0x146e>
  81f79d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f7a1:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f7a5:	83 e0 fe             	and    $0xfffffffe,%eax
  81f7a8:	89 c2                	mov    %eax,%edx
  81f7aa:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f7ae:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f7b1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f7b5:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f7b9:	83 c8 02             	or     $0x2,%eax
  81f7bc:	89 c2                	mov    %eax,%edx
  81f7be:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f7c2:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f7c5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f7c9:	48 89 c7             	mov    %rax,%rdi
  81f7cc:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  81f7d3:	00 00 00 
  81f7d6:	ff d0                	callq  *%rax
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f7d8:	e9 11 06 00 00       	jmpq   81fdee <tcp_receive+0x1a7f>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  81f7dd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f7e1:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f7e5:	83 c8 01             	or     $0x1,%eax
  81f7e8:	89 c2                	mov    %eax,%edx
  81f7ea:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f7ee:	88 50 2c             	mov    %dl,0x2c(%rax)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f7f1:	e9 f8 05 00 00       	jmpq   81fdee <tcp_receive+0x1a7f>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  81f7f6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f7fa:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f7fe:	83 c8 02             	or     $0x2,%eax
  81f801:	89 c2                	mov    %eax,%edx
  81f803:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f807:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f80a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f80e:	48 89 c7             	mov    %rax,%rdi
  81f811:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  81f818:	00 00 00 
  81f81b:	ff d0                	callq  *%rax
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  81f81d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f821:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f828:	48 85 c0             	test   %rax,%rax
  81f82b:	75 29                	jne    81f856 <tcp_receive+0x14e7>
          pcb->ooseq = tcp_seg_copy(&inseg);
  81f82d:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f834:	00 00 00 
  81f837:	48 b8 96 05 81 00 00 	movabs $0x810596,%rax
  81f83e:	00 00 00 
  81f841:	ff d0                	callq  *%rax
  81f843:	48 89 c2             	mov    %rax,%rdx
  81f846:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f84a:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f851:	e9 98 05 00 00       	jmpq   81fdee <tcp_receive+0x1a7f>

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
  81f856:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  81f85d:	00 
          for(next = pcb->ooseq; next != NULL; next = next->next) {
  81f85e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f862:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f869:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81f86d:	e9 b8 04 00 00       	jmpq   81fd2a <tcp_receive+0x19bb>
            if (seqno == next->tcphdr->seqno) {
  81f872:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f876:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f87a:	8b 50 04             	mov    0x4(%rax),%edx
  81f87d:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f884:	00 00 00 
  81f887:	8b 00                	mov    (%rax),%eax
  81f889:	39 c2                	cmp    %eax,%edx
  81f88b:	0f 85 1f 01 00 00    	jne    81f9b0 <tcp_receive+0x1641>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  81f891:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f898:	00 00 00 
  81f89b:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  81f89f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f8a3:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f8a7:	66 39 c2             	cmp    %ax,%dx
  81f8aa:	0f 86 8a 04 00 00    	jbe    81fd3a <tcp_receive+0x19cb>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  81f8b0:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f8b7:	00 00 00 
  81f8ba:	48 b8 96 05 81 00 00 	movabs $0x810596,%rax
  81f8c1:	00 00 00 
  81f8c4:	ff d0                	callq  *%rax
  81f8c6:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                if (cseg != NULL) {
  81f8ca:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81f8cf:	0f 84 6b 04 00 00    	je     81fd40 <tcp_receive+0x19d1>
                  cseg->next = next->next;
  81f8d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f8d9:	48 8b 10             	mov    (%rax),%rdx
  81f8dc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f8e0:	48 89 10             	mov    %rdx,(%rax)
                  if (prev != NULL) {
  81f8e3:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81f8e8:	74 0d                	je     81f8f7 <tcp_receive+0x1588>
                    prev->next = cseg;
  81f8ea:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f8ee:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f8f2:	48 89 10             	mov    %rdx,(%rax)
  81f8f5:	eb 0f                	jmp    81f906 <tcp_receive+0x1597>
                  } else {
                    pcb->ooseq = cseg;
  81f8f7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f8fb:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f8ff:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
                  }
                  tcp_seg_free(next);
  81f906:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f90a:	48 89 c7             	mov    %rax,%rdi
  81f90d:	48 b8 1b 05 81 00 00 	movabs $0x81051b,%rax
  81f914:	00 00 00 
  81f917:	ff d0                	callq  *%rax
                  if (cseg->next != NULL) {
  81f919:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f91d:	48 8b 00             	mov    (%rax),%rax
  81f920:	48 85 c0             	test   %rax,%rax
  81f923:	0f 84 17 04 00 00    	je     81fd40 <tcp_receive+0x19d1>
                    next = cseg->next;
  81f929:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f92d:	48 8b 00             	mov    (%rax),%rax
  81f930:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  81f934:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f938:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f93c:	0f b7 d0             	movzwl %ax,%edx
  81f93f:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f946:	00 00 00 
  81f949:	8b 00                	mov    (%rax),%eax
  81f94b:	01 c2                	add    %eax,%edx
  81f94d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f951:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f955:	8b 40 04             	mov    0x4(%rax),%eax
  81f958:	29 c2                	sub    %eax,%edx
  81f95a:	89 d0                	mov    %edx,%eax
  81f95c:	85 c0                	test   %eax,%eax
  81f95e:	0f 8e dc 03 00 00    	jle    81fd40 <tcp_receive+0x19d1>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  81f964:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f968:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f96c:	8b 40 04             	mov    0x4(%rax),%eax
  81f96f:	89 c2                	mov    %eax,%edx
  81f971:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f978:	00 00 00 
  81f97b:	8b 00                	mov    (%rax),%eax
  81f97d:	29 c2                	sub    %eax,%edx
  81f97f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f983:	66 89 50 18          	mov    %dx,0x18(%rax)
                      pbuf_realloc(cseg->p, cseg->len);
  81f987:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f98b:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f98f:	0f b7 d0             	movzwl %ax,%edx
  81f992:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f996:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f99a:	89 d6                	mov    %edx,%esi
  81f99c:	48 89 c7             	mov    %rax,%rdi
  81f99f:	48 b8 ba d9 80 00 00 	movabs $0x80d9ba,%rax
  81f9a6:	00 00 00 
  81f9a9:	ff d0                	callq  *%rax
                    }
                  }
                }
                break;
  81f9ab:	e9 90 03 00 00       	jmpq   81fd40 <tcp_receive+0x19d1>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  81f9b0:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81f9b5:	0f 85 f2 00 00 00    	jne    81faad <tcp_receive+0x173e>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  81f9bb:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f9c2:	00 00 00 
  81f9c5:	8b 10                	mov    (%rax),%edx
  81f9c7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f9cb:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f9cf:	8b 40 04             	mov    0x4(%rax),%eax
  81f9d2:	29 c2                	sub    %eax,%edx
  81f9d4:	89 d0                	mov    %edx,%eax
  81f9d6:	85 c0                	test   %eax,%eax
  81f9d8:	0f 89 5d 02 00 00    	jns    81fc3b <tcp_receive+0x18cc>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  81f9de:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f9e5:	00 00 00 
  81f9e8:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f9ec:	0f b7 d0             	movzwl %ax,%edx
  81f9ef:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f9f6:	00 00 00 
  81f9f9:	8b 00                	mov    (%rax),%eax
  81f9fb:	01 c2                	add    %eax,%edx
  81f9fd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fa01:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fa05:	8b 40 04             	mov    0x4(%rax),%eax
  81fa08:	29 c2                	sub    %eax,%edx
  81fa0a:	89 d0                	mov    %edx,%eax
  81fa0c:	85 c0                	test   %eax,%eax
  81fa0e:	7e 59                	jle    81fa69 <tcp_receive+0x16fa>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  81fa10:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fa14:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fa18:	8b 40 04             	mov    0x4(%rax),%eax
  81fa1b:	89 c2                	mov    %eax,%edx
  81fa1d:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fa24:	00 00 00 
  81fa27:	8b 00                	mov    (%rax),%eax
  81fa29:	29 c2                	sub    %eax,%edx
  81fa2b:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81fa32:	00 00 00 
  81fa35:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(inseg.p, inseg.len);
  81fa39:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81fa40:	00 00 00 
  81fa43:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81fa47:	0f b7 d0             	movzwl %ax,%edx
  81fa4a:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81fa51:	00 00 00 
  81fa54:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fa58:	89 d6                	mov    %edx,%esi
  81fa5a:	48 89 c7             	mov    %rax,%rdi
  81fa5d:	48 b8 ba d9 80 00 00 	movabs $0x80d9ba,%rax
  81fa64:	00 00 00 
  81fa67:	ff d0                	callq  *%rax
                  }
                  cseg = tcp_seg_copy(&inseg);
  81fa69:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81fa70:	00 00 00 
  81fa73:	48 b8 96 05 81 00 00 	movabs $0x810596,%rax
  81fa7a:	00 00 00 
  81fa7d:	ff d0                	callq  *%rax
  81fa7f:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                  if (cseg != NULL) {
  81fa83:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81fa88:	0f 84 b8 02 00 00    	je     81fd46 <tcp_receive+0x19d7>
                    cseg->next = next;
  81fa8e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81fa92:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81fa96:	48 89 10             	mov    %rdx,(%rax)
                    pcb->ooseq = cseg;
  81fa99:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fa9d:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81faa1:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
                  }
                  break;
  81faa8:	e9 99 02 00 00       	jmpq   81fd46 <tcp_receive+0x19d7>
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  81faad:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fab4:	00 00 00 
  81fab7:	8b 10                	mov    (%rax),%edx
  81fab9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fabd:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fac1:	8b 40 04             	mov    0x4(%rax),%eax
  81fac4:	29 c2                	sub    %eax,%edx
  81fac6:	89 d0                	mov    %edx,%eax
  81fac8:	83 e8 01             	sub    $0x1,%eax
  81facb:	85 c0                	test   %eax,%eax
  81facd:	0f 88 68 01 00 00    	js     81fc3b <tcp_receive+0x18cc>
  81fad3:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fada:	00 00 00 
  81fadd:	8b 10                	mov    (%rax),%edx
  81fadf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fae3:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fae7:	8b 40 04             	mov    0x4(%rax),%eax
  81faea:	29 c2                	sub    %eax,%edx
  81faec:	89 d0                	mov    %edx,%eax
  81faee:	83 c0 01             	add    $0x1,%eax
  81faf1:	85 c0                	test   %eax,%eax
  81faf3:	0f 8f 42 01 00 00    	jg     81fc3b <tcp_receive+0x18cc>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  81faf9:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81fb00:	00 00 00 
  81fb03:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81fb07:	0f b7 d0             	movzwl %ax,%edx
  81fb0a:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fb11:	00 00 00 
  81fb14:	8b 00                	mov    (%rax),%eax
  81fb16:	01 c2                	add    %eax,%edx
  81fb18:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fb1c:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fb20:	8b 40 04             	mov    0x4(%rax),%eax
  81fb23:	29 c2                	sub    %eax,%edx
  81fb25:	89 d0                	mov    %edx,%eax
  81fb27:	85 c0                	test   %eax,%eax
  81fb29:	7e 59                	jle    81fb84 <tcp_receive+0x1815>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  81fb2b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fb2f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fb33:	8b 40 04             	mov    0x4(%rax),%eax
  81fb36:	89 c2                	mov    %eax,%edx
  81fb38:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fb3f:	00 00 00 
  81fb42:	8b 00                	mov    (%rax),%eax
  81fb44:	29 c2                	sub    %eax,%edx
  81fb46:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81fb4d:	00 00 00 
  81fb50:	66 89 50 18          	mov    %dx,0x18(%rax)
                  pbuf_realloc(inseg.p, inseg.len);
  81fb54:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81fb5b:	00 00 00 
  81fb5e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81fb62:	0f b7 d0             	movzwl %ax,%edx
  81fb65:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81fb6c:	00 00 00 
  81fb6f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fb73:	89 d6                	mov    %edx,%esi
  81fb75:	48 89 c7             	mov    %rax,%rdi
  81fb78:	48 b8 ba d9 80 00 00 	movabs $0x80d9ba,%rax
  81fb7f:	00 00 00 
  81fb82:	ff d0                	callq  *%rax
                }

                cseg = tcp_seg_copy(&inseg);
  81fb84:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81fb8b:	00 00 00 
  81fb8e:	48 b8 96 05 81 00 00 	movabs $0x810596,%rax
  81fb95:	00 00 00 
  81fb98:	ff d0                	callq  *%rax
  81fb9a:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                if (cseg != NULL) {
  81fb9e:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81fba3:	0f 84 a3 01 00 00    	je     81fd4c <tcp_receive+0x19dd>
                  cseg->next = next;
  81fba9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81fbad:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81fbb1:	48 89 10             	mov    %rdx,(%rax)
                  prev->next = cseg;
  81fbb4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fbb8:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81fbbc:	48 89 10             	mov    %rdx,(%rax)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  81fbbf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fbc3:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fbc7:	8b 50 04             	mov    0x4(%rax),%edx
  81fbca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fbce:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81fbd2:	0f b7 c0             	movzwl %ax,%eax
  81fbd5:	01 c2                	add    %eax,%edx
  81fbd7:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fbde:	00 00 00 
  81fbe1:	8b 00                	mov    (%rax),%eax
  81fbe3:	29 c2                	sub    %eax,%edx
  81fbe5:	89 d0                	mov    %edx,%eax
  81fbe7:	85 c0                	test   %eax,%eax
  81fbe9:	0f 8e 5d 01 00 00    	jle    81fd4c <tcp_receive+0x19dd>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  81fbef:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fbf6:	00 00 00 
  81fbf9:	8b 00                	mov    (%rax),%eax
  81fbfb:	89 c2                	mov    %eax,%edx
  81fbfd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fc01:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fc05:	8b 40 04             	mov    0x4(%rax),%eax
  81fc08:	29 c2                	sub    %eax,%edx
  81fc0a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fc0e:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(prev->p, prev->len);
  81fc12:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fc16:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81fc1a:	0f b7 d0             	movzwl %ax,%edx
  81fc1d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fc21:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fc25:	89 d6                	mov    %edx,%esi
  81fc27:	48 89 c7             	mov    %rax,%rdi
  81fc2a:	48 b8 ba d9 80 00 00 	movabs $0x80d9ba,%rax
  81fc31:	00 00 00 
  81fc34:	ff d0                	callq  *%rax
                  }
                }
                break;
  81fc36:	e9 11 01 00 00       	jmpq   81fd4c <tcp_receive+0x19dd>
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  81fc3b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fc3f:	48 8b 00             	mov    (%rax),%rax
  81fc42:	48 85 c0             	test   %rax,%rax
  81fc45:	0f 85 cc 00 00 00    	jne    81fd17 <tcp_receive+0x19a8>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  81fc4b:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fc52:	00 00 00 
  81fc55:	8b 10                	mov    (%rax),%edx
  81fc57:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fc5b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fc5f:	8b 40 04             	mov    0x4(%rax),%eax
  81fc62:	29 c2                	sub    %eax,%edx
  81fc64:	89 d0                	mov    %edx,%eax
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  81fc66:	85 c0                	test   %eax,%eax
  81fc68:	0f 8e a9 00 00 00    	jle    81fd17 <tcp_receive+0x19a8>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  81fc6e:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81fc75:	00 00 00 
  81fc78:	48 b8 96 05 81 00 00 	movabs $0x810596,%rax
  81fc7f:	00 00 00 
  81fc82:	ff d0                	callq  *%rax
  81fc84:	48 89 c2             	mov    %rax,%rdx
  81fc87:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fc8b:	48 89 10             	mov    %rdx,(%rax)
                if (next->next != NULL) {
  81fc8e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fc92:	48 8b 00             	mov    (%rax),%rax
  81fc95:	48 85 c0             	test   %rax,%rax
  81fc98:	0f 84 b4 00 00 00    	je     81fd52 <tcp_receive+0x19e3>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  81fc9e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fca2:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fca6:	8b 50 04             	mov    0x4(%rax),%edx
  81fca9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fcad:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81fcb1:	0f b7 c0             	movzwl %ax,%eax
  81fcb4:	01 c2                	add    %eax,%edx
  81fcb6:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fcbd:	00 00 00 
  81fcc0:	8b 00                	mov    (%rax),%eax
  81fcc2:	29 c2                	sub    %eax,%edx
  81fcc4:	89 d0                	mov    %edx,%eax
  81fcc6:	85 c0                	test   %eax,%eax
  81fcc8:	0f 8e 84 00 00 00    	jle    81fd52 <tcp_receive+0x19e3>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  81fcce:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fcd5:	00 00 00 
  81fcd8:	8b 00                	mov    (%rax),%eax
  81fcda:	89 c2                	mov    %eax,%edx
  81fcdc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fce0:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fce4:	8b 40 04             	mov    0x4(%rax),%eax
  81fce7:	29 c2                	sub    %eax,%edx
  81fce9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fced:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(next->p, next->len);
  81fcf1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fcf5:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81fcf9:	0f b7 d0             	movzwl %ax,%edx
  81fcfc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fd00:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fd04:	89 d6                	mov    %edx,%esi
  81fd06:	48 89 c7             	mov    %rax,%rdi
  81fd09:	48 b8 ba d9 80 00 00 	movabs $0x80d9ba,%rax
  81fd10:	00 00 00 
  81fd13:	ff d0                	callq  *%rax
                  }
                }
                break;
  81fd15:	eb 3b                	jmp    81fd52 <tcp_receive+0x19e3>
              }
            }
            prev = next;
  81fd17:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fd1b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
  81fd1f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fd23:	48 8b 00             	mov    (%rax),%rax
  81fd26:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81fd2a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81fd2f:	0f 85 3d fb ff ff    	jne    81f872 <tcp_receive+0x1503>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81fd35:	e9 b4 00 00 00       	jmpq   81fdee <tcp_receive+0x1a7f>
                break;
              } else {
                /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
  81fd3a:	90                   	nop
  81fd3b:	e9 ae 00 00 00       	jmpq   81fdee <tcp_receive+0x1a7f>
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
                      pbuf_realloc(cseg->p, cseg->len);
                    }
                  }
                }
                break;
  81fd40:	90                   	nop
  81fd41:	e9 a8 00 00 00       	jmpq   81fdee <tcp_receive+0x1a7f>
                  cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
                    cseg->next = next;
                    pcb->ooseq = cseg;
                  }
                  break;
  81fd46:	90                   	nop
  81fd47:	e9 a2 00 00 00       	jmpq   81fdee <tcp_receive+0x1a7f>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
                    pbuf_realloc(prev->p, prev->len);
                  }
                }
                break;
  81fd4c:	90                   	nop
  81fd4d:	e9 9c 00 00 00       	jmpq   81fdee <tcp_receive+0x1a7f>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
                    pbuf_realloc(next->p, next->len);
                  }
                }
                break;
  81fd52:	90                   	nop
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81fd53:	e9 96 00 00 00       	jmpq   81fdee <tcp_receive+0x1a7f>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  81fd58:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fd5c:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81fd60:	83 c8 02             	or     $0x2,%eax
  81fd63:	89 c2                	mov    %eax,%edx
  81fd65:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fd69:	88 50 2c             	mov    %dl,0x2c(%rax)
  81fd6c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fd70:	48 89 c7             	mov    %rax,%rdi
  81fd73:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  81fd7a:	00 00 00 
  81fd7d:	ff d0                	callq  *%rax
  81fd7f:	eb 6d                	jmp    81fdee <tcp_receive+0x1a7f>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  81fd81:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fd88:	00 00 00 
  81fd8b:	8b 10                	mov    (%rax),%edx
  81fd8d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fd91:	8b 40 30             	mov    0x30(%rax),%eax
  81fd94:	29 c2                	sub    %eax,%edx
  81fd96:	89 d0                	mov    %edx,%eax
  81fd98:	85 c0                	test   %eax,%eax
  81fd9a:	78 2b                	js     81fdc7 <tcp_receive+0x1a58>
  81fd9c:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81fda3:	00 00 00 
  81fda6:	8b 10                	mov    (%rax),%edx
  81fda8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fdac:	8b 48 30             	mov    0x30(%rax),%ecx
  81fdaf:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fdb3:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81fdb7:	0f b7 c0             	movzwl %ax,%eax
  81fdba:	01 c8                	add    %ecx,%eax
  81fdbc:	29 c2                	sub    %eax,%edx
  81fdbe:	89 d0                	mov    %edx,%eax
  81fdc0:	83 c0 01             	add    $0x1,%eax
  81fdc3:	85 c0                	test   %eax,%eax
  81fdc5:	7e 27                	jle    81fdee <tcp_receive+0x1a7f>
      tcp_ack_now(pcb);
  81fdc7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fdcb:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81fdcf:	83 c8 02             	or     $0x2,%eax
  81fdd2:	89 c2                	mov    %eax,%edx
  81fdd4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fdd8:	88 50 2c             	mov    %dl,0x2c(%rax)
  81fddb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81fddf:	48 89 c7             	mov    %rax,%rdi
  81fde2:	48 b8 64 3d 81 00 00 	movabs $0x813d64,%rax
  81fde9:	00 00 00 
  81fdec:	ff d0                	callq  *%rax
    }
  }
  return accepted_inseq;
  81fdee:	0f b6 45 c1          	movzbl -0x3f(%rbp),%eax
}
  81fdf2:	48 83 c4 58          	add    $0x58,%rsp
  81fdf6:	5b                   	pop    %rbx
  81fdf7:	41 5c                	pop    %r12
  81fdf9:	41 5d                	pop    %r13
  81fdfb:	5d                   	pop    %rbp
  81fdfc:	c3                   	retq   

000000000081fdfd <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  81fdfd:	55                   	push   %rbp
  81fdfe:	48 89 e5             	mov    %rsp,%rbp
  81fe01:	53                   	push   %rbx
  81fe02:	48 83 ec 38          	sub    $0x38,%rsp
  81fe06:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  81fe0a:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81fe11:	00 00 00 
  81fe14:	48 8b 00             	mov    (%rax),%rax
  81fe17:	48 83 c0 14          	add    $0x14,%rax
  81fe1b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  81fe1f:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81fe26:	00 00 00 
  81fe29:	48 8b 00             	mov    (%rax),%rax
  81fe2c:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81fe30:	0f b7 c0             	movzwl %ax,%eax
  81fe33:	89 c7                	mov    %eax,%edi
  81fe35:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81fe3c:	00 00 00 
  81fe3f:	ff d0                	callq  *%rax
  81fe41:	66 c1 e8 0c          	shr    $0xc,%ax
  81fe45:	66 83 f8 05          	cmp    $0x5,%ax
  81fe49:	0f 86 14 01 00 00    	jbe    81ff63 <tcp_parseopt+0x166>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  81fe4f:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  81fe53:	e9 ca 00 00 00       	jmpq   81ff22 <tcp_parseopt+0x125>
      opt = opts[c];
  81fe58:	0f b6 55 ef          	movzbl -0x11(%rbp),%edx
  81fe5c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fe60:	48 01 d0             	add    %rdx,%rax
  81fe63:	0f b6 00             	movzbl (%rax),%eax
  81fe66:	88 45 df             	mov    %al,-0x21(%rbp)
      if (opt == 0x00) {
  81fe69:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  81fe6d:	0f 84 ec 00 00 00    	je     81ff5f <tcp_parseopt+0x162>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  81fe73:	80 7d df 01          	cmpb   $0x1,-0x21(%rbp)
  81fe77:	75 09                	jne    81fe82 <tcp_parseopt+0x85>
        ++c;
  81fe79:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  81fe7d:	e9 a0 00 00 00       	jmpq   81ff22 <tcp_parseopt+0x125>
        /* NOP option. */
      } else if (opt == 0x02 &&
  81fe82:	80 7d df 02          	cmpb   $0x2,-0x21(%rbp)
  81fe86:	75 6f                	jne    81fef7 <tcp_parseopt+0xfa>
        opts[c + 1] == 0x04) {
  81fe88:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81fe8c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  81fe90:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fe94:	48 01 d0             	add    %rdx,%rax
  81fe97:	0f b6 00             	movzbl (%rax),%eax
        /* End of options. */
        break;
      } else if (opt == 0x01) {
        ++c;
        /* NOP option. */
      } else if (opt == 0x02 &&
  81fe9a:	3c 04                	cmp    $0x4,%al
  81fe9c:	75 59                	jne    81fef7 <tcp_parseopt+0xfa>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  81fe9e:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81fea2:	48 8d 50 02          	lea    0x2(%rax),%rdx
  81fea6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81feaa:	48 01 d0             	add    %rdx,%rax
  81fead:	0f b6 00             	movzbl (%rax),%eax
  81feb0:	0f b6 c0             	movzbl %al,%eax
  81feb3:	c1 e0 08             	shl    $0x8,%eax
  81feb6:	89 c1                	mov    %eax,%ecx
  81feb8:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81febc:	48 8d 50 03          	lea    0x3(%rax),%rdx
  81fec0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fec4:	48 01 d0             	add    %rdx,%rax
  81fec7:	0f b6 00             	movzbl (%rax),%eax
  81feca:	0f b6 c0             	movzbl %al,%eax
  81fecd:	09 c8                	or     %ecx,%eax
  81fecf:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  81fed3:	66 81 7d dc b4 05    	cmpw   $0x5b4,-0x24(%rbp)
  81fed9:	77 0d                	ja     81fee8 <tcp_parseopt+0xeb>
  81fedb:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  81fee0:	74 06                	je     81fee8 <tcp_parseopt+0xeb>
  81fee2:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  81fee6:	eb 05                	jmp    81feed <tcp_parseopt+0xf0>
  81fee8:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  81feed:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81fef1:	66 89 42 40          	mov    %ax,0x40(%rdx)

        /* And we are done processing options. */
        break;
  81fef5:	eb 6c                	jmp    81ff63 <tcp_parseopt+0x166>
      } else {
        if (opts[c + 1] == 0) {
  81fef7:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81fefb:	48 8d 50 01          	lea    0x1(%rax),%rdx
  81feff:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81ff03:	48 01 d0             	add    %rdx,%rax
  81ff06:	0f b6 00             	movzbl (%rax),%eax
  81ff09:	84 c0                	test   %al,%al
  81ff0b:	74 55                	je     81ff62 <tcp_parseopt+0x165>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  81ff0d:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81ff11:	48 8d 50 01          	lea    0x1(%rax),%rdx
  81ff15:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81ff19:	48 01 d0             	add    %rdx,%rax
  81ff1c:	0f b6 00             	movzbl (%rax),%eax
  81ff1f:	00 45 ef             	add    %al,-0x11(%rbp)

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  81ff22:	0f b6 5d ef          	movzbl -0x11(%rbp),%ebx
  81ff26:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81ff2d:	00 00 00 
  81ff30:	48 8b 00             	mov    (%rax),%rax
  81ff33:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ff37:	0f b7 c0             	movzwl %ax,%eax
  81ff3a:	89 c7                	mov    %eax,%edi
  81ff3c:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81ff43:	00 00 00 
  81ff46:	ff d0                	callq  *%rax
  81ff48:	66 c1 e8 0c          	shr    $0xc,%ax
  81ff4c:	0f b7 c0             	movzwl %ax,%eax
  81ff4f:	83 e8 05             	sub    $0x5,%eax
  81ff52:	c1 e0 02             	shl    $0x2,%eax
  81ff55:	39 c3                	cmp    %eax,%ebx
  81ff57:	0f 8c fb fe ff ff    	jl     81fe58 <tcp_parseopt+0x5b>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  81ff5d:	eb 04                	jmp    81ff63 <tcp_parseopt+0x166>
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
      if (opt == 0x00) {
        /* End of options. */
        break;
  81ff5f:	90                   	nop
  81ff60:	eb 01                	jmp    81ff63 <tcp_parseopt+0x166>
        break;
      } else {
        if (opts[c + 1] == 0) {
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          break;
  81ff62:	90                   	nop
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  81ff63:	90                   	nop
  81ff64:	48 83 c4 38          	add    $0x38,%rsp
  81ff68:	5b                   	pop    %rbx
  81ff69:	5d                   	pop    %rbp
  81ff6a:	c3                   	retq   

000000000081ff6b <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  81ff6b:	55                   	push   %rbp
  81ff6c:	48 89 e5             	mov    %rsp,%rbp
  81ff6f:	48 83 ec 40          	sub    $0x40,%rsp
  81ff73:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81ff77:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
  81ff7b:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  81ff7f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ff83:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ff87:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  proto = IPH_PROTO(iphdr);
  81ff8b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81ff8f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81ff93:	0f b7 c0             	movzwl %ax,%eax
  81ff96:	89 c7                	mov    %eax,%edi
  81ff98:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  81ff9f:	00 00 00 
  81ffa2:	ff d0                	callq  *%rax
  81ffa4:	66 25 ff 00          	and    $0xff,%ax
  81ffa8:	66 89 45 de          	mov    %ax,-0x22(%rbp)

  prev = NULL;
  81ffac:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  81ffb3:	00 
  pcb = raw_pcbs;
  81ffb4:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81ffbb:	00 00 00 
  81ffbe:	48 8b 00             	mov    (%rax),%rax
  81ffc1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  81ffc5:	e9 a3 00 00 00       	jmpq   82006d <raw_input+0x102>
    if (pcb->protocol == proto) {
  81ffca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ffce:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81ffd2:	0f b6 d0             	movzbl %al,%edx
  81ffd5:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  81ffd9:	39 c2                	cmp    %eax,%edx
  81ffdb:	75 7c                	jne    820059 <raw_input+0xee>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  81ffdd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ffe1:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ffe5:	48 85 c0             	test   %rax,%rax
  81ffe8:	74 6f                	je     820059 <raw_input+0xee>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  81ffea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ffee:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fff2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81fff6:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  81fffa:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81fffe:	48 8b 7a 28          	mov    0x28(%rdx),%rdi
  820002:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  820006:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  82000a:	ff d0                	callq  *%rax
  82000c:	84 c0                	test   %al,%al
  82000e:	74 49                	je     820059 <raw_input+0xee>
        {
          /* receive function ate the packet */
          p = NULL;
  820010:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  820017:	00 
          eaten = 1;
  820018:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
          if (prev != NULL) {
  82001c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  820021:	74 36                	je     820059 <raw_input+0xee>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  820023:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820027:	48 8b 50 10          	mov    0x10(%rax),%rdx
  82002b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  82002f:	48 89 50 10          	mov    %rdx,0x10(%rax)
            pcb->next = raw_pcbs;
  820033:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  82003a:	00 00 00 
  82003d:	48 8b 10             	mov    (%rax),%rdx
  820040:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820044:	48 89 50 10          	mov    %rdx,0x10(%rax)
            raw_pcbs = pcb;
  820048:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  82004f:	00 00 00 
  820052:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  820056:	48 89 10             	mov    %rdx,(%rax)
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  820059:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82005d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    pcb = pcb->next;
  820061:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820065:	48 8b 40 10          	mov    0x10(%rax),%rax
  820069:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  82006d:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  820071:	75 0b                	jne    82007e <raw_input+0x113>
  820073:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  820078:	0f 85 4c ff ff ff    	jne    81ffca <raw_input+0x5f>
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
  82007e:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  820082:	c9                   	leaveq 
  820083:	c3                   	retq   

0000000000820084 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  820084:	55                   	push   %rbp
  820085:	48 89 e5             	mov    %rsp,%rbp
  820088:	48 83 ec 10          	sub    $0x10,%rsp
  82008c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  820090:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&pcb->local_ip, ipaddr);
  820094:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  820099:	74 08                	je     8200a3 <raw_bind+0x1f>
  82009b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  82009f:	8b 00                	mov    (%rax),%eax
  8200a1:	eb 05                	jmp    8200a8 <raw_bind+0x24>
  8200a3:	b8 00 00 00 00       	mov    $0x0,%eax
  8200a8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8200ac:	89 02                	mov    %eax,(%rdx)
  return ERR_OK;
  8200ae:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8200b3:	c9                   	leaveq 
  8200b4:	c3                   	retq   

00000000008200b5 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  8200b5:	55                   	push   %rbp
  8200b6:	48 89 e5             	mov    %rsp,%rbp
  8200b9:	48 83 ec 10          	sub    $0x10,%rsp
  8200bd:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8200c1:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&pcb->remote_ip, ipaddr);
  8200c5:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8200ca:	74 08                	je     8200d4 <raw_connect+0x1f>
  8200cc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8200d0:	8b 00                	mov    (%rax),%eax
  8200d2:	eb 05                	jmp    8200d9 <raw_connect+0x24>
  8200d4:	b8 00 00 00 00       	mov    $0x0,%eax
  8200d9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8200dd:	89 42 04             	mov    %eax,0x4(%rdx)
  return ERR_OK;
  8200e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8200e5:	c9                   	leaveq 
  8200e6:	c3                   	retq   

00000000008200e7 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  8200e7:	55                   	push   %rbp
  8200e8:	48 89 e5             	mov    %rsp,%rbp
  8200eb:	48 83 ec 18          	sub    $0x18,%rsp
  8200ef:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8200f3:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8200f7:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
  8200fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8200ff:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  820103:	48 89 50 20          	mov    %rdx,0x20(%rax)
  pcb->recv_arg = recv_arg;
  820107:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82010b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  82010f:	48 89 50 28          	mov    %rdx,0x28(%rax)
}
  820113:	90                   	nop
  820114:	c9                   	leaveq 
  820115:	c3                   	retq   

0000000000820116 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  820116:	55                   	push   %rbp
  820117:	48 89 e5             	mov    %rsp,%rbp
  82011a:	48 83 ec 40          	sub    $0x40,%rsp
  82011e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  820122:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  820126:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  82012a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  82012e:	be 14 00 00 00       	mov    $0x14,%esi
  820133:	48 89 c7             	mov    %rax,%rdi
  820136:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  82013d:	00 00 00 
  820140:	ff d0                	callq  *%rax
  820142:	84 c0                	test   %al,%al
  820144:	74 4c                	je     820192 <raw_sendto+0x7c>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  820146:	ba 00 00 00 00       	mov    $0x0,%edx
  82014b:	be 00 00 00 00       	mov    $0x0,%esi
  820150:	bf 01 00 00 00       	mov    $0x1,%edi
  820155:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  82015c:	00 00 00 
  82015f:	ff d0                	callq  *%rax
  820161:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  820165:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  82016a:	75 0a                	jne    820176 <raw_sendto+0x60>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  82016c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  820171:	e9 4a 01 00 00       	jmpq   8202c0 <raw_sendto+0x1aa>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  820176:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  82017a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  82017e:	48 89 d6             	mov    %rdx,%rsi
  820181:	48 89 c7             	mov    %rax,%rdi
  820184:	48 b8 f4 e0 80 00 00 	movabs $0x80e0f4,%rax
  82018b:	00 00 00 
  82018e:	ff d0                	callq  *%rax
  820190:	eb 4e                	jmp    8201e0 <raw_sendto+0xca>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  820192:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  820196:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    if(pbuf_header(q, -IP_HLEN)) {
  82019a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  82019e:	be ec ff ff ff       	mov    $0xffffffec,%esi
  8201a3:	48 89 c7             	mov    %rax,%rdi
  8201a6:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  8201ad:	00 00 00 
  8201b0:	ff d0                	callq  *%rax
  8201b2:	84 c0                	test   %al,%al
  8201b4:	74 2a                	je     8201e0 <raw_sendto+0xca>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  8201b6:	48 ba 58 3e 82 00 00 	movabs $0x823e58,%rdx
  8201bd:	00 00 00 
  8201c0:	be e4 00 00 00       	mov    $0xe4,%esi
  8201c5:	48 bf 7e 3e 82 00 00 	movabs $0x823e7e,%rdi
  8201cc:	00 00 00 
  8201cf:	b8 00 00 00 00       	mov    $0x0,%eax
  8201d4:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8201db:	00 00 00 
  8201de:	ff d1                	callq  *%rcx
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  8201e0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8201e4:	48 89 c7             	mov    %rax,%rdi
  8201e7:	48 b8 88 0e 81 00 00 	movabs $0x810e88,%rax
  8201ee:	00 00 00 
  8201f1:	ff d0                	callq  *%rax
  8201f3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8201f7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8201fc:	75 27                	jne    820225 <raw_sendto+0x10f>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  8201fe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  820202:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  820206:	74 13                	je     82021b <raw_sendto+0x105>
      pbuf_free(q);
  820208:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  82020c:	48 89 c7             	mov    %rax,%rdi
  82020f:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  820216:	00 00 00 
  820219:	ff d0                	callq  *%rax
    }
    return ERR_RTE;
  82021b:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  820220:	e9 9b 00 00 00       	jmpq   8202c0 <raw_sendto+0x1aa>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  820225:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820229:	48 85 c0             	test   %rax,%rax
  82022c:	74 0a                	je     820238 <raw_sendto+0x122>
  82022e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820232:	8b 00                	mov    (%rax),%eax
  820234:	85 c0                	test   %eax,%eax
  820236:	75 0e                	jne    820246 <raw_sendto+0x130>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  820238:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82023c:	48 83 c0 08          	add    $0x8,%rax
  820240:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  820244:	eb 08                	jmp    82024e <raw_sendto+0x138>
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  820246:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  82024a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  82024e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820252:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  820256:	44 0f b6 c0          	movzbl %al,%r8d
  82025a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  82025e:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  820262:	0f b6 f8             	movzbl %al,%edi
  820265:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820269:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  82026d:	0f b6 c8             	movzbl %al,%ecx
  820270:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  820274:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  820278:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  82027c:	48 83 ec 08          	sub    $0x8,%rsp
  820280:	ff 75 e8             	pushq  -0x18(%rbp)
  820283:	45 89 c1             	mov    %r8d,%r9d
  820286:	41 89 f8             	mov    %edi,%r8d
  820289:	48 89 c7             	mov    %rax,%rdi
  82028c:	48 b8 be 13 81 00 00 	movabs $0x8113be,%rax
  820293:	00 00 00 
  820296:	ff d0                	callq  *%rax
  820298:	48 83 c4 10          	add    $0x10,%rsp
  82029c:	88 45 e7             	mov    %al,-0x19(%rbp)
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  82029f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8202a3:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8202a7:	74 13                	je     8202bc <raw_sendto+0x1a6>
    /* free the header */
    pbuf_free(q);
  8202a9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8202ad:	48 89 c7             	mov    %rax,%rdi
  8202b0:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  8202b7:	00 00 00 
  8202ba:	ff d0                	callq  *%rax
  }
  return err;
  8202bc:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
}
  8202c0:	c9                   	leaveq 
  8202c1:	c3                   	retq   

00000000008202c2 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  8202c2:	55                   	push   %rbp
  8202c3:	48 89 e5             	mov    %rsp,%rbp
  8202c6:	48 83 ec 10          	sub    $0x10,%rsp
  8202ca:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8202ce:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  return raw_sendto(pcb, p, &pcb->remote_ip);
  8202d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8202d6:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8202da:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8202de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8202e2:	48 89 ce             	mov    %rcx,%rsi
  8202e5:	48 89 c7             	mov    %rax,%rdi
  8202e8:	48 b8 16 01 82 00 00 	movabs $0x820116,%rax
  8202ef:	00 00 00 
  8202f2:	ff d0                	callq  *%rax
}
  8202f4:	c9                   	leaveq 
  8202f5:	c3                   	retq   

00000000008202f6 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  8202f6:	55                   	push   %rbp
  8202f7:	48 89 e5             	mov    %rsp,%rbp
  8202fa:	48 83 ec 20          	sub    $0x20,%rsp
  8202fe:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  820302:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  820309:	00 00 00 
  82030c:	48 8b 00             	mov    (%rax),%rax
  82030f:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  820313:	75 20                	jne    820335 <raw_remove+0x3f>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  820315:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  82031c:	00 00 00 
  82031f:	48 8b 00             	mov    (%rax),%rax
  820322:	48 8b 50 10          	mov    0x10(%rax),%rdx
  820326:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  82032d:	00 00 00 
  820330:	48 89 10             	mov    %rdx,(%rax)
  820333:	eb 51                	jmp    820386 <raw_remove+0x90>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  820335:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  82033c:	00 00 00 
  82033f:	48 8b 00             	mov    (%rax),%rax
  820342:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  820346:	eb 37                	jmp    82037f <raw_remove+0x89>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  820348:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82034c:	48 8b 40 10          	mov    0x10(%rax),%rax
  820350:	48 85 c0             	test   %rax,%rax
  820353:	74 1e                	je     820373 <raw_remove+0x7d>
  820355:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820359:	48 8b 40 10          	mov    0x10(%rax),%rax
  82035d:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  820361:	75 10                	jne    820373 <raw_remove+0x7d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  820363:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820367:	48 8b 50 10          	mov    0x10(%rax),%rdx
  82036b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82036f:	48 89 50 10          	mov    %rdx,0x10(%rax)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  820373:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820377:	48 8b 40 10          	mov    0x10(%rax),%rax
  82037b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  82037f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  820384:	75 c2                	jne    820348 <raw_remove+0x52>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  820386:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82038a:	48 89 c6             	mov    %rax,%rsi
  82038d:	bf 00 00 00 00       	mov    $0x0,%edi
  820392:	48 b8 7a cf 80 00 00 	movabs $0x80cf7a,%rax
  820399:	00 00 00 
  82039c:	ff d0                	callq  *%rax
}
  82039e:	90                   	nop
  82039f:	c9                   	leaveq 
  8203a0:	c3                   	retq   

00000000008203a1 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  8203a1:	55                   	push   %rbp
  8203a2:	48 89 e5             	mov    %rsp,%rbp
  8203a5:	48 83 ec 20          	sub    $0x20,%rsp
  8203a9:	89 f8                	mov    %edi,%eax
  8203ab:	88 45 ec             	mov    %al,-0x14(%rbp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  8203ae:	bf 00 00 00 00       	mov    $0x0,%edi
  8203b3:	48 b8 cf ce 80 00 00 	movabs $0x80cecf,%rax
  8203ba:	00 00 00 
  8203bd:	ff d0                	callq  *%rax
  8203bf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  8203c3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8203c8:	74 56                	je     820420 <raw_new+0x7f>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  8203ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8203ce:	ba 30 00 00 00       	mov    $0x30,%edx
  8203d3:	be 00 00 00 00       	mov    $0x0,%esi
  8203d8:	48 89 c7             	mov    %rax,%rdi
  8203db:	48 b8 5c 21 80 00 00 	movabs $0x80215c,%rax
  8203e2:	00 00 00 
  8203e5:	ff d0                	callq  *%rax
    pcb->protocol = proto;
  8203e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8203eb:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  8203ef:	88 50 18             	mov    %dl,0x18(%rax)
    pcb->ttl = RAW_TTL;
  8203f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8203f6:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
    pcb->next = raw_pcbs;
  8203fa:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  820401:	00 00 00 
  820404:	48 8b 10             	mov    (%rax),%rdx
  820407:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82040b:	48 89 50 10          	mov    %rdx,0x10(%rax)
    raw_pcbs = pcb;
  82040f:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  820416:	00 00 00 
  820419:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  82041d:	48 89 10             	mov    %rdx,(%rax)
  }
  return pcb;
  820420:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  820424:	c9                   	leaveq 
  820425:	c3                   	retq   

0000000000820426 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  820426:	55                   	push   %rbp
  820427:	48 89 e5             	mov    %rsp,%rbp
  82042a:	53                   	push   %rbx
  82042b:	48 83 ec 48          	sub    $0x48,%rsp
  82042f:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  820433:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  820437:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82043b:	48 8b 40 08          	mov    0x8(%rax),%rax
  82043f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  hlen = IPH_HL(iphdr) * 4;
  820443:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820447:	0f b7 00             	movzwl (%rax),%eax
  82044a:	0f b7 c0             	movzwl %ax,%eax
  82044d:	89 c7                	mov    %eax,%edi
  82044f:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  820456:	00 00 00 
  820459:	ff d0                	callq  *%rax
  82045b:	66 c1 e8 08          	shr    $0x8,%ax
  82045f:	83 e0 0f             	and    $0xf,%eax
  820462:	c1 e0 02             	shl    $0x2,%eax
  820465:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  820469:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
  82046d:	f7 d8                	neg    %eax
  82046f:	0f bf d0             	movswl %ax,%edx
  820472:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820476:	89 d6                	mov    %edx,%esi
  820478:	48 89 c7             	mov    %rax,%rdi
  82047b:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  820482:	00 00 00 
  820485:	ff d0                	callq  *%rax
  820487:	84 c0                	test   %al,%al
  820489:	0f 85 97 04 00 00    	jne    820926 <icmp_input+0x500>
  82048f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820493:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  820497:	66 83 f8 03          	cmp    $0x3,%ax
  82049b:	0f 86 85 04 00 00    	jbe    820926 <icmp_input+0x500>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  8204a1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8204a5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8204a9:	0f b6 00             	movzbl (%rax),%eax
  8204ac:	88 45 e5             	mov    %al,-0x1b(%rbp)
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
  8204af:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8204b3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8204b7:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8204bb:	88 45 e4             	mov    %al,-0x1c(%rbp)
#endif /* LWIP_DEBUG */
  switch (type) {
  8204be:	0f b6 45 e5          	movzbl -0x1b(%rbp),%eax
  8204c2:	83 f8 08             	cmp    $0x8,%eax
  8204c5:	0f 85 46 04 00 00    	jne    820911 <icmp_input+0x4eb>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  8204cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8204cf:	48 8d 50 10          	lea    0x10(%rax),%rdx
  8204d3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8204d7:	48 89 c6             	mov    %rax,%rsi
  8204da:	48 89 d7             	mov    %rdx,%rdi
  8204dd:	48 b8 eb 0d 81 00 00 	movabs $0x810deb,%rax
  8204e4:	00 00 00 
  8204e7:	ff d0                	callq  *%rax
  8204e9:	84 c0                	test   %al,%al
  8204eb:	75 2f                	jne    82051c <icmp_input+0xf6>
  8204ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8204f1:	8b 58 10             	mov    0x10(%rax),%ebx
  8204f4:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  8204f9:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  820500:	00 00 00 
  820503:	ff d0                	callq  *%rax
  820505:	21 c3                	and    %eax,%ebx
  820507:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  82050c:	48 b8 95 31 81 00 00 	movabs $0x813195,%rax
  820513:	00 00 00 
  820516:	ff d0                	callq  *%rax
  820518:	39 c3                	cmp    %eax,%ebx
  82051a:	75 18                	jne    820534 <icmp_input+0x10e>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  82051c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820520:	48 89 c7             	mov    %rax,%rdi
  820523:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  82052a:	00 00 00 
  82052d:	ff d0                	callq  *%rax
      return;
  82052f:	e9 20 04 00 00       	jmpq   820954 <icmp_input+0x52e>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  820534:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820538:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  82053c:	66 83 f8 07          	cmp    $0x7,%ax
  820540:	0f 86 e3 03 00 00    	jbe    820929 <icmp_input+0x503>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  820546:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82054a:	48 89 c7             	mov    %rax,%rdi
  82054d:	48 b8 f8 2b 81 00 00 	movabs $0x812bf8,%rax
  820554:	00 00 00 
  820557:	ff d0                	callq  *%rax
  820559:	66 85 c0             	test   %ax,%ax
  82055c:	74 18                	je     820576 <icmp_input+0x150>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  82055e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820562:	48 89 c7             	mov    %rax,%rdi
  820565:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  82056c:	00 00 00 
  82056f:	ff d0                	callq  *%rax
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  820571:	e9 de 03 00 00       	jmpq   820954 <icmp_input+0x52e>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  820576:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82057a:	be 22 00 00 00       	mov    $0x22,%esi
  82057f:	48 89 c7             	mov    %rax,%rdi
  820582:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  820589:	00 00 00 
  82058c:	ff d0                	callq  *%rax
  82058e:	84 c0                	test   %al,%al
  820590:	0f 84 79 01 00 00    	je     82070f <icmp_input+0x2e9>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  820596:	0f bf 55 e6          	movswl -0x1a(%rbp),%edx
  82059a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82059e:	89 d6                	mov    %edx,%esi
  8205a0:	48 89 c7             	mov    %rax,%rdi
  8205a3:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  8205aa:	00 00 00 
  8205ad:	ff d0                	callq  *%rax
  8205af:	84 c0                	test   %al,%al
  8205b1:	74 2a                	je     8205dd <icmp_input+0x1b7>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  8205b3:	48 ba 98 3e 82 00 00 	movabs $0x823e98,%rdx
  8205ba:	00 00 00 
  8205bd:	be 7c 00 00 00       	mov    $0x7c,%esi
  8205c2:	48 bf cb 3e 82 00 00 	movabs $0x823ecb,%rdi
  8205c9:	00 00 00 
  8205cc:	b8 00 00 00 00       	mov    $0x0,%eax
  8205d1:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8205d8:	00 00 00 
  8205db:	ff d1                	callq  *%rcx
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  8205dd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8205e1:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8205e5:	0f b7 c0             	movzwl %ax,%eax
  8205e8:	ba 00 00 00 00       	mov    $0x0,%edx
  8205ed:	89 c6                	mov    %eax,%esi
  8205ef:	bf 02 00 00 00       	mov    $0x2,%edi
  8205f4:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  8205fb:	00 00 00 
  8205fe:	ff d0                	callq  *%rax
  820600:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      if (r == NULL) {
  820604:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  820609:	0f 84 30 03 00 00    	je     82093f <icmp_input+0x519>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  82060f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820613:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  820617:	0f b7 c0             	movzwl %ax,%eax
  82061a:	48 0f bf 55 e6       	movswq -0x1a(%rbp),%rdx
  82061f:	48 83 c2 08          	add    $0x8,%rdx
  820623:	48 39 d0             	cmp    %rdx,%rax
  820626:	73 2a                	jae    820652 <icmp_input+0x22c>
  820628:	48 ba e8 3e 82 00 00 	movabs $0x823ee8,%rdx
  82062f:	00 00 00 
  820632:	be 86 00 00 00       	mov    $0x86,%esi
  820637:	48 bf cb 3e 82 00 00 	movabs $0x823ecb,%rdi
  82063e:	00 00 00 
  820641:	b8 00 00 00 00       	mov    $0x0,%eax
  820646:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  82064d:	00 00 00 
  820650:	ff d1                	callq  *%rcx
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  820652:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  820656:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  82065a:	48 89 d6             	mov    %rdx,%rsi
  82065d:	48 89 c7             	mov    %rax,%rdi
  820660:	48 b8 4a e2 80 00 00 	movabs $0x80e24a,%rax
  820667:	00 00 00 
  82066a:	ff d0                	callq  *%rax
  82066c:	84 c0                	test   %al,%al
  82066e:	74 2a                	je     82069a <icmp_input+0x274>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  820670:	48 ba 20 3f 82 00 00 	movabs $0x823f20,%rdx
  820677:	00 00 00 
  82067a:	be 89 00 00 00       	mov    $0x89,%esi
  82067f:	48 bf cb 3e 82 00 00 	movabs $0x823ecb,%rdi
  820686:	00 00 00 
  820689:	b8 00 00 00 00       	mov    $0x0,%eax
  82068e:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  820695:	00 00 00 
  820698:	ff d1                	callq  *%rcx
        goto memerr;
      }
      iphdr = r->payload;
  82069a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  82069e:	48 8b 40 08          	mov    0x8(%rax),%rax
  8206a2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  8206a6:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
  8206aa:	f7 d8                	neg    %eax
  8206ac:	0f bf d0             	movswl %ax,%edx
  8206af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8206b3:	89 d6                	mov    %edx,%esi
  8206b5:	48 89 c7             	mov    %rax,%rdi
  8206b8:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  8206bf:	00 00 00 
  8206c2:	ff d0                	callq  *%rax
  8206c4:	84 c0                	test   %al,%al
  8206c6:	74 2a                	je     8206f2 <icmp_input+0x2cc>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  8206c8:	48 ba 48 3f 82 00 00 	movabs $0x823f48,%rdx
  8206cf:	00 00 00 
  8206d2:	be 8f 00 00 00       	mov    $0x8f,%esi
  8206d7:	48 bf cb 3e 82 00 00 	movabs $0x823ecb,%rdi
  8206de:	00 00 00 
  8206e1:	b8 00 00 00 00       	mov    $0x0,%eax
  8206e6:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8206ed:	00 00 00 
  8206f0:	ff d1                	callq  *%rcx
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  8206f2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8206f6:	48 89 c7             	mov    %rax,%rdi
  8206f9:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  820700:	00 00 00 
  820703:	ff d0                	callq  *%rax
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  820705:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820709:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  82070d:	eb 46                	jmp    820755 <icmp_input+0x32f>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  82070f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820713:	be de ff ff ff       	mov    $0xffffffde,%esi
  820718:	48 89 c7             	mov    %rax,%rdi
  82071b:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  820722:	00 00 00 
  820725:	ff d0                	callq  *%rax
  820727:	84 c0                	test   %al,%al
  820729:	74 2a                	je     820755 <icmp_input+0x32f>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  82072b:	48 ba 48 3f 82 00 00 	movabs $0x823f48,%rdx
  820732:	00 00 00 
  820735:	be 99 00 00 00       	mov    $0x99,%esi
  82073a:	48 bf cb 3e 82 00 00 	movabs $0x823ecb,%rdi
  820741:	00 00 00 
  820744:	b8 00 00 00 00       	mov    $0x0,%eax
  820749:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  820750:	00 00 00 
  820753:	ff d1                	callq  *%rcx
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  820755:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820759:	48 8b 40 08          	mov    0x8(%rax),%rax
  82075d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    tmpaddr.addr = iphdr->src.addr;
  820761:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820765:	8b 40 0c             	mov    0xc(%rax),%eax
  820768:	89 45 c0             	mov    %eax,-0x40(%rbp)
    iphdr->src.addr = iphdr->dest.addr;
  82076b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82076f:	8b 50 10             	mov    0x10(%rax),%edx
  820772:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820776:	89 50 0c             	mov    %edx,0xc(%rax)
    iphdr->dest.addr = tmpaddr.addr;
  820779:	8b 55 c0             	mov    -0x40(%rbp),%edx
  82077c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820780:	89 50 10             	mov    %edx,0x10(%rax)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  820783:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  820787:	0f b7 00             	movzwl (%rax),%eax
  82078a:	0f b7 c0             	movzwl %ax,%eax
  82078d:	89 c7                	mov    %eax,%edi
  82078f:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  820796:	00 00 00 
  820799:	ff d0                	callq  *%rax
  82079b:	0f b7 c0             	movzwl %ax,%eax
  82079e:	0f b6 c0             	movzbl %al,%eax
  8207a1:	89 c7                	mov    %eax,%edi
  8207a3:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8207aa:	00 00 00 
  8207ad:	ff d0                	callq  *%rax
  8207af:	89 c2                	mov    %eax,%edx
  8207b1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8207b5:	66 89 10             	mov    %dx,(%rax)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  8207b8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8207bc:	0f b7 58 02          	movzwl 0x2(%rax),%ebx
  8207c0:	bf ff f7 00 00       	mov    $0xf7ff,%edi
  8207c5:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8207cc:	00 00 00 
  8207cf:	ff d0                	callq  *%rax
  8207d1:	66 39 c3             	cmp    %ax,%bx
  8207d4:	72 2b                	jb     820801 <icmp_input+0x3db>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  8207d6:	bf 00 08 00 00       	mov    $0x800,%edi
  8207db:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  8207e2:	00 00 00 
  8207e5:	ff d0                	callq  *%rax
  8207e7:	0f b7 c0             	movzwl %ax,%eax
  8207ea:	8d 50 01             	lea    0x1(%rax),%edx
  8207ed:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8207f1:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8207f5:	01 c2                	add    %eax,%edx
  8207f7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8207fb:	66 89 50 02          	mov    %dx,0x2(%rax)
  8207ff:	eb 25                	jmp    820826 <icmp_input+0x400>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  820801:	bf 00 08 00 00       	mov    $0x800,%edi
  820806:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  82080d:	00 00 00 
  820810:	ff d0                	callq  *%rax
  820812:	89 c2                	mov    %eax,%edx
  820814:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  820818:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  82081c:	01 c2                	add    %eax,%edx
  82081e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  820822:	66 89 50 02          	mov    %dx,0x2(%rax)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  820826:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82082a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  82082e:	0f b7 c0             	movzwl %ax,%eax
  820831:	89 c7                	mov    %eax,%edi
  820833:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  82083a:	00 00 00 
  82083d:	ff d0                	callq  *%rax
  82083f:	66 0d 00 ff          	or     $0xff00,%ax
  820843:	0f b7 c0             	movzwl %ax,%eax
  820846:	89 c7                	mov    %eax,%edi
  820848:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  82084f:	00 00 00 
  820852:	ff d0                	callq  *%rax
  820854:	89 c2                	mov    %eax,%edx
  820856:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82085a:	66 89 50 08          	mov    %dx,0x8(%rax)
    IPH_CHKSUM_SET(iphdr, 0);
  82085e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820862:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  820868:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82086c:	be 14 00 00 00       	mov    $0x14,%esi
  820871:	48 89 c7             	mov    %rax,%rdi
  820874:	48 b8 c9 2b 81 00 00 	movabs $0x812bc9,%rax
  82087b:	00 00 00 
  82087e:	ff d0                	callq  *%rax
  820880:	89 c2                	mov    %eax,%edx
  820882:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820886:	66 89 50 0a          	mov    %dx,0xa(%rax)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  82088a:	0f bf 55 e6          	movswl -0x1a(%rbp),%edx
  82088e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820892:	89 d6                	mov    %edx,%esi
  820894:	48 89 c7             	mov    %rax,%rdi
  820897:	48 b8 05 dc 80 00 00 	movabs $0x80dc05,%rax
  82089e:	00 00 00 
  8208a1:	ff d0                	callq  *%rax
  8208a3:	84 c0                	test   %al,%al
  8208a5:	74 2a                	je     8208d1 <icmp_input+0x4ab>
      LWIP_ASSERT("Can't move over header in packet", 0);
  8208a7:	48 ba 80 3f 82 00 00 	movabs $0x823f80,%rdx
  8208ae:	00 00 00 
  8208b1:	be ba 00 00 00       	mov    $0xba,%esi
  8208b6:	48 bf cb 3e 82 00 00 	movabs $0x823ecb,%rdi
  8208bd:	00 00 00 
  8208c0:	b8 00 00 00 00       	mov    $0x0,%eax
  8208c5:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8208cc:	00 00 00 
  8208cf:	ff d1                	callq  *%rcx
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  8208d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8208d5:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  8208d9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8208dd:	48 83 ec 08          	sub    $0x8,%rsp
  8208e1:	ff 75 b0             	pushq  -0x50(%rbp)
  8208e4:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  8208ea:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8208f0:	b9 ff 00 00 00       	mov    $0xff,%ecx
  8208f5:	ba 00 00 00 00       	mov    $0x0,%edx
  8208fa:	48 89 c7             	mov    %rax,%rdi
  8208fd:	48 b8 be 13 81 00 00 	movabs $0x8113be,%rax
  820904:	00 00 00 
  820907:	ff d0                	callq  *%rax
  820909:	48 83 c4 10          	add    $0x10,%rsp
  82090d:	88 45 cf             	mov    %al,-0x31(%rbp)
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
  820910:	90                   	nop
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  820911:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820915:	48 89 c7             	mov    %rax,%rdi
  820918:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  82091f:	00 00 00 
  820922:	ff d0                	callq  *%rax
  return;
  820924:	eb 2e                	jmp    820954 <icmp_input+0x52e>

  iphdr = p->payload;
  hlen = IPH_HL(iphdr) * 4;
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  820926:	90                   	nop
  820927:	eb 01                	jmp    82092a <icmp_input+0x504>
      return;
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
  820929:	90                   	nop
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  return;
lenerr:
  pbuf_free(p);
  82092a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82092e:	48 89 c7             	mov    %rax,%rdi
  820931:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  820938:	00 00 00 
  82093b:	ff d0                	callq  *%rax
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  82093d:	eb 15                	jmp    820954 <icmp_input+0x52e>
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
  82093f:	90                   	nop
  pbuf_free(p);
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
memerr:
  pbuf_free(p);
  820940:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820944:	48 89 c7             	mov    %rax,%rdi
  820947:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  82094e:	00 00 00 
  820951:	ff d0                	callq  *%rax
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
  820953:	90                   	nop
}
  820954:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  820958:	c9                   	leaveq 
  820959:	c3                   	retq   

000000000082095a <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  82095a:	55                   	push   %rbp
  82095b:	48 89 e5             	mov    %rsp,%rbp
  82095e:	48 83 ec 30          	sub    $0x30,%rsp
  820962:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  820966:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  820969:	ba 00 00 00 00       	mov    $0x0,%edx
  82096e:	be 24 00 00 00       	mov    $0x24,%esi
  820973:	bf 01 00 00 00       	mov    $0x1,%edi
  820978:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  82097f:	00 00 00 
  820982:	ff d0                	callq  *%rax
  820984:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 PBUF_RAM);
  if (q == NULL) {
  820988:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  82098d:	0f 84 68 01 00 00    	je     820afb <icmp_dest_unreach+0x1a1>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  820993:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820997:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  82099b:	66 83 f8 23          	cmp    $0x23,%ax
  82099f:	77 2a                	ja     8209cb <icmp_dest_unreach+0x71>
  8209a1:	48 ba a8 3f 82 00 00 	movabs $0x823fa8,%rdx
  8209a8:	00 00 00 
  8209ab:	be f0 00 00 00       	mov    $0xf0,%esi
  8209b0:	48 bf cb 3e 82 00 00 	movabs $0x823ecb,%rdi
  8209b7:	00 00 00 
  8209ba:	b8 00 00 00 00       	mov    $0x0,%eax
  8209bf:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  8209c6:	00 00 00 
  8209c9:	ff d1                	callq  *%rcx
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  8209cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8209cf:	48 8b 40 08          	mov    0x8(%rax),%rax
  8209d3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  idur = q->payload;
  8209d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8209db:	48 8b 40 08          	mov    0x8(%rax),%rax
  8209df:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  8209e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8209e7:	0f b7 00             	movzwl (%rax),%eax
  8209ea:	0f b7 c0             	movzwl %ax,%eax
  8209ed:	89 c7                	mov    %eax,%edi
  8209ef:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  8209f6:	00 00 00 
  8209f9:	ff d0                	callq  *%rax
  8209fb:	0f b6 c0             	movzbl %al,%eax
  8209fe:	80 cc 03             	or     $0x3,%ah
  820a01:	0f b7 c0             	movzwl %ax,%eax
  820a04:	89 c7                	mov    %eax,%edi
  820a06:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  820a0d:	00 00 00 
  820a10:	ff d0                	callq  *%rax
  820a12:	89 c2                	mov    %eax,%edx
  820a14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820a18:	66 89 10             	mov    %dx,(%rax)
  ICMPH_CODE_SET(idur, t);
  820a1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820a1f:	0f b7 00             	movzwl (%rax),%eax
  820a22:	0f b7 c0             	movzwl %ax,%eax
  820a25:	89 c7                	mov    %eax,%edi
  820a27:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  820a2e:	00 00 00 
  820a31:	ff d0                	callq  *%rax
  820a33:	b0 00                	mov    $0x0,%al
  820a35:	89 c2                	mov    %eax,%edx
  820a37:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  820a3a:	09 d0                	or     %edx,%eax
  820a3c:	0f b7 c0             	movzwl %ax,%eax
  820a3f:	89 c7                	mov    %eax,%edi
  820a41:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  820a48:	00 00 00 
  820a4b:	ff d0                	callq  *%rax
  820a4d:	89 c2                	mov    %eax,%edx
  820a4f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820a53:	66 89 10             	mov    %dx,(%rax)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  820a56:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820a5a:	48 8b 40 08          	mov    0x8(%rax),%rax
  820a5e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  820a62:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  820a66:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  820a6a:	ba 1c 00 00 00       	mov    $0x1c,%edx
  820a6f:	48 89 c6             	mov    %rax,%rsi
  820a72:	48 89 cf             	mov    %rcx,%rdi
  820a75:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  820a7c:	00 00 00 
  820a7f:	ff d0                	callq  *%rax
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  820a81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820a85:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
  idur->chksum = inet_chksum(idur, q->len);
  820a8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820a8f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  820a93:	0f b7 d0             	movzwl %ax,%edx
  820a96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820a9a:	89 d6                	mov    %edx,%esi
  820a9c:	48 89 c7             	mov    %rax,%rdi
  820a9f:	48 b8 c9 2b 81 00 00 	movabs $0x812bc9,%rax
  820aa6:	00 00 00 
  820aa9:	ff d0                	callq  *%rax
  820aab:	89 c2                	mov    %eax,%edx
  820aad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820ab1:	66 89 50 02          	mov    %dx,0x2(%rax)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  820ab5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  820ab9:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  820abd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820ac1:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  820ac7:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  820acd:	b9 ff 00 00 00       	mov    $0xff,%ecx
  820ad2:	be 00 00 00 00       	mov    $0x0,%esi
  820ad7:	48 89 c7             	mov    %rax,%rdi
  820ada:	48 b8 80 16 81 00 00 	movabs $0x811680,%rax
  820ae1:	00 00 00 
  820ae4:	ff d0                	callq  *%rax
  pbuf_free(q);
  820ae6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820aea:	48 89 c7             	mov    %rax,%rdi
  820aed:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  820af4:	00 00 00 
  820af7:	ff d0                	callq  *%rax
  820af9:	eb 01                	jmp    820afc <icmp_dest_unreach+0x1a2>
  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
                 PBUF_RAM);
  if (q == NULL) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  820afb:	90                   	nop
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
}
  820afc:	c9                   	leaveq 
  820afd:	c3                   	retq   

0000000000820afe <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  820afe:	55                   	push   %rbp
  820aff:	48 89 e5             	mov    %rsp,%rbp
  820b02:	48 83 ec 30          	sub    $0x30,%rsp
  820b06:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  820b0a:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  820b0d:	ba 00 00 00 00       	mov    $0x0,%edx
  820b12:	be 24 00 00 00       	mov    $0x24,%esi
  820b17:	bf 01 00 00 00       	mov    $0x1,%edi
  820b1c:	48 b8 e7 d4 80 00 00 	movabs $0x80d4e7,%rax
  820b23:	00 00 00 
  820b26:	ff d0                	callq  *%rax
  820b28:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 PBUF_RAM);
  if (q == NULL) {
  820b2c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  820b31:	0f 84 68 01 00 00    	je     820c9f <icmp_time_exceeded+0x1a1>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  820b37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820b3b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  820b3f:	66 83 f8 23          	cmp    $0x23,%ax
  820b43:	77 2a                	ja     820b6f <icmp_time_exceeded+0x71>
  820b45:	48 ba a8 3f 82 00 00 	movabs $0x823fa8,%rdx
  820b4c:	00 00 00 
  820b4f:	be 1f 01 00 00       	mov    $0x11f,%esi
  820b54:	48 bf cb 3e 82 00 00 	movabs $0x823ecb,%rdi
  820b5b:	00 00 00 
  820b5e:	b8 00 00 00 00       	mov    $0x0,%eax
  820b63:	48 b9 f8 10 80 00 00 	movabs $0x8010f8,%rcx
  820b6a:	00 00 00 
  820b6d:	ff d1                	callq  *%rcx
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  820b6f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820b73:	48 8b 40 08          	mov    0x8(%rax),%rax
  820b77:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  820b7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820b7f:	48 8b 40 08          	mov    0x8(%rax),%rax
  820b83:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  820b87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820b8b:	0f b7 00             	movzwl (%rax),%eax
  820b8e:	0f b7 c0             	movzwl %ax,%eax
  820b91:	89 c7                	mov    %eax,%edi
  820b93:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  820b9a:	00 00 00 
  820b9d:	ff d0                	callq  *%rax
  820b9f:	0f b6 c0             	movzbl %al,%eax
  820ba2:	80 cc 0b             	or     $0xb,%ah
  820ba5:	0f b7 c0             	movzwl %ax,%eax
  820ba8:	89 c7                	mov    %eax,%edi
  820baa:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  820bb1:	00 00 00 
  820bb4:	ff d0                	callq  *%rax
  820bb6:	89 c2                	mov    %eax,%edx
  820bb8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820bbc:	66 89 10             	mov    %dx,(%rax)
  ICMPH_CODE_SET(tehdr, t);
  820bbf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820bc3:	0f b7 00             	movzwl (%rax),%eax
  820bc6:	0f b7 c0             	movzwl %ax,%eax
  820bc9:	89 c7                	mov    %eax,%edi
  820bcb:	48 b8 3b 31 81 00 00 	movabs $0x81313b,%rax
  820bd2:	00 00 00 
  820bd5:	ff d0                	callq  *%rax
  820bd7:	b0 00                	mov    $0x0,%al
  820bd9:	89 c2                	mov    %eax,%edx
  820bdb:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  820bde:	09 d0                	or     %edx,%eax
  820be0:	0f b7 c0             	movzwl %ax,%eax
  820be3:	89 c7                	mov    %eax,%edi
  820be5:	48 b8 18 31 81 00 00 	movabs $0x813118,%rax
  820bec:	00 00 00 
  820bef:	ff d0                	callq  *%rax
  820bf1:	89 c2                	mov    %eax,%edx
  820bf3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820bf7:	66 89 10             	mov    %dx,(%rax)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  820bfa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820bfe:	48 8b 40 08          	mov    0x8(%rax),%rax
  820c02:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  820c06:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  820c0a:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  820c0e:	ba 1c 00 00 00       	mov    $0x1c,%edx
  820c13:	48 89 c6             	mov    %rax,%rsi
  820c16:	48 89 cf             	mov    %rcx,%rdi
  820c19:	48 b8 fe 22 80 00 00 	movabs $0x8022fe,%rax
  820c20:	00 00 00 
  820c23:	ff d0                	callq  *%rax
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  820c25:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820c29:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  820c2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820c33:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  820c37:	0f b7 d0             	movzwl %ax,%edx
  820c3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820c3e:	89 d6                	mov    %edx,%esi
  820c40:	48 89 c7             	mov    %rax,%rdi
  820c43:	48 b8 c9 2b 81 00 00 	movabs $0x812bc9,%rax
  820c4a:	00 00 00 
  820c4d:	ff d0                	callq  *%rax
  820c4f:	89 c2                	mov    %eax,%edx
  820c51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820c55:	66 89 50 02          	mov    %dx,0x2(%rax)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  820c59:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  820c5d:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  820c61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820c65:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  820c6b:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  820c71:	b9 ff 00 00 00       	mov    $0xff,%ecx
  820c76:	be 00 00 00 00       	mov    $0x0,%esi
  820c7b:	48 89 c7             	mov    %rax,%rdi
  820c7e:	48 b8 80 16 81 00 00 	movabs $0x811680,%rax
  820c85:	00 00 00 
  820c88:	ff d0                	callq  *%rax
  pbuf_free(q);
  820c8a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820c8e:	48 89 c7             	mov    %rax,%rdi
  820c91:	48 b8 c8 dd 80 00 00 	movabs $0x80ddc8,%rax
  820c98:	00 00 00 
  820c9b:	ff d0                	callq  *%rax
  820c9d:	eb 01                	jmp    820ca0 <icmp_time_exceeded+0x1a2>
  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
                 PBUF_RAM);
  if (q == NULL) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  820c9f:	90                   	nop
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
}
  820ca0:	c9                   	leaveq 
  820ca1:	c3                   	retq   
