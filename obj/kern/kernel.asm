
obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .bootstrap:

0000000000100000 <_head64>:
// VMCALL to the VMM to get a multiboot map.
    movl $VMX_VMCALL_MBMAP, %eax
    vmcall
#endif
	
    movl $multiboot_info, %eax
  100000:	b8 00 70 10 00       	mov    $0x107000,%eax
    movl %ebx, (%eax)
  100005:	89 18                	mov    %ebx,(%rax)

#ifndef VMM_GUEST
    movw $0x1234,0x472			# warm boot
  100007:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472(%rip)        # 100482 <verify_cpu_no_longmode+0x36f>
  10000e:	34 12 
#endif
	
# Reset the stack pointer in case we didn't come from the loader
    movl $0x7c00,%esp
  100010:	bc 00 7c 00 00       	mov    $0x7c00,%esp

    call verify_cpu   #check if CPU supports long mode
  100015:	e8 cc 00 00 00       	callq  1000e6 <verify_cpu>
#ifndef VMM_GUEST
    movl $CR4_PAE,%eax
  10001a:	b8 20 00 00 00       	mov    $0x20,%eax
#else
    movl $(CR4_PAE|CR4_VMXE),%eax
#endif
    movl %eax,%cr4
  10001f:	0f 22 e0             	mov    %rax,%cr4

# build an early boot pml4 at physical address pml4phys 

    #initializing the page tables
    movl $pml4,%edi
  100022:	bf 00 20 10 00       	mov    $0x102000,%edi
    xorl %eax,%eax
  100027:	31 c0                	xor    %eax,%eax
    movl $((4096/4)*5),%ecx  # moving these many words to the 6 pages with 4 second level pages + 1 3rd level + 1 4th level pages 
  100029:	b9 00 14 00 00       	mov    $0x1400,%ecx
    rep stosl
  10002e:	f3 ab                	rep stos %eax,%es:(%rdi)
    # creating a 4G boot page table
    # setting the 4th level page table only the second entry needed (PML4)
    movl $pml4,%eax
  100030:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl $pdpt1, %ebx
  100035:	bb 00 30 10 00       	mov    $0x103000,%ebx
    orl $PTE_P,%ebx
  10003a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10003d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%eax)
  100040:	89 18                	mov    %ebx,(%rax)

    movl $pdpt2, %ebx
  100042:	bb 00 40 10 00       	mov    $0x104000,%ebx
    orl $PTE_P,%ebx
  100047:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10004a:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,0x8(%eax)
  10004d:	89 58 08             	mov    %ebx,0x8(%rax)

    # setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xa0000--0xd000
    movl $pdpt1,%edi
  100050:	bf 00 30 10 00       	mov    $0x103000,%edi
    movl $pde1,%ebx
  100055:	bb 00 50 10 00       	mov    $0x105000,%ebx
    orl $PTE_P,%ebx
  10005a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10005d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100060:	89 1f                	mov    %ebx,(%rdi)

    movl $pdpt2,%edi
  100062:	bf 00 40 10 00       	mov    $0x104000,%edi
    movl $pde2,%ebx
  100067:	bb 00 60 10 00       	mov    $0x106000,%ebx
    orl $PTE_P,%ebx
  10006c:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10006f:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100072:	89 1f                	mov    %ebx,(%rdi)
    
    # setting the pgdir so that the LA=PA
    # mapping first 1G of mem at KERNBASE
    movl $128,%ecx
  100074:	b9 80 00 00 00       	mov    $0x80,%ecx
    # Start at the end and work backwards
    #leal (pml4 + 5*0x1000 - 0x8),%edi
    movl $pde1,%edi
  100079:	bf 00 50 10 00       	mov    $0x105000,%edi
    movl $pde2,%ebx
  10007e:	bb 00 60 10 00       	mov    $0x106000,%ebx
    #64th entry - 0x8004000000
    addl $256,%ebx 
  100083:	81 c3 00 01 00 00    	add    $0x100,%ebx
    # PTE_P|PTE_W|PTE_MBZ
    movl $0x00000183,%eax
  100089:	b8 83 01 00 00       	mov    $0x183,%eax
  1:
     movl %eax,(%edi)
  10008e:	89 07                	mov    %eax,(%rdi)
     movl %eax,(%ebx)
  100090:	89 03                	mov    %eax,(%rbx)
     addl $0x8,%edi
  100092:	83 c7 08             	add    $0x8,%edi
     addl $0x8,%ebx
  100095:	83 c3 08             	add    $0x8,%ebx
     addl $0x00200000,%eax
  100098:	05 00 00 20 00       	add    $0x200000,%eax
     subl $1,%ecx
  10009d:	83 e9 01             	sub    $0x1,%ecx
     cmp $0x0,%ecx
  1000a0:	83 f9 00             	cmp    $0x0,%ecx
     jne 1b
  1000a3:	75 e9                	jne    10008e <_head64+0x8e>
 /*    subl $1,%ecx */
 /*    cmp $0x0,%ecx */
 /*    jne 1b */

    # set the cr3 register
    movl $pml4,%eax
  1000a5:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl %eax, %cr3
  1000aa:	0f 22 d8             	mov    %rax,%cr3

	
    # enable the long mode in MSR
    movl $EFER_MSR,%ecx
  1000ad:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    rdmsr
  1000b2:	0f 32                	rdmsr  
    btsl $EFER_LME,%eax
  1000b4:	0f ba e8 08          	bts    $0x8,%eax
    wrmsr
  1000b8:	0f 30                	wrmsr  
    
    # enable paging 
    movl %cr0,%eax
  1000ba:	0f 20 c0             	mov    %cr0,%rax
    orl $CR0_PE,%eax
  1000bd:	83 c8 01             	or     $0x1,%eax
    orl $CR0_PG,%eax
  1000c0:	0d 00 00 00 80       	or     $0x80000000,%eax
    orl $CR0_AM,%eax
  1000c5:	0d 00 00 04 00       	or     $0x40000,%eax
    orl $CR0_WP,%eax
  1000ca:	0d 00 00 01 00       	or     $0x10000,%eax
    orl $CR0_MP,%eax
  1000cf:	83 c8 02             	or     $0x2,%eax
    movl %eax,%cr0
  1000d2:	0f 22 c0             	mov    %rax,%cr0
    #jump to long mode with CS=0 and

    movl $gdtdesc_64,%eax
  1000d5:	b8 18 10 10 00       	mov    $0x101018,%eax
    lgdt (%eax)
  1000da:	0f 01 10             	lgdt   (%rax)
    pushl $0x8
  1000dd:	6a 08                	pushq  $0x8
    movl $_start,%eax
  1000df:	b8 0c 00 20 00       	mov    $0x20000c,%eax
    pushl %eax
  1000e4:	50                   	push   %rax

00000000001000e5 <jumpto_longmode>:
    
    .globl jumpto_longmode
    .type jumpto_longmode,@function
jumpto_longmode:
    lret
  1000e5:	cb                   	lret   

00000000001000e6 <verify_cpu>:
/*     movabs $_back_from_head64, %rax */
/*     pushq %rax */
/*     lretq */

verify_cpu:
    pushfl                   # get eflags in eax -- standardard way to check for cpuid
  1000e6:	9c                   	pushfq 
    popl %eax
  1000e7:	58                   	pop    %rax
    movl %eax,%ecx
  1000e8:	89 c1                	mov    %eax,%ecx
    xorl $0x200000, %eax
  1000ea:	35 00 00 20 00       	xor    $0x200000,%eax
    pushl %eax
  1000ef:	50                   	push   %rax
    popfl
  1000f0:	9d                   	popfq  
    pushfl
  1000f1:	9c                   	pushfq 
    popl %eax
  1000f2:	58                   	pop    %rax
    cmpl %eax,%ebx
  1000f3:	39 c3                	cmp    %eax,%ebx
    jz verify_cpu_no_longmode   # no cpuid -- no long mode
  1000f5:	74 1c                	je     100113 <verify_cpu_no_longmode>

    movl $0x0,%eax              # see if cpuid 1 is implemented
  1000f7:	b8 00 00 00 00       	mov    $0x0,%eax
    cpuid
  1000fc:	0f a2                	cpuid  
    cmpl $0x1,%eax
  1000fe:	83 f8 01             	cmp    $0x1,%eax
    jb verify_cpu_no_longmode    # cpuid 1 is not implemented
  100101:	72 10                	jb     100113 <verify_cpu_no_longmode>


    mov $0x80000001, %eax
  100103:	b8 01 00 00 80       	mov    $0x80000001,%eax
    cpuid                 
  100108:	0f a2                	cpuid  
    test $(1 << 29),%edx                 #Test if the LM-bit, is set or not.
  10010a:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    jz verify_cpu_no_longmode
  100110:	74 01                	je     100113 <verify_cpu_no_longmode>

    ret
  100112:	c3                   	retq   

0000000000100113 <verify_cpu_no_longmode>:

verify_cpu_no_longmode:
    jmp verify_cpu_no_longmode
  100113:	eb fe                	jmp    100113 <verify_cpu_no_longmode>
  100115:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10011c:	00 00 00 
  10011f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100126:	00 00 00 
  100129:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100130:	00 00 00 
  100133:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10013a:	00 00 00 
  10013d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100144:	00 00 00 
  100147:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10014e:	00 00 00 
  100151:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100158:	00 00 00 
  10015b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100162:	00 00 00 
  100165:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10016c:	00 00 00 
  10016f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100176:	00 00 00 
  100179:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100180:	00 00 00 
  100183:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10018a:	00 00 00 
  10018d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100194:	00 00 00 
  100197:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10019e:	00 00 00 
  1001a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001a8:	00 00 00 
  1001ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001b2:	00 00 00 
  1001b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001bc:	00 00 00 
  1001bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001c6:	00 00 00 
  1001c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001d0:	00 00 00 
  1001d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001da:	00 00 00 
  1001dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001e4:	00 00 00 
  1001e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001ee:	00 00 00 
  1001f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001f8:	00 00 00 
  1001fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100202:	00 00 00 
  100205:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10020c:	00 00 00 
  10020f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100216:	00 00 00 
  100219:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100220:	00 00 00 
  100223:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10022a:	00 00 00 
  10022d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100234:	00 00 00 
  100237:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10023e:	00 00 00 
  100241:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100248:	00 00 00 
  10024b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100252:	00 00 00 
  100255:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10025c:	00 00 00 
  10025f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100266:	00 00 00 
  100269:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100270:	00 00 00 
  100273:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10027a:	00 00 00 
  10027d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100284:	00 00 00 
  100287:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10028e:	00 00 00 
  100291:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100298:	00 00 00 
  10029b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002a2:	00 00 00 
  1002a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ac:	00 00 00 
  1002af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002b6:	00 00 00 
  1002b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002c0:	00 00 00 
  1002c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ca:	00 00 00 
  1002cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002d4:	00 00 00 
  1002d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002de:	00 00 00 
  1002e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002e8:	00 00 00 
  1002eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002f2:	00 00 00 
  1002f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002fc:	00 00 00 
  1002ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100306:	00 00 00 
  100309:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100310:	00 00 00 
  100313:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10031a:	00 00 00 
  10031d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100324:	00 00 00 
  100327:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10032e:	00 00 00 
  100331:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100338:	00 00 00 
  10033b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100342:	00 00 00 
  100345:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10034c:	00 00 00 
  10034f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100356:	00 00 00 
  100359:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100360:	00 00 00 
  100363:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10036a:	00 00 00 
  10036d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100374:	00 00 00 
  100377:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10037e:	00 00 00 
  100381:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100388:	00 00 00 
  10038b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100392:	00 00 00 
  100395:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10039c:	00 00 00 
  10039f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003a6:	00 00 00 
  1003a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003b0:	00 00 00 
  1003b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ba:	00 00 00 
  1003bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003c4:	00 00 00 
  1003c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ce:	00 00 00 
  1003d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003d8:	00 00 00 
  1003db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003e2:	00 00 00 
  1003e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ec:	00 00 00 
  1003ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003f6:	00 00 00 
  1003f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100400:	00 00 00 
  100403:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10040a:	00 00 00 
  10040d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100414:	00 00 00 
  100417:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10041e:	00 00 00 
  100421:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100428:	00 00 00 
  10042b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100432:	00 00 00 
  100435:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10043c:	00 00 00 
  10043f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100446:	00 00 00 
  100449:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100450:	00 00 00 
  100453:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10045a:	00 00 00 
  10045d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100464:	00 00 00 
  100467:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10046e:	00 00 00 
  100471:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100478:	00 00 00 
  10047b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100482:	00 00 00 
  100485:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10048c:	00 00 00 
  10048f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100496:	00 00 00 
  100499:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004a0:	00 00 00 
  1004a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004aa:	00 00 00 
  1004ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004b4:	00 00 00 
  1004b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004be:	00 00 00 
  1004c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004c8:	00 00 00 
  1004cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004d2:	00 00 00 
  1004d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004dc:	00 00 00 
  1004df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004e6:	00 00 00 
  1004e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004f0:	00 00 00 
  1004f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004fa:	00 00 00 
  1004fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100504:	00 00 00 
  100507:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10050e:	00 00 00 
  100511:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100518:	00 00 00 
  10051b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100522:	00 00 00 
  100525:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10052c:	00 00 00 
  10052f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100536:	00 00 00 
  100539:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100540:	00 00 00 
  100543:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10054a:	00 00 00 
  10054d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100554:	00 00 00 
  100557:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10055e:	00 00 00 
  100561:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100568:	00 00 00 
  10056b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100572:	00 00 00 
  100575:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10057c:	00 00 00 
  10057f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100586:	00 00 00 
  100589:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100590:	00 00 00 
  100593:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10059a:	00 00 00 
  10059d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005a4:	00 00 00 
  1005a7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ae:	00 00 00 
  1005b1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005b8:	00 00 00 
  1005bb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005c2:	00 00 00 
  1005c5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005cc:	00 00 00 
  1005cf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005d6:	00 00 00 
  1005d9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005e0:	00 00 00 
  1005e3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ea:	00 00 00 
  1005ed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005f4:	00 00 00 
  1005f7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005fe:	00 00 00 
  100601:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100608:	00 00 00 
  10060b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100612:	00 00 00 
  100615:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10061c:	00 00 00 
  10061f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100626:	00 00 00 
  100629:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100630:	00 00 00 
  100633:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10063a:	00 00 00 
  10063d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100644:	00 00 00 
  100647:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10064e:	00 00 00 
  100651:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100658:	00 00 00 
  10065b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100662:	00 00 00 
  100665:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10066c:	00 00 00 
  10066f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100676:	00 00 00 
  100679:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100680:	00 00 00 
  100683:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10068a:	00 00 00 
  10068d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100694:	00 00 00 
  100697:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10069e:	00 00 00 
  1006a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006a8:	00 00 00 
  1006ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006b2:	00 00 00 
  1006b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006bc:	00 00 00 
  1006bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006c6:	00 00 00 
  1006c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006d0:	00 00 00 
  1006d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006da:	00 00 00 
  1006dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006e4:	00 00 00 
  1006e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006ee:	00 00 00 
  1006f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006f8:	00 00 00 
  1006fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100702:	00 00 00 
  100705:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10070c:	00 00 00 
  10070f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100716:	00 00 00 
  100719:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100720:	00 00 00 
  100723:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10072a:	00 00 00 
  10072d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100734:	00 00 00 
  100737:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10073e:	00 00 00 
  100741:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100748:	00 00 00 
  10074b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100752:	00 00 00 
  100755:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10075c:	00 00 00 
  10075f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100766:	00 00 00 
  100769:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100770:	00 00 00 
  100773:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10077a:	00 00 00 
  10077d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100784:	00 00 00 
  100787:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10078e:	00 00 00 
  100791:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100798:	00 00 00 
  10079b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007a2:	00 00 00 
  1007a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ac:	00 00 00 
  1007af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007b6:	00 00 00 
  1007b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007c0:	00 00 00 
  1007c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ca:	00 00 00 
  1007cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007d4:	00 00 00 
  1007d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007de:	00 00 00 
  1007e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007e8:	00 00 00 
  1007eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007f2:	00 00 00 
  1007f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007fc:	00 00 00 
  1007ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100806:	00 00 00 
  100809:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100810:	00 00 00 
  100813:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10081a:	00 00 00 
  10081d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100824:	00 00 00 
  100827:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10082e:	00 00 00 
  100831:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100838:	00 00 00 
  10083b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100842:	00 00 00 
  100845:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10084c:	00 00 00 
  10084f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100856:	00 00 00 
  100859:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100860:	00 00 00 
  100863:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10086a:	00 00 00 
  10086d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100874:	00 00 00 
  100877:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10087e:	00 00 00 
  100881:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100888:	00 00 00 
  10088b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100892:	00 00 00 
  100895:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10089c:	00 00 00 
  10089f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008a6:	00 00 00 
  1008a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008b0:	00 00 00 
  1008b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ba:	00 00 00 
  1008bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008c4:	00 00 00 
  1008c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ce:	00 00 00 
  1008d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008d8:	00 00 00 
  1008db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008e2:	00 00 00 
  1008e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ec:	00 00 00 
  1008ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008f6:	00 00 00 
  1008f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100900:	00 00 00 
  100903:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10090a:	00 00 00 
  10090d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100914:	00 00 00 
  100917:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10091e:	00 00 00 
  100921:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100928:	00 00 00 
  10092b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100932:	00 00 00 
  100935:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10093c:	00 00 00 
  10093f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100946:	00 00 00 
  100949:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100950:	00 00 00 
  100953:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10095a:	00 00 00 
  10095d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100964:	00 00 00 
  100967:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10096e:	00 00 00 
  100971:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100978:	00 00 00 
  10097b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100982:	00 00 00 
  100985:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10098c:	00 00 00 
  10098f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100996:	00 00 00 
  100999:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009a0:	00 00 00 
  1009a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009aa:	00 00 00 
  1009ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009b4:	00 00 00 
  1009b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009be:	00 00 00 
  1009c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009c8:	00 00 00 
  1009cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009d2:	00 00 00 
  1009d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009dc:	00 00 00 
  1009df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009e6:	00 00 00 
  1009e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009f0:	00 00 00 
  1009f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009fa:	00 00 00 
  1009fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a04:	00 00 00 
  100a07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a0e:	00 00 00 
  100a11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a18:	00 00 00 
  100a1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a22:	00 00 00 
  100a25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a2c:	00 00 00 
  100a2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a36:	00 00 00 
  100a39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a40:	00 00 00 
  100a43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a4a:	00 00 00 
  100a4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a54:	00 00 00 
  100a57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a5e:	00 00 00 
  100a61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a68:	00 00 00 
  100a6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a72:	00 00 00 
  100a75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a7c:	00 00 00 
  100a7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a86:	00 00 00 
  100a89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a90:	00 00 00 
  100a93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a9a:	00 00 00 
  100a9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aa4:	00 00 00 
  100aa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aae:	00 00 00 
  100ab1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ab8:	00 00 00 
  100abb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ac2:	00 00 00 
  100ac5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100acc:	00 00 00 
  100acf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ad6:	00 00 00 
  100ad9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ae0:	00 00 00 
  100ae3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aea:	00 00 00 
  100aed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100af4:	00 00 00 
  100af7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100afe:	00 00 00 
  100b01:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b08:	00 00 00 
  100b0b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b12:	00 00 00 
  100b15:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b1c:	00 00 00 
  100b1f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b26:	00 00 00 
  100b29:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b30:	00 00 00 
  100b33:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b3a:	00 00 00 
  100b3d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b44:	00 00 00 
  100b47:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b4e:	00 00 00 
  100b51:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b58:	00 00 00 
  100b5b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b62:	00 00 00 
  100b65:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b6c:	00 00 00 
  100b6f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b76:	00 00 00 
  100b79:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b80:	00 00 00 
  100b83:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b8a:	00 00 00 
  100b8d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b94:	00 00 00 
  100b97:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b9e:	00 00 00 
  100ba1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ba8:	00 00 00 
  100bab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bb2:	00 00 00 
  100bb5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bbc:	00 00 00 
  100bbf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bc6:	00 00 00 
  100bc9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bd0:	00 00 00 
  100bd3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bda:	00 00 00 
  100bdd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100be4:	00 00 00 
  100be7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bee:	00 00 00 
  100bf1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bf8:	00 00 00 
  100bfb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c02:	00 00 00 
  100c05:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c0c:	00 00 00 
  100c0f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c16:	00 00 00 
  100c19:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c20:	00 00 00 
  100c23:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c2a:	00 00 00 
  100c2d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c34:	00 00 00 
  100c37:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c3e:	00 00 00 
  100c41:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c48:	00 00 00 
  100c4b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c52:	00 00 00 
  100c55:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c5c:	00 00 00 
  100c5f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c66:	00 00 00 
  100c69:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c70:	00 00 00 
  100c73:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c7a:	00 00 00 
  100c7d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c84:	00 00 00 
  100c87:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c8e:	00 00 00 
  100c91:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c98:	00 00 00 
  100c9b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ca2:	00 00 00 
  100ca5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cac:	00 00 00 
  100caf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cb6:	00 00 00 
  100cb9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cc0:	00 00 00 
  100cc3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cca:	00 00 00 
  100ccd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cd4:	00 00 00 
  100cd7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cde:	00 00 00 
  100ce1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ce8:	00 00 00 
  100ceb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cf2:	00 00 00 
  100cf5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cfc:	00 00 00 
  100cff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d06:	00 00 00 
  100d09:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d10:	00 00 00 
  100d13:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d1a:	00 00 00 
  100d1d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d24:	00 00 00 
  100d27:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d2e:	00 00 00 
  100d31:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d38:	00 00 00 
  100d3b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d42:	00 00 00 
  100d45:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d4c:	00 00 00 
  100d4f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d56:	00 00 00 
  100d59:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d60:	00 00 00 
  100d63:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d6a:	00 00 00 
  100d6d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d74:	00 00 00 
  100d77:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d7e:	00 00 00 
  100d81:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d88:	00 00 00 
  100d8b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d92:	00 00 00 
  100d95:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d9c:	00 00 00 
  100d9f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100da6:	00 00 00 
  100da9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100db0:	00 00 00 
  100db3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dba:	00 00 00 
  100dbd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dc4:	00 00 00 
  100dc7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dce:	00 00 00 
  100dd1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dd8:	00 00 00 
  100ddb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100de2:	00 00 00 
  100de5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dec:	00 00 00 
  100def:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100df6:	00 00 00 
  100df9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e00:	00 00 00 
  100e03:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e0a:	00 00 00 
  100e0d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e14:	00 00 00 
  100e17:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e1e:	00 00 00 
  100e21:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e28:	00 00 00 
  100e2b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e32:	00 00 00 
  100e35:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e3c:	00 00 00 
  100e3f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e46:	00 00 00 
  100e49:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e50:	00 00 00 
  100e53:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e5a:	00 00 00 
  100e5d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e64:	00 00 00 
  100e67:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e6e:	00 00 00 
  100e71:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e78:	00 00 00 
  100e7b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e82:	00 00 00 
  100e85:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e8c:	00 00 00 
  100e8f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e96:	00 00 00 
  100e99:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ea0:	00 00 00 
  100ea3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eaa:	00 00 00 
  100ead:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eb4:	00 00 00 
  100eb7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ebe:	00 00 00 
  100ec1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ec8:	00 00 00 
  100ecb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ed2:	00 00 00 
  100ed5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100edc:	00 00 00 
  100edf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ee6:	00 00 00 
  100ee9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ef0:	00 00 00 
  100ef3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100efa:	00 00 00 
  100efd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f04:	00 00 00 
  100f07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f0e:	00 00 00 
  100f11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f18:	00 00 00 
  100f1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f22:	00 00 00 
  100f25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f2c:	00 00 00 
  100f2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f36:	00 00 00 
  100f39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f40:	00 00 00 
  100f43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f4a:	00 00 00 
  100f4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f54:	00 00 00 
  100f57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f5e:	00 00 00 
  100f61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f68:	00 00 00 
  100f6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f72:	00 00 00 
  100f75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f7c:	00 00 00 
  100f7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f86:	00 00 00 
  100f89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f90:	00 00 00 
  100f93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f9a:	00 00 00 
  100f9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fa4:	00 00 00 
  100fa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fae:	00 00 00 
  100fb1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fb8:	00 00 00 
  100fbb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fc2:	00 00 00 
  100fc5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fcc:	00 00 00 
  100fcf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fd6:	00 00 00 
  100fd9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fe0:	00 00 00 
  100fe3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fea:	00 00 00 
  100fed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ff4:	00 00 00 
  100ff7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  100ffe:	00 00 

0000000000101000 <gdt_64>:
	...
  101008:	ff                   	(bad)  
  101009:	ff 00                	incl   (%rax)
  10100b:	00 00                	add    %al,(%rax)
  10100d:	9a                   	(bad)  
  10100e:	af                   	scas   %es:(%rdi),%eax
  10100f:	00 ff                	add    %bh,%bh
  101011:	ff 00                	incl   (%rax)
  101013:	00 00                	add    %al,(%rax)
  101015:	92                   	xchg   %eax,%edx
  101016:	cf                   	iret   
	...

0000000000101018 <gdtdesc_64>:
  101018:	17                   	(bad)  
  101019:	00 00                	add    %al,(%rax)
  10101b:	10 10                	adc    %dl,(%rax)
	...

0000000000102000 <pml4phys>:
	...

0000000000103000 <pdpt1>:
	...

0000000000104000 <pdpt2>:
	...

0000000000105000 <pde1>:
	...

0000000000106000 <pde2>:
	...

0000000000107000 <multiboot_info>:
  107000:	00 00                	add    %al,(%rax)
	...

Disassembly of section .text:

0000008004200000 <_start+0x8003fffff4>:
  8004200000:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  8004200006:	00 00                	add    %al,(%rax)
  8004200008:	fe 4f 52             	decb   0x52(%rdi)
  800420000b:	e4                   	.byte 0xe4

000000800420000c <entry>:
entry:

/* .globl _back_from_head64 */
/* _back_from_head64: */

    movabs   $gdtdesc_64,%rax
  800420000c:	48 b8 38 60 23 04 80 	movabs $0x8004236038,%rax
  8004200013:	00 00 00 
    lgdt     (%rax)
  8004200016:	0f 01 10             	lgdt   (%rax)
    movw    $DATA_SEL,%ax
  8004200019:	66 b8 10 00          	mov    $0x10,%ax
    movw    %ax,%ds
  800420001d:	8e d8                	mov    %eax,%ds
    movw    %ax,%ss
  800420001f:	8e d0                	mov    %eax,%ss
    movw    %ax,%fs
  8004200021:	8e e0                	mov    %eax,%fs
    movw    %ax,%gs
  8004200023:	8e e8                	mov    %eax,%gs
    movw    %ax,%es
  8004200025:	8e c0                	mov    %eax,%es
    pushq   $CODE_SEL
  8004200027:	6a 08                	pushq  $0x8
    movabs  $relocated,%rax
  8004200029:	48 b8 36 00 20 04 80 	movabs $0x8004200036,%rax
  8004200030:	00 00 00 
    pushq   %rax
  8004200033:	50                   	push   %rax
    lretq
  8004200034:	48 cb                	lretq  

0000008004200036 <relocated>:
relocated:

	# Clear the frame pointer register (RBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movq	$0x0,%rbp			# nuke frame pointer
  8004200036:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Set the stack pointer
	movabs	$(bootstacktop),%rax
  800420003d:	48 b8 00 60 23 04 80 	movabs $0x8004236000,%rax
  8004200044:	00 00 00 
	movq  %rax,%rsp
  8004200047:	48 89 c4             	mov    %rax,%rsp

	# now to C code
    movabs $i386_init, %rax
  800420004a:	48 b8 9a 00 20 04 80 	movabs $0x800420009a,%rax
  8004200051:	00 00 00 
	call *%rax
  8004200054:	ff d0                	callq  *%rax

0000008004200056 <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
  8004200056:	eb fe                	jmp    8004200056 <spin>

0000008004200058 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004200058:	55                   	push   %rbp
  8004200059:	48 89 e5             	mov    %rsp,%rbp
  800420005c:	48 83 ec 20          	sub    $0x20,%rsp
  8004200060:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004200064:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004200067:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420006b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420006e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004200072:	f0 87 02             	lock xchg %eax,(%rdx)
  8004200075:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004200078:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420007b:	c9                   	leaveq 
  800420007c:	c3                   	retq   

000000800420007d <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  800420007d:	55                   	push   %rbp
  800420007e:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004200081:	48 bf 60 67 23 04 80 	movabs $0x8004236760,%rdi
  8004200088:	00 00 00 
  800420008b:	48 b8 8e 84 21 04 80 	movabs $0x800421848e,%rax
  8004200092:	00 00 00 
  8004200095:	ff d0                	callq  *%rax
}
  8004200097:	90                   	nop
  8004200098:	5d                   	pop    %rbp
  8004200099:	c3                   	retq   

000000800420009a <i386_init>:



void
i386_init(void)
{
  800420009a:	55                   	push   %rbp
  800420009b:	48 89 e5             	mov    %rsp,%rbp
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);
  800420009e:	48 ba 10 20 72 04 80 	movabs $0x8004722010,%rdx
  80042000a5:	00 00 00 
  80042000a8:	48 b8 00 fd 4d 04 80 	movabs $0x80044dfd00,%rax
  80042000af:	00 00 00 
  80042000b2:	48 29 c2             	sub    %rax,%rdx
  80042000b5:	48 89 d0             	mov    %rdx,%rax
  80042000b8:	48 89 c2             	mov    %rax,%rdx
  80042000bb:	be 00 00 00 00       	mov    $0x0,%esi
  80042000c0:	48 bf 00 fd 4d 04 80 	movabs $0x80044dfd00,%rdi
  80042000c7:	00 00 00 
  80042000ca:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  80042000d1:	00 00 00 
  80042000d4:	ff d0                	callq  *%rax

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();
  80042000d6:	48 b8 b5 11 20 04 80 	movabs $0x80042011b5,%rax
  80042000dd:	00 00 00 
  80042000e0:	ff d0                	callq  *%rax


	cprintf("6828 decimal is %o octal!\n", 6828);
  80042000e2:	be ac 1a 00 00       	mov    $0x1aac,%esi
  80042000e7:	48 bf e0 ef 21 04 80 	movabs $0x800421efe0,%rdi
  80042000ee:	00 00 00 
  80042000f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042000f6:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  80042000fd:	00 00 00 
  8004200100:	ff d2                	callq  *%rdx
    */
#endif

#ifndef VMM_GUEST
	extern char end[];
	end_debug = read_section_headers((0x10000+KERNBASE), (uintptr_t)end);
  8004200102:	48 b8 10 20 72 04 80 	movabs $0x8004722010,%rax
  8004200109:	00 00 00 
  800420010c:	48 89 c6             	mov    %rax,%rsi
  800420010f:	48 bf 00 00 01 04 80 	movabs $0x8004010000,%rdi
  8004200116:	00 00 00 
  8004200119:	48 b8 14 6b 21 04 80 	movabs $0x8004216b14,%rax
  8004200120:	00 00 00 
  8004200123:	ff d0                	callq  *%rax
  8004200125:	48 89 c2             	mov    %rax,%rdx
  8004200128:	48 b8 d0 f5 6d 04 80 	movabs $0x80046df5d0,%rax
  800420012f:	00 00 00 
  8004200132:	48 89 10             	mov    %rdx,(%rax)
#endif

	// Lab 2 memory management initialization functions
	x64_vm_init();
  8004200135:	b8 00 00 00 00       	mov    $0x0,%eax
  800420013a:	48 ba 45 26 20 04 80 	movabs $0x8004202645,%rdx
  8004200141:	00 00 00 
  8004200144:	ff d2                	callq  *%rdx


	// Lab 3 user environment initialization functions
	env_init();
  8004200146:	48 b8 94 7f 20 04 80 	movabs $0x8004207f94,%rax
  800420014d:	00 00 00 
  8004200150:	ff d0                	callq  *%rax
	trap_init();
  8004200152:	48 b8 64 9e 20 04 80 	movabs $0x8004209e64,%rax
  8004200159:	00 00 00 
  800420015c:	ff d0                	callq  *%rax

#ifndef VMM_GUEST
	// Lab 4 multiprocessor initialization functions
	mp_init();
  800420015e:	48 b8 a7 7a 21 04 80 	movabs $0x8004217aa7,%rax
  8004200165:	00 00 00 
  8004200168:	ff d0                	callq  *%rax
	lapic_init();
  800420016a:	48 b8 01 7f 21 04 80 	movabs $0x8004217f01,%rax
  8004200171:	00 00 00 
  8004200174:	ff d0                	callq  *%rax
#endif

	// Lab 4 multitasking initialization functions
	pic_init();
  8004200176:	48 b8 e6 99 20 04 80 	movabs $0x80042099e6,%rax
  800420017d:	00 00 00 
  8004200180:	ff d0                	callq  *%rax

#ifndef VMM_GUEST  // Does not work in guest mode
	// Lab 6 hardware initialization functions
	time_init();
  8004200182:	48 b8 53 99 21 04 80 	movabs $0x8004219953,%rax
  8004200189:	00 00 00 
  800420018c:	ff d0                	callq  *%rax
	pci_init();
  800420018e:	48 b8 17 99 21 04 80 	movabs $0x8004219917,%rax
  8004200195:	00 00 00 
  8004200198:	ff d0                	callq  *%rax
#endif 

	// Acquire the big kernel lock before waking up APs
	// Your code here:

	lock_kernel();
  800420019a:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  80042001a1:	00 00 00 
  80042001a4:	ff d0                	callq  *%rax


#ifndef VMM_GUEST
	// Starting non-boot CPUs
	boot_aps();
  80042001a6:	48 b8 00 02 20 04 80 	movabs $0x8004200200,%rax
  80042001ad:	00 00 00 
  80042001b0:	ff d0                	callq  *%rax
#endif

	// Start fs.
	ENV_CREATE(fs_fs, ENV_TYPE_FS);
  80042001b2:	be 01 00 00 00       	mov    $0x1,%esi
  80042001b7:	48 bf 58 05 2c 04 80 	movabs $0x80042c0558,%rdi
  80042001be:	00 00 00 
  80042001c1:	48 b8 1b 90 20 04 80 	movabs $0x800420901b,%rax
  80042001c8:	00 00 00 
  80042001cb:	ff d0                	callq  *%rax
#if defined(TEST_EPT_MAP)
	test_ept_map();
#endif
#endif

	ENV_CREATE(user_icode, ENV_TYPE_USER);
  80042001cd:	be 00 00 00 00       	mov    $0x0,%esi
  80042001d2:	48 bf 80 82 2a 04 80 	movabs $0x80042a8280,%rdi
  80042001d9:	00 00 00 
  80042001dc:	48 b8 1b 90 20 04 80 	movabs $0x800420901b,%rax
  80042001e3:	00 00 00 
  80042001e6:	ff d0                	callq  *%rax

#endif // TEST*


	// Should not be necessary - drains keyboard because interrupt has given up.
	kbd_intr();
  80042001e8:	48 b8 e3 0f 20 04 80 	movabs $0x8004200fe3,%rax
  80042001ef:	00 00 00 
  80042001f2:	ff d0                	callq  *%rax



	// Schedule and run the first user environment!
	sched_yield();
  80042001f4:	48 b8 a6 da 20 04 80 	movabs $0x800420daa6,%rax
  80042001fb:	00 00 00 
  80042001fe:	ff d0                	callq  *%rax

0000008004200200 <boot_aps>:
void *mpentry_kstack;

// Start the non-boot (AP) processors.
static void
boot_aps(void)
{
  8004200200:	55                   	push   %rbp
  8004200201:	48 89 e5             	mov    %rsp,%rbp
  8004200204:	48 83 ec 30          	sub    $0x30,%rsp
	extern unsigned char mpentry_start[], mpentry_end[];
	void *code;
	struct CpuInfo *c;

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
  8004200208:	48 c7 45 f0 00 70 00 	movq   $0x7000,-0x10(%rbp)
  800420020f:	00 
  8004200210:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200214:	48 c1 e8 0c          	shr    $0xc,%rax
  8004200218:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420021b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420021e:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004200225:	00 00 00 
  8004200228:	48 8b 00             	mov    (%rax),%rax
  800420022b:	48 39 c2             	cmp    %rax,%rdx
  800420022e:	72 32                	jb     8004200262 <boot_aps+0x62>
  8004200230:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200234:	48 89 c1             	mov    %rax,%rcx
  8004200237:	48 ba 00 f0 21 04 80 	movabs $0x800421f000,%rdx
  800420023e:	00 00 00 
  8004200241:	be ac 00 00 00       	mov    $0xac,%esi
  8004200246:	48 bf 23 f0 21 04 80 	movabs $0x800421f023,%rdi
  800420024d:	00 00 00 
  8004200250:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200255:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420025c:	00 00 00 
  800420025f:	41 ff d0             	callq  *%r8
  8004200262:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004200269:	00 00 00 
  800420026c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200270:	48 01 d0             	add    %rdx,%rax
  8004200273:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
  8004200277:	48 ba ce 75 21 04 80 	movabs $0x80042175ce,%rdx
  800420027e:	00 00 00 
  8004200281:	48 b8 e8 74 21 04 80 	movabs $0x80042174e8,%rax
  8004200288:	00 00 00 
  800420028b:	48 29 c2             	sub    %rax,%rdx
  800420028e:	48 89 d0             	mov    %rdx,%rax
  8004200291:	48 89 c2             	mov    %rax,%rdx
  8004200294:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004200298:	48 be e8 74 21 04 80 	movabs $0x80042174e8,%rsi
  800420029f:	00 00 00 
  80042002a2:	48 89 c7             	mov    %rax,%rdi
  80042002a5:	48 b8 44 12 21 04 80 	movabs $0x8004211244,%rax
  80042002ac:	00 00 00 
  80042002af:	ff d0                	callq  *%rax
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  80042002b1:	48 b8 20 10 6e 04 80 	movabs $0x80046e1020,%rax
  80042002b8:	00 00 00 
  80042002bb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042002bf:	e9 13 01 00 00       	jmpq   80042003d7 <boot_aps+0x1d7>
		if (c == cpus + cpunum())  // We've started already.
  80042002c4:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  80042002cb:	00 00 00 
  80042002ce:	ff d0                	callq  *%rax
  80042002d0:	48 98                	cltq   
  80042002d2:	48 c1 e0 03          	shl    $0x3,%rax
  80042002d6:	48 89 c2             	mov    %rax,%rdx
  80042002d9:	48 c1 e2 04          	shl    $0x4,%rdx
  80042002dd:	48 01 c2             	add    %rax,%rdx
  80042002e0:	48 b8 20 10 6e 04 80 	movabs $0x80046e1020,%rax
  80042002e7:	00 00 00 
  80042002ea:	48 01 d0             	add    %rdx,%rax
  80042002ed:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042002f1:	0f 84 d7 00 00 00    	je     80042003ce <boot_aps+0x1ce>
			continue;

		// Tell mpentry.S what stack to use 
		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
  80042002f7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042002fb:	48 b8 20 10 6e 04 80 	movabs $0x80046e1020,%rax
  8004200302:	00 00 00 
  8004200305:	48 29 c2             	sub    %rax,%rdx
  8004200308:	48 89 d0             	mov    %rdx,%rax
  800420030b:	48 c1 f8 03          	sar    $0x3,%rax
  800420030f:	48 89 c2             	mov    %rax,%rdx
  8004200312:	48 b8 f1 f0 f0 f0 f0 	movabs $0xf0f0f0f0f0f0f0f1,%rax
  8004200319:	f0 f0 f0 
  800420031c:	48 0f af c2          	imul   %rdx,%rax
  8004200320:	48 c1 e0 10          	shl    $0x10,%rax
  8004200324:	48 89 c2             	mov    %rax,%rdx
  8004200327:	48 b8 00 20 6e 04 80 	movabs $0x80046e2000,%rax
  800420032e:	00 00 00 
  8004200331:	48 01 d0             	add    %rdx,%rax
  8004200334:	48 8d 90 00 00 01 00 	lea    0x10000(%rax),%rdx
  800420033b:	48 b8 e0 f5 6d 04 80 	movabs $0x80046df5e0,%rax
  8004200342:	00 00 00 
  8004200345:	48 89 10             	mov    %rdx,(%rax)
		// Start the CPU at mpentry_start
		lapic_startap(c->cpu_id, PADDR(code));
  8004200348:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420034c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004200350:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004200357:	00 00 00 
  800420035a:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  800420035e:	77 32                	ja     8004200392 <boot_aps+0x192>
  8004200360:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004200364:	48 89 c1             	mov    %rax,%rcx
  8004200367:	48 ba 30 f0 21 04 80 	movabs $0x800421f030,%rdx
  800420036e:	00 00 00 
  8004200371:	be b6 00 00 00       	mov    $0xb6,%esi
  8004200376:	48 bf 23 f0 21 04 80 	movabs $0x800421f023,%rdi
  800420037d:	00 00 00 
  8004200380:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200385:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420038c:	00 00 00 
  800420038f:	41 ff d0             	callq  *%r8
  8004200392:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004200399:	ff ff ff 
  800420039c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042003a0:	48 01 d0             	add    %rdx,%rax
  80042003a3:	89 c2                	mov    %eax,%edx
  80042003a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042003a9:	0f b6 00             	movzbl (%rax),%eax
  80042003ac:	0f b6 c0             	movzbl %al,%eax
  80042003af:	89 d6                	mov    %edx,%esi
  80042003b1:	89 c7                	mov    %eax,%edi
  80042003b3:	48 b8 6f 81 21 04 80 	movabs $0x800421816f,%rax
  80042003ba:	00 00 00 
  80042003bd:	ff d0                	callq  *%rax
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
  80042003bf:	90                   	nop
  80042003c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042003c4:	8b 40 04             	mov    0x4(%rax),%eax
  80042003c7:	83 f8 01             	cmp    $0x1,%eax
  80042003ca:	75 f4                	jne    80042003c0 <boot_aps+0x1c0>
  80042003cc:	eb 01                	jmp    80042003cf <boot_aps+0x1cf>
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
		if (c == cpus + cpunum())  // We've started already.
			continue;
  80042003ce:	90                   	nop

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  80042003cf:	48 81 45 f8 88 00 00 	addq   $0x88,-0x8(%rbp)
  80042003d6:	00 
  80042003d7:	48 b8 48 12 6e 04 80 	movabs $0x80046e1248,%rax
  80042003de:	00 00 00 
  80042003e1:	8b 00                	mov    (%rax),%eax
  80042003e3:	48 98                	cltq   
  80042003e5:	48 c1 e0 03          	shl    $0x3,%rax
  80042003e9:	48 89 c2             	mov    %rax,%rdx
  80042003ec:	48 c1 e2 04          	shl    $0x4,%rdx
  80042003f0:	48 01 c2             	add    %rax,%rdx
  80042003f3:	48 b8 20 10 6e 04 80 	movabs $0x80046e1020,%rax
  80042003fa:	00 00 00 
  80042003fd:	48 01 d0             	add    %rdx,%rax
  8004200400:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004200404:	0f 87 ba fe ff ff    	ja     80042002c4 <boot_aps+0xc4>
		lapic_startap(c->cpu_id, PADDR(code));
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
			;
	}
}
  800420040a:	90                   	nop
  800420040b:	c9                   	leaveq 
  800420040c:	c3                   	retq   

000000800420040d <mp_main>:

// Setup code for APs
void
mp_main(void)
{
  800420040d:	55                   	push   %rbp
  800420040e:	48 89 e5             	mov    %rsp,%rbp
  8004200411:	48 83 ec 10          	sub    $0x10,%rsp
	// We are in high EIP now, safe to switch to kern_pgdir 
	lcr3(boot_cr3);
  8004200415:	48 b8 e8 f5 6d 04 80 	movabs $0x80046df5e8,%rax
  800420041c:	00 00 00 
  800420041f:	48 8b 00             	mov    (%rax),%rax
  8004200422:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004200426:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420042a:	0f 22 d8             	mov    %rax,%cr3
	cprintf("SMP: CPU %d starting\n", cpunum());
  800420042d:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  8004200434:	00 00 00 
  8004200437:	ff d0                	callq  *%rax
  8004200439:	89 c6                	mov    %eax,%esi
  800420043b:	48 bf 54 f0 21 04 80 	movabs $0x800421f054,%rdi
  8004200442:	00 00 00 
  8004200445:	b8 00 00 00 00       	mov    $0x0,%eax
  800420044a:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004200451:	00 00 00 
  8004200454:	ff d2                	callq  *%rdx

	lapic_init();
  8004200456:	48 b8 01 7f 21 04 80 	movabs $0x8004217f01,%rax
  800420045d:	00 00 00 
  8004200460:	ff d0                	callq  *%rax
	env_init_percpu();
  8004200462:	48 b8 62 80 20 04 80 	movabs $0x8004208062,%rax
  8004200469:	00 00 00 
  800420046c:	ff d0                	callq  *%rax
	trap_init_percpu();
  800420046e:	48 b8 7a c5 20 04 80 	movabs $0x800420c57a,%rax
  8004200475:	00 00 00 
  8004200478:	ff d0                	callq  *%rax
	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
  800420047a:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  8004200481:	00 00 00 
  8004200484:	ff d0                	callq  *%rax
  8004200486:	48 98                	cltq   
  8004200488:	48 c1 e0 03          	shl    $0x3,%rax
  800420048c:	48 89 c2             	mov    %rax,%rdx
  800420048f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200493:	48 01 d0             	add    %rdx,%rax
  8004200496:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420049d:	00 00 00 
  80042004a0:	48 01 d0             	add    %rdx,%rax
  80042004a3:	48 83 c0 04          	add    $0x4,%rax
  80042004a7:	be 01 00 00 00       	mov    $0x1,%esi
  80042004ac:	48 89 c7             	mov    %rax,%rdi
  80042004af:	48 b8 58 00 20 04 80 	movabs $0x8004200058,%rax
  80042004b6:	00 00 00 
  80042004b9:	ff d0                	callq  *%rax
	// to start running processes on this CPU.  But make sure that
	// only one CPU can enter the scheduler at a time!
	//
	// Your code here:

	lock_kernel();
  80042004bb:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  80042004c2:	00 00 00 
  80042004c5:	ff d0                	callq  *%rax
	sched_yield();     // start running processes
  80042004c7:	48 b8 a6 da 20 04 80 	movabs $0x800420daa6,%rax
  80042004ce:	00 00 00 
  80042004d1:	ff d0                	callq  *%rax

00000080042004d3 <_panic>:
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  80042004d3:	55                   	push   %rbp
  80042004d4:	48 89 e5             	mov    %rsp,%rbp
  80042004d7:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  80042004de:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  80042004e5:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  80042004eb:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
  80042004f2:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  80042004f9:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004200500:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004200507:	84 c0                	test   %al,%al
  8004200509:	74 20                	je     800420052b <_panic+0x58>
  800420050b:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420050f:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004200513:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004200517:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420051b:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420051f:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004200523:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004200527:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;

	if (panicstr)
  800420052b:	48 b8 d8 f5 6d 04 80 	movabs $0x80046df5d8,%rax
  8004200532:	00 00 00 
  8004200535:	48 8b 00             	mov    (%rax),%rax
  8004200538:	48 85 c0             	test   %rax,%rax
  800420053b:	74 05                	je     8004200542 <_panic+0x6f>
		goto dead;
  800420053d:	e9 ba 00 00 00       	jmpq   80042005fc <_panic+0x129>
	panicstr = fmt;
  8004200542:	48 b8 d8 f5 6d 04 80 	movabs $0x80046df5d8,%rax
  8004200549:	00 00 00 
  800420054c:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  8004200553:	48 89 10             	mov    %rdx,(%rax)

	// Be extra sure that the machine is in as reasonable state
	__asm __volatile("cli; cld");
  8004200556:	fa                   	cli    
  8004200557:	fc                   	cld    

	va_start(ap, fmt);
  8004200558:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420055f:	00 00 00 
  8004200562:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  8004200569:	00 00 00 
  800420056c:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004200570:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004200577:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420057e:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)

	cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
  8004200585:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420058c:	00 00 00 
  800420058f:	ff d0                	callq  *%rax
  8004200591:	89 c6                	mov    %eax,%esi
  8004200593:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004200599:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042005a0:	89 d1                	mov    %edx,%ecx
  80042005a2:	48 89 c2             	mov    %rax,%rdx
  80042005a5:	48 bf 70 f0 21 04 80 	movabs $0x800421f070,%rdi
  80042005ac:	00 00 00 
  80042005af:	b8 00 00 00 00       	mov    $0x0,%eax
  80042005b4:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  80042005bb:	00 00 00 
  80042005be:	41 ff d0             	callq  *%r8

	vcprintf(fmt, ap);
  80042005c1:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  80042005c8:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042005cf:	48 89 d6             	mov    %rdx,%rsi
  80042005d2:	48 89 c7             	mov    %rax,%rdi
  80042005d5:	48 b8 8c 9c 20 04 80 	movabs $0x8004209c8c,%rax
  80042005dc:	00 00 00 
  80042005df:	ff d0                	callq  *%rax
	cprintf("\n");
  80042005e1:	48 bf 92 f0 21 04 80 	movabs $0x800421f092,%rdi
  80042005e8:	00 00 00 
  80042005eb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042005f0:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  80042005f7:	00 00 00 
  80042005fa:	ff d2                	callq  *%rdx
	va_end(ap);

dead:
	/* break into the kernel monitor */
	while (1)
		monitor(NULL);
  80042005fc:	bf 00 00 00 00       	mov    $0x0,%edi
  8004200601:	48 b8 73 1a 20 04 80 	movabs $0x8004201a73,%rax
  8004200608:	00 00 00 
  800420060b:	ff d0                	callq  *%rax
  800420060d:	eb ed                	jmp    80042005fc <_panic+0x129>

000000800420060f <_warn>:
}

/* like panic, but don't */
void
_warn(const char *file, int line, const char *fmt,...)
{
  800420060f:	55                   	push   %rbp
  8004200610:	48 89 e5             	mov    %rsp,%rbp
  8004200613:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420061a:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  8004200621:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  8004200627:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
  800420062e:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004200635:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420063c:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004200643:	84 c0                	test   %al,%al
  8004200645:	74 20                	je     8004200667 <_warn+0x58>
  8004200647:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420064b:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420064f:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004200653:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004200657:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420065b:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420065f:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004200663:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;

	va_start(ap, fmt);
  8004200667:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420066e:	00 00 00 
  8004200671:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  8004200678:	00 00 00 
  800420067b:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420067f:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004200686:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420068d:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel warning at %s:%d: ", file, line);
  8004200694:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  800420069a:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042006a1:	48 89 c6             	mov    %rax,%rsi
  80042006a4:	48 bf 94 f0 21 04 80 	movabs $0x800421f094,%rdi
  80042006ab:	00 00 00 
  80042006ae:	b8 00 00 00 00       	mov    $0x0,%eax
  80042006b3:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  80042006ba:	00 00 00 
  80042006bd:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  80042006bf:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  80042006c6:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042006cd:	48 89 d6             	mov    %rdx,%rsi
  80042006d0:	48 89 c7             	mov    %rax,%rdi
  80042006d3:	48 b8 8c 9c 20 04 80 	movabs $0x8004209c8c,%rax
  80042006da:	00 00 00 
  80042006dd:	ff d0                	callq  *%rax
	cprintf("\n");
  80042006df:	48 bf 92 f0 21 04 80 	movabs $0x800421f092,%rdi
  80042006e6:	00 00 00 
  80042006e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042006ee:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  80042006f5:	00 00 00 
  80042006f8:	ff d2                	callq  *%rdx
	va_end(ap);
}
  80042006fa:	90                   	nop
  80042006fb:	c9                   	leaveq 
  80042006fc:	c3                   	retq   

00000080042006fd <delay>:
static void cons_putc(int c);

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
  80042006fd:	55                   	push   %rbp
  80042006fe:	48 89 e5             	mov    %rsp,%rbp
  8004200701:	48 83 ec 20          	sub    $0x20,%rsp
  8004200705:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420070c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420070f:	89 c2                	mov    %eax,%edx
  8004200711:	ec                   	in     (%dx),%al
  8004200712:	88 45 ec             	mov    %al,-0x14(%rbp)
  8004200715:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%rbp)
  800420071c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420071f:	89 c2                	mov    %eax,%edx
  8004200721:	ec                   	in     (%dx),%al
  8004200722:	88 45 ed             	mov    %al,-0x13(%rbp)
  8004200725:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%rbp)
  800420072c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420072f:	89 c2                	mov    %eax,%edx
  8004200731:	ec                   	in     (%dx),%al
  8004200732:	88 45 ee             	mov    %al,-0x12(%rbp)
  8004200735:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%rbp)
  800420073c:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800420073f:	89 c2                	mov    %eax,%edx
  8004200741:	ec                   	in     (%dx),%al
  8004200742:	88 45 ef             	mov    %al,-0x11(%rbp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
  8004200745:	90                   	nop
  8004200746:	c9                   	leaveq 
  8004200747:	c3                   	retq   

0000008004200748 <serial_proc_data>:

static bool serial_exists;

static int
serial_proc_data(void)
{
  8004200748:	55                   	push   %rbp
  8004200749:	48 89 e5             	mov    %rsp,%rbp
  800420074c:	48 83 ec 10          	sub    $0x10,%rsp
  8004200750:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%rbp)
  8004200757:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420075a:	89 c2                	mov    %eax,%edx
  800420075c:	ec                   	in     (%dx),%al
  800420075d:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  8004200760:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
  8004200764:	0f b6 c0             	movzbl %al,%eax
  8004200767:	83 e0 01             	and    $0x1,%eax
  800420076a:	85 c0                	test   %eax,%eax
  800420076c:	75 07                	jne    8004200775 <serial_proc_data+0x2d>
		return -1;
  800420076e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200773:	eb 17                	jmp    800420078c <serial_proc_data+0x44>
  8004200775:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420077c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420077f:	89 c2                	mov    %eax,%edx
  8004200781:	ec                   	in     (%dx),%al
  8004200782:	88 45 f6             	mov    %al,-0xa(%rbp)
	return data;
  8004200785:	0f b6 45 f6          	movzbl -0xa(%rbp),%eax
	return inb(COM1+COM_RX);
  8004200789:	0f b6 c0             	movzbl %al,%eax
}
  800420078c:	c9                   	leaveq 
  800420078d:	c3                   	retq   

000000800420078e <serial_intr>:

void
serial_intr(void)
{
  800420078e:	55                   	push   %rbp
  800420078f:	48 89 e5             	mov    %rsp,%rbp
	if (serial_exists)
  8004200792:	48 b8 00 00 4e 04 80 	movabs $0x80044e0000,%rax
  8004200799:	00 00 00 
  800420079c:	0f b6 00             	movzbl (%rax),%eax
  800420079f:	84 c0                	test   %al,%al
  80042007a1:	74 16                	je     80042007b9 <serial_intr+0x2b>
		cons_intr(serial_proc_data);
  80042007a3:	48 bf 48 07 20 04 80 	movabs $0x8004200748,%rdi
  80042007aa:	00 00 00 
  80042007ad:	48 b8 36 10 20 04 80 	movabs $0x8004201036,%rax
  80042007b4:	00 00 00 
  80042007b7:	ff d0                	callq  *%rax
}
  80042007b9:	90                   	nop
  80042007ba:	5d                   	pop    %rbp
  80042007bb:	c3                   	retq   

00000080042007bc <serial_putc>:

static void
serial_putc(int c)
{
  80042007bc:	55                   	push   %rbp
  80042007bd:	48 89 e5             	mov    %rsp,%rbp
  80042007c0:	48 83 ec 18          	sub    $0x18,%rsp
  80042007c4:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int i;

	for (i = 0;
  80042007c7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042007ce:	eb 10                	jmp    80042007e0 <serial_putc+0x24>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
		delay();
  80042007d0:	48 b8 fd 06 20 04 80 	movabs $0x80042006fd,%rax
  80042007d7:	00 00 00 
  80042007da:	ff d0                	callq  *%rax
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
  80042007dc:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042007e0:	c7 45 f4 fd 03 00 00 	movl   $0x3fd,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042007e7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042007ea:	89 c2                	mov    %eax,%edx
  80042007ec:	ec                   	in     (%dx),%al
  80042007ed:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  80042007f0:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
serial_putc(int c)
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  80042007f4:	0f b6 c0             	movzbl %al,%eax
  80042007f7:	83 e0 20             	and    $0x20,%eax
static void
serial_putc(int c)
{
	int i;

	for (i = 0;
  80042007fa:	85 c0                	test   %eax,%eax
  80042007fc:	75 09                	jne    8004200807 <serial_putc+0x4b>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  80042007fe:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  8004200805:	7e c9                	jle    80042007d0 <serial_putc+0x14>
	     i++)
		delay();

	outb(COM1 + COM_TX, c);
  8004200807:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420080a:	0f b6 c0             	movzbl %al,%eax
  800420080d:	c7 45 f8 f8 03 00 00 	movl   $0x3f8,-0x8(%rbp)
  8004200814:	88 45 f2             	mov    %al,-0xe(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200817:	0f b6 45 f2          	movzbl -0xe(%rbp),%eax
  800420081b:	8b 55 f8             	mov    -0x8(%rbp),%edx
  800420081e:	ee                   	out    %al,(%dx)
}
  800420081f:	90                   	nop
  8004200820:	c9                   	leaveq 
  8004200821:	c3                   	retq   

0000008004200822 <serial_init>:

static void
serial_init(void)
{
  8004200822:	55                   	push   %rbp
  8004200823:	48 89 e5             	mov    %rsp,%rbp
  8004200826:	48 83 ec 40          	sub    $0x40,%rsp
  800420082a:	c7 45 fc fa 03 00 00 	movl   $0x3fa,-0x4(%rbp)
  8004200831:	c6 45 ce 00          	movb   $0x0,-0x32(%rbp)
  8004200835:	0f b6 45 ce          	movzbl -0x32(%rbp),%eax
  8004200839:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420083c:	ee                   	out    %al,(%dx)
  800420083d:	c7 45 f8 fb 03 00 00 	movl   $0x3fb,-0x8(%rbp)
  8004200844:	c6 45 cf 80          	movb   $0x80,-0x31(%rbp)
  8004200848:	0f b6 45 cf          	movzbl -0x31(%rbp),%eax
  800420084c:	8b 55 f8             	mov    -0x8(%rbp),%edx
  800420084f:	ee                   	out    %al,(%dx)
  8004200850:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%rbp)
  8004200857:	c6 45 d0 0c          	movb   $0xc,-0x30(%rbp)
  800420085b:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
  800420085f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004200862:	ee                   	out    %al,(%dx)
  8004200863:	c7 45 f0 f9 03 00 00 	movl   $0x3f9,-0x10(%rbp)
  800420086a:	c6 45 d1 00          	movb   $0x0,-0x2f(%rbp)
  800420086e:	0f b6 45 d1          	movzbl -0x2f(%rbp),%eax
  8004200872:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200875:	ee                   	out    %al,(%dx)
  8004200876:	c7 45 ec fb 03 00 00 	movl   $0x3fb,-0x14(%rbp)
  800420087d:	c6 45 d2 03          	movb   $0x3,-0x2e(%rbp)
  8004200881:	0f b6 45 d2          	movzbl -0x2e(%rbp),%eax
  8004200885:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200888:	ee                   	out    %al,(%dx)
  8004200889:	c7 45 e8 fc 03 00 00 	movl   $0x3fc,-0x18(%rbp)
  8004200890:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
  8004200894:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200898:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420089b:	ee                   	out    %al,(%dx)
  800420089c:	c7 45 e4 f9 03 00 00 	movl   $0x3f9,-0x1c(%rbp)
  80042008a3:	c6 45 d4 01          	movb   $0x1,-0x2c(%rbp)
  80042008a7:	0f b6 45 d4          	movzbl -0x2c(%rbp),%eax
  80042008ab:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042008ae:	ee                   	out    %al,(%dx)
  80042008af:	c7 45 e0 fd 03 00 00 	movl   $0x3fd,-0x20(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042008b6:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042008b9:	89 c2                	mov    %eax,%edx
  80042008bb:	ec                   	in     (%dx),%al
  80042008bc:	88 45 d5             	mov    %al,-0x2b(%rbp)
	return data;
  80042008bf:	0f b6 45 d5          	movzbl -0x2b(%rbp),%eax
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
  80042008c3:	3c ff                	cmp    $0xff,%al
  80042008c5:	0f 95 c2             	setne  %dl
  80042008c8:	48 b8 00 00 4e 04 80 	movabs $0x80044e0000,%rax
  80042008cf:	00 00 00 
  80042008d2:	88 10                	mov    %dl,(%rax)
  80042008d4:	c7 45 dc fa 03 00 00 	movl   $0x3fa,-0x24(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042008db:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042008de:	89 c2                	mov    %eax,%edx
  80042008e0:	ec                   	in     (%dx),%al
  80042008e1:	88 45 d6             	mov    %al,-0x2a(%rbp)
  80042008e4:	c7 45 d8 f8 03 00 00 	movl   $0x3f8,-0x28(%rbp)
  80042008eb:	8b 45 d8             	mov    -0x28(%rbp),%eax
  80042008ee:	89 c2                	mov    %eax,%edx
  80042008f0:	ec                   	in     (%dx),%al
  80042008f1:	88 45 d7             	mov    %al,-0x29(%rbp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);


	// Enable serial interrupts
	if (serial_exists)
  80042008f4:	48 b8 00 00 4e 04 80 	movabs $0x80044e0000,%rax
  80042008fb:	00 00 00 
  80042008fe:	0f b6 00             	movzbl (%rax),%eax
  8004200901:	84 c0                	test   %al,%al
  8004200903:	74 23                	je     8004200928 <serial_init+0x106>
		irq_setmask_8259A(irq_mask_8259A & ~(1<<4));
  8004200905:	48 b8 72 66 23 04 80 	movabs $0x8004236672,%rax
  800420090c:	00 00 00 
  800420090f:	0f b7 00             	movzwl (%rax),%eax
  8004200912:	0f b7 c0             	movzwl %ax,%eax
  8004200915:	25 ef ff 00 00       	and    $0xffef,%eax
  800420091a:	89 c7                	mov    %eax,%edi
  800420091c:	48 b8 39 9b 20 04 80 	movabs $0x8004209b39,%rax
  8004200923:	00 00 00 
  8004200926:	ff d0                	callq  *%rax

}
  8004200928:	90                   	nop
  8004200929:	c9                   	leaveq 
  800420092a:	c3                   	retq   

000000800420092b <lpt_putc>:
// For information on PC parallel port programming, see the class References
// page.

static void
lpt_putc(int c)
{
  800420092b:	55                   	push   %rbp
  800420092c:	48 89 e5             	mov    %rsp,%rbp
  800420092f:	48 83 ec 28          	sub    $0x28,%rsp
  8004200933:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200936:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420093d:	eb 10                	jmp    800420094f <lpt_putc+0x24>
		delay();
  800420093f:	48 b8 fd 06 20 04 80 	movabs $0x80042006fd,%rax
  8004200946:	00 00 00 
  8004200949:	ff d0                	callq  *%rax
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  800420094b:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420094f:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%rbp)
  8004200956:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200959:	89 c2                	mov    %eax,%edx
  800420095b:	ec                   	in     (%dx),%al
  800420095c:	88 45 eb             	mov    %al,-0x15(%rbp)
	return data;
  800420095f:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200963:	84 c0                	test   %al,%al
  8004200965:	78 09                	js     8004200970 <lpt_putc+0x45>
  8004200967:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  800420096e:	7e cf                	jle    800420093f <lpt_putc+0x14>
		delay();
	outb(0x378+0, c);
  8004200970:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200973:	0f b6 c0             	movzbl %al,%eax
  8004200976:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%rbp)
  800420097d:	88 45 e8             	mov    %al,-0x18(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200980:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  8004200984:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004200987:	ee                   	out    %al,(%dx)
  8004200988:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%rbp)
  800420098f:	c6 45 e9 0d          	movb   $0xd,-0x17(%rbp)
  8004200993:	0f b6 45 e9          	movzbl -0x17(%rbp),%eax
  8004200997:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800420099a:	ee                   	out    %al,(%dx)
  800420099b:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%rbp)
  80042009a2:	c6 45 ea 08          	movb   $0x8,-0x16(%rbp)
  80042009a6:	0f b6 45 ea          	movzbl -0x16(%rbp),%eax
  80042009aa:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80042009ad:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
  80042009ae:	90                   	nop
  80042009af:	c9                   	leaveq 
  80042009b0:	c3                   	retq   

00000080042009b1 <cga_init>:
static uint16_t crt_pos;


static void
cga_init(void)
{
  80042009b1:	55                   	push   %rbp
  80042009b2:	48 89 e5             	mov    %rsp,%rbp
  80042009b5:	48 83 ec 30          	sub    $0x30,%rsp
	volatile uint16_t *cp;
	uint16_t was;
	unsigned pos;

	cp = (uint16_t*) (KERNBASE + CGA_BUF);
  80042009b9:	48 b8 00 80 0b 04 80 	movabs $0x80040b8000,%rax
  80042009c0:	00 00 00 
  80042009c3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	was = *cp;
  80042009c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042009cb:	0f b7 00             	movzwl (%rax),%eax
  80042009ce:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	*cp = (uint16_t) 0xA55A;
  80042009d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042009d6:	66 c7 00 5a a5       	movw   $0xa55a,(%rax)
	if (*cp != 0xA55A) {
  80042009db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042009df:	0f b7 00             	movzwl (%rax),%eax
  80042009e2:	66 3d 5a a5          	cmp    $0xa55a,%ax
  80042009e6:	74 20                	je     8004200a08 <cga_init+0x57>
		cp = (uint16_t*) (KERNBASE + MONO_BUF);
  80042009e8:	48 b8 00 00 0b 04 80 	movabs $0x80040b0000,%rax
  80042009ef:	00 00 00 
  80042009f2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		addr_6845 = MONO_BASE;
  80042009f6:	48 b8 04 00 4e 04 80 	movabs $0x80044e0004,%rax
  80042009fd:	00 00 00 
  8004200a00:	c7 00 b4 03 00 00    	movl   $0x3b4,(%rax)
  8004200a06:	eb 1b                	jmp    8004200a23 <cga_init+0x72>
	} else {
		*cp = was;
  8004200a08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a0c:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004200a10:	66 89 10             	mov    %dx,(%rax)
		addr_6845 = CGA_BASE;
  8004200a13:	48 b8 04 00 4e 04 80 	movabs $0x80044e0004,%rax
  8004200a1a:	00 00 00 
  8004200a1d:	c7 00 d4 03 00 00    	movl   $0x3d4,(%rax)
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
  8004200a23:	48 b8 04 00 4e 04 80 	movabs $0x80044e0004,%rax
  8004200a2a:	00 00 00 
  8004200a2d:	8b 00                	mov    (%rax),%eax
  8004200a2f:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004200a32:	c6 45 dc 0e          	movb   $0xe,-0x24(%rbp)
  8004200a36:	0f b6 45 dc          	movzbl -0x24(%rbp),%eax
  8004200a3a:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200a3d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
  8004200a3e:	48 b8 04 00 4e 04 80 	movabs $0x80044e0004,%rax
  8004200a45:	00 00 00 
  8004200a48:	8b 00                	mov    (%rax),%eax
  8004200a4a:	83 c0 01             	add    $0x1,%eax
  8004200a4d:	89 45 e8             	mov    %eax,-0x18(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a50:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004200a53:	89 c2                	mov    %eax,%edx
  8004200a55:	ec                   	in     (%dx),%al
  8004200a56:	88 45 dd             	mov    %al,-0x23(%rbp)
	return data;
  8004200a59:	0f b6 45 dd          	movzbl -0x23(%rbp),%eax
  8004200a5d:	0f b6 c0             	movzbl %al,%eax
  8004200a60:	c1 e0 08             	shl    $0x8,%eax
  8004200a63:	89 45 ec             	mov    %eax,-0x14(%rbp)
	outb(addr_6845, 15);
  8004200a66:	48 b8 04 00 4e 04 80 	movabs $0x80044e0004,%rax
  8004200a6d:	00 00 00 
  8004200a70:	8b 00                	mov    (%rax),%eax
  8004200a72:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004200a75:	c6 45 de 0f          	movb   $0xf,-0x22(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200a79:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  8004200a7d:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200a80:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
  8004200a81:	48 b8 04 00 4e 04 80 	movabs $0x80044e0004,%rax
  8004200a88:	00 00 00 
  8004200a8b:	8b 00                	mov    (%rax),%eax
  8004200a8d:	83 c0 01             	add    $0x1,%eax
  8004200a90:	89 45 e0             	mov    %eax,-0x20(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a93:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004200a96:	89 c2                	mov    %eax,%edx
  8004200a98:	ec                   	in     (%dx),%al
  8004200a99:	88 45 df             	mov    %al,-0x21(%rbp)
	return data;
  8004200a9c:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200aa0:	0f b6 c0             	movzbl %al,%eax
  8004200aa3:	09 45 ec             	or     %eax,-0x14(%rbp)

	crt_buf = (uint16_t*) cp;
  8004200aa6:	48 b8 08 00 4e 04 80 	movabs $0x80044e0008,%rax
  8004200aad:	00 00 00 
  8004200ab0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200ab4:	48 89 10             	mov    %rdx,(%rax)
	crt_pos = pos;
  8004200ab7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200aba:	89 c2                	mov    %eax,%edx
  8004200abc:	48 b8 10 00 4e 04 80 	movabs $0x80044e0010,%rax
  8004200ac3:	00 00 00 
  8004200ac6:	66 89 10             	mov    %dx,(%rax)
}
  8004200ac9:	90                   	nop
  8004200aca:	c9                   	leaveq 
  8004200acb:	c3                   	retq   

0000008004200acc <cga_putc>:



static void
cga_putc(int c)
{
  8004200acc:	55                   	push   %rbp
  8004200acd:	48 89 e5             	mov    %rsp,%rbp
  8004200ad0:	48 83 ec 30          	sub    $0x30,%rsp
  8004200ad4:	89 7d dc             	mov    %edi,-0x24(%rbp)

	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
  8004200ad7:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200ada:	b0 00                	mov    $0x0,%al
  8004200adc:	85 c0                	test   %eax,%eax
  8004200ade:	75 07                	jne    8004200ae7 <cga_putc+0x1b>
		c |= 0x0700;
  8004200ae0:	81 4d dc 00 07 00 00 	orl    $0x700,-0x24(%rbp)

	switch (c & 0xff) {
  8004200ae7:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200aea:	0f b6 c0             	movzbl %al,%eax
  8004200aed:	83 f8 09             	cmp    $0x9,%eax
  8004200af0:	0f 84 f5 00 00 00    	je     8004200beb <cga_putc+0x11f>
  8004200af6:	83 f8 09             	cmp    $0x9,%eax
  8004200af9:	7f 0a                	jg     8004200b05 <cga_putc+0x39>
  8004200afb:	83 f8 08             	cmp    $0x8,%eax
  8004200afe:	74 18                	je     8004200b18 <cga_putc+0x4c>
  8004200b00:	e9 3d 01 00 00       	jmpq   8004200c42 <cga_putc+0x176>
  8004200b05:	83 f8 0a             	cmp    $0xa,%eax
  8004200b08:	74 74                	je     8004200b7e <cga_putc+0xb2>
  8004200b0a:	83 f8 0d             	cmp    $0xd,%eax
  8004200b0d:	0f 84 88 00 00 00    	je     8004200b9b <cga_putc+0xcf>
  8004200b13:	e9 2a 01 00 00       	jmpq   8004200c42 <cga_putc+0x176>
	case '\b':
		if (crt_pos > 0) {
  8004200b18:	48 b8 10 00 4e 04 80 	movabs $0x80044e0010,%rax
  8004200b1f:	00 00 00 
  8004200b22:	0f b7 00             	movzwl (%rax),%eax
  8004200b25:	66 85 c0             	test   %ax,%ax
  8004200b28:	0f 84 4f 01 00 00    	je     8004200c7d <cga_putc+0x1b1>
			crt_pos--;
  8004200b2e:	48 b8 10 00 4e 04 80 	movabs $0x80044e0010,%rax
  8004200b35:	00 00 00 
  8004200b38:	0f b7 00             	movzwl (%rax),%eax
  8004200b3b:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004200b3e:	48 b8 10 00 4e 04 80 	movabs $0x80044e0010,%rax
  8004200b45:	00 00 00 
  8004200b48:	66 89 10             	mov    %dx,(%rax)
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
  8004200b4b:	48 b8 08 00 4e 04 80 	movabs $0x80044e0008,%rax
  8004200b52:	00 00 00 
  8004200b55:	48 8b 10             	mov    (%rax),%rdx
  8004200b58:	48 b8 10 00 4e 04 80 	movabs $0x80044e0010,%rax
  8004200b5f:	00 00 00 
  8004200b62:	0f b7 00             	movzwl (%rax),%eax
  8004200b65:	0f b7 c0             	movzwl %ax,%eax
  8004200b68:	48 01 c0             	add    %rax,%rax
  8004200b6b:	48 01 d0             	add    %rdx,%rax
  8004200b6e:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200b71:	b2 00                	mov    $0x0,%dl
  8004200b73:	83 ca 20             	or     $0x20,%edx
  8004200b76:	66 89 10             	mov    %dx,(%rax)
		}
		break;
  8004200b79:	e9 ff 00 00 00       	jmpq   8004200c7d <cga_putc+0x1b1>
	case '\n':
		crt_pos += CRT_COLS;
  8004200b7e:	48 b8 10 00 4e 04 80 	movabs $0x80044e0010,%rax
  8004200b85:	00 00 00 
  8004200b88:	0f b7 00             	movzwl (%rax),%eax
  8004200b8b:	8d 50 50             	lea    0x50(%rax),%edx
  8004200b8e:	48 b8 10 00 4e 04 80 	movabs $0x80044e0010,%rax
  8004200b95:	00 00 00 
  8004200b98:	66 89 10             	mov    %dx,(%rax)
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
  8004200b9b:	48 b8 10 00 4e 04 80 	movabs $0x80044e0010,%rax
  8004200ba2:	00 00 00 
  8004200ba5:	0f b7 30             	movzwl (%rax),%esi
  8004200ba8:	48 b8 10 00 4e 04 80 	movabs $0x80044e0010,%rax
  8004200baf:	00 00 00 
  8004200bb2:	0f b7 08             	movzwl (%rax),%ecx
  8004200bb5:	0f b7 c1             	movzwl %cx,%eax
  8004200bb8:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  8004200bbe:	c1 e8 10             	shr    $0x10,%eax
  8004200bc1:	89 c2                	mov    %eax,%edx
  8004200bc3:	66 c1 ea 06          	shr    $0x6,%dx
  8004200bc7:	89 d0                	mov    %edx,%eax
  8004200bc9:	c1 e0 02             	shl    $0x2,%eax
  8004200bcc:	01 d0                	add    %edx,%eax
  8004200bce:	c1 e0 04             	shl    $0x4,%eax
  8004200bd1:	29 c1                	sub    %eax,%ecx
  8004200bd3:	89 ca                	mov    %ecx,%edx
  8004200bd5:	29 d6                	sub    %edx,%esi
  8004200bd7:	89 f2                	mov    %esi,%edx
  8004200bd9:	48 b8 10 00 4e 04 80 	movabs $0x80044e0010,%rax
  8004200be0:	00 00 00 
  8004200be3:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200be6:	e9 93 00 00 00       	jmpq   8004200c7e <cga_putc+0x1b2>
	case '\t':
		cons_putc(' ');
  8004200beb:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200bf0:	48 b8 74 11 20 04 80 	movabs $0x8004201174,%rax
  8004200bf7:	00 00 00 
  8004200bfa:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200bfc:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c01:	48 b8 74 11 20 04 80 	movabs $0x8004201174,%rax
  8004200c08:	00 00 00 
  8004200c0b:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c0d:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c12:	48 b8 74 11 20 04 80 	movabs $0x8004201174,%rax
  8004200c19:	00 00 00 
  8004200c1c:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c1e:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c23:	48 b8 74 11 20 04 80 	movabs $0x8004201174,%rax
  8004200c2a:	00 00 00 
  8004200c2d:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c2f:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c34:	48 b8 74 11 20 04 80 	movabs $0x8004201174,%rax
  8004200c3b:	00 00 00 
  8004200c3e:	ff d0                	callq  *%rax
		break;
  8004200c40:	eb 3c                	jmp    8004200c7e <cga_putc+0x1b2>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
  8004200c42:	48 b8 08 00 4e 04 80 	movabs $0x80044e0008,%rax
  8004200c49:	00 00 00 
  8004200c4c:	48 8b 30             	mov    (%rax),%rsi
  8004200c4f:	48 b8 10 00 4e 04 80 	movabs $0x80044e0010,%rax
  8004200c56:	00 00 00 
  8004200c59:	0f b7 00             	movzwl (%rax),%eax
  8004200c5c:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200c5f:	48 ba 10 00 4e 04 80 	movabs $0x80044e0010,%rdx
  8004200c66:	00 00 00 
  8004200c69:	66 89 0a             	mov    %cx,(%rdx)
  8004200c6c:	0f b7 c0             	movzwl %ax,%eax
  8004200c6f:	48 01 c0             	add    %rax,%rax
  8004200c72:	48 01 f0             	add    %rsi,%rax
  8004200c75:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200c78:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200c7b:	eb 01                	jmp    8004200c7e <cga_putc+0x1b2>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
  8004200c7d:	90                   	nop
	}


	/* scroll if necessary */

	if (crt_pos >= CRT_SIZE) {
  8004200c7e:	48 b8 10 00 4e 04 80 	movabs $0x80044e0010,%rax
  8004200c85:	00 00 00 
  8004200c88:	0f b7 00             	movzwl (%rax),%eax
  8004200c8b:	66 3d cf 07          	cmp    $0x7cf,%ax
  8004200c8f:	0f 86 89 00 00 00    	jbe    8004200d1e <cga_putc+0x252>
		int i;


		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  8004200c95:	48 b8 08 00 4e 04 80 	movabs $0x80044e0008,%rax
  8004200c9c:	00 00 00 
  8004200c9f:	48 8b 00             	mov    (%rax),%rax
  8004200ca2:	48 8d 88 a0 00 00 00 	lea    0xa0(%rax),%rcx
  8004200ca9:	48 b8 08 00 4e 04 80 	movabs $0x80044e0008,%rax
  8004200cb0:	00 00 00 
  8004200cb3:	48 8b 00             	mov    (%rax),%rax
  8004200cb6:	ba 00 0f 00 00       	mov    $0xf00,%edx
  8004200cbb:	48 89 ce             	mov    %rcx,%rsi
  8004200cbe:	48 89 c7             	mov    %rax,%rdi
  8004200cc1:	48 b8 44 12 21 04 80 	movabs $0x8004211244,%rax
  8004200cc8:	00 00 00 
  8004200ccb:	ff d0                	callq  *%rax
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200ccd:	c7 45 fc 80 07 00 00 	movl   $0x780,-0x4(%rbp)
  8004200cd4:	eb 22                	jmp    8004200cf8 <cga_putc+0x22c>
			crt_buf[i] = 0x0700 | ' ';
  8004200cd6:	48 b8 08 00 4e 04 80 	movabs $0x80044e0008,%rax
  8004200cdd:	00 00 00 
  8004200ce0:	48 8b 00             	mov    (%rax),%rax
  8004200ce3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200ce6:	48 63 d2             	movslq %edx,%rdx
  8004200ce9:	48 01 d2             	add    %rdx,%rdx
  8004200cec:	48 01 d0             	add    %rdx,%rax
  8004200cef:	66 c7 00 20 07       	movw   $0x720,(%rax)
	if (crt_pos >= CRT_SIZE) {
		int i;


		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200cf4:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200cf8:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%rbp)
  8004200cff:	7e d5                	jle    8004200cd6 <cga_putc+0x20a>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
  8004200d01:	48 b8 10 00 4e 04 80 	movabs $0x80044e0010,%rax
  8004200d08:	00 00 00 
  8004200d0b:	0f b7 00             	movzwl (%rax),%eax
  8004200d0e:	8d 50 b0             	lea    -0x50(%rax),%edx
  8004200d11:	48 b8 10 00 4e 04 80 	movabs $0x80044e0010,%rax
  8004200d18:	00 00 00 
  8004200d1b:	66 89 10             	mov    %dx,(%rax)
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
  8004200d1e:	48 b8 04 00 4e 04 80 	movabs $0x80044e0004,%rax
  8004200d25:	00 00 00 
  8004200d28:	8b 00                	mov    (%rax),%eax
  8004200d2a:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004200d2d:	c6 45 e8 0e          	movb   $0xe,-0x18(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200d31:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  8004200d35:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200d38:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
  8004200d39:	48 b8 10 00 4e 04 80 	movabs $0x80044e0010,%rax
  8004200d40:	00 00 00 
  8004200d43:	0f b7 00             	movzwl (%rax),%eax
  8004200d46:	66 c1 e8 08          	shr    $0x8,%ax
  8004200d4a:	0f b6 c0             	movzbl %al,%eax
  8004200d4d:	48 ba 04 00 4e 04 80 	movabs $0x80044e0004,%rdx
  8004200d54:	00 00 00 
  8004200d57:	8b 12                	mov    (%rdx),%edx
  8004200d59:	83 c2 01             	add    $0x1,%edx
  8004200d5c:	89 55 f4             	mov    %edx,-0xc(%rbp)
  8004200d5f:	88 45 e9             	mov    %al,-0x17(%rbp)
  8004200d62:	0f b6 45 e9          	movzbl -0x17(%rbp),%eax
  8004200d66:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004200d69:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
  8004200d6a:	48 b8 04 00 4e 04 80 	movabs $0x80044e0004,%rax
  8004200d71:	00 00 00 
  8004200d74:	8b 00                	mov    (%rax),%eax
  8004200d76:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004200d79:	c6 45 ea 0f          	movb   $0xf,-0x16(%rbp)
  8004200d7d:	0f b6 45 ea          	movzbl -0x16(%rbp),%eax
  8004200d81:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200d84:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
  8004200d85:	48 b8 10 00 4e 04 80 	movabs $0x80044e0010,%rax
  8004200d8c:	00 00 00 
  8004200d8f:	0f b7 00             	movzwl (%rax),%eax
  8004200d92:	0f b6 c0             	movzbl %al,%eax
  8004200d95:	48 ba 04 00 4e 04 80 	movabs $0x80044e0004,%rdx
  8004200d9c:	00 00 00 
  8004200d9f:	8b 12                	mov    (%rdx),%edx
  8004200da1:	83 c2 01             	add    $0x1,%edx
  8004200da4:	89 55 ec             	mov    %edx,-0x14(%rbp)
  8004200da7:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004200daa:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200dae:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200db1:	ee                   	out    %al,(%dx)
}
  8004200db2:	90                   	nop
  8004200db3:	c9                   	leaveq 
  8004200db4:	c3                   	retq   

0000008004200db5 <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
  8004200db5:	55                   	push   %rbp
  8004200db6:	48 89 e5             	mov    %rsp,%rbp
  8004200db9:	48 83 ec 20          	sub    $0x20,%rsp
  8004200dbd:	c7 45 ec 64 00 00 00 	movl   $0x64,-0x14(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200dc4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200dc7:	89 c2                	mov    %eax,%edx
  8004200dc9:	ec                   	in     (%dx),%al
  8004200dca:	88 45 eb             	mov    %al,-0x15(%rbp)
	return data;
  8004200dcd:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
	int c;
	uint8_t data;
	static uint32_t shift;
	int r;
	if ((inb(KBSTATP) & KBS_DIB) == 0)
  8004200dd1:	0f b6 c0             	movzbl %al,%eax
  8004200dd4:	83 e0 01             	and    $0x1,%eax
  8004200dd7:	85 c0                	test   %eax,%eax
  8004200dd9:	75 0a                	jne    8004200de5 <kbd_proc_data+0x30>
		return -1;
  8004200ddb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200de0:	e9 fc 01 00 00       	jmpq   8004200fe1 <kbd_proc_data+0x22c>
  8004200de5:	c7 45 f4 60 00 00 00 	movl   $0x60,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200dec:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200def:	89 c2                	mov    %eax,%edx
  8004200df1:	ec                   	in     (%dx),%al
  8004200df2:	88 45 ea             	mov    %al,-0x16(%rbp)
	return data;
  8004200df5:	0f b6 45 ea          	movzbl -0x16(%rbp),%eax

	data = inb(KBDATAP);
  8004200df9:	88 45 fb             	mov    %al,-0x5(%rbp)

	if (data == 0xE0) {
  8004200dfc:	80 7d fb e0          	cmpb   $0xe0,-0x5(%rbp)
  8004200e00:	75 27                	jne    8004200e29 <kbd_proc_data+0x74>
		// E0 escape character
		shift |= E0ESC;
  8004200e02:	48 b8 28 02 4e 04 80 	movabs $0x80044e0228,%rax
  8004200e09:	00 00 00 
  8004200e0c:	8b 00                	mov    (%rax),%eax
  8004200e0e:	83 c8 40             	or     $0x40,%eax
  8004200e11:	89 c2                	mov    %eax,%edx
  8004200e13:	48 b8 28 02 4e 04 80 	movabs $0x80044e0228,%rax
  8004200e1a:	00 00 00 
  8004200e1d:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200e1f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200e24:	e9 b8 01 00 00       	jmpq   8004200fe1 <kbd_proc_data+0x22c>
	} else if (data & 0x80) {
  8004200e29:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e2d:	84 c0                	test   %al,%al
  8004200e2f:	79 65                	jns    8004200e96 <kbd_proc_data+0xe1>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
  8004200e31:	48 b8 28 02 4e 04 80 	movabs $0x80044e0228,%rax
  8004200e38:	00 00 00 
  8004200e3b:	8b 00                	mov    (%rax),%eax
  8004200e3d:	83 e0 40             	and    $0x40,%eax
  8004200e40:	85 c0                	test   %eax,%eax
  8004200e42:	75 09                	jne    8004200e4d <kbd_proc_data+0x98>
  8004200e44:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e48:	83 e0 7f             	and    $0x7f,%eax
  8004200e4b:	eb 04                	jmp    8004200e51 <kbd_proc_data+0x9c>
  8004200e4d:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e51:	88 45 fb             	mov    %al,-0x5(%rbp)
		shift &= ~(shiftcode[data] | E0ESC);
  8004200e54:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e58:	48 ba 60 60 23 04 80 	movabs $0x8004236060,%rdx
  8004200e5f:	00 00 00 
  8004200e62:	48 98                	cltq   
  8004200e64:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200e68:	83 c8 40             	or     $0x40,%eax
  8004200e6b:	0f b6 c0             	movzbl %al,%eax
  8004200e6e:	f7 d0                	not    %eax
  8004200e70:	89 c2                	mov    %eax,%edx
  8004200e72:	48 b8 28 02 4e 04 80 	movabs $0x80044e0228,%rax
  8004200e79:	00 00 00 
  8004200e7c:	8b 00                	mov    (%rax),%eax
  8004200e7e:	21 c2                	and    %eax,%edx
  8004200e80:	48 b8 28 02 4e 04 80 	movabs $0x80044e0228,%rax
  8004200e87:	00 00 00 
  8004200e8a:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200e8c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200e91:	e9 4b 01 00 00       	jmpq   8004200fe1 <kbd_proc_data+0x22c>
	} else if (shift & E0ESC) {
  8004200e96:	48 b8 28 02 4e 04 80 	movabs $0x80044e0228,%rax
  8004200e9d:	00 00 00 
  8004200ea0:	8b 00                	mov    (%rax),%eax
  8004200ea2:	83 e0 40             	and    $0x40,%eax
  8004200ea5:	85 c0                	test   %eax,%eax
  8004200ea7:	74 21                	je     8004200eca <kbd_proc_data+0x115>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
  8004200ea9:	80 4d fb 80          	orb    $0x80,-0x5(%rbp)
		shift &= ~E0ESC;
  8004200ead:	48 b8 28 02 4e 04 80 	movabs $0x80044e0228,%rax
  8004200eb4:	00 00 00 
  8004200eb7:	8b 00                	mov    (%rax),%eax
  8004200eb9:	83 e0 bf             	and    $0xffffffbf,%eax
  8004200ebc:	89 c2                	mov    %eax,%edx
  8004200ebe:	48 b8 28 02 4e 04 80 	movabs $0x80044e0228,%rax
  8004200ec5:	00 00 00 
  8004200ec8:	89 10                	mov    %edx,(%rax)
	}

	shift |= shiftcode[data];
  8004200eca:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200ece:	48 ba 60 60 23 04 80 	movabs $0x8004236060,%rdx
  8004200ed5:	00 00 00 
  8004200ed8:	48 98                	cltq   
  8004200eda:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200ede:	0f b6 d0             	movzbl %al,%edx
  8004200ee1:	48 b8 28 02 4e 04 80 	movabs $0x80044e0228,%rax
  8004200ee8:	00 00 00 
  8004200eeb:	8b 00                	mov    (%rax),%eax
  8004200eed:	09 c2                	or     %eax,%edx
  8004200eef:	48 b8 28 02 4e 04 80 	movabs $0x80044e0228,%rax
  8004200ef6:	00 00 00 
  8004200ef9:	89 10                	mov    %edx,(%rax)
	shift ^= togglecode[data];
  8004200efb:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200eff:	48 ba 60 61 23 04 80 	movabs $0x8004236160,%rdx
  8004200f06:	00 00 00 
  8004200f09:	48 98                	cltq   
  8004200f0b:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200f0f:	0f b6 d0             	movzbl %al,%edx
  8004200f12:	48 b8 28 02 4e 04 80 	movabs $0x80044e0228,%rax
  8004200f19:	00 00 00 
  8004200f1c:	8b 00                	mov    (%rax),%eax
  8004200f1e:	31 c2                	xor    %eax,%edx
  8004200f20:	48 b8 28 02 4e 04 80 	movabs $0x80044e0228,%rax
  8004200f27:	00 00 00 
  8004200f2a:	89 10                	mov    %edx,(%rax)

	c = charcode[shift & (CTL | SHIFT)][data];
  8004200f2c:	48 b8 28 02 4e 04 80 	movabs $0x80044e0228,%rax
  8004200f33:	00 00 00 
  8004200f36:	8b 00                	mov    (%rax),%eax
  8004200f38:	83 e0 03             	and    $0x3,%eax
  8004200f3b:	89 c2                	mov    %eax,%edx
  8004200f3d:	48 b8 60 65 23 04 80 	movabs $0x8004236560,%rax
  8004200f44:	00 00 00 
  8004200f47:	89 d2                	mov    %edx,%edx
  8004200f49:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8004200f4d:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f51:	48 01 d0             	add    %rdx,%rax
  8004200f54:	0f b6 00             	movzbl (%rax),%eax
  8004200f57:	0f b6 c0             	movzbl %al,%eax
  8004200f5a:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (shift & CAPSLOCK) {
  8004200f5d:	48 b8 28 02 4e 04 80 	movabs $0x80044e0228,%rax
  8004200f64:	00 00 00 
  8004200f67:	8b 00                	mov    (%rax),%eax
  8004200f69:	83 e0 08             	and    $0x8,%eax
  8004200f6c:	85 c0                	test   %eax,%eax
  8004200f6e:	74 22                	je     8004200f92 <kbd_proc_data+0x1dd>
		if ('a' <= c && c <= 'z')
  8004200f70:	83 7d fc 60          	cmpl   $0x60,-0x4(%rbp)
  8004200f74:	7e 0c                	jle    8004200f82 <kbd_proc_data+0x1cd>
  8004200f76:	83 7d fc 7a          	cmpl   $0x7a,-0x4(%rbp)
  8004200f7a:	7f 06                	jg     8004200f82 <kbd_proc_data+0x1cd>
			c += 'A' - 'a';
  8004200f7c:	83 6d fc 20          	subl   $0x20,-0x4(%rbp)
  8004200f80:	eb 10                	jmp    8004200f92 <kbd_proc_data+0x1dd>
		else if ('A' <= c && c <= 'Z')
  8004200f82:	83 7d fc 40          	cmpl   $0x40,-0x4(%rbp)
  8004200f86:	7e 0a                	jle    8004200f92 <kbd_proc_data+0x1dd>
  8004200f88:	83 7d fc 5a          	cmpl   $0x5a,-0x4(%rbp)
  8004200f8c:	7f 04                	jg     8004200f92 <kbd_proc_data+0x1dd>
			c += 'a' - 'A';
  8004200f8e:	83 45 fc 20          	addl   $0x20,-0x4(%rbp)
	}

	// Process special keys

	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  8004200f92:	48 b8 28 02 4e 04 80 	movabs $0x80044e0228,%rax
  8004200f99:	00 00 00 
  8004200f9c:	8b 00                	mov    (%rax),%eax
  8004200f9e:	f7 d0                	not    %eax
  8004200fa0:	83 e0 06             	and    $0x6,%eax
  8004200fa3:	85 c0                	test   %eax,%eax
  8004200fa5:	75 37                	jne    8004200fde <kbd_proc_data+0x229>
  8004200fa7:	81 7d fc e9 00 00 00 	cmpl   $0xe9,-0x4(%rbp)
  8004200fae:	75 2e                	jne    8004200fde <kbd_proc_data+0x229>
		cprintf("Rebooting!\n");
  8004200fb0:	48 bf ae f0 21 04 80 	movabs $0x800421f0ae,%rdi
  8004200fb7:	00 00 00 
  8004200fba:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200fbf:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004200fc6:	00 00 00 
  8004200fc9:	ff d2                	callq  *%rdx
  8004200fcb:	c7 45 f0 92 00 00 00 	movl   $0x92,-0x10(%rbp)
  8004200fd2:	c6 45 e9 03          	movb   $0x3,-0x17(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200fd6:	0f b6 45 e9          	movzbl -0x17(%rbp),%eax
  8004200fda:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200fdd:	ee                   	out    %al,(%dx)
		cprintf("ESC pressed\n");
		asm("vmcall":"=a"(r): "0"(VMX_VMCALL_BACKTOHOST));
	}
#endif

	return c;
  8004200fde:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004200fe1:	c9                   	leaveq 
  8004200fe2:	c3                   	retq   

0000008004200fe3 <kbd_intr>:

void
kbd_intr(void)
{
  8004200fe3:	55                   	push   %rbp
  8004200fe4:	48 89 e5             	mov    %rsp,%rbp
	cons_intr(kbd_proc_data);
  8004200fe7:	48 bf b5 0d 20 04 80 	movabs $0x8004200db5,%rdi
  8004200fee:	00 00 00 
  8004200ff1:	48 b8 36 10 20 04 80 	movabs $0x8004201036,%rax
  8004200ff8:	00 00 00 
  8004200ffb:	ff d0                	callq  *%rax
}
  8004200ffd:	90                   	nop
  8004200ffe:	5d                   	pop    %rbp
  8004200fff:	c3                   	retq   

0000008004201000 <kbd_init>:

static void
kbd_init(void)
{
  8004201000:	55                   	push   %rbp
  8004201001:	48 89 e5             	mov    %rsp,%rbp

	// Drain the kbd buffer so that Bochs generates interrupts.
	kbd_intr();
  8004201004:	48 b8 e3 0f 20 04 80 	movabs $0x8004200fe3,%rax
  800420100b:	00 00 00 
  800420100e:	ff d0                	callq  *%rax
	irq_setmask_8259A(irq_mask_8259A & ~(1<<1));
  8004201010:	48 b8 72 66 23 04 80 	movabs $0x8004236672,%rax
  8004201017:	00 00 00 
  800420101a:	0f b7 00             	movzwl (%rax),%eax
  800420101d:	0f b7 c0             	movzwl %ax,%eax
  8004201020:	25 fd ff 00 00       	and    $0xfffd,%eax
  8004201025:	89 c7                	mov    %eax,%edi
  8004201027:	48 b8 39 9b 20 04 80 	movabs $0x8004209b39,%rax
  800420102e:	00 00 00 
  8004201031:	ff d0                	callq  *%rax

}
  8004201033:	90                   	nop
  8004201034:	5d                   	pop    %rbp
  8004201035:	c3                   	retq   

0000008004201036 <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
static void
cons_intr(int (*proc)(void))
{
  8004201036:	55                   	push   %rbp
  8004201037:	48 89 e5             	mov    %rsp,%rbp
  800420103a:	48 83 ec 20          	sub    $0x20,%rsp
  800420103e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int c;

	while ((c = (*proc)()) != -1) {
  8004201042:	eb 6a                	jmp    80042010ae <cons_intr+0x78>
		if (c == 0)
  8004201044:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201048:	75 02                	jne    800420104c <cons_intr+0x16>
			continue;
  800420104a:	eb 62                	jmp    80042010ae <cons_intr+0x78>
		cons.buf[cons.wpos++] = c;
  800420104c:	48 b8 20 00 4e 04 80 	movabs $0x80044e0020,%rax
  8004201053:	00 00 00 
  8004201056:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  800420105c:	8d 48 01             	lea    0x1(%rax),%ecx
  800420105f:	48 ba 20 00 4e 04 80 	movabs $0x80044e0020,%rdx
  8004201066:	00 00 00 
  8004201069:	89 8a 04 02 00 00    	mov    %ecx,0x204(%rdx)
  800420106f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004201072:	89 d1                	mov    %edx,%ecx
  8004201074:	48 ba 20 00 4e 04 80 	movabs $0x80044e0020,%rdx
  800420107b:	00 00 00 
  800420107e:	89 c0                	mov    %eax,%eax
  8004201080:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
		if (cons.wpos == CONSBUFSIZE)
  8004201083:	48 b8 20 00 4e 04 80 	movabs $0x80044e0020,%rax
  800420108a:	00 00 00 
  800420108d:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004201093:	3d 00 02 00 00       	cmp    $0x200,%eax
  8004201098:	75 14                	jne    80042010ae <cons_intr+0x78>
			cons.wpos = 0;
  800420109a:	48 b8 20 00 4e 04 80 	movabs $0x80044e0020,%rax
  80042010a1:	00 00 00 
  80042010a4:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%rax)
  80042010ab:	00 00 00 
static void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
  80042010ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042010b2:	ff d0                	callq  *%rax
  80042010b4:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80042010b7:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80042010bb:	75 87                	jne    8004201044 <cons_intr+0xe>
			continue;
		cons.buf[cons.wpos++] = c;
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;
	}
}
  80042010bd:	90                   	nop
  80042010be:	c9                   	leaveq 
  80042010bf:	c3                   	retq   

00000080042010c0 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
  80042010c0:	55                   	push   %rbp
  80042010c1:	48 89 e5             	mov    %rsp,%rbp
  80042010c4:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
  80042010c8:	48 b8 8e 07 20 04 80 	movabs $0x800420078e,%rax
  80042010cf:	00 00 00 
  80042010d2:	ff d0                	callq  *%rax
	kbd_intr();
  80042010d4:	48 b8 e3 0f 20 04 80 	movabs $0x8004200fe3,%rax
  80042010db:	00 00 00 
  80042010de:	ff d0                	callq  *%rax

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
  80042010e0:	48 b8 20 00 4e 04 80 	movabs $0x80044e0020,%rax
  80042010e7:	00 00 00 
  80042010ea:	8b 90 00 02 00 00    	mov    0x200(%rax),%edx
  80042010f0:	48 b8 20 00 4e 04 80 	movabs $0x80044e0020,%rax
  80042010f7:	00 00 00 
  80042010fa:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004201100:	39 c2                	cmp    %eax,%edx
  8004201102:	74 69                	je     800420116d <cons_getc+0xad>
		c = cons.buf[cons.rpos++];
  8004201104:	48 b8 20 00 4e 04 80 	movabs $0x80044e0020,%rax
  800420110b:	00 00 00 
  800420110e:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004201114:	8d 48 01             	lea    0x1(%rax),%ecx
  8004201117:	48 ba 20 00 4e 04 80 	movabs $0x80044e0020,%rdx
  800420111e:	00 00 00 
  8004201121:	89 8a 00 02 00 00    	mov    %ecx,0x200(%rdx)
  8004201127:	48 ba 20 00 4e 04 80 	movabs $0x80044e0020,%rdx
  800420112e:	00 00 00 
  8004201131:	89 c0                	mov    %eax,%eax
  8004201133:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004201137:	0f b6 c0             	movzbl %al,%eax
  800420113a:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (cons.rpos == CONSBUFSIZE)
  800420113d:	48 b8 20 00 4e 04 80 	movabs $0x80044e0020,%rax
  8004201144:	00 00 00 
  8004201147:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  800420114d:	3d 00 02 00 00       	cmp    $0x200,%eax
  8004201152:	75 14                	jne    8004201168 <cons_getc+0xa8>
			cons.rpos = 0;
  8004201154:	48 b8 20 00 4e 04 80 	movabs $0x80044e0020,%rax
  800420115b:	00 00 00 
  800420115e:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%rax)
  8004201165:	00 00 00 
		return c;
  8004201168:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420116b:	eb 05                	jmp    8004201172 <cons_getc+0xb2>
	}
	return 0;
  800420116d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201172:	c9                   	leaveq 
  8004201173:	c3                   	retq   

0000008004201174 <cons_putc>:

// output a character to the console
static void
cons_putc(int c)
{
  8004201174:	55                   	push   %rbp
  8004201175:	48 89 e5             	mov    %rsp,%rbp
  8004201178:	48 83 ec 10          	sub    $0x10,%rsp
  800420117c:	89 7d fc             	mov    %edi,-0x4(%rbp)
	serial_putc(c);
  800420117f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201182:	89 c7                	mov    %eax,%edi
  8004201184:	48 b8 bc 07 20 04 80 	movabs $0x80042007bc,%rax
  800420118b:	00 00 00 
  800420118e:	ff d0                	callq  *%rax
	lpt_putc(c);
  8004201190:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201193:	89 c7                	mov    %eax,%edi
  8004201195:	48 b8 2b 09 20 04 80 	movabs $0x800420092b,%rax
  800420119c:	00 00 00 
  800420119f:	ff d0                	callq  *%rax
	cga_putc(c);
  80042011a1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011a4:	89 c7                	mov    %eax,%edi
  80042011a6:	48 b8 cc 0a 20 04 80 	movabs $0x8004200acc,%rax
  80042011ad:	00 00 00 
  80042011b0:	ff d0                	callq  *%rax
}
  80042011b2:	90                   	nop
  80042011b3:	c9                   	leaveq 
  80042011b4:	c3                   	retq   

00000080042011b5 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
  80042011b5:	55                   	push   %rbp
  80042011b6:	48 89 e5             	mov    %rsp,%rbp
	cga_init();
  80042011b9:	48 b8 b1 09 20 04 80 	movabs $0x80042009b1,%rax
  80042011c0:	00 00 00 
  80042011c3:	ff d0                	callq  *%rax
	kbd_init();
  80042011c5:	48 b8 00 10 20 04 80 	movabs $0x8004201000,%rax
  80042011cc:	00 00 00 
  80042011cf:	ff d0                	callq  *%rax
	serial_init();
  80042011d1:	48 b8 22 08 20 04 80 	movabs $0x8004200822,%rax
  80042011d8:	00 00 00 
  80042011db:	ff d0                	callq  *%rax

	if (!serial_exists)
  80042011dd:	48 b8 00 00 4e 04 80 	movabs $0x80044e0000,%rax
  80042011e4:	00 00 00 
  80042011e7:	0f b6 00             	movzbl (%rax),%eax
  80042011ea:	83 f0 01             	xor    $0x1,%eax
  80042011ed:	84 c0                	test   %al,%al
  80042011ef:	74 1b                	je     800420120c <cons_init+0x57>
		cprintf("Serial port does not exist!\n");
  80042011f1:	48 bf ba f0 21 04 80 	movabs $0x800421f0ba,%rdi
  80042011f8:	00 00 00 
  80042011fb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201200:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004201207:	00 00 00 
  800420120a:	ff d2                	callq  *%rdx
}
  800420120c:	90                   	nop
  800420120d:	5d                   	pop    %rbp
  800420120e:	c3                   	retq   

000000800420120f <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
  800420120f:	55                   	push   %rbp
  8004201210:	48 89 e5             	mov    %rsp,%rbp
  8004201213:	48 83 ec 10          	sub    $0x10,%rsp
  8004201217:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cons_putc(c);
  800420121a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420121d:	89 c7                	mov    %eax,%edi
  800420121f:	48 b8 74 11 20 04 80 	movabs $0x8004201174,%rax
  8004201226:	00 00 00 
  8004201229:	ff d0                	callq  *%rax
}
  800420122b:	90                   	nop
  800420122c:	c9                   	leaveq 
  800420122d:	c3                   	retq   

000000800420122e <getchar>:

int
getchar(void)
{
  800420122e:	55                   	push   %rbp
  800420122f:	48 89 e5             	mov    %rsp,%rbp
  8004201232:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	while ((c = cons_getc()) == 0)
  8004201236:	48 b8 c0 10 20 04 80 	movabs $0x80042010c0,%rax
  800420123d:	00 00 00 
  8004201240:	ff d0                	callq  *%rax
  8004201242:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004201245:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201249:	74 eb                	je     8004201236 <getchar+0x8>
		/* do nothing */;
	return c;
  800420124b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420124e:	c9                   	leaveq 
  800420124f:	c3                   	retq   

0000008004201250 <iscons>:

int
iscons(int fdnum)
{
  8004201250:	55                   	push   %rbp
  8004201251:	48 89 e5             	mov    %rsp,%rbp
  8004201254:	48 83 ec 08          	sub    $0x8,%rsp
  8004201258:	89 7d fc             	mov    %edi,-0x4(%rbp)
	// used by readline
	return 1;
  800420125b:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004201260:	c9                   	leaveq 
  8004201261:	c3                   	retq   

0000008004201262 <mon_help>:

/***** Implementations of basic kernel monitor commands *****/

int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
  8004201262:	55                   	push   %rbp
  8004201263:	48 89 e5             	mov    %rsp,%rbp
  8004201266:	48 83 ec 30          	sub    $0x30,%rsp
  800420126a:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420126d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004201271:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  8004201275:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420127c:	eb 6f                	jmp    80042012ed <mon_help+0x8b>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  800420127e:	48 b9 80 65 23 04 80 	movabs $0x8004236580,%rcx
  8004201285:	00 00 00 
  8004201288:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420128b:	48 63 d0             	movslq %eax,%rdx
  800420128e:	48 89 d0             	mov    %rdx,%rax
  8004201291:	48 01 c0             	add    %rax,%rax
  8004201294:	48 01 d0             	add    %rdx,%rax
  8004201297:	48 c1 e0 03          	shl    $0x3,%rax
  800420129b:	48 01 c8             	add    %rcx,%rax
  800420129e:	48 83 c0 08          	add    $0x8,%rax
  80042012a2:	48 8b 08             	mov    (%rax),%rcx
  80042012a5:	48 be 80 65 23 04 80 	movabs $0x8004236580,%rsi
  80042012ac:	00 00 00 
  80042012af:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012b2:	48 63 d0             	movslq %eax,%rdx
  80042012b5:	48 89 d0             	mov    %rdx,%rax
  80042012b8:	48 01 c0             	add    %rax,%rax
  80042012bb:	48 01 d0             	add    %rdx,%rax
  80042012be:	48 c1 e0 03          	shl    $0x3,%rax
  80042012c2:	48 01 f0             	add    %rsi,%rax
  80042012c5:	48 8b 00             	mov    (%rax),%rax
  80042012c8:	48 89 ca             	mov    %rcx,%rdx
  80042012cb:	48 89 c6             	mov    %rax,%rsi
  80042012ce:	48 bf 6e f1 21 04 80 	movabs $0x800421f16e,%rdi
  80042012d5:	00 00 00 
  80042012d8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042012dd:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  80042012e4:	00 00 00 
  80042012e7:	ff d1                	callq  *%rcx
int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  80042012e9:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042012ed:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012f0:	83 f8 03             	cmp    $0x3,%eax
  80042012f3:	76 89                	jbe    800420127e <mon_help+0x1c>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
	return 0;
  80042012f5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042012fa:	c9                   	leaveq 
  80042012fb:	c3                   	retq   

00000080042012fc <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  80042012fc:	55                   	push   %rbp
  80042012fd:	48 89 e5             	mov    %rsp,%rbp
  8004201300:	48 83 ec 30          	sub    $0x30,%rsp
  8004201304:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004201307:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420130b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	extern char _start[], entry[], etext[], edata[], end[];

	cprintf("Special kernel symbols:\n");
  800420130f:	48 bf 77 f1 21 04 80 	movabs $0x800421f177,%rdi
  8004201316:	00 00 00 
  8004201319:	b8 00 00 00 00       	mov    $0x0,%eax
  800420131e:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004201325:	00 00 00 
  8004201328:	ff d2                	callq  *%rdx
	cprintf("  _start                  %08x (phys)\n", _start);
  800420132a:	48 be 0c 00 20 00 00 	movabs $0x20000c,%rsi
  8004201331:	00 00 00 
  8004201334:	48 bf 90 f1 21 04 80 	movabs $0x800421f190,%rdi
  800420133b:	00 00 00 
  800420133e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201343:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420134a:	00 00 00 
  800420134d:	ff d2                	callq  *%rdx
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
  800420134f:	48 b8 0c 00 20 00 00 	movabs $0x20000c,%rax
  8004201356:	00 00 00 
  8004201359:	48 89 c2             	mov    %rax,%rdx
  800420135c:	48 be 0c 00 20 04 80 	movabs $0x800420000c,%rsi
  8004201363:	00 00 00 
  8004201366:	48 bf b8 f1 21 04 80 	movabs $0x800421f1b8,%rdi
  800420136d:	00 00 00 
  8004201370:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201375:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800420137c:	00 00 00 
  800420137f:	ff d1                	callq  *%rcx
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
  8004201381:	48 b8 d2 ef 21 00 00 	movabs $0x21efd2,%rax
  8004201388:	00 00 00 
  800420138b:	48 89 c2             	mov    %rax,%rdx
  800420138e:	48 be d2 ef 21 04 80 	movabs $0x800421efd2,%rsi
  8004201395:	00 00 00 
  8004201398:	48 bf e0 f1 21 04 80 	movabs $0x800421f1e0,%rdi
  800420139f:	00 00 00 
  80042013a2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013a7:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  80042013ae:	00 00 00 
  80042013b1:	ff d1                	callq  *%rcx
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
  80042013b3:	48 b8 00 fd 4d 00 00 	movabs $0x4dfd00,%rax
  80042013ba:	00 00 00 
  80042013bd:	48 89 c2             	mov    %rax,%rdx
  80042013c0:	48 be 00 fd 4d 04 80 	movabs $0x80044dfd00,%rsi
  80042013c7:	00 00 00 
  80042013ca:	48 bf 08 f2 21 04 80 	movabs $0x800421f208,%rdi
  80042013d1:	00 00 00 
  80042013d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013d9:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  80042013e0:	00 00 00 
  80042013e3:	ff d1                	callq  *%rcx
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
  80042013e5:	48 b8 10 20 72 00 00 	movabs $0x722010,%rax
  80042013ec:	00 00 00 
  80042013ef:	48 89 c2             	mov    %rax,%rdx
  80042013f2:	48 be 10 20 72 04 80 	movabs $0x8004722010,%rsi
  80042013f9:	00 00 00 
  80042013fc:	48 bf 30 f2 21 04 80 	movabs $0x800421f230,%rdi
  8004201403:	00 00 00 
  8004201406:	b8 00 00 00 00       	mov    $0x0,%eax
  800420140b:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  8004201412:	00 00 00 
  8004201415:	ff d1                	callq  *%rcx
	cprintf("Kernel executable memory footprint: %dKB\n",
		ROUNDUP(end - entry, 1024) / 1024);
  8004201417:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  800420141e:	00 
  800420141f:	48 b8 0c 00 20 04 80 	movabs $0x800420000c,%rax
  8004201426:	00 00 00 
  8004201429:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420142d:	48 29 c2             	sub    %rax,%rdx
  8004201430:	48 b8 10 20 72 04 80 	movabs $0x8004722010,%rax
  8004201437:	00 00 00 
  800420143a:	48 83 e8 01          	sub    $0x1,%rax
  800420143e:	48 01 d0             	add    %rdx,%rax
  8004201441:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004201445:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201449:	ba 00 00 00 00       	mov    $0x0,%edx
  800420144e:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004201452:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201456:	48 29 d0             	sub    %rdx,%rax
	cprintf("  _start                  %08x (phys)\n", _start);
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
	cprintf("Kernel executable memory footprint: %dKB\n",
  8004201459:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  8004201460:	48 85 c0             	test   %rax,%rax
  8004201463:	48 0f 48 c2          	cmovs  %rdx,%rax
  8004201467:	48 c1 f8 0a          	sar    $0xa,%rax
  800420146b:	48 89 c6             	mov    %rax,%rsi
  800420146e:	48 bf 58 f2 21 04 80 	movabs $0x800421f258,%rdi
  8004201475:	00 00 00 
  8004201478:	b8 00 00 00 00       	mov    $0x0,%eax
  800420147d:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004201484:	00 00 00 
  8004201487:	ff d2                	callq  *%rdx
		ROUNDUP(end - entry, 1024) / 1024);
	return 0;
  8004201489:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420148e:	c9                   	leaveq 
  800420148f:	c3                   	retq   

0000008004201490 <mon_backtrace>:

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
  8004201490:	55                   	push   %rbp
  8004201491:	48 89 e5             	mov    %rsp,%rbp
  8004201494:	48 81 ec 50 05 00 00 	sub    $0x550,%rsp
  800420149b:	89 bd cc fa ff ff    	mov    %edi,-0x534(%rbp)
  80042014a1:	48 89 b5 c0 fa ff ff 	mov    %rsi,-0x540(%rbp)
  80042014a8:	48 89 95 b8 fa ff ff 	mov    %rdx,-0x548(%rbp)

static __inline uint64_t
read_rbp(void)
{
	uint64_t rbp;
	__asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  80042014af:	48 89 e8             	mov    %rbp,%rax
  80042014b2:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	return rbp;
  80042014b6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
	uint64_t rip;
	uint64_t rsp;
	uint64_t offset;
	struct Ripdebuginfo info;

	rbp = (const uint64_t*)read_rbp();
  80042014ba:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

static __inline uint64_t
read_rsp(void)
{
	uint64_t esp;
	__asm __volatile("movq %%rsp,%0" : "=r" (esp));
  80042014be:	48 89 e0             	mov    %rsp,%rax
  80042014c1:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	return esp;
  80042014c5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
	rsp = read_rsp();
  80042014c9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	if (tf) {
  80042014cd:	48 83 bd b8 fa ff ff 	cmpq   $0x0,-0x548(%rbp)
  80042014d4:	00 
  80042014d5:	74 21                	je     80042014f8 <mon_backtrace+0x68>
		rbp = (const uint64_t*)tf->tf_regs.reg_rbp;
  80042014d7:	48 8b 85 b8 fa ff ff 	mov    -0x548(%rbp),%rax
  80042014de:	48 8b 40 50          	mov    0x50(%rax),%rax
  80042014e2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		rsp = tf->tf_rsp;
  80042014e6:	48 8b 85 b8 fa ff ff 	mov    -0x548(%rbp),%rax
  80042014ed:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  80042014f4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	read_rip(rip);
  80042014f8:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 80042014ff <mon_backtrace+0x6f>
  80042014ff:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cprintf("Stack backtrace:\n");
  8004201503:	48 bf 82 f2 21 04 80 	movabs $0x800421f282,%rdi
  800420150a:	00 00 00 
  800420150d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201512:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004201519:	00 00 00 
  800420151c:	ff d2                	callq  *%rdx
	while (rbp) {
  800420151e:	e9 15 03 00 00       	jmpq   8004201838 <mon_backtrace+0x3a8>
		// print this stack frame
		cprintf("  rbp %016llx  rip %016llx\n", rbp, rip);
  8004201523:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201527:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420152b:	48 89 c6             	mov    %rax,%rsi
  800420152e:	48 bf 94 f2 21 04 80 	movabs $0x800421f294,%rdi
  8004201535:	00 00 00 
  8004201538:	b8 00 00 00 00       	mov    $0x0,%eax
  800420153d:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  8004201544:	00 00 00 
  8004201547:	ff d1                	callq  *%rcx
		if (debuginfo_rip(rip, &info) >= 0){
  8004201549:	48 8d 95 d0 fa ff ff 	lea    -0x530(%rbp),%rdx
  8004201550:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201554:	48 89 d6             	mov    %rdx,%rsi
  8004201557:	48 89 c7             	mov    %rax,%rdi
  800420155a:	48 b8 54 fe 20 04 80 	movabs $0x800420fe54,%rax
  8004201561:	00 00 00 
  8004201564:	ff d0                	callq  *%rax
  8004201566:	85 c0                	test   %eax,%eax
  8004201568:	0f 88 98 02 00 00    	js     8004201806 <mon_backtrace+0x376>
			Dwarf_Regtable_Entry *cfa_rule = &info.reg_table.cfa_rule;
  800420156e:	48 8d 85 d0 fa ff ff 	lea    -0x530(%rbp),%rax
  8004201575:	48 05 a8 00 00 00    	add    $0xa8,%rax
  800420157b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
			uint64_t cfa;

			cprintf("       %s:%d: %.*s+%016llx", info.rip_file, info.rip_line, 
				info.rip_fn_namelen, info.rip_fn_name, rip - info.rip_fn_addr);
  800420157f:	48 8b 85 f0 fa ff ff 	mov    -0x510(%rbp),%rax
		cprintf("  rbp %016llx  rip %016llx\n", rbp, rip);
		if (debuginfo_rip(rip, &info) >= 0){
			Dwarf_Regtable_Entry *cfa_rule = &info.reg_table.cfa_rule;
			uint64_t cfa;

			cprintf("       %s:%d: %.*s+%016llx", info.rip_file, info.rip_line, 
  8004201586:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420158a:	48 89 d7             	mov    %rdx,%rdi
  800420158d:	48 29 c7             	sub    %rax,%rdi
  8004201590:	48 8b b5 e0 fa ff ff 	mov    -0x520(%rbp),%rsi
  8004201597:	8b 8d e8 fa ff ff    	mov    -0x518(%rbp),%ecx
  800420159d:	8b 95 d8 fa ff ff    	mov    -0x528(%rbp),%edx
  80042015a3:	48 8b 85 d0 fa ff ff 	mov    -0x530(%rbp),%rax
  80042015aa:	49 89 f9             	mov    %rdi,%r9
  80042015ad:	49 89 f0             	mov    %rsi,%r8
  80042015b0:	48 89 c6             	mov    %rax,%rsi
  80042015b3:	48 bf b0 f2 21 04 80 	movabs $0x800421f2b0,%rdi
  80042015ba:	00 00 00 
  80042015bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015c2:	49 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%r10
  80042015c9:	00 00 00 
  80042015cc:	41 ff d2             	callq  *%r10
				info.rip_fn_namelen, info.rip_fn_name, rip - info.rip_fn_addr);

			if (cfa_rule->dw_regnum == 6) { /* 6: rbp */
  80042015cf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042015d3:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80042015d7:	66 83 f8 06          	cmp    $0x6,%ax
  80042015db:	75 15                	jne    80042015f2 <mon_backtrace+0x162>
				cfa = (uint64_t)rbp + cfa_rule->dw_offset;
  80042015dd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042015e1:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042015e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042015e9:	48 01 d0             	add    %rdx,%rax
  80042015ec:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042015f0:	eb 25                	jmp    8004201617 <mon_backtrace+0x187>
			} else if (cfa_rule->dw_regnum == 7) { /* 7: rsp */
  80042015f2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042015f6:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80042015fa:	66 83 f8 07          	cmp    $0x7,%ax
  80042015fe:	0f 85 01 02 00 00    	jne    8004201805 <mon_backtrace+0x375>
				cfa = rsp + cfa_rule->dw_offset;
  8004201604:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201608:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420160c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201610:	48 01 d0             	add    %rdx,%rax
  8004201613:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
			} else {
				goto unknown_cfa;
			}

			cprintf("  args:%d ", info.rip_fn_narg);
  8004201617:	8b 85 f8 fa ff ff    	mov    -0x508(%rbp),%eax
  800420161d:	89 c6                	mov    %eax,%esi
  800420161f:	48 bf cb f2 21 04 80 	movabs $0x800421f2cb,%rdi
  8004201626:	00 00 00 
  8004201629:	b8 00 00 00 00       	mov    $0x0,%eax
  800420162e:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004201635:	00 00 00 
  8004201638:	ff d2                	callq  *%rdx
			for (i = 0; i < info.rip_fn_narg ; i++)
  800420163a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004201641:	e9 f2 00 00 00       	jmpq   8004201738 <mon_backtrace+0x2a8>
			{
				uint64_t val;
				assert(info.offset_fn_arg[i]);
  8004201646:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201649:	48 98                	cltq   
  800420164b:	48 83 c0 0a          	add    $0xa,%rax
  800420164f:	48 8b 84 c5 d8 fa ff 	mov    -0x528(%rbp,%rax,8),%rax
  8004201656:	ff 
  8004201657:	48 85 c0             	test   %rax,%rax
  800420165a:	75 35                	jne    8004201691 <mon_backtrace+0x201>
  800420165c:	48 b9 d6 f2 21 04 80 	movabs $0x800421f2d6,%rcx
  8004201663:	00 00 00 
  8004201666:	48 ba ec f2 21 04 80 	movabs $0x800421f2ec,%rdx
  800420166d:	00 00 00 
  8004201670:	be 77 00 00 00       	mov    $0x77,%esi
  8004201675:	48 bf 01 f3 21 04 80 	movabs $0x800421f301,%rdi
  800420167c:	00 00 00 
  800420167f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201684:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420168b:	00 00 00 
  800420168e:	41 ff d0             	callq  *%r8
				offset = cfa + info.offset_fn_arg[i];
  8004201691:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201694:	48 98                	cltq   
  8004201696:	48 83 c0 0a          	add    $0xa,%rax
  800420169a:	48 8b 94 c5 d8 fa ff 	mov    -0x528(%rbp,%rax,8),%rdx
  80042016a1:	ff 
  80042016a2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042016a6:	48 01 d0             	add    %rdx,%rax
  80042016a9:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
				switch(info.size_fn_arg[i]) {
  80042016ad:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042016b0:	48 98                	cltq   
  80042016b2:	48 83 c0 08          	add    $0x8,%rax
  80042016b6:	8b 84 85 dc fa ff ff 	mov    -0x524(%rbp,%rax,4),%eax
  80042016bd:	83 f8 02             	cmp    $0x2,%eax
  80042016c0:	74 31                	je     80042016f3 <mon_backtrace+0x263>
  80042016c2:	83 f8 02             	cmp    $0x2,%eax
  80042016c5:	7f 07                	jg     80042016ce <mon_backtrace+0x23e>
  80042016c7:	83 f8 01             	cmp    $0x1,%eax
  80042016ca:	74 37                	je     8004201703 <mon_backtrace+0x273>
  80042016cc:	eb 44                	jmp    8004201712 <mon_backtrace+0x282>
  80042016ce:	83 f8 04             	cmp    $0x4,%eax
  80042016d1:	74 12                	je     80042016e5 <mon_backtrace+0x255>
  80042016d3:	83 f8 08             	cmp    $0x8,%eax
  80042016d6:	75 3a                	jne    8004201712 <mon_backtrace+0x282>
					case 8:
						val = *(uint64_t *) offset;
  80042016d8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042016dc:	48 8b 00             	mov    (%rax),%rax
  80042016df:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
						break;
  80042016e3:	eb 2d                	jmp    8004201712 <mon_backtrace+0x282>
					case 4:
						val = *(uint32_t *) offset;
  80042016e5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042016e9:	8b 00                	mov    (%rax),%eax
  80042016eb:	89 c0                	mov    %eax,%eax
  80042016ed:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
						break;
  80042016f1:	eb 1f                	jmp    8004201712 <mon_backtrace+0x282>
					case 2:
						val = *(uint16_t *) offset;
  80042016f3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042016f7:	0f b7 00             	movzwl (%rax),%eax
  80042016fa:	0f b7 c0             	movzwl %ax,%eax
  80042016fd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
						break;
  8004201701:	eb 0f                	jmp    8004201712 <mon_backtrace+0x282>
					case 1:
						val = *(uint8_t *) offset;
  8004201703:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004201707:	0f b6 00             	movzbl (%rax),%eax
  800420170a:	0f b6 c0             	movzbl %al,%eax
  800420170d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
						break;
  8004201711:	90                   	nop
				}
				cprintf(" %016x", val);
  8004201712:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201716:	48 89 c6             	mov    %rax,%rsi
  8004201719:	48 bf 10 f3 21 04 80 	movabs $0x800421f310,%rdi
  8004201720:	00 00 00 
  8004201723:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201728:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420172f:	00 00 00 
  8004201732:	ff d2                	callq  *%rdx
			} else {
				goto unknown_cfa;
			}

			cprintf("  args:%d ", info.rip_fn_narg);
			for (i = 0; i < info.rip_fn_narg ; i++)
  8004201734:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004201738:	8b 85 f8 fa ff ff    	mov    -0x508(%rbp),%eax
  800420173e:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004201741:	0f 8f ff fe ff ff    	jg     8004201646 <mon_backtrace+0x1b6>
						break;
				}
				cprintf(" %016x", val);
			}

			switch(info.reg_table.rules[6].dw_regnum) { /* 6: rbp */
  8004201747:	0f b7 85 ea fb ff ff 	movzwl -0x416(%rbp),%eax
  800420174e:	0f b7 c0             	movzwl %ax,%eax
  8004201751:	3d 0b 04 00 00       	cmp    $0x40b,%eax
  8004201756:	74 48                	je     80042017a0 <mon_backtrace+0x310>
  8004201758:	3d 9c 05 00 00       	cmp    $0x59c,%eax
  800420175d:	75 17                	jne    8004201776 <mon_backtrace+0x2e6>
				case DW_FRAME_SAME_VAL:
					break;
				case DW_FRAME_CFA_COL3:
					rbp = (const uint64_t *)*(uint64_t *)(cfa + info.reg_table.rules[6].dw_offset);
  800420175f:	48 8b 95 f0 fb ff ff 	mov    -0x410(%rbp),%rdx
  8004201766:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420176a:	48 01 d0             	add    %rdx,%rax
  800420176d:	48 8b 00             	mov    (%rax),%rax
  8004201770:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
					break;
  8004201774:	eb 2b                	jmp    80042017a1 <mon_backtrace+0x311>
				default:
					panic("unknown reg rule");
  8004201776:	48 ba 17 f3 21 04 80 	movabs $0x800421f317,%rdx
  800420177d:	00 00 00 
  8004201780:	be 91 00 00 00       	mov    $0x91,%esi
  8004201785:	48 bf 01 f3 21 04 80 	movabs $0x800421f301,%rdi
  800420178c:	00 00 00 
  800420178f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201794:	48 b9 d3 04 20 04 80 	movabs $0x80042004d3,%rcx
  800420179b:	00 00 00 
  800420179e:	ff d1                	callq  *%rcx
				cprintf(" %016x", val);
			}

			switch(info.reg_table.rules[6].dw_regnum) { /* 6: rbp */
				case DW_FRAME_SAME_VAL:
					break;
  80042017a0:	90                   	nop
				default:
					panic("unknown reg rule");
					break;
			}

			switch(info.reg_table.rules[16].dw_regnum) { /* 16: rip */
  80042017a1:	0f b7 85 8a fc ff ff 	movzwl -0x376(%rbp),%eax
  80042017a8:	0f b7 c0             	movzwl %ax,%eax
  80042017ab:	3d 0b 04 00 00       	cmp    $0x40b,%eax
  80042017b0:	74 48                	je     80042017fa <mon_backtrace+0x36a>
  80042017b2:	3d 9c 05 00 00       	cmp    $0x59c,%eax
  80042017b7:	75 17                	jne    80042017d0 <mon_backtrace+0x340>
				case DW_FRAME_SAME_VAL:
					break;
				case DW_FRAME_CFA_COL3:
					rip = *(uint64_t *)(cfa + info.reg_table.rules[16].dw_offset);
  80042017b9:	48 8b 95 90 fc ff ff 	mov    -0x370(%rbp),%rdx
  80042017c0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042017c4:	48 01 d0             	add    %rdx,%rax
  80042017c7:	48 8b 00             	mov    (%rax),%rax
  80042017ca:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					break;
  80042017ce:	eb 2b                	jmp    80042017fb <mon_backtrace+0x36b>
				default:
					panic("unknown reg rule");
  80042017d0:	48 ba 17 f3 21 04 80 	movabs $0x800421f317,%rdx
  80042017d7:	00 00 00 
  80042017da:	be 9c 00 00 00       	mov    $0x9c,%esi
  80042017df:	48 bf 01 f3 21 04 80 	movabs $0x800421f301,%rdi
  80042017e6:	00 00 00 
  80042017e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042017ee:	48 b9 d3 04 20 04 80 	movabs $0x80042004d3,%rcx
  80042017f5:	00 00 00 
  80042017f8:	ff d1                	callq  *%rcx
					break;
			}

			switch(info.reg_table.rules[16].dw_regnum) { /* 16: rip */
				case DW_FRAME_SAME_VAL:
					break;
  80042017fa:	90                   	nop
				default:
					panic("unknown reg rule");
					break;
			}

			rsp = cfa;
  80042017fb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042017ff:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004201803:	eb 18                	jmp    800420181d <mon_backtrace+0x38d>
			if (cfa_rule->dw_regnum == 6) { /* 6: rbp */
				cfa = (uint64_t)rbp + cfa_rule->dw_offset;
			} else if (cfa_rule->dw_regnum == 7) { /* 7: rsp */
				cfa = rsp + cfa_rule->dw_offset;
			} else {
				goto unknown_cfa;
  8004201805:	90                   	nop

			rsp = cfa;
		} else {
unknown_cfa:
			// move to next lower stack frame
			rip = rbp[1];
  8004201806:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420180a:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420180e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			rbp = (const uint64_t*) rbp[0];
  8004201812:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201816:	48 8b 00             	mov    (%rax),%rax
  8004201819:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		}
		cprintf("\n");
  800420181d:	48 bf 28 f3 21 04 80 	movabs $0x800421f328,%rdi
  8004201824:	00 00 00 
  8004201827:	b8 00 00 00 00       	mov    $0x0,%eax
  800420182c:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004201833:	00 00 00 
  8004201836:	ff d2                	callq  *%rdx
	}

	read_rip(rip);

	cprintf("Stack backtrace:\n");
	while (rbp) {
  8004201838:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420183d:	0f 85 e0 fc ff ff    	jne    8004201523 <mon_backtrace+0x93>
			rbp = (const uint64_t*) rbp[0];
		}
		cprintf("\n");
	}

	return 0;
  8004201843:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201848:	c9                   	leaveq 
  8004201849:	c3                   	retq   

000000800420184a <mon_exit>:


int
mon_exit(int argc, char** argv, struct Trapframe* tf)
{
  800420184a:	55                   	push   %rbp
  800420184b:	48 89 e5             	mov    %rsp,%rbp
  800420184e:	48 83 ec 18          	sub    $0x18,%rsp
  8004201852:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004201855:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004201859:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
#ifdef VMM_GUEST
	asm("hlt");
#endif
	return -1;
  800420185d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8004201862:	c9                   	leaveq 
  8004201863:	c3                   	retq   

0000008004201864 <runcmd>:
#define WHITESPACE "\t\r\n "
#define MAXARGS 16

static int
runcmd(char *buf, struct Trapframe *tf)
{
  8004201864:	55                   	push   %rbp
  8004201865:	48 89 e5             	mov    %rsp,%rbp
  8004201868:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  800420186f:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004201876:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
	int argc;
	char *argv[MAXARGS];
	int i;

	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
  800420187d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	argv[argc] = 0;
  8004201884:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201887:	48 98                	cltq   
  8004201889:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  8004201890:	ff 00 00 00 00 
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201895:	eb 15                	jmp    80042018ac <runcmd+0x48>
			*buf++ = 0;
  8004201897:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420189e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042018a2:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
  80042018a9:	c6 00 00             	movb   $0x0,(%rax)
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  80042018ac:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042018b3:	0f b6 00             	movzbl (%rax),%eax
  80042018b6:	84 c0                	test   %al,%al
  80042018b8:	74 2a                	je     80042018e4 <runcmd+0x80>
  80042018ba:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042018c1:	0f b6 00             	movzbl (%rax),%eax
  80042018c4:	0f be c0             	movsbl %al,%eax
  80042018c7:	89 c6                	mov    %eax,%esi
  80042018c9:	48 bf 2a f3 21 04 80 	movabs $0x800421f32a,%rdi
  80042018d0:	00 00 00 
  80042018d3:	48 b8 45 11 21 04 80 	movabs $0x8004211145,%rax
  80042018da:	00 00 00 
  80042018dd:	ff d0                	callq  *%rax
  80042018df:	48 85 c0             	test   %rax,%rax
  80042018e2:	75 b3                	jne    8004201897 <runcmd+0x33>
			*buf++ = 0;
		if (*buf == 0)
  80042018e4:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042018eb:	0f b6 00             	movzbl (%rax),%eax
  80042018ee:	84 c0                	test   %al,%al
  80042018f0:	0f 84 95 00 00 00    	je     800420198b <runcmd+0x127>
			break;

		// save and scan past next arg
		if (argc == MAXARGS-1) {
  80042018f6:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  80042018fa:	75 2a                	jne    8004201926 <runcmd+0xc2>
			cprintf("Too many arguments (max %d)\n", MAXARGS);
  80042018fc:	be 10 00 00 00       	mov    $0x10,%esi
  8004201901:	48 bf 2f f3 21 04 80 	movabs $0x800421f32f,%rdi
  8004201908:	00 00 00 
  800420190b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201910:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004201917:	00 00 00 
  800420191a:	ff d2                	callq  *%rdx
			return 0;
  800420191c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201921:	e9 4b 01 00 00       	jmpq   8004201a71 <runcmd+0x20d>
		}
		argv[argc++] = buf;
  8004201926:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201929:	8d 50 01             	lea    0x1(%rax),%edx
  800420192c:	89 55 fc             	mov    %edx,-0x4(%rbp)
  800420192f:	48 98                	cltq   
  8004201931:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004201938:	48 89 94 c5 70 ff ff 	mov    %rdx,-0x90(%rbp,%rax,8)
  800420193f:	ff 
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201940:	eb 08                	jmp    800420194a <runcmd+0xe6>
			buf++;
  8004201942:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  8004201949:	01 
		if (argc == MAXARGS-1) {
			cprintf("Too many arguments (max %d)\n", MAXARGS);
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
  800420194a:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201951:	0f b6 00             	movzbl (%rax),%eax
  8004201954:	84 c0                	test   %al,%al
  8004201956:	0f 84 39 ff ff ff    	je     8004201895 <runcmd+0x31>
  800420195c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201963:	0f b6 00             	movzbl (%rax),%eax
  8004201966:	0f be c0             	movsbl %al,%eax
  8004201969:	89 c6                	mov    %eax,%esi
  800420196b:	48 bf 2a f3 21 04 80 	movabs $0x800421f32a,%rdi
  8004201972:	00 00 00 
  8004201975:	48 b8 45 11 21 04 80 	movabs $0x8004211145,%rax
  800420197c:	00 00 00 
  800420197f:	ff d0                	callq  *%rax
  8004201981:	48 85 c0             	test   %rax,%rax
  8004201984:	74 bc                	je     8004201942 <runcmd+0xde>
			buf++;
	}
  8004201986:	e9 0a ff ff ff       	jmpq   8004201895 <runcmd+0x31>
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
			*buf++ = 0;
		if (*buf == 0)
			break;
  800420198b:	90                   	nop
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
	argv[argc] = 0;
  800420198c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420198f:	48 98                	cltq   
  8004201991:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  8004201998:	ff 00 00 00 00 

	// Lookup and invoke the command
	if (argc == 0)
  800420199d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042019a1:	75 0a                	jne    80042019ad <runcmd+0x149>
		return 0;
  80042019a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042019a8:	e9 c4 00 00 00       	jmpq   8004201a71 <runcmd+0x20d>
	for (i = 0; i < NCOMMANDS; i++) {
  80042019ad:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  80042019b4:	e9 82 00 00 00       	jmpq   8004201a3b <runcmd+0x1d7>
		if (strcmp(argv[0], commands[i].name) == 0)
  80042019b9:	48 b9 80 65 23 04 80 	movabs $0x8004236580,%rcx
  80042019c0:	00 00 00 
  80042019c3:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042019c6:	48 63 d0             	movslq %eax,%rdx
  80042019c9:	48 89 d0             	mov    %rdx,%rax
  80042019cc:	48 01 c0             	add    %rax,%rax
  80042019cf:	48 01 d0             	add    %rdx,%rax
  80042019d2:	48 c1 e0 03          	shl    $0x3,%rax
  80042019d6:	48 01 c8             	add    %rcx,%rax
  80042019d9:	48 8b 10             	mov    (%rax),%rdx
  80042019dc:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042019e3:	48 89 d6             	mov    %rdx,%rsi
  80042019e6:	48 89 c7             	mov    %rax,%rdi
  80042019e9:	48 b8 81 10 21 04 80 	movabs $0x8004211081,%rax
  80042019f0:	00 00 00 
  80042019f3:	ff d0                	callq  *%rax
  80042019f5:	85 c0                	test   %eax,%eax
  80042019f7:	75 3e                	jne    8004201a37 <runcmd+0x1d3>
			return commands[i].func(argc, argv, tf);
  80042019f9:	48 b9 80 65 23 04 80 	movabs $0x8004236580,%rcx
  8004201a00:	00 00 00 
  8004201a03:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201a06:	48 63 d0             	movslq %eax,%rdx
  8004201a09:	48 89 d0             	mov    %rdx,%rax
  8004201a0c:	48 01 c0             	add    %rax,%rax
  8004201a0f:	48 01 d0             	add    %rdx,%rax
  8004201a12:	48 c1 e0 03          	shl    $0x3,%rax
  8004201a16:	48 01 c8             	add    %rcx,%rax
  8004201a19:	48 83 c0 10          	add    $0x10,%rax
  8004201a1d:	48 8b 00             	mov    (%rax),%rax
  8004201a20:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004201a27:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
  8004201a2e:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004201a31:	89 cf                	mov    %ecx,%edi
  8004201a33:	ff d0                	callq  *%rax
  8004201a35:	eb 3a                	jmp    8004201a71 <runcmd+0x20d>
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
	for (i = 0; i < NCOMMANDS; i++) {
  8004201a37:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004201a3b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201a3e:	83 f8 03             	cmp    $0x3,%eax
  8004201a41:	0f 86 72 ff ff ff    	jbe    80042019b9 <runcmd+0x155>
		if (strcmp(argv[0], commands[i].name) == 0)
			return commands[i].func(argc, argv, tf);
	}
	cprintf("Unknown command '%s'\n", argv[0]);
  8004201a47:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201a4e:	48 89 c6             	mov    %rax,%rsi
  8004201a51:	48 bf 4c f3 21 04 80 	movabs $0x800421f34c,%rdi
  8004201a58:	00 00 00 
  8004201a5b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a60:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004201a67:	00 00 00 
  8004201a6a:	ff d2                	callq  *%rdx
	return 0;
  8004201a6c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201a71:	c9                   	leaveq 
  8004201a72:	c3                   	retq   

0000008004201a73 <monitor>:

void
monitor(struct Trapframe *tf)
{
  8004201a73:	55                   	push   %rbp
  8004201a74:	48 89 e5             	mov    %rsp,%rbp
  8004201a77:	48 83 ec 20          	sub    $0x20,%rsp
  8004201a7b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char *buf;

	cprintf("Welcome to the JOS kernel monitor!\n");
  8004201a7f:	48 bf 68 f3 21 04 80 	movabs $0x800421f368,%rdi
  8004201a86:	00 00 00 
  8004201a89:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a8e:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004201a95:	00 00 00 
  8004201a98:	ff d2                	callq  *%rdx
	cprintf("Type 'help' for a list of commands.\n");
  8004201a9a:	48 bf 90 f3 21 04 80 	movabs $0x800421f390,%rdi
  8004201aa1:	00 00 00 
  8004201aa4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201aa9:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004201ab0:	00 00 00 
  8004201ab3:	ff d2                	callq  *%rdx


	if (tf != NULL)
  8004201ab5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201aba:	74 13                	je     8004201acf <monitor+0x5c>
		print_trapframe(tf);
  8004201abc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201ac0:	48 89 c7             	mov    %rax,%rdi
  8004201ac3:	48 b8 f7 c9 20 04 80 	movabs $0x800420c9f7,%rax
  8004201aca:	00 00 00 
  8004201acd:	ff d0                	callq  *%rax


	while (1) {
		buf = readline("K> ");
  8004201acf:	48 bf b5 f3 21 04 80 	movabs $0x800421f3b5,%rdi
  8004201ad6:	00 00 00 
  8004201ad9:	48 b8 5a 0d 21 04 80 	movabs $0x8004210d5a,%rax
  8004201ae0:	00 00 00 
  8004201ae3:	ff d0                	callq  *%rax
  8004201ae5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (buf != NULL)
  8004201ae9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004201aee:	74 df                	je     8004201acf <monitor+0x5c>
			if (runcmd(buf, tf) < 0)
  8004201af0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201af4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201af8:	48 89 d6             	mov    %rdx,%rsi
  8004201afb:	48 89 c7             	mov    %rax,%rdi
  8004201afe:	48 b8 64 18 20 04 80 	movabs $0x8004201864,%rax
  8004201b05:	00 00 00 
  8004201b08:	ff d0                	callq  *%rax
  8004201b0a:	85 c0                	test   %eax,%eax
  8004201b0c:	78 02                	js     8004201b10 <monitor+0x9d>
				break;
	}
  8004201b0e:	eb bf                	jmp    8004201acf <monitor+0x5c>

	while (1) {
		buf = readline("K> ");
		if (buf != NULL)
			if (runcmd(buf, tf) < 0)
				break;
  8004201b10:	90                   	nop
	}
}
  8004201b11:	90                   	nop
  8004201b12:	c9                   	leaveq 
  8004201b13:	c3                   	retq   

0000008004201b14 <page2ppn>:
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);


static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004201b14:	55                   	push   %rbp
  8004201b15:	48 89 e5             	mov    %rsp,%rbp
  8004201b18:	48 83 ec 08          	sub    $0x8,%rsp
  8004201b1c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004201b20:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201b24:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  8004201b2b:	00 00 00 
  8004201b2e:	48 8b 00             	mov    (%rax),%rax
  8004201b31:	48 29 c2             	sub    %rax,%rdx
  8004201b34:	48 89 d0             	mov    %rdx,%rax
  8004201b37:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004201b3b:	c9                   	leaveq 
  8004201b3c:	c3                   	retq   

0000008004201b3d <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004201b3d:	55                   	push   %rbp
  8004201b3e:	48 89 e5             	mov    %rsp,%rbp
  8004201b41:	48 83 ec 08          	sub    $0x8,%rsp
  8004201b45:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004201b49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201b4d:	48 89 c7             	mov    %rax,%rdi
  8004201b50:	48 b8 14 1b 20 04 80 	movabs $0x8004201b14,%rax
  8004201b57:	00 00 00 
  8004201b5a:	ff d0                	callq  *%rax
  8004201b5c:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004201b60:	c9                   	leaveq 
  8004201b61:	c3                   	retq   

0000008004201b62 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004201b62:	55                   	push   %rbp
  8004201b63:	48 89 e5             	mov    %rsp,%rbp
  8004201b66:	48 83 ec 10          	sub    $0x10,%rsp
  8004201b6a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004201b6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201b72:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201b76:	48 89 c2             	mov    %rax,%rdx
  8004201b79:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004201b80:	00 00 00 
  8004201b83:	48 8b 00             	mov    (%rax),%rax
  8004201b86:	48 39 c2             	cmp    %rax,%rdx
  8004201b89:	72 2a                	jb     8004201bb5 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004201b8b:	48 ba c0 f3 21 04 80 	movabs $0x800421f3c0,%rdx
  8004201b92:	00 00 00 
  8004201b95:	be 5a 00 00 00       	mov    $0x5a,%esi
  8004201b9a:	48 bf df f3 21 04 80 	movabs $0x800421f3df,%rdi
  8004201ba1:	00 00 00 
  8004201ba4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201ba9:	48 b9 d3 04 20 04 80 	movabs $0x80042004d3,%rcx
  8004201bb0:	00 00 00 
  8004201bb3:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004201bb5:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  8004201bbc:	00 00 00 
  8004201bbf:	48 8b 00             	mov    (%rax),%rax
  8004201bc2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201bc6:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004201bca:	48 c1 e2 04          	shl    $0x4,%rdx
  8004201bce:	48 01 d0             	add    %rdx,%rax
}
  8004201bd1:	c9                   	leaveq 
  8004201bd2:	c3                   	retq   

0000008004201bd3 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004201bd3:	55                   	push   %rbp
  8004201bd4:	48 89 e5             	mov    %rsp,%rbp
  8004201bd7:	48 83 ec 20          	sub    $0x20,%rsp
  8004201bdb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004201bdf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201be3:	48 89 c7             	mov    %rax,%rdi
  8004201be6:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  8004201bed:	00 00 00 
  8004201bf0:	ff d0                	callq  *%rax
  8004201bf2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004201bf6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201bfa:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201bfe:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004201c01:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004201c04:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004201c0b:	00 00 00 
  8004201c0e:	48 8b 00             	mov    (%rax),%rax
  8004201c11:	48 39 c2             	cmp    %rax,%rdx
  8004201c14:	72 32                	jb     8004201c48 <page2kva+0x75>
  8004201c16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c1a:	48 89 c1             	mov    %rax,%rcx
  8004201c1d:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  8004201c24:	00 00 00 
  8004201c27:	be 61 00 00 00       	mov    $0x61,%esi
  8004201c2c:	48 bf df f3 21 04 80 	movabs $0x800421f3df,%rdi
  8004201c33:	00 00 00 
  8004201c36:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c3b:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004201c42:	00 00 00 
  8004201c45:	41 ff d0             	callq  *%r8
  8004201c48:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004201c4f:	00 00 00 
  8004201c52:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c56:	48 01 d0             	add    %rdx,%rax
}
  8004201c59:	c9                   	leaveq 
  8004201c5a:	c3                   	retq   

0000008004201c5b <restrictive_type>:
   uint32_t length_low;
   uint32_t length_high;
   uint32_t type;
 } memory_map_t;

static __inline uint32_t restrictive_type(uint32_t t1, uint32_t t2) {
  8004201c5b:	55                   	push   %rbp
  8004201c5c:	48 89 e5             	mov    %rsp,%rbp
  8004201c5f:	48 83 ec 08          	sub    $0x8,%rsp
  8004201c63:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004201c66:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if(t1==MB_TYPE_BAD || t2==MB_TYPE_BAD)
  8004201c69:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  8004201c6d:	74 06                	je     8004201c75 <restrictive_type+0x1a>
  8004201c6f:	83 7d f8 05          	cmpl   $0x5,-0x8(%rbp)
  8004201c73:	75 07                	jne    8004201c7c <restrictive_type+0x21>
    return MB_TYPE_BAD;
  8004201c75:	b8 05 00 00 00       	mov    $0x5,%eax
  8004201c7a:	eb 3e                	jmp    8004201cba <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_NVS || t2==MB_TYPE_ACPI_NVS)
  8004201c7c:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004201c80:	74 06                	je     8004201c88 <restrictive_type+0x2d>
  8004201c82:	83 7d f8 04          	cmpl   $0x4,-0x8(%rbp)
  8004201c86:	75 07                	jne    8004201c8f <restrictive_type+0x34>
    return MB_TYPE_ACPI_NVS;
  8004201c88:	b8 04 00 00 00       	mov    $0x4,%eax
  8004201c8d:	eb 2b                	jmp    8004201cba <restrictive_type+0x5f>
  else if(t1==MB_TYPE_RESERVED || t2==MB_TYPE_RESERVED)
  8004201c8f:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  8004201c93:	74 06                	je     8004201c9b <restrictive_type+0x40>
  8004201c95:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  8004201c99:	75 07                	jne    8004201ca2 <restrictive_type+0x47>
    return MB_TYPE_RESERVED;
  8004201c9b:	b8 02 00 00 00       	mov    $0x2,%eax
  8004201ca0:	eb 18                	jmp    8004201cba <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_RECLM || t2==MB_TYPE_ACPI_RECLM)
  8004201ca2:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004201ca6:	74 06                	je     8004201cae <restrictive_type+0x53>
  8004201ca8:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
  8004201cac:	75 07                	jne    8004201cb5 <restrictive_type+0x5a>
    return MB_TYPE_ACPI_RECLM;
  8004201cae:	b8 03 00 00 00       	mov    $0x3,%eax
  8004201cb3:	eb 05                	jmp    8004201cba <restrictive_type+0x5f>

  return MB_TYPE_USABLE;
  8004201cb5:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004201cba:	c9                   	leaveq 
  8004201cbb:	c3                   	retq   

0000008004201cbc <nvram_read>:
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int
nvram_read(int r)
{
  8004201cbc:	55                   	push   %rbp
  8004201cbd:	48 89 e5             	mov    %rsp,%rbp
  8004201cc0:	53                   	push   %rbx
  8004201cc1:	48 83 ec 18          	sub    $0x18,%rsp
  8004201cc5:	89 7d ec             	mov    %edi,-0x14(%rbp)
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
  8004201cc8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201ccb:	89 c7                	mov    %eax,%edi
  8004201ccd:	48 b8 69 99 20 04 80 	movabs $0x8004209969,%rax
  8004201cd4:	00 00 00 
  8004201cd7:	ff d0                	callq  *%rax
  8004201cd9:	89 c3                	mov    %eax,%ebx
  8004201cdb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201cde:	83 c0 01             	add    $0x1,%eax
  8004201ce1:	89 c7                	mov    %eax,%edi
  8004201ce3:	48 b8 69 99 20 04 80 	movabs $0x8004209969,%rax
  8004201cea:	00 00 00 
  8004201ced:	ff d0                	callq  *%rax
  8004201cef:	c1 e0 08             	shl    $0x8,%eax
  8004201cf2:	09 d8                	or     %ebx,%eax
}
  8004201cf4:	48 83 c4 18          	add    $0x18,%rsp
  8004201cf8:	5b                   	pop    %rbx
  8004201cf9:	5d                   	pop    %rbp
  8004201cfa:	c3                   	retq   

0000008004201cfb <multiboot_read>:

static void
multiboot_read(multiboot_info_t* mbinfo, size_t* basemem, size_t* extmem) {
  8004201cfb:	55                   	push   %rbp
  8004201cfc:	48 89 e5             	mov    %rsp,%rbp
  8004201cff:	53                   	push   %rbx
  8004201d00:	48 81 ec b8 00 00 00 	sub    $0xb8,%rsp
  8004201d07:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
  8004201d0e:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  8004201d15:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  8004201d1c:	48 89 e0             	mov    %rsp,%rax
  8004201d1f:	48 89 c3             	mov    %rax,%rbx
	int i;

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
  8004201d22:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201d29:	8b 40 30             	mov    0x30(%rax),%eax
  8004201d2c:	89 c0                	mov    %eax,%eax
  8004201d2e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];
  8004201d32:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201d39:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201d3c:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201d41:	f7 e2                	mul    %edx
  8004201d43:	89 d0                	mov    %edx,%eax
  8004201d45:	c1 e8 04             	shr    $0x4,%eax
  8004201d48:	89 c0                	mov    %eax,%eax
  8004201d4a:	48 89 c2             	mov    %rax,%rdx
  8004201d4d:	48 83 ea 01          	sub    $0x1,%rdx
  8004201d51:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004201d55:	49 89 c2             	mov    %rax,%r10
  8004201d58:	41 bb 00 00 00 00    	mov    $0x0,%r11d
  8004201d5e:	49 89 c0             	mov    %rax,%r8
  8004201d61:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004201d67:	48 c1 e0 03          	shl    $0x3,%rax
  8004201d6b:	48 8d 50 07          	lea    0x7(%rax),%rdx
  8004201d6f:	b8 10 00 00 00       	mov    $0x10,%eax
  8004201d74:	48 83 e8 01          	sub    $0x1,%rax
  8004201d78:	48 01 d0             	add    %rdx,%rax
  8004201d7b:	be 10 00 00 00       	mov    $0x10,%esi
  8004201d80:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201d85:	48 f7 f6             	div    %rsi
  8004201d88:	48 6b c0 10          	imul   $0x10,%rax,%rax
  8004201d8c:	48 29 c4             	sub    %rax,%rsp
  8004201d8f:	48 89 e0             	mov    %rsp,%rax
  8004201d92:	48 83 c0 07          	add    $0x7,%rax
  8004201d96:	48 c1 e8 03          	shr    $0x3,%rax
  8004201d9a:	48 c1 e0 03          	shl    $0x3,%rax
  8004201d9e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	cprintf("\ne820 MEMORY MAP\n");
  8004201da2:	48 bf 13 f4 21 04 80 	movabs $0x800421f413,%rdi
  8004201da9:	00 00 00 
  8004201dac:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201db1:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004201db8:	00 00 00 
  8004201dbb:	ff d2                	callq  *%rdx
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201dbd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201dc4:	e9 6c 01 00 00       	jmpq   8004201f35 <multiboot_read+0x23a>
		memory_map_t* mmap = &mmap_base[i];
  8004201dc9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201dcc:	48 63 d0             	movslq %eax,%rdx
  8004201dcf:	48 89 d0             	mov    %rdx,%rax
  8004201dd2:	48 01 c0             	add    %rax,%rax
  8004201dd5:	48 01 d0             	add    %rdx,%rax
  8004201dd8:	48 c1 e0 03          	shl    $0x3,%rax
  8004201ddc:	48 89 c2             	mov    %rax,%rdx
  8004201ddf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201de3:	48 01 d0             	add    %rdx,%rax
  8004201de6:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
  8004201dea:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201dee:	8b 40 08             	mov    0x8(%rax),%eax
  8004201df1:	89 c0                	mov    %eax,%eax
  8004201df3:	48 c1 e0 20          	shl    $0x20,%rax
  8004201df7:	48 89 c2             	mov    %rax,%rdx
  8004201dfa:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201dfe:	8b 40 04             	mov    0x4(%rax),%eax
  8004201e01:	89 c0                	mov    %eax,%eax
  8004201e03:	48 01 d0             	add    %rdx,%rax
  8004201e06:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201e0a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201e0e:	8b 40 10             	mov    0x10(%rax),%eax
  8004201e11:	89 c0                	mov    %eax,%eax
  8004201e13:	48 c1 e0 20          	shl    $0x20,%rax
  8004201e17:	48 89 c2             	mov    %rax,%rdx
  8004201e1a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201e1e:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201e21:	89 c0                	mov    %eax,%eax
  8004201e23:	48 01 d0             	add    %rdx,%rax
  8004201e26:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        
		cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size, 
  8004201e2a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201e2e:	8b 70 14             	mov    0x14(%rax),%esi
  8004201e31:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201e35:	8b 00                	mov    (%rax),%eax
  8004201e37:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004201e3b:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004201e3f:	41 89 f0             	mov    %esi,%r8d
  8004201e42:	89 c6                	mov    %eax,%esi
  8004201e44:	48 bf 28 f4 21 04 80 	movabs $0x800421f428,%rdi
  8004201e4b:	00 00 00 
  8004201e4e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201e53:	49 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%r9
  8004201e5a:	00 00 00 
  8004201e5d:	41 ff d1             	callq  *%r9
			addr, len, mmap->type);

		if(mmap->type > 5 || mmap->type < 1)
  8004201e60:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201e64:	8b 40 14             	mov    0x14(%rax),%eax
  8004201e67:	83 f8 05             	cmp    $0x5,%eax
  8004201e6a:	77 0b                	ja     8004201e77 <multiboot_read+0x17c>
  8004201e6c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201e70:	8b 40 14             	mov    0x14(%rax),%eax
  8004201e73:	85 c0                	test   %eax,%eax
  8004201e75:	75 0b                	jne    8004201e82 <multiboot_read+0x187>
			mmap->type = MB_TYPE_RESERVED;
  8004201e77:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201e7b:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)
       
		//Insert into the sorted list
		int j = 0;
  8004201e82:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
		for(;j<i;j++) {
  8004201e89:	e9 85 00 00 00       	jmpq   8004201f13 <multiboot_read+0x218>
			memory_map_t* this = mmap_list[j];
  8004201e8e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201e92:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201e95:	48 63 d2             	movslq %edx,%rdx
  8004201e98:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201e9c:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201ea0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201ea4:	8b 40 08             	mov    0x8(%rax),%eax
  8004201ea7:	89 c0                	mov    %eax,%eax
  8004201ea9:	48 c1 e0 20          	shl    $0x20,%rax
  8004201ead:	48 89 c2             	mov    %rax,%rdx
  8004201eb0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201eb4:	8b 40 04             	mov    0x4(%rax),%eax
  8004201eb7:	89 c0                	mov    %eax,%eax
  8004201eb9:	48 01 d0             	add    %rdx,%rax
  8004201ebc:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			if(this_addr > addr) {
  8004201ec0:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201ec4:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004201ec8:	76 45                	jbe    8004201f0f <multiboot_read+0x214>
				int last = i+1;
  8004201eca:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201ecd:	83 c0 01             	add    $0x1,%eax
  8004201ed0:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				while(last != j) {
  8004201ed3:	eb 30                	jmp    8004201f05 <multiboot_read+0x20a>
					*(mmap_list + last) = *(mmap_list + last - 1);
  8004201ed5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201ed9:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004201edc:	48 63 d2             	movslq %edx,%rdx
  8004201edf:	48 c1 e2 03          	shl    $0x3,%rdx
  8004201ee3:	48 01 c2             	add    %rax,%rdx
  8004201ee6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201eea:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004201eed:	48 63 c9             	movslq %ecx,%rcx
  8004201ef0:	48 c1 e1 03          	shl    $0x3,%rcx
  8004201ef4:	48 83 e9 08          	sub    $0x8,%rcx
  8004201ef8:	48 01 c8             	add    %rcx,%rax
  8004201efb:	48 8b 00             	mov    (%rax),%rax
  8004201efe:	48 89 02             	mov    %rax,(%rdx)
					last--;
  8004201f01:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
		for(;j<i;j++) {
			memory_map_t* this = mmap_list[j];
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
			if(this_addr > addr) {
				int last = i+1;
				while(last != j) {
  8004201f05:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004201f08:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004201f0b:	75 c8                	jne    8004201ed5 <multiboot_read+0x1da>
					*(mmap_list + last) = *(mmap_list + last - 1);
					last--;
				}
				break; 
  8004201f0d:	eb 10                	jmp    8004201f1f <multiboot_read+0x224>
		if(mmap->type > 5 || mmap->type < 1)
			mmap->type = MB_TYPE_RESERVED;
       
		//Insert into the sorted list
		int j = 0;
		for(;j<i;j++) {
  8004201f0f:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  8004201f13:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004201f16:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004201f19:	0f 8c 6f ff ff ff    	jl     8004201e8e <multiboot_read+0x193>
					last--;
				}
				break; 
			}
		}
		mmap_list[j] = mmap;  
  8004201f1f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201f23:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201f26:	48 63 d2             	movslq %edx,%rdx
  8004201f29:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004201f2d:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];

	cprintf("\ne820 MEMORY MAP\n");
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201f31:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201f35:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201f38:	48 63 c8             	movslq %eax,%rcx
  8004201f3b:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201f42:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201f45:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201f4a:	f7 e2                	mul    %edx
  8004201f4c:	89 d0                	mov    %edx,%eax
  8004201f4e:	c1 e8 04             	shr    $0x4,%eax
  8004201f51:	89 c0                	mov    %eax,%eax
  8004201f53:	48 39 c1             	cmp    %rax,%rcx
  8004201f56:	0f 82 6d fe ff ff    	jb     8004201dc9 <multiboot_read+0xce>
				break; 
			}
		}
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
  8004201f5c:	48 bf 5f f4 21 04 80 	movabs $0x800421f45f,%rdi
  8004201f63:	00 00 00 
  8004201f66:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201f6b:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004201f72:	00 00 00 
  8004201f75:	ff d2                	callq  *%rdx
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201f77:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  8004201f7e:	e9 93 01 00 00       	jmpq   8004202116 <multiboot_read+0x41b>
		memory_map_t* prev = mmap_list[i-1];
  8004201f83:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201f86:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004201f89:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201f8d:	48 63 d2             	movslq %edx,%rdx
  8004201f90:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201f94:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		memory_map_t* this = mmap_list[i];
  8004201f98:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201f9c:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004201f9f:	48 63 d2             	movslq %edx,%rdx
  8004201fa2:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201fa6:	48 89 45 90          	mov    %rax,-0x70(%rbp)

		uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201faa:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201fae:	8b 40 08             	mov    0x8(%rax),%eax
  8004201fb1:	89 c0                	mov    %eax,%eax
  8004201fb3:	48 c1 e0 20          	shl    $0x20,%rax
  8004201fb7:	48 89 c2             	mov    %rax,%rdx
  8004201fba:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201fbe:	8b 40 04             	mov    0x4(%rax),%eax
  8004201fc1:	89 c0                	mov    %eax,%eax
  8004201fc3:	48 01 d0             	add    %rdx,%rax
  8004201fc6:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		uint64_t prev_addr = APPEND_HILO(prev->base_addr_high, prev->base_addr_low);
  8004201fca:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201fce:	8b 40 08             	mov    0x8(%rax),%eax
  8004201fd1:	89 c0                	mov    %eax,%eax
  8004201fd3:	48 c1 e0 20          	shl    $0x20,%rax
  8004201fd7:	48 89 c2             	mov    %rax,%rdx
  8004201fda:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201fde:	8b 40 04             	mov    0x4(%rax),%eax
  8004201fe1:	89 c0                	mov    %eax,%eax
  8004201fe3:	48 01 d0             	add    %rdx,%rax
  8004201fe6:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		uint64_t prev_length = APPEND_HILO(prev->length_high, prev->length_low);
  8004201fea:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201fee:	8b 40 10             	mov    0x10(%rax),%eax
  8004201ff1:	89 c0                	mov    %eax,%eax
  8004201ff3:	48 c1 e0 20          	shl    $0x20,%rax
  8004201ff7:	48 89 c2             	mov    %rax,%rdx
  8004201ffa:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201ffe:	8b 40 0c             	mov    0xc(%rax),%eax
  8004202001:	89 c0                	mov    %eax,%eax
  8004202003:	48 01 d0             	add    %rdx,%rax
  8004202006:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		uint64_t this_length = APPEND_HILO(this->length_high, this->length_low);
  800420200d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202011:	8b 40 10             	mov    0x10(%rax),%eax
  8004202014:	89 c0                	mov    %eax,%eax
  8004202016:	48 c1 e0 20          	shl    $0x20,%rax
  800420201a:	48 89 c2             	mov    %rax,%rdx
  800420201d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202021:	8b 40 0c             	mov    0xc(%rax),%eax
  8004202024:	89 c0                	mov    %eax,%eax
  8004202026:	48 01 d0             	add    %rdx,%rax
  8004202029:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)

		// Merge adjacent regions with same type
		if(prev_addr + prev_length == this_addr && prev->type == this->type) {
  8004202030:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004202034:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420203b:	48 01 d0             	add    %rdx,%rax
  800420203e:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004202042:	75 7c                	jne    80042020c0 <multiboot_read+0x3c5>
  8004202044:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202048:	8b 50 14             	mov    0x14(%rax),%edx
  800420204b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420204f:	8b 40 14             	mov    0x14(%rax),%eax
  8004202052:	39 c2                	cmp    %eax,%edx
  8004202054:	75 6a                	jne    80042020c0 <multiboot_read+0x3c5>
			this->length_low = (uint32_t)prev_length + this_length;
  8004202056:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420205d:	89 c2                	mov    %eax,%edx
  800420205f:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202066:	01 c2                	add    %eax,%edx
  8004202068:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420206c:	89 50 0c             	mov    %edx,0xc(%rax)
			this->length_high = (uint32_t)((prev_length + this_length)>>32);
  800420206f:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004202076:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420207d:	48 01 d0             	add    %rdx,%rax
  8004202080:	48 c1 e8 20          	shr    $0x20,%rax
  8004202084:	89 c2                	mov    %eax,%edx
  8004202086:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420208a:	89 50 10             	mov    %edx,0x10(%rax)
			this->base_addr_low = prev->base_addr_low;
  800420208d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202091:	8b 50 04             	mov    0x4(%rax),%edx
  8004202094:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202098:	89 50 04             	mov    %edx,0x4(%rax)
			this->base_addr_high = prev->base_addr_high;
  800420209b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420209f:	8b 50 08             	mov    0x8(%rax),%edx
  80042020a2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042020a6:	89 50 08             	mov    %edx,0x8(%rax)
			mmap_list[i-1] = NULL;
  80042020a9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042020ac:	8d 50 ff             	lea    -0x1(%rax),%edx
  80042020af:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042020b3:	48 63 d2             	movslq %edx,%rdx
  80042020b6:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  80042020bd:	00 
  80042020be:	eb 52                	jmp    8004202112 <multiboot_read+0x417>
		} else if(prev_addr + prev_length > this_addr) {
  80042020c0:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  80042020c4:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042020cb:	48 01 d0             	add    %rdx,%rax
  80042020ce:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  80042020d2:	76 3e                	jbe    8004202112 <multiboot_read+0x417>
			//Overlapping regions
			uint32_t type = restrictive_type(prev->type, this->type);
  80042020d4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042020d8:	8b 50 14             	mov    0x14(%rax),%edx
  80042020db:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020df:	8b 40 14             	mov    0x14(%rax),%eax
  80042020e2:	89 d6                	mov    %edx,%esi
  80042020e4:	89 c7                	mov    %eax,%edi
  80042020e6:	48 b8 5b 1c 20 04 80 	movabs $0x8004201c5b,%rax
  80042020ed:	00 00 00 
  80042020f0:	ff d0                	callq  *%rax
  80042020f2:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
			prev->type = type;
  80042020f8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020fc:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  8004202102:	89 50 14             	mov    %edx,0x14(%rax)
			this->type = type;
  8004202105:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202109:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  800420210f:	89 50 14             	mov    %edx,0x14(%rax)
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202112:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004202116:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202119:	48 63 c8             	movslq %eax,%rcx
  800420211c:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004202123:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004202126:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  800420212b:	f7 e2                	mul    %edx
  800420212d:	89 d0                	mov    %edx,%eax
  800420212f:	c1 e8 04             	shr    $0x4,%eax
  8004202132:	89 c0                	mov    %eax,%eax
  8004202134:	48 39 c1             	cmp    %rax,%rcx
  8004202137:	0f 82 46 fe ff ff    	jb     8004201f83 <multiboot_read+0x288>
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  800420213d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004202144:	e9 dc 00 00 00       	jmpq   8004202225 <multiboot_read+0x52a>
		memory_map_t* mmap = mmap_list[i];
  8004202149:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420214d:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004202150:	48 63 d2             	movslq %edx,%rdx
  8004202153:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202157:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
		if(mmap) {
  800420215e:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004202165:	00 
  8004202166:	0f 84 b5 00 00 00    	je     8004202221 <multiboot_read+0x526>
			if(mmap->type == MB_TYPE_USABLE || mmap->type == MB_TYPE_ACPI_RECLM) {
  800420216c:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202173:	8b 40 14             	mov    0x14(%rax),%eax
  8004202176:	83 f8 01             	cmp    $0x1,%eax
  8004202179:	74 13                	je     800420218e <multiboot_read+0x493>
  800420217b:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202182:	8b 40 14             	mov    0x14(%rax),%eax
  8004202185:	83 f8 03             	cmp    $0x3,%eax
  8004202188:	0f 85 93 00 00 00    	jne    8004202221 <multiboot_read+0x526>
				if(mmap->base_addr_low < 0x100000 && mmap->base_addr_high == 0)
  800420218e:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202195:	8b 40 04             	mov    0x4(%rax),%eax
  8004202198:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  800420219d:	77 49                	ja     80042021e8 <multiboot_read+0x4ed>
  800420219f:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042021a6:	8b 40 08             	mov    0x8(%rax),%eax
  80042021a9:	85 c0                	test   %eax,%eax
  80042021ab:	75 3b                	jne    80042021e8 <multiboot_read+0x4ed>
					*basemem += APPEND_HILO(mmap->length_high, mmap->length_low);
  80042021ad:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042021b4:	48 8b 10             	mov    (%rax),%rdx
  80042021b7:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042021be:	8b 40 10             	mov    0x10(%rax),%eax
  80042021c1:	89 c0                	mov    %eax,%eax
  80042021c3:	48 c1 e0 20          	shl    $0x20,%rax
  80042021c7:	48 89 c1             	mov    %rax,%rcx
  80042021ca:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042021d1:	8b 40 0c             	mov    0xc(%rax),%eax
  80042021d4:	89 c0                	mov    %eax,%eax
  80042021d6:	48 01 c8             	add    %rcx,%rax
  80042021d9:	48 01 c2             	add    %rax,%rdx
  80042021dc:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042021e3:	48 89 10             	mov    %rdx,(%rax)
  80042021e6:	eb 39                	jmp    8004202221 <multiboot_read+0x526>
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
  80042021e8:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042021ef:	48 8b 10             	mov    (%rax),%rdx
  80042021f2:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042021f9:	8b 40 10             	mov    0x10(%rax),%eax
  80042021fc:	89 c0                	mov    %eax,%eax
  80042021fe:	48 c1 e0 20          	shl    $0x20,%rax
  8004202202:	48 89 c1             	mov    %rax,%rcx
  8004202205:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420220c:	8b 40 0c             	mov    0xc(%rax),%eax
  800420220f:	89 c0                	mov    %eax,%eax
  8004202211:	48 01 c8             	add    %rcx,%rax
  8004202214:	48 01 c2             	add    %rax,%rdx
  8004202217:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420221e:	48 89 10             	mov    %rdx,(%rax)
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202221:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004202225:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202228:	48 63 c8             	movslq %eax,%rcx
  800420222b:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004202232:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004202235:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  800420223a:	f7 e2                	mul    %edx
  800420223c:	89 d0                	mov    %edx,%eax
  800420223e:	c1 e8 04             	shr    $0x4,%eax
  8004202241:	89 c0                	mov    %eax,%eax
  8004202243:	48 39 c1             	cmp    %rax,%rcx
  8004202246:	0f 82 fd fe ff ff    	jb     8004202149 <multiboot_read+0x44e>
  800420224c:	48 89 dc             	mov    %rbx,%rsp
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
			}
		}
	}
}
  800420224f:	90                   	nop
  8004202250:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8004202254:	c9                   	leaveq 
  8004202255:	c3                   	retq   

0000008004202256 <i386_detect_memory>:

static void
i386_detect_memory(void)
{
  8004202256:	55                   	push   %rbp
  8004202257:	48 89 e5             	mov    %rsp,%rbp
  800420225a:	48 83 ec 50          	sub    $0x50,%rsp
	size_t npages_extmem;
	size_t basemem = 0;
  800420225e:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8004202265:	00 
	size_t extmem = 0;
  8004202266:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  800420226d:	00 

	// Check if the bootloader passed us a multiboot structure
	extern char multiboot_info[];
	uintptr_t* mbp = (uintptr_t*)multiboot_info;
  800420226e:	48 b8 00 70 10 00 00 	movabs $0x107000,%rax
  8004202275:	00 00 00 
  8004202278:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	multiboot_info_t * mbinfo = (multiboot_info_t*)*mbp;
  800420227c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202280:	48 8b 00             	mov    (%rax),%rax
  8004202283:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if(mbinfo && (mbinfo->flags & MB_FLAG_MMAP)) {
  8004202287:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420228c:	74 2d                	je     80042022bb <i386_detect_memory+0x65>
  800420228e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202292:	8b 00                	mov    (%rax),%eax
  8004202294:	83 e0 40             	and    $0x40,%eax
  8004202297:	85 c0                	test   %eax,%eax
  8004202299:	74 20                	je     80042022bb <i386_detect_memory+0x65>
		multiboot_read(mbinfo, &basemem, &extmem);
  800420229b:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  800420229f:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  80042022a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042022a7:	48 89 ce             	mov    %rcx,%rsi
  80042022aa:	48 89 c7             	mov    %rax,%rdi
  80042022ad:	48 b8 fb 1c 20 04 80 	movabs $0x8004201cfb,%rax
  80042022b4:	00 00 00 
  80042022b7:	ff d0                	callq  *%rax
  80042022b9:	eb 34                	jmp    80042022ef <i386_detect_memory+0x99>
	} else {
		basemem = (nvram_read(NVRAM_BASELO) * 1024);
  80042022bb:	bf 15 00 00 00       	mov    $0x15,%edi
  80042022c0:	48 b8 bc 1c 20 04 80 	movabs $0x8004201cbc,%rax
  80042022c7:	00 00 00 
  80042022ca:	ff d0                	callq  *%rax
  80042022cc:	c1 e0 0a             	shl    $0xa,%eax
  80042022cf:	48 98                	cltq   
  80042022d1:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		extmem = (nvram_read(NVRAM_EXTLO) * 1024);
  80042022d5:	bf 17 00 00 00       	mov    $0x17,%edi
  80042022da:	48 b8 bc 1c 20 04 80 	movabs $0x8004201cbc,%rax
  80042022e1:	00 00 00 
  80042022e4:	ff d0                	callq  *%rax
  80042022e6:	c1 e0 0a             	shl    $0xa,%eax
  80042022e9:	48 98                	cltq   
  80042022eb:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	}

	assert(basemem);
  80042022ef:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042022f3:	48 85 c0             	test   %rax,%rax
  80042022f6:	75 35                	jne    800420232d <i386_detect_memory+0xd7>
  80042022f8:	48 b9 61 f4 21 04 80 	movabs $0x800421f461,%rcx
  80042022ff:	00 00 00 
  8004202302:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004202309:	00 00 00 
  800420230c:	be 89 00 00 00       	mov    $0x89,%esi
  8004202311:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004202318:	00 00 00 
  800420231b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202320:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004202327:	00 00 00 
  800420232a:	41 ff d0             	callq  *%r8

	npages_basemem = basemem / PGSIZE;
  800420232d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202331:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202335:	48 89 c2             	mov    %rax,%rdx
  8004202338:	48 b8 30 02 4e 04 80 	movabs $0x80044e0230,%rax
  800420233f:	00 00 00 
  8004202342:	48 89 10             	mov    %rdx,(%rax)
	npages_extmem = extmem / PGSIZE;
  8004202345:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202349:	48 c1 e8 0c          	shr    $0xc,%rax
  800420234d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	
	if(nvram_read(NVRAM_EXTLO) == 0xffff) {
  8004202351:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202356:	48 b8 bc 1c 20 04 80 	movabs $0x8004201cbc,%rax
  800420235d:	00 00 00 
  8004202360:	ff d0                	callq  *%rax
  8004202362:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004202367:	75 2c                	jne    8004202395 <i386_detect_memory+0x13f>
		// EXTMEM > 16M in blocks of 64k
		size_t pextmem = nvram_read(NVRAM_EXTGT16LO) * (64 * 1024);
  8004202369:	bf 34 00 00 00       	mov    $0x34,%edi
  800420236e:	48 b8 bc 1c 20 04 80 	movabs $0x8004201cbc,%rax
  8004202375:	00 00 00 
  8004202378:	ff d0                	callq  *%rax
  800420237a:	c1 e0 10             	shl    $0x10,%eax
  800420237d:	48 98                	cltq   
  800420237f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		npages_extmem = ((16 * 1024 * 1024) + pextmem - (1 * 1024 * 1024)) / PGSIZE;
  8004202383:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202387:	48 05 00 00 f0 00    	add    $0xf00000,%rax
  800420238d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202391:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}
	
	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  8004202395:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420239a:	74 1a                	je     80042023b6 <i386_detect_memory+0x160>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  800420239c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042023a0:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  80042023a7:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  80042023ae:	00 00 00 
  80042023b1:	48 89 10             	mov    %rdx,(%rax)
  80042023b4:	eb 1a                	jmp    80042023d0 <i386_detect_memory+0x17a>
	else
		npages = npages_basemem;
  80042023b6:	48 b8 30 02 4e 04 80 	movabs $0x80044e0230,%rax
  80042023bd:	00 00 00 
  80042023c0:	48 8b 10             	mov    (%rax),%rdx
  80042023c3:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  80042023ca:	00 00 00 
  80042023cd:	48 89 10             	mov    %rdx,(%rax)

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042023d0:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  80042023d7:	00 00 00 
  80042023da:	48 8b 30             	mov    (%rax),%rsi
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
  80042023dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042023e1:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042023e5:	48 c1 e8 0a          	shr    $0xa,%rax
  80042023e9:	48 89 c1             	mov    %rax,%rcx
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
  80042023ec:	48 b8 30 02 4e 04 80 	movabs $0x80044e0230,%rax
  80042023f3:	00 00 00 
  80042023f6:	48 8b 00             	mov    (%rax),%rax
  80042023f9:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042023fd:	48 c1 e8 0a          	shr    $0xa,%rax
  8004202401:	48 89 c2             	mov    %rax,%rdx
		npages * PGSIZE / (1024 * 1024),
  8004202404:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  800420240b:	00 00 00 
  800420240e:	48 8b 00             	mov    (%rax),%rax
  8004202411:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202415:	48 c1 e8 14          	shr    $0x14,%rax
  8004202419:	49 89 f0             	mov    %rsi,%r8
  800420241c:	48 89 c6             	mov    %rax,%rsi
  800420241f:	48 bf 90 f4 21 04 80 	movabs $0x800421f490,%rdi
  8004202426:	00 00 00 
  8004202429:	b8 00 00 00 00       	mov    $0x0,%eax
  800420242e:	49 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%r9
  8004202435:	00 00 00 
  8004202438:	41 ff d1             	callq  *%r9
	//JOS 64 pages are limited by the size of both the UPAGES
	//  virtual address space, and the range from KERNBASE to UVPT.
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
  800420243b:	48 c7 45 d8 00 00 32 	movq   $0x320000,-0x28(%rbp)
  8004202442:	00 
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
  8004202443:	48 c7 45 d0 00 c0 ff 	movq   $0x7ffc000,-0x30(%rbp)
  800420244a:	07 
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
  800420244b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420244f:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  8004202453:	48 c1 e8 14          	shr    $0x14,%rax
  8004202457:	48 89 c1             	mov    %rax,%rcx
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
  800420245a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420245e:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  8004202462:	48 c1 e8 14          	shr    $0x14,%rax
  8004202466:	48 89 c6             	mov    %rax,%rsi
  8004202469:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420246d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202471:	49 89 c8             	mov    %rcx,%r8
  8004202474:	48 89 d1             	mov    %rdx,%rcx
  8004202477:	48 89 f2             	mov    %rsi,%rdx
  800420247a:	48 89 c6             	mov    %rax,%rsi
  800420247d:	48 bf e0 f4 21 04 80 	movabs $0x800421f4e0,%rdi
  8004202484:	00 00 00 
  8004202487:	b8 00 00 00 00       	mov    $0x0,%eax
  800420248c:	49 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%r9
  8004202493:	00 00 00 
  8004202496:	41 ff d1             	callq  *%r9
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
	uint64_t max_npages = upages_max < kern_mem_max ? upages_max : kern_mem_max;
  8004202499:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420249d:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  80042024a1:	48 0f 46 45 d0       	cmovbe -0x30(%rbp),%rax
  80042024a6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if(npages > max_npages) {
  80042024aa:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  80042024b1:	00 00 00 
  80042024b4:	48 8b 00             	mov    (%rax),%rax
  80042024b7:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042024bb:	76 3a                	jbe    80042024f7 <i386_detect_memory+0x2a1>
		npages = max_npages - 1024;
  80042024bd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042024c1:	48 8d 90 00 fc ff ff 	lea    -0x400(%rax),%rdx
  80042024c8:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  80042024cf:	00 00 00 
  80042024d2:	48 89 10             	mov    %rdx,(%rax)
		cprintf("Using only %uK of the available memory.\n", max_npages);
  80042024d5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042024d9:	48 89 c6             	mov    %rax,%rsi
  80042024dc:	48 bf 48 f5 21 04 80 	movabs $0x800421f548,%rdi
  80042024e3:	00 00 00 
  80042024e6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042024eb:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  80042024f2:	00 00 00 
  80042024f5:	ff d2                	callq  *%rdx
	}
}
  80042024f7:	90                   	nop
  80042024f8:	c9                   	leaveq 
  80042024f9:	c3                   	retq   

00000080042024fa <boot_alloc>:
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
  80042024fa:	55                   	push   %rbp
  80042024fb:	48 89 e5             	mov    %rsp,%rbp
  80042024fe:	48 83 ec 40          	sub    $0x40,%rsp
  8004202502:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
  8004202505:	48 b8 48 02 4e 04 80 	movabs $0x80044e0248,%rax
  800420250c:	00 00 00 
  800420250f:	48 8b 00             	mov    (%rax),%rax
  8004202512:	48 85 c0             	test   %rax,%rax
  8004202515:	75 48                	jne    800420255f <boot_alloc+0x65>
#ifdef VMM_GUEST
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
#else
		extern uintptr_t end_debug;
		nextfree = ROUNDUP((char *) end_debug, PGSIZE);
  8004202517:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  800420251e:	00 
  800420251f:	48 b8 d0 f5 6d 04 80 	movabs $0x80046df5d0,%rax
  8004202526:	00 00 00 
  8004202529:	48 8b 10             	mov    (%rax),%rdx
  800420252c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202530:	48 01 d0             	add    %rdx,%rax
  8004202533:	48 83 e8 01          	sub    $0x1,%rax
  8004202537:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420253b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420253f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202544:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004202548:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420254c:	48 29 d0             	sub    %rdx,%rax
  800420254f:	48 89 c2             	mov    %rax,%rdx
  8004202552:	48 b8 48 02 4e 04 80 	movabs $0x80044e0248,%rax
  8004202559:	00 00 00 
  800420255c:	48 89 10             	mov    %rdx,(%rax)
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.


	if ((uintptr_t)nextfree + n < (uintptr_t)nextfree
  800420255f:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004202562:	48 b8 48 02 4e 04 80 	movabs $0x80044e0248,%rax
  8004202569:	00 00 00 
  800420256c:	48 8b 00             	mov    (%rax),%rax
  800420256f:	48 01 c2             	add    %rax,%rdx
  8004202572:	48 b8 48 02 4e 04 80 	movabs $0x80044e0248,%rax
  8004202579:	00 00 00 
  800420257c:	48 8b 00             	mov    (%rax),%rax
  800420257f:	48 39 c2             	cmp    %rax,%rdx
  8004202582:	72 2f                	jb     80042025b3 <boot_alloc+0xb9>
            || nextfree + n > (char*) (npages * PGSIZE + KERNBASE))
  8004202584:	48 b8 48 02 4e 04 80 	movabs $0x80044e0248,%rax
  800420258b:	00 00 00 
  800420258e:	48 8b 10             	mov    (%rax),%rdx
  8004202591:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004202594:	48 01 c2             	add    %rax,%rdx
  8004202597:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  800420259e:	00 00 00 
  80042025a1:	48 8b 00             	mov    (%rax),%rax
  80042025a4:	48 05 00 40 00 08    	add    $0x8004000,%rax
  80042025aa:	48 c1 e0 0c          	shl    $0xc,%rax
  80042025ae:	48 39 c2             	cmp    %rax,%rdx
  80042025b1:	76 2a                	jbe    80042025dd <boot_alloc+0xe3>
		panic("out of memory during x64_vm_init");
  80042025b3:	48 ba 78 f5 21 04 80 	movabs $0x800421f578,%rdx
  80042025ba:	00 00 00 
  80042025bd:	be ee 00 00 00       	mov    $0xee,%esi
  80042025c2:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042025c9:	00 00 00 
  80042025cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042025d1:	48 b9 d3 04 20 04 80 	movabs $0x80042004d3,%rcx
  80042025d8:	00 00 00 
  80042025db:	ff d1                	callq  *%rcx
	result = nextfree;
  80042025dd:	48 b8 48 02 4e 04 80 	movabs $0x80044e0248,%rax
  80042025e4:	00 00 00 
  80042025e7:	48 8b 00             	mov    (%rax),%rax
  80042025ea:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	nextfree = ROUNDUP(nextfree + n, PGSIZE);
  80042025ee:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  80042025f5:	00 
  80042025f6:	48 b8 48 02 4e 04 80 	movabs $0x80044e0248,%rax
  80042025fd:	00 00 00 
  8004202600:	48 8b 10             	mov    (%rax),%rdx
  8004202603:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004202606:	48 01 d0             	add    %rdx,%rax
  8004202609:	48 89 c2             	mov    %rax,%rdx
  800420260c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202610:	48 01 d0             	add    %rdx,%rax
  8004202613:	48 83 e8 01          	sub    $0x1,%rax
  8004202617:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420261b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420261f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202624:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004202628:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420262c:	48 29 d0             	sub    %rdx,%rax
  800420262f:	48 89 c2             	mov    %rax,%rdx
  8004202632:	48 b8 48 02 4e 04 80 	movabs $0x80044e0248,%rax
  8004202639:	00 00 00 
  800420263c:	48 89 10             	mov    %rdx,(%rax)
	return result;
  800420263f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax

}
  8004202643:	c9                   	leaveq 
  8004202644:	c3                   	retq   

0000008004202645 <x64_vm_init>:
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
x64_vm_init(void)
{
  8004202645:	55                   	push   %rbp
  8004202646:	48 89 e5             	mov    %rsp,%rbp
  8004202649:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
	pml4e_t* pml4e;
	uint32_t cr0;
	uint64_t n;
	int r;
	struct Env *env;
	i386_detect_memory();
  800420264d:	48 b8 56 22 20 04 80 	movabs $0x8004202256,%rax
  8004202654:	00 00 00 
  8004202657:	ff d0                	callq  *%rax
	//panic("i386_vm_init: This function is not finished\n");
	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	pml4e = boot_alloc(PGSIZE);
  8004202659:	bf 00 10 00 00       	mov    $0x1000,%edi
  800420265e:	48 b8 fa 24 20 04 80 	movabs $0x80042024fa,%rax
  8004202665:	00 00 00 
  8004202668:	ff d0                	callq  *%rax
  800420266a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(pml4e, 0, PGSIZE);
  800420266e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202672:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202677:	be 00 00 00 00       	mov    $0x0,%esi
  800420267c:	48 89 c7             	mov    %rax,%rdi
  800420267f:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  8004202686:	00 00 00 
  8004202689:	ff d0                	callq  *%rax
	boot_pml4e = pml4e;
  800420268b:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004202692:	00 00 00 
  8004202695:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202699:	48 89 10             	mov    %rdx,(%rax)
	boot_cr3 = PADDR(pml4e);
  800420269c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042026a0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042026a4:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042026ab:	00 00 00 
  80042026ae:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  80042026b2:	77 32                	ja     80042026e6 <x64_vm_init+0xa1>
  80042026b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042026b8:	48 89 c1             	mov    %rax,%rcx
  80042026bb:	48 ba a0 f5 21 04 80 	movabs $0x800421f5a0,%rdx
  80042026c2:	00 00 00 
  80042026c5:	be 0e 01 00 00       	mov    $0x10e,%esi
  80042026ca:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042026d1:	00 00 00 
  80042026d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042026d9:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042026e0:	00 00 00 
  80042026e3:	41 ff d0             	callq  *%r8
  80042026e6:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042026ed:	ff ff ff 
  80042026f0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042026f4:	48 01 c2             	add    %rax,%rdx
  80042026f7:	48 b8 e8 f5 6d 04 80 	movabs $0x80046df5e8,%rax
  80042026fe:	00 00 00 
  8004202701:	48 89 10             	mov    %rdx,(%rax)
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.
	// Your code goes here:

	n = npages * sizeof(struct PageInfo);
  8004202704:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  800420270b:	00 00 00 
  800420270e:	48 8b 00             	mov    (%rax),%rax
  8004202711:	48 c1 e0 04          	shl    $0x4,%rax
  8004202715:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	pages = (struct PageInfo *) boot_alloc(n);
  8004202719:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420271d:	89 c7                	mov    %eax,%edi
  800420271f:	48 b8 fa 24 20 04 80 	movabs $0x80042024fa,%rax
  8004202726:	00 00 00 
  8004202729:	ff d0                	callq  *%rax
  800420272b:	48 89 c2             	mov    %rax,%rdx
  800420272e:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  8004202735:	00 00 00 
  8004202738:	48 89 10             	mov    %rdx,(%rax)
	memset(pages, 0, n);
  800420273b:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  8004202742:	00 00 00 
  8004202745:	48 8b 00             	mov    (%rax),%rax
  8004202748:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420274c:	be 00 00 00 00       	mov    $0x0,%esi
  8004202751:	48 89 c7             	mov    %rax,%rdi
  8004202754:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  800420275b:	00 00 00 
  800420275e:	ff d0                	callq  *%rax

	//////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.

	envs    = boot_alloc(sizeof(struct Env)*NENV);
  8004202760:	bf 00 a0 05 00       	mov    $0x5a000,%edi
  8004202765:	48 b8 fa 24 20 04 80 	movabs $0x80042024fa,%rax
  800420276c:	00 00 00 
  800420276f:	ff d0                	callq  *%rax
  8004202771:	48 89 c2             	mov    %rax,%rdx
  8004202774:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  800420277b:	00 00 00 
  800420277e:	48 89 10             	mov    %rdx,(%rax)
	memset(envs, 0, sizeof(struct Env)*NENV);
  8004202781:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  8004202788:	00 00 00 
  800420278b:	48 8b 00             	mov    (%rax),%rax
  800420278e:	ba 00 a0 05 00       	mov    $0x5a000,%edx
  8004202793:	be 00 00 00 00       	mov    $0x0,%esi
  8004202798:	48 89 c7             	mov    %rax,%rdi
  800420279b:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  80042027a2:	00 00 00 
  80042027a5:	ff d0                	callq  *%rax
	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region or page_insert
	page_init();
  80042027a7:	48 b8 01 2c 20 04 80 	movabs $0x8004202c01,%rax
  80042027ae:	00 00 00 
  80042027b1:	ff d0                	callq  *%rax
	//    - the new image at UPAGES -- kernel R, us/er R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:

	n = npages*sizeof(struct PageInfo);
  80042027b3:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  80042027ba:	00 00 00 
  80042027bd:	48 8b 00             	mov    (%rax),%rax
  80042027c0:	48 c1 e0 04          	shl    $0x4,%rax
  80042027c4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	boot_map_region(boot_pml4e, UPAGES, n, PADDR(pages), PTE_U);
  80042027c8:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  80042027cf:	00 00 00 
  80042027d2:	48 8b 00             	mov    (%rax),%rax
  80042027d5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042027d9:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042027e0:	00 00 00 
  80042027e3:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  80042027e7:	77 32                	ja     800420281b <x64_vm_init+0x1d6>
  80042027e9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042027ed:	48 89 c1             	mov    %rax,%rcx
  80042027f0:	48 ba a0 f5 21 04 80 	movabs $0x800421f5a0,%rdx
  80042027f7:	00 00 00 
  80042027fa:	be 38 01 00 00       	mov    $0x138,%esi
  80042027ff:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004202806:	00 00 00 
  8004202809:	b8 00 00 00 00       	mov    $0x0,%eax
  800420280e:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004202815:	00 00 00 
  8004202818:	41 ff d0             	callq  *%r8
  800420281b:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202822:	ff ff ff 
  8004202825:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202829:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  800420282d:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004202834:	00 00 00 
  8004202837:	48 8b 00             	mov    (%rax),%rax
  800420283a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420283e:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  8004202844:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  800420284b:	00 00 00 
  800420284e:	48 89 c7             	mov    %rax,%rdi
  8004202851:	48 b8 4f 37 20 04 80 	movabs $0x800420374f,%rax
  8004202858:	00 00 00 
  800420285b:	ff d0                	callq  *%rax
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.

	n   = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  800420285d:	48 c7 45 d8 00 10 00 	movq   $0x1000,-0x28(%rbp)
  8004202864:	00 
  8004202865:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202869:	48 05 ff 9f 05 00    	add    $0x59fff,%rax
  800420286f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004202873:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202877:	ba 00 00 00 00       	mov    $0x0,%edx
  800420287c:	48 f7 75 d8          	divq   -0x28(%rbp)
  8004202880:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202884:	48 29 d0             	sub    %rdx,%rax
  8004202887:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	boot_map_region(boot_pml4e, UENVS, n, PADDR(envs), PTE_U|PTE_P);
  800420288b:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  8004202892:	00 00 00 
  8004202895:	48 8b 00             	mov    (%rax),%rax
  8004202898:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  800420289c:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042028a3:	00 00 00 
  80042028a6:	48 39 45 c8          	cmp    %rax,-0x38(%rbp)
  80042028aa:	77 32                	ja     80042028de <x64_vm_init+0x299>
  80042028ac:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042028b0:	48 89 c1             	mov    %rax,%rcx
  80042028b3:	48 ba a0 f5 21 04 80 	movabs $0x800421f5a0,%rdx
  80042028ba:	00 00 00 
  80042028bd:	be 45 01 00 00       	mov    $0x145,%esi
  80042028c2:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042028c9:	00 00 00 
  80042028cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042028d1:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042028d8:	00 00 00 
  80042028db:	41 ff d0             	callq  *%r8
  80042028de:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042028e5:	ff ff ff 
  80042028e8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042028ec:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  80042028f0:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  80042028f7:	00 00 00 
  80042028fa:	48 8b 00             	mov    (%rax),%rax
  80042028fd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202901:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  8004202907:	48 be 00 00 80 00 80 	movabs $0x8000800000,%rsi
  800420290e:	00 00 00 
  8004202911:	48 89 c7             	mov    %rax,%rdi
  8004202914:	48 b8 4f 37 20 04 80 	movabs $0x800420374f,%rax
  800420291b:	00 00 00 
  800420291e:	ff d0                	callq  *%rax
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:

	boot_map_region(boot_pml4e, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W|PTE_P);
  8004202920:	48 b8 00 60 22 04 80 	movabs $0x8004226000,%rax
  8004202927:	00 00 00 
  800420292a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800420292e:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202935:	00 00 00 
  8004202938:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  800420293c:	77 32                	ja     8004202970 <x64_vm_init+0x32b>
  800420293e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202942:	48 89 c1             	mov    %rax,%rcx
  8004202945:	48 ba a0 f5 21 04 80 	movabs $0x800421f5a0,%rdx
  800420294c:	00 00 00 
  800420294f:	be 55 01 00 00       	mov    $0x155,%esi
  8004202954:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420295b:	00 00 00 
  800420295e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202963:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420296a:	00 00 00 
  800420296d:	41 ff d0             	callq  *%r8
  8004202970:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202977:	ff ff ff 
  800420297a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420297e:	48 01 c2             	add    %rax,%rdx
  8004202981:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004202988:	00 00 00 
  800420298b:	48 8b 00             	mov    (%rax),%rax
  800420298e:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202994:	48 89 d1             	mov    %rdx,%rcx
  8004202997:	ba 00 00 01 00       	mov    $0x10000,%edx
  800420299c:	48 be 00 00 ff 03 80 	movabs $0x8003ff0000,%rsi
  80042029a3:	00 00 00 
  80042029a6:	48 89 c7             	mov    %rax,%rdi
  80042029a9:	48 b8 4f 37 20 04 80 	movabs $0x800420374f,%rax
  80042029b0:	00 00 00 
  80042029b3:	ff d0                	callq  *%rax
	// Ie.  the VA range [KERNBASE, npages*PGSIZE) should map to
	//      the PA range [0, npages*PGSIZE)
	// Permissions: kernel RW, user NONE
	// Your code goes here: 

	boot_map_region(boot_pml4e, KERNBASE, npages*PGSIZE, 0, PTE_W|PTE_P);
  80042029b5:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  80042029bc:	00 00 00 
  80042029bf:	48 8b 00             	mov    (%rax),%rax
  80042029c2:	48 c1 e0 0c          	shl    $0xc,%rax
  80042029c6:	48 89 c2             	mov    %rax,%rdx
  80042029c9:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  80042029d0:	00 00 00 
  80042029d3:	48 8b 00             	mov    (%rax),%rax
  80042029d6:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  80042029dc:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042029e1:	48 be 00 00 00 04 80 	movabs $0x8004000000,%rsi
  80042029e8:	00 00 00 
  80042029eb:	48 89 c7             	mov    %rax,%rdi
  80042029ee:	48 b8 4f 37 20 04 80 	movabs $0x800420374f,%rax
  80042029f5:	00 00 00 
  80042029f8:	ff d0                	callq  *%rax

	// Check that the initial page directory has been set up correctly.

	// Initialize the SMP-related parts of the memory map
	mem_init_mp();
  80042029fa:	48 b8 15 2b 20 04 80 	movabs $0x8004202b15,%rax
  8004202a01:	00 00 00 
  8004202a04:	ff d0                	callq  *%rax



	//////////////////////////////////////////////////////////////////////
	// Permissions: kernel RW, user NONE
	pdpe_t *pdpe = KADDR(PTE_ADDR(pml4e[1]));
  8004202a06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202a0a:	48 83 c0 08          	add    $0x8,%rax
  8004202a0e:	48 8b 00             	mov    (%rax),%rax
  8004202a11:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202a17:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004202a1b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202a1f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202a23:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  8004202a26:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004202a29:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004202a30:	00 00 00 
  8004202a33:	48 8b 00             	mov    (%rax),%rax
  8004202a36:	48 39 c2             	cmp    %rax,%rdx
  8004202a39:	72 32                	jb     8004202a6d <x64_vm_init+0x428>
  8004202a3b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202a3f:	48 89 c1             	mov    %rax,%rcx
  8004202a42:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  8004202a49:	00 00 00 
  8004202a4c:	be 6c 01 00 00       	mov    $0x16c,%esi
  8004202a51:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004202a58:	00 00 00 
  8004202a5b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202a60:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004202a67:	00 00 00 
  8004202a6a:	41 ff d0             	callq  *%r8
  8004202a6d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202a74:	00 00 00 
  8004202a77:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202a7b:	48 01 d0             	add    %rdx,%rax
  8004202a7e:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	pde_t *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004202a82:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202a86:	48 8b 00             	mov    (%rax),%rax
  8004202a89:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202a8f:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004202a93:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202a97:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202a9b:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004202a9e:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004202aa1:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004202aa8:	00 00 00 
  8004202aab:	48 8b 00             	mov    (%rax),%rax
  8004202aae:	48 39 c2             	cmp    %rax,%rdx
  8004202ab1:	72 32                	jb     8004202ae5 <x64_vm_init+0x4a0>
  8004202ab3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202ab7:	48 89 c1             	mov    %rax,%rcx
  8004202aba:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  8004202ac1:	00 00 00 
  8004202ac4:	be 6d 01 00 00       	mov    $0x16d,%esi
  8004202ac9:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004202ad0:	00 00 00 
  8004202ad3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202ad8:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004202adf:	00 00 00 
  8004202ae2:	41 ff d0             	callq  *%r8
  8004202ae5:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202aec:	00 00 00 
  8004202aef:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202af3:	48 01 d0             	add    %rdx,%rax
  8004202af6:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	lcr3(boot_cr3);
  8004202afa:	48 b8 e8 f5 6d 04 80 	movabs $0x80046df5e8,%rax
  8004202b01:	00 00 00 
  8004202b04:	48 8b 00             	mov    (%rax),%rax
  8004202b07:	48 89 45 88          	mov    %rax,-0x78(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004202b0b:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004202b0f:	0f 22 d8             	mov    %rax,%cr3
}
  8004202b12:	90                   	nop
  8004202b13:	c9                   	leaveq 
  8004202b14:	c3                   	retq   

0000008004202b15 <mem_init_mp>:
// Modify mappings in boot_pml4e to support SMP
//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
//
static void
mem_init_mp(void)
{
  8004202b15:	55                   	push   %rbp
  8004202b16:	48 89 e5             	mov    %rsp,%rbp
  8004202b19:	48 83 ec 20          	sub    $0x20,%rsp
	// LAB 4: Your code here:


	int i;
	uintptr_t kstacktop;
	for (i = 0; i < NCPU; i++) {
  8004202b1d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004202b24:	e9 cb 00 00 00       	jmpq   8004202bf4 <mem_init_mp+0xdf>
		kstacktop = KSTACKTOP - (KSTKSIZE + KSTKGAP) * i;
  8004202b29:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004202b2c:	89 d0                	mov    %edx,%eax
  8004202b2e:	01 c0                	add    %eax,%eax
  8004202b30:	01 d0                	add    %edx,%eax
  8004202b32:	c1 e0 0f             	shl    $0xf,%eax
  8004202b35:	48 98                	cltq   
  8004202b37:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202b3e:	00 00 00 
  8004202b41:	48 29 c2             	sub    %rax,%rdx
  8004202b44:	48 89 d0             	mov    %rdx,%rax
  8004202b47:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		boot_map_region(boot_pml4e, kstacktop - KSTKSIZE, KSTKSIZE,
				PADDR(percpu_kstacks[i]), PTE_P|PTE_W);
  8004202b4b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004202b4e:	48 98                	cltq   
  8004202b50:	48 c1 e0 10          	shl    $0x10,%rax
  8004202b54:	48 89 c2             	mov    %rax,%rdx
  8004202b57:	48 b8 00 20 6e 04 80 	movabs $0x80046e2000,%rax
  8004202b5e:	00 00 00 
  8004202b61:	48 01 d0             	add    %rdx,%rax
  8004202b64:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202b68:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202b6f:	00 00 00 
  8004202b72:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004202b76:	77 32                	ja     8004202baa <mem_init_mp+0x95>
  8004202b78:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202b7c:	48 89 c1             	mov    %rax,%rcx
  8004202b7f:	48 ba a0 f5 21 04 80 	movabs $0x800421f5a0,%rdx
  8004202b86:	00 00 00 
  8004202b89:	be 90 01 00 00       	mov    $0x190,%esi
  8004202b8e:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004202b95:	00 00 00 
  8004202b98:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202b9d:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004202ba4:	00 00 00 
  8004202ba7:	41 ff d0             	callq  *%r8
  8004202baa:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202bb1:	ff ff ff 
  8004202bb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202bb8:	48 01 c2             	add    %rax,%rdx

	int i;
	uintptr_t kstacktop;
	for (i = 0; i < NCPU; i++) {
		kstacktop = KSTACKTOP - (KSTKSIZE + KSTKGAP) * i;
		boot_map_region(boot_pml4e, kstacktop - KSTKSIZE, KSTKSIZE,
  8004202bbb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202bbf:	48 8d b0 00 00 ff ff 	lea    -0x10000(%rax),%rsi
  8004202bc6:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004202bcd:	00 00 00 
  8004202bd0:	48 8b 00             	mov    (%rax),%rax
  8004202bd3:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202bd9:	48 89 d1             	mov    %rdx,%rcx
  8004202bdc:	ba 00 00 01 00       	mov    $0x10000,%edx
  8004202be1:	48 89 c7             	mov    %rax,%rdi
  8004202be4:	48 b8 4f 37 20 04 80 	movabs $0x800420374f,%rax
  8004202beb:	00 00 00 
  8004202bee:	ff d0                	callq  *%rax
	// LAB 4: Your code here:


	int i;
	uintptr_t kstacktop;
	for (i = 0; i < NCPU; i++) {
  8004202bf0:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004202bf4:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004202bf8:	0f 8e 2b ff ff ff    	jle    8004202b29 <mem_init_mp+0x14>
		kstacktop = KSTACKTOP - (KSTKSIZE + KSTKGAP) * i;
		boot_map_region(boot_pml4e, kstacktop - KSTKSIZE, KSTKSIZE,
				PADDR(percpu_kstacks[i]), PTE_P|PTE_W);
	}

}
  8004202bfe:	90                   	nop
  8004202bff:	c9                   	leaveq 
  8004202c00:	c3                   	retq   

0000008004202c01 <page_init>:
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
  8004202c01:	55                   	push   %rbp
  8004202c02:	48 89 e5             	mov    %rsp,%rbp
  8004202c05:	48 83 ec 50          	sub    $0x50,%rsp
	// LAB 4:
	// Change your code to mark the physical page at MPENTRY_PADDR
	// as in use


	void *nextfree = boot_alloc(0);
  8004202c09:	bf 00 00 00 00       	mov    $0x0,%edi
  8004202c0e:	48 b8 fa 24 20 04 80 	movabs $0x80042024fa,%rax
  8004202c15:	00 00 00 
  8004202c18:	ff d0                	callq  *%rax
  8004202c1a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	size_t i;
	int inuse;
	struct PageInfo* last = NULL;
  8004202c1e:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004202c25:	00 
	for (i = 0; i < npages; i++) {
  8004202c26:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202c2d:	00 
  8004202c2e:	e9 65 02 00 00       	jmpq   8004202e98 <page_init+0x297>
		// Off-limits until proven otherwise.
		inuse = 1;
  8004202c33:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)

		// The bottom basemem bytes are free except page 0.
		if (i != 0 && i < npages_basemem)
  8004202c3a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202c3f:	74 1a                	je     8004202c5b <page_init+0x5a>
  8004202c41:	48 b8 30 02 4e 04 80 	movabs $0x80044e0230,%rax
  8004202c48:	00 00 00 
  8004202c4b:	48 8b 00             	mov    (%rax),%rax
  8004202c4e:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004202c52:	73 07                	jae    8004202c5b <page_init+0x5a>
			inuse = 0;
  8004202c54:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

		// Mark physical page at MPENTRY_PADDR as in use
		if (i == MPENTRY_PADDR / PGSIZE)
  8004202c5b:	48 83 7d f8 07       	cmpq   $0x7,-0x8(%rbp)
  8004202c60:	75 07                	jne    8004202c69 <page_init+0x68>
			inuse = 1;
  8004202c62:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)


		// The IO hole and the kernel are non empty but
		// The memory past the kernel is free.
		if (i >= PADDR(nextfree) / PGSIZE)
  8004202c69:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202c6d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004202c71:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202c78:	00 00 00 
  8004202c7b:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004202c7f:	77 32                	ja     8004202cb3 <page_init+0xb2>
  8004202c81:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202c85:	48 89 c1             	mov    %rax,%rcx
  8004202c88:	48 ba a0 f5 21 04 80 	movabs $0x800421f5a0,%rdx
  8004202c8f:	00 00 00 
  8004202c92:	be be 01 00 00       	mov    $0x1be,%esi
  8004202c97:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004202c9e:	00 00 00 
  8004202ca1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202ca6:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004202cad:	00 00 00 
  8004202cb0:	41 ff d0             	callq  *%r8
  8004202cb3:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202cba:	ff ff ff 
  8004202cbd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202cc1:	48 01 d0             	add    %rdx,%rax
  8004202cc4:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202cc8:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004202ccc:	77 07                	ja     8004202cd5 <page_init+0xd4>
			inuse = 0;
  8004202cce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

		uint64_t va = KERNBASE + i*PGSIZE;
  8004202cd5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202cd9:	48 05 00 40 00 08    	add    $0x8004000,%rax
  8004202cdf:	48 c1 e0 0c          	shl    $0xc,%rax
  8004202ce3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if (va>=BOOT_PAGE_TABLE_START && va<BOOT_PAGE_TABLE_END)
  8004202ce7:	48 b8 00 20 10 00 00 	movabs $0x102000,%rax
  8004202cee:	00 00 00 
  8004202cf1:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004202cf5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202cf9:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202cfd:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004202d00:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004202d03:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004202d0a:	00 00 00 
  8004202d0d:	48 8b 00             	mov    (%rax),%rax
  8004202d10:	48 39 c2             	cmp    %rax,%rdx
  8004202d13:	72 32                	jb     8004202d47 <page_init+0x146>
  8004202d15:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202d19:	48 89 c1             	mov    %rax,%rcx
  8004202d1c:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  8004202d23:	00 00 00 
  8004202d26:	be c2 01 00 00       	mov    $0x1c2,%esi
  8004202d2b:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004202d32:	00 00 00 
  8004202d35:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202d3a:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004202d41:	00 00 00 
  8004202d44:	41 ff d0             	callq  *%r8
  8004202d47:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202d4e:	00 00 00 
  8004202d51:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202d55:	48 01 d0             	add    %rdx,%rax
  8004202d58:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004202d5c:	0f 87 84 00 00 00    	ja     8004202de6 <page_init+0x1e5>
  8004202d62:	48 b8 00 20 10 00 00 	movabs $0x102000,%rax
  8004202d69:	00 00 00 
  8004202d6c:	48 05 00 50 00 00    	add    $0x5000,%rax
  8004202d72:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004202d76:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202d7a:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202d7e:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  8004202d81:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004202d84:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004202d8b:	00 00 00 
  8004202d8e:	48 8b 00             	mov    (%rax),%rax
  8004202d91:	48 39 c2             	cmp    %rax,%rdx
  8004202d94:	72 32                	jb     8004202dc8 <page_init+0x1c7>
  8004202d96:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202d9a:	48 89 c1             	mov    %rax,%rcx
  8004202d9d:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  8004202da4:	00 00 00 
  8004202da7:	be c2 01 00 00       	mov    $0x1c2,%esi
  8004202dac:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004202db3:	00 00 00 
  8004202db6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202dbb:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004202dc2:	00 00 00 
  8004202dc5:	41 ff d0             	callq  *%r8
  8004202dc8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202dcf:	00 00 00 
  8004202dd2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202dd6:	48 01 d0             	add    %rdx,%rax
  8004202dd9:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004202ddd:	76 07                	jbe    8004202de6 <page_init+0x1e5>
			inuse = 1;
  8004202ddf:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)

		pages[i].pp_ref = inuse;
  8004202de6:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  8004202ded:	00 00 00 
  8004202df0:	48 8b 00             	mov    (%rax),%rax
  8004202df3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202df7:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202dfb:	48 01 d0             	add    %rdx,%rax
  8004202dfe:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004202e01:	66 89 50 08          	mov    %dx,0x8(%rax)
		pages[i].pp_link = NULL;
  8004202e05:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  8004202e0c:	00 00 00 
  8004202e0f:	48 8b 00             	mov    (%rax),%rax
  8004202e12:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202e16:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202e1a:	48 01 d0             	add    %rdx,%rax
  8004202e1d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (!inuse) {
  8004202e24:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004202e28:	75 69                	jne    8004202e93 <page_init+0x292>
			if (last)
  8004202e2a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202e2f:	74 21                	je     8004202e52 <page_init+0x251>
				last->pp_link = &pages[i];
  8004202e31:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  8004202e38:	00 00 00 
  8004202e3b:	48 8b 00             	mov    (%rax),%rax
  8004202e3e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202e42:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202e46:	48 01 c2             	add    %rax,%rdx
  8004202e49:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202e4d:	48 89 10             	mov    %rdx,(%rax)
  8004202e50:	eb 25                	jmp    8004202e77 <page_init+0x276>
			else
				page_free_list = &pages[i];
  8004202e52:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  8004202e59:	00 00 00 
  8004202e5c:	48 8b 00             	mov    (%rax),%rax
  8004202e5f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202e63:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202e67:	48 01 c2             	add    %rax,%rdx
  8004202e6a:	48 b8 38 02 4e 04 80 	movabs $0x80044e0238,%rax
  8004202e71:	00 00 00 
  8004202e74:	48 89 10             	mov    %rdx,(%rax)
			last = &pages[i];
  8004202e77:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  8004202e7e:	00 00 00 
  8004202e81:	48 8b 00             	mov    (%rax),%rax
  8004202e84:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202e88:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202e8c:	48 01 d0             	add    %rdx,%rax
  8004202e8f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	void *nextfree = boot_alloc(0);
	size_t i;
	int inuse;
	struct PageInfo* last = NULL;
	for (i = 0; i < npages; i++) {
  8004202e93:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004202e98:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004202e9f:	00 00 00 
  8004202ea2:	48 8b 00             	mov    (%rax),%rax
  8004202ea5:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004202ea9:	0f 82 84 fd ff ff    	jb     8004202c33 <page_init+0x32>
		}

	}


}
  8004202eaf:	90                   	nop
  8004202eb0:	c9                   	leaveq 
  8004202eb1:	c3                   	retq   

0000008004202eb2 <page_alloc>:
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
  8004202eb2:	55                   	push   %rbp
  8004202eb3:	48 89 e5             	mov    %rsp,%rbp
  8004202eb6:	48 83 ec 20          	sub    $0x20,%rsp
  8004202eba:	89 7d ec             	mov    %edi,-0x14(%rbp)
	// Fill this function in

	struct PageInfo *pp = page_free_list;
  8004202ebd:	48 b8 38 02 4e 04 80 	movabs $0x80044e0238,%rax
  8004202ec4:	00 00 00 
  8004202ec7:	48 8b 00             	mov    (%rax),%rax
  8004202eca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (pp) {
  8004202ece:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202ed3:	74 5e                	je     8004202f33 <page_alloc+0x81>
		//cprintf("alloc new page: struct page %x va %x pa %x \n", pp, page2kva(pp), page2pa(pp));
		page_free_list = page_free_list->pp_link;
  8004202ed5:	48 b8 38 02 4e 04 80 	movabs $0x80044e0238,%rax
  8004202edc:	00 00 00 
  8004202edf:	48 8b 00             	mov    (%rax),%rax
  8004202ee2:	48 8b 10             	mov    (%rax),%rdx
  8004202ee5:	48 b8 38 02 4e 04 80 	movabs $0x80044e0238,%rax
  8004202eec:	00 00 00 
  8004202eef:	48 89 10             	mov    %rdx,(%rax)
		pp->pp_link = NULL;
  8004202ef2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202ef6:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (alloc_flags & ALLOC_ZERO)
  8004202efd:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202f00:	83 e0 01             	and    $0x1,%eax
  8004202f03:	85 c0                	test   %eax,%eax
  8004202f05:	74 2c                	je     8004202f33 <page_alloc+0x81>
			memset(page2kva(pp), 0, PGSIZE);
  8004202f07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202f0b:	48 89 c7             	mov    %rax,%rdi
  8004202f0e:	48 b8 d3 1b 20 04 80 	movabs $0x8004201bd3,%rax
  8004202f15:	00 00 00 
  8004202f18:	ff d0                	callq  *%rax
  8004202f1a:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202f1f:	be 00 00 00 00       	mov    $0x0,%esi
  8004202f24:	48 89 c7             	mov    %rax,%rdi
  8004202f27:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  8004202f2e:	00 00 00 
  8004202f31:	ff d0                	callq  *%rax
	}
	return pp;
  8004202f33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax

}
  8004202f37:	c9                   	leaveq 
  8004202f38:	c3                   	retq   

0000008004202f39 <page_initpp>:
// The result has null links and 0 refcount.
// Note that the corresponding physical page is NOT initialized!
//
static void
page_initpp(struct PageInfo *pp)
{
  8004202f39:	55                   	push   %rbp
  8004202f3a:	48 89 e5             	mov    %rsp,%rbp
  8004202f3d:	48 83 ec 10          	sub    $0x10,%rsp
  8004202f41:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	memset(pp, 0, sizeof(*pp));
  8004202f45:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202f49:	ba 10 00 00 00       	mov    $0x10,%edx
  8004202f4e:	be 00 00 00 00       	mov    $0x0,%esi
  8004202f53:	48 89 c7             	mov    %rax,%rdi
  8004202f56:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  8004202f5d:	00 00 00 
  8004202f60:	ff d0                	callq  *%rax
}
  8004202f62:	90                   	nop
  8004202f63:	c9                   	leaveq 
  8004202f64:	c3                   	retq   

0000008004202f65 <page_free>:
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
  8004202f65:	55                   	push   %rbp
  8004202f66:	48 89 e5             	mov    %rsp,%rbp
  8004202f69:	48 83 ec 10          	sub    $0x10,%rsp
  8004202f6d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

	if (pp->pp_ref || pp->pp_link) {
  8004202f71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202f75:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202f79:	66 85 c0             	test   %ax,%ax
  8004202f7c:	75 0c                	jne    8004202f8a <page_free+0x25>
  8004202f7e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202f82:	48 8b 00             	mov    (%rax),%rax
  8004202f85:	48 85 c0             	test   %rax,%rax
  8004202f88:	74 2c                	je     8004202fb6 <page_free+0x51>
		warn("page_free: attempt to free mapped page");
  8004202f8a:	48 ba c8 f5 21 04 80 	movabs $0x800421f5c8,%rdx
  8004202f91:	00 00 00 
  8004202f94:	be 04 02 00 00       	mov    $0x204,%esi
  8004202f99:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004202fa0:	00 00 00 
  8004202fa3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202fa8:	48 b9 0f 06 20 04 80 	movabs $0x800420060f,%rcx
  8004202faf:	00 00 00 
  8004202fb2:	ff d1                	callq  *%rcx
		return;		/* be conservative and assume page is still used */
  8004202fb4:	eb 2f                	jmp    8004202fe5 <page_free+0x80>
	}
	pp->pp_link = page_free_list;
  8004202fb6:	48 b8 38 02 4e 04 80 	movabs $0x80044e0238,%rax
  8004202fbd:	00 00 00 
  8004202fc0:	48 8b 10             	mov    (%rax),%rdx
  8004202fc3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202fc7:	48 89 10             	mov    %rdx,(%rax)
	page_free_list = pp;
  8004202fca:	48 b8 38 02 4e 04 80 	movabs $0x80044e0238,%rax
  8004202fd1:	00 00 00 
  8004202fd4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202fd8:	48 89 10             	mov    %rdx,(%rax)
	pp->pp_ref = 0;
  8004202fdb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202fdf:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)

}
  8004202fe5:	c9                   	leaveq 
  8004202fe6:	c3                   	retq   

0000008004202fe7 <page_decref>:
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
  8004202fe7:	55                   	push   %rbp
  8004202fe8:	48 89 e5             	mov    %rsp,%rbp
  8004202feb:	48 83 ec 10          	sub    $0x10,%rsp
  8004202fef:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (--pp->pp_ref == 0)
  8004202ff3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202ff7:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202ffb:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004202ffe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203002:	66 89 50 08          	mov    %dx,0x8(%rax)
  8004203006:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420300a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420300e:	66 85 c0             	test   %ax,%ax
  8004203011:	75 13                	jne    8004203026 <page_decref+0x3f>
		page_free(pp);
  8004203013:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203017:	48 89 c7             	mov    %rax,%rdi
  800420301a:	48 b8 65 2f 20 04 80 	movabs $0x8004202f65,%rax
  8004203021:	00 00 00 
  8004203024:	ff d0                	callq  *%rax
}
  8004203026:	90                   	nop
  8004203027:	c9                   	leaveq 
  8004203028:	c3                   	retq   

0000008004203029 <pml4e_walk>:
// table, page directory,page directory pointer and pml4 entries.
//

pte_t *
pml4e_walk(pml4e_t *pml4e, const void *va, int create)
{
  8004203029:	55                   	push   %rbp
  800420302a:	48 89 e5             	mov    %rsp,%rbp
  800420302d:	53                   	push   %rbx
  800420302e:	48 83 ec 68          	sub    $0x68,%rsp
  8004203032:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004203036:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420303a:	89 55 9c             	mov    %edx,-0x64(%rbp)

	if (pml4e) {
  800420303d:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  8004203042:	0f 84 54 02 00 00    	je     800420329c <pml4e_walk+0x273>
		pdpe_t *pdpe  = (pdpe_t *)pml4e [PML4(va)];
  8004203048:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420304c:	48 c1 e8 27          	shr    $0x27,%rax
  8004203050:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203055:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420305c:	00 
  800420305d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203061:	48 01 d0             	add    %rdx,%rax
  8004203064:	48 8b 00             	mov    (%rax),%rax
  8004203067:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if (!((physaddr_t)pdpe & PTE_P) && create) {
  800420306b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420306f:	83 e0 01             	and    $0x1,%eax
  8004203072:	48 85 c0             	test   %rax,%rax
  8004203075:	0f 85 82 01 00 00    	jne    80042031fd <pml4e_walk+0x1d4>
  800420307b:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  800420307f:	0f 84 78 01 00 00    	je     80042031fd <pml4e_walk+0x1d4>
			struct PageInfo *page   = NULL;
  8004203085:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420308c:	00 
			if ((page = page_alloc(ALLOC_ZERO))) {
  800420308d:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203092:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004203099:	00 00 00 
  800420309c:	ff d0                	callq  *%rax
  800420309e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042030a2:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042030a7:	0f 84 46 01 00 00    	je     80042031f3 <pml4e_walk+0x1ca>
				page->pp_ref    += 1;
  80042030ad:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042030b1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042030b5:	8d 50 01             	lea    0x1(%rax),%edx
  80042030b8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042030bc:	66 89 50 08          	mov    %dx,0x8(%rax)
				pml4e [PML4(va)] = page2pa(page)|PTE_U|PTE_W|PTE_P;
  80042030c0:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042030c4:	48 c1 e8 27          	shr    $0x27,%rax
  80042030c8:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042030cd:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042030d4:	00 
  80042030d5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042030d9:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  80042030dd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042030e1:	48 89 c7             	mov    %rax,%rdi
  80042030e4:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  80042030eb:	00 00 00 
  80042030ee:	ff d0                	callq  *%rax
  80042030f0:	48 83 c8 07          	or     $0x7,%rax
  80042030f4:	48 89 03             	mov    %rax,(%rbx)
				pte_t *pte= pdpe_walk(KADDR((uintptr_t)((pdpe_t *)(PTE_ADDR(pml4e [PML4(va)])))),va,create);
  80042030f7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042030fb:	48 c1 e8 27          	shr    $0x27,%rax
  80042030ff:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203104:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420310b:	00 
  800420310c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203110:	48 01 d0             	add    %rdx,%rax
  8004203113:	48 8b 00             	mov    (%rax),%rax
  8004203116:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420311c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004203120:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203124:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203128:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  800420312b:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800420312e:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004203135:	00 00 00 
  8004203138:	48 8b 00             	mov    (%rax),%rax
  800420313b:	48 39 c2             	cmp    %rax,%rdx
  800420313e:	72 32                	jb     8004203172 <pml4e_walk+0x149>
  8004203140:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203144:	48 89 c1             	mov    %rax,%rcx
  8004203147:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  800420314e:	00 00 00 
  8004203151:	be 3c 02 00 00       	mov    $0x23c,%esi
  8004203156:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420315d:	00 00 00 
  8004203160:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203165:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420316c:	00 00 00 
  800420316f:	41 ff d0             	callq  *%r8
  8004203172:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203179:	00 00 00 
  800420317c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203180:	48 01 d0             	add    %rdx,%rax
  8004203183:	48 89 c1             	mov    %rax,%rcx
  8004203186:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004203189:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420318d:	48 89 c6             	mov    %rax,%rsi
  8004203190:	48 89 cf             	mov    %rcx,%rdi
  8004203193:	48 b8 a8 32 20 04 80 	movabs $0x80042032a8,%rax
  800420319a:	00 00 00 
  800420319d:	ff d0                	callq  *%rax
  800420319f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
				if (pte!=NULL) return pte;
  80042031a3:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042031a8:	74 09                	je     80042031b3 <pml4e_walk+0x18a>
  80042031aa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042031ae:	e9 ee 00 00 00       	jmpq   80042032a1 <pml4e_walk+0x278>
				else{
					pml4e[PML4(va)] = 0;
  80042031b3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042031b7:	48 c1 e8 27          	shr    $0x27,%rax
  80042031bb:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042031c0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042031c7:	00 
  80042031c8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042031cc:	48 01 d0             	add    %rdx,%rax
  80042031cf:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
					page_decref(page);
  80042031d6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042031da:	48 89 c7             	mov    %rax,%rdi
  80042031dd:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  80042031e4:	00 00 00 
  80042031e7:	ff d0                	callq  *%rax
					return NULL;
  80042031e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042031ee:	e9 ae 00 00 00       	jmpq   80042032a1 <pml4e_walk+0x278>
				}
			}else 
				return NULL;
  80042031f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042031f8:	e9 a4 00 00 00       	jmpq   80042032a1 <pml4e_walk+0x278>
		} else if ((uint64_t)pdpe & PTE_P) {
  80042031fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203201:	83 e0 01             	and    $0x1,%eax
  8004203204:	48 85 c0             	test   %rax,%rax
  8004203207:	0f 84 8f 00 00 00    	je     800420329c <pml4e_walk+0x273>
			return pdpe_walk(KADDR((uintptr_t)((pdpe_t *)PTE_ADDR(pdpe))),va,create);
  800420320d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203211:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203217:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800420321b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420321f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203223:	89 45 bc             	mov    %eax,-0x44(%rbp)
  8004203226:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004203229:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004203230:	00 00 00 
  8004203233:	48 8b 00             	mov    (%rax),%rax
  8004203236:	48 39 c2             	cmp    %rax,%rdx
  8004203239:	72 32                	jb     800420326d <pml4e_walk+0x244>
  800420323b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420323f:	48 89 c1             	mov    %rax,%rcx
  8004203242:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  8004203249:	00 00 00 
  800420324c:	be 46 02 00 00       	mov    $0x246,%esi
  8004203251:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004203258:	00 00 00 
  800420325b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203260:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004203267:	00 00 00 
  800420326a:	41 ff d0             	callq  *%r8
  800420326d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203274:	00 00 00 
  8004203277:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420327b:	48 01 d0             	add    %rdx,%rax
  800420327e:	48 89 c1             	mov    %rax,%rcx
  8004203281:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004203284:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203288:	48 89 c6             	mov    %rax,%rsi
  800420328b:	48 89 cf             	mov    %rcx,%rdi
  800420328e:	48 b8 a8 32 20 04 80 	movabs $0x80042032a8,%rax
  8004203295:	00 00 00 
  8004203298:	ff d0                	callq  *%rax
  800420329a:	eb 05                	jmp    80042032a1 <pml4e_walk+0x278>
		}
	}
	return NULL;
  800420329c:	b8 00 00 00 00       	mov    $0x0,%eax

}
  80042032a1:	48 83 c4 68          	add    $0x68,%rsp
  80042032a5:	5b                   	pop    %rbx
  80042032a6:	5d                   	pop    %rbp
  80042032a7:	c3                   	retq   

00000080042032a8 <pdpe_walk>:
// Given a pdpe i.e page directory pointer pdpe_walk returns the pointer to page table entry
// The programming logic in this function is similar to pml4e_walk.
// It calls the pgdir_walk which returns the page_table entry pointer.
// Hints are the same as in pml4e_walk
pte_t *
pdpe_walk(pdpe_t *pdpe,const void *va,int create){
  80042032a8:	55                   	push   %rbp
  80042032a9:	48 89 e5             	mov    %rsp,%rbp
  80042032ac:	53                   	push   %rbx
  80042032ad:	48 83 ec 68          	sub    $0x68,%rsp
  80042032b1:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80042032b5:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  80042032b9:	89 55 9c             	mov    %edx,-0x64(%rbp)


	if (pdpe){
  80042032bc:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  80042032c1:	0f 84 54 02 00 00    	je     800420351b <pdpe_walk+0x273>
		pde_t * pdp = (pde_t *)pdpe[PDPE(va)];
  80042032c7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042032cb:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042032cf:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042032d4:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042032db:	00 
  80042032dc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042032e0:	48 01 d0             	add    %rdx,%rax
  80042032e3:	48 8b 00             	mov    (%rax),%rax
  80042032e6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if(!((physaddr_t)pdp & PTE_P) && create){
  80042032ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042032ee:	83 e0 01             	and    $0x1,%eax
  80042032f1:	48 85 c0             	test   %rax,%rax
  80042032f4:	0f 85 82 01 00 00    	jne    800420347c <pdpe_walk+0x1d4>
  80042032fa:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  80042032fe:	0f 84 78 01 00 00    	je     800420347c <pdpe_walk+0x1d4>
			struct PageInfo *page   = NULL;
  8004203304:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420330b:	00 
			if ((page = page_alloc(ALLOC_ZERO))) {
  800420330c:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203311:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004203318:	00 00 00 
  800420331b:	ff d0                	callq  *%rax
  800420331d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203321:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004203326:	0f 84 46 01 00 00    	je     8004203472 <pdpe_walk+0x1ca>
				page->pp_ref    += 1;
  800420332c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203330:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203334:	8d 50 01             	lea    0x1(%rax),%edx
  8004203337:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420333b:	66 89 50 08          	mov    %dx,0x8(%rax)
				pdpe [PDPE(va)] = page2pa(page)|PTE_U|PTE_W|PTE_P;
  800420333f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203343:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203347:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420334c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203353:	00 
  8004203354:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203358:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420335c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203360:	48 89 c7             	mov    %rax,%rdi
  8004203363:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  800420336a:	00 00 00 
  800420336d:	ff d0                	callq  *%rax
  800420336f:	48 83 c8 07          	or     $0x7,%rax
  8004203373:	48 89 03             	mov    %rax,(%rbx)
				pte_t *pte = pgdir_walk(KADDR((uintptr_t)((pde_t *)PTE_ADDR(pdpe[PDPE(va)]))),va,create);
  8004203376:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420337a:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420337e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203383:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420338a:	00 
  800420338b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420338f:	48 01 d0             	add    %rdx,%rax
  8004203392:	48 8b 00             	mov    (%rax),%rax
  8004203395:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420339b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420339f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042033a3:	48 c1 e8 0c          	shr    $0xc,%rax
  80042033a7:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  80042033aa:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042033ad:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  80042033b4:	00 00 00 
  80042033b7:	48 8b 00             	mov    (%rax),%rax
  80042033ba:	48 39 c2             	cmp    %rax,%rdx
  80042033bd:	72 32                	jb     80042033f1 <pdpe_walk+0x149>
  80042033bf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042033c3:	48 89 c1             	mov    %rax,%rcx
  80042033c6:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  80042033cd:	00 00 00 
  80042033d0:	be 5d 02 00 00       	mov    $0x25d,%esi
  80042033d5:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042033dc:	00 00 00 
  80042033df:	b8 00 00 00 00       	mov    $0x0,%eax
  80042033e4:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042033eb:	00 00 00 
  80042033ee:	41 ff d0             	callq  *%r8
  80042033f1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042033f8:	00 00 00 
  80042033fb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042033ff:	48 01 d0             	add    %rdx,%rax
  8004203402:	48 89 c1             	mov    %rax,%rcx
  8004203405:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004203408:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420340c:	48 89 c6             	mov    %rax,%rsi
  800420340f:	48 89 cf             	mov    %rcx,%rdi
  8004203412:	48 b8 27 35 20 04 80 	movabs $0x8004203527,%rax
  8004203419:	00 00 00 
  800420341c:	ff d0                	callq  *%rax
  800420341e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
				if (pte!=NULL) return pte;
  8004203422:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004203427:	74 09                	je     8004203432 <pdpe_walk+0x18a>
  8004203429:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420342d:	e9 ee 00 00 00       	jmpq   8004203520 <pdpe_walk+0x278>
				else{
					pdpe[PDPE(va)] = 0;
  8004203432:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203436:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420343a:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420343f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203446:	00 
  8004203447:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420344b:	48 01 d0             	add    %rdx,%rax
  800420344e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
					page_decref(page);
  8004203455:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203459:	48 89 c7             	mov    %rax,%rdi
  800420345c:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  8004203463:	00 00 00 
  8004203466:	ff d0                	callq  *%rax
					return NULL;
  8004203468:	b8 00 00 00 00       	mov    $0x0,%eax
  800420346d:	e9 ae 00 00 00       	jmpq   8004203520 <pdpe_walk+0x278>
				}
			}else
				return NULL;
  8004203472:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203477:	e9 a4 00 00 00       	jmpq   8004203520 <pdpe_walk+0x278>
		}else if((uint64_t)pdp & PTE_P){
  800420347c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203480:	83 e0 01             	and    $0x1,%eax
  8004203483:	48 85 c0             	test   %rax,%rax
  8004203486:	0f 84 8f 00 00 00    	je     800420351b <pdpe_walk+0x273>
			return pgdir_walk(KADDR((uintptr_t)((pde_t *)PTE_ADDR(pdp))),va,create);
  800420348c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203490:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203496:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800420349a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420349e:	48 c1 e8 0c          	shr    $0xc,%rax
  80042034a2:	89 45 bc             	mov    %eax,-0x44(%rbp)
  80042034a5:	8b 55 bc             	mov    -0x44(%rbp),%edx
  80042034a8:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  80042034af:	00 00 00 
  80042034b2:	48 8b 00             	mov    (%rax),%rax
  80042034b5:	48 39 c2             	cmp    %rax,%rdx
  80042034b8:	72 32                	jb     80042034ec <pdpe_walk+0x244>
  80042034ba:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042034be:	48 89 c1             	mov    %rax,%rcx
  80042034c1:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  80042034c8:	00 00 00 
  80042034cb:	be 67 02 00 00       	mov    $0x267,%esi
  80042034d0:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042034d7:	00 00 00 
  80042034da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042034df:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042034e6:	00 00 00 
  80042034e9:	41 ff d0             	callq  *%r8
  80042034ec:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042034f3:	00 00 00 
  80042034f6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042034fa:	48 01 d0             	add    %rdx,%rax
  80042034fd:	48 89 c1             	mov    %rax,%rcx
  8004203500:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004203503:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203507:	48 89 c6             	mov    %rax,%rsi
  800420350a:	48 89 cf             	mov    %rcx,%rdi
  800420350d:	48 b8 27 35 20 04 80 	movabs $0x8004203527,%rax
  8004203514:	00 00 00 
  8004203517:	ff d0                	callq  *%rax
  8004203519:	eb 05                	jmp    8004203520 <pdpe_walk+0x278>
		}
	}
	return NULL;
  800420351b:	b8 00 00 00 00       	mov    $0x0,%eax

}
  8004203520:	48 83 c4 68          	add    $0x68,%rsp
  8004203524:	5b                   	pop    %rbx
  8004203525:	5d                   	pop    %rbp
  8004203526:	c3                   	retq   

0000008004203527 <pgdir_walk>:
// The programming logic and the hints are the same as pml4e_walk
// and pdpe_walk.

pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
  8004203527:	55                   	push   %rbp
  8004203528:	48 89 e5             	mov    %rsp,%rbp
  800420352b:	53                   	push   %rbx
  800420352c:	48 83 ec 58          	sub    $0x58,%rsp
  8004203530:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004203534:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004203538:	89 55 ac             	mov    %edx,-0x54(%rbp)

	if (pgdir) {
  800420353b:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004203540:	0f 84 fd 01 00 00    	je     8004203743 <pgdir_walk+0x21c>
		pte_t *pte  = (pte_t *)pgdir [PDX(va)];
  8004203546:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420354a:	48 c1 e8 15          	shr    $0x15,%rax
  800420354e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203553:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420355a:	00 
  800420355b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420355f:	48 01 d0             	add    %rdx,%rax
  8004203562:	48 8b 00             	mov    (%rax),%rax
  8004203565:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if (!((physaddr_t)pte & PTE_P) && create) {
  8004203569:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420356d:	83 e0 01             	and    $0x1,%eax
  8004203570:	48 85 c0             	test   %rax,%rax
  8004203573:	0f 85 2f 01 00 00    	jne    80042036a8 <pgdir_walk+0x181>
  8004203579:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  800420357d:	0f 84 25 01 00 00    	je     80042036a8 <pgdir_walk+0x181>
			struct PageInfo *page   = NULL;
  8004203583:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420358a:	00 
			if ((page = page_alloc(ALLOC_ZERO))) {
  800420358b:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203590:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004203597:	00 00 00 
  800420359a:	ff d0                	callq  *%rax
  800420359c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042035a0:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042035a5:	0f 84 f3 00 00 00    	je     800420369e <pgdir_walk+0x177>
				page->pp_ref    += 1;
  80042035ab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042035af:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042035b3:	8d 50 01             	lea    0x1(%rax),%edx
  80042035b6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042035ba:	66 89 50 08          	mov    %dx,0x8(%rax)
				pgdir [PDX(va)] = page2pa(page)|PTE_U|PTE_W|PTE_P;
  80042035be:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042035c2:	48 c1 e8 15          	shr    $0x15,%rax
  80042035c6:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042035cb:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042035d2:	00 
  80042035d3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042035d7:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  80042035db:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042035df:	48 89 c7             	mov    %rax,%rdi
  80042035e2:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  80042035e9:	00 00 00 
  80042035ec:	ff d0                	callq  *%rax
  80042035ee:	48 83 c8 07          	or     $0x7,%rax
  80042035f2:	48 89 03             	mov    %rax,(%rbx)
				return KADDR((uintptr_t)((pte_t *)(PTE_ADDR(pgdir [PDX(va)])) + PTX(va)));
  80042035f5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042035f9:	48 c1 e8 0c          	shr    $0xc,%rax
  80042035fd:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203602:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203609:	00 
  800420360a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420360e:	48 c1 e8 15          	shr    $0x15,%rax
  8004203612:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203617:	48 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%rcx
  800420361e:	00 
  800420361f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203623:	48 01 c8             	add    %rcx,%rax
  8004203626:	48 8b 00             	mov    (%rax),%rax
  8004203629:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420362f:	48 01 d0             	add    %rdx,%rax
  8004203632:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004203636:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420363a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420363e:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  8004203641:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203644:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  800420364b:	00 00 00 
  800420364e:	48 8b 00             	mov    (%rax),%rax
  8004203651:	48 39 c2             	cmp    %rax,%rdx
  8004203654:	72 32                	jb     8004203688 <pgdir_walk+0x161>
  8004203656:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420365a:	48 89 c1             	mov    %rax,%rcx
  800420365d:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  8004203664:	00 00 00 
  8004203667:	be 7d 02 00 00       	mov    $0x27d,%esi
  800420366c:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004203673:	00 00 00 
  8004203676:	b8 00 00 00 00       	mov    $0x0,%eax
  800420367b:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004203682:	00 00 00 
  8004203685:	41 ff d0             	callq  *%r8
  8004203688:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420368f:	00 00 00 
  8004203692:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203696:	48 01 d0             	add    %rdx,%rax
  8004203699:	e9 aa 00 00 00       	jmpq   8004203748 <pgdir_walk+0x221>
			}else{
				return NULL;
  800420369e:	b8 00 00 00 00       	mov    $0x0,%eax
  80042036a3:	e9 a0 00 00 00       	jmpq   8004203748 <pgdir_walk+0x221>
			}
		} else if ((uint64_t)pte & PTE_P) {
  80042036a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042036ac:	83 e0 01             	and    $0x1,%eax
  80042036af:	48 85 c0             	test   %rax,%rax
  80042036b2:	0f 84 8b 00 00 00    	je     8004203743 <pgdir_walk+0x21c>
			return KADDR((uintptr_t)((pte_t *)PTE_ADDR(pte) + PTX(va)));
  80042036b8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042036bc:	48 c1 e8 0c          	shr    $0xc,%rax
  80042036c0:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042036c5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042036cc:	00 
  80042036cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042036d1:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042036d7:	48 01 d0             	add    %rdx,%rax
  80042036da:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042036de:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042036e2:	48 c1 e8 0c          	shr    $0xc,%rax
  80042036e6:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  80042036e9:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042036ec:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  80042036f3:	00 00 00 
  80042036f6:	48 8b 00             	mov    (%rax),%rax
  80042036f9:	48 39 c2             	cmp    %rax,%rdx
  80042036fc:	72 32                	jb     8004203730 <pgdir_walk+0x209>
  80042036fe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203702:	48 89 c1             	mov    %rax,%rcx
  8004203705:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  800420370c:	00 00 00 
  800420370f:	be 82 02 00 00       	mov    $0x282,%esi
  8004203714:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420371b:	00 00 00 
  800420371e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203723:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420372a:	00 00 00 
  800420372d:	41 ff d0             	callq  *%r8
  8004203730:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203737:	00 00 00 
  800420373a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420373e:	48 01 d0             	add    %rdx,%rax
  8004203741:	eb 05                	jmp    8004203748 <pgdir_walk+0x221>
		}
	}
	return NULL;
  8004203743:	b8 00 00 00 00       	mov    $0x0,%eax

}
  8004203748:	48 83 c4 58          	add    $0x58,%rsp
  800420374c:	5b                   	pop    %rbx
  800420374d:	5d                   	pop    %rbp
  800420374e:	c3                   	retq   

000000800420374f <boot_map_region>:
// mapped pages.
//
// Hint: the TA solution uses pml4e_walk
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
  800420374f:	55                   	push   %rbp
  8004203750:	48 89 e5             	mov    %rsp,%rbp
  8004203753:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004203757:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420375b:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420375f:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  8004203763:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
  8004203767:	44 89 45 8c          	mov    %r8d,-0x74(%rbp)

	uint64_t i,j;
	pdpe_t *pdpe;
	pde_t *pde;
	//cprintf("mapping %x at %x (size: %x)\n", la, pa, size);
	for (i = 0; i < size; i+=PGSIZE) {
  800420376b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004203772:	00 
  8004203773:	e9 aa 02 00 00       	jmpq   8004203a22 <boot_map_region+0x2d3>
		pte_t *pte      = pml4e_walk(pml4e, (void *)(la + i), 1);
  8004203778:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420377c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203780:	48 01 d0             	add    %rdx,%rax
  8004203783:	48 89 c1             	mov    %rax,%rcx
  8004203786:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420378a:	ba 01 00 00 00       	mov    $0x1,%edx
  800420378f:	48 89 ce             	mov    %rcx,%rsi
  8004203792:	48 89 c7             	mov    %rax,%rdi
  8004203795:	48 b8 29 30 20 04 80 	movabs $0x8004203029,%rax
  800420379c:	00 00 00 
  800420379f:	ff d0                	callq  *%rax
  80042037a1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		physaddr_t addr = pa + i;
  80042037a5:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042037a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042037ad:	48 01 d0             	add    %rdx,%rax
  80042037b0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if (pte != NULL) {
  80042037b4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042037b9:	74 23                	je     80042037de <boot_map_region+0x8f>
			*pte    = PTE_ADDR(addr)|perm|PTE_P;
  80042037bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042037bf:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042037c5:	48 89 c2             	mov    %rax,%rdx
  80042037c8:	8b 45 8c             	mov    -0x74(%rbp),%eax
  80042037cb:	48 98                	cltq   
  80042037cd:	48 09 d0             	or     %rdx,%rax
  80042037d0:	48 83 c8 01          	or     $0x1,%rax
  80042037d4:	48 89 c2             	mov    %rax,%rdx
  80042037d7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042037db:	48 89 10             	mov    %rdx,(%rax)
		}
		pml4e [PML4(la+i)]   = pml4e [PML4(la+i)]|perm|PTE_P;
  80042037de:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042037e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042037e6:	48 01 d0             	add    %rdx,%rax
  80042037e9:	48 c1 e8 27          	shr    $0x27,%rax
  80042037ed:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042037f2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042037f9:	00 
  80042037fa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042037fe:	48 01 d0             	add    %rdx,%rax
  8004203801:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004203805:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203809:	48 01 ca             	add    %rcx,%rdx
  800420380c:	48 c1 ea 27          	shr    $0x27,%rdx
  8004203810:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203816:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  800420381d:	00 
  800420381e:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203822:	48 01 ca             	add    %rcx,%rdx
  8004203825:	48 8b 0a             	mov    (%rdx),%rcx
  8004203828:	8b 55 8c             	mov    -0x74(%rbp),%edx
  800420382b:	48 63 d2             	movslq %edx,%rdx
  800420382e:	48 09 ca             	or     %rcx,%rdx
  8004203831:	48 83 ca 01          	or     $0x1,%rdx
  8004203835:	48 89 10             	mov    %rdx,(%rax)
		pdpe                 = (pdpe_t *)KADDR(PTE_ADDR(pml4e[PML4(la + i)]));
  8004203838:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420383c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203840:	48 01 d0             	add    %rdx,%rax
  8004203843:	48 c1 e8 27          	shr    $0x27,%rax
  8004203847:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420384c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203853:	00 
  8004203854:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203858:	48 01 d0             	add    %rdx,%rax
  800420385b:	48 8b 00             	mov    (%rax),%rax
  800420385e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203864:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203868:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420386c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203870:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004203873:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004203876:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  800420387d:	00 00 00 
  8004203880:	48 8b 00             	mov    (%rax),%rax
  8004203883:	48 39 c2             	cmp    %rax,%rdx
  8004203886:	72 32                	jb     80042038ba <boot_map_region+0x16b>
  8004203888:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420388c:	48 89 c1             	mov    %rax,%rcx
  800420388f:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  8004203896:	00 00 00 
  8004203899:	be a2 02 00 00       	mov    $0x2a2,%esi
  800420389e:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042038a5:	00 00 00 
  80042038a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042038ad:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042038b4:	00 00 00 
  80042038b7:	41 ff d0             	callq  *%r8
  80042038ba:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042038c1:	00 00 00 
  80042038c4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042038c8:	48 01 d0             	add    %rdx,%rax
  80042038cb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		pdpe[PDPE(la+i)]     = pdpe[PDPE(la+i)]|perm|PTE_P;
  80042038cf:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042038d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042038d7:	48 01 d0             	add    %rdx,%rax
  80042038da:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042038de:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042038e3:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042038ea:	00 
  80042038eb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042038ef:	48 01 d0             	add    %rdx,%rax
  80042038f2:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042038f6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042038fa:	48 01 ca             	add    %rcx,%rdx
  80042038fd:	48 c1 ea 1e          	shr    $0x1e,%rdx
  8004203901:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203907:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  800420390e:	00 
  800420390f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203913:	48 01 ca             	add    %rcx,%rdx
  8004203916:	48 8b 0a             	mov    (%rdx),%rcx
  8004203919:	8b 55 8c             	mov    -0x74(%rbp),%edx
  800420391c:	48 63 d2             	movslq %edx,%rdx
  800420391f:	48 09 ca             	or     %rcx,%rdx
  8004203922:	48 83 ca 01          	or     $0x1,%rdx
  8004203926:	48 89 10             	mov    %rdx,(%rax)
		pde                  = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(la+i)]));
  8004203929:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420392d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203931:	48 01 d0             	add    %rdx,%rax
  8004203934:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203938:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420393d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203944:	00 
  8004203945:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203949:	48 01 d0             	add    %rdx,%rax
  800420394c:	48 8b 00             	mov    (%rax),%rax
  800420394f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203955:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004203959:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420395d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203961:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004203964:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004203967:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  800420396e:	00 00 00 
  8004203971:	48 8b 00             	mov    (%rax),%rax
  8004203974:	48 39 c2             	cmp    %rax,%rdx
  8004203977:	72 32                	jb     80042039ab <boot_map_region+0x25c>
  8004203979:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420397d:	48 89 c1             	mov    %rax,%rcx
  8004203980:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  8004203987:	00 00 00 
  800420398a:	be a4 02 00 00       	mov    $0x2a4,%esi
  800420398f:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004203996:	00 00 00 
  8004203999:	b8 00 00 00 00       	mov    $0x0,%eax
  800420399e:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042039a5:	00 00 00 
  80042039a8:	41 ff d0             	callq  *%r8
  80042039ab:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042039b2:	00 00 00 
  80042039b5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042039b9:	48 01 d0             	add    %rdx,%rax
  80042039bc:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		pde[PDX(la+i)]       = pde[PDX(la+i)]|perm|PTE_P;
  80042039c0:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042039c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042039c8:	48 01 d0             	add    %rdx,%rax
  80042039cb:	48 c1 e8 15          	shr    $0x15,%rax
  80042039cf:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042039d4:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042039db:	00 
  80042039dc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042039e0:	48 01 d0             	add    %rdx,%rax
  80042039e3:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042039e7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042039eb:	48 01 ca             	add    %rcx,%rdx
  80042039ee:	48 c1 ea 15          	shr    $0x15,%rdx
  80042039f2:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  80042039f8:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  80042039ff:	00 
  8004203a00:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004203a04:	48 01 ca             	add    %rcx,%rdx
  8004203a07:	48 8b 0a             	mov    (%rdx),%rcx
  8004203a0a:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004203a0d:	48 63 d2             	movslq %edx,%rdx
  8004203a10:	48 09 ca             	or     %rcx,%rdx
  8004203a13:	48 83 ca 01          	or     $0x1,%rdx
  8004203a17:	48 89 10             	mov    %rdx,(%rax)

	uint64_t i,j;
	pdpe_t *pdpe;
	pde_t *pde;
	//cprintf("mapping %x at %x (size: %x)\n", la, pa, size);
	for (i = 0; i < size; i+=PGSIZE) {
  8004203a1a:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004203a21:	00 
  8004203a22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a26:	48 3b 45 98          	cmp    -0x68(%rbp),%rax
  8004203a2a:	0f 82 48 fd ff ff    	jb     8004203778 <boot_map_region+0x29>
		pdpe[PDPE(la+i)]     = pdpe[PDPE(la+i)]|perm|PTE_P;
		pde                  = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(la+i)]));
		pde[PDX(la+i)]       = pde[PDX(la+i)]|perm|PTE_P;
	}

}
  8004203a30:	90                   	nop
  8004203a31:	c9                   	leaveq 
  8004203a32:	c3                   	retq   

0000008004203a33 <page_insert>:
// Hint: The TA solution is implemented using pml4e_walk, page_remove,
// and page2pa.
//
int
page_insert(pml4e_t *pml4e, struct PageInfo *pp, void *va, int perm)
{
  8004203a33:	55                   	push   %rbp
  8004203a34:	48 89 e5             	mov    %rsp,%rbp
  8004203a37:	48 83 ec 60          	sub    $0x60,%rsp
  8004203a3b:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004203a3f:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004203a43:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  8004203a47:	89 4d a4             	mov    %ecx,-0x5c(%rbp)

	pdpe_t *pdpe;
	pde_t *pde;
	if (pml4e && pp) {
  8004203a4a:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004203a4f:	0f 84 4b 03 00 00    	je     8004203da0 <page_insert+0x36d>
  8004203a55:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004203a5a:	0f 84 40 03 00 00    	je     8004203da0 <page_insert+0x36d>
		pte_t *pte  = pml4e_walk(pml4e, va, 1);
  8004203a60:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004203a64:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203a68:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203a6d:	48 89 ce             	mov    %rcx,%rsi
  8004203a70:	48 89 c7             	mov    %rax,%rdi
  8004203a73:	48 b8 29 30 20 04 80 	movabs $0x8004203029,%rax
  8004203a7a:	00 00 00 
  8004203a7d:	ff d0                	callq  *%rax
  8004203a7f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (pte != NULL) {
  8004203a83:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203a88:	0f 84 0b 03 00 00    	je     8004203d99 <page_insert+0x366>
			pml4e [PML4(va)] = pml4e [PML4(va)]|(perm&(~PTE_AVAIL));
  8004203a8e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203a92:	48 c1 e8 27          	shr    $0x27,%rax
  8004203a96:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203a9b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203aa2:	00 
  8004203aa3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203aa7:	48 01 d0             	add    %rdx,%rax
  8004203aaa:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203aae:	48 c1 ea 27          	shr    $0x27,%rdx
  8004203ab2:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203ab8:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004203abf:	00 
  8004203ac0:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004203ac4:	48 01 ca             	add    %rcx,%rdx
  8004203ac7:	48 8b 0a             	mov    (%rdx),%rcx
  8004203aca:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004203acd:	80 e6 f1             	and    $0xf1,%dh
  8004203ad0:	48 63 d2             	movslq %edx,%rdx
  8004203ad3:	48 09 ca             	or     %rcx,%rdx
  8004203ad6:	48 89 10             	mov    %rdx,(%rax)
			pdpe = (pdpe_t *)KADDR(PTE_ADDR(pml4e[PML4(va)]));
  8004203ad9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203add:	48 c1 e8 27          	shr    $0x27,%rax
  8004203ae1:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203ae6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203aed:	00 
  8004203aee:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203af2:	48 01 d0             	add    %rdx,%rax
  8004203af5:	48 8b 00             	mov    (%rax),%rax
  8004203af8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203afe:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004203b02:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203b06:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203b0a:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004203b0d:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004203b10:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004203b17:	00 00 00 
  8004203b1a:	48 8b 00             	mov    (%rax),%rax
  8004203b1d:	48 39 c2             	cmp    %rax,%rdx
  8004203b20:	72 32                	jb     8004203b54 <page_insert+0x121>
  8004203b22:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203b26:	48 89 c1             	mov    %rax,%rcx
  8004203b29:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  8004203b30:	00 00 00 
  8004203b33:	be cd 02 00 00       	mov    $0x2cd,%esi
  8004203b38:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004203b3f:	00 00 00 
  8004203b42:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203b47:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004203b4e:	00 00 00 
  8004203b51:	41 ff d0             	callq  *%r8
  8004203b54:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203b5b:	00 00 00 
  8004203b5e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203b62:	48 01 d0             	add    %rdx,%rax
  8004203b65:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
			pdpe[PDPE(va)] = pdpe[PDPE(va)]|(perm&(~PTE_AVAIL));
  8004203b69:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203b6d:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203b71:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203b76:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203b7d:	00 
  8004203b7e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203b82:	48 01 d0             	add    %rdx,%rax
  8004203b85:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203b89:	48 c1 ea 1e          	shr    $0x1e,%rdx
  8004203b8d:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203b93:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004203b9a:	00 
  8004203b9b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203b9f:	48 01 ca             	add    %rcx,%rdx
  8004203ba2:	48 8b 0a             	mov    (%rdx),%rcx
  8004203ba5:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004203ba8:	80 e6 f1             	and    $0xf1,%dh
  8004203bab:	48 63 d2             	movslq %edx,%rdx
  8004203bae:	48 09 ca             	or     %rcx,%rdx
  8004203bb1:	48 89 10             	mov    %rdx,(%rax)
			pde = (pde_t *)KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004203bb4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203bb8:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203bbc:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203bc1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203bc8:	00 
  8004203bc9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203bcd:	48 01 d0             	add    %rdx,%rax
  8004203bd0:	48 8b 00             	mov    (%rax),%rax
  8004203bd3:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203bd9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004203bdd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203be1:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203be5:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  8004203be8:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203beb:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004203bf2:	00 00 00 
  8004203bf5:	48 8b 00             	mov    (%rax),%rax
  8004203bf8:	48 39 c2             	cmp    %rax,%rdx
  8004203bfb:	72 32                	jb     8004203c2f <page_insert+0x1fc>
  8004203bfd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203c01:	48 89 c1             	mov    %rax,%rcx
  8004203c04:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  8004203c0b:	00 00 00 
  8004203c0e:	be cf 02 00 00       	mov    $0x2cf,%esi
  8004203c13:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004203c1a:	00 00 00 
  8004203c1d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203c22:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004203c29:	00 00 00 
  8004203c2c:	41 ff d0             	callq  *%r8
  8004203c2f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203c36:	00 00 00 
  8004203c39:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203c3d:	48 01 d0             	add    %rdx,%rax
  8004203c40:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			pde[PDX(va)] = pde[PDX(va)]|(perm&(~PTE_AVAIL));
  8004203c44:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203c48:	48 c1 e8 15          	shr    $0x15,%rax
  8004203c4c:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203c51:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203c58:	00 
  8004203c59:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203c5d:	48 01 d0             	add    %rdx,%rax
  8004203c60:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203c64:	48 c1 ea 15          	shr    $0x15,%rdx
  8004203c68:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203c6e:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004203c75:	00 
  8004203c76:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004203c7a:	48 01 ca             	add    %rcx,%rdx
  8004203c7d:	48 8b 0a             	mov    (%rdx),%rcx
  8004203c80:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004203c83:	80 e6 f1             	and    $0xf1,%dh
  8004203c86:	48 63 d2             	movslq %edx,%rdx
  8004203c89:	48 09 ca             	or     %rcx,%rdx
  8004203c8c:	48 89 10             	mov    %rdx,(%rax)
			if ((*pte & PTE_P) && (page2pa(pp) == PTE_ADDR(*pte))) {
  8004203c8f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c93:	48 8b 00             	mov    (%rax),%rax
  8004203c96:	83 e0 01             	and    $0x1,%eax
  8004203c99:	48 85 c0             	test   %rax,%rax
  8004203c9c:	74 72                	je     8004203d10 <page_insert+0x2dd>
  8004203c9e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203ca2:	48 89 c7             	mov    %rax,%rdi
  8004203ca5:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  8004203cac:	00 00 00 
  8004203caf:	ff d0                	callq  *%rax
  8004203cb1:	48 89 c2             	mov    %rax,%rdx
  8004203cb4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203cb8:	48 8b 00             	mov    (%rax),%rax
  8004203cbb:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203cc1:	48 39 c2             	cmp    %rax,%rdx
  8004203cc4:	75 4a                	jne    8004203d10 <page_insert+0x2dd>
				*pte    = PTE_ADDR(*pte)|perm|PTE_P;
  8004203cc6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203cca:	48 8b 00             	mov    (%rax),%rax
  8004203ccd:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203cd3:	48 89 c2             	mov    %rax,%rdx
  8004203cd6:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004203cd9:	48 98                	cltq   
  8004203cdb:	48 09 d0             	or     %rdx,%rax
  8004203cde:	48 83 c8 01          	or     $0x1,%rax
  8004203ce2:	48 89 c2             	mov    %rax,%rdx
  8004203ce5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ce9:	48 89 10             	mov    %rdx,(%rax)
				tlb_invalidate(pml4e, va);
  8004203cec:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203cf0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203cf4:	48 89 d6             	mov    %rdx,%rsi
  8004203cf7:	48 89 c7             	mov    %rax,%rdi
  8004203cfa:	48 b8 a6 3e 20 04 80 	movabs $0x8004203ea6,%rax
  8004203d01:	00 00 00 
  8004203d04:	ff d0                	callq  *%rax
				return 0;
  8004203d06:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203d0b:	e9 95 00 00 00       	jmpq   8004203da5 <page_insert+0x372>
			} else if (*pte & PTE_P) {
  8004203d10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d14:	48 8b 00             	mov    (%rax),%rax
  8004203d17:	83 e0 01             	and    $0x1,%eax
  8004203d1a:	48 85 c0             	test   %rax,%rax
  8004203d1d:	74 1a                	je     8004203d39 <page_insert+0x306>
				page_remove(pml4e, va);
  8004203d1f:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203d23:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203d27:	48 89 d6             	mov    %rdx,%rsi
  8004203d2a:	48 89 c7             	mov    %rax,%rdi
  8004203d2d:	48 b8 32 3e 20 04 80 	movabs $0x8004203e32,%rax
  8004203d34:	00 00 00 
  8004203d37:	ff d0                	callq  *%rax
			}
			pp->pp_ref  += 1;
  8004203d39:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203d3d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203d41:	8d 50 01             	lea    0x1(%rax),%edx
  8004203d44:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203d48:	66 89 50 08          	mov    %dx,0x8(%rax)
			*pte    = page2pa(pp)|perm|PTE_P;
  8004203d4c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203d50:	48 89 c7             	mov    %rax,%rdi
  8004203d53:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  8004203d5a:	00 00 00 
  8004203d5d:	ff d0                	callq  *%rax
  8004203d5f:	48 89 c2             	mov    %rax,%rdx
  8004203d62:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004203d65:	48 98                	cltq   
  8004203d67:	48 09 d0             	or     %rdx,%rax
  8004203d6a:	48 83 c8 01          	or     $0x1,%rax
  8004203d6e:	48 89 c2             	mov    %rax,%rdx
  8004203d71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d75:	48 89 10             	mov    %rdx,(%rax)
			tlb_invalidate(pml4e, va);
  8004203d78:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004203d7c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203d80:	48 89 d6             	mov    %rdx,%rsi
  8004203d83:	48 89 c7             	mov    %rax,%rdi
  8004203d86:	48 b8 a6 3e 20 04 80 	movabs $0x8004203ea6,%rax
  8004203d8d:	00 00 00 
  8004203d90:	ff d0                	callq  *%rax
			return 0;
  8004203d92:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203d97:	eb 0c                	jmp    8004203da5 <page_insert+0x372>
		}else
			return -E_NO_MEM;
  8004203d99:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004203d9e:	eb 05                	jmp    8004203da5 <page_insert+0x372>
	}
	return -E_NO_MEM;
  8004203da0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax

}
  8004203da5:	c9                   	leaveq 
  8004203da6:	c3                   	retq   

0000008004203da7 <page_lookup>:
//
// Hint: the TA solution uses pml4e_walk and pa2page.
//
struct PageInfo *
page_lookup(pml4e_t *pml4e, void *va, pte_t **pte_store)
{
  8004203da7:	55                   	push   %rbp
  8004203da8:	48 89 e5             	mov    %rsp,%rbp
  8004203dab:	48 83 ec 30          	sub    $0x30,%rsp
  8004203daf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203db3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004203db7:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	if (pml4e != NULL) {
  8004203dbb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203dc0:	74 69                	je     8004203e2b <page_lookup+0x84>
		pte_t *pte  = pml4e_walk(pml4e, va, 0);
  8004203dc2:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203dc6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203dca:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203dcf:	48 89 ce             	mov    %rcx,%rsi
  8004203dd2:	48 89 c7             	mov    %rax,%rdi
  8004203dd5:	48 b8 29 30 20 04 80 	movabs $0x8004203029,%rax
  8004203ddc:	00 00 00 
  8004203ddf:	ff d0                	callq  *%rax
  8004203de1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (pte != NULL && (*pte & PTE_P)) {
  8004203de5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203dea:	74 3f                	je     8004203e2b <page_lookup+0x84>
  8004203dec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203df0:	48 8b 00             	mov    (%rax),%rax
  8004203df3:	83 e0 01             	and    $0x1,%eax
  8004203df6:	48 85 c0             	test   %rax,%rax
  8004203df9:	74 30                	je     8004203e2b <page_lookup+0x84>
			if (pte_store)
  8004203dfb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004203e00:	74 0b                	je     8004203e0d <page_lookup+0x66>
				*pte_store  = pte;
  8004203e02:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203e06:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203e0a:	48 89 10             	mov    %rdx,(%rax)
			return pa2page(PTE_ADDR(*pte));
  8004203e0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e11:	48 8b 00             	mov    (%rax),%rax
  8004203e14:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203e1a:	48 89 c7             	mov    %rax,%rdi
  8004203e1d:	48 b8 62 1b 20 04 80 	movabs $0x8004201b62,%rax
  8004203e24:	00 00 00 
  8004203e27:	ff d0                	callq  *%rax
  8004203e29:	eb 05                	jmp    8004203e30 <page_lookup+0x89>
		}
	}
	return NULL;
  8004203e2b:	b8 00 00 00 00       	mov    $0x0,%eax

}
  8004203e30:	c9                   	leaveq 
  8004203e31:	c3                   	retq   

0000008004203e32 <page_remove>:
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pml4e_t *pml4e, void *va)
{
  8004203e32:	55                   	push   %rbp
  8004203e33:	48 89 e5             	mov    %rsp,%rbp
  8004203e36:	48 83 ec 20          	sub    $0x20,%rsp
  8004203e3a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203e3e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	pte_t *pte;
	struct PageInfo *page   = page_lookup(pml4e, va, &pte);
  8004203e42:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8004203e46:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203e4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203e4e:	48 89 ce             	mov    %rcx,%rsi
  8004203e51:	48 89 c7             	mov    %rax,%rdi
  8004203e54:	48 b8 a7 3d 20 04 80 	movabs $0x8004203da7,%rax
  8004203e5b:	00 00 00 
  8004203e5e:	ff d0                	callq  *%rax
  8004203e60:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (page != NULL) {
  8004203e64:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203e69:	74 38                	je     8004203ea3 <page_remove+0x71>
		tlb_invalidate(pml4e, va);
  8004203e6b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203e6f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203e73:	48 89 d6             	mov    %rdx,%rsi
  8004203e76:	48 89 c7             	mov    %rax,%rdi
  8004203e79:	48 b8 a6 3e 20 04 80 	movabs $0x8004203ea6,%rax
  8004203e80:	00 00 00 
  8004203e83:	ff d0                	callq  *%rax
		page_decref(page);
  8004203e85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e89:	48 89 c7             	mov    %rax,%rdi
  8004203e8c:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  8004203e93:	00 00 00 
  8004203e96:	ff d0                	callq  *%rax
		*pte    = 0;
  8004203e98:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203e9c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	}

}
  8004203ea3:	90                   	nop
  8004203ea4:	c9                   	leaveq 
  8004203ea5:	c3                   	retq   

0000008004203ea6 <tlb_invalidate>:
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
void
tlb_invalidate(pml4e_t *pml4e, void *va)
{
  8004203ea6:	55                   	push   %rbp
  8004203ea7:	48 89 e5             	mov    %rsp,%rbp
  8004203eaa:	48 83 ec 20          	sub    $0x20,%rsp
  8004203eae:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203eb2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Flush the entry only if we're modifying the current address space.

	assert(pml4e!=NULL);
  8004203eb6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203ebb:	75 35                	jne    8004203ef2 <tlb_invalidate+0x4c>
  8004203ebd:	48 b9 ef f5 21 04 80 	movabs $0x800421f5ef,%rcx
  8004203ec4:	00 00 00 
  8004203ec7:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004203ece:	00 00 00 
  8004203ed1:	be 24 03 00 00       	mov    $0x324,%esi
  8004203ed6:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004203edd:	00 00 00 
  8004203ee0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203ee5:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004203eec:	00 00 00 
  8004203eef:	41 ff d0             	callq  *%r8
	if (!curenv || curenv->env_pml4e == pml4e)
  8004203ef2:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  8004203ef9:	00 00 00 
  8004203efc:	ff d0                	callq  *%rax
  8004203efe:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  8004203f05:	00 00 00 
  8004203f08:	48 98                	cltq   
  8004203f0a:	48 c1 e0 03          	shl    $0x3,%rax
  8004203f0e:	48 89 c1             	mov    %rax,%rcx
  8004203f11:	48 c1 e1 04          	shl    $0x4,%rcx
  8004203f15:	48 01 c8             	add    %rcx,%rax
  8004203f18:	48 01 d0             	add    %rdx,%rax
  8004203f1b:	48 83 c0 08          	add    $0x8,%rax
  8004203f1f:	48 8b 00             	mov    (%rax),%rax
  8004203f22:	48 85 c0             	test   %rax,%rax
  8004203f25:	74 3d                	je     8004203f64 <tlb_invalidate+0xbe>
  8004203f27:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  8004203f2e:	00 00 00 
  8004203f31:	ff d0                	callq  *%rax
  8004203f33:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  8004203f3a:	00 00 00 
  8004203f3d:	48 98                	cltq   
  8004203f3f:	48 c1 e0 03          	shl    $0x3,%rax
  8004203f43:	48 89 c1             	mov    %rax,%rcx
  8004203f46:	48 c1 e1 04          	shl    $0x4,%rcx
  8004203f4a:	48 01 c8             	add    %rcx,%rax
  8004203f4d:	48 01 d0             	add    %rdx,%rax
  8004203f50:	48 83 c0 08          	add    $0x8,%rax
  8004203f54:	48 8b 00             	mov    (%rax),%rax
  8004203f57:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004203f5e:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004203f62:	75 0f                	jne    8004203f73 <tlb_invalidate+0xcd>
  8004203f64:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203f68:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void 
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
  8004203f6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f70:	0f 01 38             	invlpg (%rax)
		invlpg(va);

}
  8004203f73:	90                   	nop
  8004203f74:	c9                   	leaveq 
  8004203f75:	c3                   	retq   

0000008004203f76 <mmio_map_region>:
// location.  Return the base of the reserved region.  size does *not*
// have to be multiple of PGSIZE.
//
void *
mmio_map_region(physaddr_t pa, size_t size)
{
  8004203f76:	55                   	push   %rbp
  8004203f77:	48 89 e5             	mov    %rsp,%rbp
  8004203f7a:	48 83 ec 30          	sub    $0x30,%rsp
  8004203f7e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004203f82:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	//
	// Hint: The staff solution uses boot_map_region.
	//
	// Your code here:

	uintptr_t va = base;
  8004203f86:	48 b8 e0 65 23 04 80 	movabs $0x80042365e0,%rax
  8004203f8d:	00 00 00 
  8004203f90:	48 8b 00             	mov    (%rax),%rax
  8004203f93:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	size = ROUNDUP(size, PGSIZE);
  8004203f97:	48 c7 45 f0 00 10 00 	movq   $0x1000,-0x10(%rbp)
  8004203f9e:	00 
  8004203f9f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203fa3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203fa7:	48 01 d0             	add    %rdx,%rax
  8004203faa:	48 83 e8 01          	sub    $0x1,%rax
  8004203fae:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004203fb2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203fb6:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203fbb:	48 f7 75 f0          	divq   -0x10(%rbp)
  8004203fbf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203fc3:	48 29 d0             	sub    %rdx,%rax
  8004203fc6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	base += size;
  8004203fca:	48 b8 e0 65 23 04 80 	movabs $0x80042365e0,%rax
  8004203fd1:	00 00 00 
  8004203fd4:	48 8b 10             	mov    (%rax),%rdx
  8004203fd7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203fdb:	48 01 c2             	add    %rax,%rdx
  8004203fde:	48 b8 e0 65 23 04 80 	movabs $0x80042365e0,%rax
  8004203fe5:	00 00 00 
  8004203fe8:	48 89 10             	mov    %rdx,(%rax)
	if (base >= MMIOLIM)
  8004203feb:	48 b8 e0 65 23 04 80 	movabs $0x80042365e0,%rax
  8004203ff2:	00 00 00 
  8004203ff5:	48 8b 10             	mov    (%rax),%rdx
  8004203ff8:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004203fff:	00 00 00 
  8004204002:	48 39 c2             	cmp    %rax,%rdx
  8004204005:	76 2a                	jbe    8004204031 <mmio_map_region+0xbb>
		panic("MMIO mappings exceeded MMIOLIM");
  8004204007:	48 ba 00 f6 21 04 80 	movabs $0x800421f600,%rdx
  800420400e:	00 00 00 
  8004204011:	be 51 03 00 00       	mov    $0x351,%esi
  8004204016:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420401d:	00 00 00 
  8004204020:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204025:	48 b9 d3 04 20 04 80 	movabs $0x80042004d3,%rcx
  800420402c:	00 00 00 
  800420402f:	ff d1                	callq  *%rcx
	boot_map_region(boot_pml4e, va, size, pa, PTE_P|PTE_W|PTE_PWT|PTE_PCD);
  8004204031:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004204038:	00 00 00 
  800420403b:	48 8b 00             	mov    (%rax),%rax
  800420403e:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004204042:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204046:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420404a:	41 b8 1b 00 00 00    	mov    $0x1b,%r8d
  8004204050:	48 89 c7             	mov    %rax,%rdi
  8004204053:	48 b8 4f 37 20 04 80 	movabs $0x800420374f,%rax
  800420405a:	00 00 00 
  800420405d:	ff d0                	callq  *%rax
	return (void*) va;
  800420405f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax

}
  8004204063:	c9                   	leaveq 
  8004204064:	c3                   	retq   

0000008004204065 <user_mem_check>:
// Returns 0 if the user program can access this range of addresses,
// and -E_FAULT otherwise.
//
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
  8004204065:	55                   	push   %rbp
  8004204066:	48 89 e5             	mov    %rsp,%rbp
  8004204069:	48 83 ec 40          	sub    $0x40,%rsp
  800420406d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004204071:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004204075:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004204079:	89 4d c4             	mov    %ecx,-0x3c(%rbp)

	const void *endva = (const void *) ((uintptr_t) va + len);
  800420407c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204080:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204084:	48 01 d0             	add    %rdx,%rax
  8004204087:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	pte_t *ptep;
	if ((uintptr_t) endva >= ULIM || va > endva) {
  800420408b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420408f:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004204096:	00 00 00 
  8004204099:	48 39 c2             	cmp    %rax,%rdx
  800420409c:	77 0e                	ja     80042040ac <user_mem_check+0x47>
  800420409e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042040a2:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042040a6:	0f 86 bd 00 00 00    	jbe    8004204169 <user_mem_check+0x104>
		user_mem_check_addr = (uintptr_t) va;
  80042040ac:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042040b0:	48 b8 40 02 4e 04 80 	movabs $0x80044e0240,%rax
  80042040b7:	00 00 00 
  80042040ba:	48 89 10             	mov    %rdx,(%rax)
		return -E_FAULT;
  80042040bd:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  80042040c2:	e9 b5 00 00 00       	jmpq   800420417c <user_mem_check+0x117>
	}
	while(va<endva){
		ptep = pml4e_walk(env->env_pml4e,va,0);
  80042040c7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042040cb:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042040d2:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  80042040d6:	ba 00 00 00 00       	mov    $0x0,%edx
  80042040db:	48 89 ce             	mov    %rcx,%rsi
  80042040de:	48 89 c7             	mov    %rax,%rdi
  80042040e1:	48 b8 29 30 20 04 80 	movabs $0x8004203029,%rax
  80042040e8:	00 00 00 
  80042040eb:	ff d0                	callq  *%rax
  80042040ed:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if (!ptep || (*ptep & (perm | PTE_P)) != (perm | PTE_P)) {
  80042040f1:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042040f6:	74 1f                	je     8004204117 <user_mem_check+0xb2>
  80042040f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042040fc:	48 8b 10             	mov    (%rax),%rdx
  80042040ff:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004204102:	83 c8 01             	or     $0x1,%eax
  8004204105:	48 98                	cltq   
  8004204107:	48 21 c2             	and    %rax,%rdx
  800420410a:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420410d:	83 c8 01             	or     $0x1,%eax
  8004204110:	48 98                	cltq   
  8004204112:	48 39 c2             	cmp    %rax,%rdx
  8004204115:	74 18                	je     800420412f <user_mem_check+0xca>
			user_mem_check_addr = (uintptr_t) va;
  8004204117:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420411b:	48 b8 40 02 4e 04 80 	movabs $0x80044e0240,%rax
  8004204122:	00 00 00 
  8004204125:	48 89 10             	mov    %rdx,(%rax)
			return -E_FAULT;
  8004204128:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  800420412d:	eb 4d                	jmp    800420417c <user_mem_check+0x117>
		}
		va = ROUNDUP(va+1,PGSIZE);
  800420412f:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004204136:	00 
  8004204137:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420413b:	48 83 c0 01          	add    $0x1,%rax
  800420413f:	48 89 c2             	mov    %rax,%rdx
  8004204142:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204146:	48 01 d0             	add    %rdx,%rax
  8004204149:	48 83 e8 01          	sub    $0x1,%rax
  800420414d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204151:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204155:	ba 00 00 00 00       	mov    $0x0,%edx
  800420415a:	48 f7 75 e8          	divq   -0x18(%rbp)
  800420415e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204162:	48 29 d0             	sub    %rdx,%rax
  8004204165:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	pte_t *ptep;
	if ((uintptr_t) endva >= ULIM || va > endva) {
		user_mem_check_addr = (uintptr_t) va;
		return -E_FAULT;
	}
	while(va<endva){
  8004204169:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420416d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204171:	0f 82 50 ff ff ff    	jb     80042040c7 <user_mem_check+0x62>
			return -E_FAULT;
		}
		va = ROUNDUP(va+1,PGSIZE);
	}

	return 0;
  8004204177:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420417c:	c9                   	leaveq 
  800420417d:	c3                   	retq   

000000800420417e <user_mem_assert>:
// If it cannot, 'env' is destroyed and, if env is the current
// environment, this function will not return.
//
void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
  800420417e:	55                   	push   %rbp
  800420417f:	48 89 e5             	mov    %rsp,%rbp
  8004204182:	48 83 ec 20          	sub    $0x20,%rsp
  8004204186:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420418a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420418e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004204192:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
  8004204195:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004204198:	83 c8 04             	or     $0x4,%eax
  800420419b:	89 c1                	mov    %eax,%ecx
  800420419d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042041a1:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042041a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042041a9:	48 89 c7             	mov    %rax,%rdi
  80042041ac:	48 b8 65 40 20 04 80 	movabs $0x8004204065,%rax
  80042041b3:	00 00 00 
  80042041b6:	ff d0                	callq  *%rax
  80042041b8:	85 c0                	test   %eax,%eax
  80042041ba:	79 47                	jns    8004204203 <user_mem_assert+0x85>
		cprintf("[%08x] user_mem_check assertion failure for "
  80042041bc:	48 b8 40 02 4e 04 80 	movabs $0x80044e0240,%rax
  80042041c3:	00 00 00 
  80042041c6:	48 8b 10             	mov    (%rax),%rdx
  80042041c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042041cd:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042041d3:	89 c6                	mov    %eax,%esi
  80042041d5:	48 bf 20 f6 21 04 80 	movabs $0x800421f620,%rdi
  80042041dc:	00 00 00 
  80042041df:	b8 00 00 00 00       	mov    $0x0,%eax
  80042041e4:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  80042041eb:	00 00 00 
  80042041ee:	ff d1                	callq  *%rcx
			"va %08x\n", env->env_id, user_mem_check_addr);
		env_destroy(env);	// may not return
  80042041f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042041f4:	48 89 c7             	mov    %rax,%rdi
  80042041f7:	48 b8 81 95 20 04 80 	movabs $0x8004209581,%rax
  80042041fe:	00 00 00 
  8004204201:	ff d0                	callq  *%rax
	}
}
  8004204203:	90                   	nop
  8004204204:	c9                   	leaveq 
  8004204205:	c3                   	retq   

0000008004204206 <check_page_free_list>:
// Check that the pages on the page_free_list are reasonable.
//

static void
check_page_free_list(bool only_low_memory)
{
  8004204206:	55                   	push   %rbp
  8004204207:	48 89 e5             	mov    %rsp,%rbp
  800420420a:	48 83 ec 60          	sub    $0x60,%rsp
  800420420e:	89 f8                	mov    %edi,%eax
  8004204210:	88 45 ac             	mov    %al,-0x54(%rbp)
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
  8004204213:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004204217:	74 07                	je     8004204220 <check_page_free_list+0x1a>
  8004204219:	b8 01 00 00 00       	mov    $0x1,%eax
  800420421e:	eb 05                	jmp    8004204225 <check_page_free_list+0x1f>
  8004204220:	b8 00 02 00 00       	mov    $0x200,%eax
  8004204225:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	uint64_t nfree_basemem = 0, nfree_extmem = 0;
  8004204228:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420422f:	00 
  8004204230:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204237:	00 
	char *first_free_page;

	if (!page_free_list)
  8004204238:	48 b8 38 02 4e 04 80 	movabs $0x80044e0238,%rax
  800420423f:	00 00 00 
  8004204242:	48 8b 00             	mov    (%rax),%rax
  8004204245:	48 85 c0             	test   %rax,%rax
  8004204248:	75 2a                	jne    8004204274 <check_page_free_list+0x6e>
		panic("'page_free_list' is a null pointer!");
  800420424a:	48 ba 58 f6 21 04 80 	movabs $0x800421f658,%rdx
  8004204251:	00 00 00 
  8004204254:	be a7 03 00 00       	mov    $0x3a7,%esi
  8004204259:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204260:	00 00 00 
  8004204263:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204268:	48 b9 d3 04 20 04 80 	movabs $0x80042004d3,%rcx
  800420426f:	00 00 00 
  8004204272:	ff d1                	callq  *%rcx

	if (only_low_memory) {
  8004204274:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004204278:	0f 84 a9 00 00 00    	je     8004204327 <check_page_free_list+0x121>
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
  800420427e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8004204282:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004204286:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  800420428a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  800420428e:	48 b8 38 02 4e 04 80 	movabs $0x80044e0238,%rax
  8004204295:	00 00 00 
  8004204298:	48 8b 00             	mov    (%rax),%rax
  800420429b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420429f:	eb 58                	jmp    80042042f9 <check_page_free_list+0xf3>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
  80042042a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042042a5:	48 89 c7             	mov    %rax,%rdi
  80042042a8:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  80042042af:	00 00 00 
  80042042b2:	ff d0                	callq  *%rax
  80042042b4:	48 c1 e8 15          	shr    $0x15,%rax
  80042042b8:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042042bd:	48 89 c2             	mov    %rax,%rdx
  80042042c0:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042042c3:	48 39 c2             	cmp    %rax,%rdx
  80042042c6:	0f 93 c0             	setae  %al
  80042042c9:	0f b6 c0             	movzbl %al,%eax
  80042042cc:	89 45 e0             	mov    %eax,-0x20(%rbp)
			*tp[pagetype] = pp;
  80042042cf:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042042d2:	48 98                	cltq   
  80042042d4:	48 8b 44 c5 b0       	mov    -0x50(%rbp,%rax,8),%rax
  80042042d9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042042dd:	48 89 10             	mov    %rdx,(%rax)
			tp[pagetype] = &pp->pp_link;
  80042042e0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042042e4:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042042e7:	48 98                	cltq   
  80042042e9:	48 89 54 c5 b0       	mov    %rdx,-0x50(%rbp,%rax,8)
	if (only_low_memory) {
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042042ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042042f2:	48 8b 00             	mov    (%rax),%rax
  80042042f5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042042f9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042042fe:	75 a1                	jne    80042042a1 <check_page_free_list+0x9b>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
			*tp[pagetype] = pp;
			tp[pagetype] = &pp->pp_link;
		}
		*tp[1] = 0;
  8004204300:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004204304:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		*tp[0] = pp2;
  800420430b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420430f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004204313:	48 89 10             	mov    %rdx,(%rax)
		page_free_list = pp1;
  8004204316:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420431a:	48 b8 38 02 4e 04 80 	movabs $0x80044e0238,%rax
  8004204321:	00 00 00 
  8004204324:	48 89 10             	mov    %rdx,(%rax)
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004204327:	48 b8 38 02 4e 04 80 	movabs $0x80044e0238,%rax
  800420432e:	00 00 00 
  8004204331:	48 8b 00             	mov    (%rax),%rax
  8004204334:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204338:	eb 5e                	jmp    8004204398 <check_page_free_list+0x192>
		if (PDX(page2pa(pp)) < pdx_limit)
  800420433a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420433e:	48 89 c7             	mov    %rax,%rdi
  8004204341:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  8004204348:	00 00 00 
  800420434b:	ff d0                	callq  *%rax
  800420434d:	48 c1 e8 15          	shr    $0x15,%rax
  8004204351:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204356:	48 89 c2             	mov    %rax,%rdx
  8004204359:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420435c:	48 39 c2             	cmp    %rax,%rdx
  800420435f:	73 2c                	jae    800420438d <check_page_free_list+0x187>
			memset(page2kva(pp), 0x97, 128);
  8004204361:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204365:	48 89 c7             	mov    %rax,%rdi
  8004204368:	48 b8 d3 1b 20 04 80 	movabs $0x8004201bd3,%rax
  800420436f:	00 00 00 
  8004204372:	ff d0                	callq  *%rax
  8004204374:	ba 80 00 00 00       	mov    $0x80,%edx
  8004204379:	be 97 00 00 00       	mov    $0x97,%esi
  800420437e:	48 89 c7             	mov    %rax,%rdi
  8004204381:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  8004204388:	00 00 00 
  800420438b:	ff d0                	callq  *%rax
		page_free_list = pp1;
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  800420438d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204391:	48 8b 00             	mov    (%rax),%rax
  8004204394:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204398:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420439d:	75 9b                	jne    800420433a <check_page_free_list+0x134>
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
  800420439f:	bf 00 00 00 00       	mov    $0x0,%edi
  80042043a4:	48 b8 fa 24 20 04 80 	movabs $0x80042024fa,%rax
  80042043ab:	00 00 00 
  80042043ae:	ff d0                	callq  *%rax
  80042043b0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042043b4:	48 b8 38 02 4e 04 80 	movabs $0x80044e0238,%rax
  80042043bb:	00 00 00 
  80042043be:	48 8b 00             	mov    (%rax),%rax
  80042043c1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042043c5:	e9 20 03 00 00       	jmpq   80042046ea <check_page_free_list+0x4e4>
		// check that we didn't corrupt the free list itself
		assert(pp >= pages);
  80042043ca:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  80042043d1:	00 00 00 
  80042043d4:	48 8b 00             	mov    (%rax),%rax
  80042043d7:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042043db:	73 35                	jae    8004204412 <check_page_free_list+0x20c>
  80042043dd:	48 b9 7c f6 21 04 80 	movabs $0x800421f67c,%rcx
  80042043e4:	00 00 00 
  80042043e7:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042043ee:	00 00 00 
  80042043f1:	be c1 03 00 00       	mov    $0x3c1,%esi
  80042043f6:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042043fd:	00 00 00 
  8004204400:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204405:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420440c:	00 00 00 
  800420440f:	41 ff d0             	callq  *%r8
		assert(pp < pages + npages);
  8004204412:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  8004204419:	00 00 00 
  800420441c:	48 8b 10             	mov    (%rax),%rdx
  800420441f:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004204426:	00 00 00 
  8004204429:	48 8b 00             	mov    (%rax),%rax
  800420442c:	48 c1 e0 04          	shl    $0x4,%rax
  8004204430:	48 01 d0             	add    %rdx,%rax
  8004204433:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204437:	77 35                	ja     800420446e <check_page_free_list+0x268>
  8004204439:	48 b9 88 f6 21 04 80 	movabs $0x800421f688,%rcx
  8004204440:	00 00 00 
  8004204443:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  800420444a:	00 00 00 
  800420444d:	be c2 03 00 00       	mov    $0x3c2,%esi
  8004204452:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204459:	00 00 00 
  800420445c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204461:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204468:	00 00 00 
  800420446b:	41 ff d0             	callq  *%r8
		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
  800420446e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204472:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  8004204479:	00 00 00 
  800420447c:	48 8b 00             	mov    (%rax),%rax
  800420447f:	48 29 c2             	sub    %rax,%rdx
  8004204482:	48 89 d0             	mov    %rdx,%rax
  8004204485:	83 e0 0f             	and    $0xf,%eax
  8004204488:	48 85 c0             	test   %rax,%rax
  800420448b:	74 35                	je     80042044c2 <check_page_free_list+0x2bc>
  800420448d:	48 b9 a0 f6 21 04 80 	movabs $0x800421f6a0,%rcx
  8004204494:	00 00 00 
  8004204497:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  800420449e:	00 00 00 
  80042044a1:	be c3 03 00 00       	mov    $0x3c3,%esi
  80042044a6:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042044ad:	00 00 00 
  80042044b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042044b5:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042044bc:	00 00 00 
  80042044bf:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp) != 0);
  80042044c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042044c6:	48 89 c7             	mov    %rax,%rdi
  80042044c9:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  80042044d0:	00 00 00 
  80042044d3:	ff d0                	callq  *%rax
  80042044d5:	48 85 c0             	test   %rax,%rax
  80042044d8:	75 35                	jne    800420450f <check_page_free_list+0x309>
  80042044da:	48 b9 d2 f6 21 04 80 	movabs $0x800421f6d2,%rcx
  80042044e1:	00 00 00 
  80042044e4:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042044eb:	00 00 00 
  80042044ee:	be c6 03 00 00       	mov    $0x3c6,%esi
  80042044f3:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042044fa:	00 00 00 
  80042044fd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204502:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204509:	00 00 00 
  800420450c:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != IOPHYSMEM);
  800420450f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204513:	48 89 c7             	mov    %rax,%rdi
  8004204516:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  800420451d:	00 00 00 
  8004204520:	ff d0                	callq  *%rax
  8004204522:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004204528:	75 35                	jne    800420455f <check_page_free_list+0x359>
  800420452a:	48 b9 e3 f6 21 04 80 	movabs $0x800421f6e3,%rcx
  8004204531:	00 00 00 
  8004204534:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  800420453b:	00 00 00 
  800420453e:	be c7 03 00 00       	mov    $0x3c7,%esi
  8004204543:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420454a:	00 00 00 
  800420454d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204552:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204559:	00 00 00 
  800420455c:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
  800420455f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204563:	48 89 c7             	mov    %rax,%rdi
  8004204566:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  800420456d:	00 00 00 
  8004204570:	ff d0                	callq  *%rax
  8004204572:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004204578:	75 35                	jne    80042045af <check_page_free_list+0x3a9>
  800420457a:	48 b9 00 f7 21 04 80 	movabs $0x800421f700,%rcx
  8004204581:	00 00 00 
  8004204584:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  800420458b:	00 00 00 
  800420458e:	be c8 03 00 00       	mov    $0x3c8,%esi
  8004204593:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420459a:	00 00 00 
  800420459d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045a2:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042045a9:	00 00 00 
  80042045ac:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM);
  80042045af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042045b3:	48 89 c7             	mov    %rax,%rdi
  80042045b6:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  80042045bd:	00 00 00 
  80042045c0:	ff d0                	callq  *%rax
  80042045c2:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  80042045c8:	75 35                	jne    80042045ff <check_page_free_list+0x3f9>
  80042045ca:	48 b9 23 f7 21 04 80 	movabs $0x800421f723,%rcx
  80042045d1:	00 00 00 
  80042045d4:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042045db:	00 00 00 
  80042045de:	be c9 03 00 00       	mov    $0x3c9,%esi
  80042045e3:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042045ea:	00 00 00 
  80042045ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045f2:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042045f9:	00 00 00 
  80042045fc:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
  80042045ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204603:	48 89 c7             	mov    %rax,%rdi
  8004204606:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  800420460d:	00 00 00 
  8004204610:	ff d0                	callq  *%rax
  8004204612:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004204618:	76 4e                	jbe    8004204668 <check_page_free_list+0x462>
  800420461a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420461e:	48 89 c7             	mov    %rax,%rdi
  8004204621:	48 b8 d3 1b 20 04 80 	movabs $0x8004201bd3,%rax
  8004204628:	00 00 00 
  800420462b:	ff d0                	callq  *%rax
  800420462d:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004204631:	73 35                	jae    8004204668 <check_page_free_list+0x462>
  8004204633:	48 b9 40 f7 21 04 80 	movabs $0x800421f740,%rcx
  800420463a:	00 00 00 
  800420463d:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204644:	00 00 00 
  8004204647:	be ca 03 00 00       	mov    $0x3ca,%esi
  800420464c:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204653:	00 00 00 
  8004204656:	b8 00 00 00 00       	mov    $0x0,%eax
  800420465b:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204662:	00 00 00 
  8004204665:	41 ff d0             	callq  *%r8

		// (new test for lab 4)
		assert(page2pa(pp) != MPENTRY_PADDR);
  8004204668:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420466c:	48 89 c7             	mov    %rax,%rdi
  800420466f:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  8004204676:	00 00 00 
  8004204679:	ff d0                	callq  *%rax
  800420467b:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  8004204681:	75 35                	jne    80042046b8 <check_page_free_list+0x4b2>
  8004204683:	48 b9 85 f7 21 04 80 	movabs $0x800421f785,%rcx
  800420468a:	00 00 00 
  800420468d:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204694:	00 00 00 
  8004204697:	be cd 03 00 00       	mov    $0x3cd,%esi
  800420469c:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042046a3:	00 00 00 
  80042046a6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042046ab:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042046b2:	00 00 00 
  80042046b5:	41 ff d0             	callq  *%r8


		if (page2pa(pp) < EXTPHYSMEM)
  80042046b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042046bc:	48 89 c7             	mov    %rax,%rdi
  80042046bf:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  80042046c6:	00 00 00 
  80042046c9:	ff d0                	callq  *%rax
  80042046cb:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  80042046d1:	77 07                	ja     80042046da <check_page_free_list+0x4d4>
			++nfree_basemem;
  80042046d3:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  80042046d8:	eb 05                	jmp    80042046df <check_page_free_list+0x4d9>
		else
			++nfree_extmem;
  80042046da:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link)
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042046df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042046e3:	48 8b 00             	mov    (%rax),%rax
  80042046e6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042046ea:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042046ef:	0f 85 d5 fc ff ff    	jne    80042043ca <check_page_free_list+0x1c4>
			++nfree_basemem;
		else
			++nfree_extmem;
	}

	assert(nfree_extmem > 0);
  80042046f5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042046fa:	75 35                	jne    8004204731 <check_page_free_list+0x52b>
  80042046fc:	48 b9 a2 f7 21 04 80 	movabs $0x800421f7a2,%rcx
  8004204703:	00 00 00 
  8004204706:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  800420470d:	00 00 00 
  8004204710:	be d6 03 00 00       	mov    $0x3d6,%esi
  8004204715:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420471c:	00 00 00 
  800420471f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204724:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420472b:	00 00 00 
  800420472e:	41 ff d0             	callq  *%r8
}
  8004204731:	90                   	nop
  8004204732:	c9                   	leaveq 
  8004204733:	c3                   	retq   

0000008004204734 <check_page_alloc>:
// Check the physical page allocator (page_alloc(), page_free(),
// and page_init()).
//
static void
check_page_alloc(void)
{
  8004204734:	55                   	push   %rbp
  8004204735:	48 89 e5             	mov    %rsp,%rbp
  8004204738:	48 83 ec 40          	sub    $0x40,%rsp
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  800420473c:	48 b8 38 02 4e 04 80 	movabs $0x80044e0238,%rax
  8004204743:	00 00 00 
  8004204746:	48 8b 00             	mov    (%rax),%rax
  8004204749:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420474d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004204754:	eb 37                	jmp    800420478d <check_page_alloc+0x59>
		memset(page2kva(pp0), 0x97, PGSIZE);
  8004204756:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420475a:	48 89 c7             	mov    %rax,%rdi
  800420475d:	48 b8 d3 1b 20 04 80 	movabs $0x8004201bd3,%rax
  8004204764:	00 00 00 
  8004204767:	ff d0                	callq  *%rax
  8004204769:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420476e:	be 97 00 00 00       	mov    $0x97,%esi
  8004204773:	48 89 c7             	mov    %rax,%rdi
  8004204776:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  800420477d:	00 00 00 
  8004204780:	ff d0                	callq  *%rax
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204782:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204786:	48 8b 00             	mov    (%rax),%rax
  8004204789:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420478d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204792:	75 c2                	jne    8004204756 <check_page_alloc+0x22>
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204794:	48 b8 38 02 4e 04 80 	movabs $0x80044e0238,%rax
  800420479b:	00 00 00 
  800420479e:	48 8b 00             	mov    (%rax),%rax
  80042047a1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042047a5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  80042047ac:	e9 ec 01 00 00       	jmpq   800420499d <check_page_alloc+0x269>
		// check that we didn't corrupt the free list itself
		assert(pp0 >= pages);
  80042047b1:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  80042047b8:	00 00 00 
  80042047bb:	48 8b 00             	mov    (%rax),%rax
  80042047be:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042047c2:	73 35                	jae    80042047f9 <check_page_alloc+0xc5>
  80042047c4:	48 b9 b3 f7 21 04 80 	movabs $0x800421f7b3,%rcx
  80042047cb:	00 00 00 
  80042047ce:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042047d5:	00 00 00 
  80042047d8:	be f0 03 00 00       	mov    $0x3f0,%esi
  80042047dd:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042047e4:	00 00 00 
  80042047e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042047ec:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042047f3:	00 00 00 
  80042047f6:	41 ff d0             	callq  *%r8
		assert(pp0 < pages + npages);
  80042047f9:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  8004204800:	00 00 00 
  8004204803:	48 8b 10             	mov    (%rax),%rdx
  8004204806:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  800420480d:	00 00 00 
  8004204810:	48 8b 00             	mov    (%rax),%rax
  8004204813:	48 c1 e0 04          	shl    $0x4,%rax
  8004204817:	48 01 d0             	add    %rdx,%rax
  800420481a:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420481e:	77 35                	ja     8004204855 <check_page_alloc+0x121>
  8004204820:	48 b9 c0 f7 21 04 80 	movabs $0x800421f7c0,%rcx
  8004204827:	00 00 00 
  800420482a:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204831:	00 00 00 
  8004204834:	be f1 03 00 00       	mov    $0x3f1,%esi
  8004204839:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204840:	00 00 00 
  8004204843:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204848:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420484f:	00 00 00 
  8004204852:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp0) != 0);
  8004204855:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204859:	48 89 c7             	mov    %rax,%rdi
  800420485c:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  8004204863:	00 00 00 
  8004204866:	ff d0                	callq  *%rax
  8004204868:	48 85 c0             	test   %rax,%rax
  800420486b:	75 35                	jne    80042048a2 <check_page_alloc+0x16e>
  800420486d:	48 b9 d5 f7 21 04 80 	movabs $0x800421f7d5,%rcx
  8004204874:	00 00 00 
  8004204877:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  800420487e:	00 00 00 
  8004204881:	be f4 03 00 00       	mov    $0x3f4,%esi
  8004204886:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420488d:	00 00 00 
  8004204890:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204895:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420489c:	00 00 00 
  800420489f:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != IOPHYSMEM);
  80042048a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042048a6:	48 89 c7             	mov    %rax,%rdi
  80042048a9:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  80042048b0:	00 00 00 
  80042048b3:	ff d0                	callq  *%rax
  80042048b5:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  80042048bb:	75 35                	jne    80042048f2 <check_page_alloc+0x1be>
  80042048bd:	48 b9 e7 f7 21 04 80 	movabs $0x800421f7e7,%rcx
  80042048c4:	00 00 00 
  80042048c7:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042048ce:	00 00 00 
  80042048d1:	be f5 03 00 00       	mov    $0x3f5,%esi
  80042048d6:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042048dd:	00 00 00 
  80042048e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042048e5:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042048ec:	00 00 00 
  80042048ef:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
  80042048f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042048f6:	48 89 c7             	mov    %rax,%rdi
  80042048f9:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  8004204900:	00 00 00 
  8004204903:	ff d0                	callq  *%rax
  8004204905:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  800420490b:	75 35                	jne    8004204942 <check_page_alloc+0x20e>
  800420490d:	48 b9 08 f8 21 04 80 	movabs $0x800421f808,%rcx
  8004204914:	00 00 00 
  8004204917:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  800420491e:	00 00 00 
  8004204921:	be f6 03 00 00       	mov    $0x3f6,%esi
  8004204926:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420492d:	00 00 00 
  8004204930:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204935:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420493c:	00 00 00 
  800420493f:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM);
  8004204942:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204946:	48 89 c7             	mov    %rax,%rdi
  8004204949:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  8004204950:	00 00 00 
  8004204953:	ff d0                	callq  *%rax
  8004204955:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  800420495b:	75 35                	jne    8004204992 <check_page_alloc+0x25e>
  800420495d:	48 b9 2c f8 21 04 80 	movabs $0x800421f82c,%rcx
  8004204964:	00 00 00 
  8004204967:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  800420496e:	00 00 00 
  8004204971:	be f7 03 00 00       	mov    $0x3f7,%esi
  8004204976:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420497d:	00 00 00 
  8004204980:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204985:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420498c:	00 00 00 
  800420498f:	41 ff d0             	callq  *%r8
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204992:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204996:	48 8b 00             	mov    (%rax),%rax
  8004204999:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420499d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042049a2:	0f 85 09 fe ff ff    	jne    80042047b1 <check_page_alloc+0x7d>
		assert(page2pa(pp0) != IOPHYSMEM);
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
		assert(page2pa(pp0) != EXTPHYSMEM);
	}
	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
  80042049a8:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042049af:	00 
  80042049b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042049b4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042049b8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042049bc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  80042049c0:	bf 00 00 00 00       	mov    $0x0,%edi
  80042049c5:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  80042049cc:	00 00 00 
  80042049cf:	ff d0                	callq  *%rax
  80042049d1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042049d5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042049da:	75 35                	jne    8004204a11 <check_page_alloc+0x2dd>
  80042049dc:	48 b9 47 f8 21 04 80 	movabs $0x800421f847,%rcx
  80042049e3:	00 00 00 
  80042049e6:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042049ed:	00 00 00 
  80042049f0:	be fb 03 00 00       	mov    $0x3fb,%esi
  80042049f5:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042049fc:	00 00 00 
  80042049ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a04:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204a0b:	00 00 00 
  8004204a0e:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004204a11:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204a16:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004204a1d:	00 00 00 
  8004204a20:	ff d0                	callq  *%rax
  8004204a22:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204a26:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204a2b:	75 35                	jne    8004204a62 <check_page_alloc+0x32e>
  8004204a2d:	48 b9 5d f8 21 04 80 	movabs $0x800421f85d,%rcx
  8004204a34:	00 00 00 
  8004204a37:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204a3e:	00 00 00 
  8004204a41:	be fc 03 00 00       	mov    $0x3fc,%esi
  8004204a46:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204a4d:	00 00 00 
  8004204a50:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a55:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204a5c:	00 00 00 
  8004204a5f:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004204a62:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204a67:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004204a6e:	00 00 00 
  8004204a71:	ff d0                	callq  *%rax
  8004204a73:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204a77:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204a7c:	75 35                	jne    8004204ab3 <check_page_alloc+0x37f>
  8004204a7e:	48 b9 73 f8 21 04 80 	movabs $0x800421f873,%rcx
  8004204a85:	00 00 00 
  8004204a88:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204a8f:	00 00 00 
  8004204a92:	be fd 03 00 00       	mov    $0x3fd,%esi
  8004204a97:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204a9e:	00 00 00 
  8004204aa1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204aa6:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204aad:	00 00 00 
  8004204ab0:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204ab3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204ab8:	75 35                	jne    8004204aef <check_page_alloc+0x3bb>
  8004204aba:	48 b9 89 f8 21 04 80 	movabs $0x800421f889,%rcx
  8004204ac1:	00 00 00 
  8004204ac4:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204acb:	00 00 00 
  8004204ace:	be fe 03 00 00       	mov    $0x3fe,%esi
  8004204ad3:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204ada:	00 00 00 
  8004204add:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ae2:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204ae9:	00 00 00 
  8004204aec:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204aef:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204af4:	74 0a                	je     8004204b00 <check_page_alloc+0x3cc>
  8004204af6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204afa:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204afe:	75 35                	jne    8004204b35 <check_page_alloc+0x401>
  8004204b00:	48 b9 8d f8 21 04 80 	movabs $0x800421f88d,%rcx
  8004204b07:	00 00 00 
  8004204b0a:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204b11:	00 00 00 
  8004204b14:	be ff 03 00 00       	mov    $0x3ff,%esi
  8004204b19:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204b20:	00 00 00 
  8004204b23:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b28:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204b2f:	00 00 00 
  8004204b32:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204b35:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204b3a:	74 14                	je     8004204b50 <check_page_alloc+0x41c>
  8004204b3c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204b40:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204b44:	74 0a                	je     8004204b50 <check_page_alloc+0x41c>
  8004204b46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204b4a:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204b4e:	75 35                	jne    8004204b85 <check_page_alloc+0x451>
  8004204b50:	48 b9 a0 f8 21 04 80 	movabs $0x800421f8a0,%rcx
  8004204b57:	00 00 00 
  8004204b5a:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204b61:	00 00 00 
  8004204b64:	be 00 04 00 00       	mov    $0x400,%esi
  8004204b69:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204b70:	00 00 00 
  8004204b73:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b78:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204b7f:	00 00 00 
  8004204b82:	41 ff d0             	callq  *%r8
	assert(page2pa(pp0) < npages*PGSIZE);
  8004204b85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b89:	48 89 c7             	mov    %rax,%rdi
  8004204b8c:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  8004204b93:	00 00 00 
  8004204b96:	ff d0                	callq  *%rax
  8004204b98:	48 89 c2             	mov    %rax,%rdx
  8004204b9b:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004204ba2:	00 00 00 
  8004204ba5:	48 8b 00             	mov    (%rax),%rax
  8004204ba8:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204bac:	48 39 c2             	cmp    %rax,%rdx
  8004204baf:	72 35                	jb     8004204be6 <check_page_alloc+0x4b2>
  8004204bb1:	48 b9 c0 f8 21 04 80 	movabs $0x800421f8c0,%rcx
  8004204bb8:	00 00 00 
  8004204bbb:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204bc2:	00 00 00 
  8004204bc5:	be 01 04 00 00       	mov    $0x401,%esi
  8004204bca:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204bd1:	00 00 00 
  8004204bd4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204bd9:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204be0:	00 00 00 
  8004204be3:	41 ff d0             	callq  *%r8
	assert(page2pa(pp1) < npages*PGSIZE);
  8004204be6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204bea:	48 89 c7             	mov    %rax,%rdi
  8004204bed:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  8004204bf4:	00 00 00 
  8004204bf7:	ff d0                	callq  *%rax
  8004204bf9:	48 89 c2             	mov    %rax,%rdx
  8004204bfc:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004204c03:	00 00 00 
  8004204c06:	48 8b 00             	mov    (%rax),%rax
  8004204c09:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204c0d:	48 39 c2             	cmp    %rax,%rdx
  8004204c10:	72 35                	jb     8004204c47 <check_page_alloc+0x513>
  8004204c12:	48 b9 dd f8 21 04 80 	movabs $0x800421f8dd,%rcx
  8004204c19:	00 00 00 
  8004204c1c:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204c23:	00 00 00 
  8004204c26:	be 02 04 00 00       	mov    $0x402,%esi
  8004204c2b:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204c32:	00 00 00 
  8004204c35:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c3a:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204c41:	00 00 00 
  8004204c44:	41 ff d0             	callq  *%r8
	assert(page2pa(pp2) < npages*PGSIZE);
  8004204c47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204c4b:	48 89 c7             	mov    %rax,%rdi
  8004204c4e:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  8004204c55:	00 00 00 
  8004204c58:	ff d0                	callq  *%rax
  8004204c5a:	48 89 c2             	mov    %rax,%rdx
  8004204c5d:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004204c64:	00 00 00 
  8004204c67:	48 8b 00             	mov    (%rax),%rax
  8004204c6a:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204c6e:	48 39 c2             	cmp    %rax,%rdx
  8004204c71:	72 35                	jb     8004204ca8 <check_page_alloc+0x574>
  8004204c73:	48 b9 fa f8 21 04 80 	movabs $0x800421f8fa,%rcx
  8004204c7a:	00 00 00 
  8004204c7d:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204c84:	00 00 00 
  8004204c87:	be 03 04 00 00       	mov    $0x403,%esi
  8004204c8c:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204c93:	00 00 00 
  8004204c96:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c9b:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204ca2:	00 00 00 
  8004204ca5:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004204ca8:	48 b8 38 02 4e 04 80 	movabs $0x80044e0238,%rax
  8004204caf:	00 00 00 
  8004204cb2:	48 8b 00             	mov    (%rax),%rax
  8004204cb5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	page_free_list = 0;
  8004204cb9:	48 b8 38 02 4e 04 80 	movabs $0x80044e0238,%rax
  8004204cc0:	00 00 00 
  8004204cc3:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004204cca:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204ccf:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004204cd6:	00 00 00 
  8004204cd9:	ff d0                	callq  *%rax
  8004204cdb:	48 85 c0             	test   %rax,%rax
  8004204cde:	74 35                	je     8004204d15 <check_page_alloc+0x5e1>
  8004204ce0:	48 b9 17 f9 21 04 80 	movabs $0x800421f917,%rcx
  8004204ce7:	00 00 00 
  8004204cea:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204cf1:	00 00 00 
  8004204cf4:	be 0a 04 00 00       	mov    $0x40a,%esi
  8004204cf9:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204d00:	00 00 00 
  8004204d03:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d08:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204d0f:	00 00 00 
  8004204d12:	41 ff d0             	callq  *%r8

	// free and re-allocate?
	page_free(pp0);
  8004204d15:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204d19:	48 89 c7             	mov    %rax,%rdi
  8004204d1c:	48 b8 65 2f 20 04 80 	movabs $0x8004202f65,%rax
  8004204d23:	00 00 00 
  8004204d26:	ff d0                	callq  *%rax
	page_free(pp1);
  8004204d28:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204d2c:	48 89 c7             	mov    %rax,%rdi
  8004204d2f:	48 b8 65 2f 20 04 80 	movabs $0x8004202f65,%rax
  8004204d36:	00 00 00 
  8004204d39:	ff d0                	callq  *%rax
	page_free(pp2);
  8004204d3b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204d3f:	48 89 c7             	mov    %rax,%rdi
  8004204d42:	48 b8 65 2f 20 04 80 	movabs $0x8004202f65,%rax
  8004204d49:	00 00 00 
  8004204d4c:	ff d0                	callq  *%rax
	pp0 = pp1 = pp2 = 0;
  8004204d4e:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204d55:	00 
  8004204d56:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204d5a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204d5e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204d62:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004204d66:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204d6b:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004204d72:	00 00 00 
  8004204d75:	ff d0                	callq  *%rax
  8004204d77:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204d7b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204d80:	75 35                	jne    8004204db7 <check_page_alloc+0x683>
  8004204d82:	48 b9 47 f8 21 04 80 	movabs $0x800421f847,%rcx
  8004204d89:	00 00 00 
  8004204d8c:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204d93:	00 00 00 
  8004204d96:	be 11 04 00 00       	mov    $0x411,%esi
  8004204d9b:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204da2:	00 00 00 
  8004204da5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204daa:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204db1:	00 00 00 
  8004204db4:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004204db7:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204dbc:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004204dc3:	00 00 00 
  8004204dc6:	ff d0                	callq  *%rax
  8004204dc8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204dcc:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204dd1:	75 35                	jne    8004204e08 <check_page_alloc+0x6d4>
  8004204dd3:	48 b9 5d f8 21 04 80 	movabs $0x800421f85d,%rcx
  8004204dda:	00 00 00 
  8004204ddd:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204de4:	00 00 00 
  8004204de7:	be 12 04 00 00       	mov    $0x412,%esi
  8004204dec:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204df3:	00 00 00 
  8004204df6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204dfb:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204e02:	00 00 00 
  8004204e05:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004204e08:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204e0d:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004204e14:	00 00 00 
  8004204e17:	ff d0                	callq  *%rax
  8004204e19:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204e1d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204e22:	75 35                	jne    8004204e59 <check_page_alloc+0x725>
  8004204e24:	48 b9 73 f8 21 04 80 	movabs $0x800421f873,%rcx
  8004204e2b:	00 00 00 
  8004204e2e:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204e35:	00 00 00 
  8004204e38:	be 13 04 00 00       	mov    $0x413,%esi
  8004204e3d:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204e44:	00 00 00 
  8004204e47:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e4c:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204e53:	00 00 00 
  8004204e56:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204e59:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204e5e:	75 35                	jne    8004204e95 <check_page_alloc+0x761>
  8004204e60:	48 b9 89 f8 21 04 80 	movabs $0x800421f889,%rcx
  8004204e67:	00 00 00 
  8004204e6a:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204e71:	00 00 00 
  8004204e74:	be 14 04 00 00       	mov    $0x414,%esi
  8004204e79:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204e80:	00 00 00 
  8004204e83:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e88:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204e8f:	00 00 00 
  8004204e92:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204e95:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204e9a:	74 0a                	je     8004204ea6 <check_page_alloc+0x772>
  8004204e9c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204ea0:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204ea4:	75 35                	jne    8004204edb <check_page_alloc+0x7a7>
  8004204ea6:	48 b9 8d f8 21 04 80 	movabs $0x800421f88d,%rcx
  8004204ead:	00 00 00 
  8004204eb0:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204eb7:	00 00 00 
  8004204eba:	be 15 04 00 00       	mov    $0x415,%esi
  8004204ebf:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204ec6:	00 00 00 
  8004204ec9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ece:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204ed5:	00 00 00 
  8004204ed8:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204edb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204ee0:	74 14                	je     8004204ef6 <check_page_alloc+0x7c2>
  8004204ee2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204ee6:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204eea:	74 0a                	je     8004204ef6 <check_page_alloc+0x7c2>
  8004204eec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204ef0:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204ef4:	75 35                	jne    8004204f2b <check_page_alloc+0x7f7>
  8004204ef6:	48 b9 a0 f8 21 04 80 	movabs $0x800421f8a0,%rcx
  8004204efd:	00 00 00 
  8004204f00:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204f07:	00 00 00 
  8004204f0a:	be 16 04 00 00       	mov    $0x416,%esi
  8004204f0f:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204f16:	00 00 00 
  8004204f19:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f1e:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204f25:	00 00 00 
  8004204f28:	41 ff d0             	callq  *%r8
	assert(!page_alloc(0));
  8004204f2b:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204f30:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004204f37:	00 00 00 
  8004204f3a:	ff d0                	callq  *%rax
  8004204f3c:	48 85 c0             	test   %rax,%rax
  8004204f3f:	74 35                	je     8004204f76 <check_page_alloc+0x842>
  8004204f41:	48 b9 17 f9 21 04 80 	movabs $0x800421f917,%rcx
  8004204f48:	00 00 00 
  8004204f4b:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204f52:	00 00 00 
  8004204f55:	be 17 04 00 00       	mov    $0x417,%esi
  8004204f5a:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204f61:	00 00 00 
  8004204f64:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f69:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004204f70:	00 00 00 
  8004204f73:	41 ff d0             	callq  *%r8

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
  8004204f76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204f7a:	48 89 c7             	mov    %rax,%rdi
  8004204f7d:	48 b8 d3 1b 20 04 80 	movabs $0x8004201bd3,%rax
  8004204f84:	00 00 00 
  8004204f87:	ff d0                	callq  *%rax
  8004204f89:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204f8e:	be 01 00 00 00       	mov    $0x1,%esi
  8004204f93:	48 89 c7             	mov    %rax,%rdi
  8004204f96:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  8004204f9d:	00 00 00 
  8004204fa0:	ff d0                	callq  *%rax
	page_free(pp0);
  8004204fa2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204fa6:	48 89 c7             	mov    %rax,%rdi
  8004204fa9:	48 b8 65 2f 20 04 80 	movabs $0x8004202f65,%rax
  8004204fb0:	00 00 00 
  8004204fb3:	ff d0                	callq  *%rax
	assert((pp = page_alloc(ALLOC_ZERO)));
  8004204fb5:	bf 01 00 00 00       	mov    $0x1,%edi
  8004204fba:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004204fc1:	00 00 00 
  8004204fc4:	ff d0                	callq  *%rax
  8004204fc6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004204fca:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004204fcf:	75 35                	jne    8004205006 <check_page_alloc+0x8d2>
  8004204fd1:	48 b9 26 f9 21 04 80 	movabs $0x800421f926,%rcx
  8004204fd8:	00 00 00 
  8004204fdb:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004204fe2:	00 00 00 
  8004204fe5:	be 1c 04 00 00       	mov    $0x41c,%esi
  8004204fea:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004204ff1:	00 00 00 
  8004204ff4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ff9:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205000:	00 00 00 
  8004205003:	41 ff d0             	callq  *%r8
	assert(pp && pp0 == pp);
  8004205006:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420500b:	74 0a                	je     8004205017 <check_page_alloc+0x8e3>
  800420500d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205011:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205015:	74 35                	je     800420504c <check_page_alloc+0x918>
  8004205017:	48 b9 44 f9 21 04 80 	movabs $0x800421f944,%rcx
  800420501e:	00 00 00 
  8004205021:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004205028:	00 00 00 
  800420502b:	be 1d 04 00 00       	mov    $0x41d,%esi
  8004205030:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205037:	00 00 00 
  800420503a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420503f:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205046:	00 00 00 
  8004205049:	41 ff d0             	callq  *%r8
	c = page2kva(pp);
  800420504c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205050:	48 89 c7             	mov    %rax,%rdi
  8004205053:	48 b8 d3 1b 20 04 80 	movabs $0x8004201bd3,%rax
  800420505a:	00 00 00 
  800420505d:	ff d0                	callq  *%rax
  800420505f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < PGSIZE; i++)
  8004205063:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  800420506a:	eb 4d                	jmp    80042050b9 <check_page_alloc+0x985>
		assert(c[i] == 0);
  800420506c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420506f:	48 63 d0             	movslq %eax,%rdx
  8004205072:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205076:	48 01 d0             	add    %rdx,%rax
  8004205079:	0f b6 00             	movzbl (%rax),%eax
  800420507c:	84 c0                	test   %al,%al
  800420507e:	74 35                	je     80042050b5 <check_page_alloc+0x981>
  8004205080:	48 b9 54 f9 21 04 80 	movabs $0x800421f954,%rcx
  8004205087:	00 00 00 
  800420508a:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004205091:	00 00 00 
  8004205094:	be 20 04 00 00       	mov    $0x420,%esi
  8004205099:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042050a0:	00 00 00 
  80042050a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042050a8:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042050af:	00 00 00 
  80042050b2:	41 ff d0             	callq  *%r8
	memset(page2kva(pp0), 1, PGSIZE);
	page_free(pp0);
	assert((pp = page_alloc(ALLOC_ZERO)));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	for (i = 0; i < PGSIZE; i++)
  80042050b5:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042050b9:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%rbp)
  80042050c0:	7e aa                	jle    800420506c <check_page_alloc+0x938>
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;
  80042050c2:	48 b8 38 02 4e 04 80 	movabs $0x80044e0238,%rax
  80042050c9:	00 00 00 
  80042050cc:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042050d0:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_free(pp0);
  80042050d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042050d7:	48 89 c7             	mov    %rax,%rdi
  80042050da:	48 b8 65 2f 20 04 80 	movabs $0x8004202f65,%rax
  80042050e1:	00 00 00 
  80042050e4:	ff d0                	callq  *%rax
	page_free(pp1);
  80042050e6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042050ea:	48 89 c7             	mov    %rax,%rdi
  80042050ed:	48 b8 65 2f 20 04 80 	movabs $0x8004202f65,%rax
  80042050f4:	00 00 00 
  80042050f7:	ff d0                	callq  *%rax
	page_free(pp2);
  80042050f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042050fd:	48 89 c7             	mov    %rax,%rdi
  8004205100:	48 b8 65 2f 20 04 80 	movabs $0x8004202f65,%rax
  8004205107:	00 00 00 
  800420510a:	ff d0                	callq  *%rax

	cprintf("check_page_alloc() succeeded!\n");
  800420510c:	48 bf 60 f9 21 04 80 	movabs $0x800421f960,%rdi
  8004205113:	00 00 00 
  8004205116:	b8 00 00 00 00       	mov    $0x0,%eax
  800420511b:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004205122:	00 00 00 
  8004205125:	ff d2                	callq  *%rdx
}
  8004205127:	90                   	nop
  8004205128:	c9                   	leaveq 
  8004205129:	c3                   	retq   

000000800420512a <check_boot_pml4e>:
// but it is a pretty good sanity check.
//

static void
check_boot_pml4e(pml4e_t *pml4e)
{
  800420512a:	55                   	push   %rbp
  800420512b:	48 89 e5             	mov    %rsp,%rbp
  800420512e:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  8004205135:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
	uint64_t i, n;

	pml4e = boot_pml4e;
  800420513c:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004205143:	00 00 00 
  8004205146:	48 8b 00             	mov    (%rax),%rax
  8004205149:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
  8004205150:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004205157:	00 
  8004205158:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  800420515f:	00 00 00 
  8004205162:	48 8b 00             	mov    (%rax),%rax
  8004205165:	48 c1 e0 04          	shl    $0x4,%rax
  8004205169:	48 89 c2             	mov    %rax,%rdx
  800420516c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205170:	48 01 d0             	add    %rdx,%rax
  8004205173:	48 83 e8 01          	sub    $0x1,%rax
  8004205177:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420517b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420517f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205184:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004205188:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420518c:	48 29 d0             	sub    %rdx,%rax
  800420518f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE) {
  8004205193:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420519a:	00 
  800420519b:	e9 da 00 00 00       	jmpq   800420527a <check_boot_pml4e+0x150>
		// cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
  80042051a0:	48 ba 00 00 a0 00 80 	movabs $0x8000a00000,%rdx
  80042051a7:	00 00 00 
  80042051aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042051ae:	48 01 c2             	add    %rax,%rdx
  80042051b1:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042051b8:	48 89 d6             	mov    %rdx,%rsi
  80042051bb:	48 89 c7             	mov    %rax,%rdi
  80042051be:	48 b8 7b 58 20 04 80 	movabs $0x800420587b,%rax
  80042051c5:	00 00 00 
  80042051c8:	ff d0                	callq  *%rax
  80042051ca:	48 89 c1             	mov    %rax,%rcx
  80042051cd:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  80042051d4:	00 00 00 
  80042051d7:	48 8b 00             	mov    (%rax),%rax
  80042051da:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042051de:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042051e5:	00 00 00 
  80042051e8:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80042051ec:	77 32                	ja     8004205220 <check_boot_pml4e+0xf6>
  80042051ee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042051f2:	48 89 c1             	mov    %rax,%rcx
  80042051f5:	48 ba a0 f5 21 04 80 	movabs $0x800421f5a0,%rdx
  80042051fc:	00 00 00 
  80042051ff:	be 40 04 00 00       	mov    $0x440,%esi
  8004205204:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420520b:	00 00 00 
  800420520e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205213:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420521a:	00 00 00 
  800420521d:	41 ff d0             	callq  *%r8
  8004205220:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004205227:	ff ff ff 
  800420522a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420522e:	48 01 c2             	add    %rax,%rdx
  8004205231:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205235:	48 01 d0             	add    %rdx,%rax
  8004205238:	48 39 c1             	cmp    %rax,%rcx
  800420523b:	74 35                	je     8004205272 <check_boot_pml4e+0x148>
  800420523d:	48 b9 80 f9 21 04 80 	movabs $0x800421f980,%rcx
  8004205244:	00 00 00 
  8004205247:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  800420524e:	00 00 00 
  8004205251:	be 40 04 00 00       	mov    $0x440,%esi
  8004205256:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420525d:	00 00 00 
  8004205260:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205265:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420526c:	00 00 00 
  800420526f:	41 ff d0             	callq  *%r8

	pml4e = boot_pml4e;

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
	for (i = 0; i < n; i += PGSIZE) {
  8004205272:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205279:	00 
  800420527a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420527e:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004205282:	0f 82 18 ff ff ff    	jb     80042051a0 <check_boot_pml4e+0x76>
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}


	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  8004205288:	48 c7 45 d0 00 10 00 	movq   $0x1000,-0x30(%rbp)
  800420528f:	00 
  8004205290:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205294:	48 05 ff 9f 05 00    	add    $0x59fff,%rax
  800420529a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  800420529e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042052a2:	ba 00 00 00 00       	mov    $0x0,%edx
  80042052a7:	48 f7 75 d0          	divq   -0x30(%rbp)
  80042052ab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042052af:	48 29 d0             	sub    %rdx,%rax
  80042052b2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE)
  80042052b6:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042052bd:	00 
  80042052be:	e9 da 00 00 00       	jmpq   800420539d <check_boot_pml4e+0x273>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);
  80042052c3:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  80042052ca:	00 00 00 
  80042052cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042052d1:	48 01 c2             	add    %rax,%rdx
  80042052d4:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042052db:	48 89 d6             	mov    %rdx,%rsi
  80042052de:	48 89 c7             	mov    %rax,%rdi
  80042052e1:	48 b8 7b 58 20 04 80 	movabs $0x800420587b,%rax
  80042052e8:	00 00 00 
  80042052eb:	ff d0                	callq  *%rax
  80042052ed:	48 89 c1             	mov    %rax,%rcx
  80042052f0:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  80042052f7:	00 00 00 
  80042052fa:	48 8b 00             	mov    (%rax),%rax
  80042052fd:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004205301:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004205308:	00 00 00 
  800420530b:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  800420530f:	77 32                	ja     8004205343 <check_boot_pml4e+0x219>
  8004205311:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205315:	48 89 c1             	mov    %rax,%rcx
  8004205318:	48 ba a0 f5 21 04 80 	movabs $0x800421f5a0,%rdx
  800420531f:	00 00 00 
  8004205322:	be 47 04 00 00       	mov    $0x447,%esi
  8004205327:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420532e:	00 00 00 
  8004205331:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205336:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420533d:	00 00 00 
  8004205340:	41 ff d0             	callq  *%r8
  8004205343:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420534a:	ff ff ff 
  800420534d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205351:	48 01 c2             	add    %rax,%rdx
  8004205354:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205358:	48 01 d0             	add    %rdx,%rax
  800420535b:	48 39 c1             	cmp    %rax,%rcx
  800420535e:	74 35                	je     8004205395 <check_boot_pml4e+0x26b>
  8004205360:	48 b9 b8 f9 21 04 80 	movabs $0x800421f9b8,%rcx
  8004205367:	00 00 00 
  800420536a:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004205371:	00 00 00 
  8004205374:	be 47 04 00 00       	mov    $0x447,%esi
  8004205379:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205380:	00 00 00 
  8004205383:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205388:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420538f:	00 00 00 
  8004205392:	41 ff d0             	callq  *%r8
	}


	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
  8004205395:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  800420539c:	00 
  800420539d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042053a1:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80042053a5:	0f 82 18 ff ff ff    	jb     80042052c3 <check_boot_pml4e+0x199>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);


	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  80042053ab:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042053b2:	00 
  80042053b3:	eb 6d                	jmp    8004205422 <check_boot_pml4e+0x2f8>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);
  80042053b5:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042053bc:	00 00 00 
  80042053bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042053c3:	48 01 c2             	add    %rax,%rdx
  80042053c6:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042053cd:	48 89 d6             	mov    %rdx,%rsi
  80042053d0:	48 89 c7             	mov    %rax,%rdi
  80042053d3:	48 b8 7b 58 20 04 80 	movabs $0x800420587b,%rax
  80042053da:	00 00 00 
  80042053dd:	ff d0                	callq  *%rax
  80042053df:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042053e3:	74 35                	je     800420541a <check_boot_pml4e+0x2f0>
  80042053e5:	48 b9 f0 f9 21 04 80 	movabs $0x800421f9f0,%rcx
  80042053ec:	00 00 00 
  80042053ef:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042053f6:	00 00 00 
  80042053f9:	be 4c 04 00 00       	mov    $0x44c,%esi
  80042053fe:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205405:	00 00 00 
  8004205408:	b8 00 00 00 00       	mov    $0x0,%eax
  800420540d:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205414:	00 00 00 
  8004205417:	41 ff d0             	callq  *%r8
	for (i = 0; i < n; i += PGSIZE)
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);


	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  800420541a:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205421:	00 
  8004205422:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004205429:	00 00 00 
  800420542c:	48 8b 00             	mov    (%rax),%rax
  800420542f:	48 c1 e0 0c          	shl    $0xc,%rax
  8004205433:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004205437:	0f 87 78 ff ff ff    	ja     80042053b5 <check_boot_pml4e+0x28b>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);


	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  800420543d:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004205444:	00 
  8004205445:	e9 aa 01 00 00       	jmpq   80042055f4 <check_boot_pml4e+0x4ca>
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
  800420544a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420544e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004205452:	48 89 d0             	mov    %rdx,%rax
  8004205455:	48 01 c0             	add    %rax,%rax
  8004205458:	48 01 d0             	add    %rdx,%rax
  800420545b:	48 c1 e0 0f          	shl    $0xf,%rax
  800420545f:	48 89 c2             	mov    %rax,%rdx
  8004205462:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004205469:	00 00 00 
  800420546c:	48 29 d0             	sub    %rdx,%rax
  800420546f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004205473:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420547a:	00 
  800420547b:	e9 e6 00 00 00       	jmpq   8004205566 <check_boot_pml4e+0x43c>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
  8004205480:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004205484:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205488:	48 01 d0             	add    %rdx,%rax
  800420548b:	48 8d 90 00 80 00 00 	lea    0x8000(%rax),%rdx
  8004205492:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205499:	48 89 d6             	mov    %rdx,%rsi
  800420549c:	48 89 c7             	mov    %rax,%rdi
  800420549f:	48 b8 7b 58 20 04 80 	movabs $0x800420587b,%rax
  80042054a6:	00 00 00 
  80042054a9:	ff d0                	callq  *%rax
  80042054ab:	48 89 c1             	mov    %rax,%rcx
  80042054ae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042054b2:	48 c1 e0 10          	shl    $0x10,%rax
  80042054b6:	48 89 c2             	mov    %rax,%rdx
  80042054b9:	48 b8 00 20 6e 04 80 	movabs $0x80046e2000,%rax
  80042054c0:	00 00 00 
  80042054c3:	48 01 d0             	add    %rdx,%rax
  80042054c6:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80042054ca:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042054d1:	00 00 00 
  80042054d4:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  80042054d8:	77 32                	ja     800420550c <check_boot_pml4e+0x3e2>
  80042054da:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042054de:	48 89 c1             	mov    %rax,%rcx
  80042054e1:	48 ba a0 f5 21 04 80 	movabs $0x800421f5a0,%rdx
  80042054e8:	00 00 00 
  80042054eb:	be 55 04 00 00       	mov    $0x455,%esi
  80042054f0:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042054f7:	00 00 00 
  80042054fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042054ff:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205506:	00 00 00 
  8004205509:	41 ff d0             	callq  *%r8
  800420550c:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004205513:	ff ff ff 
  8004205516:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420551a:	48 01 c2             	add    %rax,%rdx
  800420551d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205521:	48 01 d0             	add    %rdx,%rax
  8004205524:	48 39 c1             	cmp    %rax,%rcx
  8004205527:	74 35                	je     800420555e <check_boot_pml4e+0x434>
  8004205529:	48 b9 18 fa 21 04 80 	movabs $0x800421fa18,%rcx
  8004205530:	00 00 00 
  8004205533:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  800420553a:	00 00 00 
  800420553d:	be 55 04 00 00       	mov    $0x455,%esi
  8004205542:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205549:	00 00 00 
  800420554c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205551:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205558:	00 00 00 
  800420555b:	41 ff d0             	callq  *%r8

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  800420555e:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205565:	00 
  8004205566:	48 81 7d f8 ff ff 00 	cmpq   $0xffff,-0x8(%rbp)
  800420556d:	00 
  800420556e:	0f 86 0c ff ff ff    	jbe    8004205480 <check_boot_pml4e+0x356>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004205574:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420557b:	00 
  800420557c:	eb 67                	jmp    80042055e5 <check_boot_pml4e+0x4bb>
			assert(check_va2pa(pml4e, base + i) == ~0);
  800420557e:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004205582:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205586:	48 01 c2             	add    %rax,%rdx
  8004205589:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205590:	48 89 d6             	mov    %rdx,%rsi
  8004205593:	48 89 c7             	mov    %rax,%rdi
  8004205596:	48 b8 7b 58 20 04 80 	movabs $0x800420587b,%rax
  800420559d:	00 00 00 
  80042055a0:	ff d0                	callq  *%rax
  80042055a2:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  80042055a6:	74 35                	je     80042055dd <check_boot_pml4e+0x4b3>
  80042055a8:	48 b9 60 fa 21 04 80 	movabs $0x800421fa60,%rcx
  80042055af:	00 00 00 
  80042055b2:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042055b9:	00 00 00 
  80042055bc:	be 57 04 00 00       	mov    $0x457,%esi
  80042055c1:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042055c8:	00 00 00 
  80042055cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042055d0:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042055d7:	00 00 00 
  80042055da:	41 ff d0             	callq  *%r8
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  80042055dd:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042055e4:	00 
  80042055e5:	48 81 7d f8 ff 7f 00 	cmpq   $0x7fff,-0x8(%rbp)
  80042055ec:	00 
  80042055ed:	76 8f                	jbe    800420557e <check_boot_pml4e+0x454>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);


	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  80042055ef:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  80042055f4:	48 83 7d f0 03       	cmpq   $0x3,-0x10(%rbp)
  80042055f9:	0f 86 4b fe ff ff    	jbe    800420544a <check_boot_pml4e+0x320>
		for (i = 0; i < KSTKGAP; i += PGSIZE)
			assert(check_va2pa(pml4e, base + i) == ~0);
	}


	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
  80042055ff:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004205606:	00 00 00 
  8004205609:	48 8b 00             	mov    (%rax),%rax
  800420560c:	48 83 c0 08          	add    $0x8,%rax
  8004205610:	48 8b 00             	mov    (%rax),%rax
  8004205613:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205619:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  800420561d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205621:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205625:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  8004205628:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  800420562b:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004205632:	00 00 00 
  8004205635:	48 8b 00             	mov    (%rax),%rax
  8004205638:	48 39 c2             	cmp    %rax,%rdx
  800420563b:	72 32                	jb     800420566f <check_boot_pml4e+0x545>
  800420563d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205641:	48 89 c1             	mov    %rax,%rcx
  8004205644:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  800420564b:	00 00 00 
  800420564e:	be 5b 04 00 00       	mov    $0x45b,%esi
  8004205653:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420565a:	00 00 00 
  800420565d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205662:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205669:	00 00 00 
  800420566c:	41 ff d0             	callq  *%r8
  800420566f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205676:	00 00 00 
  8004205679:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420567d:	48 01 d0             	add    %rdx,%rax
  8004205680:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004205684:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004205688:	48 8b 00             	mov    (%rax),%rax
  800420568b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205691:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004205695:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205699:	48 c1 e8 0c          	shr    $0xc,%rax
  800420569d:	89 45 8c             	mov    %eax,-0x74(%rbp)
  80042056a0:	8b 55 8c             	mov    -0x74(%rbp),%edx
  80042056a3:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  80042056aa:	00 00 00 
  80042056ad:	48 8b 00             	mov    (%rax),%rax
  80042056b0:	48 39 c2             	cmp    %rax,%rdx
  80042056b3:	72 32                	jb     80042056e7 <check_boot_pml4e+0x5bd>
  80042056b5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042056b9:	48 89 c1             	mov    %rax,%rcx
  80042056bc:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  80042056c3:	00 00 00 
  80042056c6:	be 5c 04 00 00       	mov    $0x45c,%esi
  80042056cb:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042056d2:	00 00 00 
  80042056d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042056da:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042056e1:	00 00 00 
  80042056e4:	41 ff d0             	callq  *%r8
  80042056e7:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042056ee:	00 00 00 
  80042056f1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042056f5:	48 01 d0             	add    %rdx,%rax
  80042056f8:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  80042056fc:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205703:	00 
  8004205704:	e9 46 01 00 00       	jmpq   800420584f <check_boot_pml4e+0x725>
		switch (i) {
  8004205709:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420570d:	48 83 f8 04          	cmp    $0x4,%rax
  8004205711:	72 63                	jb     8004205776 <check_boot_pml4e+0x64c>
  8004205713:	48 83 f8 05          	cmp    $0x5,%rax
  8004205717:	76 06                	jbe    800420571f <check_boot_pml4e+0x5f5>
  8004205719:	48 83 f8 1f          	cmp    $0x1f,%rax
  800420571d:	75 57                	jne    8004205776 <check_boot_pml4e+0x64c>
		case PDX(KSTACKTOP - 1):
		case PDX(UPAGES):

		case PDX(UENVS):

			assert(pgdir[i] & PTE_P);
  800420571f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205723:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420572a:	00 
  800420572b:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800420572f:	48 01 d0             	add    %rdx,%rax
  8004205732:	48 8b 00             	mov    (%rax),%rax
  8004205735:	83 e0 01             	and    $0x1,%eax
  8004205738:	48 85 c0             	test   %rax,%rax
  800420573b:	0f 85 05 01 00 00    	jne    8004205846 <check_boot_pml4e+0x71c>
  8004205741:	48 b9 83 fa 21 04 80 	movabs $0x800421fa83,%rcx
  8004205748:	00 00 00 
  800420574b:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004205752:	00 00 00 
  8004205755:	be 66 04 00 00       	mov    $0x466,%esi
  800420575a:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205761:	00 00 00 
  8004205764:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205769:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205770:	00 00 00 
  8004205773:	41 ff d0             	callq  *%r8
			break;
		default:
			if (i >= PDX(KERNBASE)) {
  8004205776:	48 83 7d f8 1f       	cmpq   $0x1f,-0x8(%rbp)
  800420577b:	0f 86 c8 00 00 00    	jbe    8004205849 <check_boot_pml4e+0x71f>
				if (pgdir[i] & PTE_P)
  8004205781:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205785:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420578c:	00 
  800420578d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004205791:	48 01 d0             	add    %rdx,%rax
  8004205794:	48 8b 00             	mov    (%rax),%rax
  8004205797:	83 e0 01             	and    $0x1,%eax
  800420579a:	48 85 c0             	test   %rax,%rax
  800420579d:	74 57                	je     80042057f6 <check_boot_pml4e+0x6cc>
					assert(pgdir[i] & PTE_W);
  800420579f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042057a3:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042057aa:	00 
  80042057ab:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042057af:	48 01 d0             	add    %rdx,%rax
  80042057b2:	48 8b 00             	mov    (%rax),%rax
  80042057b5:	83 e0 02             	and    $0x2,%eax
  80042057b8:	48 85 c0             	test   %rax,%rax
  80042057bb:	0f 85 88 00 00 00    	jne    8004205849 <check_boot_pml4e+0x71f>
  80042057c1:	48 b9 94 fa 21 04 80 	movabs $0x800421fa94,%rcx
  80042057c8:	00 00 00 
  80042057cb:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042057d2:	00 00 00 
  80042057d5:	be 6b 04 00 00       	mov    $0x46b,%esi
  80042057da:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042057e1:	00 00 00 
  80042057e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042057e9:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042057f0:	00 00 00 
  80042057f3:	41 ff d0             	callq  *%r8
				else
					assert(pgdir[i] == 0);
  80042057f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042057fa:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205801:	00 
  8004205802:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004205806:	48 01 d0             	add    %rdx,%rax
  8004205809:	48 8b 00             	mov    (%rax),%rax
  800420580c:	48 85 c0             	test   %rax,%rax
  800420580f:	74 38                	je     8004205849 <check_boot_pml4e+0x71f>
  8004205811:	48 b9 a5 fa 21 04 80 	movabs $0x800421faa5,%rcx
  8004205818:	00 00 00 
  800420581b:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004205822:	00 00 00 
  8004205825:	be 6d 04 00 00       	mov    $0x46d,%esi
  800420582a:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205831:	00 00 00 
  8004205834:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205839:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205840:	00 00 00 
  8004205843:	41 ff d0             	callq  *%r8
		case PDX(UPAGES):

		case PDX(UENVS):

			assert(pgdir[i] & PTE_P);
			break;
  8004205846:	90                   	nop
  8004205847:	eb 01                	jmp    800420584a <check_boot_pml4e+0x720>
				if (pgdir[i] & PTE_P)
					assert(pgdir[i] & PTE_W);
				else
					assert(pgdir[i] == 0);
			} 
			break;
  8004205849:	90                   	nop


	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  800420584a:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420584f:	48 81 7d f8 ff 01 00 	cmpq   $0x1ff,-0x8(%rbp)
  8004205856:	00 
  8004205857:	0f 86 ac fe ff ff    	jbe    8004205709 <check_boot_pml4e+0x5df>
					assert(pgdir[i] == 0);
			} 
			break;
		}
	}
	cprintf("check_boot_pml4e() succeeded!\n");
  800420585d:	48 bf b8 fa 21 04 80 	movabs $0x800421fab8,%rdi
  8004205864:	00 00 00 
  8004205867:	b8 00 00 00 00       	mov    $0x0,%eax
  800420586c:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004205873:	00 00 00 
  8004205876:	ff d2                	callq  *%rdx
}
  8004205878:	90                   	nop
  8004205879:	c9                   	leaveq 
  800420587a:	c3                   	retq   

000000800420587b <check_va2pa>:
// this functionality for us!  We define our own version to help check
// the check_boot_pml4e() function; it shouldn't be used elsewhere.

static physaddr_t
check_va2pa(pml4e_t *pml4e, uintptr_t va)
{
  800420587b:	55                   	push   %rbp
  800420587c:	48 89 e5             	mov    %rsp,%rbp
  800420587f:	48 83 ec 60          	sub    $0x60,%rsp
  8004205883:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004205887:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	pte_t *pte;
	pdpe_t *pdpe;
	pde_t *pde;
	// cprintf("%x", va);
	pml4e = &pml4e[PML4(va)];
  800420588b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420588f:	48 c1 e8 27          	shr    $0x27,%rax
  8004205893:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205898:	48 c1 e0 03          	shl    $0x3,%rax
  800420589c:	48 01 45 a8          	add    %rax,-0x58(%rbp)
	// cprintf(" %x %x " , PML4(va), *pml4e);
	if(!(*pml4e & PTE_P))
  80042058a0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042058a4:	48 8b 00             	mov    (%rax),%rax
  80042058a7:	83 e0 01             	and    $0x1,%eax
  80042058aa:	48 85 c0             	test   %rax,%rax
  80042058ad:	75 0c                	jne    80042058bb <check_va2pa+0x40>
		return ~0;
  80042058af:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  80042058b6:	e9 38 02 00 00       	jmpq   8004205af3 <check_va2pa+0x278>
	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*pml4e));
  80042058bb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042058bf:	48 8b 00             	mov    (%rax),%rax
  80042058c2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042058c8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042058cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042058d0:	48 c1 e8 0c          	shr    $0xc,%rax
  80042058d4:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042058d7:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042058da:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  80042058e1:	00 00 00 
  80042058e4:	48 8b 00             	mov    (%rax),%rax
  80042058e7:	48 39 c2             	cmp    %rax,%rdx
  80042058ea:	72 32                	jb     800420591e <check_va2pa+0xa3>
  80042058ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042058f0:	48 89 c1             	mov    %rax,%rcx
  80042058f3:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  80042058fa:	00 00 00 
  80042058fd:	be 85 04 00 00       	mov    $0x485,%esi
  8004205902:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205909:	00 00 00 
  800420590c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205911:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205918:	00 00 00 
  800420591b:	41 ff d0             	callq  *%r8
  800420591e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205925:	00 00 00 
  8004205928:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420592c:	48 01 d0             	add    %rdx,%rax
  800420592f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// cprintf(" %x %x " , pdpe, *pdpe);
	if (!(pdpe[PDPE(va)] & PTE_P))
  8004205933:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205937:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420593b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205940:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205947:	00 
  8004205948:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420594c:	48 01 d0             	add    %rdx,%rax
  800420594f:	48 8b 00             	mov    (%rax),%rax
  8004205952:	83 e0 01             	and    $0x1,%eax
  8004205955:	48 85 c0             	test   %rax,%rax
  8004205958:	75 0c                	jne    8004205966 <check_va2pa+0xeb>
		return ~0;
  800420595a:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205961:	e9 8d 01 00 00       	jmpq   8004205af3 <check_va2pa+0x278>
	pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004205966:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420596a:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420596e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205973:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420597a:	00 
  800420597b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420597f:	48 01 d0             	add    %rdx,%rax
  8004205982:	48 8b 00             	mov    (%rax),%rax
  8004205985:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420598b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420598f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205993:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205997:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420599a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420599d:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  80042059a4:	00 00 00 
  80042059a7:	48 8b 00             	mov    (%rax),%rax
  80042059aa:	48 39 c2             	cmp    %rax,%rdx
  80042059ad:	72 32                	jb     80042059e1 <check_va2pa+0x166>
  80042059af:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042059b3:	48 89 c1             	mov    %rax,%rcx
  80042059b6:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  80042059bd:	00 00 00 
  80042059c0:	be 89 04 00 00       	mov    $0x489,%esi
  80042059c5:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042059cc:	00 00 00 
  80042059cf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042059d4:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042059db:	00 00 00 
  80042059de:	41 ff d0             	callq  *%r8
  80042059e1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042059e8:	00 00 00 
  80042059eb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042059ef:	48 01 d0             	add    %rdx,%rax
  80042059f2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	// cprintf(" %x %x " , pde, *pde);
	pde = &pde[PDX(va)];
  80042059f6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042059fa:	48 c1 e8 15          	shr    $0x15,%rax
  80042059fe:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205a03:	48 c1 e0 03          	shl    $0x3,%rax
  8004205a07:	48 01 45 d0          	add    %rax,-0x30(%rbp)
	if (!(*pde & PTE_P))
  8004205a0b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205a0f:	48 8b 00             	mov    (%rax),%rax
  8004205a12:	83 e0 01             	and    $0x1,%eax
  8004205a15:	48 85 c0             	test   %rax,%rax
  8004205a18:	75 0c                	jne    8004205a26 <check_va2pa+0x1ab>
		return ~0;
  8004205a1a:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205a21:	e9 cd 00 00 00       	jmpq   8004205af3 <check_va2pa+0x278>
	pte = (pte_t*) KADDR(PTE_ADDR(*pde));
  8004205a26:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205a2a:	48 8b 00             	mov    (%rax),%rax
  8004205a2d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205a33:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205a37:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205a3b:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205a3f:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004205a42:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004205a45:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004205a4c:	00 00 00 
  8004205a4f:	48 8b 00             	mov    (%rax),%rax
  8004205a52:	48 39 c2             	cmp    %rax,%rdx
  8004205a55:	72 32                	jb     8004205a89 <check_va2pa+0x20e>
  8004205a57:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205a5b:	48 89 c1             	mov    %rax,%rcx
  8004205a5e:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  8004205a65:	00 00 00 
  8004205a68:	be 8e 04 00 00       	mov    $0x48e,%esi
  8004205a6d:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205a74:	00 00 00 
  8004205a77:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a7c:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205a83:	00 00 00 
  8004205a86:	41 ff d0             	callq  *%r8
  8004205a89:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205a90:	00 00 00 
  8004205a93:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205a97:	48 01 d0             	add    %rdx,%rax
  8004205a9a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	// cprintf(" %x %x " , pte, *pte);
	if (!(pte[PTX(va)] & PTE_P))
  8004205a9e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205aa2:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205aa6:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205aab:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205ab2:	00 
  8004205ab3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205ab7:	48 01 d0             	add    %rdx,%rax
  8004205aba:	48 8b 00             	mov    (%rax),%rax
  8004205abd:	83 e0 01             	and    $0x1,%eax
  8004205ac0:	48 85 c0             	test   %rax,%rax
  8004205ac3:	75 09                	jne    8004205ace <check_va2pa+0x253>
		return ~0;
  8004205ac5:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205acc:	eb 25                	jmp    8004205af3 <check_va2pa+0x278>
	// cprintf(" %x %x\n" , PTX(va),  PTE_ADDR(pte[PTX(va)]));
	return PTE_ADDR(pte[PTX(va)]);
  8004205ace:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205ad2:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205ad6:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205adb:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205ae2:	00 
  8004205ae3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205ae7:	48 01 d0             	add    %rdx,%rax
  8004205aea:	48 8b 00             	mov    (%rax),%rax
  8004205aed:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  8004205af3:	c9                   	leaveq 
  8004205af4:	c3                   	retq   

0000008004205af5 <page_check>:


// check page_insert, page_remove, &c
static void
page_check(void)
{
  8004205af5:	55                   	push   %rbp
  8004205af6:	48 89 e5             	mov    %rsp,%rbp
  8004205af9:	53                   	push   %rbx
  8004205afa:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
	void *va;
	int i;

	uintptr_t mm1, mm2;

	pp0 = pp1 = pp2 = pp3 = pp4 = pp5 =0;
  8004205b01:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004205b08:	00 
  8004205b09:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205b0d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205b11:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205b15:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004205b19:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205b1d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205b21:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205b25:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004205b29:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205b2d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	assert(pp0 = page_alloc(0));
  8004205b31:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205b36:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004205b3d:	00 00 00 
  8004205b40:	ff d0                	callq  *%rax
  8004205b42:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004205b46:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004205b4b:	75 35                	jne    8004205b82 <page_check+0x8d>
  8004205b4d:	48 b9 d7 fa 21 04 80 	movabs $0x800421fad7,%rcx
  8004205b54:	00 00 00 
  8004205b57:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004205b5e:	00 00 00 
  8004205b61:	be a6 04 00 00       	mov    $0x4a6,%esi
  8004205b66:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205b6d:	00 00 00 
  8004205b70:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b75:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205b7c:	00 00 00 
  8004205b7f:	41 ff d0             	callq  *%r8
	assert(pp1 = page_alloc(0));
  8004205b82:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205b87:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004205b8e:	00 00 00 
  8004205b91:	ff d0                	callq  *%rax
  8004205b93:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004205b97:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205b9c:	75 35                	jne    8004205bd3 <page_check+0xde>
  8004205b9e:	48 b9 eb fa 21 04 80 	movabs $0x800421faeb,%rcx
  8004205ba5:	00 00 00 
  8004205ba8:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004205baf:	00 00 00 
  8004205bb2:	be a7 04 00 00       	mov    $0x4a7,%esi
  8004205bb7:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205bbe:	00 00 00 
  8004205bc1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205bc6:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205bcd:	00 00 00 
  8004205bd0:	41 ff d0             	callq  *%r8
	assert(pp2 = page_alloc(0));
  8004205bd3:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205bd8:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004205bdf:	00 00 00 
  8004205be2:	ff d0                	callq  *%rax
  8004205be4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205be8:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205bed:	75 35                	jne    8004205c24 <page_check+0x12f>
  8004205bef:	48 b9 ff fa 21 04 80 	movabs $0x800421faff,%rcx
  8004205bf6:	00 00 00 
  8004205bf9:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004205c00:	00 00 00 
  8004205c03:	be a8 04 00 00       	mov    $0x4a8,%esi
  8004205c08:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205c0f:	00 00 00 
  8004205c12:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c17:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205c1e:	00 00 00 
  8004205c21:	41 ff d0             	callq  *%r8
	assert(pp3 = page_alloc(0));
  8004205c24:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205c29:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004205c30:	00 00 00 
  8004205c33:	ff d0                	callq  *%rax
  8004205c35:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004205c39:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205c3e:	75 35                	jne    8004205c75 <page_check+0x180>
  8004205c40:	48 b9 13 fb 21 04 80 	movabs $0x800421fb13,%rcx
  8004205c47:	00 00 00 
  8004205c4a:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004205c51:	00 00 00 
  8004205c54:	be a9 04 00 00       	mov    $0x4a9,%esi
  8004205c59:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205c60:	00 00 00 
  8004205c63:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c68:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205c6f:	00 00 00 
  8004205c72:	41 ff d0             	callq  *%r8
	assert(pp4 = page_alloc(0));
  8004205c75:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205c7a:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004205c81:	00 00 00 
  8004205c84:	ff d0                	callq  *%rax
  8004205c86:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205c8a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205c8f:	75 35                	jne    8004205cc6 <page_check+0x1d1>
  8004205c91:	48 b9 27 fb 21 04 80 	movabs $0x800421fb27,%rcx
  8004205c98:	00 00 00 
  8004205c9b:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004205ca2:	00 00 00 
  8004205ca5:	be aa 04 00 00       	mov    $0x4aa,%esi
  8004205caa:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205cb1:	00 00 00 
  8004205cb4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205cb9:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205cc0:	00 00 00 
  8004205cc3:	41 ff d0             	callq  *%r8
	assert(pp5 = page_alloc(0));
  8004205cc6:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205ccb:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004205cd2:	00 00 00 
  8004205cd5:	ff d0                	callq  *%rax
  8004205cd7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004205cdb:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205ce0:	75 35                	jne    8004205d17 <page_check+0x222>
  8004205ce2:	48 b9 3b fb 21 04 80 	movabs $0x800421fb3b,%rcx
  8004205ce9:	00 00 00 
  8004205cec:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004205cf3:	00 00 00 
  8004205cf6:	be ab 04 00 00       	mov    $0x4ab,%esi
  8004205cfb:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205d02:	00 00 00 
  8004205d05:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d0a:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205d11:	00 00 00 
  8004205d14:	41 ff d0             	callq  *%r8

	assert(pp0);
  8004205d17:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004205d1c:	75 35                	jne    8004205d53 <page_check+0x25e>
  8004205d1e:	48 b9 89 f8 21 04 80 	movabs $0x800421f889,%rcx
  8004205d25:	00 00 00 
  8004205d28:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004205d2f:	00 00 00 
  8004205d32:	be ad 04 00 00       	mov    $0x4ad,%esi
  8004205d37:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205d3e:	00 00 00 
  8004205d41:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d46:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205d4d:	00 00 00 
  8004205d50:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004205d53:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205d58:	74 0a                	je     8004205d64 <page_check+0x26f>
  8004205d5a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205d5e:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205d62:	75 35                	jne    8004205d99 <page_check+0x2a4>
  8004205d64:	48 b9 8d f8 21 04 80 	movabs $0x800421f88d,%rcx
  8004205d6b:	00 00 00 
  8004205d6e:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004205d75:	00 00 00 
  8004205d78:	be ae 04 00 00       	mov    $0x4ae,%esi
  8004205d7d:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205d84:	00 00 00 
  8004205d87:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d8c:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205d93:	00 00 00 
  8004205d96:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004205d99:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205d9e:	74 14                	je     8004205db4 <page_check+0x2bf>
  8004205da0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205da4:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205da8:	74 0a                	je     8004205db4 <page_check+0x2bf>
  8004205daa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205dae:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205db2:	75 35                	jne    8004205de9 <page_check+0x2f4>
  8004205db4:	48 b9 a0 f8 21 04 80 	movabs $0x800421f8a0,%rcx
  8004205dbb:	00 00 00 
  8004205dbe:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004205dc5:	00 00 00 
  8004205dc8:	be af 04 00 00       	mov    $0x4af,%esi
  8004205dcd:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205dd4:	00 00 00 
  8004205dd7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ddc:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205de3:	00 00 00 
  8004205de6:	41 ff d0             	callq  *%r8
	assert(pp3 && pp3 != pp2 && pp3 != pp1 && pp3 != pp0);
  8004205de9:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205dee:	74 1e                	je     8004205e0e <page_check+0x319>
  8004205df0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205df4:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205df8:	74 14                	je     8004205e0e <page_check+0x319>
  8004205dfa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205dfe:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205e02:	74 0a                	je     8004205e0e <page_check+0x319>
  8004205e04:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205e08:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205e0c:	75 35                	jne    8004205e43 <page_check+0x34e>
  8004205e0e:	48 b9 50 fb 21 04 80 	movabs $0x800421fb50,%rcx
  8004205e15:	00 00 00 
  8004205e18:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004205e1f:	00 00 00 
  8004205e22:	be b0 04 00 00       	mov    $0x4b0,%esi
  8004205e27:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205e2e:	00 00 00 
  8004205e31:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e36:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205e3d:	00 00 00 
  8004205e40:	41 ff d0             	callq  *%r8
	assert(pp4 && pp4 != pp3 && pp4 != pp2 && pp4 != pp1 && pp4 != pp0);
  8004205e43:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205e48:	74 28                	je     8004205e72 <page_check+0x37d>
  8004205e4a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205e4e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205e52:	74 1e                	je     8004205e72 <page_check+0x37d>
  8004205e54:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205e58:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205e5c:	74 14                	je     8004205e72 <page_check+0x37d>
  8004205e5e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205e62:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205e66:	74 0a                	je     8004205e72 <page_check+0x37d>
  8004205e68:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205e6c:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205e70:	75 35                	jne    8004205ea7 <page_check+0x3b2>
  8004205e72:	48 b9 80 fb 21 04 80 	movabs $0x800421fb80,%rcx
  8004205e79:	00 00 00 
  8004205e7c:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004205e83:	00 00 00 
  8004205e86:	be b1 04 00 00       	mov    $0x4b1,%esi
  8004205e8b:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205e92:	00 00 00 
  8004205e95:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e9a:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205ea1:	00 00 00 
  8004205ea4:	41 ff d0             	callq  *%r8
	assert(pp5 && pp5 != pp4 && pp5 != pp3 && pp5 != pp2 && pp5 != pp1 && pp5 != pp0);
  8004205ea7:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205eac:	74 32                	je     8004205ee0 <page_check+0x3eb>
  8004205eae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205eb2:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004205eb6:	74 28                	je     8004205ee0 <page_check+0x3eb>
  8004205eb8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205ebc:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205ec0:	74 1e                	je     8004205ee0 <page_check+0x3eb>
  8004205ec2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205ec6:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205eca:	74 14                	je     8004205ee0 <page_check+0x3eb>
  8004205ecc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205ed0:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205ed4:	74 0a                	je     8004205ee0 <page_check+0x3eb>
  8004205ed6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205eda:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205ede:	75 35                	jne    8004205f15 <page_check+0x420>
  8004205ee0:	48 b9 c0 fb 21 04 80 	movabs $0x800421fbc0,%rcx
  8004205ee7:	00 00 00 
  8004205eea:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004205ef1:	00 00 00 
  8004205ef4:	be b2 04 00 00       	mov    $0x4b2,%esi
  8004205ef9:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205f00:	00 00 00 
  8004205f03:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f08:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205f0f:	00 00 00 
  8004205f12:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004205f15:	48 b8 38 02 4e 04 80 	movabs $0x80044e0238,%rax
  8004205f1c:	00 00 00 
  8004205f1f:	48 8b 00             	mov    (%rax),%rax
  8004205f22:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	page_free_list = NULL;
  8004205f26:	48 b8 38 02 4e 04 80 	movabs $0x80044e0238,%rax
  8004205f2d:	00 00 00 
  8004205f30:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004205f37:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205f3c:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004205f43:	00 00 00 
  8004205f46:	ff d0                	callq  *%rax
  8004205f48:	48 85 c0             	test   %rax,%rax
  8004205f4b:	74 35                	je     8004205f82 <page_check+0x48d>
  8004205f4d:	48 b9 17 f9 21 04 80 	movabs $0x800421f917,%rcx
  8004205f54:	00 00 00 
  8004205f57:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004205f5e:	00 00 00 
  8004205f61:	be b9 04 00 00       	mov    $0x4b9,%esi
  8004205f66:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205f6d:	00 00 00 
  8004205f70:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f75:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205f7c:	00 00 00 
  8004205f7f:	41 ff d0             	callq  *%r8

	// there is no page allocated at address 0
	assert(page_lookup(boot_pml4e, (void *) 0x0, &ptep) == NULL);
  8004205f82:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004205f89:	00 00 00 
  8004205f8c:	48 8b 00             	mov    (%rax),%rax
  8004205f8f:	48 8d 95 e0 fe ff ff 	lea    -0x120(%rbp),%rdx
  8004205f96:	be 00 00 00 00       	mov    $0x0,%esi
  8004205f9b:	48 89 c7             	mov    %rax,%rdi
  8004205f9e:	48 b8 a7 3d 20 04 80 	movabs $0x8004203da7,%rax
  8004205fa5:	00 00 00 
  8004205fa8:	ff d0                	callq  *%rax
  8004205faa:	48 85 c0             	test   %rax,%rax
  8004205fad:	74 35                	je     8004205fe4 <page_check+0x4ef>
  8004205faf:	48 b9 10 fc 21 04 80 	movabs $0x800421fc10,%rcx
  8004205fb6:	00 00 00 
  8004205fb9:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004205fc0:	00 00 00 
  8004205fc3:	be bc 04 00 00       	mov    $0x4bc,%esi
  8004205fc8:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004205fcf:	00 00 00 
  8004205fd2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205fd7:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004205fde:	00 00 00 
  8004205fe1:	41 ff d0             	callq  *%r8

	// there is no free memory, so we can't allocate a page table 
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004205fe4:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004205feb:	00 00 00 
  8004205fee:	48 8b 00             	mov    (%rax),%rax
  8004205ff1:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205ff5:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205ffa:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205fff:	48 89 c7             	mov    %rax,%rdi
  8004206002:	48 b8 33 3a 20 04 80 	movabs $0x8004203a33,%rax
  8004206009:	00 00 00 
  800420600c:	ff d0                	callq  *%rax
  800420600e:	85 c0                	test   %eax,%eax
  8004206010:	78 35                	js     8004206047 <page_check+0x552>
  8004206012:	48 b9 48 fc 21 04 80 	movabs $0x800421fc48,%rcx
  8004206019:	00 00 00 
  800420601c:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206023:	00 00 00 
  8004206026:	be bf 04 00 00       	mov    $0x4bf,%esi
  800420602b:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206032:	00 00 00 
  8004206035:	b8 00 00 00 00       	mov    $0x0,%eax
  800420603a:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206041:	00 00 00 
  8004206044:	41 ff d0             	callq  *%r8

	// free pp0 and try again: pp0 should be used for page table
	page_free(pp0);
  8004206047:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420604b:	48 89 c7             	mov    %rax,%rdi
  800420604e:	48 b8 65 2f 20 04 80 	movabs $0x8004202f65,%rax
  8004206055:	00 00 00 
  8004206058:	ff d0                	callq  *%rax
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  800420605a:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004206061:	00 00 00 
  8004206064:	48 8b 00             	mov    (%rax),%rax
  8004206067:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420606b:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206070:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206075:	48 89 c7             	mov    %rax,%rdi
  8004206078:	48 b8 33 3a 20 04 80 	movabs $0x8004203a33,%rax
  800420607f:	00 00 00 
  8004206082:	ff d0                	callq  *%rax
  8004206084:	85 c0                	test   %eax,%eax
  8004206086:	78 35                	js     80042060bd <page_check+0x5c8>
  8004206088:	48 b9 48 fc 21 04 80 	movabs $0x800421fc48,%rcx
  800420608f:	00 00 00 
  8004206092:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206099:	00 00 00 
  800420609c:	be c3 04 00 00       	mov    $0x4c3,%esi
  80042060a1:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042060a8:	00 00 00 
  80042060ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80042060b0:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042060b7:	00 00 00 
  80042060ba:	41 ff d0             	callq  *%r8
	page_free(pp2);
  80042060bd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042060c1:	48 89 c7             	mov    %rax,%rdi
  80042060c4:	48 b8 65 2f 20 04 80 	movabs $0x8004202f65,%rax
  80042060cb:	00 00 00 
  80042060ce:	ff d0                	callq  *%rax
	page_free(pp3);
  80042060d0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042060d4:	48 89 c7             	mov    %rax,%rdi
  80042060d7:	48 b8 65 2f 20 04 80 	movabs $0x8004202f65,%rax
  80042060de:	00 00 00 
  80042060e1:	ff d0                	callq  *%rax
	//cprintf("pp1 ref count = %d\n",pp1->pp_ref);
	//cprintf("pp0 ref count = %d\n",pp0->pp_ref);
	//cprintf("pp2 ref count = %d\n",pp2->pp_ref);
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) == 0);
  80042060e3:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  80042060ea:	00 00 00 
  80042060ed:	48 8b 00             	mov    (%rax),%rax
  80042060f0:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042060f4:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042060f9:	ba 00 00 00 00       	mov    $0x0,%edx
  80042060fe:	48 89 c7             	mov    %rax,%rdi
  8004206101:	48 b8 33 3a 20 04 80 	movabs $0x8004203a33,%rax
  8004206108:	00 00 00 
  800420610b:	ff d0                	callq  *%rax
  800420610d:	85 c0                	test   %eax,%eax
  800420610f:	74 35                	je     8004206146 <page_check+0x651>
  8004206111:	48 b9 78 fc 21 04 80 	movabs $0x800421fc78,%rcx
  8004206118:	00 00 00 
  800420611b:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206122:	00 00 00 
  8004206125:	be c9 04 00 00       	mov    $0x4c9,%esi
  800420612a:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206131:	00 00 00 
  8004206134:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206139:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206140:	00 00 00 
  8004206143:	41 ff d0             	callq  *%r8
	assert((PTE_ADDR(boot_pml4e[0]) == page2pa(pp0) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp2) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp3) ));
  8004206146:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  800420614d:	00 00 00 
  8004206150:	48 8b 00             	mov    (%rax),%rax
  8004206153:	48 8b 00             	mov    (%rax),%rax
  8004206156:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420615c:	48 89 c3             	mov    %rax,%rbx
  800420615f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206163:	48 89 c7             	mov    %rax,%rdi
  8004206166:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  800420616d:	00 00 00 
  8004206170:	ff d0                	callq  *%rax
  8004206172:	48 39 c3             	cmp    %rax,%rbx
  8004206175:	0f 84 97 00 00 00    	je     8004206212 <page_check+0x71d>
  800420617b:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004206182:	00 00 00 
  8004206185:	48 8b 00             	mov    (%rax),%rax
  8004206188:	48 8b 00             	mov    (%rax),%rax
  800420618b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206191:	48 89 c3             	mov    %rax,%rbx
  8004206194:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206198:	48 89 c7             	mov    %rax,%rdi
  800420619b:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  80042061a2:	00 00 00 
  80042061a5:	ff d0                	callq  *%rax
  80042061a7:	48 39 c3             	cmp    %rax,%rbx
  80042061aa:	74 66                	je     8004206212 <page_check+0x71d>
  80042061ac:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  80042061b3:	00 00 00 
  80042061b6:	48 8b 00             	mov    (%rax),%rax
  80042061b9:	48 8b 00             	mov    (%rax),%rax
  80042061bc:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042061c2:	48 89 c3             	mov    %rax,%rbx
  80042061c5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042061c9:	48 89 c7             	mov    %rax,%rdi
  80042061cc:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  80042061d3:	00 00 00 
  80042061d6:	ff d0                	callq  *%rax
  80042061d8:	48 39 c3             	cmp    %rax,%rbx
  80042061db:	74 35                	je     8004206212 <page_check+0x71d>
  80042061dd:	48 b9 a8 fc 21 04 80 	movabs $0x800421fca8,%rcx
  80042061e4:	00 00 00 
  80042061e7:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042061ee:	00 00 00 
  80042061f1:	be ca 04 00 00       	mov    $0x4ca,%esi
  80042061f6:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042061fd:	00 00 00 
  8004206200:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206205:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420620c:	00 00 00 
  800420620f:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, 0x0) == page2pa(pp1));
  8004206212:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004206219:	00 00 00 
  800420621c:	48 8b 00             	mov    (%rax),%rax
  800420621f:	be 00 00 00 00       	mov    $0x0,%esi
  8004206224:	48 89 c7             	mov    %rax,%rdi
  8004206227:	48 b8 7b 58 20 04 80 	movabs $0x800420587b,%rax
  800420622e:	00 00 00 
  8004206231:	ff d0                	callq  *%rax
  8004206233:	48 89 c3             	mov    %rax,%rbx
  8004206236:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420623a:	48 89 c7             	mov    %rax,%rdi
  800420623d:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  8004206244:	00 00 00 
  8004206247:	ff d0                	callq  *%rax
  8004206249:	48 39 c3             	cmp    %rax,%rbx
  800420624c:	74 35                	je     8004206283 <page_check+0x78e>
  800420624e:	48 b9 30 fd 21 04 80 	movabs $0x800421fd30,%rcx
  8004206255:	00 00 00 
  8004206258:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  800420625f:	00 00 00 
  8004206262:	be cb 04 00 00       	mov    $0x4cb,%esi
  8004206267:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420626e:	00 00 00 
  8004206271:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206276:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420627d:	00 00 00 
  8004206280:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004206283:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206287:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420628b:	66 83 f8 01          	cmp    $0x1,%ax
  800420628f:	74 35                	je     80042062c6 <page_check+0x7d1>
  8004206291:	48 b9 5d fd 21 04 80 	movabs $0x800421fd5d,%rcx
  8004206298:	00 00 00 
  800420629b:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042062a2:	00 00 00 
  80042062a5:	be cc 04 00 00       	mov    $0x4cc,%esi
  80042062aa:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042062b1:	00 00 00 
  80042062b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042062b9:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042062c0:	00 00 00 
  80042062c3:	41 ff d0             	callq  *%r8
	assert(pp0->pp_ref == 1);
  80042062c6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042062ca:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042062ce:	66 83 f8 01          	cmp    $0x1,%ax
  80042062d2:	74 35                	je     8004206309 <page_check+0x814>
  80042062d4:	48 b9 6e fd 21 04 80 	movabs $0x800421fd6e,%rcx
  80042062db:	00 00 00 
  80042062de:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042062e5:	00 00 00 
  80042062e8:	be cd 04 00 00       	mov    $0x4cd,%esi
  80042062ed:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042062f4:	00 00 00 
  80042062f7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042062fc:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206303:	00 00 00 
  8004206306:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 1);
  8004206309:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420630d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206311:	66 83 f8 01          	cmp    $0x1,%ax
  8004206315:	74 35                	je     800420634c <page_check+0x857>
  8004206317:	48 b9 7f fd 21 04 80 	movabs $0x800421fd7f,%rcx
  800420631e:	00 00 00 
  8004206321:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206328:	00 00 00 
  800420632b:	be ce 04 00 00       	mov    $0x4ce,%esi
  8004206330:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206337:	00 00 00 
  800420633a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420633f:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206346:	00 00 00 
  8004206349:	41 ff d0             	callq  *%r8
	//should be able to map pp3 at PGSIZE because pp0 is already allocated for page table
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  800420634c:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004206353:	00 00 00 
  8004206356:	48 8b 00             	mov    (%rax),%rax
  8004206359:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420635d:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206362:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206367:	48 89 c7             	mov    %rax,%rdi
  800420636a:	48 b8 33 3a 20 04 80 	movabs $0x8004203a33,%rax
  8004206371:	00 00 00 
  8004206374:	ff d0                	callq  *%rax
  8004206376:	85 c0                	test   %eax,%eax
  8004206378:	74 35                	je     80042063af <page_check+0x8ba>
  800420637a:	48 b9 90 fd 21 04 80 	movabs $0x800421fd90,%rcx
  8004206381:	00 00 00 
  8004206384:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  800420638b:	00 00 00 
  800420638e:	be d0 04 00 00       	mov    $0x4d0,%esi
  8004206393:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420639a:	00 00 00 
  800420639d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042063a2:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042063a9:	00 00 00 
  80042063ac:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  80042063af:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  80042063b6:	00 00 00 
  80042063b9:	48 8b 00             	mov    (%rax),%rax
  80042063bc:	be 00 10 00 00       	mov    $0x1000,%esi
  80042063c1:	48 89 c7             	mov    %rax,%rdi
  80042063c4:	48 b8 7b 58 20 04 80 	movabs $0x800420587b,%rax
  80042063cb:	00 00 00 
  80042063ce:	ff d0                	callq  *%rax
  80042063d0:	48 89 c3             	mov    %rax,%rbx
  80042063d3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042063d7:	48 89 c7             	mov    %rax,%rdi
  80042063da:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  80042063e1:	00 00 00 
  80042063e4:	ff d0                	callq  *%rax
  80042063e6:	48 39 c3             	cmp    %rax,%rbx
  80042063e9:	74 35                	je     8004206420 <page_check+0x92b>
  80042063eb:	48 b9 c8 fd 21 04 80 	movabs $0x800421fdc8,%rcx
  80042063f2:	00 00 00 
  80042063f5:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042063fc:	00 00 00 
  80042063ff:	be d1 04 00 00       	mov    $0x4d1,%esi
  8004206404:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420640b:	00 00 00 
  800420640e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206413:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420641a:	00 00 00 
  800420641d:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004206420:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206424:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206428:	66 83 f8 02          	cmp    $0x2,%ax
  800420642c:	74 35                	je     8004206463 <page_check+0x96e>
  800420642e:	48 b9 f8 fd 21 04 80 	movabs $0x800421fdf8,%rcx
  8004206435:	00 00 00 
  8004206438:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  800420643f:	00 00 00 
  8004206442:	be d2 04 00 00       	mov    $0x4d2,%esi
  8004206447:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420644e:	00 00 00 
  8004206451:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206456:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420645d:	00 00 00 
  8004206460:	41 ff d0             	callq  *%r8

	// should be no free memory
	assert(!page_alloc(0));
  8004206463:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206468:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  800420646f:	00 00 00 
  8004206472:	ff d0                	callq  *%rax
  8004206474:	48 85 c0             	test   %rax,%rax
  8004206477:	74 35                	je     80042064ae <page_check+0x9b9>
  8004206479:	48 b9 17 f9 21 04 80 	movabs $0x800421f917,%rcx
  8004206480:	00 00 00 
  8004206483:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  800420648a:	00 00 00 
  800420648d:	be d5 04 00 00       	mov    $0x4d5,%esi
  8004206492:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206499:	00 00 00 
  800420649c:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064a1:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042064a8:	00 00 00 
  80042064ab:	41 ff d0             	callq  *%r8

	// should be able to map pp3 at PGSIZE because it's already there
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  80042064ae:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  80042064b5:	00 00 00 
  80042064b8:	48 8b 00             	mov    (%rax),%rax
  80042064bb:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042064bf:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042064c4:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042064c9:	48 89 c7             	mov    %rax,%rdi
  80042064cc:	48 b8 33 3a 20 04 80 	movabs $0x8004203a33,%rax
  80042064d3:	00 00 00 
  80042064d6:	ff d0                	callq  *%rax
  80042064d8:	85 c0                	test   %eax,%eax
  80042064da:	74 35                	je     8004206511 <page_check+0xa1c>
  80042064dc:	48 b9 90 fd 21 04 80 	movabs $0x800421fd90,%rcx
  80042064e3:	00 00 00 
  80042064e6:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042064ed:	00 00 00 
  80042064f0:	be d8 04 00 00       	mov    $0x4d8,%esi
  80042064f5:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042064fc:	00 00 00 
  80042064ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206504:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420650b:	00 00 00 
  800420650e:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004206511:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004206518:	00 00 00 
  800420651b:	48 8b 00             	mov    (%rax),%rax
  800420651e:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206523:	48 89 c7             	mov    %rax,%rdi
  8004206526:	48 b8 7b 58 20 04 80 	movabs $0x800420587b,%rax
  800420652d:	00 00 00 
  8004206530:	ff d0                	callq  *%rax
  8004206532:	48 89 c3             	mov    %rax,%rbx
  8004206535:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206539:	48 89 c7             	mov    %rax,%rdi
  800420653c:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  8004206543:	00 00 00 
  8004206546:	ff d0                	callq  *%rax
  8004206548:	48 39 c3             	cmp    %rax,%rbx
  800420654b:	74 35                	je     8004206582 <page_check+0xa8d>
  800420654d:	48 b9 c8 fd 21 04 80 	movabs $0x800421fdc8,%rcx
  8004206554:	00 00 00 
  8004206557:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  800420655e:	00 00 00 
  8004206561:	be d9 04 00 00       	mov    $0x4d9,%esi
  8004206566:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420656d:	00 00 00 
  8004206570:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206575:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420657c:	00 00 00 
  800420657f:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004206582:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206586:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420658a:	66 83 f8 02          	cmp    $0x2,%ax
  800420658e:	74 35                	je     80042065c5 <page_check+0xad0>
  8004206590:	48 b9 f8 fd 21 04 80 	movabs $0x800421fdf8,%rcx
  8004206597:	00 00 00 
  800420659a:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042065a1:	00 00 00 
  80042065a4:	be da 04 00 00       	mov    $0x4da,%esi
  80042065a9:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042065b0:	00 00 00 
  80042065b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042065b8:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042065bf:	00 00 00 
  80042065c2:	41 ff d0             	callq  *%r8

	// pp3 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
	assert(!page_alloc(0));
  80042065c5:	bf 00 00 00 00       	mov    $0x0,%edi
  80042065ca:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  80042065d1:	00 00 00 
  80042065d4:	ff d0                	callq  *%rax
  80042065d6:	48 85 c0             	test   %rax,%rax
  80042065d9:	74 35                	je     8004206610 <page_check+0xb1b>
  80042065db:	48 b9 17 f9 21 04 80 	movabs $0x800421f917,%rcx
  80042065e2:	00 00 00 
  80042065e5:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042065ec:	00 00 00 
  80042065ef:	be de 04 00 00       	mov    $0x4de,%esi
  80042065f4:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042065fb:	00 00 00 
  80042065fe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206603:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420660a:	00 00 00 
  800420660d:	41 ff d0             	callq  *%r8
	// check that pgdir_walk returns a pointer to the pte
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(PGSIZE)]));
  8004206610:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004206617:	00 00 00 
  800420661a:	48 8b 00             	mov    (%rax),%rax
  800420661d:	48 8b 00             	mov    (%rax),%rax
  8004206620:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206626:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  800420662a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420662e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206632:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  8004206635:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004206638:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  800420663f:	00 00 00 
  8004206642:	48 8b 00             	mov    (%rax),%rax
  8004206645:	48 39 c2             	cmp    %rax,%rdx
  8004206648:	72 32                	jb     800420667c <page_check+0xb87>
  800420664a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420664e:	48 89 c1             	mov    %rax,%rcx
  8004206651:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  8004206658:	00 00 00 
  800420665b:	be e0 04 00 00       	mov    $0x4e0,%esi
  8004206660:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206667:	00 00 00 
  800420666a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420666f:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206676:	00 00 00 
  8004206679:	41 ff d0             	callq  *%r8
  800420667c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206683:	00 00 00 
  8004206686:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420668a:	48 01 d0             	add    %rdx,%rax
  800420668d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde = KADDR(PTE_ADDR(pdpe[PDPE(PGSIZE)]));
  8004206691:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206695:	48 8b 00             	mov    (%rax),%rax
  8004206698:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420669e:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  80042066a2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042066a6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042066aa:	89 45 8c             	mov    %eax,-0x74(%rbp)
  80042066ad:	8b 55 8c             	mov    -0x74(%rbp),%edx
  80042066b0:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  80042066b7:	00 00 00 
  80042066ba:	48 8b 00             	mov    (%rax),%rax
  80042066bd:	48 39 c2             	cmp    %rax,%rdx
  80042066c0:	72 32                	jb     80042066f4 <page_check+0xbff>
  80042066c2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042066c6:	48 89 c1             	mov    %rax,%rcx
  80042066c9:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  80042066d0:	00 00 00 
  80042066d3:	be e1 04 00 00       	mov    $0x4e1,%esi
  80042066d8:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042066df:	00 00 00 
  80042066e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042066e7:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042066ee:	00 00 00 
  80042066f1:	41 ff d0             	callq  *%r8
  80042066f4:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042066fb:	00 00 00 
  80042066fe:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004206702:	48 01 d0             	add    %rdx,%rax
  8004206705:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep = KADDR(PTE_ADDR(pde[PDX(PGSIZE)]));
  8004206709:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800420670d:	48 8b 00             	mov    (%rax),%rax
  8004206710:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206716:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  800420671d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206724:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206728:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  800420672e:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  8004206734:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  800420673b:	00 00 00 
  800420673e:	48 8b 00             	mov    (%rax),%rax
  8004206741:	48 39 c2             	cmp    %rax,%rdx
  8004206744:	72 35                	jb     800420677b <page_check+0xc86>
  8004206746:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420674d:	48 89 c1             	mov    %rax,%rcx
  8004206750:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  8004206757:	00 00 00 
  800420675a:	be e2 04 00 00       	mov    $0x4e2,%esi
  800420675f:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206766:	00 00 00 
  8004206769:	b8 00 00 00 00       	mov    $0x0,%eax
  800420676e:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206775:	00 00 00 
  8004206778:	41 ff d0             	callq  *%r8
  800420677b:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206782:	00 00 00 
  8004206785:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420678c:	48 01 d0             	add    %rdx,%rax
  800420678f:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	assert(pml4e_walk(boot_pml4e, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
  8004206796:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  800420679d:	00 00 00 
  80042067a0:	48 8b 00             	mov    (%rax),%rax
  80042067a3:	ba 00 00 00 00       	mov    $0x0,%edx
  80042067a8:	be 00 10 00 00       	mov    $0x1000,%esi
  80042067ad:	48 89 c7             	mov    %rax,%rdi
  80042067b0:	48 b8 29 30 20 04 80 	movabs $0x8004203029,%rax
  80042067b7:	00 00 00 
  80042067ba:	ff d0                	callq  *%rax
  80042067bc:	48 89 c2             	mov    %rax,%rdx
  80042067bf:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  80042067c6:	48 83 c0 08          	add    $0x8,%rax
  80042067ca:	48 39 c2             	cmp    %rax,%rdx
  80042067cd:	74 35                	je     8004206804 <page_check+0xd0f>
  80042067cf:	48 b9 10 fe 21 04 80 	movabs $0x800421fe10,%rcx
  80042067d6:	00 00 00 
  80042067d9:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042067e0:	00 00 00 
  80042067e3:	be e3 04 00 00       	mov    $0x4e3,%esi
  80042067e8:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042067ef:	00 00 00 
  80042067f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042067f7:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042067fe:	00 00 00 
  8004206801:	41 ff d0             	callq  *%r8

	// should be able to change permissions too.
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, PTE_U) == 0);
  8004206804:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  800420680b:	00 00 00 
  800420680e:	48 8b 00             	mov    (%rax),%rax
  8004206811:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004206815:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420681a:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420681f:	48 89 c7             	mov    %rax,%rdi
  8004206822:	48 b8 33 3a 20 04 80 	movabs $0x8004203a33,%rax
  8004206829:	00 00 00 
  800420682c:	ff d0                	callq  *%rax
  800420682e:	85 c0                	test   %eax,%eax
  8004206830:	74 35                	je     8004206867 <page_check+0xd72>
  8004206832:	48 b9 50 fe 21 04 80 	movabs $0x800421fe50,%rcx
  8004206839:	00 00 00 
  800420683c:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206843:	00 00 00 
  8004206846:	be e6 04 00 00       	mov    $0x4e6,%esi
  800420684b:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206852:	00 00 00 
  8004206855:	b8 00 00 00 00       	mov    $0x0,%eax
  800420685a:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206861:	00 00 00 
  8004206864:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004206867:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  800420686e:	00 00 00 
  8004206871:	48 8b 00             	mov    (%rax),%rax
  8004206874:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206879:	48 89 c7             	mov    %rax,%rdi
  800420687c:	48 b8 7b 58 20 04 80 	movabs $0x800420587b,%rax
  8004206883:	00 00 00 
  8004206886:	ff d0                	callq  *%rax
  8004206888:	48 89 c3             	mov    %rax,%rbx
  800420688b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420688f:	48 89 c7             	mov    %rax,%rdi
  8004206892:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  8004206899:	00 00 00 
  800420689c:	ff d0                	callq  *%rax
  800420689e:	48 39 c3             	cmp    %rax,%rbx
  80042068a1:	74 35                	je     80042068d8 <page_check+0xde3>
  80042068a3:	48 b9 c8 fd 21 04 80 	movabs $0x800421fdc8,%rcx
  80042068aa:	00 00 00 
  80042068ad:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042068b4:	00 00 00 
  80042068b7:	be e7 04 00 00       	mov    $0x4e7,%esi
  80042068bc:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042068c3:	00 00 00 
  80042068c6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042068cb:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042068d2:	00 00 00 
  80042068d5:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  80042068d8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042068dc:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042068e0:	66 83 f8 02          	cmp    $0x2,%ax
  80042068e4:	74 35                	je     800420691b <page_check+0xe26>
  80042068e6:	48 b9 f8 fd 21 04 80 	movabs $0x800421fdf8,%rcx
  80042068ed:	00 00 00 
  80042068f0:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042068f7:	00 00 00 
  80042068fa:	be e8 04 00 00       	mov    $0x4e8,%esi
  80042068ff:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206906:	00 00 00 
  8004206909:	b8 00 00 00 00       	mov    $0x0,%eax
  800420690e:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206915:	00 00 00 
  8004206918:	41 ff d0             	callq  *%r8
	assert(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U);
  800420691b:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004206922:	00 00 00 
  8004206925:	48 8b 00             	mov    (%rax),%rax
  8004206928:	ba 00 00 00 00       	mov    $0x0,%edx
  800420692d:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206932:	48 89 c7             	mov    %rax,%rdi
  8004206935:	48 b8 29 30 20 04 80 	movabs $0x8004203029,%rax
  800420693c:	00 00 00 
  800420693f:	ff d0                	callq  *%rax
  8004206941:	48 8b 00             	mov    (%rax),%rax
  8004206944:	83 e0 04             	and    $0x4,%eax
  8004206947:	48 85 c0             	test   %rax,%rax
  800420694a:	75 35                	jne    8004206981 <page_check+0xe8c>
  800420694c:	48 b9 90 fe 21 04 80 	movabs $0x800421fe90,%rcx
  8004206953:	00 00 00 
  8004206956:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  800420695d:	00 00 00 
  8004206960:	be e9 04 00 00       	mov    $0x4e9,%esi
  8004206965:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420696c:	00 00 00 
  800420696f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206974:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420697b:	00 00 00 
  800420697e:	41 ff d0             	callq  *%r8
	assert(boot_pml4e[0] & PTE_U);
  8004206981:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004206988:	00 00 00 
  800420698b:	48 8b 00             	mov    (%rax),%rax
  800420698e:	48 8b 00             	mov    (%rax),%rax
  8004206991:	83 e0 04             	and    $0x4,%eax
  8004206994:	48 85 c0             	test   %rax,%rax
  8004206997:	75 35                	jne    80042069ce <page_check+0xed9>
  8004206999:	48 b9 c3 fe 21 04 80 	movabs $0x800421fec3,%rcx
  80042069a0:	00 00 00 
  80042069a3:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042069aa:	00 00 00 
  80042069ad:	be ea 04 00 00       	mov    $0x4ea,%esi
  80042069b2:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042069b9:	00 00 00 
  80042069bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042069c1:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042069c8:	00 00 00 
  80042069cb:	41 ff d0             	callq  *%r8


	// should not be able to map at PTSIZE because need free page for page table
	assert(page_insert(boot_pml4e, pp0, (void*) PTSIZE, 0) < 0);
  80042069ce:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  80042069d5:	00 00 00 
  80042069d8:	48 8b 00             	mov    (%rax),%rax
  80042069db:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80042069df:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042069e4:	ba 00 00 20 00       	mov    $0x200000,%edx
  80042069e9:	48 89 c7             	mov    %rax,%rdi
  80042069ec:	48 b8 33 3a 20 04 80 	movabs $0x8004203a33,%rax
  80042069f3:	00 00 00 
  80042069f6:	ff d0                	callq  *%rax
  80042069f8:	85 c0                	test   %eax,%eax
  80042069fa:	78 35                	js     8004206a31 <page_check+0xf3c>
  80042069fc:	48 b9 e0 fe 21 04 80 	movabs $0x800421fee0,%rcx
  8004206a03:	00 00 00 
  8004206a06:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206a0d:	00 00 00 
  8004206a10:	be ee 04 00 00       	mov    $0x4ee,%esi
  8004206a15:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206a1c:	00 00 00 
  8004206a1f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a24:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206a2b:	00 00 00 
  8004206a2e:	41 ff d0             	callq  *%r8

	// insert pp1 at PGSIZE (replacing pp3)
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004206a31:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004206a38:	00 00 00 
  8004206a3b:	48 8b 00             	mov    (%rax),%rax
  8004206a3e:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206a42:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206a47:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206a4c:	48 89 c7             	mov    %rax,%rdi
  8004206a4f:	48 b8 33 3a 20 04 80 	movabs $0x8004203a33,%rax
  8004206a56:	00 00 00 
  8004206a59:	ff d0                	callq  *%rax
  8004206a5b:	85 c0                	test   %eax,%eax
  8004206a5d:	74 35                	je     8004206a94 <page_check+0xf9f>
  8004206a5f:	48 b9 18 ff 21 04 80 	movabs $0x800421ff18,%rcx
  8004206a66:	00 00 00 
  8004206a69:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206a70:	00 00 00 
  8004206a73:	be f1 04 00 00       	mov    $0x4f1,%esi
  8004206a78:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206a7f:	00 00 00 
  8004206a82:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a87:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206a8e:	00 00 00 
  8004206a91:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U));
  8004206a94:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004206a9b:	00 00 00 
  8004206a9e:	48 8b 00             	mov    (%rax),%rax
  8004206aa1:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206aa6:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206aab:	48 89 c7             	mov    %rax,%rdi
  8004206aae:	48 b8 29 30 20 04 80 	movabs $0x8004203029,%rax
  8004206ab5:	00 00 00 
  8004206ab8:	ff d0                	callq  *%rax
  8004206aba:	48 8b 00             	mov    (%rax),%rax
  8004206abd:	83 e0 04             	and    $0x4,%eax
  8004206ac0:	48 85 c0             	test   %rax,%rax
  8004206ac3:	74 35                	je     8004206afa <page_check+0x1005>
  8004206ac5:	48 b9 50 ff 21 04 80 	movabs $0x800421ff50,%rcx
  8004206acc:	00 00 00 
  8004206acf:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206ad6:	00 00 00 
  8004206ad9:	be f2 04 00 00       	mov    $0x4f2,%esi
  8004206ade:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206ae5:	00 00 00 
  8004206ae8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206aed:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206af4:	00 00 00 
  8004206af7:	41 ff d0             	callq  *%r8

	// should have pp1 at both 0 and PGSIZE
	assert(check_va2pa(boot_pml4e, 0) == page2pa(pp1));
  8004206afa:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004206b01:	00 00 00 
  8004206b04:	48 8b 00             	mov    (%rax),%rax
  8004206b07:	be 00 00 00 00       	mov    $0x0,%esi
  8004206b0c:	48 89 c7             	mov    %rax,%rdi
  8004206b0f:	48 b8 7b 58 20 04 80 	movabs $0x800420587b,%rax
  8004206b16:	00 00 00 
  8004206b19:	ff d0                	callq  *%rax
  8004206b1b:	48 89 c3             	mov    %rax,%rbx
  8004206b1e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206b22:	48 89 c7             	mov    %rax,%rdi
  8004206b25:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  8004206b2c:	00 00 00 
  8004206b2f:	ff d0                	callq  *%rax
  8004206b31:	48 39 c3             	cmp    %rax,%rbx
  8004206b34:	74 35                	je     8004206b6b <page_check+0x1076>
  8004206b36:	48 b9 88 ff 21 04 80 	movabs $0x800421ff88,%rcx
  8004206b3d:	00 00 00 
  8004206b40:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206b47:	00 00 00 
  8004206b4a:	be f5 04 00 00       	mov    $0x4f5,%esi
  8004206b4f:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206b56:	00 00 00 
  8004206b59:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b5e:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206b65:	00 00 00 
  8004206b68:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206b6b:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004206b72:	00 00 00 
  8004206b75:	48 8b 00             	mov    (%rax),%rax
  8004206b78:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206b7d:	48 89 c7             	mov    %rax,%rdi
  8004206b80:	48 b8 7b 58 20 04 80 	movabs $0x800420587b,%rax
  8004206b87:	00 00 00 
  8004206b8a:	ff d0                	callq  *%rax
  8004206b8c:	48 89 c3             	mov    %rax,%rbx
  8004206b8f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206b93:	48 89 c7             	mov    %rax,%rdi
  8004206b96:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  8004206b9d:	00 00 00 
  8004206ba0:	ff d0                	callq  *%rax
  8004206ba2:	48 39 c3             	cmp    %rax,%rbx
  8004206ba5:	74 35                	je     8004206bdc <page_check+0x10e7>
  8004206ba7:	48 b9 b8 ff 21 04 80 	movabs $0x800421ffb8,%rcx
  8004206bae:	00 00 00 
  8004206bb1:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206bb8:	00 00 00 
  8004206bbb:	be f6 04 00 00       	mov    $0x4f6,%esi
  8004206bc0:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206bc7:	00 00 00 
  8004206bca:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206bcf:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206bd6:	00 00 00 
  8004206bd9:	41 ff d0             	callq  *%r8
	// ... and ref counts should reflect this
	assert(pp1->pp_ref == 2);
  8004206bdc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206be0:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206be4:	66 83 f8 02          	cmp    $0x2,%ax
  8004206be8:	74 35                	je     8004206c1f <page_check+0x112a>
  8004206bea:	48 b9 e8 ff 21 04 80 	movabs $0x800421ffe8,%rcx
  8004206bf1:	00 00 00 
  8004206bf4:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206bfb:	00 00 00 
  8004206bfe:	be f8 04 00 00       	mov    $0x4f8,%esi
  8004206c03:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206c0a:	00 00 00 
  8004206c0d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c12:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206c19:	00 00 00 
  8004206c1c:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206c1f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206c23:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206c27:	66 83 f8 01          	cmp    $0x1,%ax
  8004206c2b:	74 35                	je     8004206c62 <page_check+0x116d>
  8004206c2d:	48 b9 f9 ff 21 04 80 	movabs $0x800421fff9,%rcx
  8004206c34:	00 00 00 
  8004206c37:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206c3e:	00 00 00 
  8004206c41:	be f9 04 00 00       	mov    $0x4f9,%esi
  8004206c46:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206c4d:	00 00 00 
  8004206c50:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c55:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206c5c:	00 00 00 
  8004206c5f:	41 ff d0             	callq  *%r8


	// unmapping pp1 at 0 should keep pp1 at PGSIZE
	page_remove(boot_pml4e, 0x0);
  8004206c62:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004206c69:	00 00 00 
  8004206c6c:	48 8b 00             	mov    (%rax),%rax
  8004206c6f:	be 00 00 00 00       	mov    $0x0,%esi
  8004206c74:	48 89 c7             	mov    %rax,%rdi
  8004206c77:	48 b8 32 3e 20 04 80 	movabs $0x8004203e32,%rax
  8004206c7e:	00 00 00 
  8004206c81:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206c83:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004206c8a:	00 00 00 
  8004206c8d:	48 8b 00             	mov    (%rax),%rax
  8004206c90:	be 00 00 00 00       	mov    $0x0,%esi
  8004206c95:	48 89 c7             	mov    %rax,%rdi
  8004206c98:	48 b8 7b 58 20 04 80 	movabs $0x800420587b,%rax
  8004206c9f:	00 00 00 
  8004206ca2:	ff d0                	callq  *%rax
  8004206ca4:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206ca8:	74 35                	je     8004206cdf <page_check+0x11ea>
  8004206caa:	48 b9 10 00 22 04 80 	movabs $0x8004220010,%rcx
  8004206cb1:	00 00 00 
  8004206cb4:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206cbb:	00 00 00 
  8004206cbe:	be fe 04 00 00       	mov    $0x4fe,%esi
  8004206cc3:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206cca:	00 00 00 
  8004206ccd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206cd2:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206cd9:	00 00 00 
  8004206cdc:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206cdf:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004206ce6:	00 00 00 
  8004206ce9:	48 8b 00             	mov    (%rax),%rax
  8004206cec:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206cf1:	48 89 c7             	mov    %rax,%rdi
  8004206cf4:	48 b8 7b 58 20 04 80 	movabs $0x800420587b,%rax
  8004206cfb:	00 00 00 
  8004206cfe:	ff d0                	callq  *%rax
  8004206d00:	48 89 c3             	mov    %rax,%rbx
  8004206d03:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206d07:	48 89 c7             	mov    %rax,%rdi
  8004206d0a:	48 b8 3d 1b 20 04 80 	movabs $0x8004201b3d,%rax
  8004206d11:	00 00 00 
  8004206d14:	ff d0                	callq  *%rax
  8004206d16:	48 39 c3             	cmp    %rax,%rbx
  8004206d19:	74 35                	je     8004206d50 <page_check+0x125b>
  8004206d1b:	48 b9 b8 ff 21 04 80 	movabs $0x800421ffb8,%rcx
  8004206d22:	00 00 00 
  8004206d25:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206d2c:	00 00 00 
  8004206d2f:	be ff 04 00 00       	mov    $0x4ff,%esi
  8004206d34:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206d3b:	00 00 00 
  8004206d3e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d43:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206d4a:	00 00 00 
  8004206d4d:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004206d50:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206d54:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206d58:	66 83 f8 01          	cmp    $0x1,%ax
  8004206d5c:	74 35                	je     8004206d93 <page_check+0x129e>
  8004206d5e:	48 b9 5d fd 21 04 80 	movabs $0x800421fd5d,%rcx
  8004206d65:	00 00 00 
  8004206d68:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206d6f:	00 00 00 
  8004206d72:	be 00 05 00 00       	mov    $0x500,%esi
  8004206d77:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206d7e:	00 00 00 
  8004206d81:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d86:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206d8d:	00 00 00 
  8004206d90:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206d93:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206d97:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206d9b:	66 83 f8 01          	cmp    $0x1,%ax
  8004206d9f:	74 35                	je     8004206dd6 <page_check+0x12e1>
  8004206da1:	48 b9 f9 ff 21 04 80 	movabs $0x800421fff9,%rcx
  8004206da8:	00 00 00 
  8004206dab:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206db2:	00 00 00 
  8004206db5:	be 01 05 00 00       	mov    $0x501,%esi
  8004206dba:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206dc1:	00 00 00 
  8004206dc4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206dc9:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206dd0:	00 00 00 
  8004206dd3:	41 ff d0             	callq  *%r8

	// Test re-inserting pp1 at PGSIZE.
	// Thanks to Varun Agrawal for suggesting this test case.
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004206dd6:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004206ddd:	00 00 00 
  8004206de0:	48 8b 00             	mov    (%rax),%rax
  8004206de3:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206de7:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206dec:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206df1:	48 89 c7             	mov    %rax,%rdi
  8004206df4:	48 b8 33 3a 20 04 80 	movabs $0x8004203a33,%rax
  8004206dfb:	00 00 00 
  8004206dfe:	ff d0                	callq  *%rax
  8004206e00:	85 c0                	test   %eax,%eax
  8004206e02:	74 35                	je     8004206e39 <page_check+0x1344>
  8004206e04:	48 b9 18 ff 21 04 80 	movabs $0x800421ff18,%rcx
  8004206e0b:	00 00 00 
  8004206e0e:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206e15:	00 00 00 
  8004206e18:	be 05 05 00 00       	mov    $0x505,%esi
  8004206e1d:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206e24:	00 00 00 
  8004206e27:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e2c:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206e33:	00 00 00 
  8004206e36:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref);
  8004206e39:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206e3d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206e41:	66 85 c0             	test   %ax,%ax
  8004206e44:	75 35                	jne    8004206e7b <page_check+0x1386>
  8004206e46:	48 b9 33 00 22 04 80 	movabs $0x8004220033,%rcx
  8004206e4d:	00 00 00 
  8004206e50:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206e57:	00 00 00 
  8004206e5a:	be 06 05 00 00       	mov    $0x506,%esi
  8004206e5f:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206e66:	00 00 00 
  8004206e69:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e6e:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206e75:	00 00 00 
  8004206e78:	41 ff d0             	callq  *%r8
	assert(pp1->pp_link == NULL);
  8004206e7b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206e7f:	48 8b 00             	mov    (%rax),%rax
  8004206e82:	48 85 c0             	test   %rax,%rax
  8004206e85:	74 35                	je     8004206ebc <page_check+0x13c7>
  8004206e87:	48 b9 3f 00 22 04 80 	movabs $0x800422003f,%rcx
  8004206e8e:	00 00 00 
  8004206e91:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206e98:	00 00 00 
  8004206e9b:	be 07 05 00 00       	mov    $0x507,%esi
  8004206ea0:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206ea7:	00 00 00 
  8004206eaa:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206eaf:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206eb6:	00 00 00 
  8004206eb9:	41 ff d0             	callq  *%r8

	// unmapping pp1 at PGSIZE should free it
	page_remove(boot_pml4e, (void*) PGSIZE);
  8004206ebc:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004206ec3:	00 00 00 
  8004206ec6:	48 8b 00             	mov    (%rax),%rax
  8004206ec9:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206ece:	48 89 c7             	mov    %rax,%rdi
  8004206ed1:	48 b8 32 3e 20 04 80 	movabs $0x8004203e32,%rax
  8004206ed8:	00 00 00 
  8004206edb:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206edd:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004206ee4:	00 00 00 
  8004206ee7:	48 8b 00             	mov    (%rax),%rax
  8004206eea:	be 00 00 00 00       	mov    $0x0,%esi
  8004206eef:	48 89 c7             	mov    %rax,%rdi
  8004206ef2:	48 b8 7b 58 20 04 80 	movabs $0x800420587b,%rax
  8004206ef9:	00 00 00 
  8004206efc:	ff d0                	callq  *%rax
  8004206efe:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206f02:	74 35                	je     8004206f39 <page_check+0x1444>
  8004206f04:	48 b9 10 00 22 04 80 	movabs $0x8004220010,%rcx
  8004206f0b:	00 00 00 
  8004206f0e:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206f15:	00 00 00 
  8004206f18:	be 0b 05 00 00       	mov    $0x50b,%esi
  8004206f1d:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206f24:	00 00 00 
  8004206f27:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f2c:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206f33:	00 00 00 
  8004206f36:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == ~0);
  8004206f39:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004206f40:	00 00 00 
  8004206f43:	48 8b 00             	mov    (%rax),%rax
  8004206f46:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206f4b:	48 89 c7             	mov    %rax,%rdi
  8004206f4e:	48 b8 7b 58 20 04 80 	movabs $0x800420587b,%rax
  8004206f55:	00 00 00 
  8004206f58:	ff d0                	callq  *%rax
  8004206f5a:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206f5e:	74 35                	je     8004206f95 <page_check+0x14a0>
  8004206f60:	48 b9 58 00 22 04 80 	movabs $0x8004220058,%rcx
  8004206f67:	00 00 00 
  8004206f6a:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206f71:	00 00 00 
  8004206f74:	be 0c 05 00 00       	mov    $0x50c,%esi
  8004206f79:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206f80:	00 00 00 
  8004206f83:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f88:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206f8f:	00 00 00 
  8004206f92:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  8004206f95:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206f99:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206f9d:	66 85 c0             	test   %ax,%ax
  8004206fa0:	74 35                	je     8004206fd7 <page_check+0x14e2>
  8004206fa2:	48 b9 7e 00 22 04 80 	movabs $0x800422007e,%rcx
  8004206fa9:	00 00 00 
  8004206fac:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206fb3:	00 00 00 
  8004206fb6:	be 0d 05 00 00       	mov    $0x50d,%esi
  8004206fbb:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004206fc2:	00 00 00 
  8004206fc5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206fca:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004206fd1:	00 00 00 
  8004206fd4:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206fd7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206fdb:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206fdf:	66 83 f8 01          	cmp    $0x1,%ax
  8004206fe3:	74 35                	je     800420701a <page_check+0x1525>
  8004206fe5:	48 b9 f9 ff 21 04 80 	movabs $0x800421fff9,%rcx
  8004206fec:	00 00 00 
  8004206fef:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004206ff6:	00 00 00 
  8004206ff9:	be 0e 05 00 00       	mov    $0x50e,%esi
  8004206ffe:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004207005:	00 00 00 
  8004207008:	b8 00 00 00 00       	mov    $0x0,%eax
  800420700d:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004207014:	00 00 00 
  8004207017:	41 ff d0             	callq  *%r8
	page_remove(boot_pgdir, 0x0);
	assert(pp2->pp_ref == 0);
#endif

	// forcibly take pp3 back
	struct PageInfo *pp_l1 = pa2page(PTE_ADDR(boot_pml4e[0]));
  800420701a:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004207021:	00 00 00 
  8004207024:	48 8b 00             	mov    (%rax),%rax
  8004207027:	48 8b 00             	mov    (%rax),%rax
  800420702a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207030:	48 89 c7             	mov    %rax,%rdi
  8004207033:	48 b8 62 1b 20 04 80 	movabs $0x8004201b62,%rax
  800420703a:	00 00 00 
  800420703d:	ff d0                	callq  *%rax
  800420703f:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
	boot_pml4e[0] = 0;
  8004207046:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  800420704d:	00 00 00 
  8004207050:	48 8b 00             	mov    (%rax),%rax
  8004207053:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	assert(pp3->pp_ref == 1);
  800420705a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420705e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207062:	66 83 f8 01          	cmp    $0x1,%ax
  8004207066:	74 35                	je     800420709d <page_check+0x15a8>
  8004207068:	48 b9 f9 ff 21 04 80 	movabs $0x800421fff9,%rcx
  800420706f:	00 00 00 
  8004207072:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004207079:	00 00 00 
  800420707c:	be 24 05 00 00       	mov    $0x524,%esi
  8004207081:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004207088:	00 00 00 
  800420708b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207090:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004207097:	00 00 00 
  800420709a:	41 ff d0             	callq  *%r8
	page_decref(pp_l1);
  800420709d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042070a4:	48 89 c7             	mov    %rax,%rdi
  80042070a7:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  80042070ae:	00 00 00 
  80042070b1:	ff d0                	callq  *%rax
	// check pointer arithmetic in pml4e_walk
	if (pp_l1 != pp3) page_decref(pp3);
  80042070b3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042070ba:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042070be:	74 13                	je     80042070d3 <page_check+0x15de>
  80042070c0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042070c4:	48 89 c7             	mov    %rax,%rdi
  80042070c7:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  80042070ce:	00 00 00 
  80042070d1:	ff d0                	callq  *%rax
	if (pp_l1 != pp2) page_decref(pp2);
  80042070d3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042070da:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042070de:	74 13                	je     80042070f3 <page_check+0x15fe>
  80042070e0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042070e4:	48 89 c7             	mov    %rax,%rdi
  80042070e7:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  80042070ee:	00 00 00 
  80042070f1:	ff d0                	callq  *%rax
	if (pp_l1 != pp0) page_decref(pp0);
  80042070f3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042070fa:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042070fe:	74 13                	je     8004207113 <page_check+0x161e>
  8004207100:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207104:	48 89 c7             	mov    %rax,%rdi
  8004207107:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  800420710e:	00 00 00 
  8004207111:	ff d0                	callq  *%rax
	va = (void*)(PGSIZE * 100);
  8004207113:	48 c7 85 60 ff ff ff 	movq   $0x64000,-0xa0(%rbp)
  800420711a:	00 40 06 00 
	ptep = pml4e_walk(boot_pml4e, va, 1);
  800420711e:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004207125:	00 00 00 
  8004207128:	48 8b 00             	mov    (%rax),%rax
  800420712b:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004207132:	ba 01 00 00 00       	mov    $0x1,%edx
  8004207137:	48 89 ce             	mov    %rcx,%rsi
  800420713a:	48 89 c7             	mov    %rax,%rdi
  800420713d:	48 b8 29 30 20 04 80 	movabs $0x8004203029,%rax
  8004207144:	00 00 00 
  8004207147:	ff d0                	callq  *%rax
  8004207149:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(va)]));
  8004207150:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004207157:	00 00 00 
  800420715a:	48 8b 00             	mov    (%rax),%rax
  800420715d:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004207164:	48 c1 ea 27          	shr    $0x27,%rdx
  8004207168:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  800420716e:	48 c1 e2 03          	shl    $0x3,%rdx
  8004207172:	48 01 d0             	add    %rdx,%rax
  8004207175:	48 8b 00             	mov    (%rax),%rax
  8004207178:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420717e:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  8004207185:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420718c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207190:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
  8004207196:	8b 95 54 ff ff ff    	mov    -0xac(%rbp),%edx
  800420719c:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  80042071a3:	00 00 00 
  80042071a6:	48 8b 00             	mov    (%rax),%rax
  80042071a9:	48 39 c2             	cmp    %rax,%rdx
  80042071ac:	72 35                	jb     80042071e3 <page_check+0x16ee>
  80042071ae:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042071b5:	48 89 c1             	mov    %rax,%rcx
  80042071b8:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  80042071bf:	00 00 00 
  80042071c2:	be 2c 05 00 00       	mov    $0x52c,%esi
  80042071c7:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042071ce:	00 00 00 
  80042071d1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042071d6:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042071dd:	00 00 00 
  80042071e0:	41 ff d0             	callq  *%r8
  80042071e3:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042071ea:	00 00 00 
  80042071ed:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042071f4:	48 01 d0             	add    %rdx,%rax
  80042071f7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  80042071fb:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004207202:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004207206:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420720b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207212:	00 
  8004207213:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004207217:	48 01 d0             	add    %rdx,%rax
  800420721a:	48 8b 00             	mov    (%rax),%rax
  800420721d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207223:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
  800420722a:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004207231:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207235:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
  800420723b:	8b 95 44 ff ff ff    	mov    -0xbc(%rbp),%edx
  8004207241:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004207248:	00 00 00 
  800420724b:	48 8b 00             	mov    (%rax),%rax
  800420724e:	48 39 c2             	cmp    %rax,%rdx
  8004207251:	72 35                	jb     8004207288 <page_check+0x1793>
  8004207253:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420725a:	48 89 c1             	mov    %rax,%rcx
  800420725d:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  8004207264:	00 00 00 
  8004207267:	be 2d 05 00 00       	mov    $0x52d,%esi
  800420726c:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004207273:	00 00 00 
  8004207276:	b8 00 00 00 00       	mov    $0x0,%eax
  800420727b:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004207282:	00 00 00 
  8004207285:	41 ff d0             	callq  *%r8
  8004207288:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420728f:	00 00 00 
  8004207292:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004207299:	48 01 d0             	add    %rdx,%rax
  800420729c:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep1 = KADDR(PTE_ADDR(pde[PDX(va)]));
  80042072a0:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042072a7:	48 c1 e8 15          	shr    $0x15,%rax
  80042072ab:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042072b0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042072b7:	00 
  80042072b8:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042072bc:	48 01 d0             	add    %rdx,%rax
  80042072bf:	48 8b 00             	mov    (%rax),%rax
  80042072c2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042072c8:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  80042072cf:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  80042072d6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042072da:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%rbp)
  80042072e0:	8b 95 34 ff ff ff    	mov    -0xcc(%rbp),%edx
  80042072e6:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  80042072ed:	00 00 00 
  80042072f0:	48 8b 00             	mov    (%rax),%rax
  80042072f3:	48 39 c2             	cmp    %rax,%rdx
  80042072f6:	72 35                	jb     800420732d <page_check+0x1838>
  80042072f8:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  80042072ff:	48 89 c1             	mov    %rax,%rcx
  8004207302:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  8004207309:	00 00 00 
  800420730c:	be 2e 05 00 00       	mov    $0x52e,%esi
  8004207311:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004207318:	00 00 00 
  800420731b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207320:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004207327:	00 00 00 
  800420732a:	41 ff d0             	callq  *%r8
  800420732d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207334:	00 00 00 
  8004207337:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  800420733e:	48 01 d0             	add    %rdx,%rax
  8004207341:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	assert(ptep == ptep1 + PTX(va));
  8004207348:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420734f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207353:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004207358:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420735f:	00 
  8004207360:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004207367:	48 01 c2             	add    %rax,%rdx
  800420736a:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  8004207371:	48 39 c2             	cmp    %rax,%rdx
  8004207374:	74 35                	je     80042073ab <page_check+0x18b6>
  8004207376:	48 b9 8f 00 22 04 80 	movabs $0x800422008f,%rcx
  800420737d:	00 00 00 
  8004207380:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004207387:	00 00 00 
  800420738a:	be 2f 05 00 00       	mov    $0x52f,%esi
  800420738f:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004207396:	00 00 00 
  8004207399:	b8 00 00 00 00       	mov    $0x0,%eax
  800420739e:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042073a5:	00 00 00 
  80042073a8:	41 ff d0             	callq  *%r8

	// check that new page tables get cleared
	memset(page2kva(pp4), 0xFF, PGSIZE);
  80042073ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042073af:	48 89 c7             	mov    %rax,%rdi
  80042073b2:	48 b8 d3 1b 20 04 80 	movabs $0x8004201bd3,%rax
  80042073b9:	00 00 00 
  80042073bc:	ff d0                	callq  *%rax
  80042073be:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042073c3:	be ff 00 00 00       	mov    $0xff,%esi
  80042073c8:	48 89 c7             	mov    %rax,%rdi
  80042073cb:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  80042073d2:	00 00 00 
  80042073d5:	ff d0                	callq  *%rax
	pml4e_walk(boot_pml4e, 0x0, 1);
  80042073d7:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  80042073de:	00 00 00 
  80042073e1:	48 8b 00             	mov    (%rax),%rax
  80042073e4:	ba 01 00 00 00       	mov    $0x1,%edx
  80042073e9:	be 00 00 00 00       	mov    $0x0,%esi
  80042073ee:	48 89 c7             	mov    %rax,%rdi
  80042073f1:	48 b8 29 30 20 04 80 	movabs $0x8004203029,%rax
  80042073f8:	00 00 00 
  80042073fb:	ff d0                	callq  *%rax
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
  80042073fd:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004207404:	00 00 00 
  8004207407:	48 8b 00             	mov    (%rax),%rax
  800420740a:	48 8b 00             	mov    (%rax),%rax
  800420740d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207413:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  800420741a:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  8004207421:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207425:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
  800420742b:	8b 95 1c ff ff ff    	mov    -0xe4(%rbp),%edx
  8004207431:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004207438:	00 00 00 
  800420743b:	48 8b 00             	mov    (%rax),%rax
  800420743e:	48 39 c2             	cmp    %rax,%rdx
  8004207441:	72 35                	jb     8004207478 <page_check+0x1983>
  8004207443:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  800420744a:	48 89 c1             	mov    %rax,%rcx
  800420744d:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  8004207454:	00 00 00 
  8004207457:	be 34 05 00 00       	mov    $0x534,%esi
  800420745c:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004207463:	00 00 00 
  8004207466:	b8 00 00 00 00       	mov    $0x0,%eax
  800420746b:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004207472:	00 00 00 
  8004207475:	41 ff d0             	callq  *%r8
  8004207478:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420747f:	00 00 00 
  8004207482:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  8004207489:	48 01 d0             	add    %rdx,%rax
  800420748c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[0]));
  8004207490:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004207494:	48 8b 00             	mov    (%rax),%rax
  8004207497:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420749d:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  80042074a4:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042074ab:	48 c1 e8 0c          	shr    $0xc,%rax
  80042074af:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
  80042074b5:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  80042074bb:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  80042074c2:	00 00 00 
  80042074c5:	48 8b 00             	mov    (%rax),%rax
  80042074c8:	48 39 c2             	cmp    %rax,%rdx
  80042074cb:	72 35                	jb     8004207502 <page_check+0x1a0d>
  80042074cd:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042074d4:	48 89 c1             	mov    %rax,%rcx
  80042074d7:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  80042074de:	00 00 00 
  80042074e1:	be 35 05 00 00       	mov    $0x535,%esi
  80042074e6:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042074ed:	00 00 00 
  80042074f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042074f5:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042074fc:	00 00 00 
  80042074ff:	41 ff d0             	callq  *%r8
  8004207502:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207509:	00 00 00 
  800420750c:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004207513:	48 01 d0             	add    %rdx,%rax
  8004207516:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep  = KADDR(PTE_ADDR(pde[0]));
  800420751a:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800420751e:	48 8b 00             	mov    (%rax),%rax
  8004207521:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207527:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  800420752e:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  8004207535:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207539:	89 85 fc fe ff ff    	mov    %eax,-0x104(%rbp)
  800420753f:	8b 95 fc fe ff ff    	mov    -0x104(%rbp),%edx
  8004207545:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  800420754c:	00 00 00 
  800420754f:	48 8b 00             	mov    (%rax),%rax
  8004207552:	48 39 c2             	cmp    %rax,%rdx
  8004207555:	72 35                	jb     800420758c <page_check+0x1a97>
  8004207557:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  800420755e:	48 89 c1             	mov    %rax,%rcx
  8004207561:	48 ba f0 f3 21 04 80 	movabs $0x800421f3f0,%rdx
  8004207568:	00 00 00 
  800420756b:	be 36 05 00 00       	mov    $0x536,%esi
  8004207570:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004207577:	00 00 00 
  800420757a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420757f:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004207586:	00 00 00 
  8004207589:	41 ff d0             	callq  *%r8
  800420758c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207593:	00 00 00 
  8004207596:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  800420759d:	48 01 d0             	add    %rdx,%rax
  80042075a0:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	for(i=0; i<NPTENTRIES; i++)
  80042075a7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042075ae:	eb 58                	jmp    8004207608 <page_check+0x1b13>
		assert((ptep[i] & PTE_P) == 0);
  80042075b0:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  80042075b7:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042075ba:	48 63 d2             	movslq %edx,%rdx
  80042075bd:	48 c1 e2 03          	shl    $0x3,%rdx
  80042075c1:	48 01 d0             	add    %rdx,%rax
  80042075c4:	48 8b 00             	mov    (%rax),%rax
  80042075c7:	83 e0 01             	and    $0x1,%eax
  80042075ca:	48 85 c0             	test   %rax,%rax
  80042075cd:	74 35                	je     8004207604 <page_check+0x1b0f>
  80042075cf:	48 b9 a7 00 22 04 80 	movabs $0x80042200a7,%rcx
  80042075d6:	00 00 00 
  80042075d9:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042075e0:	00 00 00 
  80042075e3:	be 38 05 00 00       	mov    $0x538,%esi
  80042075e8:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042075ef:	00 00 00 
  80042075f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042075f7:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042075fe:	00 00 00 
  8004207601:	41 ff d0             	callq  *%r8
	memset(page2kva(pp4), 0xFF, PGSIZE);
	pml4e_walk(boot_pml4e, 0x0, 1);
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
	pde  = KADDR(PTE_ADDR(pdpe[0]));
	ptep  = KADDR(PTE_ADDR(pde[0]));
	for(i=0; i<NPTENTRIES; i++)
  8004207604:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004207608:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
  800420760f:	7e 9f                	jle    80042075b0 <page_check+0x1abb>
		assert((ptep[i] & PTE_P) == 0);
	boot_pml4e[0] = 0;
  8004207611:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004207618:	00 00 00 
  800420761b:	48 8b 00             	mov    (%rax),%rax
  800420761e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// give free list back
	page_free_list = fl;
  8004207625:	48 b8 38 02 4e 04 80 	movabs $0x80044e0238,%rax
  800420762c:	00 00 00 
  800420762f:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004207633:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_decref(pp0);
  8004207636:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420763a:	48 89 c7             	mov    %rax,%rdi
  800420763d:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  8004207644:	00 00 00 
  8004207647:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004207649:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420764d:	48 89 c7             	mov    %rax,%rdi
  8004207650:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  8004207657:	00 00 00 
  800420765a:	ff d0                	callq  *%rax
	page_decref(pp3);
  800420765c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207660:	48 89 c7             	mov    %rax,%rdi
  8004207663:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  800420766a:	00 00 00 
  800420766d:	ff d0                	callq  *%rax

	// Triple check that we got the ref counts right
	assert(pp0->pp_ref == 0);
  800420766f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207673:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207677:	66 85 c0             	test   %ax,%ax
  800420767a:	74 35                	je     80042076b1 <page_check+0x1bbc>
  800420767c:	48 b9 be 00 22 04 80 	movabs $0x80042200be,%rcx
  8004207683:	00 00 00 
  8004207686:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  800420768d:	00 00 00 
  8004207690:	be 44 05 00 00       	mov    $0x544,%esi
  8004207695:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420769c:	00 00 00 
  800420769f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042076a4:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042076ab:	00 00 00 
  80042076ae:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  80042076b1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042076b5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042076b9:	66 85 c0             	test   %ax,%ax
  80042076bc:	74 35                	je     80042076f3 <page_check+0x1bfe>
  80042076be:	48 b9 7e 00 22 04 80 	movabs $0x800422007e,%rcx
  80042076c5:	00 00 00 
  80042076c8:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042076cf:	00 00 00 
  80042076d2:	be 45 05 00 00       	mov    $0x545,%esi
  80042076d7:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042076de:	00 00 00 
  80042076e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042076e6:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042076ed:	00 00 00 
  80042076f0:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 0);
  80042076f3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042076f7:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042076fb:	66 85 c0             	test   %ax,%ax
  80042076fe:	74 35                	je     8004207735 <page_check+0x1c40>
  8004207700:	48 b9 cf 00 22 04 80 	movabs $0x80042200cf,%rcx
  8004207707:	00 00 00 
  800420770a:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004207711:	00 00 00 
  8004207714:	be 46 05 00 00       	mov    $0x546,%esi
  8004207719:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004207720:	00 00 00 
  8004207723:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207728:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420772f:	00 00 00 
  8004207732:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 0);
  8004207735:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207739:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420773d:	66 85 c0             	test   %ax,%ax
  8004207740:	74 35                	je     8004207777 <page_check+0x1c82>
  8004207742:	48 b9 e0 00 22 04 80 	movabs $0x80042200e0,%rcx
  8004207749:	00 00 00 
  800420774c:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004207753:	00 00 00 
  8004207756:	be 47 05 00 00       	mov    $0x547,%esi
  800420775b:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004207762:	00 00 00 
  8004207765:	b8 00 00 00 00       	mov    $0x0,%eax
  800420776a:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004207771:	00 00 00 
  8004207774:	41 ff d0             	callq  *%r8
	assert(pp4->pp_ref == 0);
  8004207777:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420777b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420777f:	66 85 c0             	test   %ax,%ax
  8004207782:	74 35                	je     80042077b9 <page_check+0x1cc4>
  8004207784:	48 b9 f1 00 22 04 80 	movabs $0x80042200f1,%rcx
  800420778b:	00 00 00 
  800420778e:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004207795:	00 00 00 
  8004207798:	be 48 05 00 00       	mov    $0x548,%esi
  800420779d:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042077a4:	00 00 00 
  80042077a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042077ac:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042077b3:	00 00 00 
  80042077b6:	41 ff d0             	callq  *%r8
	assert(pp5->pp_ref == 0);
  80042077b9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042077bd:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042077c1:	66 85 c0             	test   %ax,%ax
  80042077c4:	74 35                	je     80042077fb <page_check+0x1d06>
  80042077c6:	48 b9 02 01 22 04 80 	movabs $0x8004220102,%rcx
  80042077cd:	00 00 00 
  80042077d0:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042077d7:	00 00 00 
  80042077da:	be 49 05 00 00       	mov    $0x549,%esi
  80042077df:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042077e6:	00 00 00 
  80042077e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042077ee:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042077f5:	00 00 00 
  80042077f8:	41 ff d0             	callq  *%r8


	// test mmio_map_region
	mm1 = (uintptr_t) mmio_map_region(0, 4097);
  80042077fb:	be 01 10 00 00       	mov    $0x1001,%esi
  8004207800:	bf 00 00 00 00       	mov    $0x0,%edi
  8004207805:	48 b8 76 3f 20 04 80 	movabs $0x8004203f76,%rax
  800420780c:	00 00 00 
  800420780f:	ff d0                	callq  *%rax
  8004207811:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	mm2 = (uintptr_t) mmio_map_region(0, 4096);
  8004207818:	be 00 10 00 00       	mov    $0x1000,%esi
  800420781d:	bf 00 00 00 00       	mov    $0x0,%edi
  8004207822:	48 b8 76 3f 20 04 80 	movabs $0x8004203f76,%rax
  8004207829:	00 00 00 
  800420782c:	ff d0                	callq  *%rax
  800420782e:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	// check that they're in the right region
	assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
  8004207835:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420783c:	00 00 00 
  800420783f:	48 39 85 f0 fe ff ff 	cmp    %rax,-0x110(%rbp)
  8004207846:	76 1d                	jbe    8004207865 <page_check+0x1d70>
  8004207848:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  800420784f:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004207856:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  800420785d:	00 00 00 
  8004207860:	48 39 c2             	cmp    %rax,%rdx
  8004207863:	76 35                	jbe    800420789a <page_check+0x1da5>
  8004207865:	48 b9 18 01 22 04 80 	movabs $0x8004220118,%rcx
  800420786c:	00 00 00 
  800420786f:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004207876:	00 00 00 
  8004207879:	be 50 05 00 00       	mov    $0x550,%esi
  800420787e:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004207885:	00 00 00 
  8004207888:	b8 00 00 00 00       	mov    $0x0,%eax
  800420788d:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004207894:	00 00 00 
  8004207897:	41 ff d0             	callq  *%r8
	assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
  800420789a:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  80042078a1:	00 00 00 
  80042078a4:	48 39 85 e8 fe ff ff 	cmp    %rax,-0x118(%rbp)
  80042078ab:	76 1d                	jbe    80042078ca <page_check+0x1dd5>
  80042078ad:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  80042078b4:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  80042078bb:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  80042078c2:	00 00 00 
  80042078c5:	48 39 c2             	cmp    %rax,%rdx
  80042078c8:	76 35                	jbe    80042078ff <page_check+0x1e0a>
  80042078ca:	48 b9 40 01 22 04 80 	movabs $0x8004220140,%rcx
  80042078d1:	00 00 00 
  80042078d4:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042078db:	00 00 00 
  80042078de:	be 51 05 00 00       	mov    $0x551,%esi
  80042078e3:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042078ea:	00 00 00 
  80042078ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042078f2:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042078f9:	00 00 00 
  80042078fc:	41 ff d0             	callq  *%r8
	// check that they're page-aligned
	assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
  80042078ff:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207906:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420790b:	48 85 c0             	test   %rax,%rax
  800420790e:	75 11                	jne    8004207921 <page_check+0x1e2c>
  8004207910:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004207917:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420791c:	48 85 c0             	test   %rax,%rax
  800420791f:	74 35                	je     8004207956 <page_check+0x1e61>
  8004207921:	48 b9 68 01 22 04 80 	movabs $0x8004220168,%rcx
  8004207928:	00 00 00 
  800420792b:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004207932:	00 00 00 
  8004207935:	be 53 05 00 00       	mov    $0x553,%esi
  800420793a:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004207941:	00 00 00 
  8004207944:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207949:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004207950:	00 00 00 
  8004207953:	41 ff d0             	callq  *%r8
	// check that they don't overlap
	assert(mm1 + 8096 <= mm2);
  8004207956:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  800420795d:	48 05 a0 1f 00 00    	add    $0x1fa0,%rax
  8004207963:	48 3b 85 e8 fe ff ff 	cmp    -0x118(%rbp),%rax
  800420796a:	76 35                	jbe    80042079a1 <page_check+0x1eac>
  800420796c:	48 b9 8f 01 22 04 80 	movabs $0x800422018f,%rcx
  8004207973:	00 00 00 
  8004207976:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  800420797d:	00 00 00 
  8004207980:	be 55 05 00 00       	mov    $0x555,%esi
  8004207985:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  800420798c:	00 00 00 
  800420798f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207994:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420799b:	00 00 00 
  800420799e:	41 ff d0             	callq  *%r8
	// check page mappings

	assert(check_va2pa(boot_pml4e, mm1) == 0);
  80042079a1:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  80042079a8:	00 00 00 
  80042079ab:	48 8b 00             	mov    (%rax),%rax
  80042079ae:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  80042079b5:	48 89 d6             	mov    %rdx,%rsi
  80042079b8:	48 89 c7             	mov    %rax,%rdi
  80042079bb:	48 b8 7b 58 20 04 80 	movabs $0x800420587b,%rax
  80042079c2:	00 00 00 
  80042079c5:	ff d0                	callq  *%rax
  80042079c7:	48 85 c0             	test   %rax,%rax
  80042079ca:	74 35                	je     8004207a01 <page_check+0x1f0c>
  80042079cc:	48 b9 a8 01 22 04 80 	movabs $0x80042201a8,%rcx
  80042079d3:	00 00 00 
  80042079d6:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  80042079dd:	00 00 00 
  80042079e0:	be 58 05 00 00       	mov    $0x558,%esi
  80042079e5:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  80042079ec:	00 00 00 
  80042079ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80042079f4:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042079fb:	00 00 00 
  80042079fe:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm1+PGSIZE) == PGSIZE);
  8004207a01:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207a08:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207a0f:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004207a16:	00 00 00 
  8004207a19:	48 8b 00             	mov    (%rax),%rax
  8004207a1c:	48 89 d6             	mov    %rdx,%rsi
  8004207a1f:	48 89 c7             	mov    %rax,%rdi
  8004207a22:	48 b8 7b 58 20 04 80 	movabs $0x800420587b,%rax
  8004207a29:	00 00 00 
  8004207a2c:	ff d0                	callq  *%rax
  8004207a2e:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  8004207a34:	74 35                	je     8004207a6b <page_check+0x1f76>
  8004207a36:	48 b9 d0 01 22 04 80 	movabs $0x80042201d0,%rcx
  8004207a3d:	00 00 00 
  8004207a40:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004207a47:	00 00 00 
  8004207a4a:	be 59 05 00 00       	mov    $0x559,%esi
  8004207a4f:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004207a56:	00 00 00 
  8004207a59:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207a5e:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004207a65:	00 00 00 
  8004207a68:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2) == 0);
  8004207a6b:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004207a72:	00 00 00 
  8004207a75:	48 8b 00             	mov    (%rax),%rax
  8004207a78:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
  8004207a7f:	48 89 d6             	mov    %rdx,%rsi
  8004207a82:	48 89 c7             	mov    %rax,%rdi
  8004207a85:	48 b8 7b 58 20 04 80 	movabs $0x800420587b,%rax
  8004207a8c:	00 00 00 
  8004207a8f:	ff d0                	callq  *%rax
  8004207a91:	48 85 c0             	test   %rax,%rax
  8004207a94:	74 35                	je     8004207acb <page_check+0x1fd6>
  8004207a96:	48 b9 00 02 22 04 80 	movabs $0x8004220200,%rcx
  8004207a9d:	00 00 00 
  8004207aa0:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004207aa7:	00 00 00 
  8004207aaa:	be 5a 05 00 00       	mov    $0x55a,%esi
  8004207aaf:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004207ab6:	00 00 00 
  8004207ab9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207abe:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004207ac5:	00 00 00 
  8004207ac8:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2+PGSIZE) == ~0);
  8004207acb:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004207ad2:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207ad9:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004207ae0:	00 00 00 
  8004207ae3:	48 8b 00             	mov    (%rax),%rax
  8004207ae6:	48 89 d6             	mov    %rdx,%rsi
  8004207ae9:	48 89 c7             	mov    %rax,%rdi
  8004207aec:	48 b8 7b 58 20 04 80 	movabs $0x800420587b,%rax
  8004207af3:	00 00 00 
  8004207af6:	ff d0                	callq  *%rax
  8004207af8:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004207afc:	74 35                	je     8004207b33 <page_check+0x203e>
  8004207afe:	48 b9 28 02 22 04 80 	movabs $0x8004220228,%rcx
  8004207b05:	00 00 00 
  8004207b08:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004207b0f:	00 00 00 
  8004207b12:	be 5b 05 00 00       	mov    $0x55b,%esi
  8004207b17:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004207b1e:	00 00 00 
  8004207b21:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207b26:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004207b2d:	00 00 00 
  8004207b30:	41 ff d0             	callq  *%r8
	// check permissions
	assert(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
  8004207b33:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207b3a:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004207b41:	00 00 00 
  8004207b44:	48 8b 00             	mov    (%rax),%rax
  8004207b47:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207b4c:	48 89 ce             	mov    %rcx,%rsi
  8004207b4f:	48 89 c7             	mov    %rax,%rdi
  8004207b52:	48 b8 29 30 20 04 80 	movabs $0x8004203029,%rax
  8004207b59:	00 00 00 
  8004207b5c:	ff d0                	callq  *%rax
  8004207b5e:	48 8b 00             	mov    (%rax),%rax
  8004207b61:	83 e0 1a             	and    $0x1a,%eax
  8004207b64:	48 85 c0             	test   %rax,%rax
  8004207b67:	75 35                	jne    8004207b9e <page_check+0x20a9>
  8004207b69:	48 b9 58 02 22 04 80 	movabs $0x8004220258,%rcx
  8004207b70:	00 00 00 
  8004207b73:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004207b7a:	00 00 00 
  8004207b7d:	be 5d 05 00 00       	mov    $0x55d,%esi
  8004207b82:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004207b89:	00 00 00 
  8004207b8c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207b91:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004207b98:	00 00 00 
  8004207b9b:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & PTE_U));
  8004207b9e:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207ba5:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004207bac:	00 00 00 
  8004207baf:	48 8b 00             	mov    (%rax),%rax
  8004207bb2:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207bb7:	48 89 ce             	mov    %rcx,%rsi
  8004207bba:	48 89 c7             	mov    %rax,%rdi
  8004207bbd:	48 b8 29 30 20 04 80 	movabs $0x8004203029,%rax
  8004207bc4:	00 00 00 
  8004207bc7:	ff d0                	callq  *%rax
  8004207bc9:	48 8b 00             	mov    (%rax),%rax
  8004207bcc:	83 e0 04             	and    $0x4,%eax
  8004207bcf:	48 85 c0             	test   %rax,%rax
  8004207bd2:	74 35                	je     8004207c09 <page_check+0x2114>
  8004207bd4:	48 b9 a0 02 22 04 80 	movabs $0x80042202a0,%rcx
  8004207bdb:	00 00 00 
  8004207bde:	48 ba 69 f4 21 04 80 	movabs $0x800421f469,%rdx
  8004207be5:	00 00 00 
  8004207be8:	be 5e 05 00 00       	mov    $0x55e,%esi
  8004207bed:	48 bf 7e f4 21 04 80 	movabs $0x800421f47e,%rdi
  8004207bf4:	00 00 00 
  8004207bf7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207bfc:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004207c03:	00 00 00 
  8004207c06:	41 ff d0             	callq  *%r8
	// clear the mappings
	*pml4e_walk(boot_pml4e, (void*) mm1, 0) = 0;
  8004207c09:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207c10:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004207c17:	00 00 00 
  8004207c1a:	48 8b 00             	mov    (%rax),%rax
  8004207c1d:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207c22:	48 89 ce             	mov    %rcx,%rsi
  8004207c25:	48 89 c7             	mov    %rax,%rdi
  8004207c28:	48 b8 29 30 20 04 80 	movabs $0x8004203029,%rax
  8004207c2f:	00 00 00 
  8004207c32:	ff d0                	callq  *%rax
  8004207c34:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm1 + PGSIZE, 0) = 0;
  8004207c3b:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207c42:	48 05 00 10 00 00    	add    $0x1000,%rax
  8004207c48:	48 89 c1             	mov    %rax,%rcx
  8004207c4b:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004207c52:	00 00 00 
  8004207c55:	48 8b 00             	mov    (%rax),%rax
  8004207c58:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207c5d:	48 89 ce             	mov    %rcx,%rsi
  8004207c60:	48 89 c7             	mov    %rax,%rdi
  8004207c63:	48 b8 29 30 20 04 80 	movabs $0x8004203029,%rax
  8004207c6a:	00 00 00 
  8004207c6d:	ff d0                	callq  *%rax
  8004207c6f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm2, 0) = 0;
  8004207c76:	48 8b 8d e8 fe ff ff 	mov    -0x118(%rbp),%rcx
  8004207c7d:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004207c84:	00 00 00 
  8004207c87:	48 8b 00             	mov    (%rax),%rax
  8004207c8a:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207c8f:	48 89 ce             	mov    %rcx,%rsi
  8004207c92:	48 89 c7             	mov    %rax,%rdi
  8004207c95:	48 b8 29 30 20 04 80 	movabs $0x8004203029,%rax
  8004207c9c:	00 00 00 
  8004207c9f:	ff d0                	callq  *%rax
  8004207ca1:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)


	cprintf("check_page() succeeded!\n");
  8004207ca8:	48 bf d3 02 22 04 80 	movabs $0x80042202d3,%rdi
  8004207caf:	00 00 00 
  8004207cb2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207cb7:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004207cbe:	00 00 00 
  8004207cc1:	ff d2                	callq  *%rdx
}
  8004207cc3:	90                   	nop
  8004207cc4:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
  8004207ccb:	5b                   	pop    %rbx
  8004207ccc:	5d                   	pop    %rbp
  8004207ccd:	c3                   	retq   

0000008004207cce <page2ppn>:
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);


static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004207cce:	55                   	push   %rbp
  8004207ccf:	48 89 e5             	mov    %rsp,%rbp
  8004207cd2:	48 83 ec 08          	sub    $0x8,%rsp
  8004207cd6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004207cda:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207cde:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  8004207ce5:	00 00 00 
  8004207ce8:	48 8b 00             	mov    (%rax),%rax
  8004207ceb:	48 29 c2             	sub    %rax,%rdx
  8004207cee:	48 89 d0             	mov    %rdx,%rax
  8004207cf1:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004207cf5:	c9                   	leaveq 
  8004207cf6:	c3                   	retq   

0000008004207cf7 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004207cf7:	55                   	push   %rbp
  8004207cf8:	48 89 e5             	mov    %rsp,%rbp
  8004207cfb:	48 83 ec 08          	sub    $0x8,%rsp
  8004207cff:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004207d03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d07:	48 89 c7             	mov    %rax,%rdi
  8004207d0a:	48 b8 ce 7c 20 04 80 	movabs $0x8004207cce,%rax
  8004207d11:	00 00 00 
  8004207d14:	ff d0                	callq  *%rax
  8004207d16:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004207d1a:	c9                   	leaveq 
  8004207d1b:	c3                   	retq   

0000008004207d1c <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004207d1c:	55                   	push   %rbp
  8004207d1d:	48 89 e5             	mov    %rsp,%rbp
  8004207d20:	48 83 ec 10          	sub    $0x10,%rsp
  8004207d24:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004207d28:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d2c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207d30:	48 89 c2             	mov    %rax,%rdx
  8004207d33:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004207d3a:	00 00 00 
  8004207d3d:	48 8b 00             	mov    (%rax),%rax
  8004207d40:	48 39 c2             	cmp    %rax,%rdx
  8004207d43:	72 2a                	jb     8004207d6f <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004207d45:	48 ba f0 02 22 04 80 	movabs $0x80042202f0,%rdx
  8004207d4c:	00 00 00 
  8004207d4f:	be 5a 00 00 00       	mov    $0x5a,%esi
  8004207d54:	48 bf 0f 03 22 04 80 	movabs $0x800422030f,%rdi
  8004207d5b:	00 00 00 
  8004207d5e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207d63:	48 b9 d3 04 20 04 80 	movabs $0x80042004d3,%rcx
  8004207d6a:	00 00 00 
  8004207d6d:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004207d6f:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  8004207d76:	00 00 00 
  8004207d79:	48 8b 00             	mov    (%rax),%rax
  8004207d7c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207d80:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004207d84:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207d88:	48 01 d0             	add    %rdx,%rax
}
  8004207d8b:	c9                   	leaveq 
  8004207d8c:	c3                   	retq   

0000008004207d8d <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004207d8d:	55                   	push   %rbp
  8004207d8e:	48 89 e5             	mov    %rsp,%rbp
  8004207d91:	48 83 ec 20          	sub    $0x20,%rsp
  8004207d95:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004207d99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207d9d:	48 89 c7             	mov    %rax,%rdi
  8004207da0:	48 b8 f7 7c 20 04 80 	movabs $0x8004207cf7,%rax
  8004207da7:	00 00 00 
  8004207daa:	ff d0                	callq  *%rax
  8004207dac:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207db0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207db4:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207db8:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004207dbb:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004207dbe:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004207dc5:	00 00 00 
  8004207dc8:	48 8b 00             	mov    (%rax),%rax
  8004207dcb:	48 39 c2             	cmp    %rax,%rdx
  8004207dce:	72 32                	jb     8004207e02 <page2kva+0x75>
  8004207dd0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207dd4:	48 89 c1             	mov    %rax,%rcx
  8004207dd7:	48 ba 20 03 22 04 80 	movabs $0x8004220320,%rdx
  8004207dde:	00 00 00 
  8004207de1:	be 61 00 00 00       	mov    $0x61,%esi
  8004207de6:	48 bf 0f 03 22 04 80 	movabs $0x800422030f,%rdi
  8004207ded:	00 00 00 
  8004207df0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207df5:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004207dfc:	00 00 00 
  8004207dff:	41 ff d0             	callq  *%r8
  8004207e02:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207e09:	00 00 00 
  8004207e0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207e10:	48 01 d0             	add    %rdx,%rax
}
  8004207e13:	c9                   	leaveq 
  8004207e14:	c3                   	retq   

0000008004207e15 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  8004207e15:	55                   	push   %rbp
  8004207e16:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  8004207e19:	48 bf 60 67 23 04 80 	movabs $0x8004236760,%rdi
  8004207e20:	00 00 00 
  8004207e23:	48 b8 64 85 21 04 80 	movabs $0x8004218564,%rax
  8004207e2a:	00 00 00 
  8004207e2d:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  8004207e2f:	f3 90                	pause  
}
  8004207e31:	90                   	nop
  8004207e32:	5d                   	pop    %rbp
  8004207e33:	c3                   	retq   

0000008004207e34 <envid2env>:
//   On success, sets *env_store to the environment.
//   On error, sets *env_store to NULL.
//
int
envid2env(envid_t envid, struct Env **env_store, bool checkperm)
{
  8004207e34:	55                   	push   %rbp
  8004207e35:	48 89 e5             	mov    %rsp,%rbp
  8004207e38:	53                   	push   %rbx
  8004207e39:	48 83 ec 28          	sub    $0x28,%rsp
  8004207e3d:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8004207e40:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004207e44:	89 d0                	mov    %edx,%eax
  8004207e46:	88 45 d8             	mov    %al,-0x28(%rbp)
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
  8004207e49:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004207e4d:	75 41                	jne    8004207e90 <envid2env+0x5c>
		*env_store = curenv;
  8004207e4f:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  8004207e56:	00 00 00 
  8004207e59:	ff d0                	callq  *%rax
  8004207e5b:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  8004207e62:	00 00 00 
  8004207e65:	48 98                	cltq   
  8004207e67:	48 c1 e0 03          	shl    $0x3,%rax
  8004207e6b:	48 89 c1             	mov    %rax,%rcx
  8004207e6e:	48 c1 e1 04          	shl    $0x4,%rcx
  8004207e72:	48 01 c8             	add    %rcx,%rax
  8004207e75:	48 01 d0             	add    %rdx,%rax
  8004207e78:	48 83 c0 08          	add    $0x8,%rax
  8004207e7c:	48 8b 10             	mov    (%rax),%rdx
  8004207e7f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207e83:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  8004207e86:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207e8b:	e9 fd 00 00 00       	jmpq   8004207f8d <envid2env+0x159>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
  8004207e90:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  8004207e97:	00 00 00 
  8004207e9a:	48 8b 10             	mov    (%rax),%rdx
  8004207e9d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004207ea0:	48 98                	cltq   
  8004207ea2:	25 ff 03 00 00       	and    $0x3ff,%eax
  8004207ea7:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004207eae:	48 01 d0             	add    %rdx,%rax
  8004207eb1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
  8004207eb5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207eb9:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004207ebf:	85 c0                	test   %eax,%eax
  8004207ec1:	74 0f                	je     8004207ed2 <envid2env+0x9e>
  8004207ec3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207ec7:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207ecd:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  8004207ed0:	74 15                	je     8004207ee7 <envid2env+0xb3>
		*env_store = 0;
  8004207ed2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207ed6:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207edd:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207ee2:	e9 a6 00 00 00       	jmpq   8004207f8d <envid2env+0x159>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
  8004207ee7:	80 7d d8 00          	cmpb   $0x0,-0x28(%rbp)
  8004207eeb:	0f 84 8c 00 00 00    	je     8004207f7d <envid2env+0x149>
  8004207ef1:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  8004207ef8:	00 00 00 
  8004207efb:	ff d0                	callq  *%rax
  8004207efd:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  8004207f04:	00 00 00 
  8004207f07:	48 98                	cltq   
  8004207f09:	48 c1 e0 03          	shl    $0x3,%rax
  8004207f0d:	48 89 c1             	mov    %rax,%rcx
  8004207f10:	48 c1 e1 04          	shl    $0x4,%rcx
  8004207f14:	48 01 c8             	add    %rcx,%rax
  8004207f17:	48 01 d0             	add    %rdx,%rax
  8004207f1a:	48 83 c0 08          	add    $0x8,%rax
  8004207f1e:	48 8b 00             	mov    (%rax),%rax
  8004207f21:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004207f25:	74 56                	je     8004207f7d <envid2env+0x149>
  8004207f27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207f2b:	8b 98 cc 00 00 00    	mov    0xcc(%rax),%ebx
  8004207f31:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  8004207f38:	00 00 00 
  8004207f3b:	ff d0                	callq  *%rax
  8004207f3d:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  8004207f44:	00 00 00 
  8004207f47:	48 98                	cltq   
  8004207f49:	48 c1 e0 03          	shl    $0x3,%rax
  8004207f4d:	48 89 c1             	mov    %rax,%rcx
  8004207f50:	48 c1 e1 04          	shl    $0x4,%rcx
  8004207f54:	48 01 c8             	add    %rcx,%rax
  8004207f57:	48 01 d0             	add    %rdx,%rax
  8004207f5a:	48 83 c0 08          	add    $0x8,%rax
  8004207f5e:	48 8b 00             	mov    (%rax),%rax
  8004207f61:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207f67:	39 c3                	cmp    %eax,%ebx
  8004207f69:	74 12                	je     8004207f7d <envid2env+0x149>
		*env_store = 0;
  8004207f6b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207f6f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207f76:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207f7b:	eb 10                	jmp    8004207f8d <envid2env+0x159>
	}

	*env_store = e;
  8004207f7d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207f81:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207f85:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  8004207f88:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207f8d:	48 83 c4 28          	add    $0x28,%rsp
  8004207f91:	5b                   	pop    %rbx
  8004207f92:	5d                   	pop    %rbp
  8004207f93:	c3                   	retq   

0000008004207f94 <env_init>:
// they are in the envs array (i.e., so that the first call to
// env_alloc() returns envs[0]).
//
void
env_init(void)
{
  8004207f94:	55                   	push   %rbp
  8004207f95:	48 89 e5             	mov    %rsp,%rbp
  8004207f98:	48 83 ec 10          	sub    $0x10,%rsp
	// Set up envs array
	// LAB 3: Your code here.

	int i;
	for (i = 0; i < NENV; i++) {
  8004207f9c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004207fa3:	eb 6d                	jmp    8004208012 <env_init+0x7e>
		envs[i].env_status = ENV_FREE;
  8004207fa5:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  8004207fac:	00 00 00 
  8004207faf:	48 8b 10             	mov    (%rax),%rdx
  8004207fb2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004207fb5:	48 98                	cltq   
  8004207fb7:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004207fbe:	48 01 d0             	add    %rdx,%rax
  8004207fc1:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8004207fc8:	00 00 00 
		envs[i].env_link = &envs[i+1];
  8004207fcb:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  8004207fd2:	00 00 00 
  8004207fd5:	48 8b 10             	mov    (%rax),%rdx
  8004207fd8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004207fdb:	48 98                	cltq   
  8004207fdd:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004207fe4:	48 01 c2             	add    %rax,%rdx
  8004207fe7:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  8004207fee:	00 00 00 
  8004207ff1:	48 8b 08             	mov    (%rax),%rcx
  8004207ff4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004207ff7:	48 98                	cltq   
  8004207ff9:	48 83 c0 01          	add    $0x1,%rax
  8004207ffd:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004208004:	48 01 c8             	add    %rcx,%rax
  8004208007:	48 89 82 c0 00 00 00 	mov    %rax,0xc0(%rdx)
{
	// Set up envs array
	// LAB 3: Your code here.

	int i;
	for (i = 0; i < NENV; i++) {
  800420800e:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004208012:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  8004208019:	7e 8a                	jle    8004207fa5 <env_init+0x11>
		envs[i].env_status = ENV_FREE;
		envs[i].env_link = &envs[i+1];
	}
	envs[NENV-1].env_link = NULL;
  800420801b:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  8004208022:	00 00 00 
  8004208025:	48 8b 00             	mov    (%rax),%rax
  8004208028:	48 05 98 9e 05 00    	add    $0x59e98,%rax
  800420802e:	48 c7 80 c0 00 00 00 	movq   $0x0,0xc0(%rax)
  8004208035:	00 00 00 00 
	env_free_list = &envs[0];
  8004208039:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  8004208040:	00 00 00 
  8004208043:	48 8b 10             	mov    (%rax),%rdx
  8004208046:	48 b8 60 02 4e 04 80 	movabs $0x80044e0260,%rax
  800420804d:	00 00 00 
  8004208050:	48 89 10             	mov    %rdx,(%rax)


	// Per-CPU part of the initialization
	env_init_percpu();
  8004208053:	48 b8 62 80 20 04 80 	movabs $0x8004208062,%rax
  800420805a:	00 00 00 
  800420805d:	ff d0                	callq  *%rax
}
  800420805f:	90                   	nop
  8004208060:	c9                   	leaveq 
  8004208061:	c3                   	retq   

0000008004208062 <env_init_percpu>:

// Load GDT and segment descriptors.
void
env_init_percpu(void)
{
  8004208062:	55                   	push   %rbp
  8004208063:	48 89 e5             	mov    %rsp,%rbp
  8004208066:	53                   	push   %rbx
  8004208067:	48 83 ec 10          	sub    $0x10,%rsp
  800420806b:	48 b8 68 66 23 04 80 	movabs $0x8004236668,%rax
  8004208072:	00 00 00 
  8004208075:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}

static __inline void
lgdt(void *p)
{
	__asm __volatile("lgdt (%0)" : : "r" (p));
  8004208079:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420807d:	0f 01 10             	lgdt   (%rax)
	lgdt(&gdt_pd);

	// The kernel never uses GS or FS, so we leave those set to
	// the user data segment.
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
  8004208080:	b8 23 00 00 00       	mov    $0x23,%eax
  8004208085:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
  8004208087:	b8 23 00 00 00       	mov    $0x23,%eax
  800420808c:	8e e0                	mov    %eax,%fs
	// The kernel does use ES, DS, and SS.  We'll change between
	// the kernel and user data segments as needed.
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
  800420808e:	b8 10 00 00 00       	mov    $0x10,%eax
  8004208093:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
  8004208095:	b8 10 00 00 00       	mov    $0x10,%eax
  800420809a:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
  800420809c:	b8 10 00 00 00       	mov    $0x10,%eax
  80042080a1:	8e d0                	mov    %eax,%ss
	// Load the kernel text segment into CS.
	asm volatile("pushq %%rbx \n \t movabs $1f,%%rax \n \t pushq %%rax \n\t lretq \n 1:\n" :: "b" (GD_KT):"cc","memory");
  80042080a3:	b8 08 00 00 00       	mov    $0x8,%eax
  80042080a8:	89 c3                	mov    %eax,%ebx
  80042080aa:	53                   	push   %rbx
  80042080ab:	48 b8 b8 80 20 04 80 	movabs $0x80042080b8,%rax
  80042080b2:	00 00 00 
  80042080b5:	50                   	push   %rax
  80042080b6:	48 cb                	lretq  
  80042080b8:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
}

static __inline void
lldt(uint16_t sel)
{
	__asm __volatile("lldt %0" : : "r" (sel));
  80042080be:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80042080c2:	0f 00 d0             	lldt   %ax
	// For good measure, clear the local descriptor table (LDT),
	// since we don't use it.
	lldt(0);
}
  80042080c5:	90                   	nop
  80042080c6:	48 83 c4 10          	add    $0x10,%rsp
  80042080ca:	5b                   	pop    %rbx
  80042080cb:	5d                   	pop    %rbp
  80042080cc:	c3                   	retq   

00000080042080cd <env_setup_vm>:
// Returns 0 on success, < 0 on error.  Errors include:
//	-E_NO_MEM if page directory or table could not be allocated.
//
static int
env_setup_vm(struct Env *e)
{
  80042080cd:	55                   	push   %rbp
  80042080ce:	48 89 e5             	mov    %rsp,%rbp
  80042080d1:	48 83 ec 20          	sub    $0x20,%rsp
  80042080d5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;
	int i;
	struct PageInfo *p = NULL;
  80042080d9:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042080e0:	00 

	// Allocate a page for the page directory
	if (!(p = page_alloc(ALLOC_ZERO)))
  80042080e1:	bf 01 00 00 00       	mov    $0x1,%edi
  80042080e6:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  80042080ed:	00 00 00 
  80042080f0:	ff d0                	callq  *%rax
  80042080f2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042080f6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042080fb:	75 0a                	jne    8004208107 <env_setup_vm+0x3a>
		return -E_NO_MEM;
  80042080fd:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004208102:	e9 c2 00 00 00       	jmpq   80042081c9 <env_setup_vm+0xfc>
	//	pp_ref for env_free to work correctly.
	//    - The functions in kern/pmap.h are handy.

	// LAB 3: Your code here.

	p->pp_ref       += 1;
  8004208107:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420810b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420810f:	8d 50 01             	lea    0x1(%rax),%edx
  8004208112:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208116:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_pml4e    = page2kva(p);
  800420811a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420811e:	48 89 c7             	mov    %rax,%rdi
  8004208121:	48 b8 8d 7d 20 04 80 	movabs $0x8004207d8d,%rax
  8004208128:	00 00 00 
  800420812b:	ff d0                	callq  *%rax
  800420812d:	48 89 c2             	mov    %rax,%rdx
  8004208130:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208134:	48 89 90 e0 00 00 00 	mov    %rdx,0xe0(%rax)
	e->env_cr3      = page2pa(p);
  800420813b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420813f:	48 89 c7             	mov    %rax,%rdi
  8004208142:	48 b8 f7 7c 20 04 80 	movabs $0x8004207cf7,%rax
  8004208149:	00 00 00 
  800420814c:	ff d0                	callq  *%rax
  800420814e:	48 89 c2             	mov    %rax,%rdx
  8004208151:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208155:	48 89 90 e8 00 00 00 	mov    %rdx,0xe8(%rax)

	memset(e->env_pml4e, 0, PGSIZE);
  800420815c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208160:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208167:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420816c:	be 00 00 00 00       	mov    $0x0,%esi
  8004208171:	48 89 c7             	mov    %rax,%rdi
  8004208174:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  800420817b:	00 00 00 
  800420817e:	ff d0                	callq  *%rax
	e->env_pml4e[1] = boot_pml4e[1];
  8004208180:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208184:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420818b:	48 8d 50 08          	lea    0x8(%rax),%rdx
  800420818f:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  8004208196:	00 00 00 
  8004208199:	48 8b 00             	mov    (%rax),%rax
  800420819c:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042081a0:	48 89 02             	mov    %rax,(%rdx)


	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	e->env_pml4e[PML4(UVPT)] = e->env_cr3 | PTE_P | PTE_U;
  80042081a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042081a7:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042081ae:	48 8d 50 10          	lea    0x10(%rax),%rdx
  80042081b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042081b6:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042081bd:	48 83 c8 05          	or     $0x5,%rax
  80042081c1:	48 89 02             	mov    %rax,(%rdx)

	return 0;
  80042081c4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042081c9:	c9                   	leaveq 
  80042081ca:	c3                   	retq   

00000080042081cb <env_guest_alloc>:


// #ifndef VMM_GUEST
int
env_guest_alloc(struct Env **newenv_store, envid_t parent_id)
{
  80042081cb:	55                   	push   %rbp
  80042081cc:	48 89 e5             	mov    %rsp,%rbp
  80042081cf:	48 83 ec 50          	sub    $0x50,%rsp
  80042081d3:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  80042081d7:	89 75 b4             	mov    %esi,-0x4c(%rbp)
	int32_t generation;
	struct Env *e;

	if (!(e = env_free_list))
  80042081da:	48 b8 60 02 4e 04 80 	movabs $0x80044e0260,%rax
  80042081e1:	00 00 00 
  80042081e4:	48 8b 00             	mov    (%rax),%rax
  80042081e7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042081eb:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042081f0:	75 0a                	jne    80042081fc <env_guest_alloc+0x31>
		return -E_NO_FREE_ENV;
  80042081f2:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  80042081f7:	e9 67 04 00 00       	jmpq   8004208663 <env_guest_alloc+0x498>

	memset(&e->env_vmxinfo, 0, sizeof(struct VmxGuestInfo));
  80042081fc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208200:	48 05 20 01 00 00    	add    $0x120,%rax
  8004208206:	ba 48 00 00 00       	mov    $0x48,%edx
  800420820b:	be 00 00 00 00       	mov    $0x0,%esi
  8004208210:	48 89 c7             	mov    %rax,%rdi
  8004208213:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  800420821a:	00 00 00 
  800420821d:	ff d0                	callq  *%rax

	// allocate a page for the EPT PML4..
	struct PageInfo *p = NULL;
  800420821f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004208226:	00 

	if (!(p = page_alloc(ALLOC_ZERO)))
  8004208227:	bf 01 00 00 00       	mov    $0x1,%edi
  800420822c:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004208233:	00 00 00 
  8004208236:	ff d0                	callq  *%rax
  8004208238:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420823c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004208241:	75 0a                	jne    800420824d <env_guest_alloc+0x82>
		return -E_NO_MEM;
  8004208243:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004208248:	e9 16 04 00 00       	jmpq   8004208663 <env_guest_alloc+0x498>

	memset(p, 0, sizeof(struct PageInfo));
  800420824d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208251:	ba 10 00 00 00       	mov    $0x10,%edx
  8004208256:	be 00 00 00 00       	mov    $0x0,%esi
  800420825b:	48 89 c7             	mov    %rax,%rdi
  800420825e:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  8004208265:	00 00 00 
  8004208268:	ff d0                	callq  *%rax
	p->pp_ref       += 1;
  800420826a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420826e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004208272:	8d 50 01             	lea    0x1(%rax),%edx
  8004208275:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208279:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_pml4e    = page2kva(p);
  800420827d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208281:	48 89 c7             	mov    %rax,%rdi
  8004208284:	48 b8 8d 7d 20 04 80 	movabs $0x8004207d8d,%rax
  800420828b:	00 00 00 
  800420828e:	ff d0                	callq  *%rax
  8004208290:	48 89 c2             	mov    %rax,%rdx
  8004208293:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208297:	48 89 90 e0 00 00 00 	mov    %rdx,0xe0(%rax)
	e->env_cr3      = page2pa(p);
  800420829e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042082a2:	48 89 c7             	mov    %rax,%rdi
  80042082a5:	48 b8 f7 7c 20 04 80 	movabs $0x8004207cf7,%rax
  80042082ac:	00 00 00 
  80042082af:	ff d0                	callq  *%rax
  80042082b1:	48 89 c2             	mov    %rax,%rdx
  80042082b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042082b8:	48 89 90 e8 00 00 00 	mov    %rdx,0xe8(%rax)

	// Allocate a VMCS.
	struct PageInfo *q = vmx_init_vmcs();
  80042082bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042082c4:	48 ba c4 a6 21 04 80 	movabs $0x800421a6c4,%rdx
  80042082cb:	00 00 00 
  80042082ce:	ff d2                	callq  *%rdx
  80042082d0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (!q) {
  80042082d4:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042082d9:	75 1d                	jne    80042082f8 <env_guest_alloc+0x12d>
		page_decref(p);
  80042082db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042082df:	48 89 c7             	mov    %rax,%rdi
  80042082e2:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  80042082e9:	00 00 00 
  80042082ec:	ff d0                	callq  *%rax
		return -E_NO_MEM;
  80042082ee:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80042082f3:	e9 6b 03 00 00       	jmpq   8004208663 <env_guest_alloc+0x498>
	}
	q->pp_ref += 1;
  80042082f8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042082fc:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004208300:	8d 50 01             	lea    0x1(%rax),%edx
  8004208303:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208307:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_vmxinfo.vmcs = page2kva(q);
  800420830b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420830f:	48 89 c7             	mov    %rax,%rdi
  8004208312:	48 b8 8d 7d 20 04 80 	movabs $0x8004207d8d,%rax
  8004208319:	00 00 00 
  800420831c:	ff d0                	callq  *%rax
  800420831e:	48 89 c2             	mov    %rax,%rdx
  8004208321:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208325:	48 89 90 28 01 00 00 	mov    %rdx,0x128(%rax)

	// Allocate a page for msr load/store area.
	struct PageInfo *r = NULL;
  800420832c:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004208333:	00 
	if (!(r = page_alloc(ALLOC_ZERO))) {
  8004208334:	bf 01 00 00 00       	mov    $0x1,%edi
  8004208339:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004208340:	00 00 00 
  8004208343:	ff d0                	callq  *%rax
  8004208345:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004208349:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420834e:	75 30                	jne    8004208380 <env_guest_alloc+0x1b5>
		page_decref(p);
  8004208350:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208354:	48 89 c7             	mov    %rax,%rdi
  8004208357:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  800420835e:	00 00 00 
  8004208361:	ff d0                	callq  *%rax
		page_decref(q);
  8004208363:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208367:	48 89 c7             	mov    %rax,%rdi
  800420836a:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  8004208371:	00 00 00 
  8004208374:	ff d0                	callq  *%rax
		return -E_NO_MEM;
  8004208376:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420837b:	e9 e3 02 00 00       	jmpq   8004208663 <env_guest_alloc+0x498>
	}
	r->pp_ref += 1;
  8004208380:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208384:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004208388:	8d 50 01             	lea    0x1(%rax),%edx
  800420838b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420838f:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_vmxinfo.msr_host_area = page2kva(r);
  8004208393:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208397:	48 89 c7             	mov    %rax,%rdi
  800420839a:	48 b8 8d 7d 20 04 80 	movabs $0x8004207d8d,%rax
  80042083a1:	00 00 00 
  80042083a4:	ff d0                	callq  *%rax
  80042083a6:	48 89 c2             	mov    %rax,%rdx
  80042083a9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083ad:	48 89 90 50 01 00 00 	mov    %rdx,0x150(%rax)
	e->env_vmxinfo.msr_guest_area = page2kva(r) + PGSIZE / 2;
  80042083b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042083b8:	48 89 c7             	mov    %rax,%rdi
  80042083bb:	48 b8 8d 7d 20 04 80 	movabs $0x8004207d8d,%rax
  80042083c2:	00 00 00 
  80042083c5:	ff d0                	callq  *%rax
  80042083c7:	48 8d 90 00 08 00 00 	lea    0x800(%rax),%rdx
  80042083ce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083d2:	48 89 90 58 01 00 00 	mov    %rdx,0x158(%rax)

	// Allocate pages for IO bitmaps.
	struct PageInfo *s = NULL;
  80042083d9:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  80042083e0:	00 
	if (!(s = page_alloc(ALLOC_ZERO))) {
  80042083e1:	bf 01 00 00 00       	mov    $0x1,%edi
  80042083e6:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  80042083ed:	00 00 00 
  80042083f0:	ff d0                	callq  *%rax
  80042083f2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042083f6:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042083fb:	75 43                	jne    8004208440 <env_guest_alloc+0x275>
		page_decref(p);
  80042083fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208401:	48 89 c7             	mov    %rax,%rdi
  8004208404:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  800420840b:	00 00 00 
  800420840e:	ff d0                	callq  *%rax
		page_decref(q);
  8004208410:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208414:	48 89 c7             	mov    %rax,%rdi
  8004208417:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  800420841e:	00 00 00 
  8004208421:	ff d0                	callq  *%rax
		page_decref(r);
  8004208423:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208427:	48 89 c7             	mov    %rax,%rdi
  800420842a:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  8004208431:	00 00 00 
  8004208434:	ff d0                	callq  *%rax
		return -E_NO_MEM;
  8004208436:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420843b:	e9 23 02 00 00       	jmpq   8004208663 <env_guest_alloc+0x498>
	}
	s->pp_ref += 1;
  8004208440:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208444:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004208448:	8d 50 01             	lea    0x1(%rax),%edx
  800420844b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420844f:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_vmxinfo.io_bmap_a = page2kva(s);
  8004208453:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208457:	48 89 c7             	mov    %rax,%rdi
  800420845a:	48 b8 8d 7d 20 04 80 	movabs $0x8004207d8d,%rax
  8004208461:	00 00 00 
  8004208464:	ff d0                	callq  *%rax
  8004208466:	48 89 c2             	mov    %rax,%rdx
  8004208469:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420846d:	48 89 90 38 01 00 00 	mov    %rdx,0x138(%rax)

	struct PageInfo *t = NULL;
  8004208474:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  800420847b:	00 
	if (!(t = page_alloc(ALLOC_ZERO))) {
  800420847c:	bf 01 00 00 00       	mov    $0x1,%edi
  8004208481:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004208488:	00 00 00 
  800420848b:	ff d0                	callq  *%rax
  800420848d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004208491:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004208496:	75 56                	jne    80042084ee <env_guest_alloc+0x323>
		page_decref(p);
  8004208498:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420849c:	48 89 c7             	mov    %rax,%rdi
  800420849f:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  80042084a6:	00 00 00 
  80042084a9:	ff d0                	callq  *%rax
		page_decref(q);
  80042084ab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042084af:	48 89 c7             	mov    %rax,%rdi
  80042084b2:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  80042084b9:	00 00 00 
  80042084bc:	ff d0                	callq  *%rax
		page_decref(r);
  80042084be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042084c2:	48 89 c7             	mov    %rax,%rdi
  80042084c5:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  80042084cc:	00 00 00 
  80042084cf:	ff d0                	callq  *%rax
		page_decref(s);
  80042084d1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042084d5:	48 89 c7             	mov    %rax,%rdi
  80042084d8:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  80042084df:	00 00 00 
  80042084e2:	ff d0                	callq  *%rax
		return -E_NO_MEM;
  80042084e4:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80042084e9:	e9 75 01 00 00       	jmpq   8004208663 <env_guest_alloc+0x498>
	}
	t->pp_ref += 1;
  80042084ee:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042084f2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042084f6:	8d 50 01             	lea    0x1(%rax),%edx
  80042084f9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042084fd:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_vmxinfo.io_bmap_b = page2kva(t);
  8004208501:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208505:	48 89 c7             	mov    %rax,%rdi
  8004208508:	48 b8 8d 7d 20 04 80 	movabs $0x8004207d8d,%rax
  800420850f:	00 00 00 
  8004208512:	ff d0                	callq  *%rax
  8004208514:	48 89 c2             	mov    %rax,%rdx
  8004208517:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420851b:	48 89 90 40 01 00 00 	mov    %rdx,0x140(%rax)

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  8004208522:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208526:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420852c:	05 00 10 00 00       	add    $0x1000,%eax
  8004208531:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  8004208536:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  8004208539:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420853d:	7f 07                	jg     8004208546 <env_guest_alloc+0x37b>
		generation = 1 << ENVGENSHIFT;
  800420853f:	c7 45 fc 00 10 00 00 	movl   $0x1000,-0x4(%rbp)
	e->env_id = generation | (e - envs);
  8004208546:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420854a:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  8004208551:	00 00 00 
  8004208554:	48 8b 00             	mov    (%rax),%rax
  8004208557:	48 29 c2             	sub    %rax,%rdx
  800420855a:	48 89 d0             	mov    %rdx,%rax
  800420855d:	48 c1 f8 03          	sar    $0x3,%rax
  8004208561:	48 89 c2             	mov    %rax,%rdx
  8004208564:	48 b8 a5 4f fa a4 4f 	movabs $0x4fa4fa4fa4fa4fa5,%rax
  800420856b:	fa a4 4f 
  800420856e:	48 0f af c2          	imul   %rdx,%rax
  8004208572:	0b 45 fc             	or     -0x4(%rbp),%eax
  8004208575:	89 c2                	mov    %eax,%edx
  8004208577:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420857b:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  8004208581:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208585:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004208588:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_GUEST;
  800420858e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208592:	c7 80 d0 00 00 00 03 	movl   $0x3,0xd0(%rax)
  8004208599:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  800420859c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042085a0:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  80042085a7:	00 00 00 
	e->env_runs = 0;
  80042085aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042085ae:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  80042085b5:	00 00 00 
	e->env_vmxinfo.vcpunum = vcpu_count++;
  80042085b8:	48 b8 50 02 4e 04 80 	movabs $0x80044e0250,%rax
  80042085bf:	00 00 00 
  80042085c2:	8b 00                	mov    (%rax),%eax
  80042085c4:	8d 48 01             	lea    0x1(%rax),%ecx
  80042085c7:	48 ba 50 02 4e 04 80 	movabs $0x80044e0250,%rdx
  80042085ce:	00 00 00 
  80042085d1:	89 0a                	mov    %ecx,(%rdx)
  80042085d3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042085d7:	89 82 60 01 00 00    	mov    %eax,0x160(%rdx)
    	cprintf("VCPUNUM allocated: %d\n", e->env_vmxinfo.vcpunum);
  80042085dd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042085e1:	8b 80 60 01 00 00    	mov    0x160(%rax),%eax
  80042085e7:	89 c6                	mov    %eax,%esi
  80042085e9:	48 bf 43 03 22 04 80 	movabs $0x8004220343,%rdi
  80042085f0:	00 00 00 
  80042085f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042085f8:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  80042085ff:	00 00 00 
  8004208602:	ff d2                	callq  *%rdx

	memset(&e->env_tf, 0, sizeof(e->env_tf));
  8004208604:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208608:	ba c0 00 00 00       	mov    $0xc0,%edx
  800420860d:	be 00 00 00 00       	mov    $0x0,%esi
  8004208612:	48 89 c7             	mov    %rax,%rdi
  8004208615:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  800420861c:	00 00 00 
  800420861f:	ff d0                	callq  *%rax

	e->env_pgfault_upcall = 0;
  8004208621:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208625:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  800420862c:	00 00 00 00 
	e->env_ipc_recving = 0;
  8004208630:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208634:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)

	// commit the allocation
	env_free_list = e->env_link;
  800420863b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420863f:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  8004208646:	48 b8 60 02 4e 04 80 	movabs $0x80044e0260,%rax
  800420864d:	00 00 00 
  8004208650:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  8004208653:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208657:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420865b:	48 89 10             	mov    %rdx,(%rax)

	return 0;
  800420865e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004208663:	c9                   	leaveq 
  8004208664:	c3                   	retq   

0000008004208665 <env_guest_free>:

void env_guest_free(struct Env *e) {
  8004208665:	55                   	push   %rbp
  8004208666:	48 89 e5             	mov    %rsp,%rbp
  8004208669:	53                   	push   %rbx
  800420866a:	48 83 ec 38          	sub    $0x38,%rsp
  800420866e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	// Free the VMCS.
	page_decref(pa2page(PADDR(e->env_vmxinfo.vmcs)));
  8004208672:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208676:	48 8b 80 28 01 00 00 	mov    0x128(%rax),%rax
  800420867d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004208681:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004208688:	00 00 00 
  800420868b:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420868f:	77 32                	ja     80042086c3 <env_guest_free+0x5e>
  8004208691:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208695:	48 89 c1             	mov    %rax,%rcx
  8004208698:	48 ba 60 03 22 04 80 	movabs $0x8004220360,%rdx
  800420869f:	00 00 00 
  80042086a2:	be 45 01 00 00       	mov    $0x145,%esi
  80042086a7:	48 bf 84 03 22 04 80 	movabs $0x8004220384,%rdi
  80042086ae:	00 00 00 
  80042086b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042086b6:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042086bd:	00 00 00 
  80042086c0:	41 ff d0             	callq  *%r8
  80042086c3:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042086ca:	ff ff ff 
  80042086cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042086d1:	48 01 d0             	add    %rdx,%rax
  80042086d4:	48 89 c7             	mov    %rax,%rdi
  80042086d7:	48 b8 1c 7d 20 04 80 	movabs $0x8004207d1c,%rax
  80042086de:	00 00 00 
  80042086e1:	ff d0                	callq  *%rax
  80042086e3:	48 89 c7             	mov    %rax,%rdi
  80042086e6:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  80042086ed:	00 00 00 
  80042086f0:	ff d0                	callq  *%rax
	// Free msr load/store area.
	page_decref(pa2page(PADDR(e->env_vmxinfo.msr_host_area)));
  80042086f2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042086f6:	48 8b 80 50 01 00 00 	mov    0x150(%rax),%rax
  80042086fd:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004208701:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004208708:	00 00 00 
  800420870b:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  800420870f:	77 32                	ja     8004208743 <env_guest_free+0xde>
  8004208711:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208715:	48 89 c1             	mov    %rax,%rcx
  8004208718:	48 ba 60 03 22 04 80 	movabs $0x8004220360,%rdx
  800420871f:	00 00 00 
  8004208722:	be 47 01 00 00       	mov    $0x147,%esi
  8004208727:	48 bf 84 03 22 04 80 	movabs $0x8004220384,%rdi
  800420872e:	00 00 00 
  8004208731:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208736:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420873d:	00 00 00 
  8004208740:	41 ff d0             	callq  *%r8
  8004208743:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420874a:	ff ff ff 
  800420874d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208751:	48 01 d0             	add    %rdx,%rax
  8004208754:	48 89 c7             	mov    %rax,%rdi
  8004208757:	48 b8 1c 7d 20 04 80 	movabs $0x8004207d1c,%rax
  800420875e:	00 00 00 
  8004208761:	ff d0                	callq  *%rax
  8004208763:	48 89 c7             	mov    %rax,%rdi
  8004208766:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  800420876d:	00 00 00 
  8004208770:	ff d0                	callq  *%rax
	// Free IO bitmaps page.
	page_decref(pa2page(PADDR(e->env_vmxinfo.io_bmap_a)));
  8004208772:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208776:	48 8b 80 38 01 00 00 	mov    0x138(%rax),%rax
  800420877d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004208781:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004208788:	00 00 00 
  800420878b:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  800420878f:	77 32                	ja     80042087c3 <env_guest_free+0x15e>
  8004208791:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208795:	48 89 c1             	mov    %rax,%rcx
  8004208798:	48 ba 60 03 22 04 80 	movabs $0x8004220360,%rdx
  800420879f:	00 00 00 
  80042087a2:	be 49 01 00 00       	mov    $0x149,%esi
  80042087a7:	48 bf 84 03 22 04 80 	movabs $0x8004220384,%rdi
  80042087ae:	00 00 00 
  80042087b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042087b6:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042087bd:	00 00 00 
  80042087c0:	41 ff d0             	callq  *%r8
  80042087c3:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042087ca:	ff ff ff 
  80042087cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042087d1:	48 01 d0             	add    %rdx,%rax
  80042087d4:	48 89 c7             	mov    %rax,%rdi
  80042087d7:	48 b8 1c 7d 20 04 80 	movabs $0x8004207d1c,%rax
  80042087de:	00 00 00 
  80042087e1:	ff d0                	callq  *%rax
  80042087e3:	48 89 c7             	mov    %rax,%rdi
  80042087e6:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  80042087ed:	00 00 00 
  80042087f0:	ff d0                	callq  *%rax
	page_decref(pa2page(PADDR(e->env_vmxinfo.io_bmap_b)));
  80042087f2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042087f6:	48 8b 80 40 01 00 00 	mov    0x140(%rax),%rax
  80042087fd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004208801:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004208808:	00 00 00 
  800420880b:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420880f:	77 32                	ja     8004208843 <env_guest_free+0x1de>
  8004208811:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208815:	48 89 c1             	mov    %rax,%rcx
  8004208818:	48 ba 60 03 22 04 80 	movabs $0x8004220360,%rdx
  800420881f:	00 00 00 
  8004208822:	be 4a 01 00 00       	mov    $0x14a,%esi
  8004208827:	48 bf 84 03 22 04 80 	movabs $0x8004220384,%rdi
  800420882e:	00 00 00 
  8004208831:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208836:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420883d:	00 00 00 
  8004208840:	41 ff d0             	callq  *%r8
  8004208843:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420884a:	ff ff ff 
  800420884d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208851:	48 01 d0             	add    %rdx,%rax
  8004208854:	48 89 c7             	mov    %rax,%rdi
  8004208857:	48 b8 1c 7d 20 04 80 	movabs $0x8004207d1c,%rax
  800420885e:	00 00 00 
  8004208861:	ff d0                	callq  *%rax
  8004208863:	48 89 c7             	mov    %rax,%rdi
  8004208866:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  800420886d:	00 00 00 
  8004208870:	ff d0                	callq  *%rax
    
	// Free the host pages that were allocated for the guest and 
	// the EPT tables itself.
	free_guest_mem(e->env_pml4e);
  8004208872:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208876:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420887d:	48 89 c7             	mov    %rax,%rdi
  8004208880:	48 b8 b5 9e 21 04 80 	movabs $0x8004219eb5,%rax
  8004208887:	00 00 00 
  800420888a:	ff d0                	callq  *%rax

	// Free the EPT PML4 page.
	page_decref(pa2page(e->env_cr3));
  800420888c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208890:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208897:	48 89 c7             	mov    %rax,%rdi
  800420889a:	48 b8 1c 7d 20 04 80 	movabs $0x8004207d1c,%rax
  80042088a1:	00 00 00 
  80042088a4:	ff d0                	callq  *%rax
  80042088a6:	48 89 c7             	mov    %rax,%rdi
  80042088a9:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  80042088b0:	00 00 00 
  80042088b3:	ff d0                	callq  *%rax
	e->env_pml4e = 0;
  80042088b5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042088b9:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  80042088c0:	00 00 00 00 
	e->env_cr3 = 0;
  80042088c4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042088c8:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  80042088cf:	00 00 00 00 

	// return the environment to the free list
	e->env_status = ENV_FREE;
  80042088d3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042088d7:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  80042088de:	00 00 00 
	e->env_link = env_free_list;
  80042088e1:	48 b8 60 02 4e 04 80 	movabs $0x80044e0260,%rax
  80042088e8:	00 00 00 
  80042088eb:	48 8b 10             	mov    (%rax),%rdx
  80042088ee:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042088f2:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  80042088f9:	48 b8 60 02 4e 04 80 	movabs $0x80044e0260,%rax
  8004208900:	00 00 00 
  8004208903:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004208907:	48 89 10             	mov    %rdx,(%rax)

	cprintf("[%08x] free vmx guest env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
  800420890a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420890e:	8b 98 c8 00 00 00    	mov    0xc8(%rax),%ebx
  8004208914:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420891b:	00 00 00 
  800420891e:	ff d0                	callq  *%rax
  8004208920:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  8004208927:	00 00 00 
  800420892a:	48 98                	cltq   
  800420892c:	48 c1 e0 03          	shl    $0x3,%rax
  8004208930:	48 89 c1             	mov    %rax,%rcx
  8004208933:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208937:	48 01 c8             	add    %rcx,%rax
  800420893a:	48 01 d0             	add    %rdx,%rax
  800420893d:	48 83 c0 08          	add    $0x8,%rax
  8004208941:	48 8b 00             	mov    (%rax),%rax
  8004208944:	48 85 c0             	test   %rax,%rax
  8004208947:	74 38                	je     8004208981 <env_guest_free+0x31c>
  8004208949:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  8004208950:	00 00 00 
  8004208953:	ff d0                	callq  *%rax
  8004208955:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420895c:	00 00 00 
  800420895f:	48 98                	cltq   
  8004208961:	48 c1 e0 03          	shl    $0x3,%rax
  8004208965:	48 89 c1             	mov    %rax,%rcx
  8004208968:	48 c1 e1 04          	shl    $0x4,%rcx
  800420896c:	48 01 c8             	add    %rcx,%rax
  800420896f:	48 01 d0             	add    %rdx,%rax
  8004208972:	48 83 c0 08          	add    $0x8,%rax
  8004208976:	48 8b 00             	mov    (%rax),%rax
  8004208979:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420897f:	eb 05                	jmp    8004208986 <env_guest_free+0x321>
  8004208981:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208986:	89 da                	mov    %ebx,%edx
  8004208988:	89 c6                	mov    %eax,%esi
  800420898a:	48 bf 90 03 22 04 80 	movabs $0x8004220390,%rdi
  8004208991:	00 00 00 
  8004208994:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208999:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  80042089a0:	00 00 00 
  80042089a3:	ff d1                	callq  *%rcx
}
  80042089a5:	90                   	nop
  80042089a6:	48 83 c4 38          	add    $0x38,%rsp
  80042089aa:	5b                   	pop    %rbx
  80042089ab:	5d                   	pop    %rbp
  80042089ac:	c3                   	retq   

00000080042089ad <env_alloc>:
//	-E_NO_FREE_ENV if all NENVS environments are allocated
//	-E_NO_MEM on memory exhaustion
//
int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
  80042089ad:	55                   	push   %rbp
  80042089ae:	48 89 e5             	mov    %rsp,%rbp
  80042089b1:	48 83 ec 30          	sub    $0x30,%rsp
  80042089b5:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042089b9:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	int32_t generation;
	int r;
	struct Env *e;

	if (!(e = env_free_list))
  80042089bc:	48 b8 60 02 4e 04 80 	movabs $0x80044e0260,%rax
  80042089c3:	00 00 00 
  80042089c6:	48 8b 00             	mov    (%rax),%rax
  80042089c9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042089cd:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042089d2:	75 0a                	jne    80042089de <env_alloc+0x31>
		return -E_NO_FREE_ENV;
  80042089d4:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  80042089d9:	e9 69 01 00 00       	jmpq   8004208b47 <env_alloc+0x19a>

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
  80042089de:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042089e2:	48 89 c7             	mov    %rax,%rdi
  80042089e5:	48 b8 cd 80 20 04 80 	movabs $0x80042080cd,%rax
  80042089ec:	00 00 00 
  80042089ef:	ff d0                	callq  *%rax
  80042089f1:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042089f4:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80042089f8:	79 08                	jns    8004208a02 <env_alloc+0x55>
		return r;
  80042089fa:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042089fd:	e9 45 01 00 00       	jmpq   8004208b47 <env_alloc+0x19a>

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  8004208a02:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208a06:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004208a0c:	05 00 10 00 00       	add    $0x1000,%eax
  8004208a11:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  8004208a16:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  8004208a19:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004208a1d:	7f 07                	jg     8004208a26 <env_alloc+0x79>
		generation = 1 << ENVGENSHIFT;
  8004208a1f:	c7 45 fc 00 10 00 00 	movl   $0x1000,-0x4(%rbp)
	e->env_id = generation | (e - envs);
  8004208a26:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004208a2a:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  8004208a31:	00 00 00 
  8004208a34:	48 8b 00             	mov    (%rax),%rax
  8004208a37:	48 29 c2             	sub    %rax,%rdx
  8004208a3a:	48 89 d0             	mov    %rdx,%rax
  8004208a3d:	48 c1 f8 03          	sar    $0x3,%rax
  8004208a41:	48 89 c2             	mov    %rax,%rdx
  8004208a44:	48 b8 a5 4f fa a4 4f 	movabs $0x4fa4fa4fa4fa4fa5,%rax
  8004208a4b:	fa a4 4f 
  8004208a4e:	48 0f af c2          	imul   %rdx,%rax
  8004208a52:	0b 45 fc             	or     -0x4(%rbp),%eax
  8004208a55:	89 c2                	mov    %eax,%edx
  8004208a57:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208a5b:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  8004208a61:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208a65:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004208a68:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_USER;
  8004208a6e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208a72:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  8004208a79:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  8004208a7c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208a80:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004208a87:	00 00 00 
	e->env_runs = 0;
  8004208a8a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208a8e:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  8004208a95:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
  8004208a98:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208a9c:	ba c0 00 00 00       	mov    $0xc0,%edx
  8004208aa1:	be 00 00 00 00       	mov    $0x0,%esi
  8004208aa6:	48 89 c7             	mov    %rax,%rdi
  8004208aa9:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  8004208ab0:	00 00 00 
  8004208ab3:	ff d0                	callq  *%rax
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.  When
	// we switch privilege levels, the hardware does various
	// checks involving the RPL and the Descriptor Privilege Level
	// (DPL) stored in the descriptors themselves.
	e->env_tf.tf_ds = GD_UD | 3;
  8004208ab5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208ab9:	66 c7 80 80 00 00 00 	movw   $0x23,0x80(%rax)
  8004208ac0:	23 00 
	e->env_tf.tf_es = GD_UD | 3;
  8004208ac2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208ac6:	66 c7 40 78 23 00    	movw   $0x23,0x78(%rax)
	e->env_tf.tf_ss = GD_UD | 3;
  8004208acc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208ad0:	66 c7 80 b8 00 00 00 	movw   $0x23,0xb8(%rax)
  8004208ad7:	23 00 
	e->env_tf.tf_rsp = USTACKTOP;
  8004208ad9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208add:	b9 00 e0 7f ef       	mov    $0xef7fe000,%ecx
  8004208ae2:	48 89 88 b0 00 00 00 	mov    %rcx,0xb0(%rax)
	e->env_tf.tf_cs = GD_UT | 3;
  8004208ae9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208aed:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  8004208af4:	1b 00 


	// Enable interrupts while in user mode.
	// LAB 4: Your code here.

	e->env_tf.tf_eflags = FL_IF; // interrupts enabled
  8004208af6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208afa:	48 c7 80 a8 00 00 00 	movq   $0x200,0xa8(%rax)
  8004208b01:	00 02 00 00 


	// Clear the page fault handler until user installs one.
	e->env_pgfault_upcall = 0;
  8004208b05:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208b09:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  8004208b10:	00 00 00 00 

	// Also clear the IPC receiving flag.
	e->env_ipc_recving = 0;
  8004208b14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208b18:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)


	// commit the allocation
	env_free_list = e->env_link;
  8004208b1f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208b23:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  8004208b2a:	48 b8 60 02 4e 04 80 	movabs $0x80044e0260,%rax
  8004208b31:	00 00 00 
  8004208b34:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  8004208b37:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208b3b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004208b3f:	48 89 10             	mov    %rdx,(%rax)


	// cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);

	return 0;
  8004208b42:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004208b47:	c9                   	leaveq 
  8004208b48:	c3                   	retq   

0000008004208b49 <region_alloc>:
// Pages should be writable by user and kernel.
// Panic if any allocation attempt fails.
//
static void
region_alloc(struct Env *e, void *va, size_t len)
{
  8004208b49:	55                   	push   %rbp
  8004208b4a:	48 89 e5             	mov    %rsp,%rbp
  8004208b4d:	48 83 ec 40          	sub    $0x40,%rsp
  8004208b51:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004208b55:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004208b59:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)

	int r;
	struct PageInfo *pp;
	void *endva = (uint8_t*) va + len;
  8004208b5d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004208b61:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208b65:	48 01 d0             	add    %rdx,%rax
  8004208b68:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	while (va < endva) {
  8004208b6c:	e9 c8 00 00 00       	jmpq   8004208c39 <region_alloc+0xf0>
		// Allocate and map a page covering virtual address va.
		if (!(pp = page_alloc(0)))
  8004208b71:	bf 00 00 00 00       	mov    $0x0,%edi
  8004208b76:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  8004208b7d:	00 00 00 
  8004208b80:	ff d0                	callq  *%rax
  8004208b82:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004208b86:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004208b8b:	75 30                	jne    8004208bbd <region_alloc+0x74>
			panic("map_segment: could not alloc page: %e\n", -E_NO_MEM);
  8004208b8d:	b9 fc ff ff ff       	mov    $0xfffffffc,%ecx
  8004208b92:	48 ba b0 03 22 04 80 	movabs $0x80042203b0,%rdx
  8004208b99:	00 00 00 
  8004208b9c:	be c0 01 00 00       	mov    $0x1c0,%esi
  8004208ba1:	48 bf 84 03 22 04 80 	movabs $0x8004220384,%rdi
  8004208ba8:	00 00 00 
  8004208bab:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208bb0:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004208bb7:	00 00 00 
  8004208bba:	41 ff d0             	callq  *%r8

		// Insert the page into the env's address space
		if ((r = page_insert(e->env_pml4e, pp, va, PTE_P|PTE_W|PTE_U)) < 0)
  8004208bbd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208bc1:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208bc8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004208bcc:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004208bd0:	b9 07 00 00 00       	mov    $0x7,%ecx
  8004208bd5:	48 89 c7             	mov    %rax,%rdi
  8004208bd8:	48 b8 33 3a 20 04 80 	movabs $0x8004203a33,%rax
  8004208bdf:	00 00 00 
  8004208be2:	ff d0                	callq  *%rax
  8004208be4:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004208be7:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8004208beb:	79 30                	jns    8004208c1d <region_alloc+0xd4>
			panic("map_segment: could not insert page: %e\n", r);
  8004208bed:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208bf0:	89 c1                	mov    %eax,%ecx
  8004208bf2:	48 ba d8 03 22 04 80 	movabs $0x80042203d8,%rdx
  8004208bf9:	00 00 00 
  8004208bfc:	be c4 01 00 00       	mov    $0x1c4,%esi
  8004208c01:	48 bf 84 03 22 04 80 	movabs $0x8004220384,%rdi
  8004208c08:	00 00 00 
  8004208c0b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208c10:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004208c17:	00 00 00 
  8004208c1a:	41 ff d0             	callq  *%r8

		va = ROUNDDOWN((uint8_t*) va + PGSIZE, PGSIZE);
  8004208c1d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208c21:	48 05 00 10 00 00    	add    $0x1000,%rax
  8004208c27:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004208c2b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208c2f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208c35:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	int r;
	struct PageInfo *pp;
	void *endva = (uint8_t*) va + len;

	while (va < endva) {
  8004208c39:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208c3d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208c41:	0f 82 2a ff ff ff    	jb     8004208b71 <region_alloc+0x28>
	//
	// Hint: It is easier to use region_alloc if the caller can pass
	//   'va' and 'len' values that are not page-aligned.
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
}
  8004208c47:	90                   	nop
  8004208c48:	c9                   	leaveq 
  8004208c49:	c3                   	retq   

0000008004208c4a <load_icode>:
// load_icode panics if it encounters problems.
//  - How might load_icode fail?  What might be wrong with the given input?
//
void
load_icode(struct Env *e, uint8_t *binary)
{
  8004208c4a:	55                   	push   %rbp
  8004208c4b:	48 89 e5             	mov    %rsp,%rbp
  8004208c4e:	48 83 ec 70          	sub    $0x70,%rsp
  8004208c52:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  8004208c56:	48 89 75 90          	mov    %rsi,-0x70(%rbp)

	struct Elf *elf = (struct Elf *)binary;
  8004208c5a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004208c5e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	struct Proghdr *ph, *eph;

	if (elf && elf->e_magic == ELF_MAGIC) {
  8004208c62:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004208c67:	0f 84 72 03 00 00    	je     8004208fdf <load_icode+0x395>
  8004208c6d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208c71:	8b 00                	mov    (%rax),%eax
  8004208c73:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  8004208c78:	0f 85 61 03 00 00    	jne    8004208fdf <load_icode+0x395>
		lcr3(PADDR((uint64_t)e->env_pml4e));
  8004208c7e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208c82:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208c89:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004208c8d:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004208c94:	00 00 00 
  8004208c97:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004208c9b:	77 32                	ja     8004208ccf <load_icode+0x85>
  8004208c9d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208ca1:	48 89 c1             	mov    %rax,%rcx
  8004208ca4:	48 ba 60 03 22 04 80 	movabs $0x8004220360,%rdx
  8004208cab:	00 00 00 
  8004208cae:	be f0 01 00 00       	mov    $0x1f0,%esi
  8004208cb3:	48 bf 84 03 22 04 80 	movabs $0x8004220384,%rdi
  8004208cba:	00 00 00 
  8004208cbd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208cc2:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004208cc9:	00 00 00 
  8004208ccc:	41 ff d0             	callq  *%r8
  8004208ccf:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004208cd6:	ff ff ff 
  8004208cd9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208cdd:	48 01 d0             	add    %rdx,%rax
  8004208ce0:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004208ce4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208ce8:	0f 22 d8             	mov    %rax,%cr3
		ph  = (struct Proghdr *)((uint8_t *)elf + elf->e_phoff);
  8004208ceb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208cef:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004208cf3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208cf7:	48 01 d0             	add    %rdx,%rax
  8004208cfa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		eph = ph + elf->e_phnum;
  8004208cfe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208d02:	0f b7 40 38          	movzwl 0x38(%rax),%eax
  8004208d06:	0f b7 c0             	movzwl %ax,%eax
  8004208d09:	48 c1 e0 03          	shl    $0x3,%rax
  8004208d0d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208d14:	00 
  8004208d15:	48 29 c2             	sub    %rax,%rdx
  8004208d18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208d1c:	48 01 d0             	add    %rdx,%rax
  8004208d1f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		for(;ph < eph; ph++) {
  8004208d23:	e9 c0 00 00 00       	jmpq   8004208de8 <load_icode+0x19e>
			if (ph->p_type == ELF_PROG_LOAD) {
  8004208d28:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208d2c:	8b 00                	mov    (%rax),%eax
  8004208d2e:	83 f8 01             	cmp    $0x1,%eax
  8004208d31:	0f 85 ac 00 00 00    	jne    8004208de3 <load_icode+0x199>
				region_alloc(e, (void *)ph->p_va, ph->p_memsz);
  8004208d37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208d3b:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004208d3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208d43:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004208d47:	48 89 c1             	mov    %rax,%rcx
  8004208d4a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208d4e:	48 89 ce             	mov    %rcx,%rsi
  8004208d51:	48 89 c7             	mov    %rax,%rdi
  8004208d54:	48 b8 49 8b 20 04 80 	movabs $0x8004208b49,%rax
  8004208d5b:	00 00 00 
  8004208d5e:	ff d0                	callq  *%rax
				memcpy((void *)ph->p_va, (void *)((uint8_t *)elf + ph->p_offset), ph->p_filesz);
  8004208d60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208d64:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004208d68:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004208d6c:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004208d70:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004208d74:	48 01 d1             	add    %rdx,%rcx
  8004208d77:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004208d7b:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004208d7f:	48 89 d7             	mov    %rdx,%rdi
  8004208d82:	48 89 c2             	mov    %rax,%rdx
  8004208d85:	48 89 ce             	mov    %rcx,%rsi
  8004208d88:	48 b8 5b 13 21 04 80 	movabs $0x800421135b,%rax
  8004208d8f:	00 00 00 
  8004208d92:	ff d0                	callq  *%rax
				if (ph->p_filesz < ph->p_memsz) {
  8004208d94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208d98:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004208d9c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208da0:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004208da4:	48 39 c2             	cmp    %rax,%rdx
  8004208da7:	73 3a                	jae    8004208de3 <load_icode+0x199>
					memset((void *)(ph->p_va + ph->p_filesz), 0, ph->p_memsz-ph->p_filesz);
  8004208da9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208dad:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004208db1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208db5:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004208db9:	48 29 c2             	sub    %rax,%rdx
  8004208dbc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208dc0:	48 8b 48 10          	mov    0x10(%rax),%rcx
  8004208dc4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208dc8:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004208dcc:	48 01 c8             	add    %rcx,%rax
  8004208dcf:	be 00 00 00 00       	mov    $0x0,%esi
  8004208dd4:	48 89 c7             	mov    %rax,%rdi
  8004208dd7:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  8004208dde:	00 00 00 
  8004208de1:	ff d0                	callq  *%rax

	if (elf && elf->e_magic == ELF_MAGIC) {
		lcr3(PADDR((uint64_t)e->env_pml4e));
		ph  = (struct Proghdr *)((uint8_t *)elf + elf->e_phoff);
		eph = ph + elf->e_phnum;
		for(;ph < eph; ph++) {
  8004208de3:	48 83 45 f8 38       	addq   $0x38,-0x8(%rbp)
  8004208de8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208dec:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004208df0:	0f 82 32 ff ff ff    	jb     8004208d28 <load_icode+0xde>
				if (ph->p_filesz < ph->p_memsz) {
					memset((void *)(ph->p_va + ph->p_filesz), 0, ph->p_memsz-ph->p_filesz);
				}
			}
		}
		region_alloc(e, (void*) (USTACKTOP - PGSIZE), PGSIZE);
  8004208df6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208dfa:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004208dff:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  8004208e04:	48 89 c7             	mov    %rax,%rdi
  8004208e07:	48 b8 49 8b 20 04 80 	movabs $0x8004208b49,%rax
  8004208e0e:	00 00 00 
  8004208e11:	ff d0                	callq  *%rax
		e->env_tf.tf_rip    = elf->e_entry;
  8004208e13:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208e17:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004208e1b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208e1f:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		e->env_tf.tf_rsp    = USTACKTOP; //keeping stack 8 byte aligned
  8004208e26:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208e2a:	be 00 e0 7f ef       	mov    $0xef7fe000,%esi
  8004208e2f:	48 89 b0 b0 00 00 00 	mov    %rsi,0xb0(%rax)

		uintptr_t debug_address = USTABDATA;
  8004208e36:	48 c7 45 f0 00 00 20 	movq   $0x200000,-0x10(%rbp)
  8004208e3d:	00 
		struct Secthdr *sh = (struct Secthdr *)(((uint8_t *)elf + elf->e_shoff));
  8004208e3e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208e42:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004208e46:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208e4a:	48 01 d0             	add    %rdx,%rax
  8004208e4d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		struct Secthdr *shstr_tab = sh + elf->e_shstrndx;
  8004208e51:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208e55:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004208e59:	0f b7 c0             	movzwl %ax,%eax
  8004208e5c:	48 c1 e0 06          	shl    $0x6,%rax
  8004208e60:	48 89 c2             	mov    %rax,%rdx
  8004208e63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208e67:	48 01 d0             	add    %rdx,%rax
  8004208e6a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		struct Secthdr* esh = sh + elf->e_shnum;
  8004208e6e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208e72:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004208e76:	0f b7 c0             	movzwl %ax,%eax
  8004208e79:	48 c1 e0 06          	shl    $0x6,%rax
  8004208e7d:	48 89 c2             	mov    %rax,%rdx
  8004208e80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208e84:	48 01 d0             	add    %rdx,%rax
  8004208e87:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for(;sh < esh; sh++) {
  8004208e8b:	e9 27 01 00 00       	jmpq   8004208fb7 <load_icode+0x36d>
			char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  8004208e90:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004208e94:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004208e98:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208e9c:	8b 00                	mov    (%rax),%eax
  8004208e9e:	89 c0                	mov    %eax,%eax
  8004208ea0:	48 01 c2             	add    %rax,%rdx
  8004208ea3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208ea7:	48 01 d0             	add    %rdx,%rax
  8004208eaa:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
			if(!strcmp(name, ".debug_info") || !strcmp(name, ".debug_abbrev")
  8004208eae:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004208eb2:	48 be 00 04 22 04 80 	movabs $0x8004220400,%rsi
  8004208eb9:	00 00 00 
  8004208ebc:	48 89 c7             	mov    %rax,%rdi
  8004208ebf:	48 b8 81 10 21 04 80 	movabs $0x8004211081,%rax
  8004208ec6:	00 00 00 
  8004208ec9:	ff d0                	callq  *%rax
  8004208ecb:	85 c0                	test   %eax,%eax
  8004208ecd:	0f 84 84 00 00 00    	je     8004208f57 <load_icode+0x30d>
  8004208ed3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004208ed7:	48 be 0c 04 22 04 80 	movabs $0x800422040c,%rsi
  8004208ede:	00 00 00 
  8004208ee1:	48 89 c7             	mov    %rax,%rdi
  8004208ee4:	48 b8 81 10 21 04 80 	movabs $0x8004211081,%rax
  8004208eeb:	00 00 00 
  8004208eee:	ff d0                	callq  *%rax
  8004208ef0:	85 c0                	test   %eax,%eax
  8004208ef2:	74 63                	je     8004208f57 <load_icode+0x30d>
			   || !strcmp(name, ".debug_line") || !strcmp(name, ".eh_frame")
  8004208ef4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004208ef8:	48 be 1a 04 22 04 80 	movabs $0x800422041a,%rsi
  8004208eff:	00 00 00 
  8004208f02:	48 89 c7             	mov    %rax,%rdi
  8004208f05:	48 b8 81 10 21 04 80 	movabs $0x8004211081,%rax
  8004208f0c:	00 00 00 
  8004208f0f:	ff d0                	callq  *%rax
  8004208f11:	85 c0                	test   %eax,%eax
  8004208f13:	74 42                	je     8004208f57 <load_icode+0x30d>
  8004208f15:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004208f19:	48 be 26 04 22 04 80 	movabs $0x8004220426,%rsi
  8004208f20:	00 00 00 
  8004208f23:	48 89 c7             	mov    %rax,%rdi
  8004208f26:	48 b8 81 10 21 04 80 	movabs $0x8004211081,%rax
  8004208f2d:	00 00 00 
  8004208f30:	ff d0                	callq  *%rax
  8004208f32:	85 c0                	test   %eax,%eax
  8004208f34:	74 21                	je     8004208f57 <load_icode+0x30d>
			   || !strcmp(name, ".debug_str")) {
  8004208f36:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004208f3a:	48 be 30 04 22 04 80 	movabs $0x8004220430,%rsi
  8004208f41:	00 00 00 
  8004208f44:	48 89 c7             	mov    %rax,%rdi
  8004208f47:	48 b8 81 10 21 04 80 	movabs $0x8004211081,%rax
  8004208f4e:	00 00 00 
  8004208f51:	ff d0                	callq  *%rax
  8004208f53:	85 c0                	test   %eax,%eax
  8004208f55:	75 5b                	jne    8004208fb2 <load_icode+0x368>
				region_alloc(e ,(void*)debug_address, sh->sh_size);
  8004208f57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208f5b:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004208f5f:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8004208f63:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208f67:	48 89 ce             	mov    %rcx,%rsi
  8004208f6a:	48 89 c7             	mov    %rax,%rdi
  8004208f6d:	48 b8 49 8b 20 04 80 	movabs $0x8004208b49,%rax
  8004208f74:	00 00 00 
  8004208f77:	ff d0                	callq  *%rax
				memcpy((void *)debug_address, (void *)((uint8_t *)elf + sh->sh_offset), 
  8004208f79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208f7d:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004208f81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208f85:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004208f89:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208f8d:	48 01 c1             	add    %rax,%rcx
  8004208f90:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208f94:	48 89 ce             	mov    %rcx,%rsi
  8004208f97:	48 89 c7             	mov    %rax,%rdi
  8004208f9a:	48 b8 5b 13 21 04 80 	movabs $0x800421135b,%rax
  8004208fa1:	00 00 00 
  8004208fa4:	ff d0                	callq  *%rax
				       sh->sh_size);
				debug_address += sh->sh_size;
  8004208fa6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208faa:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004208fae:	48 01 45 f0          	add    %rax,-0x10(%rbp)

		uintptr_t debug_address = USTABDATA;
		struct Secthdr *sh = (struct Secthdr *)(((uint8_t *)elf + elf->e_shoff));
		struct Secthdr *shstr_tab = sh + elf->e_shstrndx;
		struct Secthdr* esh = sh + elf->e_shnum;
		for(;sh < esh; sh++) {
  8004208fb2:	48 83 45 e8 40       	addq   $0x40,-0x18(%rbp)
  8004208fb7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208fbb:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004208fbf:	0f 82 cb fe ff ff    	jb     8004208e90 <load_icode+0x246>
				memcpy((void *)debug_address, (void *)((uint8_t *)elf + sh->sh_offset), 
				       sh->sh_size);
				debug_address += sh->sh_size;
			}
		}
		lcr3(boot_cr3);
  8004208fc5:	48 b8 e8 f5 6d 04 80 	movabs $0x80046df5e8,%rax
  8004208fcc:	00 00 00 
  8004208fcf:	48 8b 00             	mov    (%rax),%rax
  8004208fd2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004208fd6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208fda:	0f 22 d8             	mov    %rax,%cr3
{

	struct Elf *elf = (struct Elf *)binary;
	struct Proghdr *ph, *eph;

	if (elf && elf->e_magic == ELF_MAGIC) {
  8004208fdd:	eb 2a                	jmp    8004209009 <load_icode+0x3bf>
				debug_address += sh->sh_size;
			}
		}
		lcr3(boot_cr3);
	} else {
		panic("Invalid Binary");
  8004208fdf:	48 ba 3b 04 22 04 80 	movabs $0x800422043b,%rdx
  8004208fe6:	00 00 00 
  8004208fe9:	be 11 02 00 00       	mov    $0x211,%esi
  8004208fee:	48 bf 84 03 22 04 80 	movabs $0x8004220384,%rdi
  8004208ff5:	00 00 00 
  8004208ff8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208ffd:	48 b9 d3 04 20 04 80 	movabs $0x80042004d3,%rcx
  8004209004:	00 00 00 
  8004209007:	ff d1                	callq  *%rcx
	}
	// Give environment a stack

	e->elf = binary;
  8004209009:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420900d:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004209011:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)

}
  8004209018:	90                   	nop
  8004209019:	c9                   	leaveq 
  800420901a:	c3                   	retq   

000000800420901b <env_create>:
// before running the first user-mode environment.
// The new env's parent ID is set to 0.
//
void
env_create(uint8_t *binary, enum EnvType type)
{
  800420901b:	55                   	push   %rbp
  800420901c:	48 89 e5             	mov    %rsp,%rbp
  800420901f:	48 83 ec 20          	sub    $0x20,%rsp
  8004209023:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004209027:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// LAB 3: Your code here.

	int r;
	struct Env *e;
	if ((r = env_alloc(&e, 0)) < 0)
  800420902a:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  800420902e:	be 00 00 00 00       	mov    $0x0,%esi
  8004209033:	48 89 c7             	mov    %rax,%rdi
  8004209036:	48 b8 ad 89 20 04 80 	movabs $0x80042089ad,%rax
  800420903d:	00 00 00 
  8004209040:	ff d0                	callq  *%rax
  8004209042:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004209045:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004209049:	79 30                	jns    800420907b <env_create+0x60>
		panic("env_create: could not allocate env: %e\n", r);
  800420904b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420904e:	89 c1                	mov    %eax,%ecx
  8004209050:	48 ba 50 04 22 04 80 	movabs $0x8004220450,%rdx
  8004209057:	00 00 00 
  800420905a:	be 28 02 00 00       	mov    $0x228,%esi
  800420905f:	48 bf 84 03 22 04 80 	movabs $0x8004220384,%rdi
  8004209066:	00 00 00 
  8004209069:	b8 00 00 00 00       	mov    $0x0,%eax
  800420906e:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004209075:	00 00 00 
  8004209078:	41 ff d0             	callq  *%r8
	load_icode(e, binary);
  800420907b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420907f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004209083:	48 89 d6             	mov    %rdx,%rsi
  8004209086:	48 89 c7             	mov    %rax,%rdi
  8004209089:	48 b8 4a 8c 20 04 80 	movabs $0x8004208c4a,%rax
  8004209090:	00 00 00 
  8004209093:	ff d0                	callq  *%rax
	e->env_type = type;
  8004209095:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004209099:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800420909c:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)


	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
	// LAB 5: Your code here.

	if (type == ENV_TYPE_FS)
  80042090a2:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  80042090a6:	75 19                	jne    80042090c1 <env_create+0xa6>
		e->env_tf.tf_eflags |= FL_IOPL_3;
  80042090a8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042090ac:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042090b0:	48 8b 92 a8 00 00 00 	mov    0xa8(%rdx),%rdx
  80042090b7:	80 ce 30             	or     $0x30,%dh
  80042090ba:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)

}
  80042090c1:	90                   	nop
  80042090c2:	c9                   	leaveq 
  80042090c3:	c3                   	retq   

00000080042090c4 <env_free>:
//
// Frees env e and all memory it uses.
//
void
env_free(struct Env *e)
{
  80042090c4:	55                   	push   %rbp
  80042090c5:	48 89 e5             	mov    %rsp,%rbp
  80042090c8:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  80042090cf:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
	uint64_t pdeno, pteno;
	physaddr_t pa;


#ifndef VMM_GUEST 
	if(e->env_type == ENV_TYPE_GUEST) {
  80042090d6:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042090dd:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80042090e3:	83 f8 03             	cmp    $0x3,%eax
  80042090e6:	75 1b                	jne    8004209103 <env_free+0x3f>
		env_guest_free(e);
  80042090e8:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042090ef:	48 89 c7             	mov    %rax,%rdi
  80042090f2:	48 b8 65 86 20 04 80 	movabs $0x8004208665,%rax
  80042090f9:	00 00 00 
  80042090fc:	ff d0                	callq  *%rax
		return;
  80042090fe:	e9 7c 04 00 00       	jmpq   800420957f <env_free+0x4bb>


	// If freeing the current environment, switch to kern_pgdir
	// before freeing the page directory, just in case the page
	// gets reused.
	if (e == curenv)
  8004209103:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420910a:	00 00 00 
  800420910d:	ff d0                	callq  *%rax
  800420910f:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  8004209116:	00 00 00 
  8004209119:	48 98                	cltq   
  800420911b:	48 c1 e0 03          	shl    $0x3,%rax
  800420911f:	48 89 c1             	mov    %rax,%rcx
  8004209122:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209126:	48 01 c8             	add    %rcx,%rax
  8004209129:	48 01 d0             	add    %rdx,%rax
  800420912c:	48 83 c0 08          	add    $0x8,%rax
  8004209130:	48 8b 00             	mov    (%rax),%rax
  8004209133:	48 3b 85 78 ff ff ff 	cmp    -0x88(%rbp),%rax
  800420913a:	75 18                	jne    8004209154 <env_free+0x90>
		lcr3(boot_cr3);
  800420913c:	48 b8 e8 f5 6d 04 80 	movabs $0x80046df5e8,%rax
  8004209143:	00 00 00 
  8004209146:	48 8b 00             	mov    (%rax),%rax
  8004209149:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  800420914d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004209151:	0f 22 d8             	mov    %rax,%cr3

	// cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);


	// Flush all mapped pages in the user portion of the address space
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
  8004209154:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420915b:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004209162:	48 8b 00             	mov    (%rax),%rax
  8004209165:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420916b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420916f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004209173:	48 c1 e8 0c          	shr    $0xc,%rax
  8004209177:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420917a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420917d:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004209184:	00 00 00 
  8004209187:	48 8b 00             	mov    (%rax),%rax
  800420918a:	48 39 c2             	cmp    %rax,%rdx
  800420918d:	72 32                	jb     80042091c1 <env_free+0xfd>
  800420918f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004209193:	48 89 c1             	mov    %rax,%rcx
  8004209196:	48 ba 20 03 22 04 80 	movabs $0x8004220320,%rdx
  800420919d:	00 00 00 
  80042091a0:	be 54 02 00 00       	mov    $0x254,%esi
  80042091a5:	48 bf 84 03 22 04 80 	movabs $0x8004220384,%rdi
  80042091ac:	00 00 00 
  80042091af:	b8 00 00 00 00       	mov    $0x0,%eax
  80042091b4:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042091bb:	00 00 00 
  80042091be:	41 ff d0             	callq  *%r8
  80042091c1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042091c8:	00 00 00 
  80042091cb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042091cf:	48 01 d0             	add    %rdx,%rax
  80042091d2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  80042091d6:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042091dd:	00 
  80042091de:	e9 af 02 00 00       	jmpq   8004209492 <env_free+0x3ce>
		if(!(env_pdpe[pdpe_index] & PTE_P))
  80042091e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042091e7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042091ee:	00 
  80042091ef:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042091f3:	48 01 d0             	add    %rdx,%rax
  80042091f6:	48 8b 00             	mov    (%rax),%rax
  80042091f9:	83 e0 01             	and    $0x1,%eax
  80042091fc:	48 85 c0             	test   %rax,%rax
  80042091ff:	0f 84 87 02 00 00    	je     800420948c <env_free+0x3c8>
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
  8004209205:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209209:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209210:	00 
  8004209211:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004209215:	48 01 d0             	add    %rdx,%rax
  8004209218:	48 8b 00             	mov    (%rax),%rax
  800420921b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004209221:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004209225:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004209229:	48 c1 e8 0c          	shr    $0xc,%rax
  800420922d:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004209230:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004209233:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  800420923a:	00 00 00 
  800420923d:	48 8b 00             	mov    (%rax),%rax
  8004209240:	48 39 c2             	cmp    %rax,%rdx
  8004209243:	72 32                	jb     8004209277 <env_free+0x1b3>
  8004209245:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004209249:	48 89 c1             	mov    %rax,%rcx
  800420924c:	48 ba 20 03 22 04 80 	movabs $0x8004220320,%rdx
  8004209253:	00 00 00 
  8004209256:	be 5c 02 00 00       	mov    $0x25c,%esi
  800420925b:	48 bf 84 03 22 04 80 	movabs $0x8004220384,%rdi
  8004209262:	00 00 00 
  8004209265:	b8 00 00 00 00       	mov    $0x0,%eax
  800420926a:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004209271:	00 00 00 
  8004209274:	41 ff d0             	callq  *%r8
  8004209277:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420927e:	00 00 00 
  8004209281:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004209285:	48 01 d0             	add    %rdx,%rax
  8004209288:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
  800420928c:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004209291:	75 07                	jne    800420929a <env_free+0x1d6>
  8004209293:	b8 04 00 00 00       	mov    $0x4,%eax
  8004209298:	eb 05                	jmp    800420929f <env_free+0x1db>
  800420929a:	b8 ff 01 00 00       	mov    $0x1ff,%eax
  800420929f:	89 45 b4             	mov    %eax,-0x4c(%rbp)
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  80042092a2:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042092a9:	00 
  80042092aa:	e9 70 01 00 00       	jmpq   800420941f <env_free+0x35b>

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
  80042092af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042092b3:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042092ba:	00 
  80042092bb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042092bf:	48 01 d0             	add    %rdx,%rax
  80042092c2:	48 8b 00             	mov    (%rax),%rax
  80042092c5:	83 e0 01             	and    $0x1,%eax
  80042092c8:	48 85 c0             	test   %rax,%rax
  80042092cb:	0f 84 48 01 00 00    	je     8004209419 <env_free+0x355>
				continue;
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
  80042092d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042092d5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042092dc:	00 
  80042092dd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042092e1:	48 01 d0             	add    %rdx,%rax
  80042092e4:	48 8b 00             	mov    (%rax),%rax
  80042092e7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042092ed:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			pt = (pte_t*) KADDR(pa);
  80042092f1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042092f5:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  80042092f9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042092fd:	48 c1 e8 0c          	shr    $0xc,%rax
  8004209301:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004209304:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004209307:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  800420930e:	00 00 00 
  8004209311:	48 8b 00             	mov    (%rax),%rax
  8004209314:	48 39 c2             	cmp    %rax,%rdx
  8004209317:	72 32                	jb     800420934b <env_free+0x287>
  8004209319:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420931d:	48 89 c1             	mov    %rax,%rcx
  8004209320:	48 ba 20 03 22 04 80 	movabs $0x8004220320,%rdx
  8004209327:	00 00 00 
  800420932a:	be 66 02 00 00       	mov    $0x266,%esi
  800420932f:	48 bf 84 03 22 04 80 	movabs $0x8004220384,%rdi
  8004209336:	00 00 00 
  8004209339:	b8 00 00 00 00       	mov    $0x0,%eax
  800420933e:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004209345:	00 00 00 
  8004209348:	41 ff d0             	callq  *%r8
  800420934b:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004209352:	00 00 00 
  8004209355:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004209359:	48 01 d0             	add    %rdx,%rax
  800420935c:	48 89 45 90          	mov    %rax,-0x70(%rbp)

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004209360:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004209367:	00 
  8004209368:	eb 67                	jmp    80042093d1 <env_free+0x30d>
				if (pt[pteno] & PTE_P){
  800420936a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420936e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209375:	00 
  8004209376:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420937a:	48 01 d0             	add    %rdx,%rax
  800420937d:	48 8b 00             	mov    (%rax),%rax
  8004209380:	83 e0 01             	and    $0x1,%eax
  8004209383:	48 85 c0             	test   %rax,%rax
  8004209386:	74 44                	je     80042093cc <env_free+0x308>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
  8004209388:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420938c:	48 c1 e0 1e          	shl    $0x1e,%rax
  8004209390:	48 89 c2             	mov    %rax,%rdx
  8004209393:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209397:	48 c1 e0 15          	shl    $0x15,%rax
  800420939b:	48 09 c2             	or     %rax,%rdx
  800420939e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042093a2:	48 c1 e0 0c          	shl    $0xc,%rax
  80042093a6:	48 09 d0             	or     %rdx,%rax
  80042093a9:	48 89 c2             	mov    %rax,%rdx
  80042093ac:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042093b3:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042093ba:	48 89 d6             	mov    %rdx,%rsi
  80042093bd:	48 89 c7             	mov    %rax,%rdi
  80042093c0:	48 b8 32 3e 20 04 80 	movabs $0x8004203e32,%rax
  80042093c7:	00 00 00 
  80042093ca:	ff d0                	callq  *%rax
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
			pt = (pte_t*) KADDR(pa);

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  80042093cc:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  80042093d1:	48 81 7d f0 fe 01 00 	cmpq   $0x1fe,-0x10(%rbp)
  80042093d8:	00 
  80042093d9:	76 8f                	jbe    800420936a <env_free+0x2a6>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
				}
			}

			// free the page table itself
			env_pgdir[pdeno] = 0;
  80042093db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042093df:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042093e6:	00 
  80042093e7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042093eb:	48 01 d0             	add    %rdx,%rax
  80042093ee:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(pa2page(pa));
  80042093f5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042093f9:	48 89 c7             	mov    %rax,%rdi
  80042093fc:	48 b8 1c 7d 20 04 80 	movabs $0x8004207d1c,%rax
  8004209403:	00 00 00 
  8004209406:	ff d0                	callq  *%rax
  8004209408:	48 89 c7             	mov    %rax,%rdi
  800420940b:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  8004209412:	00 00 00 
  8004209415:	ff d0                	callq  *%rax
  8004209417:	eb 01                	jmp    800420941a <env_free+0x356>
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
				continue;
  8004209419:	90                   	nop
		if(!(env_pdpe[pdpe_index] & PTE_P))
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  800420941a:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420941f:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004209422:	48 98                	cltq   
  8004209424:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004209428:	0f 87 81 fe ff ff    	ja     80042092af <env_free+0x1eb>
			// free the page table itself
			env_pgdir[pdeno] = 0;
			page_decref(pa2page(pa));
		}
		// free the page directory
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
  800420942e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209432:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209439:	00 
  800420943a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420943e:	48 01 d0             	add    %rdx,%rax
  8004209441:	48 8b 00             	mov    (%rax),%rax
  8004209444:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420944a:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
		env_pdpe[pdpe_index] = 0;
  800420944e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209452:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004209459:	00 
  800420945a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420945e:	48 01 d0             	add    %rdx,%rax
  8004209461:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		page_decref(pa2page(pa));
  8004209468:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420946c:	48 89 c7             	mov    %rax,%rdi
  800420946f:	48 b8 1c 7d 20 04 80 	movabs $0x8004207d1c,%rax
  8004209476:	00 00 00 
  8004209479:	ff d0                	callq  *%rax
  800420947b:	48 89 c7             	mov    %rax,%rdi
  800420947e:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  8004209485:	00 00 00 
  8004209488:	ff d0                	callq  *%rax
  800420948a:	eb 01                	jmp    800420948d <env_free+0x3c9>
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
		if(!(env_pdpe[pdpe_index] & PTE_P))
			continue;
  800420948c:	90                   	nop
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  800420948d:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004209492:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004209497:	0f 86 46 fd ff ff    	jbe    80042091e3 <env_free+0x11f>
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
		env_pdpe[pdpe_index] = 0;
		page_decref(pa2page(pa));
	}
	// free the page directory pointer
	page_decref(pa2page(PTE_ADDR(e->env_pml4e[0])));
  800420949d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042094a4:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042094ab:	48 8b 00             	mov    (%rax),%rax
  80042094ae:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042094b4:	48 89 c7             	mov    %rax,%rdi
  80042094b7:	48 b8 1c 7d 20 04 80 	movabs $0x8004207d1c,%rax
  80042094be:	00 00 00 
  80042094c1:	ff d0                	callq  *%rax
  80042094c3:	48 89 c7             	mov    %rax,%rdi
  80042094c6:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  80042094cd:	00 00 00 
  80042094d0:	ff d0                	callq  *%rax
	// free the page map level 4 (PML4)
	e->env_pml4e[0] = 0;
  80042094d2:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042094d9:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042094e0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	pa = e->env_cr3;
  80042094e7:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042094ee:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042094f5:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	e->env_pml4e = 0;
  80042094f9:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004209500:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  8004209507:	00 00 00 00 
	e->env_cr3 = 0;
  800420950b:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004209512:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8004209519:	00 00 00 00 
	page_decref(pa2page(pa));
  800420951d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004209521:	48 89 c7             	mov    %rax,%rdi
  8004209524:	48 b8 1c 7d 20 04 80 	movabs $0x8004207d1c,%rax
  800420952b:	00 00 00 
  800420952e:	ff d0                	callq  *%rax
  8004209530:	48 89 c7             	mov    %rax,%rdi
  8004209533:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  800420953a:	00 00 00 
  800420953d:	ff d0                	callq  *%rax

	// return the environment to the free list
	e->env_status = ENV_FREE;
  800420953f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004209546:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  800420954d:	00 00 00 
	e->env_link = env_free_list;
  8004209550:	48 b8 60 02 4e 04 80 	movabs $0x80044e0260,%rax
  8004209557:	00 00 00 
  800420955a:	48 8b 10             	mov    (%rax),%rdx
  800420955d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004209564:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  800420956b:	48 b8 60 02 4e 04 80 	movabs $0x80044e0260,%rax
  8004209572:	00 00 00 
  8004209575:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  800420957c:	48 89 10             	mov    %rdx,(%rax)
}
  800420957f:	c9                   	leaveq 
  8004209580:	c3                   	retq   

0000008004209581 <env_destroy>:
// to the caller).

//
void
env_destroy(struct Env *e)
{
  8004209581:	55                   	push   %rbp
  8004209582:	48 89 e5             	mov    %rsp,%rbp
  8004209585:	48 83 ec 10          	sub    $0x10,%rsp
  8004209589:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

	// If e is currently running on other CPUs, we change its state to
	// ENV_DYING. A zombie environment will be freed the next time
	// it traps to the kernel.
	if (e->env_status == ENV_RUNNING && curenv != e) {
  800420958d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209591:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004209597:	83 f8 03             	cmp    $0x3,%eax
  800420959a:	75 49                	jne    80042095e5 <env_destroy+0x64>
  800420959c:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  80042095a3:	00 00 00 
  80042095a6:	ff d0                	callq  *%rax
  80042095a8:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  80042095af:	00 00 00 
  80042095b2:	48 98                	cltq   
  80042095b4:	48 c1 e0 03          	shl    $0x3,%rax
  80042095b8:	48 89 c1             	mov    %rax,%rcx
  80042095bb:	48 c1 e1 04          	shl    $0x4,%rcx
  80042095bf:	48 01 c8             	add    %rcx,%rax
  80042095c2:	48 01 d0             	add    %rdx,%rax
  80042095c5:	48 83 c0 08          	add    $0x8,%rax
  80042095c9:	48 8b 00             	mov    (%rax),%rax
  80042095cc:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042095d0:	74 13                	je     80042095e5 <env_destroy+0x64>
		e->env_status = ENV_DYING;
  80042095d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042095d6:	c7 80 d4 00 00 00 01 	movl   $0x1,0xd4(%rax)
  80042095dd:	00 00 00 
		return;
  80042095e0:	e9 89 00 00 00       	jmpq   800420966e <env_destroy+0xed>
	}

	env_free(e);
  80042095e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042095e9:	48 89 c7             	mov    %rax,%rdi
  80042095ec:	48 b8 c4 90 20 04 80 	movabs $0x80042090c4,%rax
  80042095f3:	00 00 00 
  80042095f6:	ff d0                	callq  *%rax
	if (curenv == e) {
  80042095f8:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  80042095ff:	00 00 00 
  8004209602:	ff d0                	callq  *%rax
  8004209604:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420960b:	00 00 00 
  800420960e:	48 98                	cltq   
  8004209610:	48 c1 e0 03          	shl    $0x3,%rax
  8004209614:	48 89 c1             	mov    %rax,%rcx
  8004209617:	48 c1 e1 04          	shl    $0x4,%rcx
  800420961b:	48 01 c8             	add    %rcx,%rax
  800420961e:	48 01 d0             	add    %rdx,%rax
  8004209621:	48 83 c0 08          	add    $0x8,%rax
  8004209625:	48 8b 00             	mov    (%rax),%rax
  8004209628:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420962c:	75 40                	jne    800420966e <env_destroy+0xed>
		curenv = NULL;
  800420962e:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  8004209635:	00 00 00 
  8004209638:	ff d0                	callq  *%rax
  800420963a:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  8004209641:	00 00 00 
  8004209644:	48 98                	cltq   
  8004209646:	48 c1 e0 03          	shl    $0x3,%rax
  800420964a:	48 89 c1             	mov    %rax,%rcx
  800420964d:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209651:	48 01 c8             	add    %rcx,%rax
  8004209654:	48 01 d0             	add    %rdx,%rax
  8004209657:	48 83 c0 08          	add    $0x8,%rax
  800420965b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		sched_yield();
  8004209662:	48 b8 a6 da 20 04 80 	movabs $0x800420daa6,%rax
  8004209669:	00 00 00 
  800420966c:	ff d0                	callq  *%rax
	}

}
  800420966e:	c9                   	leaveq 
  800420966f:	c3                   	retq   

0000008004209670 <env_pop_tf>:
//
// This function does not return.
//
void
env_pop_tf(struct Trapframe *tf)
{
  8004209670:	55                   	push   %rbp
  8004209671:	48 89 e5             	mov    %rsp,%rbp
  8004209674:	53                   	push   %rbx
  8004209675:	48 83 ec 18          	sub    $0x18,%rsp
  8004209679:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	// Record the CPU we are running on for user-space debugging
	curenv->env_cpunum = cpunum();
  800420967d:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  8004209684:	00 00 00 
  8004209687:	ff d0                	callq  *%rax
  8004209689:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  8004209690:	00 00 00 
  8004209693:	48 98                	cltq   
  8004209695:	48 c1 e0 03          	shl    $0x3,%rax
  8004209699:	48 89 c1             	mov    %rax,%rcx
  800420969c:	48 c1 e1 04          	shl    $0x4,%rcx
  80042096a0:	48 01 c8             	add    %rcx,%rax
  80042096a3:	48 01 d0             	add    %rdx,%rax
  80042096a6:	48 83 c0 08          	add    $0x8,%rax
  80042096aa:	48 8b 18             	mov    (%rax),%rbx
  80042096ad:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  80042096b4:	00 00 00 
  80042096b7:	ff d0                	callq  *%rax
  80042096b9:	89 83 dc 00 00 00    	mov    %eax,0xdc(%rbx)

	__asm __volatile("movq %0,%%rsp\n"
  80042096bf:	48 8b 65 e8          	mov    -0x18(%rbp),%rsp
  80042096c3:	4c 8b 3c 24          	mov    (%rsp),%r15
  80042096c7:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  80042096cc:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  80042096d1:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  80042096d6:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  80042096db:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  80042096e0:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  80042096e5:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  80042096ea:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  80042096ef:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  80042096f4:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  80042096f9:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  80042096fe:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  8004209703:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  8004209708:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800420970d:	48 83 c4 78          	add    $0x78,%rsp
  8004209711:	8e 04 24             	mov    (%rsp),%es
  8004209714:	8e 5c 24 08          	mov    0x8(%rsp),%ds
  8004209718:	48 83 c4 10          	add    $0x10,%rsp
  800420971c:	48 83 c4 10          	add    $0x10,%rsp
  8004209720:	48 cf                	iretq  
			 "movw 8(%%rsp),%%ds\n"
			 "addq $16,%%rsp\n"
			 "\taddq $16,%%rsp\n" /* skip tf_trapno and tf_errcode */
			 "\tiretq"
			 : : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
  8004209722:	48 ba 78 04 22 04 80 	movabs $0x8004220478,%rdx
  8004209729:	00 00 00 
  800420972c:	be b8 02 00 00       	mov    $0x2b8,%esi
  8004209731:	48 bf 84 03 22 04 80 	movabs $0x8004220384,%rdi
  8004209738:	00 00 00 
  800420973b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209740:	48 b9 d3 04 20 04 80 	movabs $0x80042004d3,%rcx
  8004209747:	00 00 00 
  800420974a:	ff d1                	callq  *%rcx

000000800420974c <env_run>:
//
// This function does not return.
//
void
env_run(struct Env *e)
{
  800420974c:	55                   	push   %rbp
  800420974d:	48 89 e5             	mov    %rsp,%rbp
  8004209750:	48 83 ec 20          	sub    $0x20,%rsp
  8004209754:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	// Is this a context switch or just a return?
	if (curenv != e) {
  8004209758:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420975f:	00 00 00 
  8004209762:	ff d0                	callq  *%rax
  8004209764:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420976b:	00 00 00 
  800420976e:	48 98                	cltq   
  8004209770:	48 c1 e0 03          	shl    $0x3,%rax
  8004209774:	48 89 c1             	mov    %rax,%rcx
  8004209777:	48 c1 e1 04          	shl    $0x4,%rcx
  800420977b:	48 01 c8             	add    %rcx,%rax
  800420977e:	48 01 d0             	add    %rdx,%rax
  8004209781:	48 83 c0 08          	add    $0x8,%rax
  8004209785:	48 8b 00             	mov    (%rax),%rax
  8004209788:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800420978c:	0f 84 28 01 00 00    	je     80042098ba <env_run+0x16e>
		if (curenv && curenv->env_status == ENV_RUNNING)
  8004209792:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  8004209799:	00 00 00 
  800420979c:	ff d0                	callq  *%rax
  800420979e:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  80042097a5:	00 00 00 
  80042097a8:	48 98                	cltq   
  80042097aa:	48 c1 e0 03          	shl    $0x3,%rax
  80042097ae:	48 89 c1             	mov    %rax,%rcx
  80042097b1:	48 c1 e1 04          	shl    $0x4,%rcx
  80042097b5:	48 01 c8             	add    %rcx,%rax
  80042097b8:	48 01 d0             	add    %rdx,%rax
  80042097bb:	48 83 c0 08          	add    $0x8,%rax
  80042097bf:	48 8b 00             	mov    (%rax),%rax
  80042097c2:	48 85 c0             	test   %rax,%rax
  80042097c5:	74 75                	je     800420983c <env_run+0xf0>
  80042097c7:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  80042097ce:	00 00 00 
  80042097d1:	ff d0                	callq  *%rax
  80042097d3:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  80042097da:	00 00 00 
  80042097dd:	48 98                	cltq   
  80042097df:	48 c1 e0 03          	shl    $0x3,%rax
  80042097e3:	48 89 c1             	mov    %rax,%rcx
  80042097e6:	48 c1 e1 04          	shl    $0x4,%rcx
  80042097ea:	48 01 c8             	add    %rcx,%rax
  80042097ed:	48 01 d0             	add    %rdx,%rax
  80042097f0:	48 83 c0 08          	add    $0x8,%rax
  80042097f4:	48 8b 00             	mov    (%rax),%rax
  80042097f7:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042097fd:	83 f8 03             	cmp    $0x3,%eax
  8004209800:	75 3a                	jne    800420983c <env_run+0xf0>
			curenv->env_status = ENV_RUNNABLE;
  8004209802:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  8004209809:	00 00 00 
  800420980c:	ff d0                	callq  *%rax
  800420980e:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  8004209815:	00 00 00 
  8004209818:	48 98                	cltq   
  800420981a:	48 c1 e0 03          	shl    $0x3,%rax
  800420981e:	48 89 c1             	mov    %rax,%rcx
  8004209821:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209825:	48 01 c8             	add    %rcx,%rax
  8004209828:	48 01 d0             	add    %rdx,%rax
  800420982b:	48 83 c0 08          	add    $0x8,%rax
  800420982f:	48 8b 00             	mov    (%rax),%rax
  8004209832:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004209839:	00 00 00 
		//cprintf("cpu %d switch from env %d to env %d\n",
		//	cpunum(), curenv ? curenv - envs : -1, e - envs);

		// keep track of which environment we're currently
		// running
		curenv = e;
  800420983c:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  8004209843:	00 00 00 
  8004209846:	ff d0                	callq  *%rax
  8004209848:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420984f:	00 00 00 
  8004209852:	48 98                	cltq   
  8004209854:	48 c1 e0 03          	shl    $0x3,%rax
  8004209858:	48 89 c1             	mov    %rax,%rcx
  800420985b:	48 c1 e1 04          	shl    $0x4,%rcx
  800420985f:	48 01 c8             	add    %rcx,%rax
  8004209862:	48 01 d0             	add    %rdx,%rax
  8004209865:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004209869:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420986d:	48 89 02             	mov    %rax,(%rdx)
		e->env_status = ENV_RUNNING;
  8004209870:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209874:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  800420987b:	00 00 00 
		e->env_runs++;
  800420987e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209882:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  8004209888:	8d 50 01             	lea    0x1(%rax),%edx
  800420988b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420988f:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)

		// restore e's address space

		if(e->env_type != ENV_TYPE_GUEST)
  8004209895:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209899:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800420989f:	83 f8 03             	cmp    $0x3,%eax
  80042098a2:	74 16                	je     80042098ba <env_run+0x16e>
			lcr3(e->env_cr3);
  80042098a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042098a8:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042098af:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042098b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042098b7:	0f 22 d8             	mov    %rax,%cr3

	}

	assert(e->env_status == ENV_RUNNING);
  80042098ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042098be:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042098c4:	83 f8 03             	cmp    $0x3,%eax
  80042098c7:	74 35                	je     80042098fe <env_run+0x1b2>
  80042098c9:	48 b9 84 04 22 04 80 	movabs $0x8004220484,%rcx
  80042098d0:	00 00 00 
  80042098d3:	48 ba a1 04 22 04 80 	movabs $0x80042204a1,%rdx
  80042098da:	00 00 00 
  80042098dd:	be da 02 00 00       	mov    $0x2da,%esi
  80042098e2:	48 bf 84 03 22 04 80 	movabs $0x8004220384,%rdi
  80042098e9:	00 00 00 
  80042098ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042098f1:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042098f8:	00 00 00 
  80042098fb:	41 ff d0             	callq  *%r8
    
	if(e->env_type == ENV_TYPE_GUEST) {
  80042098fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209902:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  8004209908:	83 f8 03             	cmp    $0x3,%eax
  800420990b:	75 3d                	jne    800420994a <env_run+0x1fe>
		vmx_vmrun(e);
  800420990d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209911:	48 89 c7             	mov    %rax,%rdi
  8004209914:	48 b8 8d de 21 04 80 	movabs $0x800421de8d,%rax
  800420991b:	00 00 00 
  800420991e:	ff d0                	callq  *%rax
		panic ("vmx_run never returns\n");
  8004209920:	48 ba b6 04 22 04 80 	movabs $0x80042204b6,%rdx
  8004209927:	00 00 00 
  800420992a:	be de 02 00 00       	mov    $0x2de,%esi
  800420992f:	48 bf 84 03 22 04 80 	movabs $0x8004220384,%rdi
  8004209936:	00 00 00 
  8004209939:	b8 00 00 00 00       	mov    $0x0,%eax
  800420993e:	48 b9 d3 04 20 04 80 	movabs $0x80042004d3,%rcx
  8004209945:	00 00 00 
  8004209948:	ff d1                	callq  *%rcx
	}
	else {
		unlock_kernel();
  800420994a:	48 b8 15 7e 20 04 80 	movabs $0x8004207e15,%rax
  8004209951:	00 00 00 
  8004209954:	ff d0                	callq  *%rax
		env_pop_tf(&e->env_tf);
  8004209956:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420995a:	48 89 c7             	mov    %rax,%rdi
  800420995d:	48 b8 70 96 20 04 80 	movabs $0x8004209670,%rax
  8004209964:	00 00 00 
  8004209967:	ff d0                	callq  *%rax

0000008004209969 <mc146818_read>:
#include <kern/kclock.h>


unsigned
mc146818_read(unsigned reg)
{
  8004209969:	55                   	push   %rbp
  800420996a:	48 89 e5             	mov    %rsp,%rbp
  800420996d:	48 83 ec 18          	sub    $0x18,%rsp
  8004209971:	89 7d ec             	mov    %edi,-0x14(%rbp)
	outb(IO_RTC, reg);
  8004209974:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209977:	0f b6 c0             	movzbl %al,%eax
  800420997a:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  8004209981:	88 45 f6             	mov    %al,-0xa(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004209984:	0f b6 45 f6          	movzbl -0xa(%rbp),%eax
  8004209988:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420998b:	ee                   	out    %al,(%dx)
  800420998c:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004209993:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209996:	89 c2                	mov    %eax,%edx
  8004209998:	ec                   	in     (%dx),%al
  8004209999:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  800420999c:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
	return inb(IO_RTC+1);
  80042099a0:	0f b6 c0             	movzbl %al,%eax
}
  80042099a3:	c9                   	leaveq 
  80042099a4:	c3                   	retq   

00000080042099a5 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
  80042099a5:	55                   	push   %rbp
  80042099a6:	48 89 e5             	mov    %rsp,%rbp
  80042099a9:	48 83 ec 18          	sub    $0x18,%rsp
  80042099ad:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042099b0:	89 75 e8             	mov    %esi,-0x18(%rbp)
	outb(IO_RTC, reg);
  80042099b3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042099b6:	0f b6 c0             	movzbl %al,%eax
  80042099b9:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  80042099c0:	88 45 f6             	mov    %al,-0xa(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042099c3:	0f b6 45 f6          	movzbl -0xa(%rbp),%eax
  80042099c7:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042099ca:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
  80042099cb:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042099ce:	0f b6 c0             	movzbl %al,%eax
  80042099d1:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%rbp)
  80042099d8:	88 45 f7             	mov    %al,-0x9(%rbp)
  80042099db:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  80042099df:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80042099e2:	ee                   	out    %al,(%dx)
}
  80042099e3:	90                   	nop
  80042099e4:	c9                   	leaveq 
  80042099e5:	c3                   	retq   

00000080042099e6 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
  80042099e6:	55                   	push   %rbp
  80042099e7:	48 89 e5             	mov    %rsp,%rbp
  80042099ea:	48 83 ec 50          	sub    $0x50,%rsp
	didinit = 1;
  80042099ee:	48 b8 68 02 4e 04 80 	movabs $0x80044e0268,%rax
  80042099f5:	00 00 00 
  80042099f8:	c6 00 01             	movb   $0x1,(%rax)
  80042099fb:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%rbp)
  8004209a02:	c6 45 ba ff          	movb   $0xff,-0x46(%rbp)
  8004209a06:	0f b6 45 ba          	movzbl -0x46(%rbp),%eax
  8004209a0a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209a0d:	ee                   	out    %al,(%dx)
  8004209a0e:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%rbp)
  8004209a15:	c6 45 bb ff          	movb   $0xff,-0x45(%rbp)
  8004209a19:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004209a1d:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004209a20:	ee                   	out    %al,(%dx)
  8004209a21:	c7 45 f4 20 00 00 00 	movl   $0x20,-0xc(%rbp)
  8004209a28:	c6 45 bc 11          	movb   $0x11,-0x44(%rbp)
  8004209a2c:	0f b6 45 bc          	movzbl -0x44(%rbp),%eax
  8004209a30:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004209a33:	ee                   	out    %al,(%dx)
  8004209a34:	c7 45 f0 21 00 00 00 	movl   $0x21,-0x10(%rbp)
  8004209a3b:	c6 45 bd 20          	movb   $0x20,-0x43(%rbp)
  8004209a3f:	0f b6 45 bd          	movzbl -0x43(%rbp),%eax
  8004209a43:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004209a46:	ee                   	out    %al,(%dx)
  8004209a47:	c7 45 ec 21 00 00 00 	movl   $0x21,-0x14(%rbp)
  8004209a4e:	c6 45 be 04          	movb   $0x4,-0x42(%rbp)
  8004209a52:	0f b6 45 be          	movzbl -0x42(%rbp),%eax
  8004209a56:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004209a59:	ee                   	out    %al,(%dx)
  8004209a5a:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%rbp)
  8004209a61:	c6 45 bf 03          	movb   $0x3,-0x41(%rbp)
  8004209a65:	0f b6 45 bf          	movzbl -0x41(%rbp),%eax
  8004209a69:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004209a6c:	ee                   	out    %al,(%dx)
  8004209a6d:	c7 45 e4 a0 00 00 00 	movl   $0xa0,-0x1c(%rbp)
  8004209a74:	c6 45 c0 11          	movb   $0x11,-0x40(%rbp)
  8004209a78:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
  8004209a7c:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004209a7f:	ee                   	out    %al,(%dx)
  8004209a80:	c7 45 e0 a1 00 00 00 	movl   $0xa1,-0x20(%rbp)
  8004209a87:	c6 45 c1 28          	movb   $0x28,-0x3f(%rbp)
  8004209a8b:	0f b6 45 c1          	movzbl -0x3f(%rbp),%eax
  8004209a8f:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004209a92:	ee                   	out    %al,(%dx)
  8004209a93:	c7 45 dc a1 00 00 00 	movl   $0xa1,-0x24(%rbp)
  8004209a9a:	c6 45 c2 02          	movb   $0x2,-0x3e(%rbp)
  8004209a9e:	0f b6 45 c2          	movzbl -0x3e(%rbp),%eax
  8004209aa2:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004209aa5:	ee                   	out    %al,(%dx)
  8004209aa6:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%rbp)
  8004209aad:	c6 45 c3 01          	movb   $0x1,-0x3d(%rbp)
  8004209ab1:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  8004209ab5:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8004209ab8:	ee                   	out    %al,(%dx)
  8004209ab9:	c7 45 d4 20 00 00 00 	movl   $0x20,-0x2c(%rbp)
  8004209ac0:	c6 45 c4 68          	movb   $0x68,-0x3c(%rbp)
  8004209ac4:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  8004209ac8:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004209acb:	ee                   	out    %al,(%dx)
  8004209acc:	c7 45 d0 20 00 00 00 	movl   $0x20,-0x30(%rbp)
  8004209ad3:	c6 45 c5 0a          	movb   $0xa,-0x3b(%rbp)
  8004209ad7:	0f b6 45 c5          	movzbl -0x3b(%rbp),%eax
  8004209adb:	8b 55 d0             	mov    -0x30(%rbp),%edx
  8004209ade:	ee                   	out    %al,(%dx)
  8004209adf:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%rbp)
  8004209ae6:	c6 45 c6 68          	movb   $0x68,-0x3a(%rbp)
  8004209aea:	0f b6 45 c6          	movzbl -0x3a(%rbp),%eax
  8004209aee:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004209af1:	ee                   	out    %al,(%dx)
  8004209af2:	c7 45 c8 a0 00 00 00 	movl   $0xa0,-0x38(%rbp)
  8004209af9:	c6 45 c7 0a          	movb   $0xa,-0x39(%rbp)
  8004209afd:	0f b6 45 c7          	movzbl -0x39(%rbp),%eax
  8004209b01:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004209b04:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);               /* OCW3 */
	outb(IO_PIC2, 0x0a);               /* OCW3 */

	if (irq_mask_8259A != 0xFFFF)
  8004209b05:	48 b8 72 66 23 04 80 	movabs $0x8004236672,%rax
  8004209b0c:	00 00 00 
  8004209b0f:	0f b7 00             	movzwl (%rax),%eax
  8004209b12:	66 83 f8 ff          	cmp    $0xffff,%ax
  8004209b16:	74 1e                	je     8004209b36 <pic_init+0x150>
		irq_setmask_8259A(irq_mask_8259A);
  8004209b18:	48 b8 72 66 23 04 80 	movabs $0x8004236672,%rax
  8004209b1f:	00 00 00 
  8004209b22:	0f b7 00             	movzwl (%rax),%eax
  8004209b25:	0f b7 c0             	movzwl %ax,%eax
  8004209b28:	89 c7                	mov    %eax,%edi
  8004209b2a:	48 b8 39 9b 20 04 80 	movabs $0x8004209b39,%rax
  8004209b31:	00 00 00 
  8004209b34:	ff d0                	callq  *%rax
}
  8004209b36:	90                   	nop
  8004209b37:	c9                   	leaveq 
  8004209b38:	c3                   	retq   

0000008004209b39 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16_t mask)
{
  8004209b39:	55                   	push   %rbp
  8004209b3a:	48 89 e5             	mov    %rsp,%rbp
  8004209b3d:	48 83 ec 20          	sub    $0x20,%rsp
  8004209b41:	89 f8                	mov    %edi,%eax
  8004209b43:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
	int i;
	irq_mask_8259A = mask;
  8004209b47:	48 b8 72 66 23 04 80 	movabs $0x8004236672,%rax
  8004209b4e:	00 00 00 
  8004209b51:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  8004209b55:	66 89 10             	mov    %dx,(%rax)
	if (!didinit)
  8004209b58:	48 b8 68 02 4e 04 80 	movabs $0x80044e0268,%rax
  8004209b5f:	00 00 00 
  8004209b62:	0f b6 00             	movzbl (%rax),%eax
  8004209b65:	83 f0 01             	xor    $0x1,%eax
  8004209b68:	84 c0                	test   %al,%al
  8004209b6a:	0f 85 b9 00 00 00    	jne    8004209c29 <irq_setmask_8259A+0xf0>
		return;
	outb(IO_PIC1+1, (char)mask);
  8004209b70:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  8004209b74:	0f b6 c0             	movzbl %al,%eax
  8004209b77:	c7 45 f8 21 00 00 00 	movl   $0x21,-0x8(%rbp)
  8004209b7e:	88 45 f2             	mov    %al,-0xe(%rbp)
  8004209b81:	0f b6 45 f2          	movzbl -0xe(%rbp),%eax
  8004209b85:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004209b88:	ee                   	out    %al,(%dx)
	outb(IO_PIC2+1, (char)(mask >> 8));
  8004209b89:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  8004209b8d:	66 c1 e8 08          	shr    $0x8,%ax
  8004209b91:	0f b6 c0             	movzbl %al,%eax
  8004209b94:	c7 45 f4 a1 00 00 00 	movl   $0xa1,-0xc(%rbp)
  8004209b9b:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004209b9e:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004209ba2:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004209ba5:	ee                   	out    %al,(%dx)
	cprintf("enabled interrupts:");
  8004209ba6:	48 bf cd 04 22 04 80 	movabs $0x80042204cd,%rdi
  8004209bad:	00 00 00 
  8004209bb0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209bb5:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004209bbc:	00 00 00 
  8004209bbf:	ff d2                	callq  *%rdx
	for (i = 0; i < 16; i++)
  8004209bc1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004209bc8:	eb 3c                	jmp    8004209c06 <irq_setmask_8259A+0xcd>
		if (~mask & (1<<i))
  8004209bca:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  8004209bce:	f7 d0                	not    %eax
  8004209bd0:	89 c2                	mov    %eax,%edx
  8004209bd2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209bd5:	89 c1                	mov    %eax,%ecx
  8004209bd7:	d3 fa                	sar    %cl,%edx
  8004209bd9:	89 d0                	mov    %edx,%eax
  8004209bdb:	83 e0 01             	and    $0x1,%eax
  8004209bde:	85 c0                	test   %eax,%eax
  8004209be0:	74 20                	je     8004209c02 <irq_setmask_8259A+0xc9>
			cprintf(" %d", i);
  8004209be2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209be5:	89 c6                	mov    %eax,%esi
  8004209be7:	48 bf e1 04 22 04 80 	movabs $0x80042204e1,%rdi
  8004209bee:	00 00 00 
  8004209bf1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209bf6:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004209bfd:	00 00 00 
  8004209c00:	ff d2                	callq  *%rdx
	if (!didinit)
		return;
	outb(IO_PIC1+1, (char)mask);
	outb(IO_PIC2+1, (char)(mask >> 8));
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
  8004209c02:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004209c06:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  8004209c0a:	7e be                	jle    8004209bca <irq_setmask_8259A+0x91>
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
  8004209c0c:	48 bf e5 04 22 04 80 	movabs $0x80042204e5,%rdi
  8004209c13:	00 00 00 
  8004209c16:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209c1b:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004209c22:	00 00 00 
  8004209c25:	ff d2                	callq  *%rdx
  8004209c27:	eb 01                	jmp    8004209c2a <irq_setmask_8259A+0xf1>
irq_setmask_8259A(uint16_t mask)
{
	int i;
	irq_mask_8259A = mask;
	if (!didinit)
		return;
  8004209c29:	90                   	nop
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
}
  8004209c2a:	c9                   	leaveq 
  8004209c2b:	c3                   	retq   

0000008004209c2c <irq_eoi>:


void
irq_eoi(void)
{
  8004209c2c:	55                   	push   %rbp
  8004209c2d:	48 89 e5             	mov    %rsp,%rbp
  8004209c30:	48 83 ec 10          	sub    $0x10,%rsp
  8004209c34:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%rbp)
  8004209c3b:	c6 45 f6 20          	movb   $0x20,-0xa(%rbp)
  8004209c3f:	0f b6 45 f6          	movzbl -0xa(%rbp),%eax
  8004209c43:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209c46:	ee                   	out    %al,(%dx)
  8004209c47:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%rbp)
  8004209c4e:	c6 45 f7 20          	movb   $0x20,-0x9(%rbp)
  8004209c52:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004209c56:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004209c59:	ee                   	out    %al,(%dx)
	//   s: specific
	//   e: end-of-interrupt
	// xxx: specific interrupt line
	outb(IO_PIC1, 0x20);
	outb(IO_PIC2, 0x20);
}
  8004209c5a:	90                   	nop
  8004209c5b:	c9                   	leaveq 
  8004209c5c:	c3                   	retq   

0000008004209c5d <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
  8004209c5d:	55                   	push   %rbp
  8004209c5e:	48 89 e5             	mov    %rsp,%rbp
  8004209c61:	48 83 ec 10          	sub    $0x10,%rsp
  8004209c65:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004209c68:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	cputchar(ch);
  8004209c6c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209c6f:	89 c7                	mov    %eax,%edi
  8004209c71:	48 b8 0f 12 20 04 80 	movabs $0x800420120f,%rax
  8004209c78:	00 00 00 
  8004209c7b:	ff d0                	callq  *%rax
	*cnt++;
  8004209c7d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004209c81:	48 83 c0 04          	add    $0x4,%rax
  8004209c85:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  8004209c89:	90                   	nop
  8004209c8a:	c9                   	leaveq 
  8004209c8b:	c3                   	retq   

0000008004209c8c <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  8004209c8c:	55                   	push   %rbp
  8004209c8d:	48 89 e5             	mov    %rsp,%rbp
  8004209c90:	48 83 ec 30          	sub    $0x30,%rsp
  8004209c94:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004209c98:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int cnt = 0;
  8004209c9c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004209ca3:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004209ca7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004209cab:	48 8b 0a             	mov    (%rdx),%rcx
  8004209cae:	48 89 08             	mov    %rcx,(%rax)
  8004209cb1:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004209cb5:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004209cb9:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004209cbd:	48 89 50 10          	mov    %rdx,0x10(%rax)
	vprintfmt((void*)putch, &cnt, fmt, aq);
  8004209cc1:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  8004209cc5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004209cc9:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8004209ccd:	48 89 c6             	mov    %rax,%rsi
  8004209cd0:	48 bf 5d 9c 20 04 80 	movabs $0x8004209c5d,%rdi
  8004209cd7:	00 00 00 
  8004209cda:	48 b8 d4 05 21 04 80 	movabs $0x80042105d4,%rax
  8004209ce1:	00 00 00 
  8004209ce4:	ff d0                	callq  *%rax
	va_end(aq);
	return cnt;
  8004209ce6:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  8004209ce9:	c9                   	leaveq 
  8004209cea:	c3                   	retq   

0000008004209ceb <cprintf>:

int
cprintf(const char *fmt, ...)
{
  8004209ceb:	55                   	push   %rbp
  8004209cec:	48 89 e5             	mov    %rsp,%rbp
  8004209cef:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  8004209cf6:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  8004209cfd:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  8004209d04:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  8004209d0b:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004209d12:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004209d19:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004209d20:	84 c0                	test   %al,%al
  8004209d22:	74 20                	je     8004209d44 <cprintf+0x59>
  8004209d24:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004209d28:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004209d2c:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004209d30:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004209d34:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004209d38:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004209d3c:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004209d40:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;
	int cnt;
	va_start(ap, fmt);
  8004209d44:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  8004209d4b:	00 00 00 
  8004209d4e:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  8004209d55:	00 00 00 
  8004209d58:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004209d5c:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004209d63:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004209d6a:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004209d71:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  8004209d78:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8004209d7f:	48 8b 0a             	mov    (%rdx),%rcx
  8004209d82:	48 89 08             	mov    %rcx,(%rax)
  8004209d85:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004209d89:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004209d8d:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004209d91:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  8004209d95:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  8004209d9c:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004209da3:	48 89 d6             	mov    %rdx,%rsi
  8004209da6:	48 89 c7             	mov    %rax,%rdi
  8004209da9:	48 b8 8c 9c 20 04 80 	movabs $0x8004209c8c,%rax
  8004209db0:	00 00 00 
  8004209db3:	ff d0                	callq  *%rax
  8004209db5:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  8004209dbb:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8004209dc1:	c9                   	leaveq 
  8004209dc2:	c3                   	retq   

0000008004209dc3 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004209dc3:	55                   	push   %rbp
  8004209dc4:	48 89 e5             	mov    %rsp,%rbp
  8004209dc7:	48 83 ec 20          	sub    $0x20,%rsp
  8004209dcb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004209dcf:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004209dd2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004209dd6:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004209dd9:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004209ddd:	f0 87 02             	lock xchg %eax,(%rdx)
  8004209de0:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004209de3:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004209de6:	c9                   	leaveq 
  8004209de7:	c3                   	retq   

0000008004209de8 <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  8004209de8:	55                   	push   %rbp
  8004209de9:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004209dec:	48 bf 60 67 23 04 80 	movabs $0x8004236760,%rdi
  8004209df3:	00 00 00 
  8004209df6:	48 b8 8e 84 21 04 80 	movabs $0x800421848e,%rax
  8004209dfd:	00 00 00 
  8004209e00:	ff d0                	callq  *%rax
}
  8004209e02:	90                   	nop
  8004209e03:	5d                   	pop    %rbp
  8004209e04:	c3                   	retq   

0000008004209e05 <trapname>:
struct Gatedesc idt[256] = { { 0 } };
struct Pseudodesc idt_pd = {0,0};


static const char *trapname(int trapno)
{
  8004209e05:	55                   	push   %rbp
  8004209e06:	48 89 e5             	mov    %rsp,%rbp
  8004209e09:	48 83 ec 08          	sub    $0x8,%rsp
  8004209e0d:	89 7d fc             	mov    %edi,-0x4(%rbp)
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
  8004209e10:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209e13:	83 f8 13             	cmp    $0x13,%eax
  8004209e16:	77 16                	ja     8004209e2e <trapname+0x29>
		return excnames[trapno];
  8004209e18:	48 b8 00 09 22 04 80 	movabs $0x8004220900,%rax
  8004209e1f:	00 00 00 
  8004209e22:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209e25:	48 63 d2             	movslq %edx,%rdx
  8004209e28:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004209e2c:	eb 34                	jmp    8004209e62 <trapname+0x5d>
	if (trapno == T_SYSCALL)
  8004209e2e:	83 7d fc 30          	cmpl   $0x30,-0x4(%rbp)
  8004209e32:	75 0c                	jne    8004209e40 <trapname+0x3b>
		return "System call";
  8004209e34:	48 b8 00 05 22 04 80 	movabs $0x8004220500,%rax
  8004209e3b:	00 00 00 
  8004209e3e:	eb 22                	jmp    8004209e62 <trapname+0x5d>

	if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
  8004209e40:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  8004209e44:	7e 12                	jle    8004209e58 <trapname+0x53>
  8004209e46:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  8004209e4a:	7f 0c                	jg     8004209e58 <trapname+0x53>
		return "Hardware Interrupt";
  8004209e4c:	48 b8 0c 05 22 04 80 	movabs $0x800422050c,%rax
  8004209e53:	00 00 00 
  8004209e56:	eb 0a                	jmp    8004209e62 <trapname+0x5d>

	return "(unknown trap)";
  8004209e58:	48 b8 1f 05 22 04 80 	movabs $0x800422051f,%rax
  8004209e5f:	00 00 00 
}
  8004209e62:	c9                   	leaveq 
  8004209e63:	c3                   	retq   

0000008004209e64 <trap_init>:


void
trap_init(void)
{
  8004209e64:	55                   	push   %rbp
  8004209e65:	48 89 e5             	mov    %rsp,%rbp
  8004209e68:	48 83 ec 10          	sub    $0x10,%rsp
	// check that IRQ_OFFSET is a multiple of 8
	static_assert((IRQ_OFFSET & 7) == 0);


	// install a default handler
	for (i = 0; i < sizeof(idt)/sizeof(idt[0]); i++)
  8004209e6c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004209e73:	e9 8f 01 00 00       	jmpq   800420a007 <trap_init+0x1a3>
		SETGATE(idt[i], 0, GD_KT, &Xdefault, 0);
  8004209e78:	48 b8 46 d9 20 04 80 	movabs $0x800420d946,%rax
  8004209e7f:	00 00 00 
  8004209e82:	89 c1                	mov    %eax,%ecx
  8004209e84:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  8004209e8b:	00 00 00 
  8004209e8e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209e91:	48 63 d2             	movslq %edx,%rdx
  8004209e94:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209e98:	48 01 d0             	add    %rdx,%rax
  8004209e9b:	66 89 08             	mov    %cx,(%rax)
  8004209e9e:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  8004209ea5:	00 00 00 
  8004209ea8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209eab:	48 63 d2             	movslq %edx,%rdx
  8004209eae:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209eb2:	48 01 d0             	add    %rdx,%rax
  8004209eb5:	48 83 c0 02          	add    $0x2,%rax
  8004209eb9:	66 c7 00 08 00       	movw   $0x8,(%rax)
  8004209ebe:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  8004209ec5:	00 00 00 
  8004209ec8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209ecb:	48 63 d2             	movslq %edx,%rdx
  8004209ece:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209ed2:	48 01 d0             	add    %rdx,%rax
  8004209ed5:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004209ed9:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209edc:	88 50 04             	mov    %dl,0x4(%rax)
  8004209edf:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  8004209ee6:	00 00 00 
  8004209ee9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209eec:	48 63 d2             	movslq %edx,%rdx
  8004209eef:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209ef3:	48 01 d0             	add    %rdx,%rax
  8004209ef6:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004209efa:	83 e2 07             	and    $0x7,%edx
  8004209efd:	88 50 04             	mov    %dl,0x4(%rax)
  8004209f00:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  8004209f07:	00 00 00 
  8004209f0a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209f0d:	48 63 d2             	movslq %edx,%rdx
  8004209f10:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209f14:	48 01 d0             	add    %rdx,%rax
  8004209f17:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209f1b:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209f1e:	83 ca 0e             	or     $0xe,%edx
  8004209f21:	88 50 05             	mov    %dl,0x5(%rax)
  8004209f24:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  8004209f2b:	00 00 00 
  8004209f2e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209f31:	48 63 d2             	movslq %edx,%rdx
  8004209f34:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209f38:	48 01 d0             	add    %rdx,%rax
  8004209f3b:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209f3f:	83 e2 ef             	and    $0xffffffef,%edx
  8004209f42:	88 50 05             	mov    %dl,0x5(%rax)
  8004209f45:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  8004209f4c:	00 00 00 
  8004209f4f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209f52:	48 63 d2             	movslq %edx,%rdx
  8004209f55:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209f59:	48 01 d0             	add    %rdx,%rax
  8004209f5c:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209f60:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209f63:	88 50 05             	mov    %dl,0x5(%rax)
  8004209f66:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  8004209f6d:	00 00 00 
  8004209f70:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209f73:	48 63 d2             	movslq %edx,%rdx
  8004209f76:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209f7a:	48 01 d0             	add    %rdx,%rax
  8004209f7d:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209f81:	83 ca 80             	or     $0xffffff80,%edx
  8004209f84:	88 50 05             	mov    %dl,0x5(%rax)
  8004209f87:	48 b8 46 d9 20 04 80 	movabs $0x800420d946,%rax
  8004209f8e:	00 00 00 
  8004209f91:	48 c1 e8 10          	shr    $0x10,%rax
  8004209f95:	89 c1                	mov    %eax,%ecx
  8004209f97:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  8004209f9e:	00 00 00 
  8004209fa1:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209fa4:	48 63 d2             	movslq %edx,%rdx
  8004209fa7:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209fab:	48 01 d0             	add    %rdx,%rax
  8004209fae:	48 83 c0 06          	add    $0x6,%rax
  8004209fb2:	66 89 08             	mov    %cx,(%rax)
  8004209fb5:	48 b8 46 d9 20 04 80 	movabs $0x800420d946,%rax
  8004209fbc:	00 00 00 
  8004209fbf:	48 c1 e8 20          	shr    $0x20,%rax
  8004209fc3:	89 c1                	mov    %eax,%ecx
  8004209fc5:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  8004209fcc:	00 00 00 
  8004209fcf:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209fd2:	48 63 d2             	movslq %edx,%rdx
  8004209fd5:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209fd9:	48 01 d0             	add    %rdx,%rax
  8004209fdc:	48 83 c0 08          	add    $0x8,%rax
  8004209fe0:	89 08                	mov    %ecx,(%rax)
  8004209fe2:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  8004209fe9:	00 00 00 
  8004209fec:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209fef:	48 63 d2             	movslq %edx,%rdx
  8004209ff2:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209ff6:	48 01 d0             	add    %rdx,%rax
  8004209ff9:	48 83 c0 0c          	add    $0xc,%rax
  8004209ffd:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	// check that IRQ_OFFSET is a multiple of 8
	static_assert((IRQ_OFFSET & 7) == 0);


	// install a default handler
	for (i = 0; i < sizeof(idt)/sizeof(idt[0]); i++)
  800420a003:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420a007:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420a00a:	3d ff 00 00 00       	cmp    $0xff,%eax
  800420a00f:	0f 86 63 fe ff ff    	jbe    8004209e78 <trap_init+0x14>
		SETGATE(idt[i], 0, GD_KT, &Xdefault, 0);

	SETGATE(idt[T_DIVIDE], 0, GD_KT, &Xdivide, 0);
  800420a015:	48 b8 50 d8 20 04 80 	movabs $0x800420d850,%rax
  800420a01c:	00 00 00 
  800420a01f:	89 c2                	mov    %eax,%edx
  800420a021:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a028:	00 00 00 
  800420a02b:	66 89 10             	mov    %dx,(%rax)
  800420a02e:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a035:	00 00 00 
  800420a038:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  800420a03e:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a045:	00 00 00 
  800420a048:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  800420a04c:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a04f:	88 50 04             	mov    %dl,0x4(%rax)
  800420a052:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a059:	00 00 00 
  800420a05c:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  800420a060:	83 e2 07             	and    $0x7,%edx
  800420a063:	88 50 04             	mov    %dl,0x4(%rax)
  800420a066:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a06d:	00 00 00 
  800420a070:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420a074:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a077:	83 ca 0e             	or     $0xe,%edx
  800420a07a:	88 50 05             	mov    %dl,0x5(%rax)
  800420a07d:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a084:	00 00 00 
  800420a087:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420a08b:	83 e2 ef             	and    $0xffffffef,%edx
  800420a08e:	88 50 05             	mov    %dl,0x5(%rax)
  800420a091:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a098:	00 00 00 
  800420a09b:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420a09f:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a0a2:	88 50 05             	mov    %dl,0x5(%rax)
  800420a0a5:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a0ac:	00 00 00 
  800420a0af:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420a0b3:	83 ca 80             	or     $0xffffff80,%edx
  800420a0b6:	88 50 05             	mov    %dl,0x5(%rax)
  800420a0b9:	48 b8 50 d8 20 04 80 	movabs $0x800420d850,%rax
  800420a0c0:	00 00 00 
  800420a0c3:	48 c1 e8 10          	shr    $0x10,%rax
  800420a0c7:	89 c2                	mov    %eax,%edx
  800420a0c9:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a0d0:	00 00 00 
  800420a0d3:	66 89 50 06          	mov    %dx,0x6(%rax)
  800420a0d7:	48 b8 50 d8 20 04 80 	movabs $0x800420d850,%rax
  800420a0de:	00 00 00 
  800420a0e1:	48 c1 e8 20          	shr    $0x20,%rax
  800420a0e5:	89 c2                	mov    %eax,%edx
  800420a0e7:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a0ee:	00 00 00 
  800420a0f1:	89 50 08             	mov    %edx,0x8(%rax)
  800420a0f4:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a0fb:	00 00 00 
  800420a0fe:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
	SETGATE(idt[T_DEBUG],  0, GD_KT, &Xdebug,  0);
  800420a105:	48 b8 5a d8 20 04 80 	movabs $0x800420d85a,%rax
  800420a10c:	00 00 00 
  800420a10f:	89 c2                	mov    %eax,%edx
  800420a111:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a118:	00 00 00 
  800420a11b:	66 89 50 10          	mov    %dx,0x10(%rax)
  800420a11f:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a126:	00 00 00 
  800420a129:	66 c7 40 12 08 00    	movw   $0x8,0x12(%rax)
  800420a12f:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a136:	00 00 00 
  800420a139:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  800420a13d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a140:	88 50 14             	mov    %dl,0x14(%rax)
  800420a143:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a14a:	00 00 00 
  800420a14d:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  800420a151:	83 e2 07             	and    $0x7,%edx
  800420a154:	88 50 14             	mov    %dl,0x14(%rax)
  800420a157:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a15e:	00 00 00 
  800420a161:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  800420a165:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a168:	83 ca 0e             	or     $0xe,%edx
  800420a16b:	88 50 15             	mov    %dl,0x15(%rax)
  800420a16e:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a175:	00 00 00 
  800420a178:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  800420a17c:	83 e2 ef             	and    $0xffffffef,%edx
  800420a17f:	88 50 15             	mov    %dl,0x15(%rax)
  800420a182:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a189:	00 00 00 
  800420a18c:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  800420a190:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a193:	88 50 15             	mov    %dl,0x15(%rax)
  800420a196:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a19d:	00 00 00 
  800420a1a0:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  800420a1a4:	83 ca 80             	or     $0xffffff80,%edx
  800420a1a7:	88 50 15             	mov    %dl,0x15(%rax)
  800420a1aa:	48 b8 5a d8 20 04 80 	movabs $0x800420d85a,%rax
  800420a1b1:	00 00 00 
  800420a1b4:	48 c1 e8 10          	shr    $0x10,%rax
  800420a1b8:	89 c2                	mov    %eax,%edx
  800420a1ba:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a1c1:	00 00 00 
  800420a1c4:	66 89 50 16          	mov    %dx,0x16(%rax)
  800420a1c8:	48 b8 5a d8 20 04 80 	movabs $0x800420d85a,%rax
  800420a1cf:	00 00 00 
  800420a1d2:	48 c1 e8 20          	shr    $0x20,%rax
  800420a1d6:	89 c2                	mov    %eax,%edx
  800420a1d8:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a1df:	00 00 00 
  800420a1e2:	89 50 18             	mov    %edx,0x18(%rax)
  800420a1e5:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a1ec:	00 00 00 
  800420a1ef:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%rax)
	SETGATE(idt[T_NMI],    0, GD_KT, &Xnmi,    0);
  800420a1f6:	48 b8 64 d8 20 04 80 	movabs $0x800420d864,%rax
  800420a1fd:	00 00 00 
  800420a200:	89 c2                	mov    %eax,%edx
  800420a202:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a209:	00 00 00 
  800420a20c:	66 89 50 20          	mov    %dx,0x20(%rax)
  800420a210:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a217:	00 00 00 
  800420a21a:	66 c7 40 22 08 00    	movw   $0x8,0x22(%rax)
  800420a220:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a227:	00 00 00 
  800420a22a:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  800420a22e:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a231:	88 50 24             	mov    %dl,0x24(%rax)
  800420a234:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a23b:	00 00 00 
  800420a23e:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  800420a242:	83 e2 07             	and    $0x7,%edx
  800420a245:	88 50 24             	mov    %dl,0x24(%rax)
  800420a248:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a24f:	00 00 00 
  800420a252:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  800420a256:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a259:	83 ca 0e             	or     $0xe,%edx
  800420a25c:	88 50 25             	mov    %dl,0x25(%rax)
  800420a25f:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a266:	00 00 00 
  800420a269:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  800420a26d:	83 e2 ef             	and    $0xffffffef,%edx
  800420a270:	88 50 25             	mov    %dl,0x25(%rax)
  800420a273:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a27a:	00 00 00 
  800420a27d:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  800420a281:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a284:	88 50 25             	mov    %dl,0x25(%rax)
  800420a287:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a28e:	00 00 00 
  800420a291:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  800420a295:	83 ca 80             	or     $0xffffff80,%edx
  800420a298:	88 50 25             	mov    %dl,0x25(%rax)
  800420a29b:	48 b8 64 d8 20 04 80 	movabs $0x800420d864,%rax
  800420a2a2:	00 00 00 
  800420a2a5:	48 c1 e8 10          	shr    $0x10,%rax
  800420a2a9:	89 c2                	mov    %eax,%edx
  800420a2ab:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a2b2:	00 00 00 
  800420a2b5:	66 89 50 26          	mov    %dx,0x26(%rax)
  800420a2b9:	48 b8 64 d8 20 04 80 	movabs $0x800420d864,%rax
  800420a2c0:	00 00 00 
  800420a2c3:	48 c1 e8 20          	shr    $0x20,%rax
  800420a2c7:	89 c2                	mov    %eax,%edx
  800420a2c9:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a2d0:	00 00 00 
  800420a2d3:	89 50 28             	mov    %edx,0x28(%rax)
  800420a2d6:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a2dd:	00 00 00 
  800420a2e0:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%rax)
	SETGATE(idt[T_BRKPT],  0, GD_KT, &Xbrkpt,  3);
  800420a2e7:	48 b8 6e d8 20 04 80 	movabs $0x800420d86e,%rax
  800420a2ee:	00 00 00 
  800420a2f1:	89 c2                	mov    %eax,%edx
  800420a2f3:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a2fa:	00 00 00 
  800420a2fd:	66 89 50 30          	mov    %dx,0x30(%rax)
  800420a301:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a308:	00 00 00 
  800420a30b:	66 c7 40 32 08 00    	movw   $0x8,0x32(%rax)
  800420a311:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a318:	00 00 00 
  800420a31b:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  800420a31f:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a322:	88 50 34             	mov    %dl,0x34(%rax)
  800420a325:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a32c:	00 00 00 
  800420a32f:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  800420a333:	83 e2 07             	and    $0x7,%edx
  800420a336:	88 50 34             	mov    %dl,0x34(%rax)
  800420a339:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a340:	00 00 00 
  800420a343:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  800420a347:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a34a:	83 ca 0e             	or     $0xe,%edx
  800420a34d:	88 50 35             	mov    %dl,0x35(%rax)
  800420a350:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a357:	00 00 00 
  800420a35a:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  800420a35e:	83 e2 ef             	and    $0xffffffef,%edx
  800420a361:	88 50 35             	mov    %dl,0x35(%rax)
  800420a364:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a36b:	00 00 00 
  800420a36e:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  800420a372:	83 ca 60             	or     $0x60,%edx
  800420a375:	88 50 35             	mov    %dl,0x35(%rax)
  800420a378:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a37f:	00 00 00 
  800420a382:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  800420a386:	83 ca 80             	or     $0xffffff80,%edx
  800420a389:	88 50 35             	mov    %dl,0x35(%rax)
  800420a38c:	48 b8 6e d8 20 04 80 	movabs $0x800420d86e,%rax
  800420a393:	00 00 00 
  800420a396:	48 c1 e8 10          	shr    $0x10,%rax
  800420a39a:	89 c2                	mov    %eax,%edx
  800420a39c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a3a3:	00 00 00 
  800420a3a6:	66 89 50 36          	mov    %dx,0x36(%rax)
  800420a3aa:	48 b8 6e d8 20 04 80 	movabs $0x800420d86e,%rax
  800420a3b1:	00 00 00 
  800420a3b4:	48 c1 e8 20          	shr    $0x20,%rax
  800420a3b8:	89 c2                	mov    %eax,%edx
  800420a3ba:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a3c1:	00 00 00 
  800420a3c4:	89 50 38             	mov    %edx,0x38(%rax)
  800420a3c7:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a3ce:	00 00 00 
  800420a3d1:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
	SETGATE(idt[T_OFLOW],  0, GD_KT, &Xoflow,  0);
  800420a3d8:	48 b8 78 d8 20 04 80 	movabs $0x800420d878,%rax
  800420a3df:	00 00 00 
  800420a3e2:	89 c2                	mov    %eax,%edx
  800420a3e4:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a3eb:	00 00 00 
  800420a3ee:	66 89 50 40          	mov    %dx,0x40(%rax)
  800420a3f2:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a3f9:	00 00 00 
  800420a3fc:	66 c7 40 42 08 00    	movw   $0x8,0x42(%rax)
  800420a402:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a409:	00 00 00 
  800420a40c:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  800420a410:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a413:	88 50 44             	mov    %dl,0x44(%rax)
  800420a416:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a41d:	00 00 00 
  800420a420:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  800420a424:	83 e2 07             	and    $0x7,%edx
  800420a427:	88 50 44             	mov    %dl,0x44(%rax)
  800420a42a:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a431:	00 00 00 
  800420a434:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  800420a438:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a43b:	83 ca 0e             	or     $0xe,%edx
  800420a43e:	88 50 45             	mov    %dl,0x45(%rax)
  800420a441:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a448:	00 00 00 
  800420a44b:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  800420a44f:	83 e2 ef             	and    $0xffffffef,%edx
  800420a452:	88 50 45             	mov    %dl,0x45(%rax)
  800420a455:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a45c:	00 00 00 
  800420a45f:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  800420a463:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a466:	88 50 45             	mov    %dl,0x45(%rax)
  800420a469:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a470:	00 00 00 
  800420a473:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  800420a477:	83 ca 80             	or     $0xffffff80,%edx
  800420a47a:	88 50 45             	mov    %dl,0x45(%rax)
  800420a47d:	48 b8 78 d8 20 04 80 	movabs $0x800420d878,%rax
  800420a484:	00 00 00 
  800420a487:	48 c1 e8 10          	shr    $0x10,%rax
  800420a48b:	89 c2                	mov    %eax,%edx
  800420a48d:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a494:	00 00 00 
  800420a497:	66 89 50 46          	mov    %dx,0x46(%rax)
  800420a49b:	48 b8 78 d8 20 04 80 	movabs $0x800420d878,%rax
  800420a4a2:	00 00 00 
  800420a4a5:	48 c1 e8 20          	shr    $0x20,%rax
  800420a4a9:	89 c2                	mov    %eax,%edx
  800420a4ab:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a4b2:	00 00 00 
  800420a4b5:	89 50 48             	mov    %edx,0x48(%rax)
  800420a4b8:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a4bf:	00 00 00 
  800420a4c2:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
	SETGATE(idt[T_BOUND],  0, GD_KT, &Xbound,  0);
  800420a4c9:	48 b8 82 d8 20 04 80 	movabs $0x800420d882,%rax
  800420a4d0:	00 00 00 
  800420a4d3:	89 c2                	mov    %eax,%edx
  800420a4d5:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a4dc:	00 00 00 
  800420a4df:	66 89 50 50          	mov    %dx,0x50(%rax)
  800420a4e3:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a4ea:	00 00 00 
  800420a4ed:	66 c7 40 52 08 00    	movw   $0x8,0x52(%rax)
  800420a4f3:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a4fa:	00 00 00 
  800420a4fd:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  800420a501:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a504:	88 50 54             	mov    %dl,0x54(%rax)
  800420a507:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a50e:	00 00 00 
  800420a511:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  800420a515:	83 e2 07             	and    $0x7,%edx
  800420a518:	88 50 54             	mov    %dl,0x54(%rax)
  800420a51b:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a522:	00 00 00 
  800420a525:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  800420a529:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a52c:	83 ca 0e             	or     $0xe,%edx
  800420a52f:	88 50 55             	mov    %dl,0x55(%rax)
  800420a532:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a539:	00 00 00 
  800420a53c:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  800420a540:	83 e2 ef             	and    $0xffffffef,%edx
  800420a543:	88 50 55             	mov    %dl,0x55(%rax)
  800420a546:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a54d:	00 00 00 
  800420a550:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  800420a554:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a557:	88 50 55             	mov    %dl,0x55(%rax)
  800420a55a:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a561:	00 00 00 
  800420a564:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  800420a568:	83 ca 80             	or     $0xffffff80,%edx
  800420a56b:	88 50 55             	mov    %dl,0x55(%rax)
  800420a56e:	48 b8 82 d8 20 04 80 	movabs $0x800420d882,%rax
  800420a575:	00 00 00 
  800420a578:	48 c1 e8 10          	shr    $0x10,%rax
  800420a57c:	89 c2                	mov    %eax,%edx
  800420a57e:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a585:	00 00 00 
  800420a588:	66 89 50 56          	mov    %dx,0x56(%rax)
  800420a58c:	48 b8 82 d8 20 04 80 	movabs $0x800420d882,%rax
  800420a593:	00 00 00 
  800420a596:	48 c1 e8 20          	shr    $0x20,%rax
  800420a59a:	89 c2                	mov    %eax,%edx
  800420a59c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a5a3:	00 00 00 
  800420a5a6:	89 50 58             	mov    %edx,0x58(%rax)
  800420a5a9:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a5b0:	00 00 00 
  800420a5b3:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
	SETGATE(idt[T_ILLOP],  0, GD_KT, &Xillop,  0);
  800420a5ba:	48 b8 8c d8 20 04 80 	movabs $0x800420d88c,%rax
  800420a5c1:	00 00 00 
  800420a5c4:	89 c2                	mov    %eax,%edx
  800420a5c6:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a5cd:	00 00 00 
  800420a5d0:	66 89 50 60          	mov    %dx,0x60(%rax)
  800420a5d4:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a5db:	00 00 00 
  800420a5de:	66 c7 40 62 08 00    	movw   $0x8,0x62(%rax)
  800420a5e4:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a5eb:	00 00 00 
  800420a5ee:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  800420a5f2:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a5f5:	88 50 64             	mov    %dl,0x64(%rax)
  800420a5f8:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a5ff:	00 00 00 
  800420a602:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  800420a606:	83 e2 07             	and    $0x7,%edx
  800420a609:	88 50 64             	mov    %dl,0x64(%rax)
  800420a60c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a613:	00 00 00 
  800420a616:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420a61a:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a61d:	83 ca 0e             	or     $0xe,%edx
  800420a620:	88 50 65             	mov    %dl,0x65(%rax)
  800420a623:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a62a:	00 00 00 
  800420a62d:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420a631:	83 e2 ef             	and    $0xffffffef,%edx
  800420a634:	88 50 65             	mov    %dl,0x65(%rax)
  800420a637:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a63e:	00 00 00 
  800420a641:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420a645:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a648:	88 50 65             	mov    %dl,0x65(%rax)
  800420a64b:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a652:	00 00 00 
  800420a655:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420a659:	83 ca 80             	or     $0xffffff80,%edx
  800420a65c:	88 50 65             	mov    %dl,0x65(%rax)
  800420a65f:	48 b8 8c d8 20 04 80 	movabs $0x800420d88c,%rax
  800420a666:	00 00 00 
  800420a669:	48 c1 e8 10          	shr    $0x10,%rax
  800420a66d:	89 c2                	mov    %eax,%edx
  800420a66f:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a676:	00 00 00 
  800420a679:	66 89 50 66          	mov    %dx,0x66(%rax)
  800420a67d:	48 b8 8c d8 20 04 80 	movabs $0x800420d88c,%rax
  800420a684:	00 00 00 
  800420a687:	48 c1 e8 20          	shr    $0x20,%rax
  800420a68b:	89 c2                	mov    %eax,%edx
  800420a68d:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a694:	00 00 00 
  800420a697:	89 50 68             	mov    %edx,0x68(%rax)
  800420a69a:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a6a1:	00 00 00 
  800420a6a4:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%rax)
	SETGATE(idt[T_DEVICE], 0, GD_KT, &Xdevice, 0);
  800420a6ab:	48 b8 96 d8 20 04 80 	movabs $0x800420d896,%rax
  800420a6b2:	00 00 00 
  800420a6b5:	89 c2                	mov    %eax,%edx
  800420a6b7:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a6be:	00 00 00 
  800420a6c1:	66 89 50 70          	mov    %dx,0x70(%rax)
  800420a6c5:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a6cc:	00 00 00 
  800420a6cf:	66 c7 40 72 08 00    	movw   $0x8,0x72(%rax)
  800420a6d5:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a6dc:	00 00 00 
  800420a6df:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  800420a6e3:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a6e6:	88 50 74             	mov    %dl,0x74(%rax)
  800420a6e9:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a6f0:	00 00 00 
  800420a6f3:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  800420a6f7:	83 e2 07             	and    $0x7,%edx
  800420a6fa:	88 50 74             	mov    %dl,0x74(%rax)
  800420a6fd:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a704:	00 00 00 
  800420a707:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420a70b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a70e:	83 ca 0e             	or     $0xe,%edx
  800420a711:	88 50 75             	mov    %dl,0x75(%rax)
  800420a714:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a71b:	00 00 00 
  800420a71e:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420a722:	83 e2 ef             	and    $0xffffffef,%edx
  800420a725:	88 50 75             	mov    %dl,0x75(%rax)
  800420a728:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a72f:	00 00 00 
  800420a732:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420a736:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a739:	88 50 75             	mov    %dl,0x75(%rax)
  800420a73c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a743:	00 00 00 
  800420a746:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420a74a:	83 ca 80             	or     $0xffffff80,%edx
  800420a74d:	88 50 75             	mov    %dl,0x75(%rax)
  800420a750:	48 b8 96 d8 20 04 80 	movabs $0x800420d896,%rax
  800420a757:	00 00 00 
  800420a75a:	48 c1 e8 10          	shr    $0x10,%rax
  800420a75e:	89 c2                	mov    %eax,%edx
  800420a760:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a767:	00 00 00 
  800420a76a:	66 89 50 76          	mov    %dx,0x76(%rax)
  800420a76e:	48 b8 96 d8 20 04 80 	movabs $0x800420d896,%rax
  800420a775:	00 00 00 
  800420a778:	48 c1 e8 20          	shr    $0x20,%rax
  800420a77c:	89 c2                	mov    %eax,%edx
  800420a77e:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a785:	00 00 00 
  800420a788:	89 50 78             	mov    %edx,0x78(%rax)
  800420a78b:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a792:	00 00 00 
  800420a795:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
	SETGATE(idt[T_DBLFLT], 0, GD_KT, &Xdblflt, 0);
  800420a79c:	48 b8 a0 d8 20 04 80 	movabs $0x800420d8a0,%rax
  800420a7a3:	00 00 00 
  800420a7a6:	89 c2                	mov    %eax,%edx
  800420a7a8:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a7af:	00 00 00 
  800420a7b2:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
  800420a7b9:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a7c0:	00 00 00 
  800420a7c3:	66 c7 80 82 00 00 00 	movw   $0x8,0x82(%rax)
  800420a7ca:	08 00 
  800420a7cc:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a7d3:	00 00 00 
  800420a7d6:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  800420a7dd:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a7e0:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  800420a7e6:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a7ed:	00 00 00 
  800420a7f0:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  800420a7f7:	83 e2 07             	and    $0x7,%edx
  800420a7fa:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  800420a800:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a807:	00 00 00 
  800420a80a:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420a811:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a814:	83 ca 0e             	or     $0xe,%edx
  800420a817:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420a81d:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a824:	00 00 00 
  800420a827:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420a82e:	83 e2 ef             	and    $0xffffffef,%edx
  800420a831:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420a837:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a83e:	00 00 00 
  800420a841:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420a848:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a84b:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420a851:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a858:	00 00 00 
  800420a85b:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420a862:	83 ca 80             	or     $0xffffff80,%edx
  800420a865:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420a86b:	48 b8 a0 d8 20 04 80 	movabs $0x800420d8a0,%rax
  800420a872:	00 00 00 
  800420a875:	48 c1 e8 10          	shr    $0x10,%rax
  800420a879:	89 c2                	mov    %eax,%edx
  800420a87b:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a882:	00 00 00 
  800420a885:	66 89 90 86 00 00 00 	mov    %dx,0x86(%rax)
  800420a88c:	48 b8 a0 d8 20 04 80 	movabs $0x800420d8a0,%rax
  800420a893:	00 00 00 
  800420a896:	48 c1 e8 20          	shr    $0x20,%rax
  800420a89a:	89 c2                	mov    %eax,%edx
  800420a89c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a8a3:	00 00 00 
  800420a8a6:	89 90 88 00 00 00    	mov    %edx,0x88(%rax)
  800420a8ac:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a8b3:	00 00 00 
  800420a8b6:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%rax)
  800420a8bd:	00 00 00 
	SETGATE(idt[T_TSS],    0, GD_KT, &Xtss,    0);
  800420a8c0:	48 b8 a8 d8 20 04 80 	movabs $0x800420d8a8,%rax
  800420a8c7:	00 00 00 
  800420a8ca:	89 c2                	mov    %eax,%edx
  800420a8cc:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a8d3:	00 00 00 
  800420a8d6:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
  800420a8dd:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a8e4:	00 00 00 
  800420a8e7:	66 c7 80 a2 00 00 00 	movw   $0x8,0xa2(%rax)
  800420a8ee:	08 00 
  800420a8f0:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a8f7:	00 00 00 
  800420a8fa:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  800420a901:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a904:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  800420a90a:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a911:	00 00 00 
  800420a914:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  800420a91b:	83 e2 07             	and    $0x7,%edx
  800420a91e:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  800420a924:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a92b:	00 00 00 
  800420a92e:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a935:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a938:	83 ca 0e             	or     $0xe,%edx
  800420a93b:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a941:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a948:	00 00 00 
  800420a94b:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a952:	83 e2 ef             	and    $0xffffffef,%edx
  800420a955:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a95b:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a962:	00 00 00 
  800420a965:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a96c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a96f:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a975:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a97c:	00 00 00 
  800420a97f:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a986:	83 ca 80             	or     $0xffffff80,%edx
  800420a989:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a98f:	48 b8 a8 d8 20 04 80 	movabs $0x800420d8a8,%rax
  800420a996:	00 00 00 
  800420a999:	48 c1 e8 10          	shr    $0x10,%rax
  800420a99d:	89 c2                	mov    %eax,%edx
  800420a99f:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a9a6:	00 00 00 
  800420a9a9:	66 89 90 a6 00 00 00 	mov    %dx,0xa6(%rax)
  800420a9b0:	48 b8 a8 d8 20 04 80 	movabs $0x800420d8a8,%rax
  800420a9b7:	00 00 00 
  800420a9ba:	48 c1 e8 20          	shr    $0x20,%rax
  800420a9be:	89 c2                	mov    %eax,%edx
  800420a9c0:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a9c7:	00 00 00 
  800420a9ca:	89 90 a8 00 00 00    	mov    %edx,0xa8(%rax)
  800420a9d0:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a9d7:	00 00 00 
  800420a9da:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%rax)
  800420a9e1:	00 00 00 
	SETGATE(idt[T_SEGNP],  0, GD_KT, &Xsegnp,  0);
  800420a9e4:	48 b8 b0 d8 20 04 80 	movabs $0x800420d8b0,%rax
  800420a9eb:	00 00 00 
  800420a9ee:	89 c2                	mov    %eax,%edx
  800420a9f0:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420a9f7:	00 00 00 
  800420a9fa:	66 89 90 b0 00 00 00 	mov    %dx,0xb0(%rax)
  800420aa01:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420aa08:	00 00 00 
  800420aa0b:	66 c7 80 b2 00 00 00 	movw   $0x8,0xb2(%rax)
  800420aa12:	08 00 
  800420aa14:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420aa1b:	00 00 00 
  800420aa1e:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  800420aa25:	83 e2 f8             	and    $0xfffffff8,%edx
  800420aa28:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  800420aa2e:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420aa35:	00 00 00 
  800420aa38:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  800420aa3f:	83 e2 07             	and    $0x7,%edx
  800420aa42:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  800420aa48:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420aa4f:	00 00 00 
  800420aa52:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420aa59:	83 e2 f0             	and    $0xfffffff0,%edx
  800420aa5c:	83 ca 0e             	or     $0xe,%edx
  800420aa5f:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420aa65:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420aa6c:	00 00 00 
  800420aa6f:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420aa76:	83 e2 ef             	and    $0xffffffef,%edx
  800420aa79:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420aa7f:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420aa86:	00 00 00 
  800420aa89:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420aa90:	83 e2 9f             	and    $0xffffff9f,%edx
  800420aa93:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420aa99:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420aaa0:	00 00 00 
  800420aaa3:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420aaaa:	83 ca 80             	or     $0xffffff80,%edx
  800420aaad:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420aab3:	48 b8 b0 d8 20 04 80 	movabs $0x800420d8b0,%rax
  800420aaba:	00 00 00 
  800420aabd:	48 c1 e8 10          	shr    $0x10,%rax
  800420aac1:	89 c2                	mov    %eax,%edx
  800420aac3:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420aaca:	00 00 00 
  800420aacd:	66 89 90 b6 00 00 00 	mov    %dx,0xb6(%rax)
  800420aad4:	48 b8 b0 d8 20 04 80 	movabs $0x800420d8b0,%rax
  800420aadb:	00 00 00 
  800420aade:	48 c1 e8 20          	shr    $0x20,%rax
  800420aae2:	89 c2                	mov    %eax,%edx
  800420aae4:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420aaeb:	00 00 00 
  800420aaee:	89 90 b8 00 00 00    	mov    %edx,0xb8(%rax)
  800420aaf4:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420aafb:	00 00 00 
  800420aafe:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%rax)
  800420ab05:	00 00 00 
	SETGATE(idt[T_STACK],  0, GD_KT, &Xstack,  0);
  800420ab08:	48 b8 b8 d8 20 04 80 	movabs $0x800420d8b8,%rax
  800420ab0f:	00 00 00 
  800420ab12:	89 c2                	mov    %eax,%edx
  800420ab14:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ab1b:	00 00 00 
  800420ab1e:	66 89 90 c0 00 00 00 	mov    %dx,0xc0(%rax)
  800420ab25:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ab2c:	00 00 00 
  800420ab2f:	66 c7 80 c2 00 00 00 	movw   $0x8,0xc2(%rax)
  800420ab36:	08 00 
  800420ab38:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ab3f:	00 00 00 
  800420ab42:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  800420ab49:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ab4c:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  800420ab52:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ab59:	00 00 00 
  800420ab5c:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  800420ab63:	83 e2 07             	and    $0x7,%edx
  800420ab66:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  800420ab6c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ab73:	00 00 00 
  800420ab76:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420ab7d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ab80:	83 ca 0e             	or     $0xe,%edx
  800420ab83:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420ab89:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ab90:	00 00 00 
  800420ab93:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420ab9a:	83 e2 ef             	and    $0xffffffef,%edx
  800420ab9d:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420aba3:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420abaa:	00 00 00 
  800420abad:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420abb4:	83 e2 9f             	and    $0xffffff9f,%edx
  800420abb7:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420abbd:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420abc4:	00 00 00 
  800420abc7:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420abce:	83 ca 80             	or     $0xffffff80,%edx
  800420abd1:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420abd7:	48 b8 b8 d8 20 04 80 	movabs $0x800420d8b8,%rax
  800420abde:	00 00 00 
  800420abe1:	48 c1 e8 10          	shr    $0x10,%rax
  800420abe5:	89 c2                	mov    %eax,%edx
  800420abe7:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420abee:	00 00 00 
  800420abf1:	66 89 90 c6 00 00 00 	mov    %dx,0xc6(%rax)
  800420abf8:	48 b8 b8 d8 20 04 80 	movabs $0x800420d8b8,%rax
  800420abff:	00 00 00 
  800420ac02:	48 c1 e8 20          	shr    $0x20,%rax
  800420ac06:	89 c2                	mov    %eax,%edx
  800420ac08:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ac0f:	00 00 00 
  800420ac12:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)
  800420ac18:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ac1f:	00 00 00 
  800420ac22:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  800420ac29:	00 00 00 
	SETGATE(idt[T_GPFLT],  0, GD_KT, &Xgpflt,  0);
  800420ac2c:	48 b8 c0 d8 20 04 80 	movabs $0x800420d8c0,%rax
  800420ac33:	00 00 00 
  800420ac36:	89 c2                	mov    %eax,%edx
  800420ac38:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ac3f:	00 00 00 
  800420ac42:	66 89 90 d0 00 00 00 	mov    %dx,0xd0(%rax)
  800420ac49:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ac50:	00 00 00 
  800420ac53:	66 c7 80 d2 00 00 00 	movw   $0x8,0xd2(%rax)
  800420ac5a:	08 00 
  800420ac5c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ac63:	00 00 00 
  800420ac66:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  800420ac6d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ac70:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  800420ac76:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ac7d:	00 00 00 
  800420ac80:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  800420ac87:	83 e2 07             	and    $0x7,%edx
  800420ac8a:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  800420ac90:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ac97:	00 00 00 
  800420ac9a:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420aca1:	83 e2 f0             	and    $0xfffffff0,%edx
  800420aca4:	83 ca 0e             	or     $0xe,%edx
  800420aca7:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420acad:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420acb4:	00 00 00 
  800420acb7:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420acbe:	83 e2 ef             	and    $0xffffffef,%edx
  800420acc1:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420acc7:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420acce:	00 00 00 
  800420acd1:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420acd8:	83 e2 9f             	and    $0xffffff9f,%edx
  800420acdb:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420ace1:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ace8:	00 00 00 
  800420aceb:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420acf2:	83 ca 80             	or     $0xffffff80,%edx
  800420acf5:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420acfb:	48 b8 c0 d8 20 04 80 	movabs $0x800420d8c0,%rax
  800420ad02:	00 00 00 
  800420ad05:	48 c1 e8 10          	shr    $0x10,%rax
  800420ad09:	89 c2                	mov    %eax,%edx
  800420ad0b:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ad12:	00 00 00 
  800420ad15:	66 89 90 d6 00 00 00 	mov    %dx,0xd6(%rax)
  800420ad1c:	48 b8 c0 d8 20 04 80 	movabs $0x800420d8c0,%rax
  800420ad23:	00 00 00 
  800420ad26:	48 c1 e8 20          	shr    $0x20,%rax
  800420ad2a:	89 c2                	mov    %eax,%edx
  800420ad2c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ad33:	00 00 00 
  800420ad36:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
  800420ad3c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ad43:	00 00 00 
  800420ad46:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%rax)
  800420ad4d:	00 00 00 
	SETGATE(idt[T_PGFLT],  0, GD_KT, &Xpgflt,  0);
  800420ad50:	48 b8 c8 d8 20 04 80 	movabs $0x800420d8c8,%rax
  800420ad57:	00 00 00 
  800420ad5a:	89 c2                	mov    %eax,%edx
  800420ad5c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ad63:	00 00 00 
  800420ad66:	66 89 90 e0 00 00 00 	mov    %dx,0xe0(%rax)
  800420ad6d:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ad74:	00 00 00 
  800420ad77:	66 c7 80 e2 00 00 00 	movw   $0x8,0xe2(%rax)
  800420ad7e:	08 00 
  800420ad80:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ad87:	00 00 00 
  800420ad8a:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  800420ad91:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ad94:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  800420ad9a:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ada1:	00 00 00 
  800420ada4:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  800420adab:	83 e2 07             	and    $0x7,%edx
  800420adae:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  800420adb4:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420adbb:	00 00 00 
  800420adbe:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420adc5:	83 e2 f0             	and    $0xfffffff0,%edx
  800420adc8:	83 ca 0e             	or     $0xe,%edx
  800420adcb:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420add1:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420add8:	00 00 00 
  800420addb:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420ade2:	83 e2 ef             	and    $0xffffffef,%edx
  800420ade5:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420adeb:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420adf2:	00 00 00 
  800420adf5:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420adfc:	83 e2 9f             	and    $0xffffff9f,%edx
  800420adff:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420ae05:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ae0c:	00 00 00 
  800420ae0f:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420ae16:	83 ca 80             	or     $0xffffff80,%edx
  800420ae19:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420ae1f:	48 b8 c8 d8 20 04 80 	movabs $0x800420d8c8,%rax
  800420ae26:	00 00 00 
  800420ae29:	48 c1 e8 10          	shr    $0x10,%rax
  800420ae2d:	89 c2                	mov    %eax,%edx
  800420ae2f:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ae36:	00 00 00 
  800420ae39:	66 89 90 e6 00 00 00 	mov    %dx,0xe6(%rax)
  800420ae40:	48 b8 c8 d8 20 04 80 	movabs $0x800420d8c8,%rax
  800420ae47:	00 00 00 
  800420ae4a:	48 c1 e8 20          	shr    $0x20,%rax
  800420ae4e:	89 c2                	mov    %eax,%edx
  800420ae50:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ae57:	00 00 00 
  800420ae5a:	89 90 e8 00 00 00    	mov    %edx,0xe8(%rax)
  800420ae60:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ae67:	00 00 00 
  800420ae6a:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%rax)
  800420ae71:	00 00 00 
	SETGATE(idt[T_FPERR],  0, GD_KT, &Xfperr,  0);
  800420ae74:	48 b8 d0 d8 20 04 80 	movabs $0x800420d8d0,%rax
  800420ae7b:	00 00 00 
  800420ae7e:	89 c2                	mov    %eax,%edx
  800420ae80:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ae87:	00 00 00 
  800420ae8a:	66 89 90 00 01 00 00 	mov    %dx,0x100(%rax)
  800420ae91:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ae98:	00 00 00 
  800420ae9b:	66 c7 80 02 01 00 00 	movw   $0x8,0x102(%rax)
  800420aea2:	08 00 
  800420aea4:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420aeab:	00 00 00 
  800420aeae:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  800420aeb5:	83 e2 f8             	and    $0xfffffff8,%edx
  800420aeb8:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  800420aebe:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420aec5:	00 00 00 
  800420aec8:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  800420aecf:	83 e2 07             	and    $0x7,%edx
  800420aed2:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  800420aed8:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420aedf:	00 00 00 
  800420aee2:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420aee9:	83 e2 f0             	and    $0xfffffff0,%edx
  800420aeec:	83 ca 0e             	or     $0xe,%edx
  800420aeef:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420aef5:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420aefc:	00 00 00 
  800420aeff:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420af06:	83 e2 ef             	and    $0xffffffef,%edx
  800420af09:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420af0f:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420af16:	00 00 00 
  800420af19:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420af20:	83 e2 9f             	and    $0xffffff9f,%edx
  800420af23:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420af29:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420af30:	00 00 00 
  800420af33:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420af3a:	83 ca 80             	or     $0xffffff80,%edx
  800420af3d:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420af43:	48 b8 d0 d8 20 04 80 	movabs $0x800420d8d0,%rax
  800420af4a:	00 00 00 
  800420af4d:	48 c1 e8 10          	shr    $0x10,%rax
  800420af51:	89 c2                	mov    %eax,%edx
  800420af53:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420af5a:	00 00 00 
  800420af5d:	66 89 90 06 01 00 00 	mov    %dx,0x106(%rax)
  800420af64:	48 b8 d0 d8 20 04 80 	movabs $0x800420d8d0,%rax
  800420af6b:	00 00 00 
  800420af6e:	48 c1 e8 20          	shr    $0x20,%rax
  800420af72:	89 c2                	mov    %eax,%edx
  800420af74:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420af7b:	00 00 00 
  800420af7e:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
  800420af84:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420af8b:	00 00 00 
  800420af8e:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%rax)
  800420af95:	00 00 00 
	SETGATE(idt[T_ALIGN],  0, GD_KT, &Xalign,  0);
  800420af98:	48 b8 d6 d8 20 04 80 	movabs $0x800420d8d6,%rax
  800420af9f:	00 00 00 
  800420afa2:	89 c2                	mov    %eax,%edx
  800420afa4:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420afab:	00 00 00 
  800420afae:	66 89 90 10 01 00 00 	mov    %dx,0x110(%rax)
  800420afb5:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420afbc:	00 00 00 
  800420afbf:	66 c7 80 12 01 00 00 	movw   $0x8,0x112(%rax)
  800420afc6:	08 00 
  800420afc8:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420afcf:	00 00 00 
  800420afd2:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  800420afd9:	83 e2 f8             	and    $0xfffffff8,%edx
  800420afdc:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  800420afe2:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420afe9:	00 00 00 
  800420afec:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  800420aff3:	83 e2 07             	and    $0x7,%edx
  800420aff6:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  800420affc:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b003:	00 00 00 
  800420b006:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420b00d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b010:	83 ca 0e             	or     $0xe,%edx
  800420b013:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420b019:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b020:	00 00 00 
  800420b023:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420b02a:	83 e2 ef             	and    $0xffffffef,%edx
  800420b02d:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420b033:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b03a:	00 00 00 
  800420b03d:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420b044:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b047:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420b04d:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b054:	00 00 00 
  800420b057:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420b05e:	83 ca 80             	or     $0xffffff80,%edx
  800420b061:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420b067:	48 b8 d6 d8 20 04 80 	movabs $0x800420d8d6,%rax
  800420b06e:	00 00 00 
  800420b071:	48 c1 e8 10          	shr    $0x10,%rax
  800420b075:	89 c2                	mov    %eax,%edx
  800420b077:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b07e:	00 00 00 
  800420b081:	66 89 90 16 01 00 00 	mov    %dx,0x116(%rax)
  800420b088:	48 b8 d6 d8 20 04 80 	movabs $0x800420d8d6,%rax
  800420b08f:	00 00 00 
  800420b092:	48 c1 e8 20          	shr    $0x20,%rax
  800420b096:	89 c2                	mov    %eax,%edx
  800420b098:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b09f:	00 00 00 
  800420b0a2:	89 90 18 01 00 00    	mov    %edx,0x118(%rax)
  800420b0a8:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b0af:	00 00 00 
  800420b0b2:	c7 80 1c 01 00 00 00 	movl   $0x0,0x11c(%rax)
  800420b0b9:	00 00 00 
	SETGATE(idt[T_MCHK],   0, GD_KT, &Xmchk,   0);
  800420b0bc:	48 b8 da d8 20 04 80 	movabs $0x800420d8da,%rax
  800420b0c3:	00 00 00 
  800420b0c6:	89 c2                	mov    %eax,%edx
  800420b0c8:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b0cf:	00 00 00 
  800420b0d2:	66 89 90 20 01 00 00 	mov    %dx,0x120(%rax)
  800420b0d9:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b0e0:	00 00 00 
  800420b0e3:	66 c7 80 22 01 00 00 	movw   $0x8,0x122(%rax)
  800420b0ea:	08 00 
  800420b0ec:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b0f3:	00 00 00 
  800420b0f6:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420b0fd:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b100:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420b106:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b10d:	00 00 00 
  800420b110:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420b117:	83 e2 07             	and    $0x7,%edx
  800420b11a:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420b120:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b127:	00 00 00 
  800420b12a:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420b131:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b134:	83 ca 0e             	or     $0xe,%edx
  800420b137:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420b13d:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b144:	00 00 00 
  800420b147:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420b14e:	83 e2 ef             	and    $0xffffffef,%edx
  800420b151:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420b157:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b15e:	00 00 00 
  800420b161:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420b168:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b16b:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420b171:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b178:	00 00 00 
  800420b17b:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420b182:	83 ca 80             	or     $0xffffff80,%edx
  800420b185:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420b18b:	48 b8 da d8 20 04 80 	movabs $0x800420d8da,%rax
  800420b192:	00 00 00 
  800420b195:	48 c1 e8 10          	shr    $0x10,%rax
  800420b199:	89 c2                	mov    %eax,%edx
  800420b19b:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b1a2:	00 00 00 
  800420b1a5:	66 89 90 26 01 00 00 	mov    %dx,0x126(%rax)
  800420b1ac:	48 b8 da d8 20 04 80 	movabs $0x800420d8da,%rax
  800420b1b3:	00 00 00 
  800420b1b6:	48 c1 e8 20          	shr    $0x20,%rax
  800420b1ba:	89 c2                	mov    %eax,%edx
  800420b1bc:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b1c3:	00 00 00 
  800420b1c6:	89 90 28 01 00 00    	mov    %edx,0x128(%rax)
  800420b1cc:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b1d3:	00 00 00 
  800420b1d6:	c7 80 2c 01 00 00 00 	movl   $0x0,0x12c(%rax)
  800420b1dd:	00 00 00 


	SETGATE(idt[IRQ_OFFSET + 0], 0, GD_KT, &Xirq0, 0);
  800420b1e0:	48 b8 e0 d8 20 04 80 	movabs $0x800420d8e0,%rax
  800420b1e7:	00 00 00 
  800420b1ea:	89 c2                	mov    %eax,%edx
  800420b1ec:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b1f3:	00 00 00 
  800420b1f6:	66 89 90 00 02 00 00 	mov    %dx,0x200(%rax)
  800420b1fd:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b204:	00 00 00 
  800420b207:	66 c7 80 02 02 00 00 	movw   $0x8,0x202(%rax)
  800420b20e:	08 00 
  800420b210:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b217:	00 00 00 
  800420b21a:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420b221:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b224:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420b22a:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b231:	00 00 00 
  800420b234:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420b23b:	83 e2 07             	and    $0x7,%edx
  800420b23e:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420b244:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b24b:	00 00 00 
  800420b24e:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420b255:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b258:	83 ca 0e             	or     $0xe,%edx
  800420b25b:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420b261:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b268:	00 00 00 
  800420b26b:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420b272:	83 e2 ef             	and    $0xffffffef,%edx
  800420b275:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420b27b:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b282:	00 00 00 
  800420b285:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420b28c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b28f:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420b295:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b29c:	00 00 00 
  800420b29f:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420b2a6:	83 ca 80             	or     $0xffffff80,%edx
  800420b2a9:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420b2af:	48 b8 e0 d8 20 04 80 	movabs $0x800420d8e0,%rax
  800420b2b6:	00 00 00 
  800420b2b9:	48 c1 e8 10          	shr    $0x10,%rax
  800420b2bd:	89 c2                	mov    %eax,%edx
  800420b2bf:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b2c6:	00 00 00 
  800420b2c9:	66 89 90 06 02 00 00 	mov    %dx,0x206(%rax)
  800420b2d0:	48 b8 e0 d8 20 04 80 	movabs $0x800420d8e0,%rax
  800420b2d7:	00 00 00 
  800420b2da:	48 c1 e8 20          	shr    $0x20,%rax
  800420b2de:	89 c2                	mov    %eax,%edx
  800420b2e0:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b2e7:	00 00 00 
  800420b2ea:	89 90 08 02 00 00    	mov    %edx,0x208(%rax)
  800420b2f0:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b2f7:	00 00 00 
  800420b2fa:	c7 80 0c 02 00 00 00 	movl   $0x0,0x20c(%rax)
  800420b301:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 1], 0, GD_KT, &Xirq1, 0);
  800420b304:	48 b8 e6 d8 20 04 80 	movabs $0x800420d8e6,%rax
  800420b30b:	00 00 00 
  800420b30e:	89 c2                	mov    %eax,%edx
  800420b310:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b317:	00 00 00 
  800420b31a:	66 89 90 10 02 00 00 	mov    %dx,0x210(%rax)
  800420b321:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b328:	00 00 00 
  800420b32b:	66 c7 80 12 02 00 00 	movw   $0x8,0x212(%rax)
  800420b332:	08 00 
  800420b334:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b33b:	00 00 00 
  800420b33e:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420b345:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b348:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420b34e:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b355:	00 00 00 
  800420b358:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420b35f:	83 e2 07             	and    $0x7,%edx
  800420b362:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420b368:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b36f:	00 00 00 
  800420b372:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420b379:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b37c:	83 ca 0e             	or     $0xe,%edx
  800420b37f:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420b385:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b38c:	00 00 00 
  800420b38f:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420b396:	83 e2 ef             	and    $0xffffffef,%edx
  800420b399:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420b39f:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b3a6:	00 00 00 
  800420b3a9:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420b3b0:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b3b3:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420b3b9:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b3c0:	00 00 00 
  800420b3c3:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420b3ca:	83 ca 80             	or     $0xffffff80,%edx
  800420b3cd:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420b3d3:	48 b8 e6 d8 20 04 80 	movabs $0x800420d8e6,%rax
  800420b3da:	00 00 00 
  800420b3dd:	48 c1 e8 10          	shr    $0x10,%rax
  800420b3e1:	89 c2                	mov    %eax,%edx
  800420b3e3:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b3ea:	00 00 00 
  800420b3ed:	66 89 90 16 02 00 00 	mov    %dx,0x216(%rax)
  800420b3f4:	48 b8 e6 d8 20 04 80 	movabs $0x800420d8e6,%rax
  800420b3fb:	00 00 00 
  800420b3fe:	48 c1 e8 20          	shr    $0x20,%rax
  800420b402:	89 c2                	mov    %eax,%edx
  800420b404:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b40b:	00 00 00 
  800420b40e:	89 90 18 02 00 00    	mov    %edx,0x218(%rax)
  800420b414:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b41b:	00 00 00 
  800420b41e:	c7 80 1c 02 00 00 00 	movl   $0x0,0x21c(%rax)
  800420b425:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 2], 0, GD_KT, &Xirq2, 0);
  800420b428:	48 b8 ec d8 20 04 80 	movabs $0x800420d8ec,%rax
  800420b42f:	00 00 00 
  800420b432:	89 c2                	mov    %eax,%edx
  800420b434:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b43b:	00 00 00 
  800420b43e:	66 89 90 20 02 00 00 	mov    %dx,0x220(%rax)
  800420b445:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b44c:	00 00 00 
  800420b44f:	66 c7 80 22 02 00 00 	movw   $0x8,0x222(%rax)
  800420b456:	08 00 
  800420b458:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b45f:	00 00 00 
  800420b462:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420b469:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b46c:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420b472:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b479:	00 00 00 
  800420b47c:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420b483:	83 e2 07             	and    $0x7,%edx
  800420b486:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420b48c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b493:	00 00 00 
  800420b496:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420b49d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b4a0:	83 ca 0e             	or     $0xe,%edx
  800420b4a3:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420b4a9:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b4b0:	00 00 00 
  800420b4b3:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420b4ba:	83 e2 ef             	and    $0xffffffef,%edx
  800420b4bd:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420b4c3:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b4ca:	00 00 00 
  800420b4cd:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420b4d4:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b4d7:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420b4dd:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b4e4:	00 00 00 
  800420b4e7:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420b4ee:	83 ca 80             	or     $0xffffff80,%edx
  800420b4f1:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420b4f7:	48 b8 ec d8 20 04 80 	movabs $0x800420d8ec,%rax
  800420b4fe:	00 00 00 
  800420b501:	48 c1 e8 10          	shr    $0x10,%rax
  800420b505:	89 c2                	mov    %eax,%edx
  800420b507:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b50e:	00 00 00 
  800420b511:	66 89 90 26 02 00 00 	mov    %dx,0x226(%rax)
  800420b518:	48 b8 ec d8 20 04 80 	movabs $0x800420d8ec,%rax
  800420b51f:	00 00 00 
  800420b522:	48 c1 e8 20          	shr    $0x20,%rax
  800420b526:	89 c2                	mov    %eax,%edx
  800420b528:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b52f:	00 00 00 
  800420b532:	89 90 28 02 00 00    	mov    %edx,0x228(%rax)
  800420b538:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b53f:	00 00 00 
  800420b542:	c7 80 2c 02 00 00 00 	movl   $0x0,0x22c(%rax)
  800420b549:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 3], 0, GD_KT, &Xirq3, 0);
  800420b54c:	48 b8 f2 d8 20 04 80 	movabs $0x800420d8f2,%rax
  800420b553:	00 00 00 
  800420b556:	89 c2                	mov    %eax,%edx
  800420b558:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b55f:	00 00 00 
  800420b562:	66 89 90 30 02 00 00 	mov    %dx,0x230(%rax)
  800420b569:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b570:	00 00 00 
  800420b573:	66 c7 80 32 02 00 00 	movw   $0x8,0x232(%rax)
  800420b57a:	08 00 
  800420b57c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b583:	00 00 00 
  800420b586:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420b58d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b590:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420b596:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b59d:	00 00 00 
  800420b5a0:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420b5a7:	83 e2 07             	and    $0x7,%edx
  800420b5aa:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420b5b0:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b5b7:	00 00 00 
  800420b5ba:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420b5c1:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b5c4:	83 ca 0e             	or     $0xe,%edx
  800420b5c7:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420b5cd:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b5d4:	00 00 00 
  800420b5d7:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420b5de:	83 e2 ef             	and    $0xffffffef,%edx
  800420b5e1:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420b5e7:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b5ee:	00 00 00 
  800420b5f1:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420b5f8:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b5fb:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420b601:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b608:	00 00 00 
  800420b60b:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420b612:	83 ca 80             	or     $0xffffff80,%edx
  800420b615:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420b61b:	48 b8 f2 d8 20 04 80 	movabs $0x800420d8f2,%rax
  800420b622:	00 00 00 
  800420b625:	48 c1 e8 10          	shr    $0x10,%rax
  800420b629:	89 c2                	mov    %eax,%edx
  800420b62b:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b632:	00 00 00 
  800420b635:	66 89 90 36 02 00 00 	mov    %dx,0x236(%rax)
  800420b63c:	48 b8 f2 d8 20 04 80 	movabs $0x800420d8f2,%rax
  800420b643:	00 00 00 
  800420b646:	48 c1 e8 20          	shr    $0x20,%rax
  800420b64a:	89 c2                	mov    %eax,%edx
  800420b64c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b653:	00 00 00 
  800420b656:	89 90 38 02 00 00    	mov    %edx,0x238(%rax)
  800420b65c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b663:	00 00 00 
  800420b666:	c7 80 3c 02 00 00 00 	movl   $0x0,0x23c(%rax)
  800420b66d:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 4], 0, GD_KT, &Xirq4, 0);
  800420b670:	48 b8 f8 d8 20 04 80 	movabs $0x800420d8f8,%rax
  800420b677:	00 00 00 
  800420b67a:	89 c2                	mov    %eax,%edx
  800420b67c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b683:	00 00 00 
  800420b686:	66 89 90 40 02 00 00 	mov    %dx,0x240(%rax)
  800420b68d:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b694:	00 00 00 
  800420b697:	66 c7 80 42 02 00 00 	movw   $0x8,0x242(%rax)
  800420b69e:	08 00 
  800420b6a0:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b6a7:	00 00 00 
  800420b6aa:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420b6b1:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b6b4:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420b6ba:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b6c1:	00 00 00 
  800420b6c4:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420b6cb:	83 e2 07             	and    $0x7,%edx
  800420b6ce:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420b6d4:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b6db:	00 00 00 
  800420b6de:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420b6e5:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b6e8:	83 ca 0e             	or     $0xe,%edx
  800420b6eb:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420b6f1:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b6f8:	00 00 00 
  800420b6fb:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420b702:	83 e2 ef             	and    $0xffffffef,%edx
  800420b705:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420b70b:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b712:	00 00 00 
  800420b715:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420b71c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b71f:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420b725:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b72c:	00 00 00 
  800420b72f:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420b736:	83 ca 80             	or     $0xffffff80,%edx
  800420b739:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420b73f:	48 b8 f8 d8 20 04 80 	movabs $0x800420d8f8,%rax
  800420b746:	00 00 00 
  800420b749:	48 c1 e8 10          	shr    $0x10,%rax
  800420b74d:	89 c2                	mov    %eax,%edx
  800420b74f:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b756:	00 00 00 
  800420b759:	66 89 90 46 02 00 00 	mov    %dx,0x246(%rax)
  800420b760:	48 b8 f8 d8 20 04 80 	movabs $0x800420d8f8,%rax
  800420b767:	00 00 00 
  800420b76a:	48 c1 e8 20          	shr    $0x20,%rax
  800420b76e:	89 c2                	mov    %eax,%edx
  800420b770:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b777:	00 00 00 
  800420b77a:	89 90 48 02 00 00    	mov    %edx,0x248(%rax)
  800420b780:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b787:	00 00 00 
  800420b78a:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%rax)
  800420b791:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 5], 0, GD_KT, &Xirq5, 0);
  800420b794:	48 b8 fe d8 20 04 80 	movabs $0x800420d8fe,%rax
  800420b79b:	00 00 00 
  800420b79e:	89 c2                	mov    %eax,%edx
  800420b7a0:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b7a7:	00 00 00 
  800420b7aa:	66 89 90 50 02 00 00 	mov    %dx,0x250(%rax)
  800420b7b1:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b7b8:	00 00 00 
  800420b7bb:	66 c7 80 52 02 00 00 	movw   $0x8,0x252(%rax)
  800420b7c2:	08 00 
  800420b7c4:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b7cb:	00 00 00 
  800420b7ce:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420b7d5:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b7d8:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420b7de:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b7e5:	00 00 00 
  800420b7e8:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420b7ef:	83 e2 07             	and    $0x7,%edx
  800420b7f2:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420b7f8:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b7ff:	00 00 00 
  800420b802:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b809:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b80c:	83 ca 0e             	or     $0xe,%edx
  800420b80f:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b815:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b81c:	00 00 00 
  800420b81f:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b826:	83 e2 ef             	and    $0xffffffef,%edx
  800420b829:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b82f:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b836:	00 00 00 
  800420b839:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b840:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b843:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b849:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b850:	00 00 00 
  800420b853:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b85a:	83 ca 80             	or     $0xffffff80,%edx
  800420b85d:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b863:	48 b8 fe d8 20 04 80 	movabs $0x800420d8fe,%rax
  800420b86a:	00 00 00 
  800420b86d:	48 c1 e8 10          	shr    $0x10,%rax
  800420b871:	89 c2                	mov    %eax,%edx
  800420b873:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b87a:	00 00 00 
  800420b87d:	66 89 90 56 02 00 00 	mov    %dx,0x256(%rax)
  800420b884:	48 b8 fe d8 20 04 80 	movabs $0x800420d8fe,%rax
  800420b88b:	00 00 00 
  800420b88e:	48 c1 e8 20          	shr    $0x20,%rax
  800420b892:	89 c2                	mov    %eax,%edx
  800420b894:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b89b:	00 00 00 
  800420b89e:	89 90 58 02 00 00    	mov    %edx,0x258(%rax)
  800420b8a4:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b8ab:	00 00 00 
  800420b8ae:	c7 80 5c 02 00 00 00 	movl   $0x0,0x25c(%rax)
  800420b8b5:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 6], 0, GD_KT, &Xirq6, 0);
  800420b8b8:	48 b8 04 d9 20 04 80 	movabs $0x800420d904,%rax
  800420b8bf:	00 00 00 
  800420b8c2:	89 c2                	mov    %eax,%edx
  800420b8c4:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b8cb:	00 00 00 
  800420b8ce:	66 89 90 60 02 00 00 	mov    %dx,0x260(%rax)
  800420b8d5:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b8dc:	00 00 00 
  800420b8df:	66 c7 80 62 02 00 00 	movw   $0x8,0x262(%rax)
  800420b8e6:	08 00 
  800420b8e8:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b8ef:	00 00 00 
  800420b8f2:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420b8f9:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b8fc:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420b902:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b909:	00 00 00 
  800420b90c:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420b913:	83 e2 07             	and    $0x7,%edx
  800420b916:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420b91c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b923:	00 00 00 
  800420b926:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b92d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b930:	83 ca 0e             	or     $0xe,%edx
  800420b933:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b939:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b940:	00 00 00 
  800420b943:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b94a:	83 e2 ef             	and    $0xffffffef,%edx
  800420b94d:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b953:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b95a:	00 00 00 
  800420b95d:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b964:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b967:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b96d:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b974:	00 00 00 
  800420b977:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b97e:	83 ca 80             	or     $0xffffff80,%edx
  800420b981:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b987:	48 b8 04 d9 20 04 80 	movabs $0x800420d904,%rax
  800420b98e:	00 00 00 
  800420b991:	48 c1 e8 10          	shr    $0x10,%rax
  800420b995:	89 c2                	mov    %eax,%edx
  800420b997:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b99e:	00 00 00 
  800420b9a1:	66 89 90 66 02 00 00 	mov    %dx,0x266(%rax)
  800420b9a8:	48 b8 04 d9 20 04 80 	movabs $0x800420d904,%rax
  800420b9af:	00 00 00 
  800420b9b2:	48 c1 e8 20          	shr    $0x20,%rax
  800420b9b6:	89 c2                	mov    %eax,%edx
  800420b9b8:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b9bf:	00 00 00 
  800420b9c2:	89 90 68 02 00 00    	mov    %edx,0x268(%rax)
  800420b9c8:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b9cf:	00 00 00 
  800420b9d2:	c7 80 6c 02 00 00 00 	movl   $0x0,0x26c(%rax)
  800420b9d9:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 7], 0, GD_KT, &Xirq7, 0);
  800420b9dc:	48 b8 0a d9 20 04 80 	movabs $0x800420d90a,%rax
  800420b9e3:	00 00 00 
  800420b9e6:	89 c2                	mov    %eax,%edx
  800420b9e8:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420b9ef:	00 00 00 
  800420b9f2:	66 89 90 70 02 00 00 	mov    %dx,0x270(%rax)
  800420b9f9:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ba00:	00 00 00 
  800420ba03:	66 c7 80 72 02 00 00 	movw   $0x8,0x272(%rax)
  800420ba0a:	08 00 
  800420ba0c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ba13:	00 00 00 
  800420ba16:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420ba1d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ba20:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420ba26:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ba2d:	00 00 00 
  800420ba30:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420ba37:	83 e2 07             	and    $0x7,%edx
  800420ba3a:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420ba40:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ba47:	00 00 00 
  800420ba4a:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420ba51:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ba54:	83 ca 0e             	or     $0xe,%edx
  800420ba57:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420ba5d:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ba64:	00 00 00 
  800420ba67:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420ba6e:	83 e2 ef             	and    $0xffffffef,%edx
  800420ba71:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420ba77:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ba7e:	00 00 00 
  800420ba81:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420ba88:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ba8b:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420ba91:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420ba98:	00 00 00 
  800420ba9b:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420baa2:	83 ca 80             	or     $0xffffff80,%edx
  800420baa5:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420baab:	48 b8 0a d9 20 04 80 	movabs $0x800420d90a,%rax
  800420bab2:	00 00 00 
  800420bab5:	48 c1 e8 10          	shr    $0x10,%rax
  800420bab9:	89 c2                	mov    %eax,%edx
  800420babb:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bac2:	00 00 00 
  800420bac5:	66 89 90 76 02 00 00 	mov    %dx,0x276(%rax)
  800420bacc:	48 b8 0a d9 20 04 80 	movabs $0x800420d90a,%rax
  800420bad3:	00 00 00 
  800420bad6:	48 c1 e8 20          	shr    $0x20,%rax
  800420bada:	89 c2                	mov    %eax,%edx
  800420badc:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bae3:	00 00 00 
  800420bae6:	89 90 78 02 00 00    	mov    %edx,0x278(%rax)
  800420baec:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420baf3:	00 00 00 
  800420baf6:	c7 80 7c 02 00 00 00 	movl   $0x0,0x27c(%rax)
  800420bafd:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 8], 0, GD_KT, &Xirq8, 0);
  800420bb00:	48 b8 10 d9 20 04 80 	movabs $0x800420d910,%rax
  800420bb07:	00 00 00 
  800420bb0a:	89 c2                	mov    %eax,%edx
  800420bb0c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bb13:	00 00 00 
  800420bb16:	66 89 90 80 02 00 00 	mov    %dx,0x280(%rax)
  800420bb1d:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bb24:	00 00 00 
  800420bb27:	66 c7 80 82 02 00 00 	movw   $0x8,0x282(%rax)
  800420bb2e:	08 00 
  800420bb30:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bb37:	00 00 00 
  800420bb3a:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420bb41:	83 e2 f8             	and    $0xfffffff8,%edx
  800420bb44:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420bb4a:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bb51:	00 00 00 
  800420bb54:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420bb5b:	83 e2 07             	and    $0x7,%edx
  800420bb5e:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420bb64:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bb6b:	00 00 00 
  800420bb6e:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420bb75:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bb78:	83 ca 0e             	or     $0xe,%edx
  800420bb7b:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420bb81:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bb88:	00 00 00 
  800420bb8b:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420bb92:	83 e2 ef             	and    $0xffffffef,%edx
  800420bb95:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420bb9b:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bba2:	00 00 00 
  800420bba5:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420bbac:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bbaf:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420bbb5:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bbbc:	00 00 00 
  800420bbbf:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420bbc6:	83 ca 80             	or     $0xffffff80,%edx
  800420bbc9:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420bbcf:	48 b8 10 d9 20 04 80 	movabs $0x800420d910,%rax
  800420bbd6:	00 00 00 
  800420bbd9:	48 c1 e8 10          	shr    $0x10,%rax
  800420bbdd:	89 c2                	mov    %eax,%edx
  800420bbdf:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bbe6:	00 00 00 
  800420bbe9:	66 89 90 86 02 00 00 	mov    %dx,0x286(%rax)
  800420bbf0:	48 b8 10 d9 20 04 80 	movabs $0x800420d910,%rax
  800420bbf7:	00 00 00 
  800420bbfa:	48 c1 e8 20          	shr    $0x20,%rax
  800420bbfe:	89 c2                	mov    %eax,%edx
  800420bc00:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bc07:	00 00 00 
  800420bc0a:	89 90 88 02 00 00    	mov    %edx,0x288(%rax)
  800420bc10:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bc17:	00 00 00 
  800420bc1a:	c7 80 8c 02 00 00 00 	movl   $0x0,0x28c(%rax)
  800420bc21:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 9], 0, GD_KT, &Xirq9, 0);
  800420bc24:	48 b8 16 d9 20 04 80 	movabs $0x800420d916,%rax
  800420bc2b:	00 00 00 
  800420bc2e:	89 c2                	mov    %eax,%edx
  800420bc30:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bc37:	00 00 00 
  800420bc3a:	66 89 90 90 02 00 00 	mov    %dx,0x290(%rax)
  800420bc41:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bc48:	00 00 00 
  800420bc4b:	66 c7 80 92 02 00 00 	movw   $0x8,0x292(%rax)
  800420bc52:	08 00 
  800420bc54:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bc5b:	00 00 00 
  800420bc5e:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420bc65:	83 e2 f8             	and    $0xfffffff8,%edx
  800420bc68:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420bc6e:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bc75:	00 00 00 
  800420bc78:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420bc7f:	83 e2 07             	and    $0x7,%edx
  800420bc82:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420bc88:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bc8f:	00 00 00 
  800420bc92:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420bc99:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bc9c:	83 ca 0e             	or     $0xe,%edx
  800420bc9f:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420bca5:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bcac:	00 00 00 
  800420bcaf:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420bcb6:	83 e2 ef             	and    $0xffffffef,%edx
  800420bcb9:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420bcbf:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bcc6:	00 00 00 
  800420bcc9:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420bcd0:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bcd3:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420bcd9:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bce0:	00 00 00 
  800420bce3:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420bcea:	83 ca 80             	or     $0xffffff80,%edx
  800420bced:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420bcf3:	48 b8 16 d9 20 04 80 	movabs $0x800420d916,%rax
  800420bcfa:	00 00 00 
  800420bcfd:	48 c1 e8 10          	shr    $0x10,%rax
  800420bd01:	89 c2                	mov    %eax,%edx
  800420bd03:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bd0a:	00 00 00 
  800420bd0d:	66 89 90 96 02 00 00 	mov    %dx,0x296(%rax)
  800420bd14:	48 b8 16 d9 20 04 80 	movabs $0x800420d916,%rax
  800420bd1b:	00 00 00 
  800420bd1e:	48 c1 e8 20          	shr    $0x20,%rax
  800420bd22:	89 c2                	mov    %eax,%edx
  800420bd24:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bd2b:	00 00 00 
  800420bd2e:	89 90 98 02 00 00    	mov    %edx,0x298(%rax)
  800420bd34:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bd3b:	00 00 00 
  800420bd3e:	c7 80 9c 02 00 00 00 	movl   $0x0,0x29c(%rax)
  800420bd45:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 10], 0, GD_KT, &Xirq10, 0);
  800420bd48:	48 b8 1c d9 20 04 80 	movabs $0x800420d91c,%rax
  800420bd4f:	00 00 00 
  800420bd52:	89 c2                	mov    %eax,%edx
  800420bd54:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bd5b:	00 00 00 
  800420bd5e:	66 89 90 a0 02 00 00 	mov    %dx,0x2a0(%rax)
  800420bd65:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bd6c:	00 00 00 
  800420bd6f:	66 c7 80 a2 02 00 00 	movw   $0x8,0x2a2(%rax)
  800420bd76:	08 00 
  800420bd78:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bd7f:	00 00 00 
  800420bd82:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420bd89:	83 e2 f8             	and    $0xfffffff8,%edx
  800420bd8c:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420bd92:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bd99:	00 00 00 
  800420bd9c:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420bda3:	83 e2 07             	and    $0x7,%edx
  800420bda6:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420bdac:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bdb3:	00 00 00 
  800420bdb6:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420bdbd:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bdc0:	83 ca 0e             	or     $0xe,%edx
  800420bdc3:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420bdc9:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bdd0:	00 00 00 
  800420bdd3:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420bdda:	83 e2 ef             	and    $0xffffffef,%edx
  800420bddd:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420bde3:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bdea:	00 00 00 
  800420bded:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420bdf4:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bdf7:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420bdfd:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420be04:	00 00 00 
  800420be07:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420be0e:	83 ca 80             	or     $0xffffff80,%edx
  800420be11:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420be17:	48 b8 1c d9 20 04 80 	movabs $0x800420d91c,%rax
  800420be1e:	00 00 00 
  800420be21:	48 c1 e8 10          	shr    $0x10,%rax
  800420be25:	89 c2                	mov    %eax,%edx
  800420be27:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420be2e:	00 00 00 
  800420be31:	66 89 90 a6 02 00 00 	mov    %dx,0x2a6(%rax)
  800420be38:	48 b8 1c d9 20 04 80 	movabs $0x800420d91c,%rax
  800420be3f:	00 00 00 
  800420be42:	48 c1 e8 20          	shr    $0x20,%rax
  800420be46:	89 c2                	mov    %eax,%edx
  800420be48:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420be4f:	00 00 00 
  800420be52:	89 90 a8 02 00 00    	mov    %edx,0x2a8(%rax)
  800420be58:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420be5f:	00 00 00 
  800420be62:	c7 80 ac 02 00 00 00 	movl   $0x0,0x2ac(%rax)
  800420be69:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 11], 0, GD_KT, &Xirq11, 0);
  800420be6c:	48 b8 22 d9 20 04 80 	movabs $0x800420d922,%rax
  800420be73:	00 00 00 
  800420be76:	89 c2                	mov    %eax,%edx
  800420be78:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420be7f:	00 00 00 
  800420be82:	66 89 90 b0 02 00 00 	mov    %dx,0x2b0(%rax)
  800420be89:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420be90:	00 00 00 
  800420be93:	66 c7 80 b2 02 00 00 	movw   $0x8,0x2b2(%rax)
  800420be9a:	08 00 
  800420be9c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bea3:	00 00 00 
  800420bea6:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420bead:	83 e2 f8             	and    $0xfffffff8,%edx
  800420beb0:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420beb6:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bebd:	00 00 00 
  800420bec0:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420bec7:	83 e2 07             	and    $0x7,%edx
  800420beca:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420bed0:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bed7:	00 00 00 
  800420beda:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420bee1:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bee4:	83 ca 0e             	or     $0xe,%edx
  800420bee7:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420beed:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bef4:	00 00 00 
  800420bef7:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420befe:	83 e2 ef             	and    $0xffffffef,%edx
  800420bf01:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420bf07:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bf0e:	00 00 00 
  800420bf11:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420bf18:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bf1b:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420bf21:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bf28:	00 00 00 
  800420bf2b:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420bf32:	83 ca 80             	or     $0xffffff80,%edx
  800420bf35:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420bf3b:	48 b8 22 d9 20 04 80 	movabs $0x800420d922,%rax
  800420bf42:	00 00 00 
  800420bf45:	48 c1 e8 10          	shr    $0x10,%rax
  800420bf49:	89 c2                	mov    %eax,%edx
  800420bf4b:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bf52:	00 00 00 
  800420bf55:	66 89 90 b6 02 00 00 	mov    %dx,0x2b6(%rax)
  800420bf5c:	48 b8 22 d9 20 04 80 	movabs $0x800420d922,%rax
  800420bf63:	00 00 00 
  800420bf66:	48 c1 e8 20          	shr    $0x20,%rax
  800420bf6a:	89 c2                	mov    %eax,%edx
  800420bf6c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bf73:	00 00 00 
  800420bf76:	89 90 b8 02 00 00    	mov    %edx,0x2b8(%rax)
  800420bf7c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bf83:	00 00 00 
  800420bf86:	c7 80 bc 02 00 00 00 	movl   $0x0,0x2bc(%rax)
  800420bf8d:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 12], 0, GD_KT, &Xirq12, 0);
  800420bf90:	48 b8 28 d9 20 04 80 	movabs $0x800420d928,%rax
  800420bf97:	00 00 00 
  800420bf9a:	89 c2                	mov    %eax,%edx
  800420bf9c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bfa3:	00 00 00 
  800420bfa6:	66 89 90 c0 02 00 00 	mov    %dx,0x2c0(%rax)
  800420bfad:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bfb4:	00 00 00 
  800420bfb7:	66 c7 80 c2 02 00 00 	movw   $0x8,0x2c2(%rax)
  800420bfbe:	08 00 
  800420bfc0:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bfc7:	00 00 00 
  800420bfca:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420bfd1:	83 e2 f8             	and    $0xfffffff8,%edx
  800420bfd4:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420bfda:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bfe1:	00 00 00 
  800420bfe4:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420bfeb:	83 e2 07             	and    $0x7,%edx
  800420bfee:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420bff4:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420bffb:	00 00 00 
  800420bffe:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420c005:	83 e2 f0             	and    $0xfffffff0,%edx
  800420c008:	83 ca 0e             	or     $0xe,%edx
  800420c00b:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420c011:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c018:	00 00 00 
  800420c01b:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420c022:	83 e2 ef             	and    $0xffffffef,%edx
  800420c025:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420c02b:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c032:	00 00 00 
  800420c035:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420c03c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420c03f:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420c045:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c04c:	00 00 00 
  800420c04f:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420c056:	83 ca 80             	or     $0xffffff80,%edx
  800420c059:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420c05f:	48 b8 28 d9 20 04 80 	movabs $0x800420d928,%rax
  800420c066:	00 00 00 
  800420c069:	48 c1 e8 10          	shr    $0x10,%rax
  800420c06d:	89 c2                	mov    %eax,%edx
  800420c06f:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c076:	00 00 00 
  800420c079:	66 89 90 c6 02 00 00 	mov    %dx,0x2c6(%rax)
  800420c080:	48 b8 28 d9 20 04 80 	movabs $0x800420d928,%rax
  800420c087:	00 00 00 
  800420c08a:	48 c1 e8 20          	shr    $0x20,%rax
  800420c08e:	89 c2                	mov    %eax,%edx
  800420c090:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c097:	00 00 00 
  800420c09a:	89 90 c8 02 00 00    	mov    %edx,0x2c8(%rax)
  800420c0a0:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c0a7:	00 00 00 
  800420c0aa:	c7 80 cc 02 00 00 00 	movl   $0x0,0x2cc(%rax)
  800420c0b1:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 13], 0, GD_KT, &Xirq13, 0);
  800420c0b4:	48 b8 2e d9 20 04 80 	movabs $0x800420d92e,%rax
  800420c0bb:	00 00 00 
  800420c0be:	89 c2                	mov    %eax,%edx
  800420c0c0:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c0c7:	00 00 00 
  800420c0ca:	66 89 90 d0 02 00 00 	mov    %dx,0x2d0(%rax)
  800420c0d1:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c0d8:	00 00 00 
  800420c0db:	66 c7 80 d2 02 00 00 	movw   $0x8,0x2d2(%rax)
  800420c0e2:	08 00 
  800420c0e4:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c0eb:	00 00 00 
  800420c0ee:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420c0f5:	83 e2 f8             	and    $0xfffffff8,%edx
  800420c0f8:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420c0fe:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c105:	00 00 00 
  800420c108:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420c10f:	83 e2 07             	and    $0x7,%edx
  800420c112:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420c118:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c11f:	00 00 00 
  800420c122:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420c129:	83 e2 f0             	and    $0xfffffff0,%edx
  800420c12c:	83 ca 0e             	or     $0xe,%edx
  800420c12f:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420c135:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c13c:	00 00 00 
  800420c13f:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420c146:	83 e2 ef             	and    $0xffffffef,%edx
  800420c149:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420c14f:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c156:	00 00 00 
  800420c159:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420c160:	83 e2 9f             	and    $0xffffff9f,%edx
  800420c163:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420c169:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c170:	00 00 00 
  800420c173:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420c17a:	83 ca 80             	or     $0xffffff80,%edx
  800420c17d:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420c183:	48 b8 2e d9 20 04 80 	movabs $0x800420d92e,%rax
  800420c18a:	00 00 00 
  800420c18d:	48 c1 e8 10          	shr    $0x10,%rax
  800420c191:	89 c2                	mov    %eax,%edx
  800420c193:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c19a:	00 00 00 
  800420c19d:	66 89 90 d6 02 00 00 	mov    %dx,0x2d6(%rax)
  800420c1a4:	48 b8 2e d9 20 04 80 	movabs $0x800420d92e,%rax
  800420c1ab:	00 00 00 
  800420c1ae:	48 c1 e8 20          	shr    $0x20,%rax
  800420c1b2:	89 c2                	mov    %eax,%edx
  800420c1b4:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c1bb:	00 00 00 
  800420c1be:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%rax)
  800420c1c4:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c1cb:	00 00 00 
  800420c1ce:	c7 80 dc 02 00 00 00 	movl   $0x0,0x2dc(%rax)
  800420c1d5:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 14], 0, GD_KT, &Xirq14, 0);
  800420c1d8:	48 b8 34 d9 20 04 80 	movabs $0x800420d934,%rax
  800420c1df:	00 00 00 
  800420c1e2:	89 c2                	mov    %eax,%edx
  800420c1e4:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c1eb:	00 00 00 
  800420c1ee:	66 89 90 e0 02 00 00 	mov    %dx,0x2e0(%rax)
  800420c1f5:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c1fc:	00 00 00 
  800420c1ff:	66 c7 80 e2 02 00 00 	movw   $0x8,0x2e2(%rax)
  800420c206:	08 00 
  800420c208:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c20f:	00 00 00 
  800420c212:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420c219:	83 e2 f8             	and    $0xfffffff8,%edx
  800420c21c:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420c222:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c229:	00 00 00 
  800420c22c:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420c233:	83 e2 07             	and    $0x7,%edx
  800420c236:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420c23c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c243:	00 00 00 
  800420c246:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420c24d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420c250:	83 ca 0e             	or     $0xe,%edx
  800420c253:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420c259:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c260:	00 00 00 
  800420c263:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420c26a:	83 e2 ef             	and    $0xffffffef,%edx
  800420c26d:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420c273:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c27a:	00 00 00 
  800420c27d:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420c284:	83 e2 9f             	and    $0xffffff9f,%edx
  800420c287:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420c28d:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c294:	00 00 00 
  800420c297:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420c29e:	83 ca 80             	or     $0xffffff80,%edx
  800420c2a1:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420c2a7:	48 b8 34 d9 20 04 80 	movabs $0x800420d934,%rax
  800420c2ae:	00 00 00 
  800420c2b1:	48 c1 e8 10          	shr    $0x10,%rax
  800420c2b5:	89 c2                	mov    %eax,%edx
  800420c2b7:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c2be:	00 00 00 
  800420c2c1:	66 89 90 e6 02 00 00 	mov    %dx,0x2e6(%rax)
  800420c2c8:	48 b8 34 d9 20 04 80 	movabs $0x800420d934,%rax
  800420c2cf:	00 00 00 
  800420c2d2:	48 c1 e8 20          	shr    $0x20,%rax
  800420c2d6:	89 c2                	mov    %eax,%edx
  800420c2d8:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c2df:	00 00 00 
  800420c2e2:	89 90 e8 02 00 00    	mov    %edx,0x2e8(%rax)
  800420c2e8:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c2ef:	00 00 00 
  800420c2f2:	c7 80 ec 02 00 00 00 	movl   $0x0,0x2ec(%rax)
  800420c2f9:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + 15], 0, GD_KT, &Xirq15, 0);
  800420c2fc:	48 b8 3a d9 20 04 80 	movabs $0x800420d93a,%rax
  800420c303:	00 00 00 
  800420c306:	89 c2                	mov    %eax,%edx
  800420c308:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c30f:	00 00 00 
  800420c312:	66 89 90 f0 02 00 00 	mov    %dx,0x2f0(%rax)
  800420c319:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c320:	00 00 00 
  800420c323:	66 c7 80 f2 02 00 00 	movw   $0x8,0x2f2(%rax)
  800420c32a:	08 00 
  800420c32c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c333:	00 00 00 
  800420c336:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420c33d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420c340:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420c346:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c34d:	00 00 00 
  800420c350:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420c357:	83 e2 07             	and    $0x7,%edx
  800420c35a:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420c360:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c367:	00 00 00 
  800420c36a:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420c371:	83 e2 f0             	and    $0xfffffff0,%edx
  800420c374:	83 ca 0e             	or     $0xe,%edx
  800420c377:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420c37d:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c384:	00 00 00 
  800420c387:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420c38e:	83 e2 ef             	and    $0xffffffef,%edx
  800420c391:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420c397:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c39e:	00 00 00 
  800420c3a1:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420c3a8:	83 e2 9f             	and    $0xffffff9f,%edx
  800420c3ab:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420c3b1:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c3b8:	00 00 00 
  800420c3bb:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420c3c2:	83 ca 80             	or     $0xffffff80,%edx
  800420c3c5:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420c3cb:	48 b8 3a d9 20 04 80 	movabs $0x800420d93a,%rax
  800420c3d2:	00 00 00 
  800420c3d5:	48 c1 e8 10          	shr    $0x10,%rax
  800420c3d9:	89 c2                	mov    %eax,%edx
  800420c3db:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c3e2:	00 00 00 
  800420c3e5:	66 89 90 f6 02 00 00 	mov    %dx,0x2f6(%rax)
  800420c3ec:	48 b8 3a d9 20 04 80 	movabs $0x800420d93a,%rax
  800420c3f3:	00 00 00 
  800420c3f6:	48 c1 e8 20          	shr    $0x20,%rax
  800420c3fa:	89 c2                	mov    %eax,%edx
  800420c3fc:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c403:	00 00 00 
  800420c406:	89 90 f8 02 00 00    	mov    %edx,0x2f8(%rax)
  800420c40c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c413:	00 00 00 
  800420c416:	c7 80 fc 02 00 00 00 	movl   $0x0,0x2fc(%rax)
  800420c41d:	00 00 00 


	// Use DPL=3 here because system calls are explicitly invoked
	// by the user process (with "int $T_SYSCALL").
	SETGATE(idt[T_SYSCALL], 0, GD_KT, &Xsyscall, 3);
  800420c420:	48 b8 40 d9 20 04 80 	movabs $0x800420d940,%rax
  800420c427:	00 00 00 
  800420c42a:	89 c2                	mov    %eax,%edx
  800420c42c:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c433:	00 00 00 
  800420c436:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  800420c43d:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c444:	00 00 00 
  800420c447:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  800420c44e:	08 00 
  800420c450:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c457:	00 00 00 
  800420c45a:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420c461:	83 e2 f8             	and    $0xfffffff8,%edx
  800420c464:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420c46a:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c471:	00 00 00 
  800420c474:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420c47b:	83 e2 07             	and    $0x7,%edx
  800420c47e:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420c484:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c48b:	00 00 00 
  800420c48e:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420c495:	83 e2 f0             	and    $0xfffffff0,%edx
  800420c498:	83 ca 0e             	or     $0xe,%edx
  800420c49b:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420c4a1:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c4a8:	00 00 00 
  800420c4ab:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420c4b2:	83 e2 ef             	and    $0xffffffef,%edx
  800420c4b5:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420c4bb:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c4c2:	00 00 00 
  800420c4c5:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420c4cc:	83 ca 60             	or     $0x60,%edx
  800420c4cf:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420c4d5:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c4dc:	00 00 00 
  800420c4df:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420c4e6:	83 ca 80             	or     $0xffffff80,%edx
  800420c4e9:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420c4ef:	48 b8 40 d9 20 04 80 	movabs $0x800420d940,%rax
  800420c4f6:	00 00 00 
  800420c4f9:	48 c1 e8 10          	shr    $0x10,%rax
  800420c4fd:	89 c2                	mov    %eax,%edx
  800420c4ff:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c506:	00 00 00 
  800420c509:	66 89 90 06 03 00 00 	mov    %dx,0x306(%rax)
  800420c510:	48 b8 40 d9 20 04 80 	movabs $0x800420d940,%rax
  800420c517:	00 00 00 
  800420c51a:	48 c1 e8 20          	shr    $0x20,%rax
  800420c51e:	89 c2                	mov    %eax,%edx
  800420c520:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c527:	00 00 00 
  800420c52a:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  800420c530:	48 b8 80 02 4e 04 80 	movabs $0x80044e0280,%rax
  800420c537:	00 00 00 
  800420c53a:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  800420c541:	00 00 00 

	idt_pd.pd_lim = sizeof(idt)-1;
  800420c544:	48 b8 80 12 4e 04 80 	movabs $0x80044e1280,%rax
  800420c54b:	00 00 00 
  800420c54e:	66 c7 00 ff 0f       	movw   $0xfff,(%rax)
	idt_pd.pd_base = (uint64_t)idt;
  800420c553:	48 ba 80 02 4e 04 80 	movabs $0x80044e0280,%rdx
  800420c55a:	00 00 00 
  800420c55d:	48 b8 80 12 4e 04 80 	movabs $0x80044e1280,%rax
  800420c564:	00 00 00 
  800420c567:	48 89 50 02          	mov    %rdx,0x2(%rax)
	// Per-CPU setup
	trap_init_percpu();
  800420c56b:	48 b8 7a c5 20 04 80 	movabs $0x800420c57a,%rax
  800420c572:	00 00 00 
  800420c575:	ff d0                	callq  *%rax
}
  800420c577:	90                   	nop
  800420c578:	c9                   	leaveq 
  800420c579:	c3                   	retq   

000000800420c57a <trap_init_percpu>:

// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
  800420c57a:	55                   	push   %rbp
  800420c57b:	48 89 e5             	mov    %rsp,%rbp
  800420c57e:	53                   	push   %rbx
  800420c57f:	48 83 ec 18          	sub    $0x18,%rsp
	// wrong, you may not get a fault until you try to return from
	// user space on that CPU.
	//
	// LAB 4: Your code here:

	int gd_tss = (GD_TSS0 >> 3) + cpunum()*2;
  800420c583:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c58a:	00 00 00 
  800420c58d:	ff d0                	callq  *%rax
  800420c58f:	01 c0                	add    %eax,%eax
  800420c591:	83 c0 05             	add    $0x5,%eax
  800420c594:	89 45 ec             	mov    %eax,-0x14(%rbp)

	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP 
  800420c597:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c59e:	00 00 00 
  800420c5a1:	ff d0                	callq  *%rax
  800420c5a3:	89 c3                	mov    %eax,%ebx
		- (KSTKSIZE + KSTKGAP) * cpunum();
  800420c5a5:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c5ac:	00 00 00 
  800420c5af:	ff d0                	callq  *%rax
  800420c5b1:	89 c2                	mov    %eax,%edx
  800420c5b3:	89 d0                	mov    %edx,%eax
  800420c5b5:	01 c0                	add    %eax,%eax
  800420c5b7:	01 d0                	add    %edx,%eax
  800420c5b9:	c1 e0 0f             	shl    $0xf,%eax
  800420c5bc:	48 98                	cltq   
  800420c5be:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420c5c5:	00 00 00 
  800420c5c8:	48 29 c2             	sub    %rax,%rdx
  800420c5cb:	48 89 d0             	mov    %rdx,%rax
	//
	// LAB 4: Your code here:

	int gd_tss = (GD_TSS0 >> 3) + cpunum()*2;

	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP 
  800420c5ce:	48 89 c6             	mov    %rax,%rsi
  800420c5d1:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420c5d8:	00 00 00 
  800420c5db:	48 63 c3             	movslq %ebx,%rax
  800420c5de:	48 c1 e0 03          	shl    $0x3,%rax
  800420c5e2:	48 89 c1             	mov    %rax,%rcx
  800420c5e5:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c5e9:	48 01 c8             	add    %rcx,%rax
  800420c5ec:	48 01 d0             	add    %rdx,%rax
  800420c5ef:	48 83 c0 10          	add    $0x10,%rax
  800420c5f3:	48 89 70 04          	mov    %rsi,0x4(%rax)
		- (KSTKSIZE + KSTKGAP) * cpunum();

	SETTSS((struct SystemSegdesc64 *)((gdt_pd>>16)+40+cpunum()*16),STS_T64A, (uint64_t) (&thiscpu->cpu_ts),sizeof(struct Taskstate), 0);
  800420c5f7:	48 b8 68 66 23 04 80 	movabs $0x8004236668,%rax
  800420c5fe:	00 00 00 
  800420c601:	48 8b 00             	mov    (%rax),%rax
  800420c604:	48 c1 f8 10          	sar    $0x10,%rax
  800420c608:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c60c:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c613:	00 00 00 
  800420c616:	ff d0                	callq  *%rax
  800420c618:	c1 e0 04             	shl    $0x4,%eax
  800420c61b:	48 98                	cltq   
  800420c61d:	48 01 d8             	add    %rbx,%rax
  800420c620:	66 c7 00 68 00       	movw   $0x68,(%rax)
  800420c625:	48 b8 68 66 23 04 80 	movabs $0x8004236668,%rax
  800420c62c:	00 00 00 
  800420c62f:	48 8b 00             	mov    (%rax),%rax
  800420c632:	48 c1 f8 10          	sar    $0x10,%rax
  800420c636:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c63a:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c641:	00 00 00 
  800420c644:	ff d0                	callq  *%rax
  800420c646:	c1 e0 04             	shl    $0x4,%eax
  800420c649:	48 98                	cltq   
  800420c64b:	48 01 d8             	add    %rbx,%rax
  800420c64e:	48 89 c3             	mov    %rax,%rbx
  800420c651:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c658:	00 00 00 
  800420c65b:	ff d0                	callq  *%rax
  800420c65d:	48 98                	cltq   
  800420c65f:	48 c1 e0 03          	shl    $0x3,%rax
  800420c663:	48 89 c2             	mov    %rax,%rdx
  800420c666:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c66a:	48 01 d0             	add    %rdx,%rax
  800420c66d:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420c671:	48 b8 20 10 6e 04 80 	movabs $0x80046e1020,%rax
  800420c678:	00 00 00 
  800420c67b:	48 01 d0             	add    %rdx,%rax
  800420c67e:	66 89 43 02          	mov    %ax,0x2(%rbx)
  800420c682:	48 b8 68 66 23 04 80 	movabs $0x8004236668,%rax
  800420c689:	00 00 00 
  800420c68c:	48 8b 00             	mov    (%rax),%rax
  800420c68f:	48 c1 f8 10          	sar    $0x10,%rax
  800420c693:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c697:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c69e:	00 00 00 
  800420c6a1:	ff d0                	callq  *%rax
  800420c6a3:	c1 e0 04             	shl    $0x4,%eax
  800420c6a6:	48 98                	cltq   
  800420c6a8:	48 01 d8             	add    %rbx,%rax
  800420c6ab:	48 89 c3             	mov    %rax,%rbx
  800420c6ae:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c6b5:	00 00 00 
  800420c6b8:	ff d0                	callq  *%rax
  800420c6ba:	48 98                	cltq   
  800420c6bc:	48 c1 e0 03          	shl    $0x3,%rax
  800420c6c0:	48 89 c2             	mov    %rax,%rdx
  800420c6c3:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c6c7:	48 01 d0             	add    %rdx,%rax
  800420c6ca:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420c6ce:	48 b8 20 10 6e 04 80 	movabs $0x80046e1020,%rax
  800420c6d5:	00 00 00 
  800420c6d8:	48 01 d0             	add    %rdx,%rax
  800420c6db:	48 c1 e8 10          	shr    $0x10,%rax
  800420c6df:	88 43 04             	mov    %al,0x4(%rbx)
  800420c6e2:	48 b8 68 66 23 04 80 	movabs $0x8004236668,%rax
  800420c6e9:	00 00 00 
  800420c6ec:	48 8b 00             	mov    (%rax),%rax
  800420c6ef:	48 c1 f8 10          	sar    $0x10,%rax
  800420c6f3:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c6f7:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c6fe:	00 00 00 
  800420c701:	ff d0                	callq  *%rax
  800420c703:	c1 e0 04             	shl    $0x4,%eax
  800420c706:	48 98                	cltq   
  800420c708:	48 01 d8             	add    %rbx,%rax
  800420c70b:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420c70f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420c712:	83 ca 09             	or     $0x9,%edx
  800420c715:	88 50 05             	mov    %dl,0x5(%rax)
  800420c718:	48 b8 68 66 23 04 80 	movabs $0x8004236668,%rax
  800420c71f:	00 00 00 
  800420c722:	48 8b 00             	mov    (%rax),%rax
  800420c725:	48 c1 f8 10          	sar    $0x10,%rax
  800420c729:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c72d:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c734:	00 00 00 
  800420c737:	ff d0                	callq  *%rax
  800420c739:	c1 e0 04             	shl    $0x4,%eax
  800420c73c:	48 98                	cltq   
  800420c73e:	48 01 d8             	add    %rbx,%rax
  800420c741:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420c745:	83 e2 ef             	and    $0xffffffef,%edx
  800420c748:	88 50 05             	mov    %dl,0x5(%rax)
  800420c74b:	48 b8 68 66 23 04 80 	movabs $0x8004236668,%rax
  800420c752:	00 00 00 
  800420c755:	48 8b 00             	mov    (%rax),%rax
  800420c758:	48 c1 f8 10          	sar    $0x10,%rax
  800420c75c:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c760:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c767:	00 00 00 
  800420c76a:	ff d0                	callq  *%rax
  800420c76c:	c1 e0 04             	shl    $0x4,%eax
  800420c76f:	48 98                	cltq   
  800420c771:	48 01 d8             	add    %rbx,%rax
  800420c774:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420c778:	83 e2 9f             	and    $0xffffff9f,%edx
  800420c77b:	88 50 05             	mov    %dl,0x5(%rax)
  800420c77e:	48 b8 68 66 23 04 80 	movabs $0x8004236668,%rax
  800420c785:	00 00 00 
  800420c788:	48 8b 00             	mov    (%rax),%rax
  800420c78b:	48 c1 f8 10          	sar    $0x10,%rax
  800420c78f:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c793:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c79a:	00 00 00 
  800420c79d:	ff d0                	callq  *%rax
  800420c79f:	c1 e0 04             	shl    $0x4,%eax
  800420c7a2:	48 98                	cltq   
  800420c7a4:	48 01 d8             	add    %rbx,%rax
  800420c7a7:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420c7ab:	83 ca 80             	or     $0xffffff80,%edx
  800420c7ae:	88 50 05             	mov    %dl,0x5(%rax)
  800420c7b1:	48 b8 68 66 23 04 80 	movabs $0x8004236668,%rax
  800420c7b8:	00 00 00 
  800420c7bb:	48 8b 00             	mov    (%rax),%rax
  800420c7be:	48 c1 f8 10          	sar    $0x10,%rax
  800420c7c2:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c7c6:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c7cd:	00 00 00 
  800420c7d0:	ff d0                	callq  *%rax
  800420c7d2:	c1 e0 04             	shl    $0x4,%eax
  800420c7d5:	48 98                	cltq   
  800420c7d7:	48 01 d8             	add    %rbx,%rax
  800420c7da:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c7de:	83 e2 f0             	and    $0xfffffff0,%edx
  800420c7e1:	88 50 06             	mov    %dl,0x6(%rax)
  800420c7e4:	48 b8 68 66 23 04 80 	movabs $0x8004236668,%rax
  800420c7eb:	00 00 00 
  800420c7ee:	48 8b 00             	mov    (%rax),%rax
  800420c7f1:	48 c1 f8 10          	sar    $0x10,%rax
  800420c7f5:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c7f9:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c800:	00 00 00 
  800420c803:	ff d0                	callq  *%rax
  800420c805:	c1 e0 04             	shl    $0x4,%eax
  800420c808:	48 98                	cltq   
  800420c80a:	48 01 d8             	add    %rbx,%rax
  800420c80d:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c811:	83 e2 ef             	and    $0xffffffef,%edx
  800420c814:	88 50 06             	mov    %dl,0x6(%rax)
  800420c817:	48 b8 68 66 23 04 80 	movabs $0x8004236668,%rax
  800420c81e:	00 00 00 
  800420c821:	48 8b 00             	mov    (%rax),%rax
  800420c824:	48 c1 f8 10          	sar    $0x10,%rax
  800420c828:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c82c:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c833:	00 00 00 
  800420c836:	ff d0                	callq  *%rax
  800420c838:	c1 e0 04             	shl    $0x4,%eax
  800420c83b:	48 98                	cltq   
  800420c83d:	48 01 d8             	add    %rbx,%rax
  800420c840:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c844:	83 e2 9f             	and    $0xffffff9f,%edx
  800420c847:	88 50 06             	mov    %dl,0x6(%rax)
  800420c84a:	48 b8 68 66 23 04 80 	movabs $0x8004236668,%rax
  800420c851:	00 00 00 
  800420c854:	48 8b 00             	mov    (%rax),%rax
  800420c857:	48 c1 f8 10          	sar    $0x10,%rax
  800420c85b:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c85f:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c866:	00 00 00 
  800420c869:	ff d0                	callq  *%rax
  800420c86b:	c1 e0 04             	shl    $0x4,%eax
  800420c86e:	48 98                	cltq   
  800420c870:	48 01 d8             	add    %rbx,%rax
  800420c873:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c877:	83 e2 7f             	and    $0x7f,%edx
  800420c87a:	88 50 06             	mov    %dl,0x6(%rax)
  800420c87d:	48 b8 68 66 23 04 80 	movabs $0x8004236668,%rax
  800420c884:	00 00 00 
  800420c887:	48 8b 00             	mov    (%rax),%rax
  800420c88a:	48 c1 f8 10          	sar    $0x10,%rax
  800420c88e:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c892:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c899:	00 00 00 
  800420c89c:	ff d0                	callq  *%rax
  800420c89e:	c1 e0 04             	shl    $0x4,%eax
  800420c8a1:	48 98                	cltq   
  800420c8a3:	48 01 d8             	add    %rbx,%rax
  800420c8a6:	48 89 c3             	mov    %rax,%rbx
  800420c8a9:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c8b0:	00 00 00 
  800420c8b3:	ff d0                	callq  *%rax
  800420c8b5:	48 98                	cltq   
  800420c8b7:	48 c1 e0 03          	shl    $0x3,%rax
  800420c8bb:	48 89 c2             	mov    %rax,%rdx
  800420c8be:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c8c2:	48 01 d0             	add    %rdx,%rax
  800420c8c5:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420c8c9:	48 b8 20 10 6e 04 80 	movabs $0x80046e1020,%rax
  800420c8d0:	00 00 00 
  800420c8d3:	48 01 d0             	add    %rdx,%rax
  800420c8d6:	48 c1 e8 18          	shr    $0x18,%rax
  800420c8da:	88 43 07             	mov    %al,0x7(%rbx)
  800420c8dd:	48 b8 68 66 23 04 80 	movabs $0x8004236668,%rax
  800420c8e4:	00 00 00 
  800420c8e7:	48 8b 00             	mov    (%rax),%rax
  800420c8ea:	48 c1 f8 10          	sar    $0x10,%rax
  800420c8ee:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c8f2:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c8f9:	00 00 00 
  800420c8fc:	ff d0                	callq  *%rax
  800420c8fe:	c1 e0 04             	shl    $0x4,%eax
  800420c901:	48 98                	cltq   
  800420c903:	48 01 d8             	add    %rbx,%rax
  800420c906:	48 89 c3             	mov    %rax,%rbx
  800420c909:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c910:	00 00 00 
  800420c913:	ff d0                	callq  *%rax
  800420c915:	48 98                	cltq   
  800420c917:	48 c1 e0 03          	shl    $0x3,%rax
  800420c91b:	48 89 c2             	mov    %rax,%rdx
  800420c91e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c922:	48 01 d0             	add    %rdx,%rax
  800420c925:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420c929:	48 b8 20 10 6e 04 80 	movabs $0x80046e1020,%rax
  800420c930:	00 00 00 
  800420c933:	48 01 d0             	add    %rdx,%rax
  800420c936:	48 c1 e8 20          	shr    $0x20,%rax
  800420c93a:	89 43 08             	mov    %eax,0x8(%rbx)
  800420c93d:	48 b8 68 66 23 04 80 	movabs $0x8004236668,%rax
  800420c944:	00 00 00 
  800420c947:	48 8b 00             	mov    (%rax),%rax
  800420c94a:	48 c1 f8 10          	sar    $0x10,%rax
  800420c94e:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c952:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c959:	00 00 00 
  800420c95c:	ff d0                	callq  *%rax
  800420c95e:	c1 e0 04             	shl    $0x4,%eax
  800420c961:	48 98                	cltq   
  800420c963:	48 01 d8             	add    %rbx,%rax
  800420c966:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
  800420c96a:	48 b8 68 66 23 04 80 	movabs $0x8004236668,%rax
  800420c971:	00 00 00 
  800420c974:	48 8b 00             	mov    (%rax),%rax
  800420c977:	48 c1 f8 10          	sar    $0x10,%rax
  800420c97b:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c97f:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c986:	00 00 00 
  800420c989:	ff d0                	callq  *%rax
  800420c98b:	c1 e0 04             	shl    $0x4,%eax
  800420c98e:	48 98                	cltq   
  800420c990:	48 01 d8             	add    %rbx,%rax
  800420c993:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
  800420c997:	48 b8 68 66 23 04 80 	movabs $0x8004236668,%rax
  800420c99e:	00 00 00 
  800420c9a1:	48 8b 00             	mov    (%rax),%rax
  800420c9a4:	48 c1 f8 10          	sar    $0x10,%rax
  800420c9a8:	48 8d 58 28          	lea    0x28(%rax),%rbx
  800420c9ac:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420c9b3:	00 00 00 
  800420c9b6:	ff d0                	callq  *%rax
  800420c9b8:	c1 e0 04             	shl    $0x4,%eax
  800420c9bb:	48 98                	cltq   
  800420c9bd:	48 01 d8             	add    %rbx,%rax
  800420c9c0:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)

	// Load the TSS
	ltr(gd_tss << 3);
  800420c9c6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c9c9:	c1 e0 03             	shl    $0x3,%eax
  800420c9cc:	0f b7 c0             	movzwl %ax,%eax
  800420c9cf:	66 89 45 ea          	mov    %ax,-0x16(%rbp)
	__asm __volatile("lgdt (%0)" : : "r" (p));
}
static __inline void
ltr(uint16_t sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
  800420c9d3:	0f b7 45 ea          	movzwl -0x16(%rbp),%eax
  800420c9d7:	0f 00 d8             	ltr    %ax
  800420c9da:	48 b8 80 12 4e 04 80 	movabs $0x80044e1280,%rax
  800420c9e1:	00 00 00 
  800420c9e4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}  

static __inline void
lidt(void *p)
{
	__asm __volatile("lidt (%0)" : : "r" (p));
  800420c9e8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c9ec:	0f 01 18             	lidt   (%rax)


	// Load the IDT
	lidt(&idt_pd);
}
  800420c9ef:	90                   	nop
  800420c9f0:	48 83 c4 18          	add    $0x18,%rsp
  800420c9f4:	5b                   	pop    %rbx
  800420c9f5:	5d                   	pop    %rbp
  800420c9f6:	c3                   	retq   

000000800420c9f7 <print_trapframe>:

void
print_trapframe(struct Trapframe *tf)
{
  800420c9f7:	55                   	push   %rbp
  800420c9f8:	48 89 e5             	mov    %rsp,%rbp
  800420c9fb:	48 83 ec 20          	sub    $0x20,%rsp
  800420c9ff:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
  800420ca03:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420ca0a:	00 00 00 
  800420ca0d:	ff d0                	callq  *%rax
  800420ca0f:	89 c2                	mov    %eax,%edx
  800420ca11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca15:	48 89 c6             	mov    %rax,%rsi
  800420ca18:	48 bf 2e 05 22 04 80 	movabs $0x800422052e,%rdi
  800420ca1f:	00 00 00 
  800420ca22:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ca27:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800420ca2e:	00 00 00 
  800420ca31:	ff d1                	callq  *%rcx

	print_regs(&tf->tf_regs);
  800420ca33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca37:	48 89 c7             	mov    %rax,%rdi
  800420ca3a:	48 b8 09 cd 20 04 80 	movabs $0x800420cd09,%rax
  800420ca41:	00 00 00 
  800420ca44:	ff d0                	callq  *%rax
	cprintf("  es   0x----%04x\n", tf->tf_es);
  800420ca46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca4a:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800420ca4e:	0f b7 c0             	movzwl %ax,%eax
  800420ca51:	89 c6                	mov    %eax,%esi
  800420ca53:	48 bf 4c 05 22 04 80 	movabs $0x800422054c,%rdi
  800420ca5a:	00 00 00 
  800420ca5d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ca62:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420ca69:	00 00 00 
  800420ca6c:	ff d2                	callq  *%rdx
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
  800420ca6e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca72:	0f b7 80 80 00 00 00 	movzwl 0x80(%rax),%eax
  800420ca79:	0f b7 c0             	movzwl %ax,%eax
  800420ca7c:	89 c6                	mov    %eax,%esi
  800420ca7e:	48 bf 5f 05 22 04 80 	movabs $0x800422055f,%rdi
  800420ca85:	00 00 00 
  800420ca88:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ca8d:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420ca94:	00 00 00 
  800420ca97:	ff d2                	callq  *%rdx
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
  800420ca99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca9d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420caa4:	89 c7                	mov    %eax,%edi
  800420caa6:	48 b8 05 9e 20 04 80 	movabs $0x8004209e05,%rax
  800420caad:	00 00 00 
  800420cab0:	ff d0                	callq  *%rax
  800420cab2:	48 89 c2             	mov    %rax,%rdx
  800420cab5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cab9:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420cac0:	48 89 c6             	mov    %rax,%rsi
  800420cac3:	48 bf 72 05 22 04 80 	movabs $0x8004220572,%rdi
  800420caca:	00 00 00 
  800420cacd:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cad2:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800420cad9:	00 00 00 
  800420cadc:	ff d1                	callq  *%rcx
	// If this trap was a page fault that just happened
	// (so %cr2 is meaningful), print the faulting linear address.
	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  800420cade:	48 b8 90 12 4e 04 80 	movabs $0x80044e1290,%rax
  800420cae5:	00 00 00 
  800420cae8:	48 8b 00             	mov    (%rax),%rax
  800420caeb:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420caef:	75 3a                	jne    800420cb2b <print_trapframe+0x134>
  800420caf1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420caf5:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420cafc:	48 83 f8 0e          	cmp    $0xe,%rax
  800420cb00:	75 29                	jne    800420cb2b <print_trapframe+0x134>

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420cb02:	0f 20 d0             	mov    %cr2,%rax
  800420cb05:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return val;
  800420cb09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
		cprintf("  cr2  0x%08x\n", rcr2());
  800420cb0d:	48 89 c6             	mov    %rax,%rsi
  800420cb10:	48 bf 84 05 22 04 80 	movabs $0x8004220584,%rdi
  800420cb17:	00 00 00 
  800420cb1a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cb1f:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420cb26:	00 00 00 
  800420cb29:	ff d2                	callq  *%rdx
	cprintf("  err  0x%08x", tf->tf_err);
  800420cb2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cb2f:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420cb36:	48 89 c6             	mov    %rax,%rsi
  800420cb39:	48 bf 93 05 22 04 80 	movabs $0x8004220593,%rdi
  800420cb40:	00 00 00 
  800420cb43:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cb48:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420cb4f:	00 00 00 
  800420cb52:	ff d2                	callq  *%rdx
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
  800420cb54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cb58:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420cb5f:	48 83 f8 0e          	cmp    $0xe,%rax
  800420cb63:	0f 85 9c 00 00 00    	jne    800420cc05 <print_trapframe+0x20e>
		cprintf(" [%s, %s, %s]\n",
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
  800420cb69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cb6d:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420cb74:	83 e0 01             	and    $0x1,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420cb77:	48 85 c0             	test   %rax,%rax
  800420cb7a:	74 0c                	je     800420cb88 <print_trapframe+0x191>
  800420cb7c:	48 b9 a1 05 22 04 80 	movabs $0x80042205a1,%rcx
  800420cb83:	00 00 00 
  800420cb86:	eb 0a                	jmp    800420cb92 <print_trapframe+0x19b>
  800420cb88:	48 b9 ac 05 22 04 80 	movabs $0x80042205ac,%rcx
  800420cb8f:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
  800420cb92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cb96:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420cb9d:	83 e0 02             	and    $0x2,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420cba0:	48 85 c0             	test   %rax,%rax
  800420cba3:	74 0c                	je     800420cbb1 <print_trapframe+0x1ba>
  800420cba5:	48 ba b8 05 22 04 80 	movabs $0x80042205b8,%rdx
  800420cbac:	00 00 00 
  800420cbaf:	eb 0a                	jmp    800420cbbb <print_trapframe+0x1c4>
  800420cbb1:	48 ba be 05 22 04 80 	movabs $0x80042205be,%rdx
  800420cbb8:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
  800420cbbb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cbbf:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420cbc6:	83 e0 04             	and    $0x4,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420cbc9:	48 85 c0             	test   %rax,%rax
  800420cbcc:	74 0c                	je     800420cbda <print_trapframe+0x1e3>
  800420cbce:	48 b8 c3 05 22 04 80 	movabs $0x80042205c3,%rax
  800420cbd5:	00 00 00 
  800420cbd8:	eb 0a                	jmp    800420cbe4 <print_trapframe+0x1ed>
  800420cbda:	48 b8 c8 05 22 04 80 	movabs $0x80042205c8,%rax
  800420cbe1:	00 00 00 
  800420cbe4:	48 89 c6             	mov    %rax,%rsi
  800420cbe7:	48 bf cf 05 22 04 80 	movabs $0x80042205cf,%rdi
  800420cbee:	00 00 00 
  800420cbf1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cbf6:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800420cbfd:	00 00 00 
  800420cc00:	41 ff d0             	callq  *%r8
  800420cc03:	eb 1b                	jmp    800420cc20 <print_trapframe+0x229>
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
	else
		cprintf("\n");
  800420cc05:	48 bf de 05 22 04 80 	movabs $0x80042205de,%rdi
  800420cc0c:	00 00 00 
  800420cc0f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cc14:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420cc1b:	00 00 00 
  800420cc1e:	ff d2                	callq  *%rdx
	cprintf("  rip  0x%08x\n", tf->tf_rip);
  800420cc20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cc24:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800420cc2b:	48 89 c6             	mov    %rax,%rsi
  800420cc2e:	48 bf e0 05 22 04 80 	movabs $0x80042205e0,%rdi
  800420cc35:	00 00 00 
  800420cc38:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cc3d:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420cc44:	00 00 00 
  800420cc47:	ff d2                	callq  *%rdx
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
  800420cc49:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cc4d:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420cc54:	0f b7 c0             	movzwl %ax,%eax
  800420cc57:	89 c6                	mov    %eax,%esi
  800420cc59:	48 bf ef 05 22 04 80 	movabs $0x80042205ef,%rdi
  800420cc60:	00 00 00 
  800420cc63:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cc68:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420cc6f:	00 00 00 
  800420cc72:	ff d2                	callq  *%rdx
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
  800420cc74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cc78:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420cc7f:	48 89 c6             	mov    %rax,%rsi
  800420cc82:	48 bf 02 06 22 04 80 	movabs $0x8004220602,%rdi
  800420cc89:	00 00 00 
  800420cc8c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cc91:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420cc98:	00 00 00 
  800420cc9b:	ff d2                	callq  *%rdx
	if ((tf->tf_cs & 3) != 0) {
  800420cc9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cca1:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420cca8:	0f b7 c0             	movzwl %ax,%eax
  800420ccab:	83 e0 03             	and    $0x3,%eax
  800420ccae:	85 c0                	test   %eax,%eax
  800420ccb0:	74 54                	je     800420cd06 <print_trapframe+0x30f>
		cprintf("  rsp  0x%08x\n", tf->tf_rsp);
  800420ccb2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ccb6:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420ccbd:	48 89 c6             	mov    %rax,%rsi
  800420ccc0:	48 bf 11 06 22 04 80 	movabs $0x8004220611,%rdi
  800420ccc7:	00 00 00 
  800420ccca:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cccf:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420ccd6:	00 00 00 
  800420ccd9:	ff d2                	callq  *%rdx
		cprintf("  ss   0x----%04x\n", tf->tf_ss);
  800420ccdb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ccdf:	0f b7 80 b8 00 00 00 	movzwl 0xb8(%rax),%eax
  800420cce6:	0f b7 c0             	movzwl %ax,%eax
  800420cce9:	89 c6                	mov    %eax,%esi
  800420cceb:	48 bf 20 06 22 04 80 	movabs $0x8004220620,%rdi
  800420ccf2:	00 00 00 
  800420ccf5:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ccfa:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420cd01:	00 00 00 
  800420cd04:	ff d2                	callq  *%rdx
	}
	//vmcs_dump_cpu();
}
  800420cd06:	90                   	nop
  800420cd07:	c9                   	leaveq 
  800420cd08:	c3                   	retq   

000000800420cd09 <print_regs>:

void
print_regs(struct PushRegs *regs)
{
  800420cd09:	55                   	push   %rbp
  800420cd0a:	48 89 e5             	mov    %rsp,%rbp
  800420cd0d:	48 83 ec 10          	sub    $0x10,%rsp
  800420cd11:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	cprintf("  r15  0x%08x\n", regs->reg_r15);
  800420cd15:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cd19:	48 8b 00             	mov    (%rax),%rax
  800420cd1c:	48 89 c6             	mov    %rax,%rsi
  800420cd1f:	48 bf 33 06 22 04 80 	movabs $0x8004220633,%rdi
  800420cd26:	00 00 00 
  800420cd29:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cd2e:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420cd35:	00 00 00 
  800420cd38:	ff d2                	callq  *%rdx
	cprintf("  r14  0x%08x\n", regs->reg_r14);
  800420cd3a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cd3e:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420cd42:	48 89 c6             	mov    %rax,%rsi
  800420cd45:	48 bf 42 06 22 04 80 	movabs $0x8004220642,%rdi
  800420cd4c:	00 00 00 
  800420cd4f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cd54:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420cd5b:	00 00 00 
  800420cd5e:	ff d2                	callq  *%rdx
	cprintf("  r13  0x%08x\n", regs->reg_r13);
  800420cd60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cd64:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420cd68:	48 89 c6             	mov    %rax,%rsi
  800420cd6b:	48 bf 51 06 22 04 80 	movabs $0x8004220651,%rdi
  800420cd72:	00 00 00 
  800420cd75:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cd7a:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420cd81:	00 00 00 
  800420cd84:	ff d2                	callq  *%rdx
	cprintf("  r12  0x%08x\n", regs->reg_r12);
  800420cd86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cd8a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420cd8e:	48 89 c6             	mov    %rax,%rsi
  800420cd91:	48 bf 60 06 22 04 80 	movabs $0x8004220660,%rdi
  800420cd98:	00 00 00 
  800420cd9b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cda0:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420cda7:	00 00 00 
  800420cdaa:	ff d2                	callq  *%rdx
	cprintf("  r11  0x%08x\n", regs->reg_r11);
  800420cdac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cdb0:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420cdb4:	48 89 c6             	mov    %rax,%rsi
  800420cdb7:	48 bf 6f 06 22 04 80 	movabs $0x800422066f,%rdi
  800420cdbe:	00 00 00 
  800420cdc1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cdc6:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420cdcd:	00 00 00 
  800420cdd0:	ff d2                	callq  *%rdx
	cprintf("  r10  0x%08x\n", regs->reg_r10);
  800420cdd2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cdd6:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420cdda:	48 89 c6             	mov    %rax,%rsi
  800420cddd:	48 bf 7e 06 22 04 80 	movabs $0x800422067e,%rdi
  800420cde4:	00 00 00 
  800420cde7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cdec:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420cdf3:	00 00 00 
  800420cdf6:	ff d2                	callq  *%rdx
	cprintf("  r9  0x%08x\n", regs->reg_r9);
  800420cdf8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cdfc:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420ce00:	48 89 c6             	mov    %rax,%rsi
  800420ce03:	48 bf 8d 06 22 04 80 	movabs $0x800422068d,%rdi
  800420ce0a:	00 00 00 
  800420ce0d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ce12:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420ce19:	00 00 00 
  800420ce1c:	ff d2                	callq  *%rdx
	cprintf("  r8  0x%08x\n", regs->reg_r8);
  800420ce1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ce22:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420ce26:	48 89 c6             	mov    %rax,%rsi
  800420ce29:	48 bf 9b 06 22 04 80 	movabs $0x800422069b,%rdi
  800420ce30:	00 00 00 
  800420ce33:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ce38:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420ce3f:	00 00 00 
  800420ce42:	ff d2                	callq  *%rdx
	cprintf("  rdi  0x%08x\n", regs->reg_rdi);
  800420ce44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ce48:	48 8b 40 48          	mov    0x48(%rax),%rax
  800420ce4c:	48 89 c6             	mov    %rax,%rsi
  800420ce4f:	48 bf a9 06 22 04 80 	movabs $0x80042206a9,%rdi
  800420ce56:	00 00 00 
  800420ce59:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ce5e:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420ce65:	00 00 00 
  800420ce68:	ff d2                	callq  *%rdx
	cprintf("  rsi  0x%08x\n", regs->reg_rsi);
  800420ce6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ce6e:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420ce72:	48 89 c6             	mov    %rax,%rsi
  800420ce75:	48 bf b8 06 22 04 80 	movabs $0x80042206b8,%rdi
  800420ce7c:	00 00 00 
  800420ce7f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ce84:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420ce8b:	00 00 00 
  800420ce8e:	ff d2                	callq  *%rdx
	cprintf("  rbp  0x%08x\n", regs->reg_rbp);
  800420ce90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ce94:	48 8b 40 50          	mov    0x50(%rax),%rax
  800420ce98:	48 89 c6             	mov    %rax,%rsi
  800420ce9b:	48 bf c7 06 22 04 80 	movabs $0x80042206c7,%rdi
  800420cea2:	00 00 00 
  800420cea5:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ceaa:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420ceb1:	00 00 00 
  800420ceb4:	ff d2                	callq  *%rdx
	cprintf("  rbx  0x%08x\n", regs->reg_rbx);
  800420ceb6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ceba:	48 8b 40 68          	mov    0x68(%rax),%rax
  800420cebe:	48 89 c6             	mov    %rax,%rsi
  800420cec1:	48 bf d6 06 22 04 80 	movabs $0x80042206d6,%rdi
  800420cec8:	00 00 00 
  800420cecb:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ced0:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420ced7:	00 00 00 
  800420ceda:	ff d2                	callq  *%rdx
	cprintf("  rdx  0x%08x\n", regs->reg_rdx);
  800420cedc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cee0:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420cee4:	48 89 c6             	mov    %rax,%rsi
  800420cee7:	48 bf e5 06 22 04 80 	movabs $0x80042206e5,%rdi
  800420ceee:	00 00 00 
  800420cef1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cef6:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420cefd:	00 00 00 
  800420cf00:	ff d2                	callq  *%rdx
	cprintf("  rcx  0x%08x\n", regs->reg_rcx);
  800420cf02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cf06:	48 8b 40 60          	mov    0x60(%rax),%rax
  800420cf0a:	48 89 c6             	mov    %rax,%rsi
  800420cf0d:	48 bf f4 06 22 04 80 	movabs $0x80042206f4,%rdi
  800420cf14:	00 00 00 
  800420cf17:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cf1c:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420cf23:	00 00 00 
  800420cf26:	ff d2                	callq  *%rdx
	cprintf("  rax  0x%08x\n", regs->reg_rax);
  800420cf28:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cf2c:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420cf30:	48 89 c6             	mov    %rax,%rsi
  800420cf33:	48 bf 03 07 22 04 80 	movabs $0x8004220703,%rdi
  800420cf3a:	00 00 00 
  800420cf3d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cf42:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420cf49:	00 00 00 
  800420cf4c:	ff d2                	callq  *%rdx
}
  800420cf4e:	90                   	nop
  800420cf4f:	c9                   	leaveq 
  800420cf50:	c3                   	retq   

000000800420cf51 <trap_dispatch>:

static void
trap_dispatch(struct Trapframe *tf)
{
  800420cf51:	55                   	push   %rbp
  800420cf52:	48 89 e5             	mov    %rsp,%rbp
  800420cf55:	48 83 ec 10          	sub    $0x10,%rsp
  800420cf59:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

	// Handle processor exceptions.
	// LAB 3: Your code here.

	if (tf->tf_trapno == T_PGFLT) {
  800420cf5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cf61:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420cf68:	48 83 f8 0e          	cmp    $0xe,%rax
  800420cf6c:	75 18                	jne    800420cf86 <trap_dispatch+0x35>
		page_fault_handler(tf);
  800420cf6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cf72:	48 89 c7             	mov    %rax,%rdi
  800420cf75:	48 b8 cf d4 20 04 80 	movabs $0x800420d4cf,%rax
  800420cf7c:	00 00 00 
  800420cf7f:	ff d0                	callq  *%rax
		return;
  800420cf81:	e9 ea 01 00 00       	jmpq   800420d170 <trap_dispatch+0x21f>
	}
	if (tf->tf_trapno == T_SYSCALL) {
  800420cf86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cf8a:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420cf91:	48 83 f8 30          	cmp    $0x30,%rax
  800420cf95:	75 55                	jne    800420cfec <trap_dispatch+0x9b>
		// handle system call
		tf->tf_regs.reg_rax =
			syscall(tf->tf_regs.reg_rax,
  800420cf97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cf9b:	4c 8b 40 40          	mov    0x40(%rax),%r8
  800420cf9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cfa3:	48 8b 78 48          	mov    0x48(%rax),%rdi
  800420cfa7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cfab:	48 8b 48 68          	mov    0x68(%rax),%rcx
  800420cfaf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cfb3:	48 8b 50 60          	mov    0x60(%rax),%rdx
  800420cfb7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cfbb:	48 8b 70 58          	mov    0x58(%rax),%rsi
  800420cfbf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cfc3:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420cfc7:	4d 89 c1             	mov    %r8,%r9
  800420cfca:	49 89 f8             	mov    %rdi,%r8
  800420cfcd:	48 89 c7             	mov    %rax,%rdi
  800420cfd0:	48 b8 21 f4 20 04 80 	movabs $0x800420f421,%rax
  800420cfd7:	00 00 00 
  800420cfda:	ff d0                	callq  *%rax
		page_fault_handler(tf);
		return;
	}
	if (tf->tf_trapno == T_SYSCALL) {
		// handle system call
		tf->tf_regs.reg_rax =
  800420cfdc:	48 89 c2             	mov    %rax,%rdx
  800420cfdf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cfe3:	48 89 50 70          	mov    %rdx,0x70(%rax)
				tf->tf_regs.reg_rdx,
				tf->tf_regs.reg_rcx,
				tf->tf_regs.reg_rbx,
				tf->tf_regs.reg_rdi,
				tf->tf_regs.reg_rsi);
		return;
  800420cfe7:	e9 84 01 00 00       	jmpq   800420d170 <trap_dispatch+0x21f>
	}
	if (tf->tf_trapno == T_BRKPT) {
  800420cfec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cff0:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420cff7:	48 83 f8 03          	cmp    $0x3,%rax
  800420cffb:	75 18                	jne    800420d015 <trap_dispatch+0xc4>
		// Invoke the kernel monitor.
		monitor(tf);
  800420cffd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d001:	48 89 c7             	mov    %rax,%rdi
  800420d004:	48 b8 73 1a 20 04 80 	movabs $0x8004201a73,%rax
  800420d00b:	00 00 00 
  800420d00e:	ff d0                	callq  *%rax
		return;
  800420d010:	e9 5b 01 00 00       	jmpq   800420d170 <trap_dispatch+0x21f>


	// Handle spurious interrupts
	// The hardware sometimes raises these because of noise on the
	// IRQ line or other reasons. We don't care.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
  800420d015:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d019:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420d020:	48 83 f8 27          	cmp    $0x27,%rax
  800420d024:	75 33                	jne    800420d059 <trap_dispatch+0x108>
		cprintf("Spurious interrupt on irq 7\n");
  800420d026:	48 bf 12 07 22 04 80 	movabs $0x8004220712,%rdi
  800420d02d:	00 00 00 
  800420d030:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d035:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420d03c:	00 00 00 
  800420d03f:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420d041:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d045:	48 89 c7             	mov    %rax,%rdi
  800420d048:	48 b8 f7 c9 20 04 80 	movabs $0x800420c9f7,%rax
  800420d04f:	00 00 00 
  800420d052:	ff d0                	callq  *%rax
		return;
  800420d054:	e9 17 01 00 00       	jmpq   800420d170 <trap_dispatch+0x21f>
	// Add time tick increment to clock interrupts.
	// Be careful! In multiprocessors, clock interrupts are
	// triggered on every CPU.
	// LAB 6: Your code here.

	if (tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER) {
  800420d059:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d05d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420d064:	48 83 f8 20          	cmp    $0x20,%rax
  800420d068:	75 34                	jne    800420d09e <trap_dispatch+0x14d>
		// irq 0 -- clock interrupt

		if (cpunum() == 0)
  800420d06a:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420d071:	00 00 00 
  800420d074:	ff d0                	callq  *%rax
  800420d076:	85 c0                	test   %eax,%eax
  800420d078:	75 0c                	jne    800420d086 <trap_dispatch+0x135>
			time_tick();
  800420d07a:	48 b8 6a 99 21 04 80 	movabs $0x800421996a,%rax
  800420d081:	00 00 00 
  800420d084:	ff d0                	callq  *%rax

		lapic_eoi();
  800420d086:	48 b8 32 81 21 04 80 	movabs $0x8004218132,%rax
  800420d08d:	00 00 00 
  800420d090:	ff d0                	callq  *%rax

		sched_yield();
  800420d092:	48 b8 a6 da 20 04 80 	movabs $0x800420daa6,%rax
  800420d099:	00 00 00 
  800420d09c:	ff d0                	callq  *%rax
	}

	// Handle keyboard and serial interrupts.
	// LAB 5: Your code here.

	if (tf->tf_trapno == IRQ_OFFSET + IRQ_KBD) {
  800420d09e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d0a2:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420d0a9:	48 83 f8 21          	cmp    $0x21,%rax
  800420d0ad:	75 11                	jne    800420d0c0 <trap_dispatch+0x16f>
		kbd_intr();
  800420d0af:	48 b8 e3 0f 20 04 80 	movabs $0x8004200fe3,%rax
  800420d0b6:	00 00 00 
  800420d0b9:	ff d0                	callq  *%rax
		return;
  800420d0bb:	e9 b0 00 00 00       	jmpq   800420d170 <trap_dispatch+0x21f>
	}
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SERIAL) {
  800420d0c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d0c4:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420d0cb:	48 83 f8 24          	cmp    $0x24,%rax
  800420d0cf:	75 11                	jne    800420d0e2 <trap_dispatch+0x191>
		serial_intr();
  800420d0d1:	48 b8 8e 07 20 04 80 	movabs $0x800420078e,%rax
  800420d0d8:	00 00 00 
  800420d0db:	ff d0                	callq  *%rax
		return;
  800420d0dd:	e9 8e 00 00 00       	jmpq   800420d170 <trap_dispatch+0x21f>
	}


	// Unexpected trap: The user process or the kernel has a bug.
	print_trapframe(tf);
  800420d0e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d0e6:	48 89 c7             	mov    %rax,%rdi
  800420d0e9:	48 b8 f7 c9 20 04 80 	movabs $0x800420c9f7,%rax
  800420d0f0:	00 00 00 
  800420d0f3:	ff d0                	callq  *%rax
	if (tf->tf_cs == GD_KT)
  800420d0f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d0f9:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420d100:	66 83 f8 08          	cmp    $0x8,%ax
  800420d104:	75 2a                	jne    800420d130 <trap_dispatch+0x1df>
		panic("unhandled trap in kernel");
  800420d106:	48 ba 2f 07 22 04 80 	movabs $0x800422072f,%rdx
  800420d10d:	00 00 00 
  800420d110:	be 48 01 00 00       	mov    $0x148,%esi
  800420d115:	48 bf 48 07 22 04 80 	movabs $0x8004220748,%rdi
  800420d11c:	00 00 00 
  800420d11f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d124:	48 b9 d3 04 20 04 80 	movabs $0x80042004d3,%rcx
  800420d12b:	00 00 00 
  800420d12e:	ff d1                	callq  *%rcx
	else {
		env_destroy(curenv);
  800420d130:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420d137:	00 00 00 
  800420d13a:	ff d0                	callq  *%rax
  800420d13c:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420d143:	00 00 00 
  800420d146:	48 98                	cltq   
  800420d148:	48 c1 e0 03          	shl    $0x3,%rax
  800420d14c:	48 89 c1             	mov    %rax,%rcx
  800420d14f:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d153:	48 01 c8             	add    %rcx,%rax
  800420d156:	48 01 d0             	add    %rdx,%rax
  800420d159:	48 83 c0 08          	add    $0x8,%rax
  800420d15d:	48 8b 00             	mov    (%rax),%rax
  800420d160:	48 89 c7             	mov    %rax,%rdi
  800420d163:	48 b8 81 95 20 04 80 	movabs $0x8004209581,%rax
  800420d16a:	00 00 00 
  800420d16d:	ff d0                	callq  *%rax
		return;
  800420d16f:	90                   	nop
	}
}
  800420d170:	c9                   	leaveq 
  800420d171:	c3                   	retq   

000000800420d172 <trap>:

void
trap(struct Trapframe *tf)
{
  800420d172:	55                   	push   %rbp
  800420d173:	48 89 e5             	mov    %rsp,%rbp
  800420d176:	48 83 ec 20          	sub    $0x20,%rsp
  800420d17a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//struct Trapframe *tf = &tf_;
	// The environment may have set DF and some versions
	// of GCC rely on DF being clear
	asm volatile("cld" ::: "cc");
  800420d17e:	fc                   	cld    


	// Halt the CPU if some other CPU has called panic()
	extern char *panicstr;
	if (panicstr)
  800420d17f:	48 b8 d8 f5 6d 04 80 	movabs $0x80046df5d8,%rax
  800420d186:	00 00 00 
  800420d189:	48 8b 00             	mov    (%rax),%rax
  800420d18c:	48 85 c0             	test   %rax,%rax
  800420d18f:	74 01                	je     800420d192 <trap+0x20>
		asm volatile("hlt");
  800420d191:	f4                   	hlt    

	// Re-acqurie the big kernel lock if we were halted in
	// sched_yield()
	if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
  800420d192:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420d199:	00 00 00 
  800420d19c:	ff d0                	callq  *%rax
  800420d19e:	48 98                	cltq   
  800420d1a0:	48 c1 e0 03          	shl    $0x3,%rax
  800420d1a4:	48 89 c2             	mov    %rax,%rdx
  800420d1a7:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d1ab:	48 01 d0             	add    %rdx,%rax
  800420d1ae:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420d1b5:	00 00 00 
  800420d1b8:	48 01 d0             	add    %rdx,%rax
  800420d1bb:	48 83 c0 04          	add    $0x4,%rax
  800420d1bf:	be 01 00 00 00       	mov    $0x1,%esi
  800420d1c4:	48 89 c7             	mov    %rax,%rdi
  800420d1c7:	48 b8 c3 9d 20 04 80 	movabs $0x8004209dc3,%rax
  800420d1ce:	00 00 00 
  800420d1d1:	ff d0                	callq  *%rax
  800420d1d3:	83 f8 02             	cmp    $0x2,%eax
  800420d1d6:	75 0c                	jne    800420d1e4 <trap+0x72>
		lock_kernel();
  800420d1d8:	48 b8 e8 9d 20 04 80 	movabs $0x8004209de8,%rax
  800420d1df:	00 00 00 
  800420d1e2:	ff d0                	callq  *%rax

static __inline uint64_t
read_eflags(void)
{
	uint64_t rflags;
	__asm __volatile("pushfq; popq %0" : "=r" (rflags));
  800420d1e4:	9c                   	pushfq 
  800420d1e5:	58                   	pop    %rax
  800420d1e6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return rflags;
  800420d1ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax

	// Check that interrupts are disabled.  If this assertion
	// fails, DO NOT be tempted to fix it by inserting a "cli" in
	// the interrupt path.
	assert(!(read_eflags() & FL_IF));
  800420d1ee:	25 00 02 00 00       	and    $0x200,%eax
  800420d1f3:	48 85 c0             	test   %rax,%rax
  800420d1f6:	74 35                	je     800420d22d <trap+0xbb>
  800420d1f8:	48 b9 54 07 22 04 80 	movabs $0x8004220754,%rcx
  800420d1ff:	00 00 00 
  800420d202:	48 ba 6d 07 22 04 80 	movabs $0x800422076d,%rdx
  800420d209:	00 00 00 
  800420d20c:	be 65 01 00 00       	mov    $0x165,%esi
  800420d211:	48 bf 48 07 22 04 80 	movabs $0x8004220748,%rdi
  800420d218:	00 00 00 
  800420d21b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d220:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420d227:	00 00 00 
  800420d22a:	41 ff d0             	callq  *%r8


	if ((tf->tf_cs & 3) == 3) {
  800420d22d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d231:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420d238:	0f b7 c0             	movzwl %ax,%eax
  800420d23b:	83 e0 03             	and    $0x3,%eax
  800420d23e:	83 f8 03             	cmp    $0x3,%eax
  800420d241:	0f 85 a9 01 00 00    	jne    800420d3f0 <trap+0x27e>

		// Acquire the big kernel lock before doing any
		// serious kernel work.
		// LAB 4: Your code here.

		lock_kernel();
  800420d247:	48 b8 e8 9d 20 04 80 	movabs $0x8004209de8,%rax
  800420d24e:	00 00 00 
  800420d251:	ff d0                	callq  *%rax

		assert(curenv);
  800420d253:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420d25a:	00 00 00 
  800420d25d:	ff d0                	callq  *%rax
  800420d25f:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420d266:	00 00 00 
  800420d269:	48 98                	cltq   
  800420d26b:	48 c1 e0 03          	shl    $0x3,%rax
  800420d26f:	48 89 c1             	mov    %rax,%rcx
  800420d272:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d276:	48 01 c8             	add    %rcx,%rax
  800420d279:	48 01 d0             	add    %rdx,%rax
  800420d27c:	48 83 c0 08          	add    $0x8,%rax
  800420d280:	48 8b 00             	mov    (%rax),%rax
  800420d283:	48 85 c0             	test   %rax,%rax
  800420d286:	75 35                	jne    800420d2bd <trap+0x14b>
  800420d288:	48 b9 82 07 22 04 80 	movabs $0x8004220782,%rcx
  800420d28f:	00 00 00 
  800420d292:	48 ba 6d 07 22 04 80 	movabs $0x800422076d,%rdx
  800420d299:	00 00 00 
  800420d29c:	be 71 01 00 00       	mov    $0x171,%esi
  800420d2a1:	48 bf 48 07 22 04 80 	movabs $0x8004220748,%rdi
  800420d2a8:	00 00 00 
  800420d2ab:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d2b0:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420d2b7:	00 00 00 
  800420d2ba:	41 ff d0             	callq  *%r8


		// Garbage collect if current enviroment is a zombie
		if (curenv->env_status == ENV_DYING) {
  800420d2bd:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420d2c4:	00 00 00 
  800420d2c7:	ff d0                	callq  *%rax
  800420d2c9:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420d2d0:	00 00 00 
  800420d2d3:	48 98                	cltq   
  800420d2d5:	48 c1 e0 03          	shl    $0x3,%rax
  800420d2d9:	48 89 c1             	mov    %rax,%rcx
  800420d2dc:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d2e0:	48 01 c8             	add    %rcx,%rax
  800420d2e3:	48 01 d0             	add    %rdx,%rax
  800420d2e6:	48 83 c0 08          	add    $0x8,%rax
  800420d2ea:	48 8b 00             	mov    (%rax),%rax
  800420d2ed:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d2f3:	83 f8 01             	cmp    $0x1,%eax
  800420d2f6:	75 7f                	jne    800420d377 <trap+0x205>
			env_free(curenv);
  800420d2f8:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420d2ff:	00 00 00 
  800420d302:	ff d0                	callq  *%rax
  800420d304:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420d30b:	00 00 00 
  800420d30e:	48 98                	cltq   
  800420d310:	48 c1 e0 03          	shl    $0x3,%rax
  800420d314:	48 89 c1             	mov    %rax,%rcx
  800420d317:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d31b:	48 01 c8             	add    %rcx,%rax
  800420d31e:	48 01 d0             	add    %rdx,%rax
  800420d321:	48 83 c0 08          	add    $0x8,%rax
  800420d325:	48 8b 00             	mov    (%rax),%rax
  800420d328:	48 89 c7             	mov    %rax,%rdi
  800420d32b:	48 b8 c4 90 20 04 80 	movabs $0x80042090c4,%rax
  800420d332:	00 00 00 
  800420d335:	ff d0                	callq  *%rax
			curenv = NULL;
  800420d337:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420d33e:	00 00 00 
  800420d341:	ff d0                	callq  *%rax
  800420d343:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420d34a:	00 00 00 
  800420d34d:	48 98                	cltq   
  800420d34f:	48 c1 e0 03          	shl    $0x3,%rax
  800420d353:	48 89 c1             	mov    %rax,%rcx
  800420d356:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d35a:	48 01 c8             	add    %rcx,%rax
  800420d35d:	48 01 d0             	add    %rdx,%rax
  800420d360:	48 83 c0 08          	add    $0x8,%rax
  800420d364:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			sched_yield();
  800420d36b:	48 b8 a6 da 20 04 80 	movabs $0x800420daa6,%rax
  800420d372:	00 00 00 
  800420d375:	ff d0                	callq  *%rax


		// Copy trap frame (which is currently on the stack)
		// into 'curenv->env_tf', so that running the environment
		// will restart at the trap point.
		curenv->env_tf = *tf;
  800420d377:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420d37e:	00 00 00 
  800420d381:	ff d0                	callq  *%rax
  800420d383:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420d38a:	00 00 00 
  800420d38d:	48 98                	cltq   
  800420d38f:	48 c1 e0 03          	shl    $0x3,%rax
  800420d393:	48 89 c1             	mov    %rax,%rcx
  800420d396:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d39a:	48 01 c8             	add    %rcx,%rax
  800420d39d:	48 01 d0             	add    %rdx,%rax
  800420d3a0:	48 83 c0 08          	add    $0x8,%rax
  800420d3a4:	48 8b 10             	mov    (%rax),%rdx
  800420d3a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d3ab:	48 89 c6             	mov    %rax,%rsi
  800420d3ae:	b8 18 00 00 00       	mov    $0x18,%eax
  800420d3b3:	48 89 d7             	mov    %rdx,%rdi
  800420d3b6:	48 89 c1             	mov    %rax,%rcx
  800420d3b9:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		// The trapframe on the stack should be ignored from here on.
		tf = &curenv->env_tf;
  800420d3bc:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420d3c3:	00 00 00 
  800420d3c6:	ff d0                	callq  *%rax
  800420d3c8:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420d3cf:	00 00 00 
  800420d3d2:	48 98                	cltq   
  800420d3d4:	48 c1 e0 03          	shl    $0x3,%rax
  800420d3d8:	48 89 c1             	mov    %rax,%rcx
  800420d3db:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d3df:	48 01 c8             	add    %rcx,%rax
  800420d3e2:	48 01 d0             	add    %rdx,%rax
  800420d3e5:	48 83 c0 08          	add    $0x8,%rax
  800420d3e9:	48 8b 00             	mov    (%rax),%rax
  800420d3ec:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}


	// Record that tf is the last real trapframe so
	// print_trapframe can print some additional information.
	last_tf = tf;
  800420d3f0:	48 b8 90 12 4e 04 80 	movabs $0x80044e1290,%rax
  800420d3f7:	00 00 00 
  800420d3fa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d3fe:	48 89 10             	mov    %rdx,(%rax)

	// Dispatch based on what type of trap occurred
	trap_dispatch(tf);
  800420d401:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d405:	48 89 c7             	mov    %rax,%rdi
  800420d408:	48 b8 51 cf 20 04 80 	movabs $0x800420cf51,%rax
  800420d40f:	00 00 00 
  800420d412:	ff d0                	callq  *%rax


	// If we made it to this point, then no other environment was
	// scheduled, so we should return to the current environment
	// if doing so makes sense.
	if (curenv && curenv->env_status == ENV_RUNNING)
  800420d414:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420d41b:	00 00 00 
  800420d41e:	ff d0                	callq  *%rax
  800420d420:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420d427:	00 00 00 
  800420d42a:	48 98                	cltq   
  800420d42c:	48 c1 e0 03          	shl    $0x3,%rax
  800420d430:	48 89 c1             	mov    %rax,%rcx
  800420d433:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d437:	48 01 c8             	add    %rcx,%rax
  800420d43a:	48 01 d0             	add    %rdx,%rax
  800420d43d:	48 83 c0 08          	add    $0x8,%rax
  800420d441:	48 8b 00             	mov    (%rax),%rax
  800420d444:	48 85 c0             	test   %rax,%rax
  800420d447:	74 7a                	je     800420d4c3 <trap+0x351>
  800420d449:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420d450:	00 00 00 
  800420d453:	ff d0                	callq  *%rax
  800420d455:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420d45c:	00 00 00 
  800420d45f:	48 98                	cltq   
  800420d461:	48 c1 e0 03          	shl    $0x3,%rax
  800420d465:	48 89 c1             	mov    %rax,%rcx
  800420d468:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d46c:	48 01 c8             	add    %rcx,%rax
  800420d46f:	48 01 d0             	add    %rdx,%rax
  800420d472:	48 83 c0 08          	add    $0x8,%rax
  800420d476:	48 8b 00             	mov    (%rax),%rax
  800420d479:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d47f:	83 f8 03             	cmp    $0x3,%eax
  800420d482:	75 3f                	jne    800420d4c3 <trap+0x351>
		env_run(curenv);
  800420d484:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420d48b:	00 00 00 
  800420d48e:	ff d0                	callq  *%rax
  800420d490:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420d497:	00 00 00 
  800420d49a:	48 98                	cltq   
  800420d49c:	48 c1 e0 03          	shl    $0x3,%rax
  800420d4a0:	48 89 c1             	mov    %rax,%rcx
  800420d4a3:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d4a7:	48 01 c8             	add    %rcx,%rax
  800420d4aa:	48 01 d0             	add    %rdx,%rax
  800420d4ad:	48 83 c0 08          	add    $0x8,%rax
  800420d4b1:	48 8b 00             	mov    (%rax),%rax
  800420d4b4:	48 89 c7             	mov    %rax,%rdi
  800420d4b7:	48 b8 4c 97 20 04 80 	movabs $0x800420974c,%rax
  800420d4be:	00 00 00 
  800420d4c1:	ff d0                	callq  *%rax
	else
		sched_yield();
  800420d4c3:	48 b8 a6 da 20 04 80 	movabs $0x800420daa6,%rax
  800420d4ca:	00 00 00 
  800420d4cd:	ff d0                	callq  *%rax

000000800420d4cf <page_fault_handler>:
}


void
page_fault_handler(struct Trapframe *tf)
{
  800420d4cf:	55                   	push   %rbp
  800420d4d0:	48 89 e5             	mov    %rsp,%rbp
  800420d4d3:	53                   	push   %rbx
  800420d4d4:	48 83 ec 38          	sub    $0x38,%rsp
  800420d4d8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420d4dc:	0f 20 d0             	mov    %cr2,%rax
  800420d4df:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	return val;
  800420d4e3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
	uint64_t fault_va;

	struct UTrapframe *utf;
	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
  800420d4e7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)


	if ((tf->tf_cs & 3) == 0) {
  800420d4eb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d4ef:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420d4f6:	0f b7 c0             	movzwl %ax,%eax
  800420d4f9:	83 e0 03             	and    $0x3,%eax
  800420d4fc:	85 c0                	test   %eax,%eax
  800420d4fe:	75 3d                	jne    800420d53d <page_fault_handler+0x6e>
		print_trapframe(tf);
  800420d500:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d504:	48 89 c7             	mov    %rax,%rdi
  800420d507:	48 b8 f7 c9 20 04 80 	movabs $0x800420c9f7,%rax
  800420d50e:	00 00 00 
  800420d511:	ff d0                	callq  *%rax
		panic("page fault");
  800420d513:	48 ba 89 07 22 04 80 	movabs $0x8004220789,%rdx
  800420d51a:	00 00 00 
  800420d51d:	be a4 01 00 00       	mov    $0x1a4,%esi
  800420d522:	48 bf 48 07 22 04 80 	movabs $0x8004220748,%rdi
  800420d529:	00 00 00 
  800420d52c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d531:	48 b9 d3 04 20 04 80 	movabs $0x80042004d3,%rcx
  800420d538:	00 00 00 
  800420d53b:	ff d1                	callq  *%rcx
	}



	// See if the environment has installed a user page fault handler.
	if (curenv->env_pgfault_upcall == 0) {
  800420d53d:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420d544:	00 00 00 
  800420d547:	ff d0                	callq  *%rax
  800420d549:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420d550:	00 00 00 
  800420d553:	48 98                	cltq   
  800420d555:	48 c1 e0 03          	shl    $0x3,%rax
  800420d559:	48 89 c1             	mov    %rax,%rcx
  800420d55c:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d560:	48 01 c8             	add    %rcx,%rax
  800420d563:	48 01 d0             	add    %rdx,%rax
  800420d566:	48 83 c0 08          	add    $0x8,%rax
  800420d56a:	48 8b 00             	mov    (%rax),%rax
  800420d56d:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420d574:	48 85 c0             	test   %rax,%rax
  800420d577:	0f 85 b8 00 00 00    	jne    800420d635 <page_fault_handler+0x166>
		cprintf("[%08x] user fault va %08x ip %08x\n",
  800420d57d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d581:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
			curenv->env_id, fault_va, tf->tf_rip);
  800420d588:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420d58f:	00 00 00 
  800420d592:	ff d0                	callq  *%rax
  800420d594:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420d59b:	00 00 00 
  800420d59e:	48 98                	cltq   
  800420d5a0:	48 c1 e0 03          	shl    $0x3,%rax
  800420d5a4:	48 89 c1             	mov    %rax,%rcx
  800420d5a7:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d5ab:	48 01 c8             	add    %rcx,%rax
  800420d5ae:	48 01 d0             	add    %rdx,%rax
  800420d5b1:	48 83 c0 08          	add    $0x8,%rax
  800420d5b5:	48 8b 00             	mov    (%rax),%rax



	// See if the environment has installed a user page fault handler.
	if (curenv->env_pgfault_upcall == 0) {
		cprintf("[%08x] user fault va %08x ip %08x\n",
  800420d5b8:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420d5be:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d5c2:	48 89 d9             	mov    %rbx,%rcx
  800420d5c5:	89 c6                	mov    %eax,%esi
  800420d5c7:	48 bf 98 07 22 04 80 	movabs $0x8004220798,%rdi
  800420d5ce:	00 00 00 
  800420d5d1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d5d6:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800420d5dd:	00 00 00 
  800420d5e0:	41 ff d0             	callq  *%r8
			curenv->env_id, fault_va, tf->tf_rip);
		print_trapframe(tf);
  800420d5e3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d5e7:	48 89 c7             	mov    %rax,%rdi
  800420d5ea:	48 b8 f7 c9 20 04 80 	movabs $0x800420c9f7,%rax
  800420d5f1:	00 00 00 
  800420d5f4:	ff d0                	callq  *%rax
		env_destroy(curenv);
  800420d5f6:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420d5fd:	00 00 00 
  800420d600:	ff d0                	callq  *%rax
  800420d602:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420d609:	00 00 00 
  800420d60c:	48 98                	cltq   
  800420d60e:	48 c1 e0 03          	shl    $0x3,%rax
  800420d612:	48 89 c1             	mov    %rax,%rcx
  800420d615:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d619:	48 01 c8             	add    %rcx,%rax
  800420d61c:	48 01 d0             	add    %rdx,%rax
  800420d61f:	48 83 c0 08          	add    $0x8,%rax
  800420d623:	48 8b 00             	mov    (%rax),%rax
  800420d626:	48 89 c7             	mov    %rax,%rdi
  800420d629:	48 b8 81 95 20 04 80 	movabs $0x8004209581,%rax
  800420d630:	00 00 00 
  800420d633:	ff d0                	callq  *%rax
	}

	// Decide where to push our exception stack frame.
	if (tf->tf_rsp >= UXSTACKTOP - PGSIZE && tf->tf_rsp < UXSTACKTOP) {
  800420d635:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d639:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420d640:	b8 ff ef 7f ef       	mov    $0xef7fefff,%eax
  800420d645:	48 39 c2             	cmp    %rax,%rdx
  800420d648:	76 2c                	jbe    800420d676 <page_fault_handler+0x1a7>
  800420d64a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d64e:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420d655:	b8 ff ff 7f ef       	mov    $0xef7fffff,%eax
  800420d65a:	48 39 c2             	cmp    %rax,%rdx
  800420d65d:	77 17                	ja     800420d676 <page_fault_handler+0x1a7>
		// The user's ESP is ALREADY in the user exception stack area,
		// so push the new frame on the exception stack,
		// preserving the existing exception stack contents.
		utf = (struct UTrapframe*)(tf->tf_rsp
  800420d65f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d663:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
					   - sizeof(struct UTrapframe)
					   // Save a spare word for return
					   - 8);
  800420d66a:	48 2d a8 00 00 00    	sub    $0xa8,%rax
	// Decide where to push our exception stack frame.
	if (tf->tf_rsp >= UXSTACKTOP - PGSIZE && tf->tf_rsp < UXSTACKTOP) {
		// The user's ESP is ALREADY in the user exception stack area,
		// so push the new frame on the exception stack,
		// preserving the existing exception stack contents.
		utf = (struct UTrapframe*)(tf->tf_rsp
  800420d670:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420d674:	eb 09                	jmp    800420d67f <page_fault_handler+0x1b0>
		// The user's ESP is NOT in the user exception stack area,
		// so it's presumably pointing to a normal user stack
		// and the user exception stack is not in use.
		// Therefore, switch the user's ESP onto the exception stack
		// and push the new frame at the top of the exception stack.
		utf = (struct UTrapframe*)(UXSTACKTOP
  800420d676:	b8 60 ff 7f ef       	mov    $0xef7fff60,%eax
  800420d67b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}

	// If we can't write to the exception stack,
	// it means the user environment is seriously screwed up,
	// so just terminate it.
	user_mem_assert(curenv, utf, sizeof(struct UTrapframe), PTE_U | PTE_W);
  800420d67f:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420d686:	00 00 00 
  800420d689:	ff d0                	callq  *%rax
  800420d68b:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420d692:	00 00 00 
  800420d695:	48 98                	cltq   
  800420d697:	48 c1 e0 03          	shl    $0x3,%rax
  800420d69b:	48 89 c1             	mov    %rax,%rcx
  800420d69e:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d6a2:	48 01 c8             	add    %rcx,%rax
  800420d6a5:	48 01 d0             	add    %rdx,%rax
  800420d6a8:	48 83 c0 08          	add    $0x8,%rax
  800420d6ac:	48 8b 00             	mov    (%rax),%rax
  800420d6af:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420d6b3:	b9 06 00 00 00       	mov    $0x6,%ecx
  800420d6b8:	ba a0 00 00 00       	mov    $0xa0,%edx
  800420d6bd:	48 89 c7             	mov    %rax,%rdi
  800420d6c0:	48 b8 7e 41 20 04 80 	movabs $0x800420417e,%rax
  800420d6c7:	00 00 00 
  800420d6ca:	ff d0                	callq  *%rax

	// fill utf
	utf->utf_fault_va = fault_va;
  800420d6cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d6d0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d6d4:	48 89 10             	mov    %rdx,(%rax)
	utf->utf_err = tf->tf_err;
  800420d6d7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d6db:	48 8b 90 90 00 00 00 	mov    0x90(%rax),%rdx
  800420d6e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d6e6:	48 89 50 08          	mov    %rdx,0x8(%rax)
	utf->utf_regs = tf->tf_regs;
  800420d6ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d6ee:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420d6f2:	48 8b 0a             	mov    (%rdx),%rcx
  800420d6f5:	48 89 48 10          	mov    %rcx,0x10(%rax)
  800420d6f9:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420d6fd:	48 89 48 18          	mov    %rcx,0x18(%rax)
  800420d701:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  800420d705:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800420d709:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  800420d70d:	48 89 48 28          	mov    %rcx,0x28(%rax)
  800420d711:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  800420d715:	48 89 48 30          	mov    %rcx,0x30(%rax)
  800420d719:	48 8b 4a 28          	mov    0x28(%rdx),%rcx
  800420d71d:	48 89 48 38          	mov    %rcx,0x38(%rax)
  800420d721:	48 8b 4a 30          	mov    0x30(%rdx),%rcx
  800420d725:	48 89 48 40          	mov    %rcx,0x40(%rax)
  800420d729:	48 8b 4a 38          	mov    0x38(%rdx),%rcx
  800420d72d:	48 89 48 48          	mov    %rcx,0x48(%rax)
  800420d731:	48 8b 4a 40          	mov    0x40(%rdx),%rcx
  800420d735:	48 89 48 50          	mov    %rcx,0x50(%rax)
  800420d739:	48 8b 4a 48          	mov    0x48(%rdx),%rcx
  800420d73d:	48 89 48 58          	mov    %rcx,0x58(%rax)
  800420d741:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
  800420d745:	48 89 48 60          	mov    %rcx,0x60(%rax)
  800420d749:	48 8b 4a 58          	mov    0x58(%rdx),%rcx
  800420d74d:	48 89 48 68          	mov    %rcx,0x68(%rax)
  800420d751:	48 8b 4a 60          	mov    0x60(%rdx),%rcx
  800420d755:	48 89 48 70          	mov    %rcx,0x70(%rax)
  800420d759:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
  800420d75d:	48 89 48 78          	mov    %rcx,0x78(%rax)
  800420d761:	48 8b 52 70          	mov    0x70(%rdx),%rdx
  800420d765:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
	utf->utf_rip = tf->tf_rip;
  800420d76c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d770:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  800420d777:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d77b:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
	utf->utf_eflags = tf->tf_eflags;
  800420d782:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d786:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  800420d78d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d791:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
	utf->utf_rsp = tf->tf_rsp;
  800420d798:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d79c:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420d7a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d7a7:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)

 	// set user registers so that env_run switches to fault handler
	tf->tf_rsp = (uintptr_t) utf;
  800420d7ae:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d7b2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d7b6:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
 	tf->tf_rip = (uintptr_t) curenv->env_pgfault_upcall;
  800420d7bd:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420d7c4:	00 00 00 
  800420d7c7:	ff d0                	callq  *%rax
  800420d7c9:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420d7d0:	00 00 00 
  800420d7d3:	48 98                	cltq   
  800420d7d5:	48 c1 e0 03          	shl    $0x3,%rax
  800420d7d9:	48 89 c1             	mov    %rax,%rcx
  800420d7dc:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d7e0:	48 01 c8             	add    %rcx,%rax
  800420d7e3:	48 01 d0             	add    %rdx,%rax
  800420d7e6:	48 83 c0 08          	add    $0x8,%rax
  800420d7ea:	48 8b 00             	mov    (%rax),%rax
  800420d7ed:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420d7f4:	48 89 c2             	mov    %rax,%rdx
  800420d7f7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d7fb:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)

	env_run(curenv);
  800420d802:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420d809:	00 00 00 
  800420d80c:	ff d0                	callq  *%rax
  800420d80e:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420d815:	00 00 00 
  800420d818:	48 98                	cltq   
  800420d81a:	48 c1 e0 03          	shl    $0x3,%rax
  800420d81e:	48 89 c1             	mov    %rax,%rcx
  800420d821:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d825:	48 01 c8             	add    %rcx,%rax
  800420d828:	48 01 d0             	add    %rdx,%rax
  800420d82b:	48 83 c0 08          	add    $0x8,%rax
  800420d82f:	48 8b 00             	mov    (%rax),%rax
  800420d832:	48 89 c7             	mov    %rax,%rdi
  800420d835:	48 b8 4c 97 20 04 80 	movabs $0x800420974c,%rax
  800420d83c:	00 00 00 
  800420d83f:	ff d0                	callq  *%rax
  800420d841:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  800420d848:	00 00 00 
  800420d84b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000800420d850 <Xdivide>:

.text


/* CPU traps */
TRAPHANDLER_NOEC(Xdivide, T_DIVIDE)
  800420d850:	6a 00                	pushq  $0x0
  800420d852:	6a 00                	pushq  $0x0
  800420d854:	e9 f7 00 00 00       	jmpq   800420d950 <_alltraps>
  800420d859:	90                   	nop

000000800420d85a <Xdebug>:
TRAPHANDLER_NOEC(Xdebug,  T_DEBUG)
  800420d85a:	6a 00                	pushq  $0x0
  800420d85c:	6a 01                	pushq  $0x1
  800420d85e:	e9 ed 00 00 00       	jmpq   800420d950 <_alltraps>
  800420d863:	90                   	nop

000000800420d864 <Xnmi>:
TRAPHANDLER_NOEC(Xnmi,    T_NMI)
  800420d864:	6a 00                	pushq  $0x0
  800420d866:	6a 02                	pushq  $0x2
  800420d868:	e9 e3 00 00 00       	jmpq   800420d950 <_alltraps>
  800420d86d:	90                   	nop

000000800420d86e <Xbrkpt>:
TRAPHANDLER_NOEC(Xbrkpt,  T_BRKPT)
  800420d86e:	6a 00                	pushq  $0x0
  800420d870:	6a 03                	pushq  $0x3
  800420d872:	e9 d9 00 00 00       	jmpq   800420d950 <_alltraps>
  800420d877:	90                   	nop

000000800420d878 <Xoflow>:
TRAPHANDLER_NOEC(Xoflow,  T_OFLOW)
  800420d878:	6a 00                	pushq  $0x0
  800420d87a:	6a 04                	pushq  $0x4
  800420d87c:	e9 cf 00 00 00       	jmpq   800420d950 <_alltraps>
  800420d881:	90                   	nop

000000800420d882 <Xbound>:
TRAPHANDLER_NOEC(Xbound,  T_BOUND)
  800420d882:	6a 00                	pushq  $0x0
  800420d884:	6a 05                	pushq  $0x5
  800420d886:	e9 c5 00 00 00       	jmpq   800420d950 <_alltraps>
  800420d88b:	90                   	nop

000000800420d88c <Xillop>:
TRAPHANDLER_NOEC(Xillop,  T_ILLOP)
  800420d88c:	6a 00                	pushq  $0x0
  800420d88e:	6a 06                	pushq  $0x6
  800420d890:	e9 bb 00 00 00       	jmpq   800420d950 <_alltraps>
  800420d895:	90                   	nop

000000800420d896 <Xdevice>:
TRAPHANDLER_NOEC(Xdevice, T_DEVICE)
  800420d896:	6a 00                	pushq  $0x0
  800420d898:	6a 07                	pushq  $0x7
  800420d89a:	e9 b1 00 00 00       	jmpq   800420d950 <_alltraps>
  800420d89f:	90                   	nop

000000800420d8a0 <Xdblflt>:
TRAPHANDLER     (Xdblflt, T_DBLFLT)
  800420d8a0:	6a 08                	pushq  $0x8
  800420d8a2:	e9 a9 00 00 00       	jmpq   800420d950 <_alltraps>
  800420d8a7:	90                   	nop

000000800420d8a8 <Xtss>:
TRAPHANDLER     (Xtss,    T_TSS)
  800420d8a8:	6a 0a                	pushq  $0xa
  800420d8aa:	e9 a1 00 00 00       	jmpq   800420d950 <_alltraps>
  800420d8af:	90                   	nop

000000800420d8b0 <Xsegnp>:
TRAPHANDLER     (Xsegnp,  T_SEGNP)
  800420d8b0:	6a 0b                	pushq  $0xb
  800420d8b2:	e9 99 00 00 00       	jmpq   800420d950 <_alltraps>
  800420d8b7:	90                   	nop

000000800420d8b8 <Xstack>:
TRAPHANDLER     (Xstack,  T_STACK)
  800420d8b8:	6a 0c                	pushq  $0xc
  800420d8ba:	e9 91 00 00 00       	jmpq   800420d950 <_alltraps>
  800420d8bf:	90                   	nop

000000800420d8c0 <Xgpflt>:
TRAPHANDLER     (Xgpflt,  T_GPFLT)
  800420d8c0:	6a 0d                	pushq  $0xd
  800420d8c2:	e9 89 00 00 00       	jmpq   800420d950 <_alltraps>
  800420d8c7:	90                   	nop

000000800420d8c8 <Xpgflt>:
TRAPHANDLER     (Xpgflt,  T_PGFLT)
  800420d8c8:	6a 0e                	pushq  $0xe
  800420d8ca:	e9 81 00 00 00       	jmpq   800420d950 <_alltraps>
  800420d8cf:	90                   	nop

000000800420d8d0 <Xfperr>:
TRAPHANDLER_NOEC(Xfperr,  T_FPERR)
  800420d8d0:	6a 00                	pushq  $0x0
  800420d8d2:	6a 10                	pushq  $0x10
  800420d8d4:	eb 7a                	jmp    800420d950 <_alltraps>

000000800420d8d6 <Xalign>:
TRAPHANDLER     (Xalign,  T_ALIGN)
  800420d8d6:	6a 11                	pushq  $0x11
  800420d8d8:	eb 76                	jmp    800420d950 <_alltraps>

000000800420d8da <Xmchk>:
TRAPHANDLER_NOEC(Xmchk,   T_MCHK)
  800420d8da:	6a 00                	pushq  $0x0
  800420d8dc:	6a 12                	pushq  $0x12
  800420d8de:	eb 70                	jmp    800420d950 <_alltraps>

000000800420d8e0 <Xirq0>:

/* the external device interrupts */
TRAPHANDLER_NOEC(Xirq0,   IRQ_OFFSET+0)
  800420d8e0:	6a 00                	pushq  $0x0
  800420d8e2:	6a 20                	pushq  $0x20
  800420d8e4:	eb 6a                	jmp    800420d950 <_alltraps>

000000800420d8e6 <Xirq1>:
TRAPHANDLER_NOEC(Xirq1,   IRQ_OFFSET+1)
  800420d8e6:	6a 00                	pushq  $0x0
  800420d8e8:	6a 21                	pushq  $0x21
  800420d8ea:	eb 64                	jmp    800420d950 <_alltraps>

000000800420d8ec <Xirq2>:
TRAPHANDLER_NOEC(Xirq2,   IRQ_OFFSET+2)
  800420d8ec:	6a 00                	pushq  $0x0
  800420d8ee:	6a 22                	pushq  $0x22
  800420d8f0:	eb 5e                	jmp    800420d950 <_alltraps>

000000800420d8f2 <Xirq3>:
TRAPHANDLER_NOEC(Xirq3,   IRQ_OFFSET+3)
  800420d8f2:	6a 00                	pushq  $0x0
  800420d8f4:	6a 23                	pushq  $0x23
  800420d8f6:	eb 58                	jmp    800420d950 <_alltraps>

000000800420d8f8 <Xirq4>:
TRAPHANDLER_NOEC(Xirq4,   IRQ_OFFSET+4)
  800420d8f8:	6a 00                	pushq  $0x0
  800420d8fa:	6a 24                	pushq  $0x24
  800420d8fc:	eb 52                	jmp    800420d950 <_alltraps>

000000800420d8fe <Xirq5>:
TRAPHANDLER_NOEC(Xirq5,   IRQ_OFFSET+5)
  800420d8fe:	6a 00                	pushq  $0x0
  800420d900:	6a 25                	pushq  $0x25
  800420d902:	eb 4c                	jmp    800420d950 <_alltraps>

000000800420d904 <Xirq6>:
TRAPHANDLER_NOEC(Xirq6,   IRQ_OFFSET+6)
  800420d904:	6a 00                	pushq  $0x0
  800420d906:	6a 26                	pushq  $0x26
  800420d908:	eb 46                	jmp    800420d950 <_alltraps>

000000800420d90a <Xirq7>:
TRAPHANDLER_NOEC(Xirq7,   IRQ_OFFSET+7)
  800420d90a:	6a 00                	pushq  $0x0
  800420d90c:	6a 27                	pushq  $0x27
  800420d90e:	eb 40                	jmp    800420d950 <_alltraps>

000000800420d910 <Xirq8>:
TRAPHANDLER_NOEC(Xirq8,   IRQ_OFFSET+8)
  800420d910:	6a 00                	pushq  $0x0
  800420d912:	6a 28                	pushq  $0x28
  800420d914:	eb 3a                	jmp    800420d950 <_alltraps>

000000800420d916 <Xirq9>:
TRAPHANDLER_NOEC(Xirq9,   IRQ_OFFSET+9)
  800420d916:	6a 00                	pushq  $0x0
  800420d918:	6a 29                	pushq  $0x29
  800420d91a:	eb 34                	jmp    800420d950 <_alltraps>

000000800420d91c <Xirq10>:
TRAPHANDLER_NOEC(Xirq10,  IRQ_OFFSET+10)
  800420d91c:	6a 00                	pushq  $0x0
  800420d91e:	6a 2a                	pushq  $0x2a
  800420d920:	eb 2e                	jmp    800420d950 <_alltraps>

000000800420d922 <Xirq11>:
TRAPHANDLER_NOEC(Xirq11,  IRQ_OFFSET+11)
  800420d922:	6a 00                	pushq  $0x0
  800420d924:	6a 2b                	pushq  $0x2b
  800420d926:	eb 28                	jmp    800420d950 <_alltraps>

000000800420d928 <Xirq12>:
TRAPHANDLER_NOEC(Xirq12,  IRQ_OFFSET+12)
  800420d928:	6a 00                	pushq  $0x0
  800420d92a:	6a 2c                	pushq  $0x2c
  800420d92c:	eb 22                	jmp    800420d950 <_alltraps>

000000800420d92e <Xirq13>:
TRAPHANDLER_NOEC(Xirq13,  IRQ_OFFSET+13)
  800420d92e:	6a 00                	pushq  $0x0
  800420d930:	6a 2d                	pushq  $0x2d
  800420d932:	eb 1c                	jmp    800420d950 <_alltraps>

000000800420d934 <Xirq14>:
TRAPHANDLER_NOEC(Xirq14,  IRQ_OFFSET+14)
  800420d934:	6a 00                	pushq  $0x0
  800420d936:	6a 2e                	pushq  $0x2e
  800420d938:	eb 16                	jmp    800420d950 <_alltraps>

000000800420d93a <Xirq15>:
TRAPHANDLER_NOEC(Xirq15,  IRQ_OFFSET+15)
  800420d93a:	6a 00                	pushq  $0x0
  800420d93c:	6a 2f                	pushq  $0x2f
  800420d93e:	eb 10                	jmp    800420d950 <_alltraps>

000000800420d940 <Xsyscall>:

/* system call entry point */
TRAPHANDLER_NOEC(Xsyscall, T_SYSCALL)
  800420d940:	6a 00                	pushq  $0x0
  800420d942:	6a 30                	pushq  $0x30
  800420d944:	eb 0a                	jmp    800420d950 <_alltraps>

000000800420d946 <Xdefault>:

/* default handler -- not for any specific trap */
TRAPHANDLER     (Xdefault, T_DEFAULT)
  800420d946:	68 f4 01 00 00       	pushq  $0x1f4
  800420d94b:	eb 03                	jmp    800420d950 <_alltraps>
  800420d94d:	0f 1f 00             	nopl   (%rax)

000000800420d950 <_alltraps>:

.globl	_alltraps
.type	_alltraps,@function
.p2align 4, 0x90		/* 16-byte alignment, nop filled */
_alltraps:
    subq $16,%rsp
  800420d950:	48 83 ec 10          	sub    $0x10,%rsp
    movw %ds,8(%rsp)
  800420d954:	8c 5c 24 08          	mov    %ds,0x8(%rsp)
    movw %es,0(%rsp)
  800420d958:	8c 04 24             	mov    %es,(%rsp)
    PUSHA
  800420d95b:	48 83 ec 78          	sub    $0x78,%rsp
  800420d95f:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  800420d964:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  800420d969:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
  800420d96e:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  800420d973:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
  800420d978:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  800420d97d:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  800420d982:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
  800420d987:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
  800420d98c:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)
  800420d991:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  800420d996:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
  800420d99b:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  800420d9a0:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  800420d9a5:	4c 89 3c 24          	mov    %r15,(%rsp)
    movl $GD_KD, %eax
  800420d9a9:	b8 10 00 00 00       	mov    $0x10,%eax
    movw %ax, %ds
  800420d9ae:	8e d8                	mov    %eax,%ds
    movw %ax, %es
  800420d9b0:	8e c0                	mov    %eax,%es
    movw %ax, %ss
  800420d9b2:	8e d0                	mov    %eax,%ss
    movw %ax, %fs
  800420d9b4:	8e e0                	mov    %eax,%fs
    movw %ax, %gs
  800420d9b6:	8e e8                	mov    %eax,%gs
    movq %rsp,%rdi
  800420d9b8:	48 89 e7             	mov    %rsp,%rdi
    call trap   # never returns 
  800420d9bb:	e8 b2 f7 ff ff       	callq  800420d172 <trap>

000000800420d9c0 <spin>:
spin:	jmp spin
  800420d9c0:	eb fe                	jmp    800420d9c0 <spin>

000000800420d9c2 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800420d9c2:	55                   	push   %rbp
  800420d9c3:	48 89 e5             	mov    %rsp,%rbp
  800420d9c6:	48 83 ec 20          	sub    $0x20,%rsp
  800420d9ca:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d9ce:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420d9d1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d9d5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420d9d8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d9dc:	f0 87 02             	lock xchg %eax,(%rdx)
  800420d9df:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800420d9e2:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420d9e5:	c9                   	leaveq 
  800420d9e6:	c3                   	retq   

000000800420d9e7 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420d9e7:	55                   	push   %rbp
  800420d9e8:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420d9eb:	48 bf 60 67 23 04 80 	movabs $0x8004236760,%rdi
  800420d9f2:	00 00 00 
  800420d9f5:	48 b8 64 85 21 04 80 	movabs $0x8004218564,%rax
  800420d9fc:	00 00 00 
  800420d9ff:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420da01:	f3 90                	pause  
}
  800420da03:	90                   	nop
  800420da04:	5d                   	pop    %rbp
  800420da05:	c3                   	retq   

000000800420da06 <vmxon>:


#ifndef VMM_GUEST
#include <vmm/vmx.h>
static int
vmxon() {
  800420da06:	55                   	push   %rbp
  800420da07:	48 89 e5             	mov    %rsp,%rbp
  800420da0a:	48 83 ec 10          	sub    $0x10,%rsp
	int r;
	if(!thiscpu->is_vmx_root) {
  800420da0e:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420da15:	00 00 00 
  800420da18:	ff d0                	callq  *%rax
  800420da1a:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420da21:	00 00 00 
  800420da24:	48 98                	cltq   
  800420da26:	48 c1 e0 03          	shl    $0x3,%rax
  800420da2a:	48 89 c1             	mov    %rax,%rcx
  800420da2d:	48 c1 e1 04          	shl    $0x4,%rcx
  800420da31:	48 01 c8             	add    %rcx,%rax
  800420da34:	48 01 d0             	add    %rdx,%rax
  800420da37:	48 83 c0 78          	add    $0x78,%rax
  800420da3b:	0f b6 00             	movzbl (%rax),%eax
  800420da3e:	83 f0 01             	xor    $0x1,%eax
  800420da41:	84 c0                	test   %al,%al
  800420da43:	74 5a                	je     800420da9f <vmxon+0x99>
		r = vmx_init_vmxon();
  800420da45:	b8 00 00 00 00       	mov    $0x0,%eax
  800420da4a:	48 ba ca a7 21 04 80 	movabs $0x800421a7ca,%rdx
  800420da51:	00 00 00 
  800420da54:	ff d2                	callq  *%rdx
  800420da56:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if(r < 0) {
  800420da59:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420da5d:	79 25                	jns    800420da84 <vmxon+0x7e>
			cprintf("Error executing VMXON: %e\n", r);
  800420da5f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420da62:	89 c6                	mov    %eax,%esi
  800420da64:	48 bf a0 09 22 04 80 	movabs $0x80042209a0,%rdi
  800420da6b:	00 00 00 
  800420da6e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420da73:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420da7a:	00 00 00 
  800420da7d:	ff d2                	callq  *%rdx
			return r;
  800420da7f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420da82:	eb 20                	jmp    800420daa4 <vmxon+0x9e>
		}
		cprintf("VMXON\n");
  800420da84:	48 bf bb 09 22 04 80 	movabs $0x80042209bb,%rdi
  800420da8b:	00 00 00 
  800420da8e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420da93:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420da9a:	00 00 00 
  800420da9d:	ff d2                	callq  *%rdx
	}
	return 0;
  800420da9f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420daa4:	c9                   	leaveq 
  800420daa5:	c3                   	retq   

000000800420daa6 <sched_yield>:


// Choose a user environment to run and run it.
void
sched_yield(void)
{
  800420daa6:	55                   	push   %rbp
  800420daa7:	48 89 e5             	mov    %rsp,%rbp
  800420daaa:	53                   	push   %rbx
  800420daab:	48 83 ec 28          	sub    $0x28,%rsp
	struct Env *idle;

	int i, j, k;

	// Determine the starting point for the search.
	if (curenv)
  800420daaf:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420dab6:	00 00 00 
  800420dab9:	ff d0                	callq  *%rax
  800420dabb:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420dac2:	00 00 00 
  800420dac5:	48 98                	cltq   
  800420dac7:	48 c1 e0 03          	shl    $0x3,%rax
  800420dacb:	48 89 c1             	mov    %rax,%rcx
  800420dace:	48 c1 e1 04          	shl    $0x4,%rcx
  800420dad2:	48 01 c8             	add    %rcx,%rax
  800420dad5:	48 01 d0             	add    %rdx,%rax
  800420dad8:	48 83 c0 08          	add    $0x8,%rax
  800420dadc:	48 8b 00             	mov    (%rax),%rax
  800420dadf:	48 85 c0             	test   %rax,%rax
  800420dae2:	74 60                	je     800420db44 <sched_yield+0x9e>
		i = curenv-envs;
  800420dae4:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420daeb:	00 00 00 
  800420daee:	ff d0                	callq  *%rax
  800420daf0:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420daf7:	00 00 00 
  800420dafa:	48 98                	cltq   
  800420dafc:	48 c1 e0 03          	shl    $0x3,%rax
  800420db00:	48 89 c1             	mov    %rax,%rcx
  800420db03:	48 c1 e1 04          	shl    $0x4,%rcx
  800420db07:	48 01 c8             	add    %rcx,%rax
  800420db0a:	48 01 d0             	add    %rdx,%rax
  800420db0d:	48 83 c0 08          	add    $0x8,%rax
  800420db11:	48 8b 00             	mov    (%rax),%rax
  800420db14:	48 89 c2             	mov    %rax,%rdx
  800420db17:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  800420db1e:	00 00 00 
  800420db21:	48 8b 00             	mov    (%rax),%rax
  800420db24:	48 29 c2             	sub    %rax,%rdx
  800420db27:	48 89 d0             	mov    %rdx,%rax
  800420db2a:	48 c1 f8 03          	sar    $0x3,%rax
  800420db2e:	48 89 c2             	mov    %rax,%rdx
  800420db31:	48 b8 a5 4f fa a4 4f 	movabs $0x4fa4fa4fa4fa4fa5,%rax
  800420db38:	fa a4 4f 
  800420db3b:	48 0f af c2          	imul   %rdx,%rax
  800420db3f:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420db42:	eb 07                	jmp    800420db4b <sched_yield+0xa5>
	else
		i = NENV-1;
  800420db44:	c7 45 ec ff 03 00 00 	movl   $0x3ff,-0x14(%rbp)
	//cprintf("sched_yield searching from %d\n", i);

	// Loop through all the environments at most once.
	for (j = 1; j <= NENV; j++) {
  800420db4b:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%rbp)
  800420db52:	e9 1a 01 00 00       	jmpq   800420dc71 <sched_yield+0x1cb>
		k = (j + i) % NENV;
  800420db57:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420db5a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420db5d:	01 c2                	add    %eax,%edx
  800420db5f:	89 d0                	mov    %edx,%eax
  800420db61:	c1 f8 1f             	sar    $0x1f,%eax
  800420db64:	c1 e8 16             	shr    $0x16,%eax
  800420db67:	01 c2                	add    %eax,%edx
  800420db69:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  800420db6f:	29 c2                	sub    %eax,%edx
  800420db71:	89 d0                	mov    %edx,%eax
  800420db73:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		// If this environment is runnable, run it.
		if (envs[k].env_status == ENV_RUNNABLE) {
  800420db76:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  800420db7d:	00 00 00 
  800420db80:	48 8b 10             	mov    (%rax),%rdx
  800420db83:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420db86:	48 98                	cltq   
  800420db88:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420db8f:	48 01 d0             	add    %rdx,%rax
  800420db92:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420db98:	83 f8 02             	cmp    $0x2,%eax
  800420db9b:	0f 85 cc 00 00 00    	jne    800420dc6d <sched_yield+0x1c7>
#ifndef VMM_GUEST
            if (envs[k].env_type == ENV_TYPE_GUEST) {
  800420dba1:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  800420dba8:	00 00 00 
  800420dbab:	48 8b 10             	mov    (%rax),%rdx
  800420dbae:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420dbb1:	48 98                	cltq   
  800420dbb3:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420dbba:	48 01 d0             	add    %rdx,%rax
  800420dbbd:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800420dbc3:	83 f8 03             	cmp    $0x3,%eax
  800420dbc6:	75 79                	jne    800420dc41 <sched_yield+0x19b>
				int r;
				if (envs[k].env_vmxinfo.vcpunum != cpunum()) {
  800420dbc8:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  800420dbcf:	00 00 00 
  800420dbd2:	48 8b 10             	mov    (%rax),%rdx
  800420dbd5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420dbd8:	48 98                	cltq   
  800420dbda:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420dbe1:	48 01 d0             	add    %rdx,%rax
  800420dbe4:	8b 98 60 01 00 00    	mov    0x160(%rax),%ebx
  800420dbea:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420dbf1:	00 00 00 
  800420dbf4:	ff d0                	callq  *%rax
  800420dbf6:	39 c3                	cmp    %eax,%ebx
  800420dbf8:	75 72                	jne    800420dc6c <sched_yield+0x1c6>
					continue;
				}
				r = vmxon();
  800420dbfa:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dbff:	48 ba 06 da 20 04 80 	movabs $0x800420da06,%rdx
  800420dc06:	00 00 00 
  800420dc09:	ff d2                	callq  *%rdx
  800420dc0b:	89 45 e0             	mov    %eax,-0x20(%rbp)
				if (r < 0) {
  800420dc0e:	83 7d e0 00          	cmpl   $0x0,-0x20(%rbp)
  800420dc12:	79 2d                	jns    800420dc41 <sched_yield+0x19b>
					env_destroy(&envs[k]);
  800420dc14:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  800420dc1b:	00 00 00 
  800420dc1e:	48 8b 10             	mov    (%rax),%rdx
  800420dc21:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420dc24:	48 98                	cltq   
  800420dc26:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420dc2d:	48 01 d0             	add    %rdx,%rax
  800420dc30:	48 89 c7             	mov    %rax,%rdi
  800420dc33:	48 b8 81 95 20 04 80 	movabs $0x8004209581,%rax
  800420dc3a:	00 00 00 
  800420dc3d:	ff d0                	callq  *%rax
					continue;
  800420dc3f:	eb 2c                	jmp    800420dc6d <sched_yield+0x1c7>
				}
			}
#endif
			env_run(&envs[k]);
  800420dc41:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  800420dc48:	00 00 00 
  800420dc4b:	48 8b 10             	mov    (%rax),%rdx
  800420dc4e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420dc51:	48 98                	cltq   
  800420dc53:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420dc5a:	48 01 d0             	add    %rdx,%rax
  800420dc5d:	48 89 c7             	mov    %rax,%rdi
  800420dc60:	48 b8 4c 97 20 04 80 	movabs $0x800420974c,%rax
  800420dc67:	00 00 00 
  800420dc6a:	ff d0                	callq  *%rax
		if (envs[k].env_status == ENV_RUNNABLE) {
#ifndef VMM_GUEST
            if (envs[k].env_type == ENV_TYPE_GUEST) {
				int r;
				if (envs[k].env_vmxinfo.vcpunum != cpunum()) {
					continue;
  800420dc6c:	90                   	nop
	else
		i = NENV-1;
	//cprintf("sched_yield searching from %d\n", i);

	// Loop through all the environments at most once.
	for (j = 1; j <= NENV; j++) {
  800420dc6d:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  800420dc71:	81 7d e8 00 04 00 00 	cmpl   $0x400,-0x18(%rbp)
  800420dc78:	0f 8e d9 fe ff ff    	jle    800420db57 <sched_yield+0xb1>
#endif
			env_run(&envs[k]);
		}
	}

	if (curenv && curenv->env_status == ENV_RUNNING) {
  800420dc7e:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420dc85:	00 00 00 
  800420dc88:	ff d0                	callq  *%rax
  800420dc8a:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420dc91:	00 00 00 
  800420dc94:	48 98                	cltq   
  800420dc96:	48 c1 e0 03          	shl    $0x3,%rax
  800420dc9a:	48 89 c1             	mov    %rax,%rcx
  800420dc9d:	48 c1 e1 04          	shl    $0x4,%rcx
  800420dca1:	48 01 c8             	add    %rcx,%rax
  800420dca4:	48 01 d0             	add    %rdx,%rax
  800420dca7:	48 83 c0 08          	add    $0x8,%rax
  800420dcab:	48 8b 00             	mov    (%rax),%rax
  800420dcae:	48 85 c0             	test   %rax,%rax
  800420dcb1:	0f 84 60 01 00 00    	je     800420de17 <sched_yield+0x371>
  800420dcb7:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420dcbe:	00 00 00 
  800420dcc1:	ff d0                	callq  *%rax
  800420dcc3:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420dcca:	00 00 00 
  800420dccd:	48 98                	cltq   
  800420dccf:	48 c1 e0 03          	shl    $0x3,%rax
  800420dcd3:	48 89 c1             	mov    %rax,%rcx
  800420dcd6:	48 c1 e1 04          	shl    $0x4,%rcx
  800420dcda:	48 01 c8             	add    %rcx,%rax
  800420dcdd:	48 01 d0             	add    %rdx,%rax
  800420dce0:	48 83 c0 08          	add    $0x8,%rax
  800420dce4:	48 8b 00             	mov    (%rax),%rax
  800420dce7:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420dced:	83 f8 03             	cmp    $0x3,%eax
  800420dcf0:	0f 85 21 01 00 00    	jne    800420de17 <sched_yield+0x371>

#ifndef VMM_GUEST
		if (curenv->env_type == ENV_TYPE_GUEST) {
  800420dcf6:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420dcfd:	00 00 00 
  800420dd00:	ff d0                	callq  *%rax
  800420dd02:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420dd09:	00 00 00 
  800420dd0c:	48 98                	cltq   
  800420dd0e:	48 c1 e0 03          	shl    $0x3,%rax
  800420dd12:	48 89 c1             	mov    %rax,%rcx
  800420dd15:	48 c1 e1 04          	shl    $0x4,%rcx
  800420dd19:	48 01 c8             	add    %rcx,%rax
  800420dd1c:	48 01 d0             	add    %rdx,%rax
  800420dd1f:	48 83 c0 08          	add    $0x8,%rax
  800420dd23:	48 8b 00             	mov    (%rax),%rax
  800420dd26:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800420dd2c:	83 f8 03             	cmp    $0x3,%eax
  800420dd2f:	0f 85 a3 00 00 00    	jne    800420ddd8 <sched_yield+0x332>
			if (curenv->env_vmxinfo.vcpunum != cpunum()) {
  800420dd35:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420dd3c:	00 00 00 
  800420dd3f:	ff d0                	callq  *%rax
  800420dd41:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420dd48:	00 00 00 
  800420dd4b:	48 98                	cltq   
  800420dd4d:	48 c1 e0 03          	shl    $0x3,%rax
  800420dd51:	48 89 c1             	mov    %rax,%rcx
  800420dd54:	48 c1 e1 04          	shl    $0x4,%rcx
  800420dd58:	48 01 c8             	add    %rcx,%rax
  800420dd5b:	48 01 d0             	add    %rdx,%rax
  800420dd5e:	48 83 c0 08          	add    $0x8,%rax
  800420dd62:	48 8b 00             	mov    (%rax),%rax
  800420dd65:	8b 98 60 01 00 00    	mov    0x160(%rax),%ebx
  800420dd6b:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420dd72:	00 00 00 
  800420dd75:	ff d0                	callq  *%rax
  800420dd77:	39 c3                	cmp    %eax,%ebx
  800420dd79:	0f 85 a6 00 00 00    	jne    800420de25 <sched_yield+0x37f>
				return;
			}
			int r = vmxon();
  800420dd7f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dd84:	48 ba 06 da 20 04 80 	movabs $0x800420da06,%rdx
  800420dd8b:	00 00 00 
  800420dd8e:	ff d2                	callq  *%rdx
  800420dd90:	89 45 dc             	mov    %eax,-0x24(%rbp)
			if(r<0) {
  800420dd93:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420dd97:	79 3f                	jns    800420ddd8 <sched_yield+0x332>
				env_destroy(curenv);
  800420dd99:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420dda0:	00 00 00 
  800420dda3:	ff d0                	callq  *%rax
  800420dda5:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420ddac:	00 00 00 
  800420ddaf:	48 98                	cltq   
  800420ddb1:	48 c1 e0 03          	shl    $0x3,%rax
  800420ddb5:	48 89 c1             	mov    %rax,%rcx
  800420ddb8:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ddbc:	48 01 c8             	add    %rcx,%rax
  800420ddbf:	48 01 d0             	add    %rdx,%rax
  800420ddc2:	48 83 c0 08          	add    $0x8,%rax
  800420ddc6:	48 8b 00             	mov    (%rax),%rax
  800420ddc9:	48 89 c7             	mov    %rax,%rdi
  800420ddcc:	48 b8 81 95 20 04 80 	movabs $0x8004209581,%rax
  800420ddd3:	00 00 00 
  800420ddd6:	ff d0                	callq  *%rax
			}
		}
		env_run(curenv);
  800420ddd8:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420dddf:	00 00 00 
  800420dde2:	ff d0                	callq  *%rax
  800420dde4:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420ddeb:	00 00 00 
  800420ddee:	48 98                	cltq   
  800420ddf0:	48 c1 e0 03          	shl    $0x3,%rax
  800420ddf4:	48 89 c1             	mov    %rax,%rcx
  800420ddf7:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ddfb:	48 01 c8             	add    %rcx,%rax
  800420ddfe:	48 01 d0             	add    %rdx,%rax
  800420de01:	48 83 c0 08          	add    $0x8,%rax
  800420de05:	48 8b 00             	mov    (%rax),%rax
  800420de08:	48 89 c7             	mov    %rax,%rdi
  800420de0b:	48 b8 4c 97 20 04 80 	movabs $0x800420974c,%rax
  800420de12:	00 00 00 
  800420de15:	ff d0                	callq  *%rax
		env_run(curenv);
	}


	// sched_halt never returns
	sched_halt();
  800420de17:	48 b8 2d de 20 04 80 	movabs $0x800420de2d,%rax
  800420de1e:	00 00 00 
  800420de21:	ff d0                	callq  *%rax
  800420de23:	eb 01                	jmp    800420de26 <sched_yield+0x380>
	if (curenv && curenv->env_status == ENV_RUNNING) {

#ifndef VMM_GUEST
		if (curenv->env_type == ENV_TYPE_GUEST) {
			if (curenv->env_vmxinfo.vcpunum != cpunum()) {
				return;
  800420de25:	90                   	nop
	}


	// sched_halt never returns
	sched_halt();
}
  800420de26:	48 83 c4 28          	add    $0x28,%rsp
  800420de2a:	5b                   	pop    %rbx
  800420de2b:	5d                   	pop    %rbp
  800420de2c:	c3                   	retq   

000000800420de2d <sched_halt>:
// Halt this CPU when there is nothing to do. Wait until the
// timer interrupt wakes it up. This function never returns.
//
void
sched_halt(void)
{
  800420de2d:	55                   	push   %rbp
  800420de2e:	48 89 e5             	mov    %rsp,%rbp
  800420de31:	48 83 ec 20          	sub    $0x20,%rsp
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420de35:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420de3c:	eb 79                	jmp    800420deb7 <sched_halt+0x8a>
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420de3e:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  800420de45:	00 00 00 
  800420de48:	48 8b 10             	mov    (%rax),%rdx
  800420de4b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420de4e:	48 98                	cltq   
  800420de50:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420de57:	48 01 d0             	add    %rdx,%rax
  800420de5a:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420de60:	83 f8 02             	cmp    $0x2,%eax
  800420de63:	74 5f                	je     800420dec4 <sched_halt+0x97>
		     envs[i].env_status == ENV_RUNNING ||
  800420de65:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  800420de6c:	00 00 00 
  800420de6f:	48 8b 10             	mov    (%rax),%rdx
  800420de72:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420de75:	48 98                	cltq   
  800420de77:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420de7e:	48 01 d0             	add    %rdx,%rax
  800420de81:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420de87:	83 f8 03             	cmp    $0x3,%eax
  800420de8a:	74 38                	je     800420dec4 <sched_halt+0x97>
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
  800420de8c:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  800420de93:	00 00 00 
  800420de96:	48 8b 10             	mov    (%rax),%rdx
  800420de99:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420de9c:	48 98                	cltq   
  800420de9e:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420dea5:	48 01 d0             	add    %rdx,%rax
  800420dea8:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
  800420deae:	83 f8 01             	cmp    $0x1,%eax
  800420deb1:	74 11                	je     800420dec4 <sched_halt+0x97>
{
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420deb3:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420deb7:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420debe:	0f 8e 7a ff ff ff    	jle    800420de3e <sched_halt+0x11>
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
			break;
	}
	if (i == NENV) {
  800420dec4:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420decb:	75 2e                	jne    800420defb <sched_halt+0xce>
		cprintf("No runnable environments in the system!\n");
  800420decd:	48 bf c8 09 22 04 80 	movabs $0x80042209c8,%rdi
  800420ded4:	00 00 00 
  800420ded7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dedc:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420dee3:	00 00 00 
  800420dee6:	ff d2                	callq  *%rdx
		while (1)
			monitor(NULL);
  800420dee8:	bf 00 00 00 00       	mov    $0x0,%edi
  800420deed:	48 b8 73 1a 20 04 80 	movabs $0x8004201a73,%rax
  800420def4:	00 00 00 
  800420def7:	ff d0                	callq  *%rax
  800420def9:	eb ed                	jmp    800420dee8 <sched_halt+0xbb>
	}

	// Mark that no environment is running on this CPU
	curenv = NULL;
  800420defb:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420df02:	00 00 00 
  800420df05:	ff d0                	callq  *%rax
  800420df07:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420df0e:	00 00 00 
  800420df11:	48 98                	cltq   
  800420df13:	48 c1 e0 03          	shl    $0x3,%rax
  800420df17:	48 89 c1             	mov    %rax,%rcx
  800420df1a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420df1e:	48 01 c8             	add    %rcx,%rax
  800420df21:	48 01 d0             	add    %rdx,%rax
  800420df24:	48 83 c0 08          	add    $0x8,%rax
  800420df28:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	lcr3(PADDR(boot_pml4e));
  800420df2f:	48 b8 f0 f5 6d 04 80 	movabs $0x80046df5f0,%rax
  800420df36:	00 00 00 
  800420df39:	48 8b 00             	mov    (%rax),%rax
  800420df3c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420df40:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420df47:	00 00 00 
  800420df4a:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420df4e:	77 32                	ja     800420df82 <sched_halt+0x155>
  800420df50:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420df54:	48 89 c1             	mov    %rax,%rcx
  800420df57:	48 ba f8 09 22 04 80 	movabs $0x80042209f8,%rdx
  800420df5e:	00 00 00 
  800420df61:	be 75 00 00 00       	mov    $0x75,%esi
  800420df66:	48 bf 1c 0a 22 04 80 	movabs $0x8004220a1c,%rdi
  800420df6d:	00 00 00 
  800420df70:	b8 00 00 00 00       	mov    $0x0,%eax
  800420df75:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420df7c:	00 00 00 
  800420df7f:	41 ff d0             	callq  *%r8
  800420df82:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420df89:	ff ff ff 
  800420df8c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420df90:	48 01 d0             	add    %rdx,%rax
  800420df93:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420df97:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420df9b:	0f 22 d8             	mov    %rax,%cr3

	// Mark that this CPU is in the HALT state, so that when
	// timer interupts come in, we know we should re-acquire the
	// big kernel lock
	xchg(&thiscpu->cpu_status, CPU_HALTED);
  800420df9e:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420dfa5:	00 00 00 
  800420dfa8:	ff d0                	callq  *%rax
  800420dfaa:	48 98                	cltq   
  800420dfac:	48 c1 e0 03          	shl    $0x3,%rax
  800420dfb0:	48 89 c2             	mov    %rax,%rdx
  800420dfb3:	48 c1 e2 04          	shl    $0x4,%rdx
  800420dfb7:	48 01 d0             	add    %rdx,%rax
  800420dfba:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420dfc1:	00 00 00 
  800420dfc4:	48 01 d0             	add    %rdx,%rax
  800420dfc7:	48 83 c0 04          	add    $0x4,%rax
  800420dfcb:	be 02 00 00 00       	mov    $0x2,%esi
  800420dfd0:	48 89 c7             	mov    %rax,%rdi
  800420dfd3:	48 b8 c2 d9 20 04 80 	movabs $0x800420d9c2,%rax
  800420dfda:	00 00 00 
  800420dfdd:	ff d0                	callq  *%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();
  800420dfdf:	48 b8 e7 d9 20 04 80 	movabs $0x800420d9e7,%rax
  800420dfe6:	00 00 00 
  800420dfe9:	ff d0                	callq  *%rax
		"movq %0, %%rsp\n"
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
  800420dfeb:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420dff2:	00 00 00 
  800420dff5:	ff d0                	callq  *%rax
  800420dff7:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420dffe:	00 00 00 
  800420e001:	48 98                	cltq   
  800420e003:	48 c1 e0 03          	shl    $0x3,%rax
  800420e007:	48 89 c1             	mov    %rax,%rcx
  800420e00a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e00e:	48 01 c8             	add    %rcx,%rax
  800420e011:	48 01 d0             	add    %rdx,%rax
  800420e014:	48 83 c0 10          	add    $0x10,%rax
  800420e018:	48 8b 40 04          	mov    0x4(%rax),%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();

	// Reset stack pointer, enable interrupts and then halt.
	asm volatile (
  800420e01c:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  800420e023:	48 89 c4             	mov    %rax,%rsp
  800420e026:	6a 00                	pushq  $0x0
  800420e028:	6a 00                	pushq  $0x0
  800420e02a:	fb                   	sti    
  800420e02b:	f4                   	hlt    
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
}
  800420e02c:	90                   	nop
  800420e02d:	c9                   	leaveq 
  800420e02e:	c3                   	retq   

000000800420e02f <page2ppn>:
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);


static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  800420e02f:	55                   	push   %rbp
  800420e030:	48 89 e5             	mov    %rsp,%rbp
  800420e033:	48 83 ec 08          	sub    $0x8,%rsp
  800420e037:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  800420e03b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420e03f:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  800420e046:	00 00 00 
  800420e049:	48 8b 00             	mov    (%rax),%rax
  800420e04c:	48 29 c2             	sub    %rax,%rdx
  800420e04f:	48 89 d0             	mov    %rdx,%rax
  800420e052:	48 c1 f8 04          	sar    $0x4,%rax
}
  800420e056:	c9                   	leaveq 
  800420e057:	c3                   	retq   

000000800420e058 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  800420e058:	55                   	push   %rbp
  800420e059:	48 89 e5             	mov    %rsp,%rbp
  800420e05c:	48 83 ec 08          	sub    $0x8,%rsp
  800420e060:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  800420e064:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e068:	48 89 c7             	mov    %rax,%rdi
  800420e06b:	48 b8 2f e0 20 04 80 	movabs $0x800420e02f,%rax
  800420e072:	00 00 00 
  800420e075:	ff d0                	callq  *%rax
  800420e077:	48 c1 e0 0c          	shl    $0xc,%rax
}
  800420e07b:	c9                   	leaveq 
  800420e07c:	c3                   	retq   

000000800420e07d <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  800420e07d:	55                   	push   %rbp
  800420e07e:	48 89 e5             	mov    %rsp,%rbp
  800420e081:	48 83 ec 10          	sub    $0x10,%rsp
  800420e085:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  800420e089:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e08d:	48 c1 e8 0c          	shr    $0xc,%rax
  800420e091:	48 89 c2             	mov    %rax,%rdx
  800420e094:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  800420e09b:	00 00 00 
  800420e09e:	48 8b 00             	mov    (%rax),%rax
  800420e0a1:	48 39 c2             	cmp    %rax,%rdx
  800420e0a4:	72 2a                	jb     800420e0d0 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  800420e0a6:	48 ba 30 0a 22 04 80 	movabs $0x8004220a30,%rdx
  800420e0ad:	00 00 00 
  800420e0b0:	be 5a 00 00 00       	mov    $0x5a,%esi
  800420e0b5:	48 bf 4f 0a 22 04 80 	movabs $0x8004220a4f,%rdi
  800420e0bc:	00 00 00 
  800420e0bf:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e0c4:	48 b9 d3 04 20 04 80 	movabs $0x80042004d3,%rcx
  800420e0cb:	00 00 00 
  800420e0ce:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  800420e0d0:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  800420e0d7:	00 00 00 
  800420e0da:	48 8b 00             	mov    (%rax),%rax
  800420e0dd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420e0e1:	48 c1 ea 0c          	shr    $0xc,%rdx
  800420e0e5:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e0e9:	48 01 d0             	add    %rdx,%rax
}
  800420e0ec:	c9                   	leaveq 
  800420e0ed:	c3                   	retq   

000000800420e0ee <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  800420e0ee:	55                   	push   %rbp
  800420e0ef:	48 89 e5             	mov    %rsp,%rbp
  800420e0f2:	48 83 ec 20          	sub    $0x20,%rsp
  800420e0f6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  800420e0fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e0fe:	48 89 c7             	mov    %rax,%rdi
  800420e101:	48 b8 58 e0 20 04 80 	movabs $0x800420e058,%rax
  800420e108:	00 00 00 
  800420e10b:	ff d0                	callq  *%rax
  800420e10d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e111:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e115:	48 c1 e8 0c          	shr    $0xc,%rax
  800420e119:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800420e11c:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420e11f:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  800420e126:	00 00 00 
  800420e129:	48 8b 00             	mov    (%rax),%rax
  800420e12c:	48 39 c2             	cmp    %rax,%rdx
  800420e12f:	72 32                	jb     800420e163 <page2kva+0x75>
  800420e131:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e135:	48 89 c1             	mov    %rax,%rcx
  800420e138:	48 ba 60 0a 22 04 80 	movabs $0x8004220a60,%rdx
  800420e13f:	00 00 00 
  800420e142:	be 61 00 00 00       	mov    $0x61,%esi
  800420e147:	48 bf 4f 0a 22 04 80 	movabs $0x8004220a4f,%rdi
  800420e14e:	00 00 00 
  800420e151:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e156:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420e15d:	00 00 00 
  800420e160:	41 ff d0             	callq  *%r8
  800420e163:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420e16a:	00 00 00 
  800420e16d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e171:	48 01 d0             	add    %rdx,%rax
}
  800420e174:	c9                   	leaveq 
  800420e175:	c3                   	retq   

000000800420e176 <sys_cputs>:
// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void
sys_cputs(const char *s, size_t len)
{
  800420e176:	55                   	push   %rbp
  800420e177:	48 89 e5             	mov    %rsp,%rbp
  800420e17a:	48 83 ec 10          	sub    $0x10,%rsp
  800420e17e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420e182:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Check that the user has permission to read memory [s, s+len).
	// Destroy the environment if not.

	// LAB 3: Your code here.

	user_mem_assert(curenv, s, len, PTE_U);
  800420e186:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420e18d:	00 00 00 
  800420e190:	ff d0                	callq  *%rax
  800420e192:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420e199:	00 00 00 
  800420e19c:	48 98                	cltq   
  800420e19e:	48 c1 e0 03          	shl    $0x3,%rax
  800420e1a2:	48 89 c1             	mov    %rax,%rcx
  800420e1a5:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e1a9:	48 01 c8             	add    %rcx,%rax
  800420e1ac:	48 01 d0             	add    %rdx,%rax
  800420e1af:	48 83 c0 08          	add    $0x8,%rax
  800420e1b3:	48 8b 00             	mov    (%rax),%rax
  800420e1b6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e1ba:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420e1be:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420e1c3:	48 89 c7             	mov    %rax,%rdi
  800420e1c6:	48 b8 7e 41 20 04 80 	movabs $0x800420417e,%rax
  800420e1cd:	00 00 00 
  800420e1d0:	ff d0                	callq  *%rax


	// Print the string supplied by the user.
	cprintf("%.*s", len, s);
  800420e1d2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420e1d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e1da:	48 89 c6             	mov    %rax,%rsi
  800420e1dd:	48 bf 83 0a 22 04 80 	movabs $0x8004220a83,%rdi
  800420e1e4:	00 00 00 
  800420e1e7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e1ec:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800420e1f3:	00 00 00 
  800420e1f6:	ff d1                	callq  *%rcx
}
  800420e1f8:	90                   	nop
  800420e1f9:	c9                   	leaveq 
  800420e1fa:	c3                   	retq   

000000800420e1fb <sys_cgetc>:

// Read a character from the system console without blocking.
// Returns the character, or 0 if there is no input waiting.
static int
sys_cgetc(void)
{
  800420e1fb:	55                   	push   %rbp
  800420e1fc:	48 89 e5             	mov    %rsp,%rbp
	return cons_getc();
  800420e1ff:	48 b8 c0 10 20 04 80 	movabs $0x80042010c0,%rax
  800420e206:	00 00 00 
  800420e209:	ff d0                	callq  *%rax
}
  800420e20b:	5d                   	pop    %rbp
  800420e20c:	c3                   	retq   

000000800420e20d <sys_getenvid>:

// Returns the current environment's envid.
static envid_t
sys_getenvid(void)
{
  800420e20d:	55                   	push   %rbp
  800420e20e:	48 89 e5             	mov    %rsp,%rbp
	return curenv->env_id;
  800420e211:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420e218:	00 00 00 
  800420e21b:	ff d0                	callq  *%rax
  800420e21d:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420e224:	00 00 00 
  800420e227:	48 98                	cltq   
  800420e229:	48 c1 e0 03          	shl    $0x3,%rax
  800420e22d:	48 89 c1             	mov    %rax,%rcx
  800420e230:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e234:	48 01 c8             	add    %rcx,%rax
  800420e237:	48 01 d0             	add    %rdx,%rax
  800420e23a:	48 83 c0 08          	add    $0x8,%rax
  800420e23e:	48 8b 00             	mov    (%rax),%rax
  800420e241:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420e247:	5d                   	pop    %rbp
  800420e248:	c3                   	retq   

000000800420e249 <sys_env_destroy>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_destroy(envid_t envid)
{
  800420e249:	55                   	push   %rbp
  800420e24a:	48 89 e5             	mov    %rsp,%rbp
  800420e24d:	48 83 ec 20          	sub    $0x20,%rsp
  800420e251:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420e254:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420e258:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e25b:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e260:	48 89 ce             	mov    %rcx,%rsi
  800420e263:	89 c7                	mov    %eax,%edi
  800420e265:	48 b8 34 7e 20 04 80 	movabs $0x8004207e34,%rax
  800420e26c:	00 00 00 
  800420e26f:	ff d0                	callq  *%rax
  800420e271:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e274:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e278:	79 05                	jns    800420e27f <sys_env_destroy+0x36>
		return r;
  800420e27a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e27d:	eb 18                	jmp    800420e297 <sys_env_destroy+0x4e>

	env_destroy(e);
  800420e27f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e283:	48 89 c7             	mov    %rax,%rdi
  800420e286:	48 b8 81 95 20 04 80 	movabs $0x8004209581,%rax
  800420e28d:	00 00 00 
  800420e290:	ff d0                	callq  *%rax
	return 0;
  800420e292:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420e297:	c9                   	leaveq 
  800420e298:	c3                   	retq   

000000800420e299 <sys_yield>:


// Deschedule current environment and pick a different one to run.
static void
sys_yield(void)
{
  800420e299:	55                   	push   %rbp
  800420e29a:	48 89 e5             	mov    %rsp,%rbp
	sched_yield();
  800420e29d:	48 b8 a6 da 20 04 80 	movabs $0x800420daa6,%rax
  800420e2a4:	00 00 00 
  800420e2a7:	ff d0                	callq  *%rax

000000800420e2a9 <sys_exofork>:
// Returns envid of new environment, or < 0 on error.  Errors are:
//	-E_NO_FREE_ENV if no free environment is available.
//	-E_NO_MEM on memory exhaustion.
static envid_t
sys_exofork(void)
{
  800420e2a9:	55                   	push   %rbp
  800420e2aa:	48 89 e5             	mov    %rsp,%rbp
  800420e2ad:	53                   	push   %rbx
  800420e2ae:	48 83 ec 18          	sub    $0x18,%rsp

	int r;
	struct Env *e;

	if ((r = env_alloc(&e, curenv->env_id)) < 0)
  800420e2b2:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420e2b9:	00 00 00 
  800420e2bc:	ff d0                	callq  *%rax
  800420e2be:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420e2c5:	00 00 00 
  800420e2c8:	48 98                	cltq   
  800420e2ca:	48 c1 e0 03          	shl    $0x3,%rax
  800420e2ce:	48 89 c1             	mov    %rax,%rcx
  800420e2d1:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e2d5:	48 01 c8             	add    %rcx,%rax
  800420e2d8:	48 01 d0             	add    %rdx,%rax
  800420e2db:	48 83 c0 08          	add    $0x8,%rax
  800420e2df:	48 8b 00             	mov    (%rax),%rax
  800420e2e2:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420e2e8:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420e2ec:	89 d6                	mov    %edx,%esi
  800420e2ee:	48 89 c7             	mov    %rax,%rdi
  800420e2f1:	48 b8 ad 89 20 04 80 	movabs $0x80042089ad,%rax
  800420e2f8:	00 00 00 
  800420e2fb:	ff d0                	callq  *%rax
  800420e2fd:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420e300:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420e304:	79 05                	jns    800420e30b <sys_exofork+0x62>
		return r;
  800420e306:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e309:	eb 6c                	jmp    800420e377 <sys_exofork+0xce>
	e->env_status = ENV_NOT_RUNNABLE;
  800420e30b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e30f:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420e316:	00 00 00 
	e->env_tf = curenv->env_tf;
  800420e319:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420e31d:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420e324:	00 00 00 
  800420e327:	ff d0                	callq  *%rax
  800420e329:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420e330:	00 00 00 
  800420e333:	48 98                	cltq   
  800420e335:	48 c1 e0 03          	shl    $0x3,%rax
  800420e339:	48 89 c1             	mov    %rax,%rcx
  800420e33c:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e340:	48 01 c8             	add    %rcx,%rax
  800420e343:	48 01 d0             	add    %rdx,%rax
  800420e346:	48 83 c0 08          	add    $0x8,%rax
  800420e34a:	48 8b 00             	mov    (%rax),%rax
  800420e34d:	48 89 da             	mov    %rbx,%rdx
  800420e350:	48 89 c6             	mov    %rax,%rsi
  800420e353:	b8 18 00 00 00       	mov    $0x18,%eax
  800420e358:	48 89 d7             	mov    %rdx,%rdi
  800420e35b:	48 89 c1             	mov    %rax,%rcx
  800420e35e:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	e->env_tf.tf_regs.reg_rax = 0;
  800420e361:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e365:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420e36c:	00 
	return e->env_id;
  800420e36d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e371:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax

}
  800420e377:	48 83 c4 18          	add    $0x18,%rsp
  800420e37b:	5b                   	pop    %rbx
  800420e37c:	5d                   	pop    %rbp
  800420e37d:	c3                   	retq   

000000800420e37e <sys_env_set_status>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if status is not a valid status for an environment.
static int
sys_env_set_status(envid_t envid, int status)
{
  800420e37e:	55                   	push   %rbp
  800420e37f:	48 89 e5             	mov    %rsp,%rbp
  800420e382:	48 83 ec 20          	sub    $0x20,%rsp
  800420e386:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420e389:	89 75 e8             	mov    %esi,-0x18(%rbp)

	struct Env *e;
	int r;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420e38c:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420e390:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e393:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e398:	48 89 ce             	mov    %rcx,%rsi
  800420e39b:	89 c7                	mov    %eax,%edi
  800420e39d:	48 b8 34 7e 20 04 80 	movabs $0x8004207e34,%rax
  800420e3a4:	00 00 00 
  800420e3a7:	ff d0                	callq  *%rax
  800420e3a9:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e3ac:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e3b0:	79 05                	jns    800420e3b7 <sys_env_set_status+0x39>
		return r;
  800420e3b2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e3b5:	eb 25                	jmp    800420e3dc <sys_env_set_status+0x5e>
	if (status != ENV_RUNNABLE && status != ENV_NOT_RUNNABLE)
  800420e3b7:	83 7d e8 02          	cmpl   $0x2,-0x18(%rbp)
  800420e3bb:	74 0d                	je     800420e3ca <sys_env_set_status+0x4c>
  800420e3bd:	83 7d e8 04          	cmpl   $0x4,-0x18(%rbp)
  800420e3c1:	74 07                	je     800420e3ca <sys_env_set_status+0x4c>
		return -E_INVAL;
  800420e3c3:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e3c8:	eb 12                	jmp    800420e3dc <sys_env_set_status+0x5e>
	e->env_status = status;
  800420e3ca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e3ce:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420e3d1:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
	return 0;
  800420e3d7:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420e3dc:	c9                   	leaveq 
  800420e3dd:	c3                   	retq   

000000800420e3de <sys_env_set_trapframe>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  800420e3de:	55                   	push   %rbp
  800420e3df:	48 89 e5             	mov    %rsp,%rbp
  800420e3e2:	48 81 ec e0 00 00 00 	sub    $0xe0,%rsp
  800420e3e9:	89 bd 2c ff ff ff    	mov    %edi,-0xd4(%rbp)
  800420e3ef:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)

	int r;
	struct Env *e;
	struct Trapframe ltf;

	user_mem_assert(curenv, tf, sizeof(struct Trapframe), PTE_U);
  800420e3f6:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420e3fd:	00 00 00 
  800420e400:	ff d0                	callq  *%rax
  800420e402:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420e409:	00 00 00 
  800420e40c:	48 98                	cltq   
  800420e40e:	48 c1 e0 03          	shl    $0x3,%rax
  800420e412:	48 89 c1             	mov    %rax,%rcx
  800420e415:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e419:	48 01 c8             	add    %rcx,%rax
  800420e41c:	48 01 d0             	add    %rdx,%rax
  800420e41f:	48 83 c0 08          	add    $0x8,%rax
  800420e423:	48 8b 00             	mov    (%rax),%rax
  800420e426:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800420e42d:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420e432:	ba c0 00 00 00       	mov    $0xc0,%edx
  800420e437:	48 89 c7             	mov    %rax,%rdi
  800420e43a:	48 b8 7e 41 20 04 80 	movabs $0x800420417e,%rax
  800420e441:	00 00 00 
  800420e444:	ff d0                	callq  *%rax
	ltf = *tf;
  800420e446:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
  800420e44d:	48 8d 85 30 ff ff ff 	lea    -0xd0(%rbp),%rax
  800420e454:	48 89 d6             	mov    %rdx,%rsi
  800420e457:	ba 18 00 00 00       	mov    $0x18,%edx
  800420e45c:	48 89 c7             	mov    %rax,%rdi
  800420e45f:	48 89 d1             	mov    %rdx,%rcx
  800420e462:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	ltf.tf_eflags |= FL_IF;
  800420e465:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e469:	80 cc 02             	or     $0x2,%ah
  800420e46c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	ltf.tf_cs |= 3;
  800420e470:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  800420e474:	83 c8 03             	or     $0x3,%eax
  800420e477:	66 89 45 d0          	mov    %ax,-0x30(%rbp)

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420e47b:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420e47f:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
  800420e485:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e48a:	48 89 ce             	mov    %rcx,%rsi
  800420e48d:	89 c7                	mov    %eax,%edi
  800420e48f:	48 b8 34 7e 20 04 80 	movabs $0x8004207e34,%rax
  800420e496:	00 00 00 
  800420e499:	ff d0                	callq  *%rax
  800420e49b:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e49e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e4a2:	79 05                	jns    800420e4a9 <sys_env_set_trapframe+0xcb>
		return r;
  800420e4a4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e4a7:	eb 21                	jmp    800420e4ca <sys_env_set_trapframe+0xec>
	e->env_tf = ltf;
  800420e4a9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e4ad:	48 89 c7             	mov    %rax,%rdi
  800420e4b0:	48 8d 85 30 ff ff ff 	lea    -0xd0(%rbp),%rax
  800420e4b7:	ba 18 00 00 00       	mov    $0x18,%edx
  800420e4bc:	48 89 c6             	mov    %rax,%rsi
  800420e4bf:	48 89 d1             	mov    %rdx,%rcx
  800420e4c2:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	return 0;
  800420e4c5:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420e4ca:	c9                   	leaveq 
  800420e4cb:	c3                   	retq   

000000800420e4cc <sys_env_set_pgfault_upcall>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
  800420e4cc:	55                   	push   %rbp
  800420e4cd:	48 89 e5             	mov    %rsp,%rbp
  800420e4d0:	48 83 ec 20          	sub    $0x20,%rsp
  800420e4d4:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420e4d7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420e4db:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420e4df:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e4e2:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e4e7:	48 89 ce             	mov    %rcx,%rsi
  800420e4ea:	89 c7                	mov    %eax,%edi
  800420e4ec:	48 b8 34 7e 20 04 80 	movabs $0x8004207e34,%rax
  800420e4f3:	00 00 00 
  800420e4f6:	ff d0                	callq  *%rax
  800420e4f8:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e4fb:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e4ff:	79 05                	jns    800420e506 <sys_env_set_pgfault_upcall+0x3a>
		return r;
  800420e501:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e504:	eb 14                	jmp    800420e51a <sys_env_set_pgfault_upcall+0x4e>
	e->env_pgfault_upcall = func;
  800420e506:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e50a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420e50e:	48 89 90 f0 00 00 00 	mov    %rdx,0xf0(%rax)
	return 0;
  800420e515:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420e51a:	c9                   	leaveq 
  800420e51b:	c3                   	retq   

000000800420e51c <sys_page_alloc>:
//	-E_INVAL if perm is inappropriate (see above).
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  800420e51c:	55                   	push   %rbp
  800420e51d:	48 89 e5             	mov    %rsp,%rbp
  800420e520:	48 83 ec 30          	sub    $0x30,%rsp
  800420e524:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420e527:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420e52b:	89 55 d8             	mov    %edx,-0x28(%rbp)

	int r;
	struct Env *e;
	struct PageInfo *pp;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420e52e:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420e532:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420e535:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e53a:	48 89 ce             	mov    %rcx,%rsi
  800420e53d:	89 c7                	mov    %eax,%edi
  800420e53f:	48 b8 34 7e 20 04 80 	movabs $0x8004207e34,%rax
  800420e546:	00 00 00 
  800420e549:	ff d0                	callq  *%rax
  800420e54b:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e54e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e552:	79 08                	jns    800420e55c <sys_page_alloc+0x40>
		return r;
  800420e554:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e557:	e9 a7 00 00 00       	jmpq   800420e603 <sys_page_alloc+0xe7>
	if ((~perm & (PTE_U|PTE_P)) || (perm & ~PTE_SYSCALL))
  800420e55c:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420e55f:	f7 d0                	not    %eax
  800420e561:	83 e0 05             	and    $0x5,%eax
  800420e564:	85 c0                	test   %eax,%eax
  800420e566:	75 0c                	jne    800420e574 <sys_page_alloc+0x58>
  800420e568:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420e56b:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420e570:	85 c0                	test   %eax,%eax
  800420e572:	74 0a                	je     800420e57e <sys_page_alloc+0x62>
		return -E_INVAL;
  800420e574:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e579:	e9 85 00 00 00       	jmpq   800420e603 <sys_page_alloc+0xe7>
	if (va >= (void*) UTOP)
  800420e57e:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e585:	00 00 00 
  800420e588:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420e58c:	76 07                	jbe    800420e595 <sys_page_alloc+0x79>
		return -E_INVAL;
  800420e58e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e593:	eb 6e                	jmp    800420e603 <sys_page_alloc+0xe7>
	if (!(pp = page_alloc(ALLOC_ZERO)))
  800420e595:	bf 01 00 00 00       	mov    $0x1,%edi
  800420e59a:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  800420e5a1:	00 00 00 
  800420e5a4:	ff d0                	callq  *%rax
  800420e5a6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420e5aa:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420e5af:	75 07                	jne    800420e5b8 <sys_page_alloc+0x9c>
		return -E_NO_MEM;
  800420e5b1:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420e5b6:	eb 4b                	jmp    800420e603 <sys_page_alloc+0xe7>
	if ((r = page_insert(e->env_pml4e, pp, va, perm)) < 0) {
  800420e5b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e5bc:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e5c3:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  800420e5c6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e5ca:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420e5ce:	48 89 c7             	mov    %rax,%rdi
  800420e5d1:	48 b8 33 3a 20 04 80 	movabs $0x8004203a33,%rax
  800420e5d8:	00 00 00 
  800420e5db:	ff d0                	callq  *%rax
  800420e5dd:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e5e0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e5e4:	79 18                	jns    800420e5fe <sys_page_alloc+0xe2>
		page_free(pp);
  800420e5e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e5ea:	48 89 c7             	mov    %rax,%rdi
  800420e5ed:	48 b8 65 2f 20 04 80 	movabs $0x8004202f65,%rax
  800420e5f4:	00 00 00 
  800420e5f7:	ff d0                	callq  *%rax
		return r;
  800420e5f9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e5fc:	eb 05                	jmp    800420e603 <sys_page_alloc+0xe7>
	}
	return 0;
  800420e5fe:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420e603:	c9                   	leaveq 
  800420e604:	c3                   	retq   

000000800420e605 <sys_page_map>:
//		address space.
//	-E_NO_MEM if there's no memory to allocate any necessary page tables.
static int
sys_page_map(envid_t srcenvid, void *srcva,
	     envid_t dstenvid, void *dstva, int perm)
{
  800420e605:	55                   	push   %rbp
  800420e606:	48 89 e5             	mov    %rsp,%rbp
  800420e609:	48 83 ec 60          	sub    $0x60,%rsp
  800420e60d:	89 7d bc             	mov    %edi,-0x44(%rbp)
  800420e610:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800420e614:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420e617:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  800420e61b:	44 89 45 a4          	mov    %r8d,-0x5c(%rbp)
	int r;
	struct Env *es, *ed;
	struct PageInfo *pp;
	pte_t *ppte;

	if (srcva >= (void*) UTOP || dstva >= (void*) UTOP)
  800420e61f:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e626:	00 00 00 
  800420e629:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  800420e62d:	77 10                	ja     800420e63f <sys_page_map+0x3a>
  800420e62f:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e636:	00 00 00 
  800420e639:	48 39 45 a8          	cmp    %rax,-0x58(%rbp)
  800420e63d:	76 0a                	jbe    800420e649 <sys_page_map+0x44>
		return -E_INVAL;
  800420e63f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e644:	e9 3f 01 00 00       	jmpq   800420e788 <sys_page_map+0x183>
	if (srcva != ROUNDDOWN(srcva, PGSIZE) || dstva != ROUNDDOWN(dstva, PGSIZE))
  800420e649:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420e64d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420e651:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e655:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420e65b:	48 3b 45 b0          	cmp    -0x50(%rbp),%rax
  800420e65f:	75 18                	jne    800420e679 <sys_page_map+0x74>
  800420e661:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e665:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420e669:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e66d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420e673:	48 3b 45 a8          	cmp    -0x58(%rbp),%rax
  800420e677:	74 0a                	je     800420e683 <sys_page_map+0x7e>
		return -E_INVAL;
  800420e679:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e67e:	e9 05 01 00 00       	jmpq   800420e788 <sys_page_map+0x183>

	if ((r = envid2env(srcenvid, &es, 1)) < 0
  800420e683:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800420e687:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420e68a:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e68f:	48 89 ce             	mov    %rcx,%rsi
  800420e692:	89 c7                	mov    %eax,%edi
  800420e694:	48 b8 34 7e 20 04 80 	movabs $0x8004207e34,%rax
  800420e69b:	00 00 00 
  800420e69e:	ff d0                	callq  *%rax
  800420e6a0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e6a3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e6a7:	78 26                	js     800420e6cf <sys_page_map+0xca>
            || (r = envid2env(dstenvid, &ed, 1)) < 0)
  800420e6a9:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800420e6ad:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e6b0:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e6b5:	48 89 ce             	mov    %rcx,%rsi
  800420e6b8:	89 c7                	mov    %eax,%edi
  800420e6ba:	48 b8 34 7e 20 04 80 	movabs $0x8004207e34,%rax
  800420e6c1:	00 00 00 
  800420e6c4:	ff d0                	callq  *%rax
  800420e6c6:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e6c9:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e6cd:	79 08                	jns    800420e6d7 <sys_page_map+0xd2>
		return r;
  800420e6cf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e6d2:	e9 b1 00 00 00       	jmpq   800420e788 <sys_page_map+0x183>
	if ((~perm & (PTE_U|PTE_P)) || (perm & ~PTE_SYSCALL))
  800420e6d7:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800420e6da:	f7 d0                	not    %eax
  800420e6dc:	83 e0 05             	and    $0x5,%eax
  800420e6df:	85 c0                	test   %eax,%eax
  800420e6e1:	75 0c                	jne    800420e6ef <sys_page_map+0xea>
  800420e6e3:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800420e6e6:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420e6eb:	85 c0                	test   %eax,%eax
  800420e6ed:	74 0a                	je     800420e6f9 <sys_page_map+0xf4>
		return -E_INVAL;
  800420e6ef:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e6f4:	e9 8f 00 00 00       	jmpq   800420e788 <sys_page_map+0x183>
	if ((pp = page_lookup(es->env_pml4e, srcva, &ppte)) == 0)
  800420e6f9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e6fd:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e704:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  800420e708:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800420e70c:	48 89 ce             	mov    %rcx,%rsi
  800420e70f:	48 89 c7             	mov    %rax,%rdi
  800420e712:	48 b8 a7 3d 20 04 80 	movabs $0x8004203da7,%rax
  800420e719:	00 00 00 
  800420e71c:	ff d0                	callq  *%rax
  800420e71e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420e722:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420e727:	75 07                	jne    800420e730 <sys_page_map+0x12b>
		return -E_INVAL;
  800420e729:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e72e:	eb 58                	jmp    800420e788 <sys_page_map+0x183>
	if ((perm & PTE_W) && !(*ppte & PTE_W))
  800420e730:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800420e733:	83 e0 02             	and    $0x2,%eax
  800420e736:	85 c0                	test   %eax,%eax
  800420e738:	74 16                	je     800420e750 <sys_page_map+0x14b>
  800420e73a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e73e:	48 8b 00             	mov    (%rax),%rax
  800420e741:	83 e0 02             	and    $0x2,%eax
  800420e744:	48 85 c0             	test   %rax,%rax
  800420e747:	75 07                	jne    800420e750 <sys_page_map+0x14b>
		return -E_INVAL;
  800420e749:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e74e:	eb 38                	jmp    800420e788 <sys_page_map+0x183>
	if ((r = page_insert(ed->env_pml4e, pp, dstva, perm)) < 0)
  800420e750:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e754:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e75b:	8b 4d a4             	mov    -0x5c(%rbp),%ecx
  800420e75e:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420e762:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420e766:	48 89 c7             	mov    %rax,%rdi
  800420e769:	48 b8 33 3a 20 04 80 	movabs $0x8004203a33,%rax
  800420e770:	00 00 00 
  800420e773:	ff d0                	callq  *%rax
  800420e775:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e778:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e77c:	79 05                	jns    800420e783 <sys_page_map+0x17e>
		return r;
  800420e77e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e781:	eb 05                	jmp    800420e788 <sys_page_map+0x183>
	return 0;
  800420e783:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420e788:	c9                   	leaveq 
  800420e789:	c3                   	retq   

000000800420e78a <sys_page_unmap>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int
sys_page_unmap(envid_t envid, void *va)
{
  800420e78a:	55                   	push   %rbp
  800420e78b:	48 89 e5             	mov    %rsp,%rbp
  800420e78e:	48 83 ec 20          	sub    $0x20,%rsp
  800420e792:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420e795:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420e799:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420e79d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e7a0:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e7a5:	48 89 ce             	mov    %rcx,%rsi
  800420e7a8:	89 c7                	mov    %eax,%edi
  800420e7aa:	48 b8 34 7e 20 04 80 	movabs $0x8004207e34,%rax
  800420e7b1:	00 00 00 
  800420e7b4:	ff d0                	callq  *%rax
  800420e7b6:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e7b9:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e7bd:	79 05                	jns    800420e7c4 <sys_page_unmap+0x3a>
		return r;
  800420e7bf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e7c2:	eb 4b                	jmp    800420e80f <sys_page_unmap+0x85>
	if (va >= (void*) UTOP || PGOFF(va))
  800420e7c4:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e7cb:	00 00 00 
  800420e7ce:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  800420e7d2:	77 0e                	ja     800420e7e2 <sys_page_unmap+0x58>
  800420e7d4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e7d8:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420e7dd:	48 85 c0             	test   %rax,%rax
  800420e7e0:	74 07                	je     800420e7e9 <sys_page_unmap+0x5f>
		return -E_INVAL;
  800420e7e2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e7e7:	eb 26                	jmp    800420e80f <sys_page_unmap+0x85>
	page_remove(e->env_pml4e, va);
  800420e7e9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e7ed:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e7f4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420e7f8:	48 89 d6             	mov    %rdx,%rsi
  800420e7fb:	48 89 c7             	mov    %rax,%rdi
  800420e7fe:	48 b8 32 3e 20 04 80 	movabs $0x8004203e32,%rax
  800420e805:	00 00 00 
  800420e808:	ff d0                	callq  *%rax
	return 0;
  800420e80a:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420e80f:	c9                   	leaveq 
  800420e810:	c3                   	retq   

000000800420e811 <sys_ipc_try_send>:
//		current environment's address space.
//	-E_NO_MEM if there's not enough memory to map srcva in envid's
//		address space.
static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
  800420e811:	55                   	push   %rbp
  800420e812:	48 89 e5             	mov    %rsp,%rbp
  800420e815:	53                   	push   %rbx
  800420e816:	48 83 ec 58          	sub    $0x58,%rsp
  800420e81a:	89 7d bc             	mov    %edi,-0x44(%rbp)
  800420e81d:	89 75 b8             	mov    %esi,-0x48(%rbp)
  800420e820:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420e824:	89 4d ac             	mov    %ecx,-0x54(%rbp)

	int r;
	struct Env *e;
	struct PageInfo *pp;
	pte_t *ppte;    
	if ((r = envid2env(envid, &e, 0)) < 0)
  800420e827:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800420e82b:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420e82e:	ba 00 00 00 00       	mov    $0x0,%edx
  800420e833:	48 89 ce             	mov    %rcx,%rsi
  800420e836:	89 c7                	mov    %eax,%edi
  800420e838:	48 b8 34 7e 20 04 80 	movabs $0x8004207e34,%rax
  800420e83f:	00 00 00 
  800420e842:	ff d0                	callq  *%rax
  800420e844:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420e847:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420e84b:	79 08                	jns    800420e855 <sys_ipc_try_send+0x44>
		return r;
  800420e84d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e850:	e9 89 06 00 00       	jmpq   800420eede <sys_ipc_try_send+0x6cd>
	if (!e->env_ipc_recving) {
  800420e855:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e859:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420e860:	83 f0 01             	xor    $0x1,%eax
  800420e863:	84 c0                	test   %al,%al
  800420e865:	74 0a                	je     800420e871 <sys_ipc_try_send+0x60>
		/* cprintf("[%08x] not recieving!\n", e->env_id); */
		return -E_IPC_NOT_RECV;
  800420e867:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  800420e86c:	e9 6d 06 00 00       	jmpq   800420eede <sys_ipc_try_send+0x6cd>
	}
    

	if(curenv->env_type == ENV_TYPE_GUEST && e->env_ipc_dstva < (void*) UTOP) {
  800420e871:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420e878:	00 00 00 
  800420e87b:	ff d0                	callq  *%rax
  800420e87d:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420e884:	00 00 00 
  800420e887:	48 98                	cltq   
  800420e889:	48 c1 e0 03          	shl    $0x3,%rax
  800420e88d:	48 89 c1             	mov    %rax,%rcx
  800420e890:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e894:	48 01 c8             	add    %rcx,%rax
  800420e897:	48 01 d0             	add    %rdx,%rax
  800420e89a:	48 83 c0 08          	add    $0x8,%rax
  800420e89e:	48 8b 00             	mov    (%rax),%rax
  800420e8a1:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800420e8a7:	83 f8 03             	cmp    $0x3,%eax
  800420e8aa:	0f 85 7b 01 00 00    	jne    800420ea2b <sys_ipc_try_send+0x21a>
  800420e8b0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e8b4:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420e8bb:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e8c2:	00 00 00 
  800420e8c5:	48 39 c2             	cmp    %rax,%rdx
  800420e8c8:	0f 87 5d 01 00 00    	ja     800420ea2b <sys_ipc_try_send+0x21a>
		// Guest sending a message. srcva is a kernel page.
		/* cprintf("Sending message from a guest\n"); */
		assert(srcva >= (void*)KERNBASE);
  800420e8ce:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420e8d5:	00 00 00 
  800420e8d8:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  800420e8dc:	77 35                	ja     800420e913 <sys_ipc_try_send+0x102>
  800420e8de:	48 b9 88 0a 22 04 80 	movabs $0x8004220a88,%rcx
  800420e8e5:	00 00 00 
  800420e8e8:	48 ba a1 0a 22 04 80 	movabs $0x8004220aa1,%rdx
  800420e8ef:	00 00 00 
  800420e8f2:	be 63 01 00 00       	mov    $0x163,%esi
  800420e8f7:	48 bf b6 0a 22 04 80 	movabs $0x8004220ab6,%rdi
  800420e8fe:	00 00 00 
  800420e901:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e906:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420e90d:	00 00 00 
  800420e910:	41 ff d0             	callq  *%r8
		pp = pa2page(PADDR(srcva));
  800420e913:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420e917:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420e91b:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420e922:	00 00 00 
  800420e925:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  800420e929:	77 32                	ja     800420e95d <sys_ipc_try_send+0x14c>
  800420e92b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e92f:	48 89 c1             	mov    %rax,%rcx
  800420e932:	48 ba c8 0a 22 04 80 	movabs $0x8004220ac8,%rdx
  800420e939:	00 00 00 
  800420e93c:	be 64 01 00 00       	mov    $0x164,%esi
  800420e941:	48 bf b6 0a 22 04 80 	movabs $0x8004220ab6,%rdi
  800420e948:	00 00 00 
  800420e94b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e950:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420e957:	00 00 00 
  800420e95a:	41 ff d0             	callq  *%r8
  800420e95d:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420e964:	ff ff ff 
  800420e967:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e96b:	48 01 d0             	add    %rdx,%rax
  800420e96e:	48 89 c7             	mov    %rax,%rdi
  800420e971:	48 b8 7d e0 20 04 80 	movabs $0x800420e07d,%rax
  800420e978:	00 00 00 
  800420e97b:	ff d0                	callq  *%rax
  800420e97d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

		r = page_insert(e->env_pml4e, pp, e->env_ipc_dstva, perm);
  800420e981:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  800420e984:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e988:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420e98f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e993:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e99a:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  800420e99e:	48 89 c7             	mov    %rax,%rdi
  800420e9a1:	48 b8 33 3a 20 04 80 	movabs $0x8004203a33,%rax
  800420e9a8:	00 00 00 
  800420e9ab:	ff d0                	callq  *%rax
  800420e9ad:	89 45 ec             	mov    %eax,-0x14(%rbp)
		if (r < 0) {
  800420e9b0:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420e9b4:	79 63                	jns    800420ea19 <sys_ipc_try_send+0x208>
			cprintf("[%08x] page_insert %08x failed in sys_ipc_try_send (%e)\n", curenv->env_id, srcva, r);
  800420e9b6:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420e9bd:	00 00 00 
  800420e9c0:	ff d0                	callq  *%rax
  800420e9c2:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420e9c9:	00 00 00 
  800420e9cc:	48 98                	cltq   
  800420e9ce:	48 c1 e0 03          	shl    $0x3,%rax
  800420e9d2:	48 89 c1             	mov    %rax,%rcx
  800420e9d5:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e9d9:	48 01 c8             	add    %rcx,%rax
  800420e9dc:	48 01 d0             	add    %rdx,%rax
  800420e9df:	48 83 c0 08          	add    $0x8,%rax
  800420e9e3:	48 8b 00             	mov    (%rax),%rax
  800420e9e6:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420e9ec:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  800420e9ef:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420e9f3:	89 c6                	mov    %eax,%esi
  800420e9f5:	48 bf f0 0a 22 04 80 	movabs $0x8004220af0,%rdi
  800420e9fc:	00 00 00 
  800420e9ff:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ea04:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800420ea0b:	00 00 00 
  800420ea0e:	41 ff d0             	callq  *%r8
			return r;
  800420ea11:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ea14:	e9 c5 04 00 00       	jmpq   800420eede <sys_ipc_try_send+0x6cd>
		}

		e->env_ipc_perm = perm;
  800420ea19:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ea1d:	8b 55 ac             	mov    -0x54(%rbp),%edx
  800420ea20:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
  800420ea26:	e9 22 04 00 00       	jmpq   800420ee4d <sys_ipc_try_send+0x63c>
	} else if(e->env_type == ENV_TYPE_GUEST && srcva < (void*) UTOP) {
  800420ea2b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ea2f:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800420ea35:	83 f8 03             	cmp    $0x3,%eax
  800420ea38:	0f 85 7d 01 00 00    	jne    800420ebbb <sys_ipc_try_send+0x3aa>
  800420ea3e:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420ea45:	00 00 00 
  800420ea48:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  800420ea4c:	0f 87 69 01 00 00    	ja     800420ebbb <sys_ipc_try_send+0x3aa>
		// Sending a message to a VMX guest.
		/* cprintf("Sending message to guest\n"); */
		pp = page_lookup(curenv->env_pml4e, srcva, &ppte);
  800420ea52:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420ea59:	00 00 00 
  800420ea5c:	ff d0                	callq  *%rax
  800420ea5e:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420ea65:	00 00 00 
  800420ea68:	48 98                	cltq   
  800420ea6a:	48 c1 e0 03          	shl    $0x3,%rax
  800420ea6e:	48 89 c1             	mov    %rax,%rcx
  800420ea71:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ea75:	48 01 c8             	add    %rcx,%rax
  800420ea78:	48 01 d0             	add    %rdx,%rax
  800420ea7b:	48 83 c0 08          	add    $0x8,%rax
  800420ea7f:	48 8b 00             	mov    (%rax),%rax
  800420ea82:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420ea89:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  800420ea8d:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800420ea91:	48 89 ce             	mov    %rcx,%rsi
  800420ea94:	48 89 c7             	mov    %rax,%rdi
  800420ea97:	48 b8 a7 3d 20 04 80 	movabs $0x8004203da7,%rax
  800420ea9e:	00 00 00 
  800420eaa1:	ff d0                	callq  *%rax
  800420eaa3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		if(pp == 0) {
  800420eaa7:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420eaac:	75 61                	jne    800420eb0f <sys_ipc_try_send+0x2fe>
			cprintf("[%08x] page_lookup %08x failed in sys_ipc_try_send\n", curenv->env_id, srcva);
  800420eaae:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420eab5:	00 00 00 
  800420eab8:	ff d0                	callq  *%rax
  800420eaba:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420eac1:	00 00 00 
  800420eac4:	48 98                	cltq   
  800420eac6:	48 c1 e0 03          	shl    $0x3,%rax
  800420eaca:	48 89 c1             	mov    %rax,%rcx
  800420eacd:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ead1:	48 01 c8             	add    %rcx,%rax
  800420ead4:	48 01 d0             	add    %rdx,%rax
  800420ead7:	48 83 c0 08          	add    $0x8,%rax
  800420eadb:	48 8b 00             	mov    (%rax),%rax
  800420eade:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420eae4:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420eae8:	89 c6                	mov    %eax,%esi
  800420eaea:	48 bf 30 0b 22 04 80 	movabs $0x8004220b30,%rdi
  800420eaf1:	00 00 00 
  800420eaf4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420eaf9:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800420eb00:	00 00 00 
  800420eb03:	ff d1                	callq  *%rcx
			return -E_INVAL;
  800420eb05:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420eb0a:	e9 cf 03 00 00       	jmpq   800420eede <sys_ipc_try_send+0x6cd>
		}

		if ((perm & PTE_W) && !(*ppte &PTE_W)) {
  800420eb0f:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800420eb12:	83 e0 02             	and    $0x2,%eax
  800420eb15:	85 c0                	test   %eax,%eax
  800420eb17:	74 6c                	je     800420eb85 <sys_ipc_try_send+0x374>
  800420eb19:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420eb1d:	48 8b 00             	mov    (%rax),%rax
  800420eb20:	83 e0 02             	and    $0x2,%eax
  800420eb23:	48 85 c0             	test   %rax,%rax
  800420eb26:	75 5d                	jne    800420eb85 <sys_ipc_try_send+0x374>
			cprintf("[%08x] attempt to send read-only page read-write in sys_ipc_try_send\n", curenv->env_id);
  800420eb28:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420eb2f:	00 00 00 
  800420eb32:	ff d0                	callq  *%rax
  800420eb34:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420eb3b:	00 00 00 
  800420eb3e:	48 98                	cltq   
  800420eb40:	48 c1 e0 03          	shl    $0x3,%rax
  800420eb44:	48 89 c1             	mov    %rax,%rcx
  800420eb47:	48 c1 e1 04          	shl    $0x4,%rcx
  800420eb4b:	48 01 c8             	add    %rcx,%rax
  800420eb4e:	48 01 d0             	add    %rdx,%rax
  800420eb51:	48 83 c0 08          	add    $0x8,%rax
  800420eb55:	48 8b 00             	mov    (%rax),%rax
  800420eb58:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420eb5e:	89 c6                	mov    %eax,%esi
  800420eb60:	48 bf 68 0b 22 04 80 	movabs $0x8004220b68,%rdi
  800420eb67:	00 00 00 
  800420eb6a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420eb6f:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420eb76:	00 00 00 
  800420eb79:	ff d2                	callq  *%rdx
			return -E_INVAL;
  800420eb7b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420eb80:	e9 59 03 00 00       	jmpq   800420eede <sys_ipc_try_send+0x6cd>
		}

		// Map the page in guest physical memory.
		// TODO: Fix permissions.
//#ifndef VMM_GUEST
		r = ept_page_insert(e->env_pml4e, pp, e->env_ipc_dstva, __EPTE_FULL);
  800420eb85:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420eb89:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420eb90:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420eb94:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420eb9b:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  800420eb9f:	b9 07 00 00 00       	mov    $0x7,%ecx
  800420eba4:	48 89 c7             	mov    %rax,%rdi
  800420eba7:	48 b8 ea 9e 21 04 80 	movabs $0x8004219eea,%rax
  800420ebae:	00 00 00 
  800420ebb1:	ff d0                	callq  *%rax
  800420ebb3:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420ebb6:	e9 92 02 00 00       	jmpq   800420ee4d <sys_ipc_try_send+0x63c>
//#endif
    
	} else if (srcva < (void*) UTOP && e->env_ipc_dstva < (void*) UTOP) {
  800420ebbb:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420ebc2:	00 00 00 
  800420ebc5:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  800420ebc9:	0f 87 70 02 00 00    	ja     800420ee3f <sys_ipc_try_send+0x62e>
  800420ebcf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ebd3:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420ebda:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420ebe1:	00 00 00 
  800420ebe4:	48 39 c2             	cmp    %rax,%rdx
  800420ebe7:	0f 87 52 02 00 00    	ja     800420ee3f <sys_ipc_try_send+0x62e>

			if ((~perm & (PTE_U|PTE_P)) || (perm & ~PTE_SYSCALL)) {
  800420ebed:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800420ebf0:	f7 d0                	not    %eax
  800420ebf2:	83 e0 05             	and    $0x5,%eax
  800420ebf5:	85 c0                	test   %eax,%eax
  800420ebf7:	75 0c                	jne    800420ec05 <sys_ipc_try_send+0x3f4>
  800420ebf9:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800420ebfc:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420ec01:	85 c0                	test   %eax,%eax
  800420ec03:	74 60                	je     800420ec65 <sys_ipc_try_send+0x454>
				cprintf("[%08x] bad perm %x in sys_ipc_try_send\n", curenv->env_id, perm);
  800420ec05:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420ec0c:	00 00 00 
  800420ec0f:	ff d0                	callq  *%rax
  800420ec11:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420ec18:	00 00 00 
  800420ec1b:	48 98                	cltq   
  800420ec1d:	48 c1 e0 03          	shl    $0x3,%rax
  800420ec21:	48 89 c1             	mov    %rax,%rcx
  800420ec24:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ec28:	48 01 c8             	add    %rcx,%rax
  800420ec2b:	48 01 d0             	add    %rdx,%rax
  800420ec2e:	48 83 c0 08          	add    $0x8,%rax
  800420ec32:	48 8b 00             	mov    (%rax),%rax
  800420ec35:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420ec3b:	8b 55 ac             	mov    -0x54(%rbp),%edx
  800420ec3e:	89 c6                	mov    %eax,%esi
  800420ec40:	48 bf b0 0b 22 04 80 	movabs $0x8004220bb0,%rdi
  800420ec47:	00 00 00 
  800420ec4a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ec4f:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800420ec56:	00 00 00 
  800420ec59:	ff d1                	callq  *%rcx
				return -E_INVAL;
  800420ec5b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ec60:	e9 79 02 00 00       	jmpq   800420eede <sys_ipc_try_send+0x6cd>
			}

			pp = page_lookup(curenv->env_pml4e, srcva, &ppte);
  800420ec65:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420ec6c:	00 00 00 
  800420ec6f:	ff d0                	callq  *%rax
  800420ec71:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420ec78:	00 00 00 
  800420ec7b:	48 98                	cltq   
  800420ec7d:	48 c1 e0 03          	shl    $0x3,%rax
  800420ec81:	48 89 c1             	mov    %rax,%rcx
  800420ec84:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ec88:	48 01 c8             	add    %rcx,%rax
  800420ec8b:	48 01 d0             	add    %rdx,%rax
  800420ec8e:	48 83 c0 08          	add    $0x8,%rax
  800420ec92:	48 8b 00             	mov    (%rax),%rax
  800420ec95:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420ec9c:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  800420eca0:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800420eca4:	48 89 ce             	mov    %rcx,%rsi
  800420eca7:	48 89 c7             	mov    %rax,%rdi
  800420ecaa:	48 b8 a7 3d 20 04 80 	movabs $0x8004203da7,%rax
  800420ecb1:	00 00 00 
  800420ecb4:	ff d0                	callq  *%rax
  800420ecb6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
			if (pp == 0) {
  800420ecba:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420ecbf:	75 61                	jne    800420ed22 <sys_ipc_try_send+0x511>
				cprintf("[%08x] page_lookup %08x failed in sys_ipc_try_send\n", curenv->env_id, srcva);
  800420ecc1:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420ecc8:	00 00 00 
  800420eccb:	ff d0                	callq  *%rax
  800420eccd:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420ecd4:	00 00 00 
  800420ecd7:	48 98                	cltq   
  800420ecd9:	48 c1 e0 03          	shl    $0x3,%rax
  800420ecdd:	48 89 c1             	mov    %rax,%rcx
  800420ece0:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ece4:	48 01 c8             	add    %rcx,%rax
  800420ece7:	48 01 d0             	add    %rdx,%rax
  800420ecea:	48 83 c0 08          	add    $0x8,%rax
  800420ecee:	48 8b 00             	mov    (%rax),%rax
  800420ecf1:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420ecf7:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420ecfb:	89 c6                	mov    %eax,%esi
  800420ecfd:	48 bf 30 0b 22 04 80 	movabs $0x8004220b30,%rdi
  800420ed04:	00 00 00 
  800420ed07:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ed0c:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800420ed13:	00 00 00 
  800420ed16:	ff d1                	callq  *%rcx
				return -E_INVAL;
  800420ed18:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ed1d:	e9 bc 01 00 00       	jmpq   800420eede <sys_ipc_try_send+0x6cd>
			}

			if ((perm & PTE_W) && !(*ppte & PTE_W)) {
  800420ed22:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800420ed25:	83 e0 02             	and    $0x2,%eax
  800420ed28:	85 c0                	test   %eax,%eax
  800420ed2a:	74 6c                	je     800420ed98 <sys_ipc_try_send+0x587>
  800420ed2c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ed30:	48 8b 00             	mov    (%rax),%rax
  800420ed33:	83 e0 02             	and    $0x2,%eax
  800420ed36:	48 85 c0             	test   %rax,%rax
  800420ed39:	75 5d                	jne    800420ed98 <sys_ipc_try_send+0x587>
				cprintf("[%08x] attempt to send read-only page read-write in sys_ipc_try_send\n", curenv->env_id);
  800420ed3b:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420ed42:	00 00 00 
  800420ed45:	ff d0                	callq  *%rax
  800420ed47:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420ed4e:	00 00 00 
  800420ed51:	48 98                	cltq   
  800420ed53:	48 c1 e0 03          	shl    $0x3,%rax
  800420ed57:	48 89 c1             	mov    %rax,%rcx
  800420ed5a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ed5e:	48 01 c8             	add    %rcx,%rax
  800420ed61:	48 01 d0             	add    %rdx,%rax
  800420ed64:	48 83 c0 08          	add    $0x8,%rax
  800420ed68:	48 8b 00             	mov    (%rax),%rax
  800420ed6b:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420ed71:	89 c6                	mov    %eax,%esi
  800420ed73:	48 bf 68 0b 22 04 80 	movabs $0x8004220b68,%rdi
  800420ed7a:	00 00 00 
  800420ed7d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ed82:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800420ed89:	00 00 00 
  800420ed8c:	ff d2                	callq  *%rdx
				return -E_INVAL;
  800420ed8e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ed93:	e9 46 01 00 00       	jmpq   800420eede <sys_ipc_try_send+0x6cd>
			}

			r = page_insert(e->env_pml4e, pp, e->env_ipc_dstva, perm);
  800420ed98:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  800420ed9b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ed9f:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420eda6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420edaa:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420edb1:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  800420edb5:	48 89 c7             	mov    %rax,%rdi
  800420edb8:	48 b8 33 3a 20 04 80 	movabs $0x8004203a33,%rax
  800420edbf:	00 00 00 
  800420edc2:	ff d0                	callq  *%rax
  800420edc4:	89 45 ec             	mov    %eax,-0x14(%rbp)
			if (r < 0) {
  800420edc7:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420edcb:	79 63                	jns    800420ee30 <sys_ipc_try_send+0x61f>
				cprintf("[%08x] page_insert %08x failed in sys_ipc_try_send (%e)\n", curenv->env_id, srcva, r);
  800420edcd:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420edd4:	00 00 00 
  800420edd7:	ff d0                	callq  *%rax
  800420edd9:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420ede0:	00 00 00 
  800420ede3:	48 98                	cltq   
  800420ede5:	48 c1 e0 03          	shl    $0x3,%rax
  800420ede9:	48 89 c1             	mov    %rax,%rcx
  800420edec:	48 c1 e1 04          	shl    $0x4,%rcx
  800420edf0:	48 01 c8             	add    %rcx,%rax
  800420edf3:	48 01 d0             	add    %rdx,%rax
  800420edf6:	48 83 c0 08          	add    $0x8,%rax
  800420edfa:	48 8b 00             	mov    (%rax),%rax
  800420edfd:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420ee03:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  800420ee06:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420ee0a:	89 c6                	mov    %eax,%esi
  800420ee0c:	48 bf f0 0a 22 04 80 	movabs $0x8004220af0,%rdi
  800420ee13:	00 00 00 
  800420ee16:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ee1b:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800420ee22:	00 00 00 
  800420ee25:	41 ff d0             	callq  *%r8
				return r;
  800420ee28:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ee2b:	e9 ae 00 00 00       	jmpq   800420eede <sys_ipc_try_send+0x6cd>
			}

			e->env_ipc_perm = perm;
  800420ee30:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ee34:	8b 55 ac             	mov    -0x54(%rbp),%edx
  800420ee37:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
  800420ee3d:	eb 0e                	jmp    800420ee4d <sys_ipc_try_send+0x63c>
		} else {
			e->env_ipc_perm = 0;
  800420ee3f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ee43:	c7 80 10 01 00 00 00 	movl   $0x0,0x110(%rax)
  800420ee4a:	00 00 00 
		}

		e->env_ipc_recving = 0;
  800420ee4d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ee51:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)
		e->env_ipc_from = curenv->env_id;
  800420ee58:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
  800420ee5c:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420ee63:	00 00 00 
  800420ee66:	ff d0                	callq  *%rax
  800420ee68:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420ee6f:	00 00 00 
  800420ee72:	48 98                	cltq   
  800420ee74:	48 c1 e0 03          	shl    $0x3,%rax
  800420ee78:	48 89 c1             	mov    %rax,%rcx
  800420ee7b:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ee7f:	48 01 c8             	add    %rcx,%rax
  800420ee82:	48 01 d0             	add    %rdx,%rax
  800420ee85:	48 83 c0 08          	add    $0x8,%rax
  800420ee89:	48 8b 00             	mov    (%rax),%rax
  800420ee8c:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420ee92:	89 83 0c 01 00 00    	mov    %eax,0x10c(%rbx)
		e->env_ipc_value = value;
  800420ee98:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ee9c:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420ee9f:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
		e->env_tf.tf_regs.reg_rax = 0;
  800420eea5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420eea9:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420eeb0:	00 
		e->env_status = ENV_RUNNABLE;
  800420eeb1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420eeb5:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420eebc:	00 00 00 

		if(e->env_type == ENV_TYPE_GUEST) {
  800420eebf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420eec3:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800420eec9:	83 f8 03             	cmp    $0x3,%eax
  800420eecc:	75 0b                	jne    800420eed9 <sys_ipc_try_send+0x6c8>
			e->env_tf.tf_regs.reg_rsi = value;
  800420eece:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420eed2:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420eed5:	48 89 50 40          	mov    %rdx,0x40(%rax)
		}

		return 0;
  800420eed9:	b8 00 00 00 00       	mov    $0x0,%eax

	}
  800420eede:	48 83 c4 58          	add    $0x58,%rsp
  800420eee2:	5b                   	pop    %rbx
  800420eee3:	5d                   	pop    %rbp
  800420eee4:	c3                   	retq   

000000800420eee5 <sys_ipc_recv>:
// return 0 on success.
// Return < 0 on error.  Errors are:
//	-E_INVAL if dstva < UTOP but dstva is not page-aligned.
static int
sys_ipc_recv(void *dstva)
{
  800420eee5:	55                   	push   %rbp
  800420eee6:	48 89 e5             	mov    %rsp,%rbp
  800420eee9:	48 83 ec 10          	sub    $0x10,%rsp
  800420eeed:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

	if (curenv->env_ipc_recving)
  800420eef1:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420eef8:	00 00 00 
  800420eefb:	ff d0                	callq  *%rax
  800420eefd:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420ef04:	00 00 00 
  800420ef07:	48 98                	cltq   
  800420ef09:	48 c1 e0 03          	shl    $0x3,%rax
  800420ef0d:	48 89 c1             	mov    %rax,%rcx
  800420ef10:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ef14:	48 01 c8             	add    %rcx,%rax
  800420ef17:	48 01 d0             	add    %rdx,%rax
  800420ef1a:	48 83 c0 08          	add    $0x8,%rax
  800420ef1e:	48 8b 00             	mov    (%rax),%rax
  800420ef21:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420ef28:	84 c0                	test   %al,%al
  800420ef2a:	74 2a                	je     800420ef56 <sys_ipc_recv+0x71>
		panic("already recving!");
  800420ef2c:	48 ba d8 0b 22 04 80 	movabs $0x8004220bd8,%rdx
  800420ef33:	00 00 00 
  800420ef36:	be bc 01 00 00       	mov    $0x1bc,%esi
  800420ef3b:	48 bf b6 0a 22 04 80 	movabs $0x8004220ab6,%rdi
  800420ef42:	00 00 00 
  800420ef45:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ef4a:	48 b9 d3 04 20 04 80 	movabs $0x80042004d3,%rcx
  800420ef51:	00 00 00 
  800420ef54:	ff d1                	callq  *%rcx
	
	curenv->env_ipc_recving = 1;
  800420ef56:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420ef5d:	00 00 00 
  800420ef60:	ff d0                	callq  *%rax
  800420ef62:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420ef69:	00 00 00 
  800420ef6c:	48 98                	cltq   
  800420ef6e:	48 c1 e0 03          	shl    $0x3,%rax
  800420ef72:	48 89 c1             	mov    %rax,%rcx
  800420ef75:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ef79:	48 01 c8             	add    %rcx,%rax
  800420ef7c:	48 01 d0             	add    %rdx,%rax
  800420ef7f:	48 83 c0 08          	add    $0x8,%rax
  800420ef83:	48 8b 00             	mov    (%rax),%rax
  800420ef86:	c6 80 f8 00 00 00 01 	movb   $0x1,0xf8(%rax)
	curenv->env_ipc_dstva = dstva;
  800420ef8d:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420ef94:	00 00 00 
  800420ef97:	ff d0                	callq  *%rax
  800420ef99:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420efa0:	00 00 00 
  800420efa3:	48 98                	cltq   
  800420efa5:	48 c1 e0 03          	shl    $0x3,%rax
  800420efa9:	48 89 c1             	mov    %rax,%rcx
  800420efac:	48 c1 e1 04          	shl    $0x4,%rcx
  800420efb0:	48 01 c8             	add    %rcx,%rax
  800420efb3:	48 01 d0             	add    %rdx,%rax
  800420efb6:	48 83 c0 08          	add    $0x8,%rax
  800420efba:	48 8b 00             	mov    (%rax),%rax
  800420efbd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420efc1:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)
	curenv->env_status = ENV_NOT_RUNNABLE;
  800420efc8:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420efcf:	00 00 00 
  800420efd2:	ff d0                	callq  *%rax
  800420efd4:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420efdb:	00 00 00 
  800420efde:	48 98                	cltq   
  800420efe0:	48 c1 e0 03          	shl    $0x3,%rax
  800420efe4:	48 89 c1             	mov    %rax,%rcx
  800420efe7:	48 c1 e1 04          	shl    $0x4,%rcx
  800420efeb:	48 01 c8             	add    %rcx,%rax
  800420efee:	48 01 d0             	add    %rdx,%rax
  800420eff1:	48 83 c0 08          	add    $0x8,%rax
  800420eff5:	48 8b 00             	mov    (%rax),%rax
  800420eff8:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420efff:	00 00 00 
	sched_yield();
  800420f002:	48 b8 a6 da 20 04 80 	movabs $0x800420daa6,%rax
  800420f009:	00 00 00 
  800420f00c:	ff d0                	callq  *%rax

000000800420f00e <sys_time_msec>:


// Return the current time.
static int
sys_time_msec(void)
{
  800420f00e:	55                   	push   %rbp
  800420f00f:	48 89 e5             	mov    %rsp,%rbp

	return (int) time_msec();
  800420f012:	48 b8 dd 99 21 04 80 	movabs $0x80042199dd,%rax
  800420f019:	00 00 00 
  800420f01c:	ff d0                	callq  *%rax

}
  800420f01e:	5d                   	pop    %rbp
  800420f01f:	c3                   	retq   

000000800420f020 <sys_net_transmit>:



static int
sys_net_transmit(const void *data, size_t len)
{
  800420f020:	55                   	push   %rbp
  800420f021:	48 89 e5             	mov    %rsp,%rbp
  800420f024:	48 83 ec 10          	sub    $0x10,%rsp
  800420f028:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f02c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	user_mem_assert(curenv, data, len, 0);
  800420f030:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420f037:	00 00 00 
  800420f03a:	ff d0                	callq  *%rax
  800420f03c:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420f043:	00 00 00 
  800420f046:	48 98                	cltq   
  800420f048:	48 c1 e0 03          	shl    $0x3,%rax
  800420f04c:	48 89 c1             	mov    %rax,%rcx
  800420f04f:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f053:	48 01 c8             	add    %rcx,%rax
  800420f056:	48 01 d0             	add    %rdx,%rax
  800420f059:	48 83 c0 08          	add    $0x8,%rax
  800420f05d:	48 8b 00             	mov    (%rax),%rax
  800420f060:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f064:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420f068:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420f06d:	48 89 c7             	mov    %rax,%rdi
  800420f070:	48 b8 7e 41 20 04 80 	movabs $0x800420417e,%rax
  800420f077:	00 00 00 
  800420f07a:	ff d0                	callq  *%rax
	return e1000_transmit(data, len);
  800420f07c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f080:	89 c2                	mov    %eax,%edx
  800420f082:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f086:	89 d6                	mov    %edx,%esi
  800420f088:	48 89 c7             	mov    %rax,%rdi
  800420f08b:	48 b8 43 8b 21 04 80 	movabs $0x8004218b43,%rax
  800420f092:	00 00 00 
  800420f095:	ff d0                	callq  *%rax
}
  800420f097:	c9                   	leaveq 
  800420f098:	c3                   	retq   

000000800420f099 <sys_net_receive>:

static int
sys_net_receive(void *buf, size_t len)
{
  800420f099:	55                   	push   %rbp
  800420f09a:	48 89 e5             	mov    %rsp,%rbp
  800420f09d:	48 83 ec 10          	sub    $0x10,%rsp
  800420f0a1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f0a5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	user_mem_assert(curenv, buf, len, PTE_W);
  800420f0a9:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420f0b0:	00 00 00 
  800420f0b3:	ff d0                	callq  *%rax
  800420f0b5:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420f0bc:	00 00 00 
  800420f0bf:	48 98                	cltq   
  800420f0c1:	48 c1 e0 03          	shl    $0x3,%rax
  800420f0c5:	48 89 c1             	mov    %rax,%rcx
  800420f0c8:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f0cc:	48 01 c8             	add    %rcx,%rax
  800420f0cf:	48 01 d0             	add    %rdx,%rax
  800420f0d2:	48 83 c0 08          	add    $0x8,%rax
  800420f0d6:	48 8b 00             	mov    (%rax),%rax
  800420f0d9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f0dd:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420f0e1:	b9 02 00 00 00       	mov    $0x2,%ecx
  800420f0e6:	48 89 c7             	mov    %rax,%rdi
  800420f0e9:	48 b8 7e 41 20 04 80 	movabs $0x800420417e,%rax
  800420f0f0:	00 00 00 
  800420f0f3:	ff d0                	callq  *%rax
	return e1000_receive(buf, len);
  800420f0f5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f0f9:	89 c2                	mov    %eax,%edx
  800420f0fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f0ff:	89 d6                	mov    %edx,%esi
  800420f101:	48 89 c7             	mov    %rax,%rdi
  800420f104:	48 b8 c3 8c 21 04 80 	movabs $0x8004218cc3,%rax
  800420f10b:	00 00 00 
  800420f10e:	ff d0                	callq  *%rax
}
  800420f110:	c9                   	leaveq 
  800420f111:	c3                   	retq   

000000800420f112 <sys_vmx_list_vms>:



//#ifndef VMM_GUEST
static void
sys_vmx_list_vms() {
  800420f112:	55                   	push   %rbp
  800420f113:	48 89 e5             	mov    %rsp,%rbp
	vmx_list_vms();
  800420f116:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f11b:	48 ba ab a3 21 04 80 	movabs $0x800421a3ab,%rdx
  800420f122:	00 00 00 
  800420f125:	ff d2                	callq  *%rdx
}
  800420f127:	90                   	nop
  800420f128:	5d                   	pop    %rbp
  800420f129:	c3                   	retq   

000000800420f12a <sys_vmx_sel_resume>:

static bool
sys_vmx_sel_resume(int i) {
  800420f12a:	55                   	push   %rbp
  800420f12b:	48 89 e5             	mov    %rsp,%rbp
  800420f12e:	48 83 ec 10          	sub    $0x10,%rsp
  800420f132:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return vmx_sel_resume(i);
  800420f135:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f138:	89 c7                	mov    %eax,%edi
  800420f13a:	48 b8 6c a4 21 04 80 	movabs $0x800421a46c,%rax
  800420f141:	00 00 00 
  800420f144:	ff d0                	callq  *%rax
}
  800420f146:	c9                   	leaveq 
  800420f147:	c3                   	retq   

000000800420f148 <sys_vmx_get_vmdisk_number>:

static int
sys_vmx_get_vmdisk_number() {
  800420f148:	55                   	push   %rbp
  800420f149:	48 89 e5             	mov    %rsp,%rbp
	return vmx_get_vmdisk_number();
  800420f14c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f151:	48 ba de e2 21 04 80 	movabs $0x800421e2de,%rdx
  800420f158:	00 00 00 
  800420f15b:	ff d2                	callq  *%rdx
}
  800420f15d:	5d                   	pop    %rbp
  800420f15e:	c3                   	retq   

000000800420f15f <sys_vmx_incr_vmdisk_number>:

static void
sys_vmx_incr_vmdisk_number() {
  800420f15f:	55                   	push   %rbp
  800420f160:	48 89 e5             	mov    %rsp,%rbp
	vmx_incr_vmdisk_number();
  800420f163:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f168:	48 ba f0 e2 21 04 80 	movabs $0x800421e2f0,%rdx
  800420f16f:	00 00 00 
  800420f172:	ff d2                	callq  *%rdx
}
  800420f174:	90                   	nop
  800420f175:	5d                   	pop    %rbp
  800420f176:	c3                   	retq   

000000800420f177 <sys_ept_map>:
//       env_pml4e to store the root of the extended page tables.
// 
static int
sys_ept_map(envid_t srcenvid, void *srcva,
	    envid_t guest, void* guest_pa, int perm)
{
  800420f177:	55                   	push   %rbp
  800420f178:	48 89 e5             	mov    %rsp,%rbp
  800420f17b:	48 83 ec 50          	sub    $0x50,%rsp
  800420f17f:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420f182:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420f186:	89 55 c8             	mov    %edx,-0x38(%rbp)
  800420f189:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  800420f18d:	44 89 45 b4          	mov    %r8d,-0x4c(%rbp)
	struct Env *src_env_store = NULL;
  800420f191:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  800420f198:	00 
	struct Env *guest_env_store = NULL;
  800420f199:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  800420f1a0:	00 
	pte_t **pte_store = NULL;
  800420f1a1:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f1a8:	00 
	struct PageInfo *pp = NULL;
  800420f1a9:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420f1b0:	00 
	
	if (envid2env(srcenvid, &src_env_store, 1) < 0 || 
  800420f1b1:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800420f1b5:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420f1b8:	ba 01 00 00 00       	mov    $0x1,%edx
  800420f1bd:	48 89 ce             	mov    %rcx,%rsi
  800420f1c0:	89 c7                	mov    %eax,%edi
  800420f1c2:	48 b8 34 7e 20 04 80 	movabs $0x8004207e34,%rax
  800420f1c9:	00 00 00 
  800420f1cc:	ff d0                	callq  *%rax
  800420f1ce:	85 c0                	test   %eax,%eax
  800420f1d0:	78 21                	js     800420f1f3 <sys_ept_map+0x7c>
			envid2env(guest, &guest_env_store, 1) < 0)
  800420f1d2:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800420f1d6:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420f1d9:	ba 01 00 00 00       	mov    $0x1,%edx
  800420f1de:	48 89 ce             	mov    %rcx,%rsi
  800420f1e1:	89 c7                	mov    %eax,%edi
  800420f1e3:	48 b8 34 7e 20 04 80 	movabs $0x8004207e34,%rax
  800420f1ea:	00 00 00 
  800420f1ed:	ff d0                	callq  *%rax
	struct Env *src_env_store = NULL;
	struct Env *guest_env_store = NULL;
	pte_t **pte_store = NULL;
	struct PageInfo *pp = NULL;
	
	if (envid2env(srcenvid, &src_env_store, 1) < 0 || 
  800420f1ef:	85 c0                	test   %eax,%eax
  800420f1f1:	79 0a                	jns    800420f1fd <sys_ept_map+0x86>
			envid2env(guest, &guest_env_store, 1) < 0)
		return -E_BAD_ENV;
  800420f1f3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420f1f8:	e9 3d 01 00 00       	jmpq   800420f33a <sys_ept_map+0x1c3>

	if (srcva >= (void *)UTOP || (uint64_t)srcva % PGSIZE != 0)
  800420f1fd:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420f204:	00 00 00 
  800420f207:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  800420f20b:	77 0e                	ja     800420f21b <sys_ept_map+0xa4>
  800420f20d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f211:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420f216:	48 85 c0             	test   %rax,%rax
  800420f219:	74 0a                	je     800420f225 <sys_ept_map+0xae>
		return -E_INVAL;
  800420f21b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420f220:	e9 15 01 00 00       	jmpq   800420f33a <sys_ept_map+0x1c3>

	if (guest_env_store->env_vmxinfo.vmcs == 0)
  800420f225:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f229:	48 8b 80 28 01 00 00 	mov    0x128(%rax),%rax
  800420f230:	48 85 c0             	test   %rax,%rax
  800420f233:	75 0a                	jne    800420f23f <sys_ept_map+0xc8>
		return -E_BAD_ENV;
  800420f235:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420f23a:	e9 fb 00 00 00       	jmpq   800420f33a <sys_ept_map+0x1c3>

	if (guest_pa >= (void *)(guest_env_store->env_vmxinfo).phys_sz|| ROUNDUP(guest_pa, PGSIZE) != guest_pa)
  800420f23f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f243:	48 8b 80 20 01 00 00 	mov    0x120(%rax),%rax
  800420f24a:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  800420f24e:	76 35                	jbe    800420f285 <sys_ept_map+0x10e>
  800420f250:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  800420f257:	00 
  800420f258:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420f25c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f260:	48 01 d0             	add    %rdx,%rax
  800420f263:	48 83 e8 01          	sub    $0x1,%rax
  800420f267:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420f26b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f26f:	ba 00 00 00 00       	mov    $0x0,%edx
  800420f274:	48 f7 75 e8          	divq   -0x18(%rbp)
  800420f278:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f27c:	48 29 d0             	sub    %rdx,%rax
  800420f27f:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  800420f283:	74 0a                	je     800420f28f <sys_ept_map+0x118>
		return -E_INVAL;
  800420f285:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420f28a:	e9 ab 00 00 00       	jmpq   800420f33a <sys_ept_map+0x1c3>
	
	if ((perm & __EPTE_READ) == 0)
  800420f28f:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420f292:	83 e0 01             	and    $0x1,%eax
  800420f295:	85 c0                	test   %eax,%eax
  800420f297:	75 0a                	jne    800420f2a3 <sys_ept_map+0x12c>
		return -E_INVAL; 
  800420f299:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420f29e:	e9 97 00 00 00       	jmpq   800420f33a <sys_ept_map+0x1c3>

	if ((pp = page_lookup(src_env_store->env_pml4e, srcva, pte_store)) == NULL)
  800420f2a3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f2a7:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420f2ae:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420f2b2:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420f2b6:	48 89 ce             	mov    %rcx,%rsi
  800420f2b9:	48 89 c7             	mov    %rax,%rdi
  800420f2bc:	48 b8 a7 3d 20 04 80 	movabs $0x8004203da7,%rax
  800420f2c3:	00 00 00 
  800420f2c6:	ff d0                	callq  *%rax
  800420f2c8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420f2cc:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420f2d1:	75 07                	jne    800420f2da <sys_ept_map+0x163>
		return -E_INVAL;
  800420f2d3:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420f2d8:	eb 60                	jmp    800420f33a <sys_ept_map+0x1c3>

	/*if ((perm & PTE_W) && (((uint64_t)srcva & PTE_W == 0) && (uint64_t)srcva & PTE_R))
		return -E_INVAL;
*/
	if (ept_map_hva2gpa(guest_env_store->env_pml4e,(void *)page2kva(pp), guest_pa, perm, 0) < 0)
  800420f2da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f2de:	48 89 c7             	mov    %rax,%rdi
  800420f2e1:	48 b8 ee e0 20 04 80 	movabs $0x800420e0ee,%rax
  800420f2e8:	00 00 00 
  800420f2eb:	ff d0                	callq  *%rax
  800420f2ed:	48 89 c6             	mov    %rax,%rsi
  800420f2f0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f2f4:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420f2fb:	8b 4d b4             	mov    -0x4c(%rbp),%ecx
  800420f2fe:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420f302:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420f308:	48 89 c7             	mov    %rax,%rdi
  800420f30b:	48 b8 cc 9f 21 04 80 	movabs $0x8004219fcc,%rax
  800420f312:	00 00 00 
  800420f315:	ff d0                	callq  *%rax
  800420f317:	85 c0                	test   %eax,%eax
  800420f319:	79 07                	jns    800420f322 <sys_ept_map+0x1ab>
		return -E_NO_MEM; 
  800420f31b:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420f320:	eb 18                	jmp    800420f33a <sys_ept_map+0x1c3>
	
	pp->pp_ref += 1;
  800420f322:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f326:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420f32a:	8d 50 01             	lea    0x1(%rax),%edx
  800420f32d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f331:	66 89 50 08          	mov    %dx,0x8(%rax)
	 
	return 0;
  800420f335:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420f33a:	c9                   	leaveq 
  800420f33b:	c3                   	retq   

000000800420f33c <sys_env_mkguest>:

static envid_t
sys_env_mkguest(uint64_t gphysz, uint64_t gRIP) {
  800420f33c:	55                   	push   %rbp
  800420f33d:	48 89 e5             	mov    %rsp,%rbp
  800420f340:	48 83 ec 20          	sub    $0x20,%rsp
  800420f344:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f348:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int r;
	struct Env *e;

	// Check if the processor has VMX support.
	if ( !vmx_check_support() ) {
  800420f34c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f351:	48 ba 42 a5 21 04 80 	movabs $0x800421a542,%rdx
  800420f358:	00 00 00 
  800420f35b:	ff d2                	callq  *%rdx
  800420f35d:	83 f0 01             	xor    $0x1,%eax
  800420f360:	84 c0                	test   %al,%al
  800420f362:	74 0a                	je     800420f36e <sys_env_mkguest+0x32>
		return -E_NO_VMX;
  800420f364:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
  800420f369:	e9 b1 00 00 00       	jmpq   800420f41f <sys_env_mkguest+0xe3>
	} else if ( !vmx_check_ept() ) {
  800420f36e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f373:	48 ba 78 a5 21 04 80 	movabs $0x800421a578,%rdx
  800420f37a:	00 00 00 
  800420f37d:	ff d2                	callq  *%rdx
  800420f37f:	83 f0 01             	xor    $0x1,%eax
  800420f382:	84 c0                	test   %al,%al
  800420f384:	74 0a                	je     800420f390 <sys_env_mkguest+0x54>
		return -E_NO_EPT;
  800420f386:	b8 ee ff ff ff       	mov    $0xffffffee,%eax
  800420f38b:	e9 8f 00 00 00       	jmpq   800420f41f <sys_env_mkguest+0xe3>
	} 
	if ((r = env_guest_alloc(&e, curenv->env_id)) < 0)
  800420f390:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420f397:	00 00 00 
  800420f39a:	ff d0                	callq  *%rax
  800420f39c:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420f3a3:	00 00 00 
  800420f3a6:	48 98                	cltq   
  800420f3a8:	48 c1 e0 03          	shl    $0x3,%rax
  800420f3ac:	48 89 c1             	mov    %rax,%rcx
  800420f3af:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f3b3:	48 01 c8             	add    %rcx,%rax
  800420f3b6:	48 01 d0             	add    %rdx,%rax
  800420f3b9:	48 83 c0 08          	add    $0x8,%rax
  800420f3bd:	48 8b 00             	mov    (%rax),%rax
  800420f3c0:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420f3c6:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  800420f3ca:	89 d6                	mov    %edx,%esi
  800420f3cc:	48 89 c7             	mov    %rax,%rdi
  800420f3cf:	48 b8 cb 81 20 04 80 	movabs $0x80042081cb,%rax
  800420f3d6:	00 00 00 
  800420f3d9:	ff d0                	callq  *%rax
  800420f3db:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420f3de:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420f3e2:	79 05                	jns    800420f3e9 <sys_env_mkguest+0xad>
		return r;
  800420f3e4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f3e7:	eb 36                	jmp    800420f41f <sys_env_mkguest+0xe3>
	e->env_status = ENV_NOT_RUNNABLE;
  800420f3e9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f3ed:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420f3f4:	00 00 00 
	e->env_vmxinfo.phys_sz = gphysz;
  800420f3f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f3fb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f3ff:	48 89 90 20 01 00 00 	mov    %rdx,0x120(%rax)
	e->env_tf.tf_rip = gRIP;
  800420f406:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f40a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f40e:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	return e->env_id;
  800420f415:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f419:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420f41f:	c9                   	leaveq 
  800420f420:	c3                   	retq   

000000800420f421 <syscall>:


// Dispatches to the correct kernel function, passing the arguments.
int64_t
syscall(uint64_t syscallno, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420f421:	55                   	push   %rbp
  800420f422:	48 89 e5             	mov    %rsp,%rbp
  800420f425:	48 83 ec 30          	sub    $0x30,%rsp
  800420f429:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f42d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420f431:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f435:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420f439:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  800420f43d:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)

	switch (syscallno) {
  800420f441:	48 83 7d f8 16       	cmpq   $0x16,-0x8(%rbp)
  800420f446:	0f 87 d9 02 00 00    	ja     800420f725 <syscall+0x304>
  800420f44c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f450:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420f457:	00 
  800420f458:	48 b8 f0 0b 22 04 80 	movabs $0x8004220bf0,%rax
  800420f45f:	00 00 00 
  800420f462:	48 01 d0             	add    %rdx,%rax
  800420f465:	48 8b 00             	mov    (%rax),%rax
  800420f468:	ff e0                	jmpq   *%rax

	case SYS_cputs:
		sys_cputs((const char*) a1, a2);
  800420f46a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f46e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f472:	48 89 d6             	mov    %rdx,%rsi
  800420f475:	48 89 c7             	mov    %rax,%rdi
  800420f478:	48 b8 76 e1 20 04 80 	movabs $0x800420e176,%rax
  800420f47f:	00 00 00 
  800420f482:	ff d0                	callq  *%rax
		return 0;
  800420f484:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f489:	e9 9e 02 00 00       	jmpq   800420f72c <syscall+0x30b>
	case SYS_cgetc:
		return sys_cgetc();
  800420f48e:	48 b8 fb e1 20 04 80 	movabs $0x800420e1fb,%rax
  800420f495:	00 00 00 
  800420f498:	ff d0                	callq  *%rax
  800420f49a:	48 98                	cltq   
  800420f49c:	e9 8b 02 00 00       	jmpq   800420f72c <syscall+0x30b>
	case SYS_getenvid:
		return sys_getenvid();
  800420f4a1:	48 b8 0d e2 20 04 80 	movabs $0x800420e20d,%rax
  800420f4a8:	00 00 00 
  800420f4ab:	ff d0                	callq  *%rax
  800420f4ad:	48 98                	cltq   
  800420f4af:	e9 78 02 00 00       	jmpq   800420f72c <syscall+0x30b>
	case SYS_env_destroy:
		return sys_env_destroy(a1);
  800420f4b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f4b8:	89 c7                	mov    %eax,%edi
  800420f4ba:	48 b8 49 e2 20 04 80 	movabs $0x800420e249,%rax
  800420f4c1:	00 00 00 
  800420f4c4:	ff d0                	callq  *%rax
  800420f4c6:	48 98                	cltq   
  800420f4c8:	e9 5f 02 00 00       	jmpq   800420f72c <syscall+0x30b>

	case SYS_page_alloc:
		return sys_page_alloc(a1, (void*) a2, a3);
  800420f4cd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f4d1:	89 c6                	mov    %eax,%esi
  800420f4d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f4d7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f4db:	89 d1                	mov    %edx,%ecx
  800420f4dd:	89 f2                	mov    %esi,%edx
  800420f4df:	48 89 c6             	mov    %rax,%rsi
  800420f4e2:	89 cf                	mov    %ecx,%edi
  800420f4e4:	48 b8 1c e5 20 04 80 	movabs $0x800420e51c,%rax
  800420f4eb:	00 00 00 
  800420f4ee:	ff d0                	callq  *%rax
  800420f4f0:	48 98                	cltq   
  800420f4f2:	e9 35 02 00 00       	jmpq   800420f72c <syscall+0x30b>
	case SYS_page_map:
		return sys_page_map(a1, (void*) a2, a3, (void*) a4, a5);
  800420f4f7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f4fb:	41 89 c0             	mov    %eax,%r8d
  800420f4fe:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420f502:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f506:	89 c6                	mov    %eax,%esi
  800420f508:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f50c:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420f510:	89 cf                	mov    %ecx,%edi
  800420f512:	48 89 d1             	mov    %rdx,%rcx
  800420f515:	89 f2                	mov    %esi,%edx
  800420f517:	48 89 c6             	mov    %rax,%rsi
  800420f51a:	48 b8 05 e6 20 04 80 	movabs $0x800420e605,%rax
  800420f521:	00 00 00 
  800420f524:	ff d0                	callq  *%rax
  800420f526:	48 98                	cltq   
  800420f528:	e9 ff 01 00 00       	jmpq   800420f72c <syscall+0x30b>
	case SYS_page_unmap:
		return sys_page_unmap(a1, (void*) a2);
  800420f52d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f531:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f535:	48 89 c6             	mov    %rax,%rsi
  800420f538:	89 d7                	mov    %edx,%edi
  800420f53a:	48 b8 8a e7 20 04 80 	movabs $0x800420e78a,%rax
  800420f541:	00 00 00 
  800420f544:	ff d0                	callq  *%rax
  800420f546:	48 98                	cltq   
  800420f548:	e9 df 01 00 00       	jmpq   800420f72c <syscall+0x30b>
	case SYS_exofork:
		return sys_exofork();
  800420f54d:	48 b8 a9 e2 20 04 80 	movabs $0x800420e2a9,%rax
  800420f554:	00 00 00 
  800420f557:	ff d0                	callq  *%rax
  800420f559:	48 98                	cltq   
  800420f55b:	e9 cc 01 00 00       	jmpq   800420f72c <syscall+0x30b>
	case SYS_env_set_status:
		return sys_env_set_status(a1, a2);
  800420f560:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f564:	89 c2                	mov    %eax,%edx
  800420f566:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f56a:	89 d6                	mov    %edx,%esi
  800420f56c:	89 c7                	mov    %eax,%edi
  800420f56e:	48 b8 7e e3 20 04 80 	movabs $0x800420e37e,%rax
  800420f575:	00 00 00 
  800420f578:	ff d0                	callq  *%rax
  800420f57a:	48 98                	cltq   
  800420f57c:	e9 ab 01 00 00       	jmpq   800420f72c <syscall+0x30b>

	case SYS_env_set_trapframe:
		return sys_env_set_trapframe(a1, (struct Trapframe*) a2);
  800420f581:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f585:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f589:	48 89 c6             	mov    %rax,%rsi
  800420f58c:	89 d7                	mov    %edx,%edi
  800420f58e:	48 b8 de e3 20 04 80 	movabs $0x800420e3de,%rax
  800420f595:	00 00 00 
  800420f598:	ff d0                	callq  *%rax
  800420f59a:	48 98                	cltq   
  800420f59c:	e9 8b 01 00 00       	jmpq   800420f72c <syscall+0x30b>

	case SYS_env_set_pgfault_upcall:
		return sys_env_set_pgfault_upcall(a1, (void*) a2);
  800420f5a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f5a5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f5a9:	48 89 c6             	mov    %rax,%rsi
  800420f5ac:	89 d7                	mov    %edx,%edi
  800420f5ae:	48 b8 cc e4 20 04 80 	movabs $0x800420e4cc,%rax
  800420f5b5:	00 00 00 
  800420f5b8:	ff d0                	callq  *%rax
  800420f5ba:	48 98                	cltq   
  800420f5bc:	e9 6b 01 00 00       	jmpq   800420f72c <syscall+0x30b>
	case SYS_yield:
		sys_yield();
  800420f5c1:	48 b8 99 e2 20 04 80 	movabs $0x800420e299,%rax
  800420f5c8:	00 00 00 
  800420f5cb:	ff d0                	callq  *%rax
		return 0;
  800420f5cd:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f5d2:	e9 55 01 00 00       	jmpq   800420f72c <syscall+0x30b>
	case SYS_ipc_try_send:
		return sys_ipc_try_send(a1, a2, (void*) a3, a4);
  800420f5d7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f5db:	89 c1                	mov    %eax,%ecx
  800420f5dd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f5e1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f5e5:	89 d6                	mov    %edx,%esi
  800420f5e7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f5eb:	89 d7                	mov    %edx,%edi
  800420f5ed:	48 89 c2             	mov    %rax,%rdx
  800420f5f0:	48 b8 11 e8 20 04 80 	movabs $0x800420e811,%rax
  800420f5f7:	00 00 00 
  800420f5fa:	ff d0                	callq  *%rax
  800420f5fc:	48 98                	cltq   
  800420f5fe:	e9 29 01 00 00       	jmpq   800420f72c <syscall+0x30b>
	case SYS_ipc_recv:
		sys_ipc_recv((void*) a1);
  800420f603:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f607:	48 89 c7             	mov    %rax,%rdi
  800420f60a:	48 b8 e5 ee 20 04 80 	movabs $0x800420eee5,%rax
  800420f611:	00 00 00 
  800420f614:	ff d0                	callq  *%rax
		return 0;
  800420f616:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f61b:	e9 0c 01 00 00       	jmpq   800420f72c <syscall+0x30b>

	case SYS_time_msec:
		return sys_time_msec();
  800420f620:	48 b8 0e f0 20 04 80 	movabs $0x800420f00e,%rax
  800420f627:	00 00 00 
  800420f62a:	ff d0                	callq  *%rax
  800420f62c:	48 98                	cltq   
  800420f62e:	e9 f9 00 00 00       	jmpq   800420f72c <syscall+0x30b>
	case SYS_net_transmit:
		return sys_net_transmit((const void*)a1, a2);
  800420f633:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f637:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f63b:	48 89 d6             	mov    %rdx,%rsi
  800420f63e:	48 89 c7             	mov    %rax,%rdi
  800420f641:	48 b8 20 f0 20 04 80 	movabs $0x800420f020,%rax
  800420f648:	00 00 00 
  800420f64b:	ff d0                	callq  *%rax
  800420f64d:	48 98                	cltq   
  800420f64f:	e9 d8 00 00 00       	jmpq   800420f72c <syscall+0x30b>
	case SYS_net_receive:
		return sys_net_receive((void*)a1, a2);
  800420f654:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f658:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f65c:	48 89 d6             	mov    %rdx,%rsi
  800420f65f:	48 89 c7             	mov    %rax,%rdi
  800420f662:	48 b8 99 f0 20 04 80 	movabs $0x800420f099,%rax
  800420f669:	00 00 00 
  800420f66c:	ff d0                	callq  *%rax
  800420f66e:	48 98                	cltq   
  800420f670:	e9 b7 00 00 00       	jmpq   800420f72c <syscall+0x30b>

//#ifndef VMM_GUEST
	case SYS_ept_map:
		return sys_ept_map(a1, (void*) a2, a3, (void*) a4, a5);
  800420f675:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f679:	41 89 c0             	mov    %eax,%r8d
  800420f67c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420f680:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f684:	89 c6                	mov    %eax,%esi
  800420f686:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f68a:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420f68e:	89 cf                	mov    %ecx,%edi
  800420f690:	48 89 d1             	mov    %rdx,%rcx
  800420f693:	89 f2                	mov    %esi,%edx
  800420f695:	48 89 c6             	mov    %rax,%rsi
  800420f698:	48 b8 77 f1 20 04 80 	movabs $0x800420f177,%rax
  800420f69f:	00 00 00 
  800420f6a2:	ff d0                	callq  *%rax
  800420f6a4:	48 98                	cltq   
  800420f6a6:	e9 81 00 00 00       	jmpq   800420f72c <syscall+0x30b>
	case SYS_env_mkguest:
		return sys_env_mkguest(a1, a2);
  800420f6ab:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f6af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f6b3:	48 89 d6             	mov    %rdx,%rsi
  800420f6b6:	48 89 c7             	mov    %rax,%rdi
  800420f6b9:	48 b8 3c f3 20 04 80 	movabs $0x800420f33c,%rax
  800420f6c0:	00 00 00 
  800420f6c3:	ff d0                	callq  *%rax
  800420f6c5:	48 98                	cltq   
  800420f6c7:	eb 63                	jmp    800420f72c <syscall+0x30b>
	case SYS_vmx_list_vms:
		sys_vmx_list_vms();
  800420f6c9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f6ce:	48 ba 12 f1 20 04 80 	movabs $0x800420f112,%rdx
  800420f6d5:	00 00 00 
  800420f6d8:	ff d2                	callq  *%rdx
		return 0;
  800420f6da:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f6df:	eb 4b                	jmp    800420f72c <syscall+0x30b>
	case SYS_vmx_sel_resume:
		return sys_vmx_sel_resume(a1);
  800420f6e1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f6e5:	89 c7                	mov    %eax,%edi
  800420f6e7:	48 b8 2a f1 20 04 80 	movabs $0x800420f12a,%rax
  800420f6ee:	00 00 00 
  800420f6f1:	ff d0                	callq  *%rax
  800420f6f3:	0f b6 c0             	movzbl %al,%eax
  800420f6f6:	eb 34                	jmp    800420f72c <syscall+0x30b>
	case SYS_vmx_get_vmdisk_number:
		return sys_vmx_get_vmdisk_number();
  800420f6f8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f6fd:	48 ba 48 f1 20 04 80 	movabs $0x800420f148,%rdx
  800420f704:	00 00 00 
  800420f707:	ff d2                	callq  *%rdx
  800420f709:	48 98                	cltq   
  800420f70b:	eb 1f                	jmp    800420f72c <syscall+0x30b>
	case SYS_vmx_incr_vmdisk_number:
		sys_vmx_incr_vmdisk_number();
  800420f70d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f712:	48 ba 5f f1 20 04 80 	movabs $0x800420f15f,%rdx
  800420f719:	00 00 00 
  800420f71c:	ff d2                	callq  *%rdx
		return 0;
  800420f71e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f723:	eb 07                	jmp    800420f72c <syscall+0x30b>
//#endif

		
	default:
		return -E_NO_SYS;
  800420f725:	48 c7 c0 f9 ff ff ff 	mov    $0xfffffffffffffff9,%rax
	}
}
  800420f72c:	c9                   	leaveq 
  800420f72d:	c3                   	retq   

000000800420f72e <list_func_die>:
	const char *stabstr_end;
};


int list_func_die(struct Ripdebuginfo *info, Dwarf_Die *die, uint64_t addr)
{
  800420f72e:	55                   	push   %rbp
  800420f72f:	48 89 e5             	mov    %rsp,%rbp
  800420f732:	48 81 ec c0 61 00 00 	sub    $0x61c0,%rsp
  800420f739:	48 89 bd 58 9e ff ff 	mov    %rdi,-0x61a8(%rbp)
  800420f740:	48 89 b5 50 9e ff ff 	mov    %rsi,-0x61b0(%rbp)
  800420f747:	48 89 95 48 9e ff ff 	mov    %rdx,-0x61b8(%rbp)
	_Dwarf_Line ln;
	Dwarf_Attribute *low;
	Dwarf_Attribute *high;
	Dwarf_CU *cu = die->cu_header;
  800420f74e:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f755:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800420f75c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Dwarf_Die *cudie = die->cu_die; 
  800420f760:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f767:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420f76e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	Dwarf_Die ret, sib=*die; 
  800420f772:	48 8b 95 50 9e ff ff 	mov    -0x61b0(%rbp),%rdx
  800420f779:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420f780:	48 89 d1             	mov    %rdx,%rcx
  800420f783:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420f788:	48 89 ce             	mov    %rcx,%rsi
  800420f78b:	48 89 c7             	mov    %rax,%rdi
  800420f78e:	48 b8 5b 13 21 04 80 	movabs $0x800421135b,%rax
  800420f795:	00 00 00 
  800420f798:	ff d0                	callq  *%rax
	Dwarf_Attribute *attr;
	uint64_t offset;
	uint64_t ret_val=8;
  800420f79a:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  800420f7a1:	00 
	uint64_t ret_offset=0;
  800420f7a2:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420f7a9:	00 

	if(die->die_tag != DW_TAG_subprogram)
  800420f7aa:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f7b1:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f7b5:	48 83 f8 2e          	cmp    $0x2e,%rax
  800420f7b9:	74 0a                	je     800420f7c5 <list_func_die+0x97>
		return 0;
  800420f7bb:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f7c0:	e9 8d 06 00 00       	jmpq   800420fe52 <list_func_die+0x724>

	memset(&ln, 0, sizeof(_Dwarf_Line));
  800420f7c5:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420f7cc:	ba 38 00 00 00       	mov    $0x38,%edx
  800420f7d1:	be 00 00 00 00       	mov    $0x0,%esi
  800420f7d6:	48 89 c7             	mov    %rax,%rdi
  800420f7d9:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  800420f7e0:	00 00 00 
  800420f7e3:	ff d0                	callq  *%rax

	low  = _dwarf_attr_find(die, DW_AT_low_pc);
  800420f7e5:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f7ec:	be 11 00 00 00       	mov    $0x11,%esi
  800420f7f1:	48 89 c7             	mov    %rax,%rdi
  800420f7f4:	48 b8 97 30 21 04 80 	movabs $0x8004213097,%rax
  800420f7fb:	00 00 00 
  800420f7fe:	ff d0                	callq  *%rax
  800420f800:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	high = _dwarf_attr_find(die, DW_AT_high_pc);
  800420f804:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f80b:	be 12 00 00 00       	mov    $0x12,%esi
  800420f810:	48 89 c7             	mov    %rax,%rdi
  800420f813:	48 b8 97 30 21 04 80 	movabs $0x8004213097,%rax
  800420f81a:	00 00 00 
  800420f81d:	ff d0                	callq  *%rax
  800420f81f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if((low && (low->u[0].u64 < addr)) && (high && (high->u[0].u64 > addr)))
  800420f823:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420f828:	0f 84 1f 06 00 00    	je     800420fe4d <list_func_die+0x71f>
  800420f82e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f832:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420f836:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420f83d:	0f 83 0a 06 00 00    	jae    800420fe4d <list_func_die+0x71f>
  800420f843:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420f848:	0f 84 ff 05 00 00    	je     800420fe4d <list_func_die+0x71f>
  800420f84e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f852:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420f856:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420f85d:	0f 86 ea 05 00 00    	jbe    800420fe4d <list_func_die+0x71f>
	{
		info->rip_file = die->cu_die->die_name;
  800420f863:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f86a:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420f871:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420f878:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f87f:	48 89 10             	mov    %rdx,(%rax)

		info->rip_fn_name = die->die_name;
  800420f882:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f889:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420f890:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f897:	48 89 50 10          	mov    %rdx,0x10(%rax)
		info->rip_fn_namelen = strlen(die->die_name);
  800420f89b:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f8a2:	48 8b 80 50 03 00 00 	mov    0x350(%rax),%rax
  800420f8a9:	48 89 c7             	mov    %rax,%rdi
  800420f8ac:	48 b8 b3 0e 21 04 80 	movabs $0x8004210eb3,%rax
  800420f8b3:	00 00 00 
  800420f8b6:	ff d0                	callq  *%rax
  800420f8b8:	89 c2                	mov    %eax,%edx
  800420f8ba:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f8c1:	89 50 18             	mov    %edx,0x18(%rax)

		info->rip_fn_addr = (uintptr_t)low->u[0].u64;
  800420f8c4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f8c8:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420f8cc:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f8d3:	48 89 50 20          	mov    %rdx,0x20(%rax)

		assert(die->cu_die);	
  800420f8d7:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f8de:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420f8e5:	48 85 c0             	test   %rax,%rax
  800420f8e8:	75 35                	jne    800420f91f <list_func_die+0x1f1>
  800420f8ea:	48 b9 e0 0f 22 04 80 	movabs $0x8004220fe0,%rcx
  800420f8f1:	00 00 00 
  800420f8f4:	48 ba ec 0f 22 04 80 	movabs $0x8004220fec,%rdx
  800420f8fb:	00 00 00 
  800420f8fe:	be 95 00 00 00       	mov    $0x95,%esi
  800420f903:	48 bf 01 10 22 04 80 	movabs $0x8004221001,%rdi
  800420f90a:	00 00 00 
  800420f90d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f912:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800420f919:	00 00 00 
  800420f91c:	41 ff d0             	callq  *%r8
		dwarf_srclines(die->cu_die, &ln, addr, NULL); 
  800420f91f:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f926:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420f92d:	48 8b 95 48 9e ff ff 	mov    -0x61b8(%rbp),%rdx
  800420f934:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
  800420f93b:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420f940:	48 89 c7             	mov    %rax,%rdi
  800420f943:	48 b8 4f 66 21 04 80 	movabs $0x800421664f,%rax
  800420f94a:	00 00 00 
  800420f94d:	ff d0                	callq  *%rax

		info->rip_line = ln.ln_lineno;
  800420f94f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420f956:	89 c2                	mov    %eax,%edx
  800420f958:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f95f:	89 50 08             	mov    %edx,0x8(%rax)
		info->rip_fn_narg = 0;
  800420f962:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f969:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)

		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
  800420f970:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  800420f977:	00 00 00 
  800420f97a:	48 8b 00             	mov    (%rax),%rax
  800420f97d:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420f984:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420f98b:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420f98f:	48 89 c7             	mov    %rax,%rdi
  800420f992:	48 b8 2c 33 21 04 80 	movabs $0x800421332c,%rax
  800420f999:	00 00 00 
  800420f99c:	ff d0                	callq  *%rax
  800420f99e:	83 f8 04             	cmp    $0x4,%eax
  800420f9a1:	0f 84 9f 04 00 00    	je     800420fe46 <list_func_die+0x718>
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
  800420f9a7:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420f9ae:	48 83 f8 05          	cmp    $0x5,%rax
  800420f9b2:	0f 85 8a 04 00 00    	jne    800420fe42 <list_func_die+0x714>
				goto last;

			attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420f9b8:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420f9bf:	be 49 00 00 00       	mov    $0x49,%esi
  800420f9c4:	48 89 c7             	mov    %rax,%rdi
  800420f9c7:	48 b8 97 30 21 04 80 	movabs $0x8004213097,%rax
  800420f9ce:	00 00 00 
  800420f9d1:	ff d0                	callq  *%rax
  800420f9d3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
		try_again:
			if(attr != NULL)
  800420f9d7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f9dc:	0f 84 b6 00 00 00    	je     800420fa98 <list_func_die+0x36a>
			{
				offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420f9e2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f9e6:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420f9ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f9ee:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420f9f2:	48 01 d0             	add    %rdx,%rax
  800420f9f5:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				dwarf_offdie(dbg, offset, &sib, *cu);
  800420f9f9:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  800420fa00:	00 00 00 
  800420fa03:	48 8b 08             	mov    (%rax),%rcx
  800420fa06:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420fa0d:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420fa11:	48 83 ec 08          	sub    $0x8,%rsp
  800420fa15:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fa19:	ff 70 30             	pushq  0x30(%rax)
  800420fa1c:	ff 70 28             	pushq  0x28(%rax)
  800420fa1f:	ff 70 20             	pushq  0x20(%rax)
  800420fa22:	ff 70 18             	pushq  0x18(%rax)
  800420fa25:	ff 70 10             	pushq  0x10(%rax)
  800420fa28:	ff 70 08             	pushq  0x8(%rax)
  800420fa2b:	ff 30                	pushq  (%rax)
  800420fa2d:	48 89 cf             	mov    %rcx,%rdi
  800420fa30:	48 b8 b5 2f 21 04 80 	movabs $0x8004212fb5,%rax
  800420fa37:	00 00 00 
  800420fa3a:	ff d0                	callq  *%rax
  800420fa3c:	48 83 c4 40          	add    $0x40,%rsp
				attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420fa40:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420fa47:	be 0b 00 00 00       	mov    $0xb,%esi
  800420fa4c:	48 89 c7             	mov    %rax,%rdi
  800420fa4f:	48 b8 97 30 21 04 80 	movabs $0x8004213097,%rax
  800420fa56:	00 00 00 
  800420fa59:	ff d0                	callq  *%rax
  800420fa5b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		
				if(attr != NULL)
  800420fa5f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420fa64:	74 0e                	je     800420fa74 <list_func_die+0x346>
				{
					ret_val = attr->u[0].u64;
  800420fa66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa6a:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420fa6e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420fa72:	eb 24                	jmp    800420fa98 <list_func_die+0x36a>
				}
				else
				{
					attr = _dwarf_attr_find(&sib, DW_AT_type);
  800420fa74:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420fa7b:	be 49 00 00 00       	mov    $0x49,%esi
  800420fa80:	48 89 c7             	mov    %rax,%rdi
  800420fa83:	48 b8 97 30 21 04 80 	movabs $0x8004213097,%rax
  800420fa8a:	00 00 00 
  800420fa8d:	ff d0                	callq  *%rax
  800420fa8f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					goto try_again;
  800420fa93:	e9 3f ff ff ff       	jmpq   800420f9d7 <list_func_die+0x2a9>
				}
			}

			ret_offset = 0;
  800420fa98:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420fa9f:	00 
			attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420faa0:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420faa7:	be 02 00 00 00       	mov    $0x2,%esi
  800420faac:	48 89 c7             	mov    %rax,%rdi
  800420faaf:	48 b8 97 30 21 04 80 	movabs $0x8004213097,%rax
  800420fab6:	00 00 00 
  800420fab9:	ff d0                	callq  *%rax
  800420fabb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if (attr != NULL)
  800420fabf:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420fac4:	0f 84 a0 00 00 00    	je     800420fb6a <list_func_die+0x43c>
			{
				Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420faca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420face:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420fad2:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
				Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420fad6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fada:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420fade:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
				Dwarf_Small atom;
				Dwarf_Unsigned op1, op2;

				switch(attr->at_form) {
  800420fae2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fae6:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420faea:	48 83 f8 03          	cmp    $0x3,%rax
  800420faee:	72 7a                	jb     800420fb6a <list_func_die+0x43c>
  800420faf0:	48 83 f8 04          	cmp    $0x4,%rax
  800420faf4:	76 06                	jbe    800420fafc <list_func_die+0x3ce>
  800420faf6:	48 83 f8 0a          	cmp    $0xa,%rax
  800420fafa:	75 6e                	jne    800420fb6a <list_func_die+0x43c>
					case DW_FORM_block1:
					case DW_FORM_block2:
					case DW_FORM_block4:
						offset = 0;
  800420fafc:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420fb03:	00 
						atom = *(loc_ptr++);
  800420fb04:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fb08:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420fb0c:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420fb10:	0f b6 00             	movzbl (%rax),%eax
  800420fb13:	88 45 af             	mov    %al,-0x51(%rbp)
						offset++;
  800420fb16:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
						if (atom == DW_OP_fbreg) {
  800420fb1b:	80 7d af 91          	cmpb   $0x91,-0x51(%rbp)
  800420fb1f:	75 48                	jne    800420fb69 <list_func_die+0x43b>
							uint8_t *p = loc_ptr;
  800420fb21:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fb25:	48 89 85 68 9e ff ff 	mov    %rax,-0x6198(%rbp)
							ret_offset = _dwarf_decode_sleb128(&p);
  800420fb2c:	48 8d 85 68 9e ff ff 	lea    -0x6198(%rbp),%rax
  800420fb33:	48 89 c7             	mov    %rax,%rdi
  800420fb36:	48 b8 50 1d 21 04 80 	movabs $0x8004211d50,%rax
  800420fb3d:	00 00 00 
  800420fb40:	ff d0                	callq  *%rax
  800420fb42:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
							offset += p - loc_ptr;
  800420fb46:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420fb4d:	48 89 c2             	mov    %rax,%rdx
  800420fb50:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fb54:	48 29 c2             	sub    %rax,%rdx
  800420fb57:	48 89 d0             	mov    %rdx,%rax
  800420fb5a:	48 01 45 c0          	add    %rax,-0x40(%rbp)
							loc_ptr = p;
  800420fb5e:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420fb65:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
						}
						break;
  800420fb69:	90                   	nop
				}
			}

			info->size_fn_arg[info->rip_fn_narg] = ret_val;
  800420fb6a:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420fb71:	8b 50 28             	mov    0x28(%rax),%edx
  800420fb74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb78:	89 c1                	mov    %eax,%ecx
  800420fb7a:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420fb81:	48 63 d2             	movslq %edx,%rdx
  800420fb84:	48 83 c2 08          	add    $0x8,%rdx
  800420fb88:	89 4c 90 0c          	mov    %ecx,0xc(%rax,%rdx,4)
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
  800420fb8c:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420fb93:	8b 50 28             	mov    0x28(%rax),%edx
  800420fb96:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420fb9d:	48 63 d2             	movslq %edx,%rdx
  800420fba0:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420fba4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420fba8:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
			info->rip_fn_narg++;
  800420fbad:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420fbb4:	8b 40 28             	mov    0x28(%rax),%eax
  800420fbb7:	8d 50 01             	lea    0x1(%rax),%edx
  800420fbba:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420fbc1:	89 50 28             	mov    %edx,0x28(%rax)
			sib = ret; 
  800420fbc4:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420fbcb:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420fbd2:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420fbd7:	48 89 ce             	mov    %rcx,%rsi
  800420fbda:	48 89 c7             	mov    %rax,%rdi
  800420fbdd:	48 b8 5b 13 21 04 80 	movabs $0x800421135b,%rax
  800420fbe4:	00 00 00 
  800420fbe7:	ff d0                	callq  *%rax

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420fbe9:	e9 1c 02 00 00       	jmpq   800420fe0a <list_func_die+0x6dc>
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
  800420fbee:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420fbf5:	48 83 f8 05          	cmp    $0x5,%rax
  800420fbf9:	0f 85 46 02 00 00    	jne    800420fe45 <list_func_die+0x717>
					break;

				attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420fbff:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420fc06:	be 49 00 00 00       	mov    $0x49,%esi
  800420fc0b:	48 89 c7             	mov    %rax,%rdi
  800420fc0e:	48 b8 97 30 21 04 80 	movabs $0x8004213097,%rax
  800420fc15:	00 00 00 
  800420fc18:	ff d0                	callq  *%rax
  800420fc1a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
				if(attr != NULL)
  800420fc1e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420fc23:	0f 84 90 00 00 00    	je     800420fcb9 <list_func_die+0x58b>
				{	   
					offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420fc29:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fc2d:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420fc31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc35:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420fc39:	48 01 d0             	add    %rdx,%rax
  800420fc3c:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
					dwarf_offdie(dbg, offset, &sib, *cu);
  800420fc40:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  800420fc47:	00 00 00 
  800420fc4a:	48 8b 08             	mov    (%rax),%rcx
  800420fc4d:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420fc54:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420fc58:	48 83 ec 08          	sub    $0x8,%rsp
  800420fc5c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fc60:	ff 70 30             	pushq  0x30(%rax)
  800420fc63:	ff 70 28             	pushq  0x28(%rax)
  800420fc66:	ff 70 20             	pushq  0x20(%rax)
  800420fc69:	ff 70 18             	pushq  0x18(%rax)
  800420fc6c:	ff 70 10             	pushq  0x10(%rax)
  800420fc6f:	ff 70 08             	pushq  0x8(%rax)
  800420fc72:	ff 30                	pushq  (%rax)
  800420fc74:	48 89 cf             	mov    %rcx,%rdi
  800420fc77:	48 b8 b5 2f 21 04 80 	movabs $0x8004212fb5,%rax
  800420fc7e:	00 00 00 
  800420fc81:	ff d0                	callq  *%rax
  800420fc83:	48 83 c4 40          	add    $0x40,%rsp
					attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420fc87:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420fc8e:	be 0b 00 00 00       	mov    $0xb,%esi
  800420fc93:	48 89 c7             	mov    %rax,%rdi
  800420fc96:	48 b8 97 30 21 04 80 	movabs $0x8004213097,%rax
  800420fc9d:	00 00 00 
  800420fca0:	ff d0                	callq  *%rax
  800420fca2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
					if(attr != NULL)
  800420fca6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420fcab:	74 0c                	je     800420fcb9 <list_func_die+0x58b>
					{
						ret_val = attr->u[0].u64;
  800420fcad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fcb1:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420fcb5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
					}
				}
	
				ret_offset = 0;
  800420fcb9:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420fcc0:	00 
				attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420fcc1:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420fcc8:	be 02 00 00 00       	mov    $0x2,%esi
  800420fccd:	48 89 c7             	mov    %rax,%rdi
  800420fcd0:	48 b8 97 30 21 04 80 	movabs $0x8004213097,%rax
  800420fcd7:	00 00 00 
  800420fcda:	ff d0                	callq  *%rax
  800420fcdc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				if (attr != NULL)
  800420fce0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420fce5:	0f 84 a0 00 00 00    	je     800420fd8b <list_func_die+0x65d>
				{
					Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420fceb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fcef:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420fcf3:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
					Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420fcf7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fcfb:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420fcff:	48 89 45 98          	mov    %rax,-0x68(%rbp)
					Dwarf_Small atom;
					Dwarf_Unsigned op1, op2;

					switch(attr->at_form) {
  800420fd03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd07:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fd0b:	48 83 f8 03          	cmp    $0x3,%rax
  800420fd0f:	72 7a                	jb     800420fd8b <list_func_die+0x65d>
  800420fd11:	48 83 f8 04          	cmp    $0x4,%rax
  800420fd15:	76 06                	jbe    800420fd1d <list_func_die+0x5ef>
  800420fd17:	48 83 f8 0a          	cmp    $0xa,%rax
  800420fd1b:	75 6e                	jne    800420fd8b <list_func_die+0x65d>
						case DW_FORM_block1:
						case DW_FORM_block2:
						case DW_FORM_block4:
							offset = 0;
  800420fd1d:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420fd24:	00 
							atom = *(loc_ptr++);
  800420fd25:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420fd29:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420fd2d:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420fd31:	0f b6 00             	movzbl (%rax),%eax
  800420fd34:	88 45 97             	mov    %al,-0x69(%rbp)
							offset++;
  800420fd37:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
							if (atom == DW_OP_fbreg) {
  800420fd3c:	80 7d 97 91          	cmpb   $0x91,-0x69(%rbp)
  800420fd40:	75 48                	jne    800420fd8a <list_func_die+0x65c>
								uint8_t *p = loc_ptr;
  800420fd42:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420fd46:	48 89 85 60 9e ff ff 	mov    %rax,-0x61a0(%rbp)
								ret_offset = _dwarf_decode_sleb128(&p);
  800420fd4d:	48 8d 85 60 9e ff ff 	lea    -0x61a0(%rbp),%rax
  800420fd54:	48 89 c7             	mov    %rax,%rdi
  800420fd57:	48 b8 50 1d 21 04 80 	movabs $0x8004211d50,%rax
  800420fd5e:	00 00 00 
  800420fd61:	ff d0                	callq  *%rax
  800420fd63:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
								offset += p - loc_ptr;
  800420fd67:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420fd6e:	48 89 c2             	mov    %rax,%rdx
  800420fd71:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420fd75:	48 29 c2             	sub    %rax,%rdx
  800420fd78:	48 89 d0             	mov    %rdx,%rax
  800420fd7b:	48 01 45 c0          	add    %rax,-0x40(%rbp)
								loc_ptr = p;
  800420fd7f:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420fd86:	48 89 45 98          	mov    %rax,-0x68(%rbp)
							}
							break;
  800420fd8a:	90                   	nop
					}
				}

				info->size_fn_arg[info->rip_fn_narg]=ret_val;// _get_arg_size(ret);
  800420fd8b:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420fd92:	8b 50 28             	mov    0x28(%rax),%edx
  800420fd95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fd99:	89 c1                	mov    %eax,%ecx
  800420fd9b:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420fda2:	48 63 d2             	movslq %edx,%rdx
  800420fda5:	48 83 c2 08          	add    $0x8,%rdx
  800420fda9:	89 4c 90 0c          	mov    %ecx,0xc(%rax,%rdx,4)
				info->offset_fn_arg[info->rip_fn_narg]=ret_offset;
  800420fdad:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420fdb4:	8b 50 28             	mov    0x28(%rax),%edx
  800420fdb7:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420fdbe:	48 63 d2             	movslq %edx,%rdx
  800420fdc1:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420fdc5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420fdc9:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
				info->rip_fn_narg++;
  800420fdce:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420fdd5:	8b 40 28             	mov    0x28(%rax),%eax
  800420fdd8:	8d 50 01             	lea    0x1(%rax),%edx
  800420fddb:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420fde2:	89 50 28             	mov    %edx,0x28(%rax)
				sib = ret; 
  800420fde5:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420fdec:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420fdf3:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420fdf8:	48 89 ce             	mov    %rcx,%rsi
  800420fdfb:	48 89 c7             	mov    %rax,%rdi
  800420fdfe:	48 b8 5b 13 21 04 80 	movabs $0x800421135b,%rax
  800420fe05:	00 00 00 
  800420fe08:	ff d0                	callq  *%rax
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
			info->rip_fn_narg++;
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420fe0a:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  800420fe11:	00 00 00 
  800420fe14:	48 8b 00             	mov    (%rax),%rax
  800420fe17:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420fe1b:	48 8d 95 e0 ce ff ff 	lea    -0x3120(%rbp),%rdx
  800420fe22:	48 8d b5 70 9e ff ff 	lea    -0x6190(%rbp),%rsi
  800420fe29:	48 89 c7             	mov    %rax,%rdi
  800420fe2c:	48 b8 2a 31 21 04 80 	movabs $0x800421312a,%rax
  800420fe33:	00 00 00 
  800420fe36:	ff d0                	callq  *%rax
  800420fe38:	85 c0                	test   %eax,%eax
  800420fe3a:	0f 84 ae fd ff ff    	je     800420fbee <list_func_die+0x4c0>
  800420fe40:	eb 04                	jmp    800420fe46 <list_func_die+0x718>
		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
				goto last;
  800420fe42:	90                   	nop
  800420fe43:	eb 01                	jmp    800420fe46 <list_func_die+0x718>
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
					break;
  800420fe45:	90                   	nop
				info->rip_fn_narg++;
				sib = ret; 
			}
		}
	last:	
		return 1;
  800420fe46:	b8 01 00 00 00       	mov    $0x1,%eax
  800420fe4b:	eb 05                	jmp    800420fe52 <list_func_die+0x724>
	}

	return 0;
  800420fe4d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fe52:	c9                   	leaveq 
  800420fe53:	c3                   	retq   

000000800420fe54 <debuginfo_rip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info)
{
  800420fe54:	55                   	push   %rbp
  800420fe55:	48 89 e5             	mov    %rsp,%rbp
  800420fe58:	48 81 ec c0 91 00 00 	sub    $0x91c0,%rsp
  800420fe5f:	48 89 bd 48 6e ff ff 	mov    %rdi,-0x91b8(%rbp)
  800420fe66:	48 89 b5 40 6e ff ff 	mov    %rsi,-0x91c0(%rbp)
	static struct Env* lastenv = NULL;
	void* elf;    
	Dwarf_Section *sect;
	Dwarf_CU cu;
	Dwarf_Die die, cudie, die2;
	Dwarf_Regtable *rt = NULL;
  800420fe6d:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420fe74:	00 
	//Set up initial pc
	uint64_t pc  = (uintptr_t)addr;
  800420fe75:	48 8b 85 48 6e ff ff 	mov    -0x91b8(%rbp),%rax
  800420fe7c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    
	// Initialize *info
	info->rip_file = "<unknown>";
  800420fe80:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420fe87:	48 bf 0f 10 22 04 80 	movabs $0x800422100f,%rdi
  800420fe8e:	00 00 00 
  800420fe91:	48 89 38             	mov    %rdi,(%rax)
	info->rip_line = 0;
  800420fe94:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420fe9b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	info->rip_fn_name = "<unknown>";
  800420fea2:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420fea9:	48 bf 0f 10 22 04 80 	movabs $0x800422100f,%rdi
  800420feb0:	00 00 00 
  800420feb3:	48 89 78 10          	mov    %rdi,0x10(%rax)
	info->rip_fn_namelen = 9;
  800420feb7:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420febe:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
	info->rip_fn_addr = addr;
  800420fec5:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420fecc:	48 8b 95 48 6e ff ff 	mov    -0x91b8(%rbp),%rdx
  800420fed3:	48 89 50 20          	mov    %rdx,0x20(%rax)
	info->rip_fn_narg = 0;
  800420fed7:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420fede:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
    
	// Find the relevant set of stabs
	if (addr >= ULIM) {
  800420fee5:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420feec:	00 00 00 
  800420feef:	48 39 85 48 6e ff ff 	cmp    %rax,-0x91b8(%rbp)
  800420fef6:	76 13                	jbe    800420ff0b <debuginfo_rip+0xb7>
		elf = (void *)0x10000 + KERNBASE;
  800420fef8:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800420feff:	00 00 00 
  800420ff02:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ff06:	e9 04 01 00 00       	jmpq   800421000f <debuginfo_rip+0x1bb>
	} else {

		if(curenv != lastenv) {
  800420ff0b:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420ff12:	00 00 00 
  800420ff15:	ff d0                	callq  *%rax
  800420ff17:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420ff1e:	00 00 00 
  800420ff21:	48 98                	cltq   
  800420ff23:	48 c1 e0 03          	shl    $0x3,%rax
  800420ff27:	48 89 c1             	mov    %rax,%rcx
  800420ff2a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ff2e:	48 01 c8             	add    %rcx,%rax
  800420ff31:	48 01 d0             	add    %rdx,%rax
  800420ff34:	48 83 c0 08          	add    $0x8,%rax
  800420ff38:	48 8b 10             	mov    (%rax),%rdx
  800420ff3b:	48 b8 98 12 4e 04 80 	movabs $0x80044e1298,%rax
  800420ff42:	00 00 00 
  800420ff45:	48 8b 00             	mov    (%rax),%rax
  800420ff48:	48 39 c2             	cmp    %rax,%rdx
  800420ff4b:	0f 84 83 00 00 00    	je     800420ffd4 <debuginfo_rip+0x180>
			find_debug_sections((uintptr_t)curenv->elf);
  800420ff51:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420ff58:	00 00 00 
  800420ff5b:	ff d0                	callq  *%rax
  800420ff5d:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420ff64:	00 00 00 
  800420ff67:	48 98                	cltq   
  800420ff69:	48 c1 e0 03          	shl    $0x3,%rax
  800420ff6d:	48 89 c1             	mov    %rax,%rcx
  800420ff70:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ff74:	48 01 c8             	add    %rcx,%rax
  800420ff77:	48 01 d0             	add    %rdx,%rax
  800420ff7a:	48 83 c0 08          	add    $0x8,%rax
  800420ff7e:	48 8b 00             	mov    (%rax),%rax
  800420ff81:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420ff88:	48 89 c7             	mov    %rax,%rdi
  800420ff8b:	48 b8 4a 68 21 04 80 	movabs $0x800421684a,%rax
  800420ff92:	00 00 00 
  800420ff95:	ff d0                	callq  *%rax
			lastenv = curenv;
  800420ff97:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420ff9e:	00 00 00 
  800420ffa1:	ff d0                	callq  *%rax
  800420ffa3:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420ffaa:	00 00 00 
  800420ffad:	48 98                	cltq   
  800420ffaf:	48 c1 e0 03          	shl    $0x3,%rax
  800420ffb3:	48 89 c1             	mov    %rax,%rcx
  800420ffb6:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ffba:	48 01 c8             	add    %rcx,%rax
  800420ffbd:	48 01 d0             	add    %rdx,%rax
  800420ffc0:	48 83 c0 08          	add    $0x8,%rax
  800420ffc4:	48 8b 10             	mov    (%rax),%rdx
  800420ffc7:	48 b8 98 12 4e 04 80 	movabs $0x80044e1298,%rax
  800420ffce:	00 00 00 
  800420ffd1:	48 89 10             	mov    %rdx,(%rax)
		}
		elf = curenv->elf;
  800420ffd4:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800420ffdb:	00 00 00 
  800420ffde:	ff d0                	callq  *%rax
  800420ffe0:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800420ffe7:	00 00 00 
  800420ffea:	48 98                	cltq   
  800420ffec:	48 c1 e0 03          	shl    $0x3,%rax
  800420fff0:	48 89 c1             	mov    %rax,%rcx
  800420fff3:	48 c1 e1 04          	shl    $0x4,%rcx
  800420fff7:	48 01 c8             	add    %rcx,%rax
  800420fffa:	48 01 d0             	add    %rdx,%rax
  800420fffd:	48 83 c0 08          	add    $0x8,%rax
  8004210001:	48 8b 00             	mov    (%rax),%rax
  8004210004:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800421000b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	}
	_dwarf_init(dbg, elf);
  800421000f:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  8004210016:	00 00 00 
  8004210019:	48 8b 00             	mov    (%rax),%rax
  800421001c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210020:	48 89 d6             	mov    %rdx,%rsi
  8004210023:	48 89 c7             	mov    %rax,%rdi
  8004210026:	48 b8 ff 1f 21 04 80 	movabs $0x8004211fff,%rax
  800421002d:	00 00 00 
  8004210030:	ff d0                	callq  *%rax

	sect = _dwarf_find_section(".debug_info");	
  8004210032:	48 bf 19 10 22 04 80 	movabs $0x8004221019,%rdi
  8004210039:	00 00 00 
  800421003c:	48 b8 ca 67 21 04 80 	movabs $0x80042167ca,%rax
  8004210043:	00 00 00 
  8004210046:	ff d0                	callq  *%rax
  8004210048:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
  800421004c:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  8004210053:	00 00 00 
  8004210056:	48 8b 00             	mov    (%rax),%rax
  8004210059:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421005d:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004210061:	48 89 50 08          	mov    %rdx,0x8(%rax)
	dbg->dbg_info_size = sect->ds_size;
  8004210065:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  800421006c:	00 00 00 
  800421006f:	48 8b 00             	mov    (%rax),%rax
  8004210072:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210076:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  800421007a:	48 89 50 10          	mov    %rdx,0x10(%rax)

	assert(dbg->dbg_info_size);
  800421007e:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  8004210085:	00 00 00 
  8004210088:	48 8b 00             	mov    (%rax),%rax
  800421008b:	48 8b 40 10          	mov    0x10(%rax),%rax
  800421008f:	48 85 c0             	test   %rax,%rax
  8004210092:	0f 85 78 01 00 00    	jne    8004210210 <debuginfo_rip+0x3bc>
  8004210098:	48 b9 25 10 22 04 80 	movabs $0x8004221025,%rcx
  800421009f:	00 00 00 
  80042100a2:	48 ba ec 0f 22 04 80 	movabs $0x8004220fec,%rdx
  80042100a9:	00 00 00 
  80042100ac:	be 3d 01 00 00       	mov    $0x13d,%esi
  80042100b1:	48 bf 01 10 22 04 80 	movabs $0x8004221001,%rdi
  80042100b8:	00 00 00 
  80042100bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042100c0:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042100c7:	00 00 00 
  80042100ca:	41 ff d0             	callq  *%r8
	while(_get_next_cu(dbg, &cu) == 0)
	{
		if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
  80042100cd:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  80042100d4:	00 00 00 
  80042100d7:	48 8b 00             	mov    (%rax),%rax
  80042100da:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
  80042100de:	48 8d 95 c0 9e ff ff 	lea    -0x6140(%rbp),%rdx
  80042100e5:	be 00 00 00 00       	mov    $0x0,%esi
  80042100ea:	48 89 c7             	mov    %rax,%rdi
  80042100ed:	48 b8 2a 31 21 04 80 	movabs $0x800421312a,%rax
  80042100f4:	00 00 00 
  80042100f7:	ff d0                	callq  *%rax
  80042100f9:	83 f8 04             	cmp    $0x4,%eax
  80042100fc:	75 05                	jne    8004210103 <debuginfo_rip+0x2af>
			continue;
  80042100fe:	e9 0d 01 00 00       	jmpq   8004210210 <debuginfo_rip+0x3bc>

		cudie.cu_header = &cu;
  8004210103:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004210107:	48 89 85 20 a2 ff ff 	mov    %rax,-0x5de0(%rbp)
		cudie.cu_die = NULL;
  800421010e:	48 c7 85 28 a2 ff ff 	movq   $0x0,-0x5dd8(%rbp)
  8004210115:	00 00 00 00 

		if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
  8004210119:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  8004210120:	00 00 00 
  8004210123:	48 8b 00             	mov    (%rax),%rax
  8004210126:	48 8d 8d 30 cf ff ff 	lea    -0x30d0(%rbp),%rcx
  800421012d:	48 8d 95 c0 9e ff ff 	lea    -0x6140(%rbp),%rdx
  8004210134:	48 8d 75 a0          	lea    -0x60(%rbp),%rsi
  8004210138:	48 89 c7             	mov    %rax,%rdi
  800421013b:	48 b8 2c 33 21 04 80 	movabs $0x800421332c,%rax
  8004210142:	00 00 00 
  8004210145:	ff d0                	callq  *%rax
  8004210147:	83 f8 04             	cmp    $0x4,%eax
  800421014a:	75 05                	jne    8004210151 <debuginfo_rip+0x2fd>
			continue;
  800421014c:	e9 bf 00 00 00       	jmpq   8004210210 <debuginfo_rip+0x3bc>

		die.cu_header = &cu;
  8004210151:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004210155:	48 89 85 90 d2 ff ff 	mov    %rax,-0x2d70(%rbp)
		die.cu_die = &cudie;
  800421015c:	48 8d 85 c0 9e ff ff 	lea    -0x6140(%rbp),%rax
  8004210163:	48 89 85 98 d2 ff ff 	mov    %rax,-0x2d68(%rbp)
		while(1)
		{
			if(list_func_die(info, &die, addr))
  800421016a:	48 8b 95 48 6e ff ff 	mov    -0x91b8(%rbp),%rdx
  8004210171:	48 8d 8d 30 cf ff ff 	lea    -0x30d0(%rbp),%rcx
  8004210178:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800421017f:	48 89 ce             	mov    %rcx,%rsi
  8004210182:	48 89 c7             	mov    %rax,%rdi
  8004210185:	48 b8 2e f7 20 04 80 	movabs $0x800420f72e,%rax
  800421018c:	00 00 00 
  800421018f:	ff d0                	callq  *%rax
  8004210191:	85 c0                	test   %eax,%eax
  8004210193:	0f 85 ac 00 00 00    	jne    8004210245 <debuginfo_rip+0x3f1>
				goto find_done;
			if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
  8004210199:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  80042101a0:	00 00 00 
  80042101a3:	48 8b 00             	mov    (%rax),%rax
  80042101a6:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
  80042101aa:	48 8d 95 50 6e ff ff 	lea    -0x91b0(%rbp),%rdx
  80042101b1:	48 8d b5 30 cf ff ff 	lea    -0x30d0(%rbp),%rsi
  80042101b8:	48 89 c7             	mov    %rax,%rdi
  80042101bb:	48 b8 2a 31 21 04 80 	movabs $0x800421312a,%rax
  80042101c2:	00 00 00 
  80042101c5:	ff d0                	callq  *%rax
  80042101c7:	85 c0                	test   %eax,%eax
  80042101c9:	79 02                	jns    80042101cd <debuginfo_rip+0x379>
				break; 
  80042101cb:	eb 43                	jmp    8004210210 <debuginfo_rip+0x3bc>
			die = die2;
  80042101cd:	48 8d 85 30 cf ff ff 	lea    -0x30d0(%rbp),%rax
  80042101d4:	48 8d 8d 50 6e ff ff 	lea    -0x91b0(%rbp),%rcx
  80042101db:	ba 70 30 00 00       	mov    $0x3070,%edx
  80042101e0:	48 89 ce             	mov    %rcx,%rsi
  80042101e3:	48 89 c7             	mov    %rax,%rdi
  80042101e6:	48 b8 5b 13 21 04 80 	movabs $0x800421135b,%rax
  80042101ed:	00 00 00 
  80042101f0:	ff d0                	callq  *%rax
			die.cu_header = &cu;
  80042101f2:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042101f6:	48 89 85 90 d2 ff ff 	mov    %rax,-0x2d70(%rbp)
			die.cu_die = &cudie;
  80042101fd:	48 8d 85 c0 9e ff ff 	lea    -0x6140(%rbp),%rax
  8004210204:	48 89 85 98 d2 ff ff 	mov    %rax,-0x2d68(%rbp)
		}
  800421020b:	e9 5a ff ff ff       	jmpq   800421016a <debuginfo_rip+0x316>
	sect = _dwarf_find_section(".debug_info");	
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
	dbg->dbg_info_size = sect->ds_size;

	assert(dbg->dbg_info_size);
	while(_get_next_cu(dbg, &cu) == 0)
  8004210210:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  8004210217:	00 00 00 
  800421021a:	48 8b 00             	mov    (%rax),%rax
  800421021d:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004210221:	48 89 d6             	mov    %rdx,%rsi
  8004210224:	48 89 c7             	mov    %rax,%rdi
  8004210227:	48 b8 db 20 21 04 80 	movabs $0x80042120db,%rax
  800421022e:	00 00 00 
  8004210231:	ff d0                	callq  *%rax
  8004210233:	85 c0                	test   %eax,%eax
  8004210235:	0f 84 92 fe ff ff    	je     80042100cd <debuginfo_rip+0x279>
			die.cu_header = &cu;
			die.cu_die = &cudie;
		}
	}

	return -1;
  800421023b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210240:	e9 c7 00 00 00       	jmpq   800421030c <debuginfo_rip+0x4b8>
		die.cu_header = &cu;
		die.cu_die = &cudie;
		while(1)
		{
			if(list_func_die(info, &die, addr))
				goto find_done;
  8004210245:	90                   	nop

	return -1;

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
  8004210246:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  800421024d:	00 00 00 
  8004210250:	48 8b 00             	mov    (%rax),%rax
  8004210253:	be 00 00 00 00       	mov    $0x0,%esi
  8004210258:	48 89 c7             	mov    %rax,%rdi
  800421025b:	48 b8 42 5a 21 04 80 	movabs $0x8004215a42,%rax
  8004210262:	00 00 00 
  8004210265:	ff d0                	callq  *%rax
  8004210267:	83 f8 01             	cmp    $0x1,%eax
  800421026a:	75 0a                	jne    8004210276 <debuginfo_rip+0x422>
		return -1;
  800421026c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210271:	e9 96 00 00 00       	jmpq   800421030c <debuginfo_rip+0x4b8>

	if (dwarf_get_fde_at_pc(dbg, addr, fde, cie, NULL) == DW_DLV_OK) {
  8004210276:	48 b8 80 66 23 04 80 	movabs $0x8004236680,%rax
  800421027d:	00 00 00 
  8004210280:	48 8b 08             	mov    (%rax),%rcx
  8004210283:	48 b8 78 66 23 04 80 	movabs $0x8004236678,%rax
  800421028a:	00 00 00 
  800421028d:	48 8b 10             	mov    (%rax),%rdx
  8004210290:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  8004210297:	00 00 00 
  800421029a:	48 8b 00             	mov    (%rax),%rax
  800421029d:	48 8b b5 48 6e ff ff 	mov    -0x91b8(%rbp),%rsi
  80042102a4:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80042102aa:	48 89 c7             	mov    %rax,%rdi
  80042102ad:	48 b8 4a 35 21 04 80 	movabs $0x800421354a,%rax
  80042102b4:	00 00 00 
  80042102b7:	ff d0                	callq  *%rax
  80042102b9:	85 c0                	test   %eax,%eax
  80042102bb:	75 4a                	jne    8004210307 <debuginfo_rip+0x4b3>
		dwarf_get_fde_info_for_all_regs(dbg, fde, addr,
  80042102bd:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  80042102c4:	48 8d 88 a8 00 00 00 	lea    0xa8(%rax),%rcx
  80042102cb:	48 b8 78 66 23 04 80 	movabs $0x8004236678,%rax
  80042102d2:	00 00 00 
  80042102d5:	48 8b 30             	mov    (%rax),%rsi
  80042102d8:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  80042102df:	00 00 00 
  80042102e2:	48 8b 00             	mov    (%rax),%rax
  80042102e5:	48 8b 95 48 6e ff ff 	mov    -0x91b8(%rbp),%rdx
  80042102ec:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80042102f2:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80042102f8:	48 89 c7             	mov    %rax,%rdi
  80042102fb:	48 b8 3a 48 21 04 80 	movabs $0x800421483a,%rax
  8004210302:	00 00 00 
  8004210305:	ff d0                	callq  *%rax
					break;
			}
		}
#endif
	}
	return 0;
  8004210307:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421030c:	c9                   	leaveq 
  800421030d:	c3                   	retq   

000000800421030e <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800421030e:	55                   	push   %rbp
  800421030f:	48 89 e5             	mov    %rsp,%rbp
  8004210312:	48 83 ec 30          	sub    $0x30,%rsp
  8004210316:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800421031a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800421031e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210322:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
  8004210325:	44 89 45 e0          	mov    %r8d,-0x20(%rbp)
  8004210329:	44 89 4d dc          	mov    %r9d,-0x24(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800421032d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210330:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004210334:	77 54                	ja     800421038a <printnum+0x7c>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  8004210336:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004210339:	8d 78 ff             	lea    -0x1(%rax),%edi
  800421033c:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  800421033f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210343:	ba 00 00 00 00       	mov    $0x0,%edx
  8004210348:	48 f7 f6             	div    %rsi
  800421034b:	49 89 c2             	mov    %rax,%r10
  800421034e:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  8004210351:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004210354:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004210358:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421035c:	41 89 c9             	mov    %ecx,%r9d
  800421035f:	41 89 f8             	mov    %edi,%r8d
  8004210362:	89 d1                	mov    %edx,%ecx
  8004210364:	4c 89 d2             	mov    %r10,%rdx
  8004210367:	48 89 c7             	mov    %rax,%rdi
  800421036a:	48 b8 0e 03 21 04 80 	movabs $0x800421030e,%rax
  8004210371:	00 00 00 
  8004210374:	ff d0                	callq  *%rax
  8004210376:	eb 1c                	jmp    8004210394 <printnum+0x86>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  8004210378:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800421037c:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800421037f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210383:	48 89 ce             	mov    %rcx,%rsi
  8004210386:	89 d7                	mov    %edx,%edi
  8004210388:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800421038a:	83 6d e0 01          	subl   $0x1,-0x20(%rbp)
  800421038e:	83 7d e0 00          	cmpl   $0x0,-0x20(%rbp)
  8004210392:	7f e4                	jg     8004210378 <printnum+0x6a>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  8004210394:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004210397:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421039b:	ba 00 00 00 00       	mov    $0x0,%edx
  80042103a0:	48 f7 f1             	div    %rcx
  80042103a3:	48 b8 30 12 22 04 80 	movabs $0x8004221230,%rax
  80042103aa:	00 00 00 
  80042103ad:	0f b6 04 10          	movzbl (%rax,%rdx,1),%eax
  80042103b1:	0f be d0             	movsbl %al,%edx
  80042103b4:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80042103b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042103bc:	48 89 ce             	mov    %rcx,%rsi
  80042103bf:	89 d7                	mov    %edx,%edi
  80042103c1:	ff d0                	callq  *%rax
}
  80042103c3:	90                   	nop
  80042103c4:	c9                   	leaveq 
  80042103c5:	c3                   	retq   

00000080042103c6 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  80042103c6:	55                   	push   %rbp
  80042103c7:	48 89 e5             	mov    %rsp,%rbp
  80042103ca:	48 83 ec 20          	sub    $0x20,%rsp
  80042103ce:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042103d2:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  80042103d5:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  80042103d9:	7e 4f                	jle    800421042a <getuint+0x64>
		x= va_arg(*ap, unsigned long long);
  80042103db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042103df:	8b 00                	mov    (%rax),%eax
  80042103e1:	83 f8 30             	cmp    $0x30,%eax
  80042103e4:	73 24                	jae    800421040a <getuint+0x44>
  80042103e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042103ea:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042103ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042103f2:	8b 00                	mov    (%rax),%eax
  80042103f4:	89 c0                	mov    %eax,%eax
  80042103f6:	48 01 d0             	add    %rdx,%rax
  80042103f9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042103fd:	8b 12                	mov    (%rdx),%edx
  80042103ff:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8004210402:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210406:	89 0a                	mov    %ecx,(%rdx)
  8004210408:	eb 14                	jmp    800421041e <getuint+0x58>
  800421040a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421040e:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210412:	48 8d 48 08          	lea    0x8(%rax),%rcx
  8004210416:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421041a:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800421041e:	48 8b 00             	mov    (%rax),%rax
  8004210421:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210425:	e9 9d 00 00 00       	jmpq   80042104c7 <getuint+0x101>
	else if (lflag)
  800421042a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421042e:	74 4c                	je     800421047c <getuint+0xb6>
		x= va_arg(*ap, unsigned long);
  8004210430:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210434:	8b 00                	mov    (%rax),%eax
  8004210436:	83 f8 30             	cmp    $0x30,%eax
  8004210439:	73 24                	jae    800421045f <getuint+0x99>
  800421043b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421043f:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004210443:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210447:	8b 00                	mov    (%rax),%eax
  8004210449:	89 c0                	mov    %eax,%eax
  800421044b:	48 01 d0             	add    %rdx,%rax
  800421044e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210452:	8b 12                	mov    (%rdx),%edx
  8004210454:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8004210457:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421045b:	89 0a                	mov    %ecx,(%rdx)
  800421045d:	eb 14                	jmp    8004210473 <getuint+0xad>
  800421045f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210463:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210467:	48 8d 48 08          	lea    0x8(%rax),%rcx
  800421046b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421046f:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8004210473:	48 8b 00             	mov    (%rax),%rax
  8004210476:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421047a:	eb 4b                	jmp    80042104c7 <getuint+0x101>
	else
		x= va_arg(*ap, unsigned int);
  800421047c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210480:	8b 00                	mov    (%rax),%eax
  8004210482:	83 f8 30             	cmp    $0x30,%eax
  8004210485:	73 24                	jae    80042104ab <getuint+0xe5>
  8004210487:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421048b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800421048f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210493:	8b 00                	mov    (%rax),%eax
  8004210495:	89 c0                	mov    %eax,%eax
  8004210497:	48 01 d0             	add    %rdx,%rax
  800421049a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421049e:	8b 12                	mov    (%rdx),%edx
  80042104a0:	8d 4a 08             	lea    0x8(%rdx),%ecx
  80042104a3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042104a7:	89 0a                	mov    %ecx,(%rdx)
  80042104a9:	eb 14                	jmp    80042104bf <getuint+0xf9>
  80042104ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042104af:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042104b3:	48 8d 48 08          	lea    0x8(%rax),%rcx
  80042104b7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042104bb:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  80042104bf:	8b 00                	mov    (%rax),%eax
  80042104c1:	89 c0                	mov    %eax,%eax
  80042104c3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  80042104c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042104cb:	c9                   	leaveq 
  80042104cc:	c3                   	retq   

00000080042104cd <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  80042104cd:	55                   	push   %rbp
  80042104ce:	48 89 e5             	mov    %rsp,%rbp
  80042104d1:	48 83 ec 20          	sub    $0x20,%rsp
  80042104d5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042104d9:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  80042104dc:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  80042104e0:	7e 4f                	jle    8004210531 <getint+0x64>
		x=va_arg(*ap, long long);
  80042104e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042104e6:	8b 00                	mov    (%rax),%eax
  80042104e8:	83 f8 30             	cmp    $0x30,%eax
  80042104eb:	73 24                	jae    8004210511 <getint+0x44>
  80042104ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042104f1:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042104f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042104f9:	8b 00                	mov    (%rax),%eax
  80042104fb:	89 c0                	mov    %eax,%eax
  80042104fd:	48 01 d0             	add    %rdx,%rax
  8004210500:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210504:	8b 12                	mov    (%rdx),%edx
  8004210506:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8004210509:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421050d:	89 0a                	mov    %ecx,(%rdx)
  800421050f:	eb 14                	jmp    8004210525 <getint+0x58>
  8004210511:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210515:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210519:	48 8d 48 08          	lea    0x8(%rax),%rcx
  800421051d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210521:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8004210525:	48 8b 00             	mov    (%rax),%rax
  8004210528:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421052c:	e9 9d 00 00 00       	jmpq   80042105ce <getint+0x101>
	else if (lflag)
  8004210531:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004210535:	74 4c                	je     8004210583 <getint+0xb6>
		x=va_arg(*ap, long);
  8004210537:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421053b:	8b 00                	mov    (%rax),%eax
  800421053d:	83 f8 30             	cmp    $0x30,%eax
  8004210540:	73 24                	jae    8004210566 <getint+0x99>
  8004210542:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210546:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800421054a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421054e:	8b 00                	mov    (%rax),%eax
  8004210550:	89 c0                	mov    %eax,%eax
  8004210552:	48 01 d0             	add    %rdx,%rax
  8004210555:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210559:	8b 12                	mov    (%rdx),%edx
  800421055b:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800421055e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210562:	89 0a                	mov    %ecx,(%rdx)
  8004210564:	eb 14                	jmp    800421057a <getint+0xad>
  8004210566:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421056a:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421056e:	48 8d 48 08          	lea    0x8(%rax),%rcx
  8004210572:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210576:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800421057a:	48 8b 00             	mov    (%rax),%rax
  800421057d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210581:	eb 4b                	jmp    80042105ce <getint+0x101>
	else
		x=va_arg(*ap, int);
  8004210583:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210587:	8b 00                	mov    (%rax),%eax
  8004210589:	83 f8 30             	cmp    $0x30,%eax
  800421058c:	73 24                	jae    80042105b2 <getint+0xe5>
  800421058e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210592:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004210596:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421059a:	8b 00                	mov    (%rax),%eax
  800421059c:	89 c0                	mov    %eax,%eax
  800421059e:	48 01 d0             	add    %rdx,%rax
  80042105a1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042105a5:	8b 12                	mov    (%rdx),%edx
  80042105a7:	8d 4a 08             	lea    0x8(%rdx),%ecx
  80042105aa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042105ae:	89 0a                	mov    %ecx,(%rdx)
  80042105b0:	eb 14                	jmp    80042105c6 <getint+0xf9>
  80042105b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042105b6:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042105ba:	48 8d 48 08          	lea    0x8(%rax),%rcx
  80042105be:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042105c2:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  80042105c6:	8b 00                	mov    (%rax),%eax
  80042105c8:	48 98                	cltq   
  80042105ca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  80042105ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042105d2:	c9                   	leaveq 
  80042105d3:	c3                   	retq   

00000080042105d4 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  80042105d4:	55                   	push   %rbp
  80042105d5:	48 89 e5             	mov    %rsp,%rbp
  80042105d8:	41 54                	push   %r12
  80042105da:	53                   	push   %rbx
  80042105db:	48 83 ec 60          	sub    $0x60,%rsp
  80042105df:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80042105e3:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  80042105e7:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  80042105eb:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  80042105ef:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  80042105f3:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042105f7:	48 8b 0a             	mov    (%rdx),%rcx
  80042105fa:	48 89 08             	mov    %rcx,(%rax)
  80042105fd:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004210601:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004210605:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004210609:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800421060d:	eb 17                	jmp    8004210626 <vprintfmt+0x52>
			if (ch == '\0')
  800421060f:	85 db                	test   %ebx,%ebx
  8004210611:	0f 84 b9 04 00 00    	je     8004210ad0 <vprintfmt+0x4fc>
				return;
			putch(ch, putdat);
  8004210617:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800421061b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421061f:	48 89 d6             	mov    %rdx,%rsi
  8004210622:	89 df                	mov    %ebx,%edi
  8004210624:	ff d0                	callq  *%rax
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  8004210626:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421062a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421062e:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  8004210632:	0f b6 00             	movzbl (%rax),%eax
  8004210635:	0f b6 d8             	movzbl %al,%ebx
  8004210638:	83 fb 25             	cmp    $0x25,%ebx
  800421063b:	75 d2                	jne    800421060f <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  800421063d:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  8004210641:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  8004210648:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  800421064f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  8004210656:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800421065d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004210661:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210665:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  8004210669:	0f b6 00             	movzbl (%rax),%eax
  800421066c:	0f b6 d8             	movzbl %al,%ebx
  800421066f:	8d 43 dd             	lea    -0x23(%rbx),%eax
  8004210672:	83 f8 55             	cmp    $0x55,%eax
  8004210675:	0f 87 22 04 00 00    	ja     8004210a9d <vprintfmt+0x4c9>
  800421067b:	89 c0                	mov    %eax,%eax
  800421067d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004210684:	00 
  8004210685:	48 b8 58 12 22 04 80 	movabs $0x8004221258,%rax
  800421068c:	00 00 00 
  800421068f:	48 01 d0             	add    %rdx,%rax
  8004210692:	48 8b 00             	mov    (%rax),%rax
  8004210695:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  8004210697:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  800421069b:	eb c0                	jmp    800421065d <vprintfmt+0x89>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800421069d:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  80042106a1:	eb ba                	jmp    800421065d <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  80042106a3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  80042106aa:	8b 55 d8             	mov    -0x28(%rbp),%edx
  80042106ad:	89 d0                	mov    %edx,%eax
  80042106af:	c1 e0 02             	shl    $0x2,%eax
  80042106b2:	01 d0                	add    %edx,%eax
  80042106b4:	01 c0                	add    %eax,%eax
  80042106b6:	01 d8                	add    %ebx,%eax
  80042106b8:	83 e8 30             	sub    $0x30,%eax
  80042106bb:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  80042106be:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042106c2:	0f b6 00             	movzbl (%rax),%eax
  80042106c5:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  80042106c8:	83 fb 2f             	cmp    $0x2f,%ebx
  80042106cb:	7e 60                	jle    800421072d <vprintfmt+0x159>
  80042106cd:	83 fb 39             	cmp    $0x39,%ebx
  80042106d0:	7f 5b                	jg     800421072d <vprintfmt+0x159>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  80042106d2:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  80042106d7:	eb d1                	jmp    80042106aa <vprintfmt+0xd6>
			goto process_precision;

		case '*':
			precision = va_arg(aq, int);
  80042106d9:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80042106dc:	83 f8 30             	cmp    $0x30,%eax
  80042106df:	73 17                	jae    80042106f8 <vprintfmt+0x124>
  80042106e1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042106e5:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80042106e8:	89 d2                	mov    %edx,%edx
  80042106ea:	48 01 d0             	add    %rdx,%rax
  80042106ed:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80042106f0:	83 c2 08             	add    $0x8,%edx
  80042106f3:	89 55 b8             	mov    %edx,-0x48(%rbp)
  80042106f6:	eb 0c                	jmp    8004210704 <vprintfmt+0x130>
  80042106f8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042106fc:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004210700:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8004210704:	8b 00                	mov    (%rax),%eax
  8004210706:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  8004210709:	eb 23                	jmp    800421072e <vprintfmt+0x15a>

		case '.':
			if (width < 0)
  800421070b:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800421070f:	0f 89 48 ff ff ff    	jns    800421065d <vprintfmt+0x89>
				width = 0;
  8004210715:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  800421071c:	e9 3c ff ff ff       	jmpq   800421065d <vprintfmt+0x89>

		case '#':
			altflag = 1;
  8004210721:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  8004210728:	e9 30 ff ff ff       	jmpq   800421065d <vprintfmt+0x89>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
  800421072d:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
  800421072e:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004210732:	0f 89 25 ff ff ff    	jns    800421065d <vprintfmt+0x89>
				width = precision, precision = -1;
  8004210738:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421073b:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800421073e:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  8004210745:	e9 13 ff ff ff       	jmpq   800421065d <vprintfmt+0x89>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  800421074a:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  800421074e:	e9 0a ff ff ff       	jmpq   800421065d <vprintfmt+0x89>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  8004210753:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8004210756:	83 f8 30             	cmp    $0x30,%eax
  8004210759:	73 17                	jae    8004210772 <vprintfmt+0x19e>
  800421075b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421075f:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8004210762:	89 d2                	mov    %edx,%edx
  8004210764:	48 01 d0             	add    %rdx,%rax
  8004210767:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800421076a:	83 c2 08             	add    $0x8,%edx
  800421076d:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8004210770:	eb 0c                	jmp    800421077e <vprintfmt+0x1aa>
  8004210772:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210776:	48 8d 50 08          	lea    0x8(%rax),%rdx
  800421077a:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800421077e:	8b 10                	mov    (%rax),%edx
  8004210780:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004210784:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210788:	48 89 ce             	mov    %rcx,%rsi
  800421078b:	89 d7                	mov    %edx,%edi
  800421078d:	ff d0                	callq  *%rax
			break;
  800421078f:	e9 37 03 00 00       	jmpq   8004210acb <vprintfmt+0x4f7>

			// error message
		case 'e':
			err = va_arg(aq, int);
  8004210794:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8004210797:	83 f8 30             	cmp    $0x30,%eax
  800421079a:	73 17                	jae    80042107b3 <vprintfmt+0x1df>
  800421079c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042107a0:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80042107a3:	89 d2                	mov    %edx,%edx
  80042107a5:	48 01 d0             	add    %rdx,%rax
  80042107a8:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80042107ab:	83 c2 08             	add    $0x8,%edx
  80042107ae:	89 55 b8             	mov    %edx,-0x48(%rbp)
  80042107b1:	eb 0c                	jmp    80042107bf <vprintfmt+0x1eb>
  80042107b3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042107b7:	48 8d 50 08          	lea    0x8(%rax),%rdx
  80042107bb:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  80042107bf:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  80042107c1:	85 db                	test   %ebx,%ebx
  80042107c3:	79 02                	jns    80042107c7 <vprintfmt+0x1f3>
				err = -err;
  80042107c5:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80042107c7:	83 fb 15             	cmp    $0x15,%ebx
  80042107ca:	7f 16                	jg     80042107e2 <vprintfmt+0x20e>
  80042107cc:	48 b8 80 11 22 04 80 	movabs $0x8004221180,%rax
  80042107d3:	00 00 00 
  80042107d6:	48 63 d3             	movslq %ebx,%rdx
  80042107d9:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  80042107dd:	4d 85 e4             	test   %r12,%r12
  80042107e0:	75 2e                	jne    8004210810 <vprintfmt+0x23c>
				printfmt(putch, putdat, "error %d", err);
  80042107e2:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  80042107e6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042107ea:	89 d9                	mov    %ebx,%ecx
  80042107ec:	48 ba 41 12 22 04 80 	movabs $0x8004221241,%rdx
  80042107f3:	00 00 00 
  80042107f6:	48 89 c7             	mov    %rax,%rdi
  80042107f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042107fe:	49 b8 da 0a 21 04 80 	movabs $0x8004210ada,%r8
  8004210805:	00 00 00 
  8004210808:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  800421080b:	e9 bb 02 00 00       	jmpq   8004210acb <vprintfmt+0x4f7>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  8004210810:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  8004210814:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210818:	4c 89 e1             	mov    %r12,%rcx
  800421081b:	48 ba 4a 12 22 04 80 	movabs $0x800422124a,%rdx
  8004210822:	00 00 00 
  8004210825:	48 89 c7             	mov    %rax,%rdi
  8004210828:	b8 00 00 00 00       	mov    $0x0,%eax
  800421082d:	49 b8 da 0a 21 04 80 	movabs $0x8004210ada,%r8
  8004210834:	00 00 00 
  8004210837:	41 ff d0             	callq  *%r8
			break;
  800421083a:	e9 8c 02 00 00       	jmpq   8004210acb <vprintfmt+0x4f7>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  800421083f:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8004210842:	83 f8 30             	cmp    $0x30,%eax
  8004210845:	73 17                	jae    800421085e <vprintfmt+0x28a>
  8004210847:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421084b:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800421084e:	89 d2                	mov    %edx,%edx
  8004210850:	48 01 d0             	add    %rdx,%rax
  8004210853:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8004210856:	83 c2 08             	add    $0x8,%edx
  8004210859:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800421085c:	eb 0c                	jmp    800421086a <vprintfmt+0x296>
  800421085e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210862:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004210866:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800421086a:	4c 8b 20             	mov    (%rax),%r12
  800421086d:	4d 85 e4             	test   %r12,%r12
  8004210870:	75 0a                	jne    800421087c <vprintfmt+0x2a8>
				p = "(null)";
  8004210872:	49 bc 4d 12 22 04 80 	movabs $0x800422124d,%r12
  8004210879:	00 00 00 
			if (width > 0 && padc != '-')
  800421087c:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004210880:	7e 78                	jle    80042108fa <vprintfmt+0x326>
  8004210882:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  8004210886:	74 72                	je     80042108fa <vprintfmt+0x326>
				for (width -= strnlen(p, precision); width > 0; width--)
  8004210888:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421088b:	48 98                	cltq   
  800421088d:	48 89 c6             	mov    %rax,%rsi
  8004210890:	4c 89 e7             	mov    %r12,%rdi
  8004210893:	48 b8 e1 0e 21 04 80 	movabs $0x8004210ee1,%rax
  800421089a:	00 00 00 
  800421089d:	ff d0                	callq  *%rax
  800421089f:	29 45 dc             	sub    %eax,-0x24(%rbp)
  80042108a2:	eb 17                	jmp    80042108bb <vprintfmt+0x2e7>
					putch(padc, putdat);
  80042108a4:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  80042108a8:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042108ac:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042108b0:	48 89 ce             	mov    %rcx,%rsi
  80042108b3:	89 d7                	mov    %edx,%edi
  80042108b5:	ff d0                	callq  *%rax
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80042108b7:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  80042108bb:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042108bf:	7f e3                	jg     80042108a4 <vprintfmt+0x2d0>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80042108c1:	eb 37                	jmp    80042108fa <vprintfmt+0x326>
				if (altflag && (ch < ' ' || ch > '~'))
  80042108c3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  80042108c7:	74 1e                	je     80042108e7 <vprintfmt+0x313>
  80042108c9:	83 fb 1f             	cmp    $0x1f,%ebx
  80042108cc:	7e 05                	jle    80042108d3 <vprintfmt+0x2ff>
  80042108ce:	83 fb 7e             	cmp    $0x7e,%ebx
  80042108d1:	7e 14                	jle    80042108e7 <vprintfmt+0x313>
					putch('?', putdat);
  80042108d3:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042108d7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042108db:	48 89 d6             	mov    %rdx,%rsi
  80042108de:	bf 3f 00 00 00       	mov    $0x3f,%edi
  80042108e3:	ff d0                	callq  *%rax
  80042108e5:	eb 0f                	jmp    80042108f6 <vprintfmt+0x322>
				else
					putch(ch, putdat);
  80042108e7:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042108eb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042108ef:	48 89 d6             	mov    %rdx,%rsi
  80042108f2:	89 df                	mov    %ebx,%edi
  80042108f4:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80042108f6:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  80042108fa:	4c 89 e0             	mov    %r12,%rax
  80042108fd:	4c 8d 60 01          	lea    0x1(%rax),%r12
  8004210901:	0f b6 00             	movzbl (%rax),%eax
  8004210904:	0f be d8             	movsbl %al,%ebx
  8004210907:	85 db                	test   %ebx,%ebx
  8004210909:	74 28                	je     8004210933 <vprintfmt+0x35f>
  800421090b:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800421090f:	78 b2                	js     80042108c3 <vprintfmt+0x2ef>
  8004210911:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  8004210915:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  8004210919:	79 a8                	jns    80042108c3 <vprintfmt+0x2ef>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800421091b:	eb 16                	jmp    8004210933 <vprintfmt+0x35f>
				putch(' ', putdat);
  800421091d:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004210921:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210925:	48 89 d6             	mov    %rdx,%rsi
  8004210928:	bf 20 00 00 00       	mov    $0x20,%edi
  800421092d:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800421092f:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  8004210933:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004210937:	7f e4                	jg     800421091d <vprintfmt+0x349>
				putch(' ', putdat);
			break;
  8004210939:	e9 8d 01 00 00       	jmpq   8004210acb <vprintfmt+0x4f7>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  800421093e:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8004210942:	be 03 00 00 00       	mov    $0x3,%esi
  8004210947:	48 89 c7             	mov    %rax,%rdi
  800421094a:	48 b8 cd 04 21 04 80 	movabs $0x80042104cd,%rax
  8004210951:	00 00 00 
  8004210954:	ff d0                	callq  *%rax
  8004210956:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  800421095a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421095e:	48 85 c0             	test   %rax,%rax
  8004210961:	79 1d                	jns    8004210980 <vprintfmt+0x3ac>
				putch('-', putdat);
  8004210963:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004210967:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421096b:	48 89 d6             	mov    %rdx,%rsi
  800421096e:	bf 2d 00 00 00       	mov    $0x2d,%edi
  8004210973:	ff d0                	callq  *%rax
				num = -(long long) num;
  8004210975:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210979:	48 f7 d8             	neg    %rax
  800421097c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  8004210980:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  8004210987:	e9 d2 00 00 00       	jmpq   8004210a5e <vprintfmt+0x48a>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  800421098c:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8004210990:	be 03 00 00 00       	mov    $0x3,%esi
  8004210995:	48 89 c7             	mov    %rax,%rdi
  8004210998:	48 b8 c6 03 21 04 80 	movabs $0x80042103c6,%rax
  800421099f:	00 00 00 
  80042109a2:	ff d0                	callq  *%rax
  80042109a4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  80042109a8:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  80042109af:	e9 aa 00 00 00       	jmpq   8004210a5e <vprintfmt+0x48a>

			// (unsigned) octal
		case 'o':

			num = getuint(&aq, 3);
  80042109b4:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  80042109b8:	be 03 00 00 00       	mov    $0x3,%esi
  80042109bd:	48 89 c7             	mov    %rax,%rdi
  80042109c0:	48 b8 c6 03 21 04 80 	movabs $0x80042103c6,%rax
  80042109c7:	00 00 00 
  80042109ca:	ff d0                	callq  *%rax
  80042109cc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 8;
  80042109d0:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
			goto number;
  80042109d7:	e9 82 00 00 00       	jmpq   8004210a5e <vprintfmt+0x48a>


			// pointer
		case 'p':
			putch('0', putdat);
  80042109dc:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042109e0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042109e4:	48 89 d6             	mov    %rdx,%rsi
  80042109e7:	bf 30 00 00 00       	mov    $0x30,%edi
  80042109ec:	ff d0                	callq  *%rax
			putch('x', putdat);
  80042109ee:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042109f2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042109f6:	48 89 d6             	mov    %rdx,%rsi
  80042109f9:	bf 78 00 00 00       	mov    $0x78,%edi
  80042109fe:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  8004210a00:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8004210a03:	83 f8 30             	cmp    $0x30,%eax
  8004210a06:	73 17                	jae    8004210a1f <vprintfmt+0x44b>
  8004210a08:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210a0c:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8004210a0f:	89 d2                	mov    %edx,%edx
  8004210a11:	48 01 d0             	add    %rdx,%rax
  8004210a14:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8004210a17:	83 c2 08             	add    $0x8,%edx
  8004210a1a:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  8004210a1d:	eb 0c                	jmp    8004210a2b <vprintfmt+0x457>
				(uintptr_t) va_arg(aq, void *);
  8004210a1f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210a23:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004210a27:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8004210a2b:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  8004210a2e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  8004210a32:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  8004210a39:	eb 23                	jmp    8004210a5e <vprintfmt+0x48a>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  8004210a3b:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8004210a3f:	be 03 00 00 00       	mov    $0x3,%esi
  8004210a44:	48 89 c7             	mov    %rax,%rdi
  8004210a47:	48 b8 c6 03 21 04 80 	movabs $0x80042103c6,%rax
  8004210a4e:	00 00 00 
  8004210a51:	ff d0                	callq  *%rax
  8004210a53:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  8004210a57:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  8004210a5e:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  8004210a63:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004210a66:	8b 7d dc             	mov    -0x24(%rbp),%edi
  8004210a69:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210a6d:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  8004210a71:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210a75:	45 89 c1             	mov    %r8d,%r9d
  8004210a78:	41 89 f8             	mov    %edi,%r8d
  8004210a7b:	48 89 c7             	mov    %rax,%rdi
  8004210a7e:	48 b8 0e 03 21 04 80 	movabs $0x800421030e,%rax
  8004210a85:	00 00 00 
  8004210a88:	ff d0                	callq  *%rax
			break;
  8004210a8a:	eb 3f                	jmp    8004210acb <vprintfmt+0x4f7>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  8004210a8c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004210a90:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210a94:	48 89 d6             	mov    %rdx,%rsi
  8004210a97:	89 df                	mov    %ebx,%edi
  8004210a99:	ff d0                	callq  *%rax
			break;
  8004210a9b:	eb 2e                	jmp    8004210acb <vprintfmt+0x4f7>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  8004210a9d:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004210aa1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210aa5:	48 89 d6             	mov    %rdx,%rsi
  8004210aa8:	bf 25 00 00 00       	mov    $0x25,%edi
  8004210aad:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  8004210aaf:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  8004210ab4:	eb 05                	jmp    8004210abb <vprintfmt+0x4e7>
  8004210ab6:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  8004210abb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004210abf:	48 83 e8 01          	sub    $0x1,%rax
  8004210ac3:	0f b6 00             	movzbl (%rax),%eax
  8004210ac6:	3c 25                	cmp    $0x25,%al
  8004210ac8:	75 ec                	jne    8004210ab6 <vprintfmt+0x4e2>
				/* do nothing */;
			break;
  8004210aca:	90                   	nop
		}
	}
  8004210acb:	e9 3d fb ff ff       	jmpq   800421060d <vprintfmt+0x39>
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
  8004210ad0:	90                   	nop
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  8004210ad1:	48 83 c4 60          	add    $0x60,%rsp
  8004210ad5:	5b                   	pop    %rbx
  8004210ad6:	41 5c                	pop    %r12
  8004210ad8:	5d                   	pop    %rbp
  8004210ad9:	c3                   	retq   

0000008004210ada <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  8004210ada:	55                   	push   %rbp
  8004210adb:	48 89 e5             	mov    %rsp,%rbp
  8004210ade:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  8004210ae5:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  8004210aec:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  8004210af3:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
  8004210afa:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004210b01:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004210b08:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004210b0f:	84 c0                	test   %al,%al
  8004210b11:	74 20                	je     8004210b33 <printfmt+0x59>
  8004210b13:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004210b17:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004210b1b:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004210b1f:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004210b23:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004210b27:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004210b2b:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004210b2f:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;

	va_start(ap, fmt);
  8004210b33:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  8004210b3a:	00 00 00 
  8004210b3d:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  8004210b44:	00 00 00 
  8004210b47:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004210b4b:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004210b52:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004210b59:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  8004210b60:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  8004210b67:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  8004210b6e:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  8004210b75:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004210b7c:	48 89 c7             	mov    %rax,%rdi
  8004210b7f:	48 b8 d4 05 21 04 80 	movabs $0x80042105d4,%rax
  8004210b86:	00 00 00 
  8004210b89:	ff d0                	callq  *%rax
	va_end(ap);
}
  8004210b8b:	90                   	nop
  8004210b8c:	c9                   	leaveq 
  8004210b8d:	c3                   	retq   

0000008004210b8e <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  8004210b8e:	55                   	push   %rbp
  8004210b8f:	48 89 e5             	mov    %rsp,%rbp
  8004210b92:	48 83 ec 10          	sub    $0x10,%rsp
  8004210b96:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004210b99:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  8004210b9d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210ba1:	8b 40 10             	mov    0x10(%rax),%eax
  8004210ba4:	8d 50 01             	lea    0x1(%rax),%edx
  8004210ba7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210bab:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  8004210bae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210bb2:	48 8b 10             	mov    (%rax),%rdx
  8004210bb5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210bb9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210bbd:	48 39 c2             	cmp    %rax,%rdx
  8004210bc0:	73 17                	jae    8004210bd9 <sprintputch+0x4b>
		*b->buf++ = ch;
  8004210bc2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210bc6:	48 8b 00             	mov    (%rax),%rax
  8004210bc9:	48 8d 48 01          	lea    0x1(%rax),%rcx
  8004210bcd:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210bd1:	48 89 0a             	mov    %rcx,(%rdx)
  8004210bd4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004210bd7:	88 10                	mov    %dl,(%rax)
}
  8004210bd9:	90                   	nop
  8004210bda:	c9                   	leaveq 
  8004210bdb:	c3                   	retq   

0000008004210bdc <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  8004210bdc:	55                   	push   %rbp
  8004210bdd:	48 89 e5             	mov    %rsp,%rbp
  8004210be0:	48 83 ec 50          	sub    $0x50,%rsp
  8004210be4:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004210be8:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  8004210beb:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004210bef:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004210bf3:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  8004210bf7:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210bfb:	48 8b 0a             	mov    (%rdx),%rcx
  8004210bfe:	48 89 08             	mov    %rcx,(%rax)
  8004210c01:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004210c05:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004210c09:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004210c0d:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  8004210c11:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210c15:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004210c19:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004210c1c:	48 98                	cltq   
  8004210c1e:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  8004210c22:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210c26:	48 01 d0             	add    %rdx,%rax
  8004210c29:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004210c2d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  8004210c34:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210c39:	74 06                	je     8004210c41 <vsnprintf+0x65>
  8004210c3b:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004210c3f:	7f 07                	jg     8004210c48 <vsnprintf+0x6c>
		return -E_INVAL;
  8004210c41:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8004210c46:	eb 2f                	jmp    8004210c77 <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  8004210c48:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  8004210c4c:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004210c50:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8004210c54:	48 89 c6             	mov    %rax,%rsi
  8004210c57:	48 bf 8e 0b 21 04 80 	movabs $0x8004210b8e,%rdi
  8004210c5e:	00 00 00 
  8004210c61:	48 b8 d4 05 21 04 80 	movabs $0x80042105d4,%rax
  8004210c68:	00 00 00 
  8004210c6b:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  8004210c6d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210c71:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  8004210c74:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  8004210c77:	c9                   	leaveq 
  8004210c78:	c3                   	retq   

0000008004210c79 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  8004210c79:	55                   	push   %rbp
  8004210c7a:	48 89 e5             	mov    %rsp,%rbp
  8004210c7d:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  8004210c84:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  8004210c8b:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  8004210c91:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
  8004210c98:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004210c9f:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004210ca6:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004210cad:	84 c0                	test   %al,%al
  8004210caf:	74 20                	je     8004210cd1 <snprintf+0x58>
  8004210cb1:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004210cb5:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004210cb9:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004210cbd:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004210cc1:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004210cc5:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004210cc9:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004210ccd:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  8004210cd1:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  8004210cd8:	00 00 00 
  8004210cdb:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  8004210ce2:	00 00 00 
  8004210ce5:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004210ce9:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004210cf0:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004210cf7:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  8004210cfe:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  8004210d05:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8004210d0c:	48 8b 0a             	mov    (%rdx),%rcx
  8004210d0f:	48 89 08             	mov    %rcx,(%rax)
  8004210d12:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004210d16:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004210d1a:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004210d1e:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  8004210d22:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  8004210d29:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004210d30:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  8004210d36:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004210d3d:	48 89 c7             	mov    %rax,%rdi
  8004210d40:	48 b8 dc 0b 21 04 80 	movabs $0x8004210bdc,%rax
  8004210d47:	00 00 00 
  8004210d4a:	ff d0                	callq  *%rax
  8004210d4c:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  8004210d52:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8004210d58:	c9                   	leaveq 
  8004210d59:	c3                   	retq   

0000008004210d5a <readline>:
#define BUFLEN 1024
static char buf[BUFLEN];

char *
readline(const char *prompt)
{
  8004210d5a:	55                   	push   %rbp
  8004210d5b:	48 89 e5             	mov    %rsp,%rbp
  8004210d5e:	48 83 ec 20          	sub    $0x20,%rsp
  8004210d62:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, c, echoing;


#if JOS_KERNEL
	if (prompt != NULL)
  8004210d66:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210d6b:	74 22                	je     8004210d8f <readline+0x35>
		cprintf("%s", prompt);
  8004210d6d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210d71:	48 89 c6             	mov    %rax,%rsi
  8004210d74:	48 bf 08 15 22 04 80 	movabs $0x8004221508,%rdi
  8004210d7b:	00 00 00 
  8004210d7e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210d83:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004210d8a:	00 00 00 
  8004210d8d:	ff d2                	callq  *%rdx
	if (prompt != NULL)
		fprintf(1, "%s", prompt);
#endif


	i = 0;
  8004210d8f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	echoing = iscons(0);
  8004210d96:	bf 00 00 00 00       	mov    $0x0,%edi
  8004210d9b:	48 b8 50 12 20 04 80 	movabs $0x8004201250,%rax
  8004210da2:	00 00 00 
  8004210da5:	ff d0                	callq  *%rax
  8004210da7:	89 45 f8             	mov    %eax,-0x8(%rbp)
	while (1) {
		c = getchar();
  8004210daa:	48 b8 2e 12 20 04 80 	movabs $0x800420122e,%rax
  8004210db1:	00 00 00 
  8004210db4:	ff d0                	callq  *%rax
  8004210db6:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (c < 0) {
  8004210db9:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004210dbd:	79 30                	jns    8004210def <readline+0x95>

			if (c != -E_EOF)
  8004210dbf:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%rbp)
  8004210dc3:	74 20                	je     8004210de5 <readline+0x8b>
				cprintf("read error: %e\n", c);
  8004210dc5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210dc8:	89 c6                	mov    %eax,%esi
  8004210dca:	48 bf 0b 15 22 04 80 	movabs $0x800422150b,%rdi
  8004210dd1:	00 00 00 
  8004210dd4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210dd9:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004210de0:	00 00 00 
  8004210de3:	ff d2                	callq  *%rdx

			return NULL;
  8004210de5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210dea:	e9 c2 00 00 00       	jmpq   8004210eb1 <readline+0x157>
		} else if ((c == '\b' || c == '\x7f') && i > 0) {
  8004210def:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  8004210df3:	74 06                	je     8004210dfb <readline+0xa1>
  8004210df5:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  8004210df9:	75 26                	jne    8004210e21 <readline+0xc7>
  8004210dfb:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004210dff:	7e 20                	jle    8004210e21 <readline+0xc7>
			if (echoing)
  8004210e01:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004210e05:	74 11                	je     8004210e18 <readline+0xbe>
				cputchar('\b');
  8004210e07:	bf 08 00 00 00       	mov    $0x8,%edi
  8004210e0c:	48 b8 0f 12 20 04 80 	movabs $0x800420120f,%rax
  8004210e13:	00 00 00 
  8004210e16:	ff d0                	callq  *%rax
			i--;
  8004210e18:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  8004210e1c:	e9 8b 00 00 00       	jmpq   8004210eac <readline+0x152>
		} else if (c >= ' ' && i < BUFLEN-1) {
  8004210e21:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  8004210e25:	7e 3f                	jle    8004210e66 <readline+0x10c>
  8004210e27:	81 7d fc fe 03 00 00 	cmpl   $0x3fe,-0x4(%rbp)
  8004210e2e:	7f 36                	jg     8004210e66 <readline+0x10c>
			if (echoing)
  8004210e30:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004210e34:	74 11                	je     8004210e47 <readline+0xed>
				cputchar(c);
  8004210e36:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210e39:	89 c7                	mov    %eax,%edi
  8004210e3b:	48 b8 0f 12 20 04 80 	movabs $0x800420120f,%rax
  8004210e42:	00 00 00 
  8004210e45:	ff d0                	callq  *%rax
			buf[i++] = c;
  8004210e47:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004210e4a:	8d 50 01             	lea    0x1(%rax),%edx
  8004210e4d:	89 55 fc             	mov    %edx,-0x4(%rbp)
  8004210e50:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004210e53:	89 d1                	mov    %edx,%ecx
  8004210e55:	48 ba a0 12 4e 04 80 	movabs $0x80044e12a0,%rdx
  8004210e5c:	00 00 00 
  8004210e5f:	48 98                	cltq   
  8004210e61:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  8004210e64:	eb 46                	jmp    8004210eac <readline+0x152>
		} else if (c == '\n' || c == '\r') {
  8004210e66:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  8004210e6a:	74 0a                	je     8004210e76 <readline+0x11c>
  8004210e6c:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  8004210e70:	0f 85 34 ff ff ff    	jne    8004210daa <readline+0x50>
			if (echoing)
  8004210e76:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004210e7a:	74 11                	je     8004210e8d <readline+0x133>
				cputchar('\n');
  8004210e7c:	bf 0a 00 00 00       	mov    $0xa,%edi
  8004210e81:	48 b8 0f 12 20 04 80 	movabs $0x800420120f,%rax
  8004210e88:	00 00 00 
  8004210e8b:	ff d0                	callq  *%rax
			buf[i] = 0;
  8004210e8d:	48 ba a0 12 4e 04 80 	movabs $0x80044e12a0,%rdx
  8004210e94:	00 00 00 
  8004210e97:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004210e9a:	48 98                	cltq   
  8004210e9c:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
			return buf;
  8004210ea0:	48 b8 a0 12 4e 04 80 	movabs $0x80044e12a0,%rax
  8004210ea7:	00 00 00 
  8004210eaa:	eb 05                	jmp    8004210eb1 <readline+0x157>
		}
	}
  8004210eac:	e9 f9 fe ff ff       	jmpq   8004210daa <readline+0x50>
}
  8004210eb1:	c9                   	leaveq 
  8004210eb2:	c3                   	retq   

0000008004210eb3 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  8004210eb3:	55                   	push   %rbp
  8004210eb4:	48 89 e5             	mov    %rsp,%rbp
  8004210eb7:	48 83 ec 18          	sub    $0x18,%rsp
  8004210ebb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  8004210ebf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004210ec6:	eb 09                	jmp    8004210ed1 <strlen+0x1e>
		n++;
  8004210ec8:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  8004210ecc:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004210ed1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210ed5:	0f b6 00             	movzbl (%rax),%eax
  8004210ed8:	84 c0                	test   %al,%al
  8004210eda:	75 ec                	jne    8004210ec8 <strlen+0x15>
		n++;
	return n;
  8004210edc:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004210edf:	c9                   	leaveq 
  8004210ee0:	c3                   	retq   

0000008004210ee1 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  8004210ee1:	55                   	push   %rbp
  8004210ee2:	48 89 e5             	mov    %rsp,%rbp
  8004210ee5:	48 83 ec 20          	sub    $0x20,%rsp
  8004210ee9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210eed:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  8004210ef1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004210ef8:	eb 0e                	jmp    8004210f08 <strnlen+0x27>
		n++;
  8004210efa:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  8004210efe:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004210f03:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  8004210f08:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004210f0d:	74 0b                	je     8004210f1a <strnlen+0x39>
  8004210f0f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210f13:	0f b6 00             	movzbl (%rax),%eax
  8004210f16:	84 c0                	test   %al,%al
  8004210f18:	75 e0                	jne    8004210efa <strnlen+0x19>
		n++;
	return n;
  8004210f1a:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004210f1d:	c9                   	leaveq 
  8004210f1e:	c3                   	retq   

0000008004210f1f <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  8004210f1f:	55                   	push   %rbp
  8004210f20:	48 89 e5             	mov    %rsp,%rbp
  8004210f23:	48 83 ec 20          	sub    $0x20,%rsp
  8004210f27:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210f2b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  8004210f2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210f33:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  8004210f37:	90                   	nop
  8004210f38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210f3c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210f40:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210f44:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210f48:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  8004210f4c:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  8004210f50:	0f b6 12             	movzbl (%rdx),%edx
  8004210f53:	88 10                	mov    %dl,(%rax)
  8004210f55:	0f b6 00             	movzbl (%rax),%eax
  8004210f58:	84 c0                	test   %al,%al
  8004210f5a:	75 dc                	jne    8004210f38 <strcpy+0x19>
		/* do nothing */;
	return ret;
  8004210f5c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210f60:	c9                   	leaveq 
  8004210f61:	c3                   	retq   

0000008004210f62 <strcat>:

char *
strcat(char *dst, const char *src)
{
  8004210f62:	55                   	push   %rbp
  8004210f63:	48 89 e5             	mov    %rsp,%rbp
  8004210f66:	48 83 ec 20          	sub    $0x20,%rsp
  8004210f6a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210f6e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  8004210f72:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210f76:	48 89 c7             	mov    %rax,%rdi
  8004210f79:	48 b8 b3 0e 21 04 80 	movabs $0x8004210eb3,%rax
  8004210f80:	00 00 00 
  8004210f83:	ff d0                	callq  *%rax
  8004210f85:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  8004210f88:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004210f8b:	48 63 d0             	movslq %eax,%rdx
  8004210f8e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210f92:	48 01 c2             	add    %rax,%rdx
  8004210f95:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210f99:	48 89 c6             	mov    %rax,%rsi
  8004210f9c:	48 89 d7             	mov    %rdx,%rdi
  8004210f9f:	48 b8 1f 0f 21 04 80 	movabs $0x8004210f1f,%rax
  8004210fa6:	00 00 00 
  8004210fa9:	ff d0                	callq  *%rax
	return dst;
  8004210fab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004210faf:	c9                   	leaveq 
  8004210fb0:	c3                   	retq   

0000008004210fb1 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  8004210fb1:	55                   	push   %rbp
  8004210fb2:	48 89 e5             	mov    %rsp,%rbp
  8004210fb5:	48 83 ec 28          	sub    $0x28,%rsp
  8004210fb9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210fbd:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210fc1:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  8004210fc5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210fc9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  8004210fcd:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210fd4:	00 
  8004210fd5:	eb 2a                	jmp    8004211001 <strncpy+0x50>
		*dst++ = *src;
  8004210fd7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210fdb:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210fdf:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210fe3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210fe7:	0f b6 12             	movzbl (%rdx),%edx
  8004210fea:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  8004210fec:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210ff0:	0f b6 00             	movzbl (%rax),%eax
  8004210ff3:	84 c0                	test   %al,%al
  8004210ff5:	74 05                	je     8004210ffc <strncpy+0x4b>
			src++;
  8004210ff7:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  8004210ffc:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004211001:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211005:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004211009:	72 cc                	jb     8004210fd7 <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  800421100b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800421100f:	c9                   	leaveq 
  8004211010:	c3                   	retq   

0000008004211011 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  8004211011:	55                   	push   %rbp
  8004211012:	48 89 e5             	mov    %rsp,%rbp
  8004211015:	48 83 ec 28          	sub    $0x28,%rsp
  8004211019:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421101d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211021:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  8004211025:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211029:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  800421102d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211032:	74 3d                	je     8004211071 <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  8004211034:	eb 1d                	jmp    8004211053 <strlcpy+0x42>
			*dst++ = *src++;
  8004211036:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421103a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421103e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004211042:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004211046:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800421104a:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800421104e:	0f b6 12             	movzbl (%rdx),%edx
  8004211051:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  8004211053:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  8004211058:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421105d:	74 0b                	je     800421106a <strlcpy+0x59>
  800421105f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211063:	0f b6 00             	movzbl (%rax),%eax
  8004211066:	84 c0                	test   %al,%al
  8004211068:	75 cc                	jne    8004211036 <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  800421106a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421106e:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  8004211071:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211075:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211079:	48 29 c2             	sub    %rax,%rdx
  800421107c:	48 89 d0             	mov    %rdx,%rax
}
  800421107f:	c9                   	leaveq 
  8004211080:	c3                   	retq   

0000008004211081 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  8004211081:	55                   	push   %rbp
  8004211082:	48 89 e5             	mov    %rsp,%rbp
  8004211085:	48 83 ec 10          	sub    $0x10,%rsp
  8004211089:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800421108d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  8004211091:	eb 0a                	jmp    800421109d <strcmp+0x1c>
		p++, q++;
  8004211093:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004211098:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  800421109d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042110a1:	0f b6 00             	movzbl (%rax),%eax
  80042110a4:	84 c0                	test   %al,%al
  80042110a6:	74 12                	je     80042110ba <strcmp+0x39>
  80042110a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042110ac:	0f b6 10             	movzbl (%rax),%edx
  80042110af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042110b3:	0f b6 00             	movzbl (%rax),%eax
  80042110b6:	38 c2                	cmp    %al,%dl
  80042110b8:	74 d9                	je     8004211093 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80042110ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042110be:	0f b6 00             	movzbl (%rax),%eax
  80042110c1:	0f b6 d0             	movzbl %al,%edx
  80042110c4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042110c8:	0f b6 00             	movzbl (%rax),%eax
  80042110cb:	0f b6 c0             	movzbl %al,%eax
  80042110ce:	29 c2                	sub    %eax,%edx
  80042110d0:	89 d0                	mov    %edx,%eax
}
  80042110d2:	c9                   	leaveq 
  80042110d3:	c3                   	retq   

00000080042110d4 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80042110d4:	55                   	push   %rbp
  80042110d5:	48 89 e5             	mov    %rsp,%rbp
  80042110d8:	48 83 ec 18          	sub    $0x18,%rsp
  80042110dc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80042110e0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80042110e4:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  80042110e8:	eb 0f                	jmp    80042110f9 <strncmp+0x25>
		n--, p++, q++;
  80042110ea:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  80042110ef:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80042110f4:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  80042110f9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042110fe:	74 1d                	je     800421111d <strncmp+0x49>
  8004211100:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211104:	0f b6 00             	movzbl (%rax),%eax
  8004211107:	84 c0                	test   %al,%al
  8004211109:	74 12                	je     800421111d <strncmp+0x49>
  800421110b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421110f:	0f b6 10             	movzbl (%rax),%edx
  8004211112:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211116:	0f b6 00             	movzbl (%rax),%eax
  8004211119:	38 c2                	cmp    %al,%dl
  800421111b:	74 cd                	je     80042110ea <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  800421111d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004211122:	75 07                	jne    800421112b <strncmp+0x57>
		return 0;
  8004211124:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211129:	eb 18                	jmp    8004211143 <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  800421112b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421112f:	0f b6 00             	movzbl (%rax),%eax
  8004211132:	0f b6 d0             	movzbl %al,%edx
  8004211135:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211139:	0f b6 00             	movzbl (%rax),%eax
  800421113c:	0f b6 c0             	movzbl %al,%eax
  800421113f:	29 c2                	sub    %eax,%edx
  8004211141:	89 d0                	mov    %edx,%eax
}
  8004211143:	c9                   	leaveq 
  8004211144:	c3                   	retq   

0000008004211145 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  8004211145:	55                   	push   %rbp
  8004211146:	48 89 e5             	mov    %rsp,%rbp
  8004211149:	48 83 ec 10          	sub    $0x10,%rsp
  800421114d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004211151:	89 f0                	mov    %esi,%eax
  8004211153:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  8004211156:	eb 17                	jmp    800421116f <strchr+0x2a>
		if (*s == c)
  8004211158:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421115c:	0f b6 00             	movzbl (%rax),%eax
  800421115f:	3a 45 f4             	cmp    -0xc(%rbp),%al
  8004211162:	75 06                	jne    800421116a <strchr+0x25>
			return (char *) s;
  8004211164:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211168:	eb 15                	jmp    800421117f <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  800421116a:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800421116f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211173:	0f b6 00             	movzbl (%rax),%eax
  8004211176:	84 c0                	test   %al,%al
  8004211178:	75 de                	jne    8004211158 <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  800421117a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421117f:	c9                   	leaveq 
  8004211180:	c3                   	retq   

0000008004211181 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  8004211181:	55                   	push   %rbp
  8004211182:	48 89 e5             	mov    %rsp,%rbp
  8004211185:	48 83 ec 10          	sub    $0x10,%rsp
  8004211189:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800421118d:	89 f0                	mov    %esi,%eax
  800421118f:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  8004211192:	eb 11                	jmp    80042111a5 <strfind+0x24>
		if (*s == c)
  8004211194:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211198:	0f b6 00             	movzbl (%rax),%eax
  800421119b:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800421119e:	74 12                	je     80042111b2 <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  80042111a0:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80042111a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042111a9:	0f b6 00             	movzbl (%rax),%eax
  80042111ac:	84 c0                	test   %al,%al
  80042111ae:	75 e4                	jne    8004211194 <strfind+0x13>
  80042111b0:	eb 01                	jmp    80042111b3 <strfind+0x32>
		if (*s == c)
			break;
  80042111b2:	90                   	nop
	return (char *) s;
  80042111b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042111b7:	c9                   	leaveq 
  80042111b8:	c3                   	retq   

00000080042111b9 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80042111b9:	55                   	push   %rbp
  80042111ba:	48 89 e5             	mov    %rsp,%rbp
  80042111bd:	48 83 ec 18          	sub    $0x18,%rsp
  80042111c1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80042111c5:	89 75 f4             	mov    %esi,-0xc(%rbp)
  80042111c8:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  80042111cc:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042111d1:	75 06                	jne    80042111d9 <memset+0x20>
		return v;
  80042111d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042111d7:	eb 69                	jmp    8004211242 <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  80042111d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042111dd:	83 e0 03             	and    $0x3,%eax
  80042111e0:	48 85 c0             	test   %rax,%rax
  80042111e3:	75 48                	jne    800421122d <memset+0x74>
  80042111e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042111e9:	83 e0 03             	and    $0x3,%eax
  80042111ec:	48 85 c0             	test   %rax,%rax
  80042111ef:	75 3c                	jne    800421122d <memset+0x74>
		c &= 0xFF;
  80042111f1:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80042111f8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042111fb:	c1 e0 18             	shl    $0x18,%eax
  80042111fe:	89 c2                	mov    %eax,%edx
  8004211200:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211203:	c1 e0 10             	shl    $0x10,%eax
  8004211206:	09 c2                	or     %eax,%edx
  8004211208:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421120b:	c1 e0 08             	shl    $0x8,%eax
  800421120e:	09 d0                	or     %edx,%eax
  8004211210:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  8004211213:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211217:	48 c1 e8 02          	shr    $0x2,%rax
  800421121b:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  800421121e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211222:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211225:	48 89 d7             	mov    %rdx,%rdi
  8004211228:	fc                   	cld    
  8004211229:	f3 ab                	rep stos %eax,%es:(%rdi)
  800421122b:	eb 11                	jmp    800421123e <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  800421122d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211231:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211234:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211238:	48 89 d7             	mov    %rdx,%rdi
  800421123b:	fc                   	cld    
  800421123c:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  800421123e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004211242:	c9                   	leaveq 
  8004211243:	c3                   	retq   

0000008004211244 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  8004211244:	55                   	push   %rbp
  8004211245:	48 89 e5             	mov    %rsp,%rbp
  8004211248:	48 83 ec 28          	sub    $0x28,%rsp
  800421124c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211250:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211254:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  8004211258:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421125c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  8004211260:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211264:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  8004211268:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421126c:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004211270:	0f 83 88 00 00 00    	jae    80042112fe <memmove+0xba>
  8004211276:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421127a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421127e:	48 01 d0             	add    %rdx,%rax
  8004211281:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004211285:	76 77                	jbe    80042112fe <memmove+0xba>
		s += n;
  8004211287:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421128b:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  800421128f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211293:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  8004211297:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421129b:	83 e0 03             	and    $0x3,%eax
  800421129e:	48 85 c0             	test   %rax,%rax
  80042112a1:	75 3b                	jne    80042112de <memmove+0x9a>
  80042112a3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042112a7:	83 e0 03             	and    $0x3,%eax
  80042112aa:	48 85 c0             	test   %rax,%rax
  80042112ad:	75 2f                	jne    80042112de <memmove+0x9a>
  80042112af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042112b3:	83 e0 03             	and    $0x3,%eax
  80042112b6:	48 85 c0             	test   %rax,%rax
  80042112b9:	75 23                	jne    80042112de <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80042112bb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042112bf:	48 83 e8 04          	sub    $0x4,%rax
  80042112c3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042112c7:	48 83 ea 04          	sub    $0x4,%rdx
  80042112cb:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042112cf:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  80042112d3:	48 89 c7             	mov    %rax,%rdi
  80042112d6:	48 89 d6             	mov    %rdx,%rsi
  80042112d9:	fd                   	std    
  80042112da:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  80042112dc:	eb 1d                	jmp    80042112fb <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  80042112de:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042112e2:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  80042112e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042112ea:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  80042112ee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042112f2:	48 89 d7             	mov    %rdx,%rdi
  80042112f5:	48 89 c1             	mov    %rax,%rcx
  80042112f8:	fd                   	std    
  80042112f9:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80042112fb:	fc                   	cld    
  80042112fc:	eb 57                	jmp    8004211355 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  80042112fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211302:	83 e0 03             	and    $0x3,%eax
  8004211305:	48 85 c0             	test   %rax,%rax
  8004211308:	75 36                	jne    8004211340 <memmove+0xfc>
  800421130a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421130e:	83 e0 03             	and    $0x3,%eax
  8004211311:	48 85 c0             	test   %rax,%rax
  8004211314:	75 2a                	jne    8004211340 <memmove+0xfc>
  8004211316:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421131a:	83 e0 03             	and    $0x3,%eax
  800421131d:	48 85 c0             	test   %rax,%rax
  8004211320:	75 1e                	jne    8004211340 <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  8004211322:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211326:	48 c1 e8 02          	shr    $0x2,%rax
  800421132a:	48 89 c1             	mov    %rax,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  800421132d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211331:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211335:	48 89 c7             	mov    %rax,%rdi
  8004211338:	48 89 d6             	mov    %rdx,%rsi
  800421133b:	fc                   	cld    
  800421133c:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800421133e:	eb 15                	jmp    8004211355 <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  8004211340:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211344:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211348:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421134c:	48 89 c7             	mov    %rax,%rdi
  800421134f:	48 89 d6             	mov    %rdx,%rsi
  8004211352:	fc                   	cld    
  8004211353:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  8004211355:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004211359:	c9                   	leaveq 
  800421135a:	c3                   	retq   

000000800421135b <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  800421135b:	55                   	push   %rbp
  800421135c:	48 89 e5             	mov    %rsp,%rbp
  800421135f:	48 83 ec 18          	sub    $0x18,%rsp
  8004211363:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004211367:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800421136b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  800421136f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211373:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8004211377:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421137b:	48 89 ce             	mov    %rcx,%rsi
  800421137e:	48 89 c7             	mov    %rax,%rdi
  8004211381:	48 b8 44 12 21 04 80 	movabs $0x8004211244,%rax
  8004211388:	00 00 00 
  800421138b:	ff d0                	callq  *%rax
}
  800421138d:	c9                   	leaveq 
  800421138e:	c3                   	retq   

000000800421138f <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  800421138f:	55                   	push   %rbp
  8004211390:	48 89 e5             	mov    %rsp,%rbp
  8004211393:	48 83 ec 28          	sub    $0x28,%rsp
  8004211397:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421139b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421139f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  80042113a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042113a7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  80042113ab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042113af:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  80042113b3:	eb 36                	jmp    80042113eb <memcmp+0x5c>
		if (*s1 != *s2)
  80042113b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042113b9:	0f b6 10             	movzbl (%rax),%edx
  80042113bc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042113c0:	0f b6 00             	movzbl (%rax),%eax
  80042113c3:	38 c2                	cmp    %al,%dl
  80042113c5:	74 1a                	je     80042113e1 <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  80042113c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042113cb:	0f b6 00             	movzbl (%rax),%eax
  80042113ce:	0f b6 d0             	movzbl %al,%edx
  80042113d1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042113d5:	0f b6 00             	movzbl (%rax),%eax
  80042113d8:	0f b6 c0             	movzbl %al,%eax
  80042113db:	29 c2                	sub    %eax,%edx
  80042113dd:	89 d0                	mov    %edx,%eax
  80042113df:	eb 20                	jmp    8004211401 <memcmp+0x72>
		s1++, s2++;
  80042113e1:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80042113e6:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80042113eb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042113ef:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  80042113f3:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80042113f7:	48 85 c0             	test   %rax,%rax
  80042113fa:	75 b9                	jne    80042113b5 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  80042113fc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211401:	c9                   	leaveq 
  8004211402:	c3                   	retq   

0000008004211403 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  8004211403:	55                   	push   %rbp
  8004211404:	48 89 e5             	mov    %rsp,%rbp
  8004211407:	48 83 ec 28          	sub    $0x28,%rsp
  800421140b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421140f:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  8004211412:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  8004211416:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421141a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421141e:	48 01 d0             	add    %rdx,%rax
  8004211421:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  8004211425:	eb 19                	jmp    8004211440 <memfind+0x3d>
		if (*(const unsigned char *) s == (unsigned char) c)
  8004211427:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421142b:	0f b6 00             	movzbl (%rax),%eax
  800421142e:	0f b6 d0             	movzbl %al,%edx
  8004211431:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004211434:	0f b6 c0             	movzbl %al,%eax
  8004211437:	39 c2                	cmp    %eax,%edx
  8004211439:	74 11                	je     800421144c <memfind+0x49>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  800421143b:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004211440:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211444:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004211448:	72 dd                	jb     8004211427 <memfind+0x24>
  800421144a:	eb 01                	jmp    800421144d <memfind+0x4a>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
  800421144c:	90                   	nop
	return (void *) s;
  800421144d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004211451:	c9                   	leaveq 
  8004211452:	c3                   	retq   

0000008004211453 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  8004211453:	55                   	push   %rbp
  8004211454:	48 89 e5             	mov    %rsp,%rbp
  8004211457:	48 83 ec 38          	sub    $0x38,%rsp
  800421145b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421145f:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004211463:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  8004211466:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  800421146d:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004211474:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  8004211475:	eb 05                	jmp    800421147c <strtol+0x29>
		s++;
  8004211477:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800421147c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211480:	0f b6 00             	movzbl (%rax),%eax
  8004211483:	3c 20                	cmp    $0x20,%al
  8004211485:	74 f0                	je     8004211477 <strtol+0x24>
  8004211487:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421148b:	0f b6 00             	movzbl (%rax),%eax
  800421148e:	3c 09                	cmp    $0x9,%al
  8004211490:	74 e5                	je     8004211477 <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  8004211492:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211496:	0f b6 00             	movzbl (%rax),%eax
  8004211499:	3c 2b                	cmp    $0x2b,%al
  800421149b:	75 07                	jne    80042114a4 <strtol+0x51>
		s++;
  800421149d:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  80042114a2:	eb 17                	jmp    80042114bb <strtol+0x68>
	else if (*s == '-')
  80042114a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042114a8:	0f b6 00             	movzbl (%rax),%eax
  80042114ab:	3c 2d                	cmp    $0x2d,%al
  80042114ad:	75 0c                	jne    80042114bb <strtol+0x68>
		s++, neg = 1;
  80042114af:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  80042114b4:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80042114bb:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80042114bf:	74 06                	je     80042114c7 <strtol+0x74>
  80042114c1:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  80042114c5:	75 28                	jne    80042114ef <strtol+0x9c>
  80042114c7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042114cb:	0f b6 00             	movzbl (%rax),%eax
  80042114ce:	3c 30                	cmp    $0x30,%al
  80042114d0:	75 1d                	jne    80042114ef <strtol+0x9c>
  80042114d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042114d6:	48 83 c0 01          	add    $0x1,%rax
  80042114da:	0f b6 00             	movzbl (%rax),%eax
  80042114dd:	3c 78                	cmp    $0x78,%al
  80042114df:	75 0e                	jne    80042114ef <strtol+0x9c>
		s += 2, base = 16;
  80042114e1:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  80042114e6:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  80042114ed:	eb 2c                	jmp    800421151b <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  80042114ef:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80042114f3:	75 19                	jne    800421150e <strtol+0xbb>
  80042114f5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042114f9:	0f b6 00             	movzbl (%rax),%eax
  80042114fc:	3c 30                	cmp    $0x30,%al
  80042114fe:	75 0e                	jne    800421150e <strtol+0xbb>
		s++, base = 8;
  8004211500:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8004211505:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  800421150c:	eb 0d                	jmp    800421151b <strtol+0xc8>
	else if (base == 0)
  800421150e:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004211512:	75 07                	jne    800421151b <strtol+0xc8>
		base = 10;
  8004211514:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  800421151b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421151f:	0f b6 00             	movzbl (%rax),%eax
  8004211522:	3c 2f                	cmp    $0x2f,%al
  8004211524:	7e 1d                	jle    8004211543 <strtol+0xf0>
  8004211526:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421152a:	0f b6 00             	movzbl (%rax),%eax
  800421152d:	3c 39                	cmp    $0x39,%al
  800421152f:	7f 12                	jg     8004211543 <strtol+0xf0>
			dig = *s - '0';
  8004211531:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211535:	0f b6 00             	movzbl (%rax),%eax
  8004211538:	0f be c0             	movsbl %al,%eax
  800421153b:	83 e8 30             	sub    $0x30,%eax
  800421153e:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004211541:	eb 4e                	jmp    8004211591 <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  8004211543:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211547:	0f b6 00             	movzbl (%rax),%eax
  800421154a:	3c 60                	cmp    $0x60,%al
  800421154c:	7e 1d                	jle    800421156b <strtol+0x118>
  800421154e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211552:	0f b6 00             	movzbl (%rax),%eax
  8004211555:	3c 7a                	cmp    $0x7a,%al
  8004211557:	7f 12                	jg     800421156b <strtol+0x118>
			dig = *s - 'a' + 10;
  8004211559:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421155d:	0f b6 00             	movzbl (%rax),%eax
  8004211560:	0f be c0             	movsbl %al,%eax
  8004211563:	83 e8 57             	sub    $0x57,%eax
  8004211566:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004211569:	eb 26                	jmp    8004211591 <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  800421156b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421156f:	0f b6 00             	movzbl (%rax),%eax
  8004211572:	3c 40                	cmp    $0x40,%al
  8004211574:	7e 47                	jle    80042115bd <strtol+0x16a>
  8004211576:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421157a:	0f b6 00             	movzbl (%rax),%eax
  800421157d:	3c 5a                	cmp    $0x5a,%al
  800421157f:	7f 3c                	jg     80042115bd <strtol+0x16a>
			dig = *s - 'A' + 10;
  8004211581:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211585:	0f b6 00             	movzbl (%rax),%eax
  8004211588:	0f be c0             	movsbl %al,%eax
  800421158b:	83 e8 37             	sub    $0x37,%eax
  800421158e:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  8004211591:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004211594:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  8004211597:	7d 23                	jge    80042115bc <strtol+0x169>
			break;
		s++, val = (val * base) + dig;
  8004211599:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800421159e:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80042115a1:	48 98                	cltq   
  80042115a3:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  80042115a8:	48 89 c2             	mov    %rax,%rdx
  80042115ab:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042115ae:	48 98                	cltq   
  80042115b0:	48 01 d0             	add    %rdx,%rax
  80042115b3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  80042115b7:	e9 5f ff ff ff       	jmpq   800421151b <strtol+0xc8>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
  80042115bc:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
  80042115bd:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042115c2:	74 0b                	je     80042115cf <strtol+0x17c>
		*endptr = (char *) s;
  80042115c4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042115c8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042115cc:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  80042115cf:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042115d3:	74 09                	je     80042115de <strtol+0x18b>
  80042115d5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042115d9:	48 f7 d8             	neg    %rax
  80042115dc:	eb 04                	jmp    80042115e2 <strtol+0x18f>
  80042115de:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80042115e2:	c9                   	leaveq 
  80042115e3:	c3                   	retq   

00000080042115e4 <strstr>:

char * strstr(const char *in, const char *str)
{
  80042115e4:	55                   	push   %rbp
  80042115e5:	48 89 e5             	mov    %rsp,%rbp
  80042115e8:	48 83 ec 30          	sub    $0x30,%rsp
  80042115ec:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042115f0:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  80042115f4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042115f8:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042115fc:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004211600:	0f b6 00             	movzbl (%rax),%eax
  8004211603:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  8004211606:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800421160a:	75 06                	jne    8004211612 <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  800421160c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211610:	eb 6b                	jmp    800421167d <strstr+0x99>

	len = strlen(str);
  8004211612:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211616:	48 89 c7             	mov    %rax,%rdi
  8004211619:	48 b8 b3 0e 21 04 80 	movabs $0x8004210eb3,%rax
  8004211620:	00 00 00 
  8004211623:	ff d0                	callq  *%rax
  8004211625:	48 98                	cltq   
  8004211627:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  800421162b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421162f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211633:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004211637:	0f b6 00             	movzbl (%rax),%eax
  800421163a:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  800421163d:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  8004211641:	75 07                	jne    800421164a <strstr+0x66>
				return (char *) 0;
  8004211643:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211648:	eb 33                	jmp    800421167d <strstr+0x99>
		} while (sc != c);
  800421164a:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800421164e:	3a 45 ff             	cmp    -0x1(%rbp),%al
  8004211651:	75 d8                	jne    800421162b <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  8004211653:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211657:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800421165b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421165f:	48 89 ce             	mov    %rcx,%rsi
  8004211662:	48 89 c7             	mov    %rax,%rdi
  8004211665:	48 b8 d4 10 21 04 80 	movabs $0x80042110d4,%rax
  800421166c:	00 00 00 
  800421166f:	ff d0                	callq  *%rax
  8004211671:	85 c0                	test   %eax,%eax
  8004211673:	75 b6                	jne    800421162b <strstr+0x47>

	return (char *) (in - 1);
  8004211675:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211679:	48 83 e8 01          	sub    $0x1,%rax
}
  800421167d:	c9                   	leaveq 
  800421167e:	c3                   	retq   

000000800421167f <_dwarf_read_lsb>:
Dwarf_Section *
_dwarf_find_section(const char *name);

uint64_t
_dwarf_read_lsb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800421167f:	55                   	push   %rbp
  8004211680:	48 89 e5             	mov    %rsp,%rbp
  8004211683:	48 83 ec 28          	sub    $0x28,%rsp
  8004211687:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421168b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421168f:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  8004211692:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211696:	48 8b 10             	mov    (%rax),%rdx
  8004211699:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421169d:	48 01 d0             	add    %rdx,%rax
  80042116a0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  80042116a4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042116ab:	00 
	switch (bytes_to_read) {
  80042116ac:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042116af:	83 f8 02             	cmp    $0x2,%eax
  80042116b2:	0f 84 ab 00 00 00    	je     8004211763 <_dwarf_read_lsb+0xe4>
  80042116b8:	83 f8 02             	cmp    $0x2,%eax
  80042116bb:	7f 0e                	jg     80042116cb <_dwarf_read_lsb+0x4c>
  80042116bd:	83 f8 01             	cmp    $0x1,%eax
  80042116c0:	0f 84 b3 00 00 00    	je     8004211779 <_dwarf_read_lsb+0xfa>
  80042116c6:	e9 d9 00 00 00       	jmpq   80042117a4 <_dwarf_read_lsb+0x125>
  80042116cb:	83 f8 04             	cmp    $0x4,%eax
  80042116ce:	74 65                	je     8004211735 <_dwarf_read_lsb+0xb6>
  80042116d0:	83 f8 08             	cmp    $0x8,%eax
  80042116d3:	0f 85 cb 00 00 00    	jne    80042117a4 <_dwarf_read_lsb+0x125>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  80042116d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042116dd:	48 83 c0 04          	add    $0x4,%rax
  80042116e1:	0f b6 00             	movzbl (%rax),%eax
  80042116e4:	0f b6 c0             	movzbl %al,%eax
  80042116e7:	48 c1 e0 20          	shl    $0x20,%rax
  80042116eb:	48 89 c2             	mov    %rax,%rdx
  80042116ee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042116f2:	48 83 c0 05          	add    $0x5,%rax
  80042116f6:	0f b6 00             	movzbl (%rax),%eax
  80042116f9:	0f b6 c0             	movzbl %al,%eax
  80042116fc:	48 c1 e0 28          	shl    $0x28,%rax
  8004211700:	48 09 d0             	or     %rdx,%rax
  8004211703:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  8004211707:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421170b:	48 83 c0 06          	add    $0x6,%rax
  800421170f:	0f b6 00             	movzbl (%rax),%eax
  8004211712:	0f b6 c0             	movzbl %al,%eax
  8004211715:	48 c1 e0 30          	shl    $0x30,%rax
  8004211719:	48 89 c2             	mov    %rax,%rdx
  800421171c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211720:	48 83 c0 07          	add    $0x7,%rax
  8004211724:	0f b6 00             	movzbl (%rax),%eax
  8004211727:	0f b6 c0             	movzbl %al,%eax
  800421172a:	48 c1 e0 38          	shl    $0x38,%rax
  800421172e:	48 09 d0             	or     %rdx,%rax
  8004211731:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  8004211735:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211739:	48 83 c0 02          	add    $0x2,%rax
  800421173d:	0f b6 00             	movzbl (%rax),%eax
  8004211740:	0f b6 c0             	movzbl %al,%eax
  8004211743:	48 c1 e0 10          	shl    $0x10,%rax
  8004211747:	48 89 c2             	mov    %rax,%rdx
  800421174a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421174e:	48 83 c0 03          	add    $0x3,%rax
  8004211752:	0f b6 00             	movzbl (%rax),%eax
  8004211755:	0f b6 c0             	movzbl %al,%eax
  8004211758:	48 c1 e0 18          	shl    $0x18,%rax
  800421175c:	48 09 d0             	or     %rdx,%rax
  800421175f:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  8004211763:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211767:	48 83 c0 01          	add    $0x1,%rax
  800421176b:	0f b6 00             	movzbl (%rax),%eax
  800421176e:	0f b6 c0             	movzbl %al,%eax
  8004211771:	48 c1 e0 08          	shl    $0x8,%rax
  8004211775:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  8004211779:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421177d:	0f b6 00             	movzbl (%rax),%eax
  8004211780:	0f b6 c0             	movzbl %al,%eax
  8004211783:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004211787:	90                   	nop
	default:
		return (0);
	}

	*offsetp += bytes_to_read;
  8004211788:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421178c:	48 8b 10             	mov    (%rax),%rdx
  800421178f:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004211792:	48 98                	cltq   
  8004211794:	48 01 c2             	add    %rax,%rdx
  8004211797:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421179b:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800421179e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042117a2:	eb 05                	jmp    80042117a9 <_dwarf_read_lsb+0x12a>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  80042117a4:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*offsetp += bytes_to_read;

	return (ret);
}
  80042117a9:	c9                   	leaveq 
  80042117aa:	c3                   	retq   

00000080042117ab <_dwarf_decode_lsb>:

uint64_t
_dwarf_decode_lsb(uint8_t **data, int bytes_to_read)
{
  80042117ab:	55                   	push   %rbp
  80042117ac:	48 89 e5             	mov    %rsp,%rbp
  80042117af:	48 83 ec 20          	sub    $0x20,%rsp
  80042117b3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042117b7:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  80042117ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042117be:	48 8b 00             	mov    (%rax),%rax
  80042117c1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  80042117c5:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042117cc:	00 
	switch (bytes_to_read) {
  80042117cd:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042117d0:	83 f8 02             	cmp    $0x2,%eax
  80042117d3:	0f 84 ab 00 00 00    	je     8004211884 <_dwarf_decode_lsb+0xd9>
  80042117d9:	83 f8 02             	cmp    $0x2,%eax
  80042117dc:	7f 0e                	jg     80042117ec <_dwarf_decode_lsb+0x41>
  80042117de:	83 f8 01             	cmp    $0x1,%eax
  80042117e1:	0f 84 b3 00 00 00    	je     800421189a <_dwarf_decode_lsb+0xef>
  80042117e7:	e9 d9 00 00 00       	jmpq   80042118c5 <_dwarf_decode_lsb+0x11a>
  80042117ec:	83 f8 04             	cmp    $0x4,%eax
  80042117ef:	74 65                	je     8004211856 <_dwarf_decode_lsb+0xab>
  80042117f1:	83 f8 08             	cmp    $0x8,%eax
  80042117f4:	0f 85 cb 00 00 00    	jne    80042118c5 <_dwarf_decode_lsb+0x11a>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  80042117fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042117fe:	48 83 c0 04          	add    $0x4,%rax
  8004211802:	0f b6 00             	movzbl (%rax),%eax
  8004211805:	0f b6 c0             	movzbl %al,%eax
  8004211808:	48 c1 e0 20          	shl    $0x20,%rax
  800421180c:	48 89 c2             	mov    %rax,%rdx
  800421180f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211813:	48 83 c0 05          	add    $0x5,%rax
  8004211817:	0f b6 00             	movzbl (%rax),%eax
  800421181a:	0f b6 c0             	movzbl %al,%eax
  800421181d:	48 c1 e0 28          	shl    $0x28,%rax
  8004211821:	48 09 d0             	or     %rdx,%rax
  8004211824:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  8004211828:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421182c:	48 83 c0 06          	add    $0x6,%rax
  8004211830:	0f b6 00             	movzbl (%rax),%eax
  8004211833:	0f b6 c0             	movzbl %al,%eax
  8004211836:	48 c1 e0 30          	shl    $0x30,%rax
  800421183a:	48 89 c2             	mov    %rax,%rdx
  800421183d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211841:	48 83 c0 07          	add    $0x7,%rax
  8004211845:	0f b6 00             	movzbl (%rax),%eax
  8004211848:	0f b6 c0             	movzbl %al,%eax
  800421184b:	48 c1 e0 38          	shl    $0x38,%rax
  800421184f:	48 09 d0             	or     %rdx,%rax
  8004211852:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  8004211856:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421185a:	48 83 c0 02          	add    $0x2,%rax
  800421185e:	0f b6 00             	movzbl (%rax),%eax
  8004211861:	0f b6 c0             	movzbl %al,%eax
  8004211864:	48 c1 e0 10          	shl    $0x10,%rax
  8004211868:	48 89 c2             	mov    %rax,%rdx
  800421186b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421186f:	48 83 c0 03          	add    $0x3,%rax
  8004211873:	0f b6 00             	movzbl (%rax),%eax
  8004211876:	0f b6 c0             	movzbl %al,%eax
  8004211879:	48 c1 e0 18          	shl    $0x18,%rax
  800421187d:	48 09 d0             	or     %rdx,%rax
  8004211880:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  8004211884:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211888:	48 83 c0 01          	add    $0x1,%rax
  800421188c:	0f b6 00             	movzbl (%rax),%eax
  800421188f:	0f b6 c0             	movzbl %al,%eax
  8004211892:	48 c1 e0 08          	shl    $0x8,%rax
  8004211896:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800421189a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421189e:	0f b6 00             	movzbl (%rax),%eax
  80042118a1:	0f b6 c0             	movzbl %al,%eax
  80042118a4:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  80042118a8:	90                   	nop
	default:
		return (0);
	}

	*data += bytes_to_read;
  80042118a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042118ad:	48 8b 10             	mov    (%rax),%rdx
  80042118b0:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042118b3:	48 98                	cltq   
  80042118b5:	48 01 c2             	add    %rax,%rdx
  80042118b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042118bc:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042118bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042118c3:	eb 05                	jmp    80042118ca <_dwarf_decode_lsb+0x11f>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  80042118c5:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*data += bytes_to_read;

	return (ret);
}
  80042118ca:	c9                   	leaveq 
  80042118cb:	c3                   	retq   

00000080042118cc <_dwarf_read_msb>:

uint64_t
_dwarf_read_msb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  80042118cc:	55                   	push   %rbp
  80042118cd:	48 89 e5             	mov    %rsp,%rbp
  80042118d0:	48 83 ec 28          	sub    $0x28,%rsp
  80042118d4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042118d8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042118dc:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  80042118df:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042118e3:	48 8b 10             	mov    (%rax),%rdx
  80042118e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042118ea:	48 01 d0             	add    %rdx,%rax
  80042118ed:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	switch (bytes_to_read) {
  80042118f1:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042118f4:	83 f8 02             	cmp    $0x2,%eax
  80042118f7:	74 35                	je     800421192e <_dwarf_read_msb+0x62>
  80042118f9:	83 f8 02             	cmp    $0x2,%eax
  80042118fc:	7f 0a                	jg     8004211908 <_dwarf_read_msb+0x3c>
  80042118fe:	83 f8 01             	cmp    $0x1,%eax
  8004211901:	74 18                	je     800421191b <_dwarf_read_msb+0x4f>
  8004211903:	e9 53 01 00 00       	jmpq   8004211a5b <_dwarf_read_msb+0x18f>
  8004211908:	83 f8 04             	cmp    $0x4,%eax
  800421190b:	74 49                	je     8004211956 <_dwarf_read_msb+0x8a>
  800421190d:	83 f8 08             	cmp    $0x8,%eax
  8004211910:	0f 84 96 00 00 00    	je     80042119ac <_dwarf_read_msb+0xe0>
  8004211916:	e9 40 01 00 00       	jmpq   8004211a5b <_dwarf_read_msb+0x18f>
	case 1:
		ret = src[0];
  800421191b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421191f:	0f b6 00             	movzbl (%rax),%eax
  8004211922:	0f b6 c0             	movzbl %al,%eax
  8004211925:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  8004211929:	e9 34 01 00 00       	jmpq   8004211a62 <_dwarf_read_msb+0x196>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800421192e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211932:	48 83 c0 01          	add    $0x1,%rax
  8004211936:	0f b6 00             	movzbl (%rax),%eax
  8004211939:	0f b6 d0             	movzbl %al,%edx
  800421193c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211940:	0f b6 00             	movzbl (%rax),%eax
  8004211943:	0f b6 c0             	movzbl %al,%eax
  8004211946:	48 c1 e0 08          	shl    $0x8,%rax
  800421194a:	48 09 d0             	or     %rdx,%rax
  800421194d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  8004211951:	e9 0c 01 00 00       	jmpq   8004211a62 <_dwarf_read_msb+0x196>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  8004211956:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421195a:	48 83 c0 03          	add    $0x3,%rax
  800421195e:	0f b6 00             	movzbl (%rax),%eax
  8004211961:	0f b6 c0             	movzbl %al,%eax
  8004211964:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211968:	48 83 c2 02          	add    $0x2,%rdx
  800421196c:	0f b6 12             	movzbl (%rdx),%edx
  800421196f:	0f b6 d2             	movzbl %dl,%edx
  8004211972:	48 c1 e2 08          	shl    $0x8,%rdx
  8004211976:	48 09 d0             	or     %rdx,%rax
  8004211979:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800421197d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211981:	48 83 c0 01          	add    $0x1,%rax
  8004211985:	0f b6 00             	movzbl (%rax),%eax
  8004211988:	0f b6 c0             	movzbl %al,%eax
  800421198b:	48 c1 e0 10          	shl    $0x10,%rax
  800421198f:	48 89 c2             	mov    %rax,%rdx
  8004211992:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211996:	0f b6 00             	movzbl (%rax),%eax
  8004211999:	0f b6 c0             	movzbl %al,%eax
  800421199c:	48 c1 e0 18          	shl    $0x18,%rax
  80042119a0:	48 09 d0             	or     %rdx,%rax
  80042119a3:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  80042119a7:	e9 b6 00 00 00       	jmpq   8004211a62 <_dwarf_read_msb+0x196>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  80042119ac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042119b0:	48 83 c0 07          	add    $0x7,%rax
  80042119b4:	0f b6 00             	movzbl (%rax),%eax
  80042119b7:	0f b6 c0             	movzbl %al,%eax
  80042119ba:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042119be:	48 83 c2 06          	add    $0x6,%rdx
  80042119c2:	0f b6 12             	movzbl (%rdx),%edx
  80042119c5:	0f b6 d2             	movzbl %dl,%edx
  80042119c8:	48 c1 e2 08          	shl    $0x8,%rdx
  80042119cc:	48 09 d0             	or     %rdx,%rax
  80042119cf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  80042119d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042119d7:	48 83 c0 05          	add    $0x5,%rax
  80042119db:	0f b6 00             	movzbl (%rax),%eax
  80042119de:	0f b6 c0             	movzbl %al,%eax
  80042119e1:	48 c1 e0 10          	shl    $0x10,%rax
  80042119e5:	48 89 c2             	mov    %rax,%rdx
  80042119e8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042119ec:	48 83 c0 04          	add    $0x4,%rax
  80042119f0:	0f b6 00             	movzbl (%rax),%eax
  80042119f3:	0f b6 c0             	movzbl %al,%eax
  80042119f6:	48 c1 e0 18          	shl    $0x18,%rax
  80042119fa:	48 09 d0             	or     %rdx,%rax
  80042119fd:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  8004211a01:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211a05:	48 83 c0 03          	add    $0x3,%rax
  8004211a09:	0f b6 00             	movzbl (%rax),%eax
  8004211a0c:	0f b6 c0             	movzbl %al,%eax
  8004211a0f:	48 c1 e0 20          	shl    $0x20,%rax
  8004211a13:	48 89 c2             	mov    %rax,%rdx
  8004211a16:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211a1a:	48 83 c0 02          	add    $0x2,%rax
  8004211a1e:	0f b6 00             	movzbl (%rax),%eax
  8004211a21:	0f b6 c0             	movzbl %al,%eax
  8004211a24:	48 c1 e0 28          	shl    $0x28,%rax
  8004211a28:	48 09 d0             	or     %rdx,%rax
  8004211a2b:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  8004211a2f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211a33:	48 83 c0 01          	add    $0x1,%rax
  8004211a37:	0f b6 00             	movzbl (%rax),%eax
  8004211a3a:	0f b6 c0             	movzbl %al,%eax
  8004211a3d:	48 c1 e0 30          	shl    $0x30,%rax
  8004211a41:	48 89 c2             	mov    %rax,%rdx
  8004211a44:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211a48:	0f b6 00             	movzbl (%rax),%eax
  8004211a4b:	0f b6 c0             	movzbl %al,%eax
  8004211a4e:	48 c1 e0 38          	shl    $0x38,%rax
  8004211a52:	48 09 d0             	or     %rdx,%rax
  8004211a55:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004211a59:	eb 07                	jmp    8004211a62 <_dwarf_read_msb+0x196>
	default:
		return (0);
  8004211a5b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211a60:	eb 1a                	jmp    8004211a7c <_dwarf_read_msb+0x1b0>
	}

	*offsetp += bytes_to_read;
  8004211a62:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211a66:	48 8b 10             	mov    (%rax),%rdx
  8004211a69:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004211a6c:	48 98                	cltq   
  8004211a6e:	48 01 c2             	add    %rax,%rdx
  8004211a71:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211a75:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004211a78:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004211a7c:	c9                   	leaveq 
  8004211a7d:	c3                   	retq   

0000008004211a7e <_dwarf_decode_msb>:

uint64_t
_dwarf_decode_msb(uint8_t **data, int bytes_to_read)
{
  8004211a7e:	55                   	push   %rbp
  8004211a7f:	48 89 e5             	mov    %rsp,%rbp
  8004211a82:	48 83 ec 20          	sub    $0x20,%rsp
  8004211a86:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211a8a:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  8004211a8d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a91:	48 8b 00             	mov    (%rax),%rax
  8004211a94:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  8004211a98:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004211a9f:	00 
	switch (bytes_to_read) {
  8004211aa0:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004211aa3:	83 f8 02             	cmp    $0x2,%eax
  8004211aa6:	74 35                	je     8004211add <_dwarf_decode_msb+0x5f>
  8004211aa8:	83 f8 02             	cmp    $0x2,%eax
  8004211aab:	7f 0a                	jg     8004211ab7 <_dwarf_decode_msb+0x39>
  8004211aad:	83 f8 01             	cmp    $0x1,%eax
  8004211ab0:	74 18                	je     8004211aca <_dwarf_decode_msb+0x4c>
  8004211ab2:	e9 53 01 00 00       	jmpq   8004211c0a <_dwarf_decode_msb+0x18c>
  8004211ab7:	83 f8 04             	cmp    $0x4,%eax
  8004211aba:	74 49                	je     8004211b05 <_dwarf_decode_msb+0x87>
  8004211abc:	83 f8 08             	cmp    $0x8,%eax
  8004211abf:	0f 84 96 00 00 00    	je     8004211b5b <_dwarf_decode_msb+0xdd>
  8004211ac5:	e9 40 01 00 00       	jmpq   8004211c0a <_dwarf_decode_msb+0x18c>
	case 1:
		ret = src[0];
  8004211aca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211ace:	0f b6 00             	movzbl (%rax),%eax
  8004211ad1:	0f b6 c0             	movzbl %al,%eax
  8004211ad4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  8004211ad8:	e9 34 01 00 00       	jmpq   8004211c11 <_dwarf_decode_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  8004211add:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211ae1:	48 83 c0 01          	add    $0x1,%rax
  8004211ae5:	0f b6 00             	movzbl (%rax),%eax
  8004211ae8:	0f b6 d0             	movzbl %al,%edx
  8004211aeb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211aef:	0f b6 00             	movzbl (%rax),%eax
  8004211af2:	0f b6 c0             	movzbl %al,%eax
  8004211af5:	48 c1 e0 08          	shl    $0x8,%rax
  8004211af9:	48 09 d0             	or     %rdx,%rax
  8004211afc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  8004211b00:	e9 0c 01 00 00       	jmpq   8004211c11 <_dwarf_decode_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  8004211b05:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211b09:	48 83 c0 03          	add    $0x3,%rax
  8004211b0d:	0f b6 00             	movzbl (%rax),%eax
  8004211b10:	0f b6 c0             	movzbl %al,%eax
  8004211b13:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211b17:	48 83 c2 02          	add    $0x2,%rdx
  8004211b1b:	0f b6 12             	movzbl (%rdx),%edx
  8004211b1e:	0f b6 d2             	movzbl %dl,%edx
  8004211b21:	48 c1 e2 08          	shl    $0x8,%rdx
  8004211b25:	48 09 d0             	or     %rdx,%rax
  8004211b28:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  8004211b2c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211b30:	48 83 c0 01          	add    $0x1,%rax
  8004211b34:	0f b6 00             	movzbl (%rax),%eax
  8004211b37:	0f b6 c0             	movzbl %al,%eax
  8004211b3a:	48 c1 e0 10          	shl    $0x10,%rax
  8004211b3e:	48 89 c2             	mov    %rax,%rdx
  8004211b41:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211b45:	0f b6 00             	movzbl (%rax),%eax
  8004211b48:	0f b6 c0             	movzbl %al,%eax
  8004211b4b:	48 c1 e0 18          	shl    $0x18,%rax
  8004211b4f:	48 09 d0             	or     %rdx,%rax
  8004211b52:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004211b56:	e9 b6 00 00 00       	jmpq   8004211c11 <_dwarf_decode_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  8004211b5b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211b5f:	48 83 c0 07          	add    $0x7,%rax
  8004211b63:	0f b6 00             	movzbl (%rax),%eax
  8004211b66:	0f b6 c0             	movzbl %al,%eax
  8004211b69:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211b6d:	48 83 c2 06          	add    $0x6,%rdx
  8004211b71:	0f b6 12             	movzbl (%rdx),%edx
  8004211b74:	0f b6 d2             	movzbl %dl,%edx
  8004211b77:	48 c1 e2 08          	shl    $0x8,%rdx
  8004211b7b:	48 09 d0             	or     %rdx,%rax
  8004211b7e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  8004211b82:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211b86:	48 83 c0 05          	add    $0x5,%rax
  8004211b8a:	0f b6 00             	movzbl (%rax),%eax
  8004211b8d:	0f b6 c0             	movzbl %al,%eax
  8004211b90:	48 c1 e0 10          	shl    $0x10,%rax
  8004211b94:	48 89 c2             	mov    %rax,%rdx
  8004211b97:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211b9b:	48 83 c0 04          	add    $0x4,%rax
  8004211b9f:	0f b6 00             	movzbl (%rax),%eax
  8004211ba2:	0f b6 c0             	movzbl %al,%eax
  8004211ba5:	48 c1 e0 18          	shl    $0x18,%rax
  8004211ba9:	48 09 d0             	or     %rdx,%rax
  8004211bac:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  8004211bb0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211bb4:	48 83 c0 03          	add    $0x3,%rax
  8004211bb8:	0f b6 00             	movzbl (%rax),%eax
  8004211bbb:	0f b6 c0             	movzbl %al,%eax
  8004211bbe:	48 c1 e0 20          	shl    $0x20,%rax
  8004211bc2:	48 89 c2             	mov    %rax,%rdx
  8004211bc5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211bc9:	48 83 c0 02          	add    $0x2,%rax
  8004211bcd:	0f b6 00             	movzbl (%rax),%eax
  8004211bd0:	0f b6 c0             	movzbl %al,%eax
  8004211bd3:	48 c1 e0 28          	shl    $0x28,%rax
  8004211bd7:	48 09 d0             	or     %rdx,%rax
  8004211bda:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  8004211bde:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211be2:	48 83 c0 01          	add    $0x1,%rax
  8004211be6:	0f b6 00             	movzbl (%rax),%eax
  8004211be9:	0f b6 c0             	movzbl %al,%eax
  8004211bec:	48 c1 e0 30          	shl    $0x30,%rax
  8004211bf0:	48 89 c2             	mov    %rax,%rdx
  8004211bf3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211bf7:	0f b6 00             	movzbl (%rax),%eax
  8004211bfa:	0f b6 c0             	movzbl %al,%eax
  8004211bfd:	48 c1 e0 38          	shl    $0x38,%rax
  8004211c01:	48 09 d0             	or     %rdx,%rax
  8004211c04:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004211c08:	eb 07                	jmp    8004211c11 <_dwarf_decode_msb+0x193>
	default:
		return (0);
  8004211c0a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211c0f:	eb 1a                	jmp    8004211c2b <_dwarf_decode_msb+0x1ad>
		break;
	}

	*data += bytes_to_read;
  8004211c11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c15:	48 8b 10             	mov    (%rax),%rdx
  8004211c18:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004211c1b:	48 98                	cltq   
  8004211c1d:	48 01 c2             	add    %rax,%rdx
  8004211c20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c24:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004211c27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004211c2b:	c9                   	leaveq 
  8004211c2c:	c3                   	retq   

0000008004211c2d <_dwarf_read_sleb128>:

int64_t
_dwarf_read_sleb128(uint8_t *data, uint64_t *offsetp)
{
  8004211c2d:	55                   	push   %rbp
  8004211c2e:	48 89 e5             	mov    %rsp,%rbp
  8004211c31:	48 83 ec 30          	sub    $0x30,%rsp
  8004211c35:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004211c39:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int64_t ret = 0;
  8004211c3d:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004211c44:	00 
	uint8_t b;
	int shift = 0;
  8004211c45:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  8004211c4c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211c50:	48 8b 10             	mov    (%rax),%rdx
  8004211c53:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211c57:	48 01 d0             	add    %rdx,%rax
  8004211c5a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  8004211c5e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c62:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211c66:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004211c6a:	0f b6 00             	movzbl (%rax),%eax
  8004211c6d:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004211c70:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211c74:	83 e0 7f             	and    $0x7f,%eax
  8004211c77:	89 c2                	mov    %eax,%edx
  8004211c79:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211c7c:	89 c1                	mov    %eax,%ecx
  8004211c7e:	d3 e2                	shl    %cl,%edx
  8004211c80:	89 d0                	mov    %edx,%eax
  8004211c82:	48 98                	cltq   
  8004211c84:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  8004211c88:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211c8c:	48 8b 00             	mov    (%rax),%rax
  8004211c8f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211c93:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211c97:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  8004211c9a:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004211c9e:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211ca2:	84 c0                	test   %al,%al
  8004211ca4:	78 b8                	js     8004211c5e <_dwarf_read_sleb128+0x31>

	if (shift < 32 && (b & 0x40) != 0)
  8004211ca6:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  8004211caa:	7f 1f                	jg     8004211ccb <_dwarf_read_sleb128+0x9e>
  8004211cac:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211cb0:	83 e0 40             	and    $0x40,%eax
  8004211cb3:	85 c0                	test   %eax,%eax
  8004211cb5:	74 14                	je     8004211ccb <_dwarf_read_sleb128+0x9e>
		ret |= (-1 << shift);
  8004211cb7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211cba:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8004211cbf:	89 c1                	mov    %eax,%ecx
  8004211cc1:	d3 e2                	shl    %cl,%edx
  8004211cc3:	89 d0                	mov    %edx,%eax
  8004211cc5:	48 98                	cltq   
  8004211cc7:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	return (ret);
  8004211ccb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004211ccf:	c9                   	leaveq 
  8004211cd0:	c3                   	retq   

0000008004211cd1 <_dwarf_read_uleb128>:

uint64_t
_dwarf_read_uleb128(uint8_t *data, uint64_t *offsetp)
{
  8004211cd1:	55                   	push   %rbp
  8004211cd2:	48 89 e5             	mov    %rsp,%rbp
  8004211cd5:	48 83 ec 30          	sub    $0x30,%rsp
  8004211cd9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004211cdd:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t ret = 0;
  8004211ce1:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004211ce8:	00 
	uint8_t b;
	int shift = 0;
  8004211ce9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  8004211cf0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211cf4:	48 8b 10             	mov    (%rax),%rdx
  8004211cf7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211cfb:	48 01 d0             	add    %rdx,%rax
  8004211cfe:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  8004211d02:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211d06:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211d0a:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004211d0e:	0f b6 00             	movzbl (%rax),%eax
  8004211d11:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004211d14:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211d18:	83 e0 7f             	and    $0x7f,%eax
  8004211d1b:	89 c2                	mov    %eax,%edx
  8004211d1d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211d20:	89 c1                	mov    %eax,%ecx
  8004211d22:	d3 e2                	shl    %cl,%edx
  8004211d24:	89 d0                	mov    %edx,%eax
  8004211d26:	48 98                	cltq   
  8004211d28:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  8004211d2c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211d30:	48 8b 00             	mov    (%rax),%rax
  8004211d33:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211d37:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211d3b:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  8004211d3e:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004211d42:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211d46:	84 c0                	test   %al,%al
  8004211d48:	78 b8                	js     8004211d02 <_dwarf_read_uleb128+0x31>

	return (ret);
  8004211d4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004211d4e:	c9                   	leaveq 
  8004211d4f:	c3                   	retq   

0000008004211d50 <_dwarf_decode_sleb128>:

int64_t
_dwarf_decode_sleb128(uint8_t **dp)
{
  8004211d50:	55                   	push   %rbp
  8004211d51:	48 89 e5             	mov    %rsp,%rbp
  8004211d54:	48 83 ec 28          	sub    $0x28,%rsp
  8004211d58:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int64_t ret = 0;
  8004211d5c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004211d63:	00 
	uint8_t b;
	int shift = 0;
  8004211d64:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  8004211d6b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211d6f:	48 8b 00             	mov    (%rax),%rax
  8004211d72:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  8004211d76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211d7a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211d7e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004211d82:	0f b6 00             	movzbl (%rax),%eax
  8004211d85:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004211d88:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211d8c:	83 e0 7f             	and    $0x7f,%eax
  8004211d8f:	89 c2                	mov    %eax,%edx
  8004211d91:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211d94:	89 c1                	mov    %eax,%ecx
  8004211d96:	d3 e2                	shl    %cl,%edx
  8004211d98:	89 d0                	mov    %edx,%eax
  8004211d9a:	48 98                	cltq   
  8004211d9c:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  8004211da0:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004211da4:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211da8:	84 c0                	test   %al,%al
  8004211daa:	78 ca                	js     8004211d76 <_dwarf_decode_sleb128+0x26>

	if (shift < 32 && (b & 0x40) != 0)
  8004211dac:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  8004211db0:	7f 1f                	jg     8004211dd1 <_dwarf_decode_sleb128+0x81>
  8004211db2:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211db6:	83 e0 40             	and    $0x40,%eax
  8004211db9:	85 c0                	test   %eax,%eax
  8004211dbb:	74 14                	je     8004211dd1 <_dwarf_decode_sleb128+0x81>
		ret |= (-1 << shift);
  8004211dbd:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211dc0:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8004211dc5:	89 c1                	mov    %eax,%ecx
  8004211dc7:	d3 e2                	shl    %cl,%edx
  8004211dc9:	89 d0                	mov    %edx,%eax
  8004211dcb:	48 98                	cltq   
  8004211dcd:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	*dp = src;
  8004211dd1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211dd5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211dd9:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004211ddc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004211de0:	c9                   	leaveq 
  8004211de1:	c3                   	retq   

0000008004211de2 <_dwarf_decode_uleb128>:

uint64_t
_dwarf_decode_uleb128(uint8_t **dp)
{
  8004211de2:	55                   	push   %rbp
  8004211de3:	48 89 e5             	mov    %rsp,%rbp
  8004211de6:	48 83 ec 28          	sub    $0x28,%rsp
  8004211dea:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint64_t ret = 0;
  8004211dee:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004211df5:	00 
	uint8_t b;
	int shift = 0;
  8004211df6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  8004211dfd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211e01:	48 8b 00             	mov    (%rax),%rax
  8004211e04:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  8004211e08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211e0c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211e10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004211e14:	0f b6 00             	movzbl (%rax),%eax
  8004211e17:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004211e1a:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211e1e:	83 e0 7f             	and    $0x7f,%eax
  8004211e21:	89 c2                	mov    %eax,%edx
  8004211e23:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211e26:	89 c1                	mov    %eax,%ecx
  8004211e28:	d3 e2                	shl    %cl,%edx
  8004211e2a:	89 d0                	mov    %edx,%eax
  8004211e2c:	48 98                	cltq   
  8004211e2e:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  8004211e32:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004211e36:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211e3a:	84 c0                	test   %al,%al
  8004211e3c:	78 ca                	js     8004211e08 <_dwarf_decode_uleb128+0x26>

	*dp = src;
  8004211e3e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211e42:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211e46:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004211e49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004211e4d:	c9                   	leaveq 
  8004211e4e:	c3                   	retq   

0000008004211e4f <_dwarf_read_string>:

#define Dwarf_Unsigned uint64_t

char *
_dwarf_read_string(void *data, Dwarf_Unsigned size, uint64_t *offsetp)
{
  8004211e4f:	55                   	push   %rbp
  8004211e50:	48 89 e5             	mov    %rsp,%rbp
  8004211e53:	48 83 ec 28          	sub    $0x28,%rsp
  8004211e57:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211e5b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211e5f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *ret, *src;

	ret = src = (char *) data + *offsetp;
  8004211e63:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211e67:	48 8b 10             	mov    (%rax),%rdx
  8004211e6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211e6e:	48 01 d0             	add    %rdx,%rax
  8004211e71:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211e75:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e79:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (*src != '\0' && *offsetp < size) {
  8004211e7d:	eb 17                	jmp    8004211e96 <_dwarf_read_string+0x47>
		src++;
  8004211e7f:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
		(*offsetp)++;
  8004211e84:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211e88:	48 8b 00             	mov    (%rax),%rax
  8004211e8b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211e8f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211e93:	48 89 10             	mov    %rdx,(%rax)
{
	char *ret, *src;

	ret = src = (char *) data + *offsetp;

	while (*src != '\0' && *offsetp < size) {
  8004211e96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e9a:	0f b6 00             	movzbl (%rax),%eax
  8004211e9d:	84 c0                	test   %al,%al
  8004211e9f:	74 0d                	je     8004211eae <_dwarf_read_string+0x5f>
  8004211ea1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211ea5:	48 8b 00             	mov    (%rax),%rax
  8004211ea8:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211eac:	72 d1                	jb     8004211e7f <_dwarf_read_string+0x30>
		src++;
		(*offsetp)++;
	}

	if (*src == '\0' && *offsetp < size)
  8004211eae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211eb2:	0f b6 00             	movzbl (%rax),%eax
  8004211eb5:	84 c0                	test   %al,%al
  8004211eb7:	75 1f                	jne    8004211ed8 <_dwarf_read_string+0x89>
  8004211eb9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211ebd:	48 8b 00             	mov    (%rax),%rax
  8004211ec0:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211ec4:	73 12                	jae    8004211ed8 <_dwarf_read_string+0x89>
		(*offsetp)++;
  8004211ec6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211eca:	48 8b 00             	mov    (%rax),%rax
  8004211ecd:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211ed1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211ed5:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004211ed8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  8004211edc:	c9                   	leaveq 
  8004211edd:	c3                   	retq   

0000008004211ede <_dwarf_read_block>:

uint8_t *
_dwarf_read_block(void *data, uint64_t *offsetp, uint64_t length)
{
  8004211ede:	55                   	push   %rbp
  8004211edf:	48 89 e5             	mov    %rsp,%rbp
  8004211ee2:	48 83 ec 28          	sub    $0x28,%rsp
  8004211ee6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211eea:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211eee:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t *ret, *src;

	ret = src = (uint8_t *) data + *offsetp;
  8004211ef2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211ef6:	48 8b 10             	mov    (%rax),%rdx
  8004211ef9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211efd:	48 01 d0             	add    %rdx,%rax
  8004211f00:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211f04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211f08:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	(*offsetp) += length;
  8004211f0c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211f10:	48 8b 10             	mov    (%rax),%rdx
  8004211f13:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211f17:	48 01 c2             	add    %rax,%rdx
  8004211f1a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211f1e:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004211f21:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  8004211f25:	c9                   	leaveq 
  8004211f26:	c3                   	retq   

0000008004211f27 <_dwarf_elf_get_byte_order>:

Dwarf_Endianness
_dwarf_elf_get_byte_order(void *obj)
{
  8004211f27:	55                   	push   %rbp
  8004211f28:	48 89 e5             	mov    %rsp,%rbp
  8004211f2b:	48 83 ec 20          	sub    $0x20,%rsp
  8004211f2f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *)obj;
  8004211f33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211f37:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  8004211f3b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004211f40:	75 35                	jne    8004211f77 <_dwarf_elf_get_byte_order+0x50>
  8004211f42:	48 b9 20 15 22 04 80 	movabs $0x8004221520,%rcx
  8004211f49:	00 00 00 
  8004211f4c:	48 ba 2a 15 22 04 80 	movabs $0x800422152a,%rdx
  8004211f53:	00 00 00 
  8004211f56:	be 29 01 00 00       	mov    $0x129,%esi
  8004211f5b:	48 bf 3f 15 22 04 80 	movabs $0x800422153f,%rdi
  8004211f62:	00 00 00 
  8004211f65:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211f6a:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004211f71:	00 00 00 
  8004211f74:	41 ff d0             	callq  *%r8

//TODO: Need to check for 64bit here. Because currently Elf header for
//      64bit doesn't have any memeber e_ident. But need to see what is
//      similar in 64bit.
	switch (e->e_ident[EI_DATA]) {
  8004211f77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211f7b:	0f b6 40 05          	movzbl 0x5(%rax),%eax
  8004211f7f:	0f b6 c0             	movzbl %al,%eax
  8004211f82:	83 f8 02             	cmp    $0x2,%eax
  8004211f85:	75 07                	jne    8004211f8e <_dwarf_elf_get_byte_order+0x67>
	case ELFDATA2MSB:
		return (DW_OBJECT_MSB);
  8004211f87:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211f8c:	eb 05                	jmp    8004211f93 <_dwarf_elf_get_byte_order+0x6c>

	case ELFDATA2LSB:
	case ELFDATANONE:
	default:
		return (DW_OBJECT_LSB);
  8004211f8e:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
  8004211f93:	c9                   	leaveq 
  8004211f94:	c3                   	retq   

0000008004211f95 <_dwarf_elf_get_pointer_size>:

Dwarf_Small
_dwarf_elf_get_pointer_size(void *obj)
{
  8004211f95:	55                   	push   %rbp
  8004211f96:	48 89 e5             	mov    %rsp,%rbp
  8004211f99:	48 83 ec 20          	sub    $0x20,%rsp
  8004211f9d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *) obj;
  8004211fa1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211fa5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  8004211fa9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004211fae:	75 35                	jne    8004211fe5 <_dwarf_elf_get_pointer_size+0x50>
  8004211fb0:	48 b9 20 15 22 04 80 	movabs $0x8004221520,%rcx
  8004211fb7:	00 00 00 
  8004211fba:	48 ba 2a 15 22 04 80 	movabs $0x800422152a,%rdx
  8004211fc1:	00 00 00 
  8004211fc4:	be 3f 01 00 00       	mov    $0x13f,%esi
  8004211fc9:	48 bf 3f 15 22 04 80 	movabs $0x800422153f,%rdi
  8004211fd0:	00 00 00 
  8004211fd3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211fd8:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004211fdf:	00 00 00 
  8004211fe2:	41 ff d0             	callq  *%r8

	if (e->e_ident[4] == ELFCLASS32)
  8004211fe5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211fe9:	0f b6 40 04          	movzbl 0x4(%rax),%eax
  8004211fed:	3c 01                	cmp    $0x1,%al
  8004211fef:	75 07                	jne    8004211ff8 <_dwarf_elf_get_pointer_size+0x63>
		return (4);
  8004211ff1:	b8 04 00 00 00       	mov    $0x4,%eax
  8004211ff6:	eb 05                	jmp    8004211ffd <_dwarf_elf_get_pointer_size+0x68>
	else
		return (8);
  8004211ff8:	b8 08 00 00 00       	mov    $0x8,%eax
}
  8004211ffd:	c9                   	leaveq 
  8004211ffe:	c3                   	retq   

0000008004211fff <_dwarf_init>:

//Return 0 on success
int _dwarf_init(Dwarf_Debug dbg, void *obj)
{
  8004211fff:	55                   	push   %rbp
  8004212000:	48 89 e5             	mov    %rsp,%rbp
  8004212003:	48 83 ec 10          	sub    $0x10,%rsp
  8004212007:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800421200b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	memset(dbg, 0, sizeof(struct _Dwarf_Debug));
  800421200f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212013:	ba 60 00 00 00       	mov    $0x60,%edx
  8004212018:	be 00 00 00 00       	mov    $0x0,%esi
  800421201d:	48 89 c7             	mov    %rax,%rdi
  8004212020:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  8004212027:	00 00 00 
  800421202a:	ff d0                	callq  *%rax
	dbg->curr_off_dbginfo = 0;
  800421202c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212030:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	dbg->dbg_info_size = 0;
  8004212037:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421203b:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004212042:	00 
	dbg->dbg_pointer_size = _dwarf_elf_get_pointer_size(obj); 
  8004212043:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212047:	48 89 c7             	mov    %rax,%rdi
  800421204a:	48 b8 95 1f 21 04 80 	movabs $0x8004211f95,%rax
  8004212051:	00 00 00 
  8004212054:	ff d0                	callq  *%rax
  8004212056:	0f b6 d0             	movzbl %al,%edx
  8004212059:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421205d:	89 50 28             	mov    %edx,0x28(%rax)

	if (_dwarf_elf_get_byte_order(obj) == DW_OBJECT_MSB) {
  8004212060:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212064:	48 89 c7             	mov    %rax,%rdi
  8004212067:	48 b8 27 1f 21 04 80 	movabs $0x8004211f27,%rax
  800421206e:	00 00 00 
  8004212071:	ff d0                	callq  *%rax
  8004212073:	85 c0                	test   %eax,%eax
  8004212075:	75 26                	jne    800421209d <_dwarf_init+0x9e>
		dbg->read = _dwarf_read_msb;
  8004212077:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421207b:	48 b9 cc 18 21 04 80 	movabs $0x80042118cc,%rcx
  8004212082:	00 00 00 
  8004212085:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_msb;
  8004212089:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421208d:	48 b9 7e 1a 21 04 80 	movabs $0x8004211a7e,%rcx
  8004212094:	00 00 00 
  8004212097:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800421209b:	eb 24                	jmp    80042120c1 <_dwarf_init+0xc2>
	} else {
		dbg->read = _dwarf_read_lsb;
  800421209d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042120a1:	48 be 7f 16 21 04 80 	movabs $0x800421167f,%rsi
  80042120a8:	00 00 00 
  80042120ab:	48 89 70 18          	mov    %rsi,0x18(%rax)
		dbg->decode = _dwarf_decode_lsb;
  80042120af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042120b3:	48 ba ab 17 21 04 80 	movabs $0x80042117ab,%rdx
  80042120ba:	00 00 00 
  80042120bd:	48 89 50 20          	mov    %rdx,0x20(%rax)
	}
	_dwarf_frame_params_init(dbg);
  80042120c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042120c5:	48 89 c7             	mov    %rax,%rdi
  80042120c8:	48 b8 09 35 21 04 80 	movabs $0x8004213509,%rax
  80042120cf:	00 00 00 
  80042120d2:	ff d0                	callq  *%rax
	return 0;
  80042120d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042120d9:	c9                   	leaveq 
  80042120da:	c3                   	retq   

00000080042120db <_get_next_cu>:

//Return 0 on success
int _get_next_cu(Dwarf_Debug dbg, Dwarf_CU *cu)
{
  80042120db:	55                   	push   %rbp
  80042120dc:	48 89 e5             	mov    %rsp,%rbp
  80042120df:	48 83 ec 20          	sub    $0x20,%rsp
  80042120e3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042120e7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint32_t length;
	uint64_t offset;
	uint8_t dwarf_size;

	if(dbg->curr_off_dbginfo > dbg->dbg_info_size)
  80042120eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042120ef:	48 8b 10             	mov    (%rax),%rdx
  80042120f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042120f6:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042120fa:	48 39 c2             	cmp    %rax,%rdx
  80042120fd:	76 0a                	jbe    8004212109 <_get_next_cu+0x2e>
		return -1;
  80042120ff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212104:	e9 71 01 00 00       	jmpq   800421227a <_get_next_cu+0x19f>

	offset = dbg->curr_off_dbginfo;
  8004212109:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421210d:	48 8b 00             	mov    (%rax),%rax
  8004212110:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cu->cu_offset = offset;
  8004212114:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004212118:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421211c:	48 89 50 30          	mov    %rdx,0x30(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset,4);
  8004212120:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212124:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212128:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421212c:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004212130:	48 89 d7             	mov    %rdx,%rdi
  8004212133:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  8004212137:	ba 04 00 00 00       	mov    $0x4,%edx
  800421213c:	48 89 ce             	mov    %rcx,%rsi
  800421213f:	ff d0                	callq  *%rax
  8004212141:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (length == 0xffffffff) {
  8004212144:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  8004212148:	75 2a                	jne    8004212174 <_get_next_cu+0x99>
		length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 8);
  800421214a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421214e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212152:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212156:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800421215a:	48 89 d7             	mov    %rdx,%rdi
  800421215d:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  8004212161:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212166:	48 89 ce             	mov    %rcx,%rsi
  8004212169:	ff d0                	callq  *%rax
  800421216b:	89 45 fc             	mov    %eax,-0x4(%rbp)
		dwarf_size = 8;
  800421216e:	c6 45 fb 08          	movb   $0x8,-0x5(%rbp)
  8004212172:	eb 04                	jmp    8004212178 <_get_next_cu+0x9d>
	} else {
		dwarf_size = 4;
  8004212174:	c6 45 fb 04          	movb   $0x4,-0x5(%rbp)
	}

	cu->cu_dwarf_size = dwarf_size;
  8004212178:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421217c:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  8004212180:	88 50 19             	mov    %dl,0x19(%rax)
	 if (length > ds->ds_size - offset) {
	 return (DW_DLE_CU_LENGTH_ERROR);
	 }*/

	/* Compute the offset to the next compilation unit: */
	dbg->curr_off_dbginfo = offset + length;
  8004212183:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004212186:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421218a:	48 01 c2             	add    %rax,%rdx
  800421218d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212191:	48 89 10             	mov    %rdx,(%rax)
	cu->cu_next_offset   = dbg->curr_off_dbginfo;
  8004212194:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212198:	48 8b 10             	mov    (%rax),%rdx
  800421219b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421219f:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/* Initialise the compilation unit. */
	cu->cu_length = (uint64_t)length;
  80042121a3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042121a6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042121aa:	48 89 10             	mov    %rdx,(%rax)

	cu->cu_length_size   = (dwarf_size == 4 ? 4 : 12);
  80042121ad:	80 7d fb 04          	cmpb   $0x4,-0x5(%rbp)
  80042121b1:	75 07                	jne    80042121ba <_get_next_cu+0xdf>
  80042121b3:	ba 04 00 00 00       	mov    $0x4,%edx
  80042121b8:	eb 05                	jmp    80042121bf <_get_next_cu+0xe4>
  80042121ba:	ba 0c 00 00 00       	mov    $0xc,%edx
  80042121bf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042121c3:	88 50 18             	mov    %dl,0x18(%rax)
	cu->version              = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 2);
  80042121c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042121ca:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042121ce:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042121d2:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  80042121d6:	48 89 d7             	mov    %rdx,%rdi
  80042121d9:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  80042121dd:	ba 02 00 00 00       	mov    $0x2,%edx
  80042121e2:	48 89 ce             	mov    %rcx,%rsi
  80042121e5:	ff d0                	callq  *%rax
  80042121e7:	89 c2                	mov    %eax,%edx
  80042121e9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042121ed:	66 89 50 08          	mov    %dx,0x8(%rax)
	cu->debug_abbrev_offset  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, dwarf_size);
  80042121f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042121f5:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042121f9:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  80042121fd:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212201:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  8004212205:	48 89 cf             	mov    %rcx,%rdi
  8004212208:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800421220c:	48 89 ce             	mov    %rcx,%rsi
  800421220f:	ff d0                	callq  *%rax
  8004212211:	48 89 c2             	mov    %rax,%rdx
  8004212214:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212218:	48 89 50 10          	mov    %rdx,0x10(%rax)
	//cu->cu_abbrev_offset_cur = cu->cu_abbrev_offset;
	cu->addr_size  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 1);
  800421221c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212220:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212224:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212228:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800421222c:	48 89 d7             	mov    %rdx,%rdi
  800421222f:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  8004212233:	ba 01 00 00 00       	mov    $0x1,%edx
  8004212238:	48 89 ce             	mov    %rcx,%rsi
  800421223b:	ff d0                	callq  *%rax
  800421223d:	89 c2                	mov    %eax,%edx
  800421223f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212243:	88 50 0a             	mov    %dl,0xa(%rax)

	if (cu->version < 2 || cu->version > 4) {
  8004212246:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421224a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800421224e:	66 83 f8 01          	cmp    $0x1,%ax
  8004212252:	76 0e                	jbe    8004212262 <_get_next_cu+0x187>
  8004212254:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212258:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800421225c:	66 83 f8 04          	cmp    $0x4,%ax
  8004212260:	76 07                	jbe    8004212269 <_get_next_cu+0x18e>
		return -1;
  8004212262:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212267:	eb 11                	jmp    800421227a <_get_next_cu+0x19f>
	}

	cu->cu_die_offset = offset;
  8004212269:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421226d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212271:	48 89 50 28          	mov    %rdx,0x28(%rax)

	return 0;
  8004212275:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421227a:	c9                   	leaveq 
  800421227b:	c3                   	retq   

000000800421227c <print_cu>:

void print_cu(Dwarf_CU cu)
{
  800421227c:	55                   	push   %rbp
  800421227d:	48 89 e5             	mov    %rsp,%rbp
	cprintf("%ld---%du--%d\n",cu.cu_length,cu.version,cu.addr_size);
  8004212280:	0f b6 45 1a          	movzbl 0x1a(%rbp),%eax
  8004212284:	0f b6 c8             	movzbl %al,%ecx
  8004212287:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
  800421228b:	0f b7 d0             	movzwl %ax,%edx
  800421228e:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8004212292:	48 89 c6             	mov    %rax,%rsi
  8004212295:	48 bf 52 15 22 04 80 	movabs $0x8004221552,%rdi
  800421229c:	00 00 00 
  800421229f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042122a4:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  80042122ab:	00 00 00 
  80042122ae:	41 ff d0             	callq  *%r8
}
  80042122b1:	90                   	nop
  80042122b2:	5d                   	pop    %rbp
  80042122b3:	c3                   	retq   

00000080042122b4 <_dwarf_abbrev_parse>:

//Return 0 on success
int
_dwarf_abbrev_parse(Dwarf_Debug dbg, Dwarf_CU cu, Dwarf_Unsigned *offset,
		    Dwarf_Abbrev *abp, Dwarf_Section *ds)
{
  80042122b4:	55                   	push   %rbp
  80042122b5:	48 89 e5             	mov    %rsp,%rbp
  80042122b8:	48 83 ec 60          	sub    $0x60,%rsp
  80042122bc:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  80042122c0:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  80042122c4:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  80042122c8:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
	uint64_t tag;
	uint8_t children;
	uint64_t abbr_addr;
	int ret;

	assert(abp != NULL);
  80042122cc:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  80042122d1:	75 35                	jne    8004212308 <_dwarf_abbrev_parse+0x54>
  80042122d3:	48 b9 61 15 22 04 80 	movabs $0x8004221561,%rcx
  80042122da:	00 00 00 
  80042122dd:	48 ba 2a 15 22 04 80 	movabs $0x800422152a,%rdx
  80042122e4:	00 00 00 
  80042122e7:	be a4 01 00 00       	mov    $0x1a4,%esi
  80042122ec:	48 bf 3f 15 22 04 80 	movabs $0x800422153f,%rdi
  80042122f3:	00 00 00 
  80042122f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042122fb:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004212302:	00 00 00 
  8004212305:	41 ff d0             	callq  *%r8
	assert(ds != NULL);
  8004212308:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  800421230d:	75 35                	jne    8004212344 <_dwarf_abbrev_parse+0x90>
  800421230f:	48 b9 6d 15 22 04 80 	movabs $0x800422156d,%rcx
  8004212316:	00 00 00 
  8004212319:	48 ba 2a 15 22 04 80 	movabs $0x800422152a,%rdx
  8004212320:	00 00 00 
  8004212323:	be a5 01 00 00       	mov    $0x1a5,%esi
  8004212328:	48 bf 3f 15 22 04 80 	movabs $0x800422153f,%rdi
  800421232f:	00 00 00 
  8004212332:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212337:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421233e:	00 00 00 
  8004212341:	41 ff d0             	callq  *%r8

	if (*offset >= ds->ds_size)
  8004212344:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212348:	48 8b 10             	mov    (%rax),%rdx
  800421234b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421234f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212353:	48 39 c2             	cmp    %rax,%rdx
  8004212356:	72 0a                	jb     8004212362 <_dwarf_abbrev_parse+0xae>
        	return (DW_DLE_NO_ENTRY);
  8004212358:	b8 04 00 00 00       	mov    $0x4,%eax
  800421235d:	e9 d3 01 00 00       	jmpq   8004212535 <_dwarf_abbrev_parse+0x281>

	aboff = *offset;
  8004212362:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212366:	48 8b 00             	mov    (%rax),%rax
  8004212369:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	abbr_addr = (uint64_t)ds->ds_data; //(uint64_t)((uint8_t *)elf_base_ptr + ds->sh_offset);
  800421236d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212371:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212375:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	entry = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004212379:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421237d:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004212381:	48 89 d6             	mov    %rdx,%rsi
  8004212384:	48 89 c7             	mov    %rax,%rdi
  8004212387:	48 b8 d1 1c 21 04 80 	movabs $0x8004211cd1,%rax
  800421238e:	00 00 00 
  8004212391:	ff d0                	callq  *%rax
  8004212393:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if (entry == 0) {
  8004212397:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800421239c:	75 15                	jne    80042123b3 <_dwarf_abbrev_parse+0xff>
		/* Last entry. */
		//Need to make connection from below function
		abp->ab_entry = 0;
  800421239e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042123a2:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return DW_DLE_NONE;
  80042123a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042123ae:	e9 82 01 00 00       	jmpq   8004212535 <_dwarf_abbrev_parse+0x281>
	}

	tag = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  80042123b3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042123b7:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042123bb:	48 89 d6             	mov    %rdx,%rsi
  80042123be:	48 89 c7             	mov    %rax,%rdi
  80042123c1:	48 b8 d1 1c 21 04 80 	movabs $0x8004211cd1,%rax
  80042123c8:	00 00 00 
  80042123cb:	ff d0                	callq  *%rax
  80042123cd:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	children = dbg->read((uint8_t *)abbr_addr, offset, 1);
  80042123d1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042123d5:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042123d9:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80042123dd:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80042123e1:	ba 01 00 00 00       	mov    $0x1,%edx
  80042123e6:	48 89 cf             	mov    %rcx,%rdi
  80042123e9:	ff d0                	callq  *%rax
  80042123eb:	88 45 df             	mov    %al,-0x21(%rbp)

	abp->ab_entry    = entry;
  80042123ee:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042123f2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042123f6:	48 89 10             	mov    %rdx,(%rax)
	abp->ab_tag      = tag;
  80042123f9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042123fd:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212401:	48 89 50 08          	mov    %rdx,0x8(%rax)
	abp->ab_children = children;
  8004212405:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004212409:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  800421240d:	88 50 10             	mov    %dl,0x10(%rax)
	abp->ab_offset   = aboff;
  8004212410:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004212414:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004212418:	48 89 50 18          	mov    %rdx,0x18(%rax)
	abp->ab_length   = 0;    /* fill in later. */
  800421241c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004212420:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  8004212427:	00 
	abp->ab_atnum    = 0;
  8004212428:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421242c:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  8004212433:	00 

	/* Parse attribute definitions. */
	do {
		adoff = *offset;
  8004212434:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212438:	48 8b 00             	mov    (%rax),%rax
  800421243b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		attr = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800421243f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212443:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004212447:	48 89 d6             	mov    %rdx,%rsi
  800421244a:	48 89 c7             	mov    %rax,%rdi
  800421244d:	48 b8 d1 1c 21 04 80 	movabs $0x8004211cd1,%rax
  8004212454:	00 00 00 
  8004212457:	ff d0                	callq  *%rax
  8004212459:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		form = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800421245d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212461:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004212465:	48 89 d6             	mov    %rdx,%rsi
  8004212468:	48 89 c7             	mov    %rax,%rdi
  800421246b:	48 b8 d1 1c 21 04 80 	movabs $0x8004211cd1,%rax
  8004212472:	00 00 00 
  8004212475:	ff d0                	callq  *%rax
  8004212477:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		if (attr != 0)
  800421247b:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004212480:	0f 84 89 00 00 00    	je     800421250f <_dwarf_abbrev_parse+0x25b>
		{
			/* Initialise the attribute definition structure. */
			abp->ab_attrdef[abp->ab_atnum].ad_attrib = attr;
  8004212486:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421248a:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800421248e:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004212492:	48 89 d0             	mov    %rdx,%rax
  8004212495:	48 01 c0             	add    %rax,%rax
  8004212498:	48 01 d0             	add    %rdx,%rax
  800421249b:	48 c1 e0 03          	shl    $0x3,%rax
  800421249f:	48 01 c8             	add    %rcx,%rax
  80042124a2:	48 8d 50 30          	lea    0x30(%rax),%rdx
  80042124a6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042124aa:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_form   = form;
  80042124ad:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042124b1:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042124b5:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  80042124b9:	48 89 d0             	mov    %rdx,%rax
  80042124bc:	48 01 c0             	add    %rax,%rax
  80042124bf:	48 01 d0             	add    %rdx,%rax
  80042124c2:	48 c1 e0 03          	shl    $0x3,%rax
  80042124c6:	48 01 c8             	add    %rcx,%rax
  80042124c9:	48 8d 50 38          	lea    0x38(%rax),%rdx
  80042124cd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042124d1:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_offset = adoff;
  80042124d4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042124d8:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042124dc:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  80042124e0:	48 89 d0             	mov    %rdx,%rax
  80042124e3:	48 01 c0             	add    %rax,%rax
  80042124e6:	48 01 d0             	add    %rdx,%rax
  80042124e9:	48 c1 e0 03          	shl    $0x3,%rax
  80042124ed:	48 01 c8             	add    %rcx,%rax
  80042124f0:	48 8d 50 40          	lea    0x40(%rax),%rdx
  80042124f4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042124f8:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_atnum++;
  80042124fb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042124ff:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212503:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004212507:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421250b:	48 89 50 28          	mov    %rdx,0x28(%rax)
		}
	} while (attr != 0);
  800421250f:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004212514:	0f 85 1a ff ff ff    	jne    8004212434 <_dwarf_abbrev_parse+0x180>

	//(*abp)->ab_length = *offset - aboff;
	abp->ab_length = (uint64_t)(*offset - aboff);
  800421251a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421251e:	48 8b 00             	mov    (%rax),%rax
  8004212521:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  8004212525:	48 89 c2             	mov    %rax,%rdx
  8004212528:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421252c:	48 89 50 20          	mov    %rdx,0x20(%rax)

	return DW_DLV_OK;
  8004212530:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212535:	c9                   	leaveq 
  8004212536:	c3                   	retq   

0000008004212537 <_dwarf_abbrev_find>:

//Return 0 on success
int
_dwarf_abbrev_find(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t entry, Dwarf_Abbrev *abp)
{
  8004212537:	55                   	push   %rbp
  8004212538:	48 89 e5             	mov    %rsp,%rbp
  800421253b:	48 83 ec 40          	sub    $0x40,%rsp
  800421253f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004212543:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004212547:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	Dwarf_Section *ds;
	uint64_t offset;
	int ret;

	if (entry == 0)
  800421254b:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004212550:	75 0a                	jne    800421255c <_dwarf_abbrev_find+0x25>
	{
		return (DW_DLE_NO_ENTRY);
  8004212552:	b8 04 00 00 00       	mov    $0x4,%eax
  8004212557:	e9 e3 00 00 00       	jmpq   800421263f <_dwarf_abbrev_find+0x108>
	}

	/* Load and search the abbrev table. */
	ds = _dwarf_find_section(".debug_abbrev");
  800421255c:	48 bf 78 15 22 04 80 	movabs $0x8004221578,%rdi
  8004212563:	00 00 00 
  8004212566:	48 b8 ca 67 21 04 80 	movabs $0x80042167ca,%rax
  800421256d:	00 00 00 
  8004212570:	ff d0                	callq  *%rax
  8004212572:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(ds != NULL);
  8004212576:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421257b:	75 35                	jne    80042125b2 <_dwarf_abbrev_find+0x7b>
  800421257d:	48 b9 6d 15 22 04 80 	movabs $0x800422156d,%rcx
  8004212584:	00 00 00 
  8004212587:	48 ba 2a 15 22 04 80 	movabs $0x800422152a,%rdx
  800421258e:	00 00 00 
  8004212591:	be e5 01 00 00       	mov    $0x1e5,%esi
  8004212596:	48 bf 3f 15 22 04 80 	movabs $0x800422153f,%rdi
  800421259d:	00 00 00 
  80042125a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042125a5:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042125ac:	00 00 00 
  80042125af:	41 ff d0             	callq  *%r8

	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
  80042125b2:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042125b6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	while (offset < ds->ds_size) {
  80042125ba:	eb 6a                	jmp    8004212626 <_dwarf_abbrev_find+0xef>
		ret = _dwarf_abbrev_parse(dbg, cu, &offset, abp, ds);
  80042125bc:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80042125c0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042125c4:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  80042125c8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042125cc:	48 83 ec 08          	sub    $0x8,%rsp
  80042125d0:	ff 75 40             	pushq  0x40(%rbp)
  80042125d3:	ff 75 38             	pushq  0x38(%rbp)
  80042125d6:	ff 75 30             	pushq  0x30(%rbp)
  80042125d9:	ff 75 28             	pushq  0x28(%rbp)
  80042125dc:	ff 75 20             	pushq  0x20(%rbp)
  80042125df:	ff 75 18             	pushq  0x18(%rbp)
  80042125e2:	ff 75 10             	pushq  0x10(%rbp)
  80042125e5:	48 89 c7             	mov    %rax,%rdi
  80042125e8:	48 b8 b4 22 21 04 80 	movabs $0x80042122b4,%rax
  80042125ef:	00 00 00 
  80042125f2:	ff d0                	callq  *%rax
  80042125f4:	48 83 c4 40          	add    $0x40,%rsp
  80042125f8:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (ret != DW_DLE_NONE)
  80042125fb:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  80042125ff:	74 05                	je     8004212606 <_dwarf_abbrev_find+0xcf>
			return (ret);
  8004212601:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004212604:	eb 39                	jmp    800421263f <_dwarf_abbrev_find+0x108>
		if (abp->ab_entry == entry) {
  8004212606:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421260a:	48 8b 00             	mov    (%rax),%rax
  800421260d:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212611:	75 07                	jne    800421261a <_dwarf_abbrev_find+0xe3>
			//cu->cu_abbrev_offset_cur = offset;
			return DW_DLE_NONE;
  8004212613:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212618:	eb 25                	jmp    800421263f <_dwarf_abbrev_find+0x108>
		}
		if (abp->ab_entry == 0) {
  800421261a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421261e:	48 8b 00             	mov    (%rax),%rax
  8004212621:	48 85 c0             	test   %rax,%rax
  8004212624:	74 13                	je     8004212639 <_dwarf_abbrev_find+0x102>
	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
	while (offset < ds->ds_size) {
  8004212626:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421262a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421262e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212632:	48 39 c2             	cmp    %rax,%rdx
  8004212635:	77 85                	ja     80042125bc <_dwarf_abbrev_find+0x85>
  8004212637:	eb 01                	jmp    800421263a <_dwarf_abbrev_find+0x103>
			return DW_DLE_NONE;
		}
		if (abp->ab_entry == 0) {
			//cu->cu_abbrev_offset_cur = offset;
			//cu->cu_abbrev_loaded = 1;
			break;
  8004212639:	90                   	nop
		}
	}

	return DW_DLE_NO_ENTRY;
  800421263a:	b8 04 00 00 00       	mov    $0x4,%eax
}
  800421263f:	c9                   	leaveq 
  8004212640:	c3                   	retq   

0000008004212641 <_dwarf_attr_init>:

//Return 0 on success
int
_dwarf_attr_init(Dwarf_Debug dbg, uint64_t *offsetp, Dwarf_CU *cu, Dwarf_Die *ret_die, Dwarf_AttrDef *ad,
		 uint64_t form, int indirect)
{
  8004212641:	55                   	push   %rbp
  8004212642:	48 89 e5             	mov    %rsp,%rbp
  8004212645:	48 81 ec c0 00 00 00 	sub    $0xc0,%rsp
  800421264c:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004212653:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  800421265a:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004212661:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  8004212668:	4c 89 85 48 ff ff ff 	mov    %r8,-0xb8(%rbp)
  800421266f:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
	struct _Dwarf_Attribute atref;
	Dwarf_Section *str;
	int ret;
	Dwarf_Section *ds = _dwarf_find_section(".debug_info");
  8004212676:	48 bf 86 15 22 04 80 	movabs $0x8004221586,%rdi
  800421267d:	00 00 00 
  8004212680:	48 b8 ca 67 21 04 80 	movabs $0x80042167ca,%rax
  8004212687:	00 00 00 
  800421268a:	ff d0                	callq  *%rax
  800421268c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	uint8_t *ds_data = (uint8_t *)ds->ds_data; //(uint8_t *)dbg->dbg_info_offset_elf;
  8004212690:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212694:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212698:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint8_t dwarf_size = cu->cu_dwarf_size;
  800421269c:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042126a3:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  80042126a7:	88 45 e7             	mov    %al,-0x19(%rbp)

	ret = DW_DLE_NONE;
  80042126aa:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	memset(&atref, 0, sizeof(atref));
  80042126b1:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  80042126b8:	ba 60 00 00 00       	mov    $0x60,%edx
  80042126bd:	be 00 00 00 00       	mov    $0x0,%esi
  80042126c2:	48 89 c7             	mov    %rax,%rdi
  80042126c5:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  80042126cc:	00 00 00 
  80042126cf:	ff d0                	callq  *%rax
	atref.at_die = ret_die;
  80042126d1:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042126d8:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	atref.at_attrib = ad->ad_attrib;
  80042126df:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042126e6:	48 8b 00             	mov    (%rax),%rax
  80042126e9:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	atref.at_form = ad->ad_form;
  80042126ed:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042126f4:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042126f8:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	atref.at_indirect = indirect;
  80042126fc:	8b 45 10             	mov    0x10(%rbp),%eax
  80042126ff:	89 45 90             	mov    %eax,-0x70(%rbp)
	atref.at_ld = NULL;
  8004212702:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8004212709:	00 

	switch (form) {
  800421270a:	48 83 bd 40 ff ff ff 	cmpq   $0x20,-0xc0(%rbp)
  8004212711:	20 
  8004212712:	0f 87 87 04 00 00    	ja     8004212b9f <_dwarf_attr_init+0x55e>
  8004212718:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  800421271f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004212726:	00 
  8004212727:	48 b8 b0 15 22 04 80 	movabs $0x80042215b0,%rax
  800421272e:	00 00 00 
  8004212731:	48 01 d0             	add    %rdx,%rax
  8004212734:	48 8b 00             	mov    (%rax),%rax
  8004212737:	ff e0                	jmpq   *%rax
	case DW_FORM_addr:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  8004212739:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004212740:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212744:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800421274b:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  800421274f:	0f b6 d2             	movzbl %dl,%edx
  8004212752:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004212759:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421275d:	48 89 cf             	mov    %rcx,%rdi
  8004212760:	ff d0                	callq  *%rax
  8004212762:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004212766:	e9 3e 04 00 00       	jmpq   8004212ba9 <_dwarf_attr_init+0x568>
	case DW_FORM_block:
	case DW_FORM_exprloc:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  800421276b:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004212772:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212776:	48 89 d6             	mov    %rdx,%rsi
  8004212779:	48 89 c7             	mov    %rax,%rdi
  800421277c:	48 b8 d1 1c 21 04 80 	movabs $0x8004211cd1,%rax
  8004212783:	00 00 00 
  8004212786:	ff d0                	callq  *%rax
  8004212788:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800421278c:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004212790:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004212797:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421279b:	48 89 ce             	mov    %rcx,%rsi
  800421279e:	48 89 c7             	mov    %rax,%rdi
  80042127a1:	48 b8 de 1e 21 04 80 	movabs $0x8004211ede,%rax
  80042127a8:	00 00 00 
  80042127ab:	ff d0                	callq  *%rax
  80042127ad:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  80042127b1:	e9 f3 03 00 00       	jmpq   8004212ba9 <_dwarf_attr_init+0x568>
	case DW_FORM_block1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  80042127b6:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042127bd:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042127c1:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042127c8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042127cc:	ba 01 00 00 00       	mov    $0x1,%edx
  80042127d1:	48 89 cf             	mov    %rcx,%rdi
  80042127d4:	ff d0                	callq  *%rax
  80042127d6:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  80042127da:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042127de:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042127e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042127e9:	48 89 ce             	mov    %rcx,%rsi
  80042127ec:	48 89 c7             	mov    %rax,%rdi
  80042127ef:	48 b8 de 1e 21 04 80 	movabs $0x8004211ede,%rax
  80042127f6:	00 00 00 
  80042127f9:	ff d0                	callq  *%rax
  80042127fb:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  80042127ff:	e9 a5 03 00 00       	jmpq   8004212ba9 <_dwarf_attr_init+0x568>
	case DW_FORM_block2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  8004212804:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421280b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421280f:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004212816:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421281a:	ba 02 00 00 00       	mov    $0x2,%edx
  800421281f:	48 89 cf             	mov    %rcx,%rdi
  8004212822:	ff d0                	callq  *%rax
  8004212824:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004212828:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421282c:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004212833:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212837:	48 89 ce             	mov    %rcx,%rsi
  800421283a:	48 89 c7             	mov    %rax,%rdi
  800421283d:	48 b8 de 1e 21 04 80 	movabs $0x8004211ede,%rax
  8004212844:	00 00 00 
  8004212847:	ff d0                	callq  *%rax
  8004212849:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800421284d:	e9 57 03 00 00       	jmpq   8004212ba9 <_dwarf_attr_init+0x568>
	case DW_FORM_block4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  8004212852:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004212859:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421285d:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004212864:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212868:	ba 04 00 00 00       	mov    $0x4,%edx
  800421286d:	48 89 cf             	mov    %rcx,%rdi
  8004212870:	ff d0                	callq  *%rax
  8004212872:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004212876:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421287a:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004212881:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212885:	48 89 ce             	mov    %rcx,%rsi
  8004212888:	48 89 c7             	mov    %rax,%rdi
  800421288b:	48 b8 de 1e 21 04 80 	movabs $0x8004211ede,%rax
  8004212892:	00 00 00 
  8004212895:	ff d0                	callq  *%rax
  8004212897:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800421289b:	e9 09 03 00 00       	jmpq   8004212ba9 <_dwarf_attr_init+0x568>
	case DW_FORM_data1:
	case DW_FORM_flag:
	case DW_FORM_ref1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  80042128a0:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042128a7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042128ab:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042128b2:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042128b6:	ba 01 00 00 00       	mov    $0x1,%edx
  80042128bb:	48 89 cf             	mov    %rcx,%rdi
  80042128be:	ff d0                	callq  *%rax
  80042128c0:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042128c4:	e9 e0 02 00 00       	jmpq   8004212ba9 <_dwarf_attr_init+0x568>
	case DW_FORM_data2:
	case DW_FORM_ref2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  80042128c9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042128d0:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042128d4:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042128db:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042128df:	ba 02 00 00 00       	mov    $0x2,%edx
  80042128e4:	48 89 cf             	mov    %rcx,%rdi
  80042128e7:	ff d0                	callq  *%rax
  80042128e9:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042128ed:	e9 b7 02 00 00       	jmpq   8004212ba9 <_dwarf_attr_init+0x568>
	case DW_FORM_data4:
	case DW_FORM_ref4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  80042128f2:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042128f9:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042128fd:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004212904:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212908:	ba 04 00 00 00       	mov    $0x4,%edx
  800421290d:	48 89 cf             	mov    %rcx,%rdi
  8004212910:	ff d0                	callq  *%rax
  8004212912:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004212916:	e9 8e 02 00 00       	jmpq   8004212ba9 <_dwarf_attr_init+0x568>
	case DW_FORM_data8:
	case DW_FORM_ref8:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 8);
  800421291b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004212922:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212926:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421292d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212931:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212936:	48 89 cf             	mov    %rcx,%rdi
  8004212939:	ff d0                	callq  *%rax
  800421293b:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421293f:	e9 65 02 00 00       	jmpq   8004212ba9 <_dwarf_attr_init+0x568>
	case DW_FORM_indirect:
		form = _dwarf_read_uleb128(ds_data, offsetp);
  8004212944:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421294b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421294f:	48 89 d6             	mov    %rdx,%rsi
  8004212952:	48 89 c7             	mov    %rax,%rdi
  8004212955:	48 b8 d1 1c 21 04 80 	movabs $0x8004211cd1,%rax
  800421295c:	00 00 00 
  800421295f:	ff d0                	callq  *%rax
  8004212961:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
		return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
  8004212968:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
  800421296f:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  8004212976:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  800421297d:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004212984:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421298b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004212992:	48 83 ec 08          	sub    $0x8,%rsp
  8004212996:	6a 01                	pushq  $0x1
  8004212998:	4d 89 c1             	mov    %r8,%r9
  800421299b:	49 89 f8             	mov    %rdi,%r8
  800421299e:	48 89 c7             	mov    %rax,%rdi
  80042129a1:	48 b8 41 26 21 04 80 	movabs $0x8004212641,%rax
  80042129a8:	00 00 00 
  80042129ab:	ff d0                	callq  *%rax
  80042129ad:	48 83 c4 10          	add    $0x10,%rsp
  80042129b1:	e9 21 03 00 00       	jmpq   8004212cd7 <_dwarf_attr_init+0x696>
	case DW_FORM_ref_addr:
		if (cu->version == 2)
  80042129b6:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042129bd:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042129c1:	66 83 f8 02          	cmp    $0x2,%ax
  80042129c5:	75 32                	jne    80042129f9 <_dwarf_attr_init+0x3b8>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  80042129c7:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042129ce:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042129d2:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  80042129d9:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  80042129dd:	0f b6 d2             	movzbl %dl,%edx
  80042129e0:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042129e7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042129eb:	48 89 cf             	mov    %rcx,%rdi
  80042129ee:	ff d0                	callq  *%rax
  80042129f0:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		else if (cu->version == 3)
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
		break;
  80042129f4:	e9 af 01 00 00       	jmpq   8004212ba8 <_dwarf_attr_init+0x567>
		form = _dwarf_read_uleb128(ds_data, offsetp);
		return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
	case DW_FORM_ref_addr:
		if (cu->version == 2)
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
		else if (cu->version == 3)
  80042129f9:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004212a00:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004212a04:	66 83 f8 03          	cmp    $0x3,%ax
  8004212a08:	0f 85 9a 01 00 00    	jne    8004212ba8 <_dwarf_attr_init+0x567>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004212a0e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004212a15:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212a19:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004212a1d:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004212a24:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212a28:	48 89 cf             	mov    %rcx,%rdi
  8004212a2b:	ff d0                	callq  *%rax
  8004212a2d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004212a31:	e9 72 01 00 00       	jmpq   8004212ba8 <_dwarf_attr_init+0x567>
	case DW_FORM_ref_udata:
	case DW_FORM_udata:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  8004212a36:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004212a3d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212a41:	48 89 d6             	mov    %rdx,%rsi
  8004212a44:	48 89 c7             	mov    %rax,%rdi
  8004212a47:	48 b8 d1 1c 21 04 80 	movabs $0x8004211cd1,%rax
  8004212a4e:	00 00 00 
  8004212a51:	ff d0                	callq  *%rax
  8004212a53:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004212a57:	e9 4d 01 00 00       	jmpq   8004212ba9 <_dwarf_attr_init+0x568>
	case DW_FORM_sdata:
		atref.u[0].s64 = _dwarf_read_sleb128(ds_data, offsetp);
  8004212a5c:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004212a63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212a67:	48 89 d6             	mov    %rdx,%rsi
  8004212a6a:	48 89 c7             	mov    %rax,%rdi
  8004212a6d:	48 b8 2d 1c 21 04 80 	movabs $0x8004211c2d,%rax
  8004212a74:	00 00 00 
  8004212a77:	ff d0                	callq  *%rax
  8004212a79:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004212a7d:	e9 27 01 00 00       	jmpq   8004212ba9 <_dwarf_attr_init+0x568>
	case DW_FORM_sec_offset:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004212a82:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004212a89:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212a8d:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004212a91:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004212a98:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212a9c:	48 89 cf             	mov    %rcx,%rdi
  8004212a9f:	ff d0                	callq  *%rax
  8004212aa1:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004212aa5:	e9 ff 00 00 00       	jmpq   8004212ba9 <_dwarf_attr_init+0x568>
	case DW_FORM_string:
		atref.u[0].s =(char*) _dwarf_read_string(ds_data, (uint64_t)ds->ds_size, offsetp);
  8004212aaa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212aae:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004212ab2:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004212ab9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212abd:	48 89 ce             	mov    %rcx,%rsi
  8004212ac0:	48 89 c7             	mov    %rax,%rdi
  8004212ac3:	48 b8 4f 1e 21 04 80 	movabs $0x8004211e4f,%rax
  8004212aca:	00 00 00 
  8004212acd:	ff d0                	callq  *%rax
  8004212acf:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004212ad3:	e9 d1 00 00 00       	jmpq   8004212ba9 <_dwarf_attr_init+0x568>
	case DW_FORM_strp:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004212ad8:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004212adf:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212ae3:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004212ae7:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004212aee:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212af2:	48 89 cf             	mov    %rcx,%rdi
  8004212af5:	ff d0                	callq  *%rax
  8004212af7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		str = _dwarf_find_section(".debug_str");
  8004212afb:	48 bf 92 15 22 04 80 	movabs $0x8004221592,%rdi
  8004212b02:	00 00 00 
  8004212b05:	48 b8 ca 67 21 04 80 	movabs $0x80042167ca,%rax
  8004212b0c:	00 00 00 
  8004212b0f:	ff d0                	callq  *%rax
  8004212b11:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		assert(str != NULL);
  8004212b15:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004212b1a:	75 35                	jne    8004212b51 <_dwarf_attr_init+0x510>
  8004212b1c:	48 b9 9d 15 22 04 80 	movabs $0x800422159d,%rcx
  8004212b23:	00 00 00 
  8004212b26:	48 ba 2a 15 22 04 80 	movabs $0x800422152a,%rdx
  8004212b2d:	00 00 00 
  8004212b30:	be 51 02 00 00       	mov    $0x251,%esi
  8004212b35:	48 bf 3f 15 22 04 80 	movabs $0x800422153f,%rdi
  8004212b3c:	00 00 00 
  8004212b3f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212b44:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004212b4b:	00 00 00 
  8004212b4e:	41 ff d0             	callq  *%r8
		//atref.u[1].s = (char *)(elf_base_ptr + str->sh_offset) + atref.u[0].u64;
		atref.u[1].s = (char *)str->ds_data + atref.u[0].u64;
  8004212b51:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212b55:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004212b59:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212b5d:	48 01 d0             	add    %rdx,%rax
  8004212b60:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004212b64:	eb 43                	jmp    8004212ba9 <_dwarf_attr_init+0x568>
	case DW_FORM_ref_sig8:
		atref.u[0].u64 = 8;
  8004212b66:	48 c7 45 98 08 00 00 	movq   $0x8,-0x68(%rbp)
  8004212b6d:	00 
		atref.u[1].u8p = (uint8_t*)(_dwarf_read_block(ds_data, offsetp, atref.u[0].u64));
  8004212b6e:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004212b72:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004212b79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b7d:	48 89 ce             	mov    %rcx,%rsi
  8004212b80:	48 89 c7             	mov    %rax,%rdi
  8004212b83:	48 b8 de 1e 21 04 80 	movabs $0x8004211ede,%rax
  8004212b8a:	00 00 00 
  8004212b8d:	ff d0                	callq  *%rax
  8004212b8f:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004212b93:	eb 14                	jmp    8004212ba9 <_dwarf_attr_init+0x568>
	case DW_FORM_flag_present:
		/* This form has no value encoded in the DIE. */
		atref.u[0].u64 = 1;
  8004212b95:	48 c7 45 98 01 00 00 	movq   $0x1,-0x68(%rbp)
  8004212b9c:	00 
		break;
  8004212b9d:	eb 0a                	jmp    8004212ba9 <_dwarf_attr_init+0x568>
	default:
		//DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
		ret = DW_DLE_ATTR_FORM_BAD;
  8004212b9f:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%rbp)
		break;
  8004212ba6:	eb 01                	jmp    8004212ba9 <_dwarf_attr_init+0x568>
	case DW_FORM_ref_addr:
		if (cu->version == 2)
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
		else if (cu->version == 3)
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
		break;
  8004212ba8:	90                   	nop
		//DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
		ret = DW_DLE_ATTR_FORM_BAD;
		break;
	}

	if (ret == DW_DLE_NONE) {
  8004212ba9:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004212bad:	0f 85 21 01 00 00    	jne    8004212cd4 <_dwarf_attr_init+0x693>
		if (form == DW_FORM_block || form == DW_FORM_block1 ||
  8004212bb3:	48 83 bd 40 ff ff ff 	cmpq   $0x9,-0xc0(%rbp)
  8004212bba:	09 
  8004212bbb:	74 1e                	je     8004212bdb <_dwarf_attr_init+0x59a>
  8004212bbd:	48 83 bd 40 ff ff ff 	cmpq   $0xa,-0xc0(%rbp)
  8004212bc4:	0a 
  8004212bc5:	74 14                	je     8004212bdb <_dwarf_attr_init+0x59a>
  8004212bc7:	48 83 bd 40 ff ff ff 	cmpq   $0x3,-0xc0(%rbp)
  8004212bce:	03 
  8004212bcf:	74 0a                	je     8004212bdb <_dwarf_attr_init+0x59a>
		    form == DW_FORM_block2 || form == DW_FORM_block4) {
  8004212bd1:	48 83 bd 40 ff ff ff 	cmpq   $0x4,-0xc0(%rbp)
  8004212bd8:	04 
  8004212bd9:	75 10                	jne    8004212beb <_dwarf_attr_init+0x5aa>
			atref.at_block.bl_len = atref.u[0].u64;
  8004212bdb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212bdf:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			atref.at_block.bl_data = atref.u[1].u8p;
  8004212be3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212be7:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
  8004212beb:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004212bef:	48 83 f8 03          	cmp    $0x3,%rax
  8004212bf3:	75 39                	jne    8004212c2e <_dwarf_attr_init+0x5ed>
			switch (atref.at_form) {
  8004212bf5:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004212bf9:	48 83 f8 08          	cmp    $0x8,%rax
  8004212bfd:	74 1c                	je     8004212c1b <_dwarf_attr_init+0x5da>
  8004212bff:	48 83 f8 0e          	cmp    $0xe,%rax
  8004212c03:	74 02                	je     8004212c07 <_dwarf_attr_init+0x5c6>
				break;
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
				break;
			default:
				break;
  8004212c05:	eb 27                	jmp    8004212c2e <_dwarf_attr_init+0x5ed>
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
			switch (atref.at_form) {
			case DW_FORM_strp:
				ret_die->die_name = atref.u[1].s;
  8004212c07:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004212c0b:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004212c12:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  8004212c19:	eb 13                	jmp    8004212c2e <_dwarf_attr_init+0x5ed>
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
  8004212c1b:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004212c1f:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004212c26:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  8004212c2d:	90                   	nop
			default:
				break;
			}
		}
		ret_die->die_attr[ret_die->die_attr_count++] = atref;
  8004212c2e:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004212c35:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004212c3c:	8d 48 01             	lea    0x1(%rax),%ecx
  8004212c3f:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  8004212c46:	88 8a 58 03 00 00    	mov    %cl,0x358(%rdx)
  8004212c4c:	0f b6 c0             	movzbl %al,%eax
  8004212c4f:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  8004212c56:	48 63 d0             	movslq %eax,%rdx
  8004212c59:	48 89 d0             	mov    %rdx,%rax
  8004212c5c:	48 01 c0             	add    %rax,%rax
  8004212c5f:	48 01 d0             	add    %rdx,%rax
  8004212c62:	48 c1 e0 05          	shl    $0x5,%rax
  8004212c66:	48 01 c8             	add    %rcx,%rax
  8004212c69:	48 05 70 03 00 00    	add    $0x370,%rax
  8004212c6f:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004212c76:	48 89 10             	mov    %rdx,(%rax)
  8004212c79:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004212c80:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004212c84:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004212c88:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004212c8c:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  8004212c90:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004212c94:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004212c98:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004212c9c:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004212ca0:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004212ca4:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004212ca8:	48 89 50 30          	mov    %rdx,0x30(%rax)
  8004212cac:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004212cb0:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004212cb4:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004212cb8:	48 89 50 40          	mov    %rdx,0x40(%rax)
  8004212cbc:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212cc0:	48 89 50 48          	mov    %rdx,0x48(%rax)
  8004212cc4:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212cc8:	48 89 50 50          	mov    %rdx,0x50(%rax)
  8004212ccc:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212cd0:	48 89 50 58          	mov    %rdx,0x58(%rax)
	}

	return (ret);
  8004212cd4:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004212cd7:	c9                   	leaveq 
  8004212cd8:	c3                   	retq   

0000008004212cd9 <dwarf_search_die_within_cu>:

int
dwarf_search_die_within_cu(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t offset, Dwarf_Die *ret_die, int search_sibling)
{
  8004212cd9:	55                   	push   %rbp
  8004212cda:	48 89 e5             	mov    %rsp,%rbp
  8004212cdd:	48 81 ec 90 03 00 00 	sub    $0x390,%rsp
  8004212ce4:	48 89 bd 88 fc ff ff 	mov    %rdi,-0x378(%rbp)
  8004212ceb:	48 89 b5 80 fc ff ff 	mov    %rsi,-0x380(%rbp)
  8004212cf2:	48 89 95 78 fc ff ff 	mov    %rdx,-0x388(%rbp)
  8004212cf9:	89 8d 74 fc ff ff    	mov    %ecx,-0x38c(%rbp)
	uint64_t abnum;
	uint64_t die_offset;
	int ret, level;
	int i;

	assert(dbg);
  8004212cff:	48 83 bd 88 fc ff ff 	cmpq   $0x0,-0x378(%rbp)
  8004212d06:	00 
  8004212d07:	75 35                	jne    8004212d3e <dwarf_search_die_within_cu+0x65>
  8004212d09:	48 b9 b8 16 22 04 80 	movabs $0x80042216b8,%rcx
  8004212d10:	00 00 00 
  8004212d13:	48 ba 2a 15 22 04 80 	movabs $0x800422152a,%rdx
  8004212d1a:	00 00 00 
  8004212d1d:	be 86 02 00 00       	mov    $0x286,%esi
  8004212d22:	48 bf 3f 15 22 04 80 	movabs $0x800422153f,%rdi
  8004212d29:	00 00 00 
  8004212d2c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212d31:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004212d38:	00 00 00 
  8004212d3b:	41 ff d0             	callq  *%r8
	//assert(cu);
	assert(ret_die);
  8004212d3e:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
  8004212d45:	00 
  8004212d46:	75 35                	jne    8004212d7d <dwarf_search_die_within_cu+0xa4>
  8004212d48:	48 b9 bc 16 22 04 80 	movabs $0x80042216bc,%rcx
  8004212d4f:	00 00 00 
  8004212d52:	48 ba 2a 15 22 04 80 	movabs $0x800422152a,%rdx
  8004212d59:	00 00 00 
  8004212d5c:	be 88 02 00 00       	mov    $0x288,%esi
  8004212d61:	48 bf 3f 15 22 04 80 	movabs $0x800422153f,%rdi
  8004212d68:	00 00 00 
  8004212d6b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212d70:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004212d77:	00 00 00 
  8004212d7a:	41 ff d0             	callq  *%r8

	level = 1;
  8004212d7d:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004212d84:	e9 fa 01 00 00       	jmpq   8004212f83 <dwarf_search_die_within_cu+0x2aa>

		die_offset = offset;
  8004212d89:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004212d90:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		abnum = _dwarf_read_uleb128((uint8_t *)dbg->dbg_info_offset_elf, &offset);
  8004212d94:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004212d9b:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212d9f:	48 89 c2             	mov    %rax,%rdx
  8004212da2:	48 8d 85 80 fc ff ff 	lea    -0x380(%rbp),%rax
  8004212da9:	48 89 c6             	mov    %rax,%rsi
  8004212dac:	48 89 d7             	mov    %rdx,%rdi
  8004212daf:	48 b8 d1 1c 21 04 80 	movabs $0x8004211cd1,%rax
  8004212db6:	00 00 00 
  8004212db9:	ff d0                	callq  *%rax
  8004212dbb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		if (abnum == 0) {
  8004212dbf:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004212dc4:	75 22                	jne    8004212de8 <dwarf_search_die_within_cu+0x10f>
			if (level == 0 || !search_sibling) {
  8004212dc6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004212dca:	74 09                	je     8004212dd5 <dwarf_search_die_within_cu+0xfc>
  8004212dcc:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  8004212dd3:	75 0a                	jne    8004212ddf <dwarf_search_die_within_cu+0x106>
				//No more entry
				return (DW_DLE_NO_ENTRY);
  8004212dd5:	b8 04 00 00 00       	mov    $0x4,%eax
  8004212dda:	e9 d4 01 00 00       	jmpq   8004212fb3 <dwarf_search_die_within_cu+0x2da>
			}
			/*
			 * Return to previous DIE level.
			 */
			level--;
  8004212ddf:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
			continue;
  8004212de3:	e9 9b 01 00 00       	jmpq   8004212f83 <dwarf_search_die_within_cu+0x2aa>
		}

		if ((ret = _dwarf_abbrev_find(dbg, cu, abnum, &ab)) != DW_DLE_NONE)
  8004212de8:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  8004212def:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212df3:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004212dfa:	48 83 ec 08          	sub    $0x8,%rsp
  8004212dfe:	ff 75 40             	pushq  0x40(%rbp)
  8004212e01:	ff 75 38             	pushq  0x38(%rbp)
  8004212e04:	ff 75 30             	pushq  0x30(%rbp)
  8004212e07:	ff 75 28             	pushq  0x28(%rbp)
  8004212e0a:	ff 75 20             	pushq  0x20(%rbp)
  8004212e0d:	ff 75 18             	pushq  0x18(%rbp)
  8004212e10:	ff 75 10             	pushq  0x10(%rbp)
  8004212e13:	48 89 ce             	mov    %rcx,%rsi
  8004212e16:	48 89 c7             	mov    %rax,%rdi
  8004212e19:	48 b8 37 25 21 04 80 	movabs $0x8004212537,%rax
  8004212e20:	00 00 00 
  8004212e23:	ff d0                	callq  *%rax
  8004212e25:	48 83 c4 40          	add    $0x40,%rsp
  8004212e29:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004212e2c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004212e30:	74 08                	je     8004212e3a <dwarf_search_die_within_cu+0x161>
			return (ret);
  8004212e32:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004212e35:	e9 79 01 00 00       	jmpq   8004212fb3 <dwarf_search_die_within_cu+0x2da>
		ret_die->die_offset = die_offset;
  8004212e3a:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212e41:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004212e45:	48 89 10             	mov    %rdx,(%rax)
		ret_die->die_abnum  = abnum;
  8004212e48:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212e4f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212e53:	48 89 50 10          	mov    %rdx,0x10(%rax)
		ret_die->die_ab  = ab;
  8004212e57:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212e5e:	48 8d 50 20          	lea    0x20(%rax),%rdx
  8004212e62:	48 8d 85 b0 fc ff ff 	lea    -0x350(%rbp),%rax
  8004212e69:	b9 66 00 00 00       	mov    $0x66,%ecx
  8004212e6e:	48 89 d7             	mov    %rdx,%rdi
  8004212e71:	48 89 c6             	mov    %rax,%rsi
  8004212e74:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		ret_die->die_attr_count = 0;
  8004212e77:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212e7e:	c6 80 58 03 00 00 00 	movb   $0x0,0x358(%rax)
		ret_die->die_tag = ab.ab_tag;
  8004212e85:	48 8b 95 b8 fc ff ff 	mov    -0x348(%rbp),%rdx
  8004212e8c:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212e93:	48 89 50 18          	mov    %rdx,0x18(%rax)
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  8004212e97:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8004212e9e:	e9 91 00 00 00       	jmpq   8004212f34 <dwarf_search_die_within_cu+0x25b>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
  8004212ea3:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004212ea6:	48 63 d0             	movslq %eax,%rdx
  8004212ea9:	48 89 d0             	mov    %rdx,%rax
  8004212eac:	48 01 c0             	add    %rax,%rax
  8004212eaf:	48 01 d0             	add    %rdx,%rax
  8004212eb2:	48 c1 e0 03          	shl    $0x3,%rax
  8004212eb6:	48 01 e8             	add    %rbp,%rax
  8004212eb9:	48 2d 18 03 00 00    	sub    $0x318,%rax
  8004212ebf:	48 8b 08             	mov    (%rax),%rcx
  8004212ec2:	48 8d b5 b0 fc ff ff 	lea    -0x350(%rbp),%rsi
  8004212ec9:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004212ecc:	48 63 d0             	movslq %eax,%rdx
  8004212ecf:	48 89 d0             	mov    %rdx,%rax
  8004212ed2:	48 01 c0             	add    %rax,%rax
  8004212ed5:	48 01 d0             	add    %rdx,%rax
  8004212ed8:	48 c1 e0 03          	shl    $0x3,%rax
  8004212edc:	48 83 c0 30          	add    $0x30,%rax
  8004212ee0:	48 8d 3c 06          	lea    (%rsi,%rax,1),%rdi
  8004212ee4:	48 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%rdx
  8004212eeb:	48 8d b5 80 fc ff ff 	lea    -0x380(%rbp),%rsi
  8004212ef2:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004212ef9:	48 83 ec 08          	sub    $0x8,%rsp
  8004212efd:	6a 00                	pushq  $0x0
  8004212eff:	49 89 c9             	mov    %rcx,%r9
  8004212f02:	49 89 f8             	mov    %rdi,%r8
  8004212f05:	48 89 d1             	mov    %rdx,%rcx
  8004212f08:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  8004212f0c:	48 89 c7             	mov    %rax,%rdi
  8004212f0f:	48 b8 41 26 21 04 80 	movabs $0x8004212641,%rax
  8004212f16:	00 00 00 
  8004212f19:	ff d0                	callq  *%rax
  8004212f1b:	48 83 c4 10          	add    $0x10,%rsp
  8004212f1f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004212f22:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004212f26:	74 08                	je     8004212f30 <dwarf_search_die_within_cu+0x257>
				return (ret);
  8004212f28:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004212f2b:	e9 83 00 00 00       	jmpq   8004212fb3 <dwarf_search_die_within_cu+0x2da>
		ret_die->die_attr_count = 0;
		ret_die->die_tag = ab.ab_tag;
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  8004212f30:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004212f34:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004212f37:	48 63 d0             	movslq %eax,%rdx
  8004212f3a:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  8004212f41:	48 39 c2             	cmp    %rax,%rdx
  8004212f44:	0f 82 59 ff ff ff    	jb     8004212ea3 <dwarf_search_die_within_cu+0x1ca>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
				return (ret);
		}

		ret_die->die_next_off = offset;
  8004212f4a:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
  8004212f51:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212f58:	48 89 50 08          	mov    %rdx,0x8(%rax)
		if (search_sibling && level > 0) {
  8004212f5c:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  8004212f63:	74 17                	je     8004212f7c <dwarf_search_die_within_cu+0x2a3>
  8004212f65:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004212f69:	7e 11                	jle    8004212f7c <dwarf_search_die_within_cu+0x2a3>
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  8004212f6b:	0f b6 85 c0 fc ff ff 	movzbl -0x340(%rbp),%eax
  8004212f72:	3c 01                	cmp    $0x1,%al
  8004212f74:	75 0d                	jne    8004212f83 <dwarf_search_die_within_cu+0x2aa>
				/* Advance to next DIE level. */
				level++;
  8004212f76:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
		}

		ret_die->die_next_off = offset;
		if (search_sibling && level > 0) {
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  8004212f7a:	eb 07                	jmp    8004212f83 <dwarf_search_die_within_cu+0x2aa>
				/* Advance to next DIE level. */
				level++;
			}
		} else {
			//*ret_die = die;
			return (DW_DLE_NONE);
  8004212f7c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212f81:	eb 30                	jmp    8004212fb3 <dwarf_search_die_within_cu+0x2da>
	//assert(cu);
	assert(ret_die);

	level = 1;

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004212f83:	48 8b 55 30          	mov    0x30(%rbp),%rdx
  8004212f87:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004212f8e:	48 39 c2             	cmp    %rax,%rdx
  8004212f91:	76 1b                	jbe    8004212fae <dwarf_search_die_within_cu+0x2d5>
  8004212f93:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004212f9a:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004212f9e:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004212fa5:	48 39 c2             	cmp    %rax,%rdx
  8004212fa8:	0f 87 db fd ff ff    	ja     8004212d89 <dwarf_search_die_within_cu+0xb0>
			//*ret_die = die;
			return (DW_DLE_NONE);
		}
	}

	return (DW_DLE_NO_ENTRY);
  8004212fae:	b8 04 00 00 00       	mov    $0x4,%eax
}
  8004212fb3:	c9                   	leaveq 
  8004212fb4:	c3                   	retq   

0000008004212fb5 <dwarf_offdie>:

//Return 0 on success
int
dwarf_offdie(Dwarf_Debug dbg, uint64_t offset, Dwarf_Die *ret_die, Dwarf_CU cu)
{
  8004212fb5:	55                   	push   %rbp
  8004212fb6:	48 89 e5             	mov    %rsp,%rbp
  8004212fb9:	48 83 ec 30          	sub    $0x30,%rsp
  8004212fbd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004212fc1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004212fc5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int ret;

	assert(dbg);
  8004212fc9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004212fce:	75 35                	jne    8004213005 <dwarf_offdie+0x50>
  8004212fd0:	48 b9 b8 16 22 04 80 	movabs $0x80042216b8,%rcx
  8004212fd7:	00 00 00 
  8004212fda:	48 ba 2a 15 22 04 80 	movabs $0x800422152a,%rdx
  8004212fe1:	00 00 00 
  8004212fe4:	be c4 02 00 00       	mov    $0x2c4,%esi
  8004212fe9:	48 bf 3f 15 22 04 80 	movabs $0x800422153f,%rdi
  8004212ff0:	00 00 00 
  8004212ff3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212ff8:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004212fff:	00 00 00 
  8004213002:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004213005:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421300a:	75 35                	jne    8004213041 <dwarf_offdie+0x8c>
  800421300c:	48 b9 bc 16 22 04 80 	movabs $0x80042216bc,%rcx
  8004213013:	00 00 00 
  8004213016:	48 ba 2a 15 22 04 80 	movabs $0x800422152a,%rdx
  800421301d:	00 00 00 
  8004213020:	be c5 02 00 00       	mov    $0x2c5,%esi
  8004213025:	48 bf 3f 15 22 04 80 	movabs $0x800422153f,%rdi
  800421302c:	00 00 00 
  800421302f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213034:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421303b:	00 00 00 
  800421303e:	41 ff d0             	callq  *%r8

	/* First search the current CU. */
	if (offset < cu.cu_next_offset) {
  8004213041:	48 8b 45 30          	mov    0x30(%rbp),%rax
  8004213045:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004213049:	76 45                	jbe    8004213090 <dwarf_offdie+0xdb>
		ret = dwarf_search_die_within_cu(dbg, cu, offset, ret_die, 0);
  800421304b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421304f:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8004213053:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213057:	48 83 ec 08          	sub    $0x8,%rsp
  800421305b:	ff 75 40             	pushq  0x40(%rbp)
  800421305e:	ff 75 38             	pushq  0x38(%rbp)
  8004213061:	ff 75 30             	pushq  0x30(%rbp)
  8004213064:	ff 75 28             	pushq  0x28(%rbp)
  8004213067:	ff 75 20             	pushq  0x20(%rbp)
  800421306a:	ff 75 18             	pushq  0x18(%rbp)
  800421306d:	ff 75 10             	pushq  0x10(%rbp)
  8004213070:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004213075:	48 89 c7             	mov    %rax,%rdi
  8004213078:	48 b8 d9 2c 21 04 80 	movabs $0x8004212cd9,%rax
  800421307f:	00 00 00 
  8004213082:	ff d0                	callq  *%rax
  8004213084:	48 83 c4 40          	add    $0x40,%rsp
  8004213088:	89 45 fc             	mov    %eax,-0x4(%rbp)
		return ret;
  800421308b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421308e:	eb 05                	jmp    8004213095 <dwarf_offdie+0xe0>
	}

	/*TODO: Search other CU*/
	return DW_DLV_OK;
  8004213090:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213095:	c9                   	leaveq 
  8004213096:	c3                   	retq   

0000008004213097 <_dwarf_attr_find>:

Dwarf_Attribute*
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
  8004213097:	55                   	push   %rbp
  8004213098:	48 89 e5             	mov    %rsp,%rbp
  800421309b:	48 83 ec 20          	sub    $0x20,%rsp
  800421309f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042130a3:	89 f0                	mov    %esi,%eax
  80042130a5:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Attribute *myat = NULL;
  80042130a9:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042130b0:	00 
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  80042130b1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042130b8:	eb 57                	jmp    8004213111 <_dwarf_attr_find+0x7a>
	{
		if (die->die_attr[i].at_attrib == attr)
  80042130ba:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042130be:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042130c1:	48 63 d0             	movslq %eax,%rdx
  80042130c4:	48 89 d0             	mov    %rdx,%rax
  80042130c7:	48 01 c0             	add    %rax,%rax
  80042130ca:	48 01 d0             	add    %rdx,%rax
  80042130cd:	48 c1 e0 05          	shl    $0x5,%rax
  80042130d1:	48 01 c8             	add    %rcx,%rax
  80042130d4:	48 05 80 03 00 00    	add    $0x380,%rax
  80042130da:	48 8b 10             	mov    (%rax),%rdx
  80042130dd:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80042130e1:	48 39 c2             	cmp    %rax,%rdx
  80042130e4:	75 27                	jne    800421310d <_dwarf_attr_find+0x76>
		{
			myat = &(die->die_attr[i]);
  80042130e6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042130e9:	48 63 d0             	movslq %eax,%rdx
  80042130ec:	48 89 d0             	mov    %rdx,%rax
  80042130ef:	48 01 c0             	add    %rax,%rax
  80042130f2:	48 01 d0             	add    %rdx,%rax
  80042130f5:	48 c1 e0 05          	shl    $0x5,%rax
  80042130f9:	48 8d 90 70 03 00 00 	lea    0x370(%rax),%rdx
  8004213100:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213104:	48 01 d0             	add    %rdx,%rax
  8004213107:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800421310b:	eb 17                	jmp    8004213124 <_dwarf_attr_find+0x8d>
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
	Dwarf_Attribute *myat = NULL;
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  800421310d:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004213111:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213115:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  800421311c:	0f b6 c0             	movzbl %al,%eax
  800421311f:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8004213122:	7f 96                	jg     80042130ba <_dwarf_attr_find+0x23>
			myat = &(die->die_attr[i]);
			break;
		}
	}

	return myat;
  8004213124:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004213128:	c9                   	leaveq 
  8004213129:	c3                   	retq   

000000800421312a <dwarf_siblingof>:

//Return 0 on success
int
dwarf_siblingof(Dwarf_Debug dbg, Dwarf_Die *die, Dwarf_Die *ret_die,
		Dwarf_CU *cu)
{
  800421312a:	55                   	push   %rbp
  800421312b:	48 89 e5             	mov    %rsp,%rbp
  800421312e:	48 83 ec 40          	sub    $0x40,%rsp
  8004213132:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004213136:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421313a:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800421313e:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	Dwarf_Attribute *at;
	uint64_t offset;
	int ret, search_sibling;

	assert(dbg);
  8004213142:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004213147:	75 35                	jne    800421317e <dwarf_siblingof+0x54>
  8004213149:	48 b9 b8 16 22 04 80 	movabs $0x80042216b8,%rcx
  8004213150:	00 00 00 
  8004213153:	48 ba 2a 15 22 04 80 	movabs $0x800422152a,%rdx
  800421315a:	00 00 00 
  800421315d:	be ec 02 00 00       	mov    $0x2ec,%esi
  8004213162:	48 bf 3f 15 22 04 80 	movabs $0x800422153f,%rdi
  8004213169:	00 00 00 
  800421316c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213171:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004213178:	00 00 00 
  800421317b:	41 ff d0             	callq  *%r8
	assert(ret_die);
  800421317e:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004213183:	75 35                	jne    80042131ba <dwarf_siblingof+0x90>
  8004213185:	48 b9 bc 16 22 04 80 	movabs $0x80042216bc,%rcx
  800421318c:	00 00 00 
  800421318f:	48 ba 2a 15 22 04 80 	movabs $0x800422152a,%rdx
  8004213196:	00 00 00 
  8004213199:	be ed 02 00 00       	mov    $0x2ed,%esi
  800421319e:	48 bf 3f 15 22 04 80 	movabs $0x800422153f,%rdi
  80042131a5:	00 00 00 
  80042131a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042131ad:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042131b4:	00 00 00 
  80042131b7:	41 ff d0             	callq  *%r8
	assert(cu);
  80042131ba:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  80042131bf:	75 35                	jne    80042131f6 <dwarf_siblingof+0xcc>
  80042131c1:	48 b9 c4 16 22 04 80 	movabs $0x80042216c4,%rcx
  80042131c8:	00 00 00 
  80042131cb:	48 ba 2a 15 22 04 80 	movabs $0x800422152a,%rdx
  80042131d2:	00 00 00 
  80042131d5:	be ee 02 00 00       	mov    $0x2ee,%esi
  80042131da:	48 bf 3f 15 22 04 80 	movabs $0x800422153f,%rdi
  80042131e1:	00 00 00 
  80042131e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042131e9:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042131f0:	00 00 00 
  80042131f3:	41 ff d0             	callq  *%r8

	/* Application requests the first DIE in this CU. */
	if (die == NULL)
  80042131f6:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042131fb:	75 44                	jne    8004213241 <dwarf_siblingof+0x117>
		return (dwarf_offdie(dbg, cu->cu_die_offset, ret_die, *cu));
  80042131fd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213201:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004213205:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213209:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421320d:	48 83 ec 08          	sub    $0x8,%rsp
  8004213211:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213215:	ff 70 30             	pushq  0x30(%rax)
  8004213218:	ff 70 28             	pushq  0x28(%rax)
  800421321b:	ff 70 20             	pushq  0x20(%rax)
  800421321e:	ff 70 18             	pushq  0x18(%rax)
  8004213221:	ff 70 10             	pushq  0x10(%rax)
  8004213224:	ff 70 08             	pushq  0x8(%rax)
  8004213227:	ff 30                	pushq  (%rax)
  8004213229:	48 89 cf             	mov    %rcx,%rdi
  800421322c:	48 b8 b5 2f 21 04 80 	movabs $0x8004212fb5,%rax
  8004213233:	00 00 00 
  8004213236:	ff d0                	callq  *%rax
  8004213238:	48 83 c4 40          	add    $0x40,%rsp
  800421323c:	e9 e9 00 00 00       	jmpq   800421332a <dwarf_siblingof+0x200>

	/*
	 * If the DIE doesn't have any children, its sibling sits next
	 * right to it.
	 */
	search_sibling = 0;
  8004213241:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004213248:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421324c:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004213250:	84 c0                	test   %al,%al
  8004213252:	75 0e                	jne    8004213262 <dwarf_siblingof+0x138>
		offset = die->die_next_off;
  8004213254:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213258:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421325c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004213260:	eb 6b                	jmp    80042132cd <dwarf_siblingof+0x1a3>
	else {
		/*
		 * Look for DW_AT_sibling attribute for the offset of
		 * its sibling.
		 */
		if ((at = _dwarf_attr_find(die, DW_AT_sibling)) != NULL) {
  8004213262:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213266:	be 01 00 00 00       	mov    $0x1,%esi
  800421326b:	48 89 c7             	mov    %rax,%rdi
  800421326e:	48 b8 97 30 21 04 80 	movabs $0x8004213097,%rax
  8004213275:	00 00 00 
  8004213278:	ff d0                	callq  *%rax
  800421327a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800421327e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004213283:	74 35                	je     80042132ba <dwarf_siblingof+0x190>
			if (at->at_form != DW_FORM_ref_addr)
  8004213285:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213289:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421328d:	48 83 f8 10          	cmp    $0x10,%rax
  8004213291:	74 19                	je     80042132ac <dwarf_siblingof+0x182>
				offset = at->u[0].u64 + cu->cu_offset;
  8004213293:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213297:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800421329b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421329f:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042132a3:	48 01 d0             	add    %rdx,%rax
  80042132a6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042132aa:	eb 21                	jmp    80042132cd <dwarf_siblingof+0x1a3>
			else
				offset = at->u[0].u64;
  80042132ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042132b0:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042132b4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042132b8:	eb 13                	jmp    80042132cd <dwarf_siblingof+0x1a3>
		} else {
			offset = die->die_next_off;
  80042132ba:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042132be:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042132c2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			search_sibling = 1;
  80042132c6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
		}
	}

	ret = dwarf_search_die_within_cu(dbg, *cu, offset, ret_die, search_sibling);
  80042132cd:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80042132d0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042132d4:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  80042132d8:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  80042132dc:	48 83 ec 08          	sub    $0x8,%rsp
  80042132e0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042132e4:	ff 70 30             	pushq  0x30(%rax)
  80042132e7:	ff 70 28             	pushq  0x28(%rax)
  80042132ea:	ff 70 20             	pushq  0x20(%rax)
  80042132ed:	ff 70 18             	pushq  0x18(%rax)
  80042132f0:	ff 70 10             	pushq  0x10(%rax)
  80042132f3:	ff 70 08             	pushq  0x8(%rax)
  80042132f6:	ff 30                	pushq  (%rax)
  80042132f8:	48 b8 d9 2c 21 04 80 	movabs $0x8004212cd9,%rax
  80042132ff:	00 00 00 
  8004213302:	ff d0                	callq  *%rax
  8004213304:	48 83 c4 40          	add    $0x40,%rsp
  8004213308:	89 45 e4             	mov    %eax,-0x1c(%rbp)


	if (ret == DW_DLE_NO_ENTRY) {
  800421330b:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  800421330f:	75 07                	jne    8004213318 <dwarf_siblingof+0x1ee>
		return (DW_DLV_NO_ENTRY);
  8004213311:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213316:	eb 12                	jmp    800421332a <dwarf_siblingof+0x200>
	} else if (ret != DW_DLE_NONE)
  8004213318:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421331c:	74 07                	je     8004213325 <dwarf_siblingof+0x1fb>
		return (DW_DLV_ERROR);
  800421331e:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213323:	eb 05                	jmp    800421332a <dwarf_siblingof+0x200>


	return (DW_DLV_OK);
  8004213325:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421332a:	c9                   	leaveq 
  800421332b:	c3                   	retq   

000000800421332c <dwarf_child>:

int
dwarf_child(Dwarf_Debug dbg, Dwarf_CU *cu, Dwarf_Die *die, Dwarf_Die *ret_die)
{
  800421332c:	55                   	push   %rbp
  800421332d:	48 89 e5             	mov    %rsp,%rbp
  8004213330:	48 83 ec 30          	sub    $0x30,%rsp
  8004213334:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004213338:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421333c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004213340:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	int ret;

	assert(die);
  8004213344:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004213349:	75 35                	jne    8004213380 <dwarf_child+0x54>
  800421334b:	48 b9 c7 16 22 04 80 	movabs $0x80042216c7,%rcx
  8004213352:	00 00 00 
  8004213355:	48 ba 2a 15 22 04 80 	movabs $0x800422152a,%rdx
  800421335c:	00 00 00 
  800421335f:	be 1c 03 00 00       	mov    $0x31c,%esi
  8004213364:	48 bf 3f 15 22 04 80 	movabs $0x800422153f,%rdi
  800421336b:	00 00 00 
  800421336e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213373:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421337a:	00 00 00 
  800421337d:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004213380:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004213385:	75 35                	jne    80042133bc <dwarf_child+0x90>
  8004213387:	48 b9 bc 16 22 04 80 	movabs $0x80042216bc,%rcx
  800421338e:	00 00 00 
  8004213391:	48 ba 2a 15 22 04 80 	movabs $0x800422152a,%rdx
  8004213398:	00 00 00 
  800421339b:	be 1d 03 00 00       	mov    $0x31d,%esi
  80042133a0:	48 bf 3f 15 22 04 80 	movabs $0x800422153f,%rdi
  80042133a7:	00 00 00 
  80042133aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042133af:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042133b6:	00 00 00 
  80042133b9:	41 ff d0             	callq  *%r8
	assert(dbg);
  80042133bc:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042133c1:	75 35                	jne    80042133f8 <dwarf_child+0xcc>
  80042133c3:	48 b9 b8 16 22 04 80 	movabs $0x80042216b8,%rcx
  80042133ca:	00 00 00 
  80042133cd:	48 ba 2a 15 22 04 80 	movabs $0x800422152a,%rdx
  80042133d4:	00 00 00 
  80042133d7:	be 1e 03 00 00       	mov    $0x31e,%esi
  80042133dc:	48 bf 3f 15 22 04 80 	movabs $0x800422153f,%rdi
  80042133e3:	00 00 00 
  80042133e6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042133eb:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042133f2:	00 00 00 
  80042133f5:	41 ff d0             	callq  *%r8
	assert(cu);
  80042133f8:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042133fd:	75 35                	jne    8004213434 <dwarf_child+0x108>
  80042133ff:	48 b9 c4 16 22 04 80 	movabs $0x80042216c4,%rcx
  8004213406:	00 00 00 
  8004213409:	48 ba 2a 15 22 04 80 	movabs $0x800422152a,%rdx
  8004213410:	00 00 00 
  8004213413:	be 1f 03 00 00       	mov    $0x31f,%esi
  8004213418:	48 bf 3f 15 22 04 80 	movabs $0x800422153f,%rdi
  800421341f:	00 00 00 
  8004213422:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213427:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421342e:	00 00 00 
  8004213431:	41 ff d0             	callq  *%r8

	if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004213434:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213438:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  800421343c:	84 c0                	test   %al,%al
  800421343e:	75 07                	jne    8004213447 <dwarf_child+0x11b>
		return (DW_DLE_NO_ENTRY);
  8004213440:	b8 04 00 00 00       	mov    $0x4,%eax
  8004213445:	eb 63                	jmp    80042134aa <dwarf_child+0x17e>

	ret = dwarf_search_die_within_cu(dbg, *cu, die->die_next_off, ret_die, 0);
  8004213447:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421344b:	48 8b 70 08          	mov    0x8(%rax),%rsi
  800421344f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213453:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  8004213457:	48 83 ec 08          	sub    $0x8,%rsp
  800421345b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421345f:	ff 70 30             	pushq  0x30(%rax)
  8004213462:	ff 70 28             	pushq  0x28(%rax)
  8004213465:	ff 70 20             	pushq  0x20(%rax)
  8004213468:	ff 70 18             	pushq  0x18(%rax)
  800421346b:	ff 70 10             	pushq  0x10(%rax)
  800421346e:	ff 70 08             	pushq  0x8(%rax)
  8004213471:	ff 30                	pushq  (%rax)
  8004213473:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004213478:	48 b8 d9 2c 21 04 80 	movabs $0x8004212cd9,%rax
  800421347f:	00 00 00 
  8004213482:	ff d0                	callq  *%rax
  8004213484:	48 83 c4 40          	add    $0x40,%rsp
  8004213488:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if (ret == DW_DLE_NO_ENTRY) {
  800421348b:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  800421348f:	75 07                	jne    8004213498 <dwarf_child+0x16c>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  8004213491:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213496:	eb 12                	jmp    80042134aa <dwarf_child+0x17e>
	} else if (ret != DW_DLE_NONE)
  8004213498:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800421349c:	74 07                	je     80042134a5 <dwarf_child+0x179>
		return (DW_DLV_ERROR);
  800421349e:	b8 01 00 00 00       	mov    $0x1,%eax
  80042134a3:	eb 05                	jmp    80042134aa <dwarf_child+0x17e>

	return (DW_DLV_OK);
  80042134a5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042134aa:	c9                   	leaveq 
  80042134ab:	c3                   	retq   

00000080042134ac <_dwarf_find_section_enhanced>:


int  _dwarf_find_section_enhanced(Dwarf_Section *ds)
{
  80042134ac:	55                   	push   %rbp
  80042134ad:	48 89 e5             	mov    %rsp,%rbp
  80042134b0:	48 83 ec 20          	sub    $0x20,%rsp
  80042134b4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *secthdr = _dwarf_find_section(ds->ds_name);
  80042134b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042134bc:	48 8b 00             	mov    (%rax),%rax
  80042134bf:	48 89 c7             	mov    %rax,%rdi
  80042134c2:	48 b8 ca 67 21 04 80 	movabs $0x80042167ca,%rax
  80042134c9:	00 00 00 
  80042134cc:	ff d0                	callq  *%rax
  80042134ce:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	ds->ds_data = secthdr->ds_data;//(Dwarf_Small*)((uint8_t *)elf_base_ptr + secthdr->sh_offset);
  80042134d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042134d6:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042134da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042134de:	48 89 50 08          	mov    %rdx,0x8(%rax)
	ds->ds_addr = secthdr->ds_addr;
  80042134e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042134e6:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042134ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042134ee:	48 89 50 10          	mov    %rdx,0x10(%rax)
	ds->ds_size = secthdr->ds_size;
  80042134f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042134f6:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042134fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042134fe:	48 89 50 18          	mov    %rdx,0x18(%rax)
	return 0;
  8004213502:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213507:	c9                   	leaveq 
  8004213508:	c3                   	retq   

0000008004213509 <_dwarf_frame_params_init>:

extern int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

void
_dwarf_frame_params_init(Dwarf_Debug dbg)
{
  8004213509:	55                   	push   %rbp
  800421350a:	48 89 e5             	mov    %rsp,%rbp
  800421350d:	48 83 ec 08          	sub    $0x8,%rsp
  8004213511:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	/* Initialise call frame related parameters. */
	dbg->dbg_frame_rule_table_size = DW_FRAME_LAST_REG_NUM;
  8004213515:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213519:	66 c7 40 48 42 00    	movw   $0x42,0x48(%rax)
	dbg->dbg_frame_rule_initial_value = DW_FRAME_REG_INITIAL_VALUE;
  800421351f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213523:	66 c7 40 4a 0b 04    	movw   $0x40b,0x4a(%rax)
	dbg->dbg_frame_cfa_value = DW_FRAME_CFA_COL3;
  8004213529:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421352d:	66 c7 40 4c 9c 05    	movw   $0x59c,0x4c(%rax)
	dbg->dbg_frame_same_value = DW_FRAME_SAME_VAL;
  8004213533:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213537:	66 c7 40 4e 0b 04    	movw   $0x40b,0x4e(%rax)
	dbg->dbg_frame_undefined_value = DW_FRAME_UNDEFINED_VAL;
  800421353d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213541:	66 c7 40 50 0a 04    	movw   $0x40a,0x50(%rax)
}
  8004213547:	90                   	nop
  8004213548:	c9                   	leaveq 
  8004213549:	c3                   	retq   

000000800421354a <dwarf_get_fde_at_pc>:

int
dwarf_get_fde_at_pc(Dwarf_Debug dbg, Dwarf_Addr pc,
		    struct _Dwarf_Fde *ret_fde, Dwarf_Cie cie,
		    Dwarf_Error *error)
{
  800421354a:	55                   	push   %rbp
  800421354b:	48 89 e5             	mov    %rsp,%rbp
  800421354e:	48 83 ec 40          	sub    $0x40,%rsp
  8004213552:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004213556:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421355a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800421355e:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004213562:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
	Dwarf_Fde fde = ret_fde;
  8004213566:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421356a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(fde, 0, sizeof(struct _Dwarf_Fde));
  800421356e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213572:	ba 80 00 00 00       	mov    $0x80,%edx
  8004213577:	be 00 00 00 00       	mov    $0x0,%esi
  800421357c:	48 89 c7             	mov    %rax,%rdi
  800421357f:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  8004213586:	00 00 00 
  8004213589:	ff d0                	callq  *%rax
	fde->fde_cie = cie;
  800421358b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421358f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213593:	48 89 50 08          	mov    %rdx,0x8(%rax)
	
	if (ret_fde == NULL)
  8004213597:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421359c:	75 60                	jne    80042135fe <dwarf_get_fde_at_pc+0xb4>
		return (DW_DLV_ERROR);
  800421359e:	b8 01 00 00 00       	mov    $0x1,%eax
  80042135a3:	eb 73                	jmp    8004213618 <dwarf_get_fde_at_pc+0xce>

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
  80042135a5:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80042135a9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042135ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042135b1:	be 01 00 00 00       	mov    $0x1,%esi
  80042135b6:	48 89 c7             	mov    %rax,%rdi
  80042135b9:	48 b8 ba 57 21 04 80 	movabs $0x80042157ba,%rax
  80042135c0:	00 00 00 
  80042135c3:	ff d0                	callq  *%rax
  80042135c5:	85 c0                	test   %eax,%eax
  80042135c7:	79 07                	jns    80042135d0 <dwarf_get_fde_at_pc+0x86>
		{
			return DW_DLV_NO_ENTRY;
  80042135c9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042135ce:	eb 48                	jmp    8004213618 <dwarf_get_fde_at_pc+0xce>
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  80042135d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042135d4:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042135d8:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042135dc:	77 20                	ja     80042135fe <dwarf_get_fde_at_pc+0xb4>
  80042135de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042135e2:	48 8b 50 30          	mov    0x30(%rax),%rdx
		    fde->fde_adrange)
  80042135e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042135ea:	48 8b 40 38          	mov    0x38(%rax),%rax
	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
		{
			return DW_DLV_NO_ENTRY;
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  80042135ee:	48 01 d0             	add    %rdx,%rax
  80042135f1:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042135f5:	76 07                	jbe    80042135fe <dwarf_get_fde_at_pc+0xb4>
		    fde->fde_adrange)
			return (DW_DLV_OK);
  80042135f7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042135fc:	eb 1a                	jmp    8004213618 <dwarf_get_fde_at_pc+0xce>
	fde->fde_cie = cie;
	
	if (ret_fde == NULL)
		return (DW_DLV_ERROR);

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  80042135fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213602:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004213606:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421360a:	48 8b 40 40          	mov    0x40(%rax),%rax
  800421360e:	48 39 c2             	cmp    %rax,%rdx
  8004213611:	72 92                	jb     80042135a5 <dwarf_get_fde_at_pc+0x5b>
		    fde->fde_adrange)
			return (DW_DLV_OK);
	}

	DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
	return (DW_DLV_NO_ENTRY);
  8004213613:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8004213618:	c9                   	leaveq 
  8004213619:	c3                   	retq   

000000800421361a <_dwarf_frame_regtable_copy>:

int
_dwarf_frame_regtable_copy(Dwarf_Debug dbg, Dwarf_Regtable3 **dest,
			   Dwarf_Regtable3 *src, Dwarf_Error *error)
{
  800421361a:	55                   	push   %rbp
  800421361b:	48 89 e5             	mov    %rsp,%rbp
  800421361e:	48 83 ec 30          	sub    $0x30,%rsp
  8004213622:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004213626:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421362a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800421362e:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	int i;

	assert(dest != NULL);
  8004213632:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004213637:	75 35                	jne    800421366e <_dwarf_frame_regtable_copy+0x54>
  8004213639:	48 b9 da 16 22 04 80 	movabs $0x80042216da,%rcx
  8004213640:	00 00 00 
  8004213643:	48 ba e7 16 22 04 80 	movabs $0x80042216e7,%rdx
  800421364a:	00 00 00 
  800421364d:	be 57 00 00 00       	mov    $0x57,%esi
  8004213652:	48 bf fc 16 22 04 80 	movabs $0x80042216fc,%rdi
  8004213659:	00 00 00 
  800421365c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213661:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004213668:	00 00 00 
  800421366b:	41 ff d0             	callq  *%r8
	assert(src != NULL);
  800421366e:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004213673:	75 35                	jne    80042136aa <_dwarf_frame_regtable_copy+0x90>
  8004213675:	48 b9 12 17 22 04 80 	movabs $0x8004221712,%rcx
  800421367c:	00 00 00 
  800421367f:	48 ba e7 16 22 04 80 	movabs $0x80042216e7,%rdx
  8004213686:	00 00 00 
  8004213689:	be 58 00 00 00       	mov    $0x58,%esi
  800421368e:	48 bf fc 16 22 04 80 	movabs $0x80042216fc,%rdi
  8004213695:	00 00 00 
  8004213698:	b8 00 00 00 00       	mov    $0x0,%eax
  800421369d:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042136a4:	00 00 00 
  80042136a7:	41 ff d0             	callq  *%r8

	if (*dest == NULL) {
  80042136aa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042136ae:	48 8b 00             	mov    (%rax),%rax
  80042136b1:	48 85 c0             	test   %rax,%rax
  80042136b4:	75 39                	jne    80042136ef <_dwarf_frame_regtable_copy+0xd5>
		*dest = &global_rt_table_shadow;
  80042136b6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042136ba:	48 bf e0 16 4e 04 80 	movabs $0x80044e16e0,%rdi
  80042136c1:	00 00 00 
  80042136c4:	48 89 38             	mov    %rdi,(%rax)
		(*dest)->rt3_reg_table_size = src->rt3_reg_table_size;
  80042136c7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042136cb:	48 8b 00             	mov    (%rax),%rax
  80042136ce:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042136d2:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
  80042136d6:	66 89 50 18          	mov    %dx,0x18(%rax)
		(*dest)->rt3_rules = global_rules_shadow;
  80042136da:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042136de:	48 8b 00             	mov    (%rax),%rax
  80042136e1:	48 be 00 f8 6d 04 80 	movabs $0x80046df800,%rsi
  80042136e8:	00 00 00 
  80042136eb:	48 89 70 20          	mov    %rsi,0x20(%rax)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
  80042136ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042136f3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042136f7:	48 8b 12             	mov    (%rdx),%rdx
  80042136fa:	48 89 d1             	mov    %rdx,%rcx
  80042136fd:	ba 18 00 00 00       	mov    $0x18,%edx
  8004213702:	48 89 c6             	mov    %rax,%rsi
  8004213705:	48 89 cf             	mov    %rcx,%rdi
  8004213708:	48 b8 5b 13 21 04 80 	movabs $0x800421135b,%rax
  800421370f:	00 00 00 
  8004213712:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004213714:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421371b:	eb 5a                	jmp    8004213777 <_dwarf_frame_regtable_copy+0x15d>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
  800421371d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213721:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213725:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213728:	48 63 d0             	movslq %eax,%rdx
  800421372b:	48 89 d0             	mov    %rdx,%rax
  800421372e:	48 01 c0             	add    %rax,%rax
  8004213731:	48 01 d0             	add    %rdx,%rax
  8004213734:	48 c1 e0 03          	shl    $0x3,%rax
  8004213738:	48 01 c1             	add    %rax,%rcx
  800421373b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421373f:	48 8b 00             	mov    (%rax),%rax
  8004213742:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004213746:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213749:	48 63 d0             	movslq %eax,%rdx
  800421374c:	48 89 d0             	mov    %rdx,%rax
  800421374f:	48 01 c0             	add    %rax,%rax
  8004213752:	48 01 d0             	add    %rdx,%rax
  8004213755:	48 c1 e0 03          	shl    $0x3,%rax
  8004213759:	48 01 f0             	add    %rsi,%rax
  800421375c:	ba 18 00 00 00       	mov    $0x18,%edx
  8004213761:	48 89 ce             	mov    %rcx,%rsi
  8004213764:	48 89 c7             	mov    %rax,%rdi
  8004213767:	48 b8 5b 13 21 04 80 	movabs $0x800421135b,%rax
  800421376e:	00 00 00 
  8004213771:	ff d0                	callq  *%rax

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
  8004213773:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004213777:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421377b:	48 8b 00             	mov    (%rax),%rax
  800421377e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213782:	0f b7 c0             	movzwl %ax,%eax
  8004213785:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004213788:	7e 44                	jle    80042137ce <_dwarf_frame_regtable_copy+0x1b4>
		     i < src->rt3_reg_table_size; i++)
  800421378a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421378e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213792:	0f b7 c0             	movzwl %ax,%eax
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004213795:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004213798:	7f 83                	jg     800421371d <_dwarf_frame_regtable_copy+0x103>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  800421379a:	eb 32                	jmp    80042137ce <_dwarf_frame_regtable_copy+0x1b4>
		(*dest)->rt3_rules[i].dw_regnum =
  800421379c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042137a0:	48 8b 00             	mov    (%rax),%rax
  80042137a3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042137a7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042137aa:	48 63 d0             	movslq %eax,%rdx
  80042137ad:	48 89 d0             	mov    %rdx,%rax
  80042137b0:	48 01 c0             	add    %rax,%rax
  80042137b3:	48 01 d0             	add    %rdx,%rax
  80042137b6:	48 c1 e0 03          	shl    $0x3,%rax
  80042137ba:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
			dbg->dbg_frame_undefined_value;
  80042137be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042137c2:	0f b7 40 50          	movzwl 0x50(%rax),%eax
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
		(*dest)->rt3_rules[i].dw_regnum =
  80042137c6:	66 89 42 02          	mov    %ax,0x2(%rdx)
	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  80042137ca:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042137ce:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042137d2:	48 8b 00             	mov    (%rax),%rax
  80042137d5:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042137d9:	0f b7 c0             	movzwl %ax,%eax
  80042137dc:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042137df:	7f bb                	jg     800421379c <_dwarf_frame_regtable_copy+0x182>
		(*dest)->rt3_rules[i].dw_regnum =
			dbg->dbg_frame_undefined_value;

	return (DW_DLE_NONE);
  80042137e1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042137e6:	c9                   	leaveq 
  80042137e7:	c3                   	retq   

00000080042137e8 <_dwarf_frame_run_inst>:

static int
_dwarf_frame_run_inst(Dwarf_Debug dbg, Dwarf_Regtable3 *rt, uint8_t *insts,
		      Dwarf_Unsigned len, Dwarf_Unsigned caf, Dwarf_Signed daf, Dwarf_Addr pc,
		      Dwarf_Addr pc_req, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  80042137e8:	55                   	push   %rbp
  80042137e9:	48 89 e5             	mov    %rsp,%rbp
  80042137ec:	53                   	push   %rbx
  80042137ed:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  80042137f4:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  80042137f8:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  80042137fc:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  8004213800:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  8004213804:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  800421380b:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
			ret = DW_DLE_DF_REG_NUM_TOO_HIGH;               \
			goto program_done;                              \
		}                                                       \
	} while(0)

	ret = DW_DLE_NONE;
  8004213812:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	init_rt = saved_rt = NULL;
  8004213819:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004213820:	00 
  8004213821:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004213825:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	*row_pc = pc;
  8004213829:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421382d:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213831:	48 89 10             	mov    %rdx,(%rax)

	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
  8004213834:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004213838:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800421383c:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
  8004213840:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213844:	48 89 c7             	mov    %rax,%rdi
  8004213847:	48 b8 1a 36 21 04 80 	movabs $0x800421361a,%rax
  800421384e:	00 00 00 
  8004213851:	ff d0                	callq  *%rax
	p = insts;
  8004213853:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004213857:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	pe = p + len;
  800421385b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800421385f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213863:	48 01 d0             	add    %rdx,%rax
  8004213866:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	while (p < pe) {
  800421386a:	e9 38 0d 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		if (*p == DW_CFA_nop) {
  800421386f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213873:	0f b6 00             	movzbl (%rax),%eax
  8004213876:	84 c0                	test   %al,%al
  8004213878:	75 11                	jne    800421388b <_dwarf_frame_run_inst+0xa3>
			p++;
  800421387a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421387e:	48 83 c0 01          	add    $0x1,%rax
  8004213882:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			continue;
  8004213886:	e9 1c 0d 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		}

		high2 = *p & 0xc0;
  800421388b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421388f:	0f b6 00             	movzbl (%rax),%eax
  8004213892:	83 e0 c0             	and    $0xffffffc0,%eax
  8004213895:	88 45 df             	mov    %al,-0x21(%rbp)
		low6 = *p & 0x3f;
  8004213898:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421389c:	0f b6 00             	movzbl (%rax),%eax
  800421389f:	83 e0 3f             	and    $0x3f,%eax
  80042138a2:	88 45 de             	mov    %al,-0x22(%rbp)
		p++;
  80042138a5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042138a9:	48 83 c0 01          	add    $0x1,%rax
  80042138ad:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

		if (high2 > 0) {
  80042138b1:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  80042138b5:	0f 84 a4 01 00 00    	je     8004213a5f <_dwarf_frame_run_inst+0x277>
			switch (high2) {
  80042138bb:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  80042138bf:	3d 80 00 00 00       	cmp    $0x80,%eax
  80042138c4:	74 37                	je     80042138fd <_dwarf_frame_run_inst+0x115>
  80042138c6:	3d c0 00 00 00       	cmp    $0xc0,%eax
  80042138cb:	0f 84 03 01 00 00    	je     80042139d4 <_dwarf_frame_run_inst+0x1ec>
  80042138d1:	83 f8 40             	cmp    $0x40,%eax
  80042138d4:	0f 85 73 01 00 00    	jne    8004213a4d <_dwarf_frame_run_inst+0x265>
			case DW_CFA_advance_loc:
			        pc += low6 * caf;
  80042138da:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  80042138de:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042138e5:	ff 
  80042138e6:	48 01 45 10          	add    %rax,0x10(%rbp)
			        if (pc_req < pc)
  80042138ea:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042138ee:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042138f2:	0f 83 61 01 00 00    	jae    8004213a59 <_dwarf_frame_run_inst+0x271>
			                goto program_done;
  80042138f8:	e9 c4 0c 00 00       	jmpq   80042145c1 <_dwarf_frame_run_inst+0xdd9>
			        break;
			case DW_CFA_offset:
			        *row_pc = pc;
  80042138fd:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213901:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213905:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  8004213908:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421390c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213910:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213914:	66 39 c2             	cmp    %ax,%dx
  8004213917:	72 0c                	jb     8004213925 <_dwarf_frame_run_inst+0x13d>
  8004213919:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213920:	e9 9c 0c 00 00       	jmpq   80042145c1 <_dwarf_frame_run_inst+0xdd9>
			        RL[low6].dw_offset_relevant = 1;
  8004213925:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213929:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421392d:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004213931:	48 89 d0             	mov    %rdx,%rax
  8004213934:	48 01 c0             	add    %rax,%rax
  8004213937:	48 01 d0             	add    %rdx,%rax
  800421393a:	48 c1 e0 03          	shl    $0x3,%rax
  800421393e:	48 01 c8             	add    %rcx,%rax
  8004213941:	c6 00 01             	movb   $0x1,(%rax)
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
  8004213944:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213948:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421394c:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004213950:	48 89 d0             	mov    %rdx,%rax
  8004213953:	48 01 c0             	add    %rax,%rax
  8004213956:	48 01 d0             	add    %rdx,%rax
  8004213959:	48 c1 e0 03          	shl    $0x3,%rax
  800421395d:	48 01 c8             	add    %rcx,%rax
  8004213960:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
  8004213964:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213968:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421396c:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004213970:	48 89 d0             	mov    %rdx,%rax
  8004213973:	48 01 c0             	add    %rax,%rax
  8004213976:	48 01 d0             	add    %rdx,%rax
  8004213979:	48 c1 e0 03          	shl    $0x3,%rax
  800421397d:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213981:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213985:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004213989:	66 89 42 02          	mov    %ax,0x2(%rdx)
			        RL[low6].dw_offset_or_block_len =
  800421398d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213991:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213995:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004213999:	48 89 d0             	mov    %rdx,%rax
  800421399c:	48 01 c0             	add    %rax,%rax
  800421399f:	48 01 d0             	add    %rdx,%rax
  80042139a2:	48 c1 e0 03          	shl    $0x3,%rax
  80042139a6:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
					_dwarf_decode_uleb128(&p) * daf;
  80042139aa:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042139ae:	48 89 c7             	mov    %rax,%rdi
  80042139b1:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  80042139b8:	00 00 00 
  80042139bb:	ff d0                	callq  *%rax
  80042139bd:	48 89 c2             	mov    %rax,%rdx
  80042139c0:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042139c7:	48 0f af c2          	imul   %rdx,%rax
			        *row_pc = pc;
			        CHECK_TABLE_SIZE(low6);
			        RL[low6].dw_offset_relevant = 1;
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
			        RL[low6].dw_offset_or_block_len =
  80042139cb:	48 89 43 08          	mov    %rax,0x8(%rbx)
					_dwarf_decode_uleb128(&p) * daf;
			        break;
  80042139cf:	e9 86 00 00 00       	jmpq   8004213a5a <_dwarf_frame_run_inst+0x272>
			case DW_CFA_restore:
			        *row_pc = pc;
  80042139d4:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042139d8:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042139dc:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  80042139df:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042139e3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042139e7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042139eb:	66 39 c2             	cmp    %ax,%dx
  80042139ee:	72 0c                	jb     80042139fc <_dwarf_frame_run_inst+0x214>
  80042139f0:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042139f7:	e9 c5 0b 00 00       	jmpq   80042145c1 <_dwarf_frame_run_inst+0xdd9>
			        memcpy(&RL[low6], &INITRL[low6],
  80042139fc:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213a00:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213a04:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004213a08:	48 89 d0             	mov    %rdx,%rax
  8004213a0b:	48 01 c0             	add    %rax,%rax
  8004213a0e:	48 01 d0             	add    %rdx,%rax
  8004213a11:	48 c1 e0 03          	shl    $0x3,%rax
  8004213a15:	48 01 c1             	add    %rax,%rcx
  8004213a18:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213a1c:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004213a20:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004213a24:	48 89 d0             	mov    %rdx,%rax
  8004213a27:	48 01 c0             	add    %rax,%rax
  8004213a2a:	48 01 d0             	add    %rdx,%rax
  8004213a2d:	48 c1 e0 03          	shl    $0x3,%rax
  8004213a31:	48 01 f0             	add    %rsi,%rax
  8004213a34:	ba 18 00 00 00       	mov    $0x18,%edx
  8004213a39:	48 89 ce             	mov    %rcx,%rsi
  8004213a3c:	48 89 c7             	mov    %rax,%rdi
  8004213a3f:	48 b8 5b 13 21 04 80 	movabs $0x800421135b,%rax
  8004213a46:	00 00 00 
  8004213a49:	ff d0                	callq  *%rax
				       sizeof(Dwarf_Regtable_Entry3));
			        break;
  8004213a4b:	eb 0d                	jmp    8004213a5a <_dwarf_frame_run_inst+0x272>
			default:
			        DWARF_SET_ERROR(dbg, error,
						DW_DLE_FRAME_INSTR_EXEC_ERROR);
			        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  8004213a4d:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			        goto program_done;
  8004213a54:	e9 68 0b 00 00       	jmpq   80042145c1 <_dwarf_frame_run_inst+0xdd9>
			switch (high2) {
			case DW_CFA_advance_loc:
			        pc += low6 * caf;
			        if (pc_req < pc)
			                goto program_done;
			        break;
  8004213a59:	90                   	nop
						DW_DLE_FRAME_INSTR_EXEC_ERROR);
			        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
			        goto program_done;
			}

			continue;
  8004213a5a:	e9 48 0b 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		}

		switch (low6) {
  8004213a5f:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  8004213a63:	83 f8 16             	cmp    $0x16,%eax
  8004213a66:	0f 87 32 0b 00 00    	ja     800421459e <_dwarf_frame_run_inst+0xdb6>
  8004213a6c:	89 c0                	mov    %eax,%eax
  8004213a6e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004213a75:	00 
  8004213a76:	48 b8 20 17 22 04 80 	movabs $0x8004221720,%rax
  8004213a7d:	00 00 00 
  8004213a80:	48 01 d0             	add    %rdx,%rax
  8004213a83:	48 8b 00             	mov    (%rax),%rax
  8004213a86:	ff e0                	jmpq   *%rax
		case DW_CFA_set_loc:
			pc = dbg->decode(&p, dbg->dbg_pointer_size);
  8004213a88:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213a8c:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004213a90:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004213a94:	8b 4a 28             	mov    0x28(%rdx),%ecx
  8004213a97:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004213a9b:	89 ce                	mov    %ecx,%esi
  8004213a9d:	48 89 d7             	mov    %rdx,%rdi
  8004213aa0:	ff d0                	callq  *%rax
  8004213aa2:	48 89 45 10          	mov    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004213aa6:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004213aaa:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004213aae:	0f 82 03 0b 00 00    	jb     80042145b7 <_dwarf_frame_run_inst+0xdcf>
			        goto program_done;
			break;
  8004213ab4:	e9 ee 0a 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_advance_loc1:
			pc += dbg->decode(&p, 1) * caf;
  8004213ab9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213abd:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004213ac1:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004213ac5:	be 01 00 00 00       	mov    $0x1,%esi
  8004213aca:	48 89 d7             	mov    %rdx,%rdi
  8004213acd:	ff d0                	callq  *%rax
  8004213acf:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004213ad6:	ff 
  8004213ad7:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004213adb:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004213adf:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004213ae3:	0f 82 d1 0a 00 00    	jb     80042145ba <_dwarf_frame_run_inst+0xdd2>
			        goto program_done;
			break;
  8004213ae9:	e9 b9 0a 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_advance_loc2:
			pc += dbg->decode(&p, 2) * caf;
  8004213aee:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213af2:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004213af6:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004213afa:	be 02 00 00 00       	mov    $0x2,%esi
  8004213aff:	48 89 d7             	mov    %rdx,%rdi
  8004213b02:	ff d0                	callq  *%rax
  8004213b04:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004213b0b:	ff 
  8004213b0c:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004213b10:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004213b14:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004213b18:	0f 82 9f 0a 00 00    	jb     80042145bd <_dwarf_frame_run_inst+0xdd5>
			        goto program_done;
			break;
  8004213b1e:	e9 84 0a 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_advance_loc4:
			pc += dbg->decode(&p, 4) * caf;
  8004213b23:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213b27:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004213b2b:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004213b2f:	be 04 00 00 00       	mov    $0x4,%esi
  8004213b34:	48 89 d7             	mov    %rdx,%rdi
  8004213b37:	ff d0                	callq  *%rax
  8004213b39:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004213b40:	ff 
  8004213b41:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004213b45:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004213b49:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004213b4d:	0f 82 6d 0a 00 00    	jb     80042145c0 <_dwarf_frame_run_inst+0xdd8>
			        goto program_done;
			break;
  8004213b53:	e9 4f 0a 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_offset_extended:
			*row_pc = pc;
  8004213b58:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213b5c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213b60:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004213b63:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213b67:	48 89 c7             	mov    %rax,%rdi
  8004213b6a:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  8004213b71:	00 00 00 
  8004213b74:	ff d0                	callq  *%rax
  8004213b76:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  8004213b7a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213b7e:	48 89 c7             	mov    %rax,%rdi
  8004213b81:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  8004213b88:	00 00 00 
  8004213b8b:	ff d0                	callq  *%rax
  8004213b8d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004213b91:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213b95:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213b99:	0f b7 c0             	movzwl %ax,%eax
  8004213b9c:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213ba0:	77 0c                	ja     8004213bae <_dwarf_frame_run_inst+0x3c6>
  8004213ba2:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213ba9:	e9 13 0a 00 00       	jmpq   80042145c1 <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 1;
  8004213bae:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213bb2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213bb6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213bba:	48 89 d0             	mov    %rdx,%rax
  8004213bbd:	48 01 c0             	add    %rax,%rax
  8004213bc0:	48 01 d0             	add    %rdx,%rax
  8004213bc3:	48 c1 e0 03          	shl    $0x3,%rax
  8004213bc7:	48 01 c8             	add    %rcx,%rax
  8004213bca:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004213bcd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213bd1:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213bd5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213bd9:	48 89 d0             	mov    %rdx,%rax
  8004213bdc:	48 01 c0             	add    %rax,%rax
  8004213bdf:	48 01 d0             	add    %rdx,%rax
  8004213be2:	48 c1 e0 03          	shl    $0x3,%rax
  8004213be6:	48 01 c8             	add    %rcx,%rax
  8004213be9:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004213bed:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213bf1:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213bf5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213bf9:	48 89 d0             	mov    %rdx,%rax
  8004213bfc:	48 01 c0             	add    %rax,%rax
  8004213bff:	48 01 d0             	add    %rdx,%rax
  8004213c02:	48 c1 e0 03          	shl    $0x3,%rax
  8004213c06:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213c0a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213c0e:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004213c12:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  8004213c16:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213c1a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213c1e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213c22:	48 89 d0             	mov    %rdx,%rax
  8004213c25:	48 01 c0             	add    %rax,%rax
  8004213c28:	48 01 d0             	add    %rdx,%rax
  8004213c2b:	48 c1 e0 03          	shl    $0x3,%rax
  8004213c2f:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213c33:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004213c3a:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004213c3f:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004213c43:	e9 5f 09 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_restore_extended:
			*row_pc = pc;
  8004213c48:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213c4c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213c50:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004213c53:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213c57:	48 89 c7             	mov    %rax,%rdi
  8004213c5a:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  8004213c61:	00 00 00 
  8004213c64:	ff d0                	callq  *%rax
  8004213c66:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004213c6a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213c6e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213c72:	0f b7 c0             	movzwl %ax,%eax
  8004213c75:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213c79:	77 0c                	ja     8004213c87 <_dwarf_frame_run_inst+0x49f>
  8004213c7b:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213c82:	e9 3a 09 00 00       	jmpq   80042145c1 <_dwarf_frame_run_inst+0xdd9>
			memcpy(&RL[reg], &INITRL[reg],
  8004213c87:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213c8b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213c8f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213c93:	48 89 d0             	mov    %rdx,%rax
  8004213c96:	48 01 c0             	add    %rax,%rax
  8004213c99:	48 01 d0             	add    %rdx,%rax
  8004213c9c:	48 c1 e0 03          	shl    $0x3,%rax
  8004213ca0:	48 01 c1             	add    %rax,%rcx
  8004213ca3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213ca7:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004213cab:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213caf:	48 89 d0             	mov    %rdx,%rax
  8004213cb2:	48 01 c0             	add    %rax,%rax
  8004213cb5:	48 01 d0             	add    %rdx,%rax
  8004213cb8:	48 c1 e0 03          	shl    $0x3,%rax
  8004213cbc:	48 01 f0             	add    %rsi,%rax
  8004213cbf:	ba 18 00 00 00       	mov    $0x18,%edx
  8004213cc4:	48 89 ce             	mov    %rcx,%rsi
  8004213cc7:	48 89 c7             	mov    %rax,%rdi
  8004213cca:	48 b8 5b 13 21 04 80 	movabs $0x800421135b,%rax
  8004213cd1:	00 00 00 
  8004213cd4:	ff d0                	callq  *%rax
			       sizeof(Dwarf_Regtable_Entry3));
			break;
  8004213cd6:	e9 cc 08 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_undefined:
			*row_pc = pc;
  8004213cdb:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213cdf:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213ce3:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004213ce6:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213cea:	48 89 c7             	mov    %rax,%rdi
  8004213ced:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  8004213cf4:	00 00 00 
  8004213cf7:	ff d0                	callq  *%rax
  8004213cf9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004213cfd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213d01:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213d05:	0f b7 c0             	movzwl %ax,%eax
  8004213d08:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213d0c:	77 0c                	ja     8004213d1a <_dwarf_frame_run_inst+0x532>
  8004213d0e:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213d15:	e9 a7 08 00 00       	jmpq   80042145c1 <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 0;
  8004213d1a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213d1e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213d22:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213d26:	48 89 d0             	mov    %rdx,%rax
  8004213d29:	48 01 c0             	add    %rax,%rax
  8004213d2c:	48 01 d0             	add    %rdx,%rax
  8004213d2f:	48 c1 e0 03          	shl    $0x3,%rax
  8004213d33:	48 01 c8             	add    %rcx,%rax
  8004213d36:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_undefined_value;
  8004213d39:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213d3d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213d41:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213d45:	48 89 d0             	mov    %rdx,%rax
  8004213d48:	48 01 c0             	add    %rax,%rax
  8004213d4b:	48 01 d0             	add    %rdx,%rax
  8004213d4e:	48 c1 e0 03          	shl    $0x3,%rax
  8004213d52:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213d56:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213d5a:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  8004213d5e:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  8004213d62:	e9 40 08 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_same_value:
			reg = _dwarf_decode_uleb128(&p);
  8004213d67:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213d6b:	48 89 c7             	mov    %rax,%rdi
  8004213d6e:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  8004213d75:	00 00 00 
  8004213d78:	ff d0                	callq  *%rax
  8004213d7a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004213d7e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213d82:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213d86:	0f b7 c0             	movzwl %ax,%eax
  8004213d89:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213d8d:	77 0c                	ja     8004213d9b <_dwarf_frame_run_inst+0x5b3>
  8004213d8f:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213d96:	e9 26 08 00 00       	jmpq   80042145c1 <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 0;
  8004213d9b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213d9f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213da3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213da7:	48 89 d0             	mov    %rdx,%rax
  8004213daa:	48 01 c0             	add    %rax,%rax
  8004213dad:	48 01 d0             	add    %rdx,%rax
  8004213db0:	48 c1 e0 03          	shl    $0x3,%rax
  8004213db4:	48 01 c8             	add    %rcx,%rax
  8004213db7:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_same_value;
  8004213dba:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213dbe:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213dc2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213dc6:	48 89 d0             	mov    %rdx,%rax
  8004213dc9:	48 01 c0             	add    %rax,%rax
  8004213dcc:	48 01 d0             	add    %rdx,%rax
  8004213dcf:	48 c1 e0 03          	shl    $0x3,%rax
  8004213dd3:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213dd7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213ddb:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  8004213ddf:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  8004213de3:	e9 bf 07 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_register:
			*row_pc = pc;
  8004213de8:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213dec:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213df0:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004213df3:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213df7:	48 89 c7             	mov    %rax,%rdi
  8004213dfa:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  8004213e01:	00 00 00 
  8004213e04:	ff d0                	callq  *%rax
  8004213e06:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			reg2 = _dwarf_decode_uleb128(&p);
  8004213e0a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213e0e:	48 89 c7             	mov    %rax,%rdi
  8004213e11:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  8004213e18:	00 00 00 
  8004213e1b:	ff d0                	callq  *%rax
  8004213e1d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004213e21:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213e25:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213e29:	0f b7 c0             	movzwl %ax,%eax
  8004213e2c:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213e30:	77 0c                	ja     8004213e3e <_dwarf_frame_run_inst+0x656>
  8004213e32:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213e39:	e9 83 07 00 00       	jmpq   80042145c1 <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 0;
  8004213e3e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213e42:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213e46:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213e4a:	48 89 d0             	mov    %rdx,%rax
  8004213e4d:	48 01 c0             	add    %rax,%rax
  8004213e50:	48 01 d0             	add    %rdx,%rax
  8004213e53:	48 c1 e0 03          	shl    $0x3,%rax
  8004213e57:	48 01 c8             	add    %rcx,%rax
  8004213e5a:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = reg2;
  8004213e5d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213e61:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213e65:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213e69:	48 89 d0             	mov    %rdx,%rax
  8004213e6c:	48 01 c0             	add    %rax,%rax
  8004213e6f:	48 01 d0             	add    %rdx,%rax
  8004213e72:	48 c1 e0 03          	shl    $0x3,%rax
  8004213e76:	48 01 c8             	add    %rcx,%rax
  8004213e79:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213e7d:	66 89 50 02          	mov    %dx,0x2(%rax)
			break;
  8004213e81:	e9 21 07 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_remember_state:
			_dwarf_frame_regtable_copy(dbg, &saved_rt, rt, error);
  8004213e86:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004213e8a:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004213e8e:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  8004213e92:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213e96:	48 89 c7             	mov    %rax,%rdi
  8004213e99:	48 b8 1a 36 21 04 80 	movabs $0x800421361a,%rax
  8004213ea0:	00 00 00 
  8004213ea3:	ff d0                	callq  *%rax
			break;
  8004213ea5:	e9 fd 06 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_restore_state:
			*row_pc = pc;
  8004213eaa:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213eae:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213eb2:	48 89 10             	mov    %rdx,(%rax)
			_dwarf_frame_regtable_copy(dbg, &rt, saved_rt, error);
  8004213eb5:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004213eb9:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004213ebd:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  8004213ec1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213ec5:	48 89 c7             	mov    %rax,%rdi
  8004213ec8:	48 b8 1a 36 21 04 80 	movabs $0x800421361a,%rax
  8004213ecf:	00 00 00 
  8004213ed2:	ff d0                	callq  *%rax
			break;
  8004213ed4:	e9 ce 06 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_def_cfa:
			*row_pc = pc;
  8004213ed9:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213edd:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213ee1:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004213ee4:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213ee8:	48 89 c7             	mov    %rax,%rdi
  8004213eeb:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  8004213ef2:	00 00 00 
  8004213ef5:	ff d0                	callq  *%rax
  8004213ef7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  8004213efb:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213eff:	48 89 c7             	mov    %rax,%rdi
  8004213f02:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  8004213f09:	00 00 00 
  8004213f0c:	ff d0                	callq  *%rax
  8004213f0e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  8004213f12:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213f16:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004213f19:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213f1d:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  8004213f21:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213f25:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213f29:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = uoff;
  8004213f2d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213f31:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213f35:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004213f39:	e9 69 06 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_def_cfa_register:
			*row_pc = pc;
  8004213f3e:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213f42:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213f46:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004213f49:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213f4d:	48 89 c7             	mov    %rax,%rdi
  8004213f50:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  8004213f57:	00 00 00 
  8004213f5a:	ff d0                	callq  *%rax
  8004213f5c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CFA.dw_regnum = reg;
  8004213f60:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213f64:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213f68:	66 89 50 02          	mov    %dx,0x2(%rax)
			 * Note that DW_CFA_def_cfa_register change the CFA
			 * rule register while keep the old offset. So we
			 * should not touch the CFA.dw_offset_relevant flag
			 * here.
			 */
			break;
  8004213f6c:	e9 36 06 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_def_cfa_offset:
			*row_pc = pc;
  8004213f71:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213f75:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213f79:	48 89 10             	mov    %rdx,(%rax)
			uoff = _dwarf_decode_uleb128(&p);
  8004213f7c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213f80:	48 89 c7             	mov    %rax,%rdi
  8004213f83:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  8004213f8a:	00 00 00 
  8004213f8d:	ff d0                	callq  *%rax
  8004213f8f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  8004213f93:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213f97:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004213f9a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213f9e:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = uoff;
  8004213fa2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213fa6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213faa:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004213fae:	e9 f4 05 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_def_cfa_expression:
			*row_pc = pc;
  8004213fb3:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213fb7:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213fbb:	48 89 10             	mov    %rdx,(%rax)
			CFA.dw_offset_relevant = 0;
  8004213fbe:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213fc2:	c6 00 00             	movb   $0x0,(%rax)
			CFA.dw_value_type = DW_EXPR_EXPRESSION;
  8004213fc5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213fc9:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			CFA.dw_offset_or_block_len = _dwarf_decode_uleb128(&p);
  8004213fcd:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  8004213fd1:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213fd5:	48 89 c7             	mov    %rax,%rdi
  8004213fd8:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  8004213fdf:	00 00 00 
  8004213fe2:	ff d0                	callq  *%rax
  8004213fe4:	48 89 43 08          	mov    %rax,0x8(%rbx)
			CFA.dw_block_ptr = p;
  8004213fe8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213fec:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004213ff0:	48 89 50 10          	mov    %rdx,0x10(%rax)
			p += CFA.dw_offset_or_block_len;
  8004213ff4:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004213ff8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213ffc:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214000:	48 01 d0             	add    %rdx,%rax
  8004214003:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  8004214007:	e9 9b 05 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_expression:
			*row_pc = pc;
  800421400c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004214010:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004214014:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004214017:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421401b:	48 89 c7             	mov    %rax,%rdi
  800421401e:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  8004214025:	00 00 00 
  8004214028:	ff d0                	callq  *%rax
  800421402a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800421402e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214032:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004214036:	0f b7 c0             	movzwl %ax,%eax
  8004214039:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421403d:	77 0c                	ja     800421404b <_dwarf_frame_run_inst+0x863>
  800421403f:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004214046:	e9 76 05 00 00       	jmpq   80042145c1 <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 0;
  800421404b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421404f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214053:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214057:	48 89 d0             	mov    %rdx,%rax
  800421405a:	48 01 c0             	add    %rax,%rax
  800421405d:	48 01 d0             	add    %rdx,%rax
  8004214060:	48 c1 e0 03          	shl    $0x3,%rax
  8004214064:	48 01 c8             	add    %rcx,%rax
  8004214067:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
  800421406a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421406e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214072:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214076:	48 89 d0             	mov    %rdx,%rax
  8004214079:	48 01 c0             	add    %rax,%rax
  800421407c:	48 01 d0             	add    %rdx,%rax
  800421407f:	48 c1 e0 03          	shl    $0x3,%rax
  8004214083:	48 01 c8             	add    %rcx,%rax
  8004214086:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  800421408a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421408e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214092:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214096:	48 89 d0             	mov    %rdx,%rax
  8004214099:	48 01 c0             	add    %rax,%rax
  800421409c:	48 01 d0             	add    %rdx,%rax
  800421409f:	48 c1 e0 03          	shl    $0x3,%rax
  80042140a3:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  80042140a7:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042140ab:	48 89 c7             	mov    %rax,%rdi
  80042140ae:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  80042140b5:	00 00 00 
  80042140b8:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  80042140ba:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  80042140be:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042140c2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042140c6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042140ca:	48 89 d0             	mov    %rdx,%rax
  80042140cd:	48 01 c0             	add    %rax,%rax
  80042140d0:	48 01 d0             	add    %rdx,%rax
  80042140d3:	48 c1 e0 03          	shl    $0x3,%rax
  80042140d7:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042140db:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042140df:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  80042140e3:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042140e7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042140eb:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042140ef:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042140f3:	48 89 d0             	mov    %rdx,%rax
  80042140f6:	48 01 c0             	add    %rax,%rax
  80042140f9:	48 01 d0             	add    %rdx,%rax
  80042140fc:	48 c1 e0 03          	shl    $0x3,%rax
  8004214100:	48 01 f0             	add    %rsi,%rax
  8004214103:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214107:	48 01 c8             	add    %rcx,%rax
  800421410a:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  800421410e:	e9 94 04 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_offset_extended_sf:
			*row_pc = pc;
  8004214113:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004214117:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421411b:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800421411e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004214122:	48 89 c7             	mov    %rax,%rdi
  8004214125:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  800421412c:	00 00 00 
  800421412f:	ff d0                	callq  *%rax
  8004214131:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004214135:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004214139:	48 89 c7             	mov    %rax,%rdi
  800421413c:	48 b8 50 1d 21 04 80 	movabs $0x8004211d50,%rax
  8004214143:	00 00 00 
  8004214146:	ff d0                	callq  *%rax
  8004214148:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  800421414c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214150:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004214154:	0f b7 c0             	movzwl %ax,%eax
  8004214157:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421415b:	77 0c                	ja     8004214169 <_dwarf_frame_run_inst+0x981>
  800421415d:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004214164:	e9 58 04 00 00       	jmpq   80042145c1 <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 1;
  8004214169:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421416d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214171:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214175:	48 89 d0             	mov    %rdx,%rax
  8004214178:	48 01 c0             	add    %rax,%rax
  800421417b:	48 01 d0             	add    %rdx,%rax
  800421417e:	48 c1 e0 03          	shl    $0x3,%rax
  8004214182:	48 01 c8             	add    %rcx,%rax
  8004214185:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004214188:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421418c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214190:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214194:	48 89 d0             	mov    %rdx,%rax
  8004214197:	48 01 c0             	add    %rax,%rax
  800421419a:	48 01 d0             	add    %rdx,%rax
  800421419d:	48 c1 e0 03          	shl    $0x3,%rax
  80042141a1:	48 01 c8             	add    %rcx,%rax
  80042141a4:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  80042141a8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042141ac:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042141b0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042141b4:	48 89 d0             	mov    %rdx,%rax
  80042141b7:	48 01 c0             	add    %rax,%rax
  80042141ba:	48 01 d0             	add    %rdx,%rax
  80042141bd:	48 c1 e0 03          	shl    $0x3,%rax
  80042141c1:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042141c5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042141c9:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042141cd:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  80042141d1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042141d5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042141d9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042141dd:	48 89 d0             	mov    %rdx,%rax
  80042141e0:	48 01 c0             	add    %rax,%rax
  80042141e3:	48 01 d0             	add    %rdx,%rax
  80042141e6:	48 c1 e0 03          	shl    $0x3,%rax
  80042141ea:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042141ee:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042141f5:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  80042141fa:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  80042141fe:	e9 a4 03 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_def_cfa_sf:
			*row_pc = pc;
  8004214203:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004214207:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421420b:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  800421420e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004214212:	48 89 c7             	mov    %rax,%rdi
  8004214215:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  800421421c:	00 00 00 
  800421421f:	ff d0                	callq  *%rax
  8004214221:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004214225:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004214229:	48 89 c7             	mov    %rax,%rdi
  800421422c:	48 b8 50 1d 21 04 80 	movabs $0x8004211d50,%rax
  8004214233:	00 00 00 
  8004214236:	ff d0                	callq  *%rax
  8004214238:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  800421423c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214240:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004214243:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214247:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  800421424b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421424f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214253:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  8004214257:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421425b:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004214262:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004214267:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  800421426b:	e9 37 03 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_def_cfa_offset_sf:
			*row_pc = pc;
  8004214270:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004214274:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004214278:	48 89 10             	mov    %rdx,(%rax)
			soff = _dwarf_decode_sleb128(&p);
  800421427b:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421427f:	48 89 c7             	mov    %rax,%rdi
  8004214282:	48 b8 50 1d 21 04 80 	movabs $0x8004211d50,%rax
  8004214289:	00 00 00 
  800421428c:	ff d0                	callq  *%rax
  800421428e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  8004214292:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214296:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004214299:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421429d:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  80042142a1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042142a5:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  80042142ac:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  80042142b1:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  80042142b5:	e9 ed 02 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_val_offset:
			*row_pc = pc;
  80042142ba:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042142be:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042142c2:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042142c5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042142c9:	48 89 c7             	mov    %rax,%rdi
  80042142cc:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  80042142d3:	00 00 00 
  80042142d6:	ff d0                	callq  *%rax
  80042142d8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  80042142dc:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042142e0:	48 89 c7             	mov    %rax,%rdi
  80042142e3:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  80042142ea:	00 00 00 
  80042142ed:	ff d0                	callq  *%rax
  80042142ef:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042142f3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042142f7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042142fb:	0f b7 c0             	movzwl %ax,%eax
  80042142fe:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004214302:	77 0c                	ja     8004214310 <_dwarf_frame_run_inst+0xb28>
  8004214304:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421430b:	e9 b1 02 00 00       	jmpq   80042145c1 <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 1;
  8004214310:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214314:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214318:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421431c:	48 89 d0             	mov    %rdx,%rax
  800421431f:	48 01 c0             	add    %rax,%rax
  8004214322:	48 01 d0             	add    %rdx,%rax
  8004214325:	48 c1 e0 03          	shl    $0x3,%rax
  8004214329:	48 01 c8             	add    %rcx,%rax
  800421432c:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  800421432f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214333:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214337:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421433b:	48 89 d0             	mov    %rdx,%rax
  800421433e:	48 01 c0             	add    %rax,%rax
  8004214341:	48 01 d0             	add    %rdx,%rax
  8004214344:	48 c1 e0 03          	shl    $0x3,%rax
  8004214348:	48 01 c8             	add    %rcx,%rax
  800421434b:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800421434f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214353:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214357:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421435b:	48 89 d0             	mov    %rdx,%rax
  800421435e:	48 01 c0             	add    %rax,%rax
  8004214361:	48 01 d0             	add    %rdx,%rax
  8004214364:	48 c1 e0 03          	shl    $0x3,%rax
  8004214368:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421436c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004214370:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004214374:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  8004214378:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421437c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214380:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214384:	48 89 d0             	mov    %rdx,%rax
  8004214387:	48 01 c0             	add    %rax,%rax
  800421438a:	48 01 d0             	add    %rdx,%rax
  800421438d:	48 c1 e0 03          	shl    $0x3,%rax
  8004214391:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004214395:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800421439c:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  80042143a1:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  80042143a5:	e9 fd 01 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_val_offset_sf:
			*row_pc = pc;
  80042143aa:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042143ae:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042143b2:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042143b5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042143b9:	48 89 c7             	mov    %rax,%rdi
  80042143bc:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  80042143c3:	00 00 00 
  80042143c6:	ff d0                	callq  *%rax
  80042143c8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  80042143cc:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042143d0:	48 89 c7             	mov    %rax,%rdi
  80042143d3:	48 b8 50 1d 21 04 80 	movabs $0x8004211d50,%rax
  80042143da:	00 00 00 
  80042143dd:	ff d0                	callq  *%rax
  80042143df:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042143e3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042143e7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042143eb:	0f b7 c0             	movzwl %ax,%eax
  80042143ee:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042143f2:	77 0c                	ja     8004214400 <_dwarf_frame_run_inst+0xc18>
  80042143f4:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042143fb:	e9 c1 01 00 00       	jmpq   80042145c1 <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 1;
  8004214400:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214404:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214408:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421440c:	48 89 d0             	mov    %rdx,%rax
  800421440f:	48 01 c0             	add    %rax,%rax
  8004214412:	48 01 d0             	add    %rdx,%rax
  8004214415:	48 c1 e0 03          	shl    $0x3,%rax
  8004214419:	48 01 c8             	add    %rcx,%rax
  800421441c:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  800421441f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214423:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214427:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421442b:	48 89 d0             	mov    %rdx,%rax
  800421442e:	48 01 c0             	add    %rax,%rax
  8004214431:	48 01 d0             	add    %rdx,%rax
  8004214434:	48 c1 e0 03          	shl    $0x3,%rax
  8004214438:	48 01 c8             	add    %rcx,%rax
  800421443b:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800421443f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214443:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214447:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421444b:	48 89 d0             	mov    %rdx,%rax
  800421444e:	48 01 c0             	add    %rax,%rax
  8004214451:	48 01 d0             	add    %rdx,%rax
  8004214454:	48 c1 e0 03          	shl    $0x3,%rax
  8004214458:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421445c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004214460:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004214464:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  8004214468:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421446c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214470:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214474:	48 89 d0             	mov    %rdx,%rax
  8004214477:	48 01 c0             	add    %rax,%rax
  800421447a:	48 01 d0             	add    %rdx,%rax
  800421447d:	48 c1 e0 03          	shl    $0x3,%rax
  8004214481:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004214485:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800421448c:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004214491:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004214495:	e9 0d 01 00 00       	jmpq   80042145a7 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_val_expression:
			*row_pc = pc;
  800421449a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421449e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042144a2:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042144a5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042144a9:	48 89 c7             	mov    %rax,%rdi
  80042144ac:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  80042144b3:	00 00 00 
  80042144b6:	ff d0                	callq  *%rax
  80042144b8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042144bc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042144c0:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042144c4:	0f b7 c0             	movzwl %ax,%eax
  80042144c7:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042144cb:	77 0c                	ja     80042144d9 <_dwarf_frame_run_inst+0xcf1>
  80042144cd:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042144d4:	e9 e8 00 00 00       	jmpq   80042145c1 <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 0;
  80042144d9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042144dd:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042144e1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042144e5:	48 89 d0             	mov    %rdx,%rax
  80042144e8:	48 01 c0             	add    %rax,%rax
  80042144eb:	48 01 d0             	add    %rdx,%rax
  80042144ee:	48 c1 e0 03          	shl    $0x3,%rax
  80042144f2:	48 01 c8             	add    %rcx,%rax
  80042144f5:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
  80042144f8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042144fc:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214500:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214504:	48 89 d0             	mov    %rdx,%rax
  8004214507:	48 01 c0             	add    %rax,%rax
  800421450a:	48 01 d0             	add    %rdx,%rax
  800421450d:	48 c1 e0 03          	shl    $0x3,%rax
  8004214511:	48 01 c8             	add    %rcx,%rax
  8004214514:	c6 40 01 03          	movb   $0x3,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  8004214518:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421451c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214520:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214524:	48 89 d0             	mov    %rdx,%rax
  8004214527:	48 01 c0             	add    %rax,%rax
  800421452a:	48 01 d0             	add    %rdx,%rax
  800421452d:	48 c1 e0 03          	shl    $0x3,%rax
  8004214531:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004214535:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004214539:	48 89 c7             	mov    %rax,%rdi
  800421453c:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  8004214543:	00 00 00 
  8004214546:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  8004214548:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  800421454c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214550:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214554:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214558:	48 89 d0             	mov    %rdx,%rax
  800421455b:	48 01 c0             	add    %rax,%rax
  800421455e:	48 01 d0             	add    %rdx,%rax
  8004214561:	48 c1 e0 03          	shl    $0x3,%rax
  8004214565:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004214569:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421456d:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  8004214571:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004214575:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214579:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421457d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214581:	48 89 d0             	mov    %rdx,%rax
  8004214584:	48 01 c0             	add    %rax,%rax
  8004214587:	48 01 d0             	add    %rdx,%rax
  800421458a:	48 c1 e0 03          	shl    $0x3,%rax
  800421458e:	48 01 f0             	add    %rsi,%rax
  8004214591:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214595:	48 01 c8             	add    %rcx,%rax
  8004214598:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  800421459c:	eb 09                	jmp    80042145a7 <_dwarf_frame_run_inst+0xdbf>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_INSTR_EXEC_ERROR);
			ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  800421459e:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			goto program_done;
  80042145a5:	eb 1a                	jmp    80042145c1 <_dwarf_frame_run_inst+0xdd9>
	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
	p = insts;
	pe = p + len;

	while (p < pe) {
  80042145a7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042145ab:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042145af:	0f 82 ba f2 ff ff    	jb     800421386f <_dwarf_frame_run_inst+0x87>
  80042145b5:	eb 0a                	jmp    80042145c1 <_dwarf_frame_run_inst+0xdd9>

		switch (low6) {
		case DW_CFA_set_loc:
			pc = dbg->decode(&p, dbg->dbg_pointer_size);
			if (pc_req < pc)
			        goto program_done;
  80042145b7:	90                   	nop
  80042145b8:	eb 07                	jmp    80042145c1 <_dwarf_frame_run_inst+0xdd9>
			break;
		case DW_CFA_advance_loc1:
			pc += dbg->decode(&p, 1) * caf;
			if (pc_req < pc)
			        goto program_done;
  80042145ba:	90                   	nop
  80042145bb:	eb 04                	jmp    80042145c1 <_dwarf_frame_run_inst+0xdd9>
			break;
		case DW_CFA_advance_loc2:
			pc += dbg->decode(&p, 2) * caf;
			if (pc_req < pc)
			        goto program_done;
  80042145bd:	90                   	nop
  80042145be:	eb 01                	jmp    80042145c1 <_dwarf_frame_run_inst+0xdd9>
			break;
		case DW_CFA_advance_loc4:
			pc += dbg->decode(&p, 4) * caf;
			if (pc_req < pc)
			        goto program_done;
  80042145c0:	90                   	nop
			goto program_done;
		}
	}

program_done:
	return (ret);
  80042145c1:	8b 45 ec             	mov    -0x14(%rbp),%eax
#undef  CFA
#undef  INITCFA
#undef  RL
#undef  INITRL
#undef  CHECK_TABLE_SIZE
}
  80042145c4:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  80042145cb:	5b                   	pop    %rbx
  80042145cc:	5d                   	pop    %rbp
  80042145cd:	c3                   	retq   

00000080042145ce <_dwarf_frame_get_internal_table>:
int
_dwarf_frame_get_internal_table(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_req, Dwarf_Regtable3 **ret_rt,
				Dwarf_Addr *ret_row_pc,
				Dwarf_Error *error)
{
  80042145ce:	55                   	push   %rbp
  80042145cf:	48 89 e5             	mov    %rsp,%rbp
  80042145d2:	48 83 ec 60          	sub    $0x60,%rsp
  80042145d6:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042145da:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042145de:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042145e2:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80042145e6:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  80042145ea:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Cie cie;
	Dwarf_Regtable3 *rt;
	Dwarf_Addr row_pc;
	int i, ret;

	assert(ret_rt != NULL);
  80042145ee:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  80042145f3:	75 35                	jne    800421462a <_dwarf_frame_get_internal_table+0x5c>
  80042145f5:	48 b9 d8 17 22 04 80 	movabs $0x80042217d8,%rcx
  80042145fc:	00 00 00 
  80042145ff:	48 ba e7 16 22 04 80 	movabs $0x80042216e7,%rdx
  8004214606:	00 00 00 
  8004214609:	be 83 01 00 00       	mov    $0x183,%esi
  800421460e:	48 bf fc 16 22 04 80 	movabs $0x80042216fc,%rdi
  8004214615:	00 00 00 
  8004214618:	b8 00 00 00 00       	mov    $0x0,%eax
  800421461d:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004214624:	00 00 00 
  8004214627:	41 ff d0             	callq  *%r8

	//dbg = fde->fde_dbg;
	assert(dbg != NULL);
  800421462a:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800421462f:	75 35                	jne    8004214666 <_dwarf_frame_get_internal_table+0x98>
  8004214631:	48 b9 e7 17 22 04 80 	movabs $0x80042217e7,%rcx
  8004214638:	00 00 00 
  800421463b:	48 ba e7 16 22 04 80 	movabs $0x80042216e7,%rdx
  8004214642:	00 00 00 
  8004214645:	be 86 01 00 00       	mov    $0x186,%esi
  800421464a:	48 bf fc 16 22 04 80 	movabs $0x80042216fc,%rdi
  8004214651:	00 00 00 
  8004214654:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214659:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004214660:	00 00 00 
  8004214663:	41 ff d0             	callq  *%r8

	rt = dbg->dbg_internal_reg_table;
  8004214666:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421466a:	48 8b 40 58          	mov    0x58(%rax),%rax
  800421466e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	/* Clear the content of regtable from previous run. */
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
  8004214672:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214676:	ba 18 00 00 00       	mov    $0x18,%edx
  800421467b:	be 00 00 00 00       	mov    $0x0,%esi
  8004214680:	48 89 c7             	mov    %rax,%rdi
  8004214683:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  800421468a:	00 00 00 
  800421468d:	ff d0                	callq  *%rax
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
  800421468f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214693:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004214697:	0f b7 d0             	movzwl %ax,%edx
  800421469a:	48 89 d0             	mov    %rdx,%rax
  800421469d:	48 01 c0             	add    %rax,%rax
  80042146a0:	48 01 d0             	add    %rdx,%rax
  80042146a3:	48 c1 e0 03          	shl    $0x3,%rax
  80042146a7:	48 89 c2             	mov    %rax,%rdx
  80042146aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042146ae:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042146b2:	be 00 00 00 00       	mov    $0x0,%esi
  80042146b7:	48 89 c7             	mov    %rax,%rdi
  80042146ba:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  80042146c1:	00 00 00 
  80042146c4:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  80042146c6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042146cd:	eb 2f                	jmp    80042146fe <_dwarf_frame_get_internal_table+0x130>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;
  80042146cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042146d3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042146d7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042146da:	48 63 d0             	movslq %eax,%rdx
  80042146dd:	48 89 d0             	mov    %rdx,%rax
  80042146e0:	48 01 c0             	add    %rax,%rax
  80042146e3:	48 01 d0             	add    %rdx,%rax
  80042146e6:	48 c1 e0 03          	shl    $0x3,%rax
  80042146ea:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042146ee:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042146f2:	0f b7 40 4a          	movzwl 0x4a(%rax),%eax
  80042146f6:	66 89 42 02          	mov    %ax,0x2(%rdx)
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  80042146fa:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042146fe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214702:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004214706:	0f b7 c0             	movzwl %ax,%eax
  8004214709:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800421470c:	7f c1                	jg     80042146cf <_dwarf_frame_get_internal_table+0x101>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

	/* Run initial instructions in CIE. */
	cie = fde->fde_cie;
  800421470e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214712:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214716:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	assert(cie != NULL);
  800421471a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800421471f:	75 35                	jne    8004214756 <_dwarf_frame_get_internal_table+0x188>
  8004214721:	48 b9 f3 17 22 04 80 	movabs $0x80042217f3,%rcx
  8004214728:	00 00 00 
  800421472b:	48 ba e7 16 22 04 80 	movabs $0x80042216e7,%rdx
  8004214732:	00 00 00 
  8004214735:	be 95 01 00 00       	mov    $0x195,%esi
  800421473a:	48 bf fc 16 22 04 80 	movabs $0x80042216fc,%rdi
  8004214741:	00 00 00 
  8004214744:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214749:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004214750:	00 00 00 
  8004214753:	41 ff d0             	callq  *%r8
	ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  8004214756:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421475a:	4c 8b 48 40          	mov    0x40(%rax),%r9
  800421475e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214762:	4c 8b 40 38          	mov    0x38(%rax),%r8
  8004214766:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421476a:	48 8b 48 70          	mov    0x70(%rax),%rcx
  800421476e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214772:	48 8b 50 68          	mov    0x68(%rax),%rdx
  8004214776:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800421477a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421477e:	ff 75 a0             	pushq  -0x60(%rbp)
  8004214781:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  8004214785:	57                   	push   %rdi
  8004214786:	6a ff                	pushq  $0xffffffffffffffff
  8004214788:	6a 00                	pushq  $0x0
  800421478a:	48 89 c7             	mov    %rax,%rdi
  800421478d:	48 b8 e8 37 21 04 80 	movabs $0x80042137e8,%rax
  8004214794:	00 00 00 
  8004214797:	ff d0                	callq  *%rax
  8004214799:	48 83 c4 20          	add    $0x20,%rsp
  800421479d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				    cie->cie_instlen, cie->cie_caf,
				    cie->cie_daf, 0, ~0ULL,
				    &row_pc, error);
	if (ret != DW_DLE_NONE)
  80042147a0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042147a4:	74 08                	je     80042147ae <_dwarf_frame_get_internal_table+0x1e0>
		return (ret);
  80042147a6:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042147a9:	e9 8a 00 00 00       	jmpq   8004214838 <_dwarf_frame_get_internal_table+0x26a>
	/* Run instructions in FDE. */
	if (pc_req >= fde->fde_initloc) {
  80042147ae:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042147b2:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042147b6:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042147ba:	77 61                	ja     800421481d <_dwarf_frame_get_internal_table+0x24f>
		ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  80042147bc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042147c0:	48 8b 78 30          	mov    0x30(%rax),%rdi
  80042147c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042147c8:	4c 8b 48 40          	mov    0x40(%rax),%r9
  80042147cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042147d0:	4c 8b 50 38          	mov    0x38(%rax),%r10
  80042147d4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042147d8:	48 8b 48 58          	mov    0x58(%rax),%rcx
  80042147dc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042147e0:	48 8b 50 50          	mov    0x50(%rax),%rdx
  80042147e4:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042147e8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042147ec:	ff 75 a0             	pushq  -0x60(%rbp)
  80042147ef:	4c 8d 45 d8          	lea    -0x28(%rbp),%r8
  80042147f3:	41 50                	push   %r8
  80042147f5:	ff 75 b8             	pushq  -0x48(%rbp)
  80042147f8:	57                   	push   %rdi
  80042147f9:	4d 89 d0             	mov    %r10,%r8
  80042147fc:	48 89 c7             	mov    %rax,%rdi
  80042147ff:	48 b8 e8 37 21 04 80 	movabs $0x80042137e8,%rax
  8004214806:	00 00 00 
  8004214809:	ff d0                	callq  *%rax
  800421480b:	48 83 c4 20          	add    $0x20,%rsp
  800421480f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
					    fde->fde_instlen, cie->cie_caf,
					    cie->cie_daf,
					    fde->fde_initloc, pc_req,
					    &row_pc, error);
		if (ret != DW_DLE_NONE)
  8004214812:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004214816:	74 05                	je     800421481d <_dwarf_frame_get_internal_table+0x24f>
			return (ret);
  8004214818:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421481b:	eb 1b                	jmp    8004214838 <_dwarf_frame_get_internal_table+0x26a>
	}

	*ret_rt = rt;
  800421481d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214821:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004214825:	48 89 10             	mov    %rdx,(%rax)
	*ret_row_pc = row_pc;
  8004214828:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421482c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004214830:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  8004214833:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214838:	c9                   	leaveq 
  8004214839:	c3                   	retq   

000000800421483a <dwarf_get_fde_info_for_all_regs>:
int
dwarf_get_fde_info_for_all_regs(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_requested,
				Dwarf_Regtable *reg_table, Dwarf_Addr *row_pc,
				Dwarf_Error *error)
{
  800421483a:	55                   	push   %rbp
  800421483b:	48 89 e5             	mov    %rsp,%rbp
  800421483e:	48 83 ec 50          	sub    $0x50,%rsp
  8004214842:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004214846:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421484a:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800421484e:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004214852:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  8004214856:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
	Dwarf_Regtable3 *rt;
	Dwarf_Addr pc;
	Dwarf_Half cfa;
	int i, ret;

	if (fde == NULL || reg_table == NULL) {
  800421485a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800421485f:	74 07                	je     8004214868 <dwarf_get_fde_info_for_all_regs+0x2e>
  8004214861:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004214866:	75 0a                	jne    8004214872 <dwarf_get_fde_info_for_all_regs+0x38>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  8004214868:	b8 01 00 00 00       	mov    $0x1,%eax
  800421486d:	e9 f9 02 00 00       	jmpq   8004214b6b <dwarf_get_fde_info_for_all_regs+0x331>
	}

	assert(dbg != NULL);
  8004214872:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004214877:	75 35                	jne    80042148ae <dwarf_get_fde_info_for_all_regs+0x74>
  8004214879:	48 b9 e7 17 22 04 80 	movabs $0x80042217e7,%rcx
  8004214880:	00 00 00 
  8004214883:	48 ba e7 16 22 04 80 	movabs $0x80042216e7,%rdx
  800421488a:	00 00 00 
  800421488d:	be bf 01 00 00       	mov    $0x1bf,%esi
  8004214892:	48 bf fc 16 22 04 80 	movabs $0x80042216fc,%rdi
  8004214899:	00 00 00 
  800421489c:	b8 00 00 00 00       	mov    $0x0,%eax
  80042148a1:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042148a8:	00 00 00 
  80042148ab:	41 ff d0             	callq  *%r8

	if (pc_requested < fde->fde_initloc ||
  80042148ae:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042148b2:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042148b6:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042148ba:	77 19                	ja     80042148d5 <dwarf_get_fde_info_for_all_regs+0x9b>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
  80042148bc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042148c0:	48 8b 50 30          	mov    0x30(%rax),%rdx
  80042148c4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042148c8:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042148cc:	48 01 d0             	add    %rdx,%rax
		return (DW_DLV_ERROR);
	}

	assert(dbg != NULL);

	if (pc_requested < fde->fde_initloc ||
  80042148cf:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042148d3:	77 0a                	ja     80042148df <dwarf_get_fde_info_for_all_regs+0xa5>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
		return (DW_DLV_ERROR);
  80042148d5:	b8 01 00 00 00       	mov    $0x1,%eax
  80042148da:	e9 8c 02 00 00       	jmpq   8004214b6b <dwarf_get_fde_info_for_all_regs+0x331>
	}

	ret = _dwarf_frame_get_internal_table(dbg, fde, pc_requested, &rt, &pc,
  80042148df:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
  80042148e3:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
  80042148e7:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  80042148eb:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042148ef:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042148f3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042148f7:	4d 89 c1             	mov    %r8,%r9
  80042148fa:	49 89 f8             	mov    %rdi,%r8
  80042148fd:	48 89 c7             	mov    %rax,%rdi
  8004214900:	48 b8 ce 45 21 04 80 	movabs $0x80042145ce,%rax
  8004214907:	00 00 00 
  800421490a:	ff d0                	callq  *%rax
  800421490c:	89 45 f8             	mov    %eax,-0x8(%rbp)
					      error);
	if (ret != DW_DLE_NONE)
  800421490f:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004214913:	74 0a                	je     800421491f <dwarf_get_fde_info_for_all_regs+0xe5>
		return (DW_DLV_ERROR);
  8004214915:	b8 01 00 00 00       	mov    $0x1,%eax
  800421491a:	e9 4c 02 00 00       	jmpq   8004214b6b <dwarf_get_fde_info_for_all_regs+0x331>
	/*
	 * Copy the CFA rule to the column intended for holding the CFA,
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
  800421491f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214923:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004214927:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	if (cfa < DW_REG_TABLE_SIZE) {
  800421492b:	66 83 7d f6 41       	cmpw   $0x41,-0xa(%rbp)
  8004214930:	0f 87 b7 00 00 00    	ja     80042149ed <dwarf_get_fde_info_for_all_regs+0x1b3>
		reg_table->rules[cfa].dw_offset_relevant =
  8004214936:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
			CFA.dw_offset_relevant;
  800421493a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421493e:	0f b6 00             	movzbl (%rax),%eax
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
	if (cfa < DW_REG_TABLE_SIZE) {
		reg_table->rules[cfa].dw_offset_relevant =
  8004214941:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214945:	48 63 c9             	movslq %ecx,%rcx
  8004214948:	48 83 c1 01          	add    $0x1,%rcx
  800421494c:	48 c1 e1 04          	shl    $0x4,%rcx
  8004214950:	48 01 ca             	add    %rcx,%rdx
  8004214953:	88 02                	mov    %al,(%rdx)
			CFA.dw_offset_relevant;
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
  8004214955:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004214959:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421495d:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8004214961:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214965:	48 63 c9             	movslq %ecx,%rcx
  8004214968:	48 83 c1 01          	add    $0x1,%rcx
  800421496c:	48 c1 e1 04          	shl    $0x4,%rcx
  8004214970:	48 01 ca             	add    %rcx,%rdx
  8004214973:	48 83 c2 01          	add    $0x1,%rdx
  8004214977:	88 02                	mov    %al,(%rdx)
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
  8004214979:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800421497d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214981:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004214985:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214989:	48 63 c9             	movslq %ecx,%rcx
  800421498c:	48 83 c1 01          	add    $0x1,%rcx
  8004214990:	48 c1 e1 04          	shl    $0x4,%rcx
  8004214994:	48 01 ca             	add    %rcx,%rdx
  8004214997:	48 83 c2 02          	add    $0x2,%rdx
  800421499b:	66 89 02             	mov    %ax,(%rdx)
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
  800421499e:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  80042149a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042149a6:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042149aa:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042149ae:	48 63 c9             	movslq %ecx,%rcx
  80042149b1:	48 83 c1 01          	add    $0x1,%rcx
  80042149b5:	48 c1 e1 04          	shl    $0x4,%rcx
  80042149b9:	48 01 ca             	add    %rcx,%rdx
  80042149bc:	48 83 c2 08          	add    $0x8,%rdx
  80042149c0:	48 89 02             	mov    %rax,(%rdx)
		reg_table->cfa_rule = reg_table->rules[cfa];
  80042149c3:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80042149c7:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80042149cb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042149cf:	48 63 d2             	movslq %edx,%rdx
  80042149d2:	48 83 c2 01          	add    $0x1,%rdx
  80042149d6:	48 c1 e2 04          	shl    $0x4,%rdx
  80042149da:	48 01 d0             	add    %rdx,%rax
  80042149dd:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042149e1:	48 8b 00             	mov    (%rax),%rax
  80042149e4:	48 89 01             	mov    %rax,(%rcx)
  80042149e7:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  80042149eb:	eb 3c                	jmp    8004214a29 <dwarf_get_fde_info_for_all_regs+0x1ef>
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
		    CFA.dw_offset_relevant;
  80042149ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042149f1:	0f b6 10             	movzbl (%rax),%edx
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
		reg_table->cfa_rule = reg_table->rules[cfa];
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
  80042149f4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042149f8:	88 10                	mov    %dl,(%rax)
		    CFA.dw_offset_relevant;
		reg_table->cfa_rule.dw_value_type = CFA.dw_value_type;
  80042149fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042149fe:	0f b6 50 01          	movzbl 0x1(%rax),%edx
  8004214a02:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214a06:	88 50 01             	mov    %dl,0x1(%rax)
		reg_table->cfa_rule.dw_regnum = CFA.dw_regnum;
  8004214a09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214a0d:	0f b7 50 02          	movzwl 0x2(%rax),%edx
  8004214a11:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214a15:	66 89 50 02          	mov    %dx,0x2(%rax)
		reg_table->cfa_rule.dw_offset = CFA.dw_offset_or_block_len;
  8004214a19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214a1d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214a21:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214a25:	48 89 50 08          	mov    %rdx,0x8(%rax)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  8004214a29:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004214a30:	e9 05 01 00 00       	jmpq   8004214b3a <dwarf_get_fde_info_for_all_regs+0x300>
	     i++) {

		/* Do not overwrite CFA column */
		if (i == cfa)
  8004214a35:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8004214a39:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004214a3c:	0f 84 f3 00 00 00    	je     8004214b35 <dwarf_get_fde_info_for_all_regs+0x2fb>
			continue;

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
  8004214a42:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214a46:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214a4a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004214a4d:	48 63 d0             	movslq %eax,%rdx
  8004214a50:	48 89 d0             	mov    %rdx,%rax
  8004214a53:	48 01 c0             	add    %rax,%rax
  8004214a56:	48 01 d0             	add    %rdx,%rax
  8004214a59:	48 c1 e0 03          	shl    $0x3,%rax
  8004214a5d:	48 01 c8             	add    %rcx,%rax
  8004214a60:	0f b6 00             	movzbl (%rax),%eax

		/* Do not overwrite CFA column */
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
  8004214a63:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214a67:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004214a6a:	48 63 c9             	movslq %ecx,%rcx
  8004214a6d:	48 83 c1 01          	add    $0x1,%rcx
  8004214a71:	48 c1 e1 04          	shl    $0x4,%rcx
  8004214a75:	48 01 ca             	add    %rcx,%rdx
  8004214a78:	88 02                	mov    %al,(%rdx)
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
  8004214a7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214a7e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214a82:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004214a85:	48 63 d0             	movslq %eax,%rdx
  8004214a88:	48 89 d0             	mov    %rdx,%rax
  8004214a8b:	48 01 c0             	add    %rax,%rax
  8004214a8e:	48 01 d0             	add    %rdx,%rax
  8004214a91:	48 c1 e0 03          	shl    $0x3,%rax
  8004214a95:	48 01 c8             	add    %rcx,%rax
  8004214a98:	0f b6 40 01          	movzbl 0x1(%rax),%eax
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
  8004214a9c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214aa0:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004214aa3:	48 63 c9             	movslq %ecx,%rcx
  8004214aa6:	48 83 c1 01          	add    $0x1,%rcx
  8004214aaa:	48 c1 e1 04          	shl    $0x4,%rcx
  8004214aae:	48 01 ca             	add    %rcx,%rdx
  8004214ab1:	48 83 c2 01          	add    $0x1,%rdx
  8004214ab5:	88 02                	mov    %al,(%rdx)
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
  8004214ab7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214abb:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214abf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004214ac2:	48 63 d0             	movslq %eax,%rdx
  8004214ac5:	48 89 d0             	mov    %rdx,%rax
  8004214ac8:	48 01 c0             	add    %rax,%rax
  8004214acb:	48 01 d0             	add    %rdx,%rax
  8004214ace:	48 c1 e0 03          	shl    $0x3,%rax
  8004214ad2:	48 01 c8             	add    %rcx,%rax
  8004214ad5:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004214ad9:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214add:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004214ae0:	48 63 c9             	movslq %ecx,%rcx
  8004214ae3:	48 83 c1 01          	add    $0x1,%rcx
  8004214ae7:	48 c1 e1 04          	shl    $0x4,%rcx
  8004214aeb:	48 01 ca             	add    %rcx,%rdx
  8004214aee:	48 83 c2 02          	add    $0x2,%rdx
  8004214af2:	66 89 02             	mov    %ax,(%rdx)
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
  8004214af5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214af9:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214afd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004214b00:	48 63 d0             	movslq %eax,%rdx
  8004214b03:	48 89 d0             	mov    %rdx,%rax
  8004214b06:	48 01 c0             	add    %rax,%rax
  8004214b09:	48 01 d0             	add    %rdx,%rax
  8004214b0c:	48 c1 e0 03          	shl    $0x3,%rax
  8004214b10:	48 01 c8             	add    %rcx,%rax
  8004214b13:	48 8b 40 08          	mov    0x8(%rax),%rax
		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
  8004214b17:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214b1b:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004214b1e:	48 63 c9             	movslq %ecx,%rcx
  8004214b21:	48 83 c1 01          	add    $0x1,%rcx
  8004214b25:	48 c1 e1 04          	shl    $0x4,%rcx
  8004214b29:	48 01 ca             	add    %rcx,%rdx
  8004214b2c:	48 83 c2 08          	add    $0x8,%rdx
  8004214b30:	48 89 02             	mov    %rax,(%rdx)
  8004214b33:	eb 01                	jmp    8004214b36 <dwarf_get_fde_info_for_all_regs+0x2fc>
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
	     i++) {

		/* Do not overwrite CFA column */
		if (i == cfa)
			continue;
  8004214b35:	90                   	nop

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
	     i++) {
  8004214b36:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  8004214b3a:	83 7d fc 41          	cmpl   $0x41,-0x4(%rbp)
  8004214b3e:	7f 14                	jg     8004214b54 <dwarf_get_fde_info_for_all_regs+0x31a>
  8004214b40:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214b44:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  8004214b48:	0f b7 c0             	movzwl %ax,%eax
  8004214b4b:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004214b4e:	0f 8f e1 fe ff ff    	jg     8004214a35 <dwarf_get_fde_info_for_all_regs+0x1fb>
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
	}

	if (row_pc) *row_pc = pc;
  8004214b54:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004214b59:	74 0b                	je     8004214b66 <dwarf_get_fde_info_for_all_regs+0x32c>
  8004214b5b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214b5f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214b63:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLV_OK);
  8004214b66:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214b6b:	c9                   	leaveq 
  8004214b6c:	c3                   	retq   

0000008004214b6d <_dwarf_frame_read_lsb_encoded>:

static int
_dwarf_frame_read_lsb_encoded(Dwarf_Debug dbg, uint64_t *val, uint8_t *data,
			      uint64_t *offsetp, uint8_t encode, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004214b6d:	55                   	push   %rbp
  8004214b6e:	48 89 e5             	mov    %rsp,%rbp
  8004214b71:	48 83 ec 40          	sub    $0x40,%rsp
  8004214b75:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004214b79:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004214b7d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004214b81:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004214b85:	44 89 c0             	mov    %r8d,%eax
  8004214b88:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  8004214b8c:	88 45 cc             	mov    %al,-0x34(%rbp)
	uint8_t application;

	if (encode == DW_EH_PE_omit)
  8004214b8f:	80 7d cc ff          	cmpb   $0xff,-0x34(%rbp)
  8004214b93:	75 0a                	jne    8004214b9f <_dwarf_frame_read_lsb_encoded+0x32>
		return (DW_DLE_NONE);
  8004214b95:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214b9a:	e9 f8 01 00 00       	jmpq   8004214d97 <_dwarf_frame_read_lsb_encoded+0x22a>

	application = encode & 0xf0;
  8004214b9f:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004214ba3:	83 e0 f0             	and    $0xfffffff0,%eax
  8004214ba6:	88 45 ff             	mov    %al,-0x1(%rbp)
	encode &= 0x0f;
  8004214ba9:	80 65 cc 0f          	andb   $0xf,-0x34(%rbp)

	switch (encode) {
  8004214bad:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004214bb1:	83 f8 0c             	cmp    $0xc,%eax
  8004214bb4:	0f 87 84 01 00 00    	ja     8004214d3e <_dwarf_frame_read_lsb_encoded+0x1d1>
  8004214bba:	89 c0                	mov    %eax,%eax
  8004214bbc:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004214bc3:	00 
  8004214bc4:	48 b8 00 18 22 04 80 	movabs $0x8004221800,%rax
  8004214bcb:	00 00 00 
  8004214bce:	48 01 d0             	add    %rdx,%rax
  8004214bd1:	48 8b 00             	mov    (%rax),%rax
  8004214bd4:	ff e0                	jmpq   *%rax
	case DW_EH_PE_absptr:
		*val = dbg->read(data, offsetp, dbg->dbg_pointer_size);
  8004214bd6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214bda:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214bde:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214be2:	8b 52 28             	mov    0x28(%rdx),%edx
  8004214be5:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004214be9:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004214bed:	48 89 cf             	mov    %rcx,%rdi
  8004214bf0:	ff d0                	callq  *%rax
  8004214bf2:	48 89 c2             	mov    %rax,%rdx
  8004214bf5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214bf9:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004214bfc:	e9 44 01 00 00       	jmpq   8004214d45 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_uleb128:
		*val = _dwarf_read_uleb128(data, offsetp);
  8004214c01:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214c05:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214c09:	48 89 d6             	mov    %rdx,%rsi
  8004214c0c:	48 89 c7             	mov    %rax,%rdi
  8004214c0f:	48 b8 d1 1c 21 04 80 	movabs $0x8004211cd1,%rax
  8004214c16:	00 00 00 
  8004214c19:	ff d0                	callq  *%rax
  8004214c1b:	48 89 c2             	mov    %rax,%rdx
  8004214c1e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214c22:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004214c25:	e9 1b 01 00 00       	jmpq   8004214d45 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_udata2:
		*val = dbg->read(data, offsetp, 2);
  8004214c2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214c2e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214c32:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004214c36:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004214c3a:	ba 02 00 00 00       	mov    $0x2,%edx
  8004214c3f:	48 89 cf             	mov    %rcx,%rdi
  8004214c42:	ff d0                	callq  *%rax
  8004214c44:	48 89 c2             	mov    %rax,%rdx
  8004214c47:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214c4b:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004214c4e:	e9 f2 00 00 00       	jmpq   8004214d45 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_udata4:
		*val = dbg->read(data, offsetp, 4);
  8004214c53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214c57:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214c5b:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004214c5f:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004214c63:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214c68:	48 89 cf             	mov    %rcx,%rdi
  8004214c6b:	ff d0                	callq  *%rax
  8004214c6d:	48 89 c2             	mov    %rax,%rdx
  8004214c70:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214c74:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004214c77:	e9 c9 00 00 00       	jmpq   8004214d45 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_udata8:
		*val = dbg->read(data, offsetp, 8);
  8004214c7c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214c80:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214c84:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004214c88:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004214c8c:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214c91:	48 89 cf             	mov    %rcx,%rdi
  8004214c94:	ff d0                	callq  *%rax
  8004214c96:	48 89 c2             	mov    %rax,%rdx
  8004214c99:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214c9d:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004214ca0:	e9 a0 00 00 00       	jmpq   8004214d45 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_sleb128:
		*val = _dwarf_read_sleb128(data, offsetp);
  8004214ca5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214ca9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214cad:	48 89 d6             	mov    %rdx,%rsi
  8004214cb0:	48 89 c7             	mov    %rax,%rdi
  8004214cb3:	48 b8 2d 1c 21 04 80 	movabs $0x8004211c2d,%rax
  8004214cba:	00 00 00 
  8004214cbd:	ff d0                	callq  *%rax
  8004214cbf:	48 89 c2             	mov    %rax,%rdx
  8004214cc2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214cc6:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004214cc9:	eb 7a                	jmp    8004214d45 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_sdata2:
		*val = (int16_t) dbg->read(data, offsetp, 2);
  8004214ccb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214ccf:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214cd3:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004214cd7:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004214cdb:	ba 02 00 00 00       	mov    $0x2,%edx
  8004214ce0:	48 89 cf             	mov    %rcx,%rdi
  8004214ce3:	ff d0                	callq  *%rax
  8004214ce5:	48 0f bf d0          	movswq %ax,%rdx
  8004214ce9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214ced:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004214cf0:	eb 53                	jmp    8004214d45 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_sdata4:
		*val = (int32_t) dbg->read(data, offsetp, 4);
  8004214cf2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214cf6:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214cfa:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004214cfe:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004214d02:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214d07:	48 89 cf             	mov    %rcx,%rdi
  8004214d0a:	ff d0                	callq  *%rax
  8004214d0c:	48 63 d0             	movslq %eax,%rdx
  8004214d0f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214d13:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004214d16:	eb 2d                	jmp    8004214d45 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_sdata8:
		*val = dbg->read(data, offsetp, 8);
  8004214d18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214d1c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214d20:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004214d24:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004214d28:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214d2d:	48 89 cf             	mov    %rcx,%rdi
  8004214d30:	ff d0                	callq  *%rax
  8004214d32:	48 89 c2             	mov    %rax,%rdx
  8004214d35:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214d39:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004214d3c:	eb 07                	jmp    8004214d45 <_dwarf_frame_read_lsb_encoded+0x1d8>
	default:
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004214d3e:	b8 14 00 00 00       	mov    $0x14,%eax
  8004214d43:	eb 52                	jmp    8004214d97 <_dwarf_frame_read_lsb_encoded+0x22a>
	}

	if (application == DW_EH_PE_pcrel) {
  8004214d45:	80 7d ff 10          	cmpb   $0x10,-0x1(%rbp)
  8004214d49:	75 47                	jne    8004214d92 <_dwarf_frame_read_lsb_encoded+0x225>
		/*
		 * Value is relative to .eh_frame section virtual addr.
		 */
		switch (encode) {
  8004214d4b:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004214d4f:	83 f8 01             	cmp    $0x1,%eax
  8004214d52:	7c 3d                	jl     8004214d91 <_dwarf_frame_read_lsb_encoded+0x224>
  8004214d54:	83 f8 04             	cmp    $0x4,%eax
  8004214d57:	7e 0a                	jle    8004214d63 <_dwarf_frame_read_lsb_encoded+0x1f6>
  8004214d59:	83 e8 09             	sub    $0x9,%eax
  8004214d5c:	83 f8 03             	cmp    $0x3,%eax
  8004214d5f:	77 30                	ja     8004214d91 <_dwarf_frame_read_lsb_encoded+0x224>
  8004214d61:	eb 17                	jmp    8004214d7a <_dwarf_frame_read_lsb_encoded+0x20d>
		case DW_EH_PE_uleb128:
		case DW_EH_PE_udata2:
		case DW_EH_PE_udata4:
		case DW_EH_PE_udata8:
			*val += pc;
  8004214d63:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214d67:	48 8b 10             	mov    (%rax),%rdx
  8004214d6a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214d6e:	48 01 c2             	add    %rax,%rdx
  8004214d71:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214d75:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004214d78:	eb 18                	jmp    8004214d92 <_dwarf_frame_read_lsb_encoded+0x225>
		case DW_EH_PE_sleb128:
		case DW_EH_PE_sdata2:
		case DW_EH_PE_sdata4:
		case DW_EH_PE_sdata8:
			*val = pc + (int64_t) *val;
  8004214d7a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214d7e:	48 8b 10             	mov    (%rax),%rdx
  8004214d81:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214d85:	48 01 c2             	add    %rax,%rdx
  8004214d88:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214d8c:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004214d8f:	eb 01                	jmp    8004214d92 <_dwarf_frame_read_lsb_encoded+0x225>
		default:
			/* DW_EH_PE_absptr is absolute value. */
			break;
  8004214d91:	90                   	nop
		}
	}

	/* XXX Applications other than DW_EH_PE_pcrel are not handled. */

	return (DW_DLE_NONE);
  8004214d92:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214d97:	c9                   	leaveq 
  8004214d98:	c3                   	retq   

0000008004214d99 <_dwarf_frame_parse_lsb_cie_augment>:

static int
_dwarf_frame_parse_lsb_cie_augment(Dwarf_Debug dbg, Dwarf_Cie cie,
				   Dwarf_Error *error)
{
  8004214d99:	55                   	push   %rbp
  8004214d9a:	48 89 e5             	mov    %rsp,%rbp
  8004214d9d:	48 83 ec 50          	sub    $0x50,%rsp
  8004214da1:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004214da5:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004214da9:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	uint8_t *aug_p, *augdata_p;
	uint64_t val, offset;
	uint8_t encode;
	int ret;

	assert(cie->cie_augment != NULL && *cie->cie_augment == 'z');
  8004214dad:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214db1:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214db5:	48 85 c0             	test   %rax,%rax
  8004214db8:	74 0f                	je     8004214dc9 <_dwarf_frame_parse_lsb_cie_augment+0x30>
  8004214dba:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214dbe:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214dc2:	0f b6 00             	movzbl (%rax),%eax
  8004214dc5:	3c 7a                	cmp    $0x7a,%al
  8004214dc7:	74 35                	je     8004214dfe <_dwarf_frame_parse_lsb_cie_augment+0x65>
  8004214dc9:	48 b9 68 18 22 04 80 	movabs $0x8004221868,%rcx
  8004214dd0:	00 00 00 
  8004214dd3:	48 ba e7 16 22 04 80 	movabs $0x80042216e7,%rdx
  8004214dda:	00 00 00 
  8004214ddd:	be 4a 02 00 00       	mov    $0x24a,%esi
  8004214de2:	48 bf fc 16 22 04 80 	movabs $0x80042216fc,%rdi
  8004214de9:	00 00 00 
  8004214dec:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214df1:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004214df8:	00 00 00 
  8004214dfb:	41 ff d0             	callq  *%r8
	/*
	 * Here we're only interested in the presence of augment 'R'
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
  8004214dfe:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214e02:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214e06:	48 83 c0 01          	add    $0x1,%rax
  8004214e0a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	augdata_p = cie->cie_augdata;
  8004214e0e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214e12:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004214e16:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (*aug_p != '\0') {
  8004214e1a:	e9 b4 00 00 00       	jmpq   8004214ed3 <_dwarf_frame_parse_lsb_cie_augment+0x13a>
		switch (*aug_p) {
  8004214e1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214e23:	0f b6 00             	movzbl (%rax),%eax
  8004214e26:	0f b6 c0             	movzbl %al,%eax
  8004214e29:	83 f8 50             	cmp    $0x50,%eax
  8004214e2c:	74 18                	je     8004214e46 <_dwarf_frame_parse_lsb_cie_augment+0xad>
  8004214e2e:	83 f8 52             	cmp    $0x52,%eax
  8004214e31:	74 7c                	je     8004214eaf <_dwarf_frame_parse_lsb_cie_augment+0x116>
  8004214e33:	83 f8 4c             	cmp    $0x4c,%eax
  8004214e36:	0f 85 8b 00 00 00    	jne    8004214ec7 <_dwarf_frame_parse_lsb_cie_augment+0x12e>
		case 'L':
			/* Skip one augment in augment data. */
			augdata_p++;
  8004214e3c:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  8004214e41:	e9 88 00 00 00       	jmpq   8004214ece <_dwarf_frame_parse_lsb_cie_augment+0x135>
		case 'P':
			/* Skip two augments in augment data. */
			encode = *augdata_p++;
  8004214e46:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214e4a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214e4e:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004214e52:	0f b6 00             	movzbl (%rax),%eax
  8004214e55:	88 45 ef             	mov    %al,-0x11(%rbp)
			offset = 0;
  8004214e58:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004214e5f:	00 
			ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004214e60:	0f b6 7d ef          	movzbl -0x11(%rbp),%edi
  8004214e64:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004214e68:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004214e6c:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8004214e70:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214e74:	48 83 ec 08          	sub    $0x8,%rsp
  8004214e78:	ff 75 b8             	pushq  -0x48(%rbp)
  8004214e7b:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004214e81:	41 89 f8             	mov    %edi,%r8d
  8004214e84:	48 89 c7             	mov    %rax,%rdi
  8004214e87:	48 b8 6d 4b 21 04 80 	movabs $0x8004214b6d,%rax
  8004214e8e:	00 00 00 
  8004214e91:	ff d0                	callq  *%rax
  8004214e93:	48 83 c4 10          	add    $0x10,%rsp
  8004214e97:	89 45 e8             	mov    %eax,-0x18(%rbp)
							    augdata_p, &offset, encode, 0, error);
			if (ret != DW_DLE_NONE)
  8004214e9a:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  8004214e9e:	74 05                	je     8004214ea5 <_dwarf_frame_parse_lsb_cie_augment+0x10c>
				return (ret);
  8004214ea0:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004214ea3:	eb 42                	jmp    8004214ee7 <_dwarf_frame_parse_lsb_cie_augment+0x14e>
			augdata_p += offset;
  8004214ea5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214ea9:	48 01 45 f0          	add    %rax,-0x10(%rbp)
			break;
  8004214ead:	eb 1f                	jmp    8004214ece <_dwarf_frame_parse_lsb_cie_augment+0x135>
		case 'R':
			cie->cie_fde_encode = *augdata_p++;
  8004214eaf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214eb3:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214eb7:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004214ebb:	0f b6 10             	movzbl (%rax),%edx
  8004214ebe:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214ec2:	88 50 60             	mov    %dl,0x60(%rax)
			break;
  8004214ec5:	eb 07                	jmp    8004214ece <_dwarf_frame_parse_lsb_cie_augment+0x135>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004214ec7:	b8 14 00 00 00       	mov    $0x14,%eax
  8004214ecc:	eb 19                	jmp    8004214ee7 <_dwarf_frame_parse_lsb_cie_augment+0x14e>
		}
		aug_p++;
  8004214ece:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
	augdata_p = cie->cie_augdata;
	while (*aug_p != '\0') {
  8004214ed3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214ed7:	0f b6 00             	movzbl (%rax),%eax
  8004214eda:	84 c0                	test   %al,%al
  8004214edc:	0f 85 3d ff ff ff    	jne    8004214e1f <_dwarf_frame_parse_lsb_cie_augment+0x86>
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		}
		aug_p++;
	}

	return (DW_DLE_NONE);
  8004214ee2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214ee7:	c9                   	leaveq 
  8004214ee8:	c3                   	retq   

0000008004214ee9 <_dwarf_frame_set_cie>:


static int
_dwarf_frame_set_cie(Dwarf_Debug dbg, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, Dwarf_Cie ret_cie, Dwarf_Error *error)
{
  8004214ee9:	55                   	push   %rbp
  8004214eea:	48 89 e5             	mov    %rsp,%rbp
  8004214eed:	48 83 ec 60          	sub    $0x60,%rsp
  8004214ef1:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004214ef5:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004214ef9:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004214efd:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004214f01:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
	Dwarf_Cie cie;
	uint64_t length;
	int dwarf_size, ret;
	char *p;

	assert(ret_cie);
  8004214f05:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004214f0a:	75 35                	jne    8004214f41 <_dwarf_frame_set_cie+0x58>
  8004214f0c:	48 b9 9d 18 22 04 80 	movabs $0x800422189d,%rcx
  8004214f13:	00 00 00 
  8004214f16:	48 ba e7 16 22 04 80 	movabs $0x80042216e7,%rdx
  8004214f1d:	00 00 00 
  8004214f20:	be 7b 02 00 00       	mov    $0x27b,%esi
  8004214f25:	48 bf fc 16 22 04 80 	movabs $0x80042216fc,%rdi
  8004214f2c:	00 00 00 
  8004214f2f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214f34:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004214f3b:	00 00 00 
  8004214f3e:	41 ff d0             	callq  *%r8
	cie = ret_cie;
  8004214f41:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214f45:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cie->cie_dbg = dbg;
  8004214f49:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214f4d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214f51:	48 89 10             	mov    %rdx,(%rax)
	cie->cie_offset = *off;
  8004214f54:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214f58:	48 8b 10             	mov    (%rax),%rdx
  8004214f5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214f5f:	48 89 50 10          	mov    %rdx,0x10(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004214f63:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214f67:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214f6b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214f6f:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214f73:	48 89 d7             	mov    %rdx,%rdi
  8004214f76:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004214f7a:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214f7f:	48 89 ce             	mov    %rcx,%rsi
  8004214f82:	ff d0                	callq  *%rax
  8004214f84:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004214f88:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214f8d:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004214f91:	75 2e                	jne    8004214fc1 <_dwarf_frame_set_cie+0xd8>
		dwarf_size = 8;
  8004214f93:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004214f9a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214f9e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214fa2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214fa6:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214faa:	48 89 d7             	mov    %rdx,%rdi
  8004214fad:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004214fb1:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214fb6:	48 89 ce             	mov    %rcx,%rsi
  8004214fb9:	ff d0                	callq  *%rax
  8004214fbb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004214fbf:	eb 07                	jmp    8004214fc8 <_dwarf_frame_set_cie+0xdf>
	} else
		dwarf_size = 4;
  8004214fc1:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004214fc8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214fcc:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004214fd0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214fd4:	48 8b 00             	mov    (%rax),%rax
  8004214fd7:	48 29 c2             	sub    %rax,%rdx
  8004214fda:	48 89 d0             	mov    %rdx,%rax
  8004214fdd:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004214fe1:	73 0a                	jae    8004214fed <_dwarf_frame_set_cie+0x104>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004214fe3:	b8 12 00 00 00       	mov    $0x12,%eax
  8004214fe8:	e9 7e 03 00 00       	jmpq   800421536b <_dwarf_frame_set_cie+0x482>
	}

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
  8004214fed:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214ff1:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214ff5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214ff9:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214ffd:	48 89 d7             	mov    %rdx,%rdi
  8004215000:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004215003:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004215007:	48 89 ce             	mov    %rcx,%rsi
  800421500a:	ff d0                	callq  *%rax
	cie->cie_length = length;
  800421500c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215010:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215014:	48 89 50 18          	mov    %rdx,0x18(%rax)

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004215018:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421501c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215020:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004215024:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004215028:	48 89 d7             	mov    %rdx,%rdi
  800421502b:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  800421502f:	ba 01 00 00 00       	mov    $0x1,%edx
  8004215034:	48 89 ce             	mov    %rcx,%rsi
  8004215037:	ff d0                	callq  *%rax
  8004215039:	89 c2                	mov    %eax,%edx
  800421503b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421503f:	66 89 50 20          	mov    %dx,0x20(%rax)
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004215043:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215047:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  800421504b:	66 83 f8 01          	cmp    $0x1,%ax
  800421504f:	74 26                	je     8004215077 <_dwarf_frame_set_cie+0x18e>
  8004215051:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215055:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004215059:	66 83 f8 03          	cmp    $0x3,%ax
  800421505d:	74 18                	je     8004215077 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
  800421505f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215063:	0f b7 40 20          	movzwl 0x20(%rax),%eax

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
	cie->cie_length = length;

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004215067:	66 83 f8 04          	cmp    $0x4,%ax
  800421506b:	74 0a                	je     8004215077 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_VERSION_BAD);
		return (DW_DLE_FRAME_VERSION_BAD);
  800421506d:	b8 16 00 00 00       	mov    $0x16,%eax
  8004215072:	e9 f4 02 00 00       	jmpq   800421536b <_dwarf_frame_set_cie+0x482>
	}

	cie->cie_augment = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004215077:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421507b:	48 8b 10             	mov    (%rax),%rdx
  800421507e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215082:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004215086:	48 01 d0             	add    %rdx,%rax
  8004215089:	48 89 c2             	mov    %rax,%rdx
  800421508c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215090:	48 89 50 28          	mov    %rdx,0x28(%rax)
	p = (char *)dbg->dbg_eh_offset;
  8004215094:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215098:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421509c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while (p[(*off)++] != '\0')
  80042150a0:	90                   	nop
  80042150a1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042150a5:	48 8b 00             	mov    (%rax),%rax
  80042150a8:	48 8d 48 01          	lea    0x1(%rax),%rcx
  80042150ac:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042150b0:	48 89 0a             	mov    %rcx,(%rdx)
  80042150b3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042150b7:	48 01 d0             	add    %rdx,%rax
  80042150ba:	0f b6 00             	movzbl (%rax),%eax
  80042150bd:	84 c0                	test   %al,%al
  80042150bf:	75 e0                	jne    80042150a1 <_dwarf_frame_set_cie+0x1b8>
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
  80042150c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042150c5:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042150c9:	0f b6 00             	movzbl (%rax),%eax
  80042150cc:	84 c0                	test   %al,%al
  80042150ce:	74 48                	je     8004215118 <_dwarf_frame_set_cie+0x22f>
  80042150d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042150d4:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042150d8:	0f b6 00             	movzbl (%rax),%eax
  80042150db:	3c 7a                	cmp    $0x7a,%al
  80042150dd:	74 39                	je     8004215118 <_dwarf_frame_set_cie+0x22f>
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  80042150df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042150e3:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042150e7:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042150eb:	75 07                	jne    80042150f4 <_dwarf_frame_set_cie+0x20b>
  80042150ed:	ba 04 00 00 00       	mov    $0x4,%edx
  80042150f2:	eb 05                	jmp    80042150f9 <_dwarf_frame_set_cie+0x210>
  80042150f4:	ba 0c 00 00 00       	mov    $0xc,%edx
  80042150f9:	48 01 c2             	add    %rax,%rdx
			cie->cie_length;
  80042150fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215100:	48 8b 40 18          	mov    0x18(%rax),%rax
	while (p[(*off)++] != '\0')
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004215104:	48 01 c2             	add    %rax,%rdx
  8004215107:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421510b:	48 89 10             	mov    %rdx,(%rax)
			cie->cie_length;
		return (DW_DLE_NONE);
  800421510e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215113:	e9 53 02 00 00       	jmpq   800421536b <_dwarf_frame_set_cie+0x482>
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
  8004215118:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421511c:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004215120:	48 be a5 18 22 04 80 	movabs $0x80042218a5,%rsi
  8004215127:	00 00 00 
  800421512a:	48 89 c7             	mov    %rax,%rdi
  800421512d:	48 b8 e4 15 21 04 80 	movabs $0x80042115e4,%rax
  8004215134:	00 00 00 
  8004215137:	ff d0                	callq  *%rax
  8004215139:	48 85 c0             	test   %rax,%rax
  800421513c:	74 2e                	je     800421516c <_dwarf_frame_set_cie+0x283>
		cie->cie_ehdata = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  800421513e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215142:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215146:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421514a:	8b 52 28             	mov    0x28(%rdx),%edx
  800421514d:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004215151:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004215155:	48 89 cf             	mov    %rcx,%rdi
  8004215158:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  800421515c:	48 89 ce             	mov    %rcx,%rsi
  800421515f:	ff d0                	callq  *%rax
  8004215161:	48 89 c2             	mov    %rax,%rdx
  8004215164:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215168:	48 89 50 30          	mov    %rdx,0x30(%rax)
					    dbg->dbg_pointer_size);

	cie->cie_caf = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  800421516c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215170:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004215174:	48 89 c2             	mov    %rax,%rdx
  8004215177:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421517b:	48 89 c6             	mov    %rax,%rsi
  800421517e:	48 89 d7             	mov    %rdx,%rdi
  8004215181:	48 b8 d1 1c 21 04 80 	movabs $0x8004211cd1,%rax
  8004215188:	00 00 00 
  800421518b:	ff d0                	callq  *%rax
  800421518d:	48 89 c2             	mov    %rax,%rdx
  8004215190:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215194:	48 89 50 38          	mov    %rdx,0x38(%rax)
	cie->cie_daf = _dwarf_read_sleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004215198:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421519c:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042151a0:	48 89 c2             	mov    %rax,%rdx
  80042151a3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042151a7:	48 89 c6             	mov    %rax,%rsi
  80042151aa:	48 89 d7             	mov    %rdx,%rdi
  80042151ad:	48 b8 2d 1c 21 04 80 	movabs $0x8004211c2d,%rax
  80042151b4:	00 00 00 
  80042151b7:	ff d0                	callq  *%rax
  80042151b9:	48 89 c2             	mov    %rax,%rdx
  80042151bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042151c0:	48 89 50 40          	mov    %rdx,0x40(%rax)

	/* Return address register. */
	if (cie->cie_version == 1)
  80042151c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042151c8:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  80042151cc:	66 83 f8 01          	cmp    $0x1,%ax
  80042151d0:	75 2e                	jne    8004215200 <_dwarf_frame_set_cie+0x317>
		cie->cie_ra = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  80042151d2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042151d6:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042151da:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042151de:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042151e2:	48 89 d7             	mov    %rdx,%rdi
  80042151e5:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  80042151e9:	ba 01 00 00 00       	mov    $0x1,%edx
  80042151ee:	48 89 ce             	mov    %rcx,%rsi
  80042151f1:	ff d0                	callq  *%rax
  80042151f3:	48 89 c2             	mov    %rax,%rdx
  80042151f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042151fa:	48 89 50 48          	mov    %rdx,0x48(%rax)
  80042151fe:	eb 2c                	jmp    800421522c <_dwarf_frame_set_cie+0x343>
	else
		cie->cie_ra = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004215200:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215204:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004215208:	48 89 c2             	mov    %rax,%rdx
  800421520b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421520f:	48 89 c6             	mov    %rax,%rsi
  8004215212:	48 89 d7             	mov    %rdx,%rdi
  8004215215:	48 b8 d1 1c 21 04 80 	movabs $0x8004211cd1,%rax
  800421521c:	00 00 00 
  800421521f:	ff d0                	callq  *%rax
  8004215221:	48 89 c2             	mov    %rax,%rdx
  8004215224:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215228:	48 89 50 48          	mov    %rdx,0x48(%rax)

	/* Optional CIE augmentation data for .eh_frame section. */
	if (*cie->cie_augment == 'z') {
  800421522c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215230:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004215234:	0f b6 00             	movzbl (%rax),%eax
  8004215237:	3c 7a                	cmp    $0x7a,%al
  8004215239:	0f 85 99 00 00 00    	jne    80042152d8 <_dwarf_frame_set_cie+0x3ef>
		cie->cie_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  800421523f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215243:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004215247:	48 89 c2             	mov    %rax,%rdx
  800421524a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421524e:	48 89 c6             	mov    %rax,%rsi
  8004215251:	48 89 d7             	mov    %rdx,%rdi
  8004215254:	48 b8 d1 1c 21 04 80 	movabs $0x8004211cd1,%rax
  800421525b:	00 00 00 
  800421525e:	ff d0                	callq  *%rax
  8004215260:	48 89 c2             	mov    %rax,%rdx
  8004215263:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215267:	48 89 50 50          	mov    %rdx,0x50(%rax)
		cie->cie_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  800421526b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421526f:	48 8b 10             	mov    (%rax),%rdx
  8004215272:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215276:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421527a:	48 01 d0             	add    %rdx,%rax
  800421527d:	48 89 c2             	mov    %rax,%rdx
  8004215280:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215284:	48 89 50 58          	mov    %rdx,0x58(%rax)
		*off += cie->cie_auglen;
  8004215288:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421528c:	48 8b 10             	mov    (%rax),%rdx
  800421528f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215293:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004215297:	48 01 c2             	add    %rax,%rdx
  800421529a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421529e:	48 89 10             	mov    %rdx,(%rax)
		/*
		 * XXX Use DW_EH_PE_absptr for default FDE PC start/range,
		 * in case _dwarf_frame_parse_lsb_cie_augment fails to
		 * find out the real encode.
		 */
		cie->cie_fde_encode = DW_EH_PE_absptr;
  80042152a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042152a5:	c6 40 60 00          	movb   $0x0,0x60(%rax)
		ret = _dwarf_frame_parse_lsb_cie_augment(dbg, cie, error);
  80042152a9:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80042152ad:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042152b1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042152b5:	48 89 ce             	mov    %rcx,%rsi
  80042152b8:	48 89 c7             	mov    %rax,%rdi
  80042152bb:	48 b8 99 4d 21 04 80 	movabs $0x8004214d99,%rax
  80042152c2:	00 00 00 
  80042152c5:	ff d0                	callq  *%rax
  80042152c7:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  80042152ca:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042152ce:	74 08                	je     80042152d8 <_dwarf_frame_set_cie+0x3ef>
			return (ret);
  80042152d0:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042152d3:	e9 93 00 00 00       	jmpq   800421536b <_dwarf_frame_set_cie+0x482>
	}

	/* CIE Initial instructions. */
	cie->cie_initinst = (uint8_t *)dbg->dbg_eh_offset + *off;
  80042152d8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042152dc:	48 8b 10             	mov    (%rax),%rdx
  80042152df:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042152e3:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042152e7:	48 01 d0             	add    %rdx,%rax
  80042152ea:	48 89 c2             	mov    %rax,%rdx
  80042152ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042152f1:	48 89 50 68          	mov    %rdx,0x68(%rax)
	if (dwarf_size == 4)
  80042152f5:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042152f9:	75 2a                	jne    8004215325 <_dwarf_frame_set_cie+0x43c>
		cie->cie_instlen = cie->cie_offset + 4 + length - *off;
  80042152fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042152ff:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004215303:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215307:	48 01 c2             	add    %rax,%rdx
  800421530a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421530e:	48 8b 00             	mov    (%rax),%rax
  8004215311:	48 f7 d8             	neg    %rax
  8004215314:	48 01 d0             	add    %rdx,%rax
  8004215317:	48 8d 50 04          	lea    0x4(%rax),%rdx
  800421531b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421531f:	48 89 50 70          	mov    %rdx,0x70(%rax)
  8004215323:	eb 28                	jmp    800421534d <_dwarf_frame_set_cie+0x464>
	else
		cie->cie_instlen = cie->cie_offset + 12 + length - *off;
  8004215325:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215329:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800421532d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215331:	48 01 c2             	add    %rax,%rdx
  8004215334:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215338:	48 8b 00             	mov    (%rax),%rax
  800421533b:	48 f7 d8             	neg    %rax
  800421533e:	48 01 d0             	add    %rdx,%rax
  8004215341:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004215345:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215349:	48 89 50 70          	mov    %rdx,0x70(%rax)

	*off += cie->cie_instlen;
  800421534d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215351:	48 8b 10             	mov    (%rax),%rdx
  8004215354:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215358:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421535c:	48 01 c2             	add    %rax,%rdx
  800421535f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215363:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004215366:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421536b:	c9                   	leaveq 
  800421536c:	c3                   	retq   

000000800421536d <_dwarf_frame_set_fde>:

static int
_dwarf_frame_set_fde(Dwarf_Debug dbg, Dwarf_Fde ret_fde, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, int eh_frame, Dwarf_Cie cie, Dwarf_Error *error)
{
  800421536d:	55                   	push   %rbp
  800421536e:	48 89 e5             	mov    %rsp,%rbp
  8004215371:	48 83 ec 60          	sub    $0x60,%rsp
  8004215375:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004215379:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421537d:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004215381:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004215385:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
  8004215389:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Fde fde;
	Dwarf_Unsigned cieoff;
	uint64_t length, val;
	int dwarf_size, ret;

	fde = ret_fde;
  800421538d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215391:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	fde->fde_dbg = dbg;
  8004215395:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215399:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421539d:	48 89 10             	mov    %rdx,(%rax)
	fde->fde_addr = (uint8_t *)dbg->dbg_eh_offset + *off;
  80042153a0:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042153a4:	48 8b 10             	mov    (%rax),%rdx
  80042153a7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042153ab:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042153af:	48 01 d0             	add    %rdx,%rax
  80042153b2:	48 89 c2             	mov    %rax,%rdx
  80042153b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042153b9:	48 89 50 10          	mov    %rdx,0x10(%rax)
	fde->fde_offset = *off;
  80042153bd:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042153c1:	48 8b 10             	mov    (%rax),%rdx
  80042153c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042153c8:	48 89 50 18          	mov    %rdx,0x18(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  80042153cc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042153d0:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042153d4:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042153d8:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042153dc:	48 89 d7             	mov    %rdx,%rdi
  80042153df:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042153e3:	ba 04 00 00 00       	mov    $0x4,%edx
  80042153e8:	48 89 ce             	mov    %rcx,%rsi
  80042153eb:	ff d0                	callq  *%rax
  80042153ed:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  80042153f1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042153f6:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042153fa:	75 2e                	jne    800421542a <_dwarf_frame_set_fde+0xbd>
		dwarf_size = 8;
  80042153fc:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004215403:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215407:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421540b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421540f:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004215413:	48 89 d7             	mov    %rdx,%rdi
  8004215416:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800421541a:	ba 08 00 00 00       	mov    $0x8,%edx
  800421541f:	48 89 ce             	mov    %rcx,%rsi
  8004215422:	ff d0                	callq  *%rax
  8004215424:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004215428:	eb 07                	jmp    8004215431 <_dwarf_frame_set_fde+0xc4>
	} else
		dwarf_size = 4;
  800421542a:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004215431:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215435:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004215439:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421543d:	48 8b 00             	mov    (%rax),%rax
  8004215440:	48 29 c2             	sub    %rax,%rdx
  8004215443:	48 89 d0             	mov    %rdx,%rax
  8004215446:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800421544a:	73 0a                	jae    8004215456 <_dwarf_frame_set_fde+0xe9>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  800421544c:	b8 12 00 00 00       	mov    $0x12,%eax
  8004215451:	e9 fb 02 00 00       	jmpq   8004215751 <_dwarf_frame_set_fde+0x3e4>
	}

	fde->fde_length = length;
  8004215456:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421545a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421545e:	48 89 50 20          	mov    %rdx,0x20(%rax)

	if (eh_frame) {
  8004215462:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004215466:	74 61                	je     80042154c9 <_dwarf_frame_set_fde+0x15c>
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004215468:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421546c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215470:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004215474:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004215478:	48 89 d7             	mov    %rdx,%rdi
  800421547b:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800421547f:	ba 04 00 00 00       	mov    $0x4,%edx
  8004215484:	48 89 ce             	mov    %rcx,%rsi
  8004215487:	ff d0                	callq  *%rax
  8004215489:	48 89 c2             	mov    %rax,%rdx
  800421548c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215490:	48 89 50 28          	mov    %rdx,0x28(%rax)
		cieoff = *off - (4 + fde->fde_cieoff);
  8004215494:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215498:	48 8b 10             	mov    (%rax),%rdx
  800421549b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421549f:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042154a3:	48 29 c2             	sub    %rax,%rdx
  80042154a6:	48 89 d0             	mov    %rdx,%rax
  80042154a9:	48 83 e8 04          	sub    $0x4,%rax
  80042154ad:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		/* This delta should never be 0. */
		if (cieoff == fde->fde_offset) {
  80042154b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042154b5:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042154b9:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042154bd:	75 40                	jne    80042154ff <_dwarf_frame_set_fde+0x192>
			DWARF_SET_ERROR(dbg, error, DW_DLE_NO_CIE_FOR_FDE);
			return (DW_DLE_NO_CIE_FOR_FDE);
  80042154bf:	b8 13 00 00 00       	mov    $0x13,%eax
  80042154c4:	e9 88 02 00 00       	jmpq   8004215751 <_dwarf_frame_set_fde+0x3e4>
		}
	} else {
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size);
  80042154c9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042154cd:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042154d1:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042154d5:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042154d9:	48 89 d7             	mov    %rdx,%rdi
  80042154dc:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042154df:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042154e3:	48 89 ce             	mov    %rcx,%rsi
  80042154e6:	ff d0                	callq  *%rax
  80042154e8:	48 89 c2             	mov    %rax,%rdx
  80042154eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042154ef:	48 89 50 28          	mov    %rdx,0x28(%rax)
		cieoff = fde->fde_cieoff;
  80042154f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042154f7:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042154fb:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	if (eh_frame) {
  80042154ff:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004215503:	0f 84 e2 00 00 00    	je     80042155eb <_dwarf_frame_set_fde+0x27e>
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004215509:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421550d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004215511:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215515:	48 8b 00             	mov    (%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004215518:	48 8d 3c 02          	lea    (%rdx,%rax,1),%rdi
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  800421551c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215520:	0f b6 40 60          	movzbl 0x60(%rax),%eax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004215524:	0f b6 c8             	movzbl %al,%ecx
						    (uint8_t *)dbg->dbg_eh_offset,
  8004215527:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421552b:	48 8b 40 38          	mov    0x38(%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  800421552f:	49 89 c2             	mov    %rax,%r10
  8004215532:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004215536:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  800421553a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421553e:	48 83 ec 08          	sub    $0x8,%rsp
  8004215542:	ff 75 10             	pushq  0x10(%rbp)
  8004215545:	49 89 f9             	mov    %rdi,%r9
  8004215548:	41 89 c8             	mov    %ecx,%r8d
  800421554b:	48 89 d1             	mov    %rdx,%rcx
  800421554e:	4c 89 d2             	mov    %r10,%rdx
  8004215551:	48 89 c7             	mov    %rax,%rdi
  8004215554:	48 b8 6d 4b 21 04 80 	movabs $0x8004214b6d,%rax
  800421555b:	00 00 00 
  800421555e:	ff d0                	callq  *%rax
  8004215560:	48 83 c4 10          	add    $0x10,%rsp
  8004215564:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
		if (ret != DW_DLE_NONE)
  8004215567:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800421556b:	74 08                	je     8004215575 <_dwarf_frame_set_fde+0x208>
			return (ret);
  800421556d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004215570:	e9 dc 01 00 00       	jmpq   8004215751 <_dwarf_frame_set_fde+0x3e4>
		fde->fde_initloc = val;
  8004215575:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215579:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421557d:	48 89 50 30          	mov    %rdx,0x30(%rax)
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
  8004215581:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215585:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004215589:	0f b6 c8             	movzbl %al,%ecx
						    (uint8_t *)dbg->dbg_eh_offset,
  800421558c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215590:	48 8b 40 38          	mov    0x38(%rax),%rax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004215594:	48 89 c7             	mov    %rax,%rdi
  8004215597:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800421559b:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  800421559f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042155a3:	48 83 ec 08          	sub    $0x8,%rsp
  80042155a7:	ff 75 10             	pushq  0x10(%rbp)
  80042155aa:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80042155b0:	41 89 c8             	mov    %ecx,%r8d
  80042155b3:	48 89 d1             	mov    %rdx,%rcx
  80042155b6:	48 89 fa             	mov    %rdi,%rdx
  80042155b9:	48 89 c7             	mov    %rax,%rdi
  80042155bc:	48 b8 6d 4b 21 04 80 	movabs $0x8004214b6d,%rax
  80042155c3:	00 00 00 
  80042155c6:	ff d0                	callq  *%rax
  80042155c8:	48 83 c4 10          	add    $0x10,%rsp
  80042155cc:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
  80042155cf:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042155d3:	74 08                	je     80042155dd <_dwarf_frame_set_fde+0x270>
			return (ret);
  80042155d5:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042155d8:	e9 74 01 00 00       	jmpq   8004215751 <_dwarf_frame_set_fde+0x3e4>
		fde->fde_adrange = val;
  80042155dd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042155e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042155e5:	48 89 50 38          	mov    %rdx,0x38(%rax)
  80042155e9:	eb 5c                	jmp    8004215647 <_dwarf_frame_set_fde+0x2da>
	} else {
		fde->fde_initloc = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  80042155eb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042155ef:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042155f3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042155f7:	8b 52 28             	mov    0x28(%rdx),%edx
  80042155fa:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80042155fe:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004215602:	48 89 cf             	mov    %rcx,%rdi
  8004215605:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004215609:	48 89 ce             	mov    %rcx,%rsi
  800421560c:	ff d0                	callq  *%rax
  800421560e:	48 89 c2             	mov    %rax,%rdx
  8004215611:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215615:	48 89 50 30          	mov    %rdx,0x30(%rax)
					     dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004215619:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421561d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215621:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004215625:	8b 52 28             	mov    0x28(%rdx),%edx
  8004215628:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800421562c:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004215630:	48 89 cf             	mov    %rcx,%rdi
  8004215633:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004215637:	48 89 ce             	mov    %rcx,%rsi
  800421563a:	ff d0                	callq  *%rax
  800421563c:	48 89 c2             	mov    %rax,%rdx
  800421563f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215643:	48 89 50 38          	mov    %rdx,0x38(%rax)
					     dbg->dbg_pointer_size);
	}

	/* Optional FDE augmentation data for .eh_frame section. (ignored) */
	if (eh_frame && *cie->cie_augment == 'z') {
  8004215647:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  800421564b:	74 71                	je     80042156be <_dwarf_frame_set_fde+0x351>
  800421564d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215651:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004215655:	0f b6 00             	movzbl (%rax),%eax
  8004215658:	3c 7a                	cmp    $0x7a,%al
  800421565a:	75 62                	jne    80042156be <_dwarf_frame_set_fde+0x351>
		fde->fde_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  800421565c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215660:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004215664:	48 89 c2             	mov    %rax,%rdx
  8004215667:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421566b:	48 89 c6             	mov    %rax,%rsi
  800421566e:	48 89 d7             	mov    %rdx,%rdi
  8004215671:	48 b8 d1 1c 21 04 80 	movabs $0x8004211cd1,%rax
  8004215678:	00 00 00 
  800421567b:	ff d0                	callq  *%rax
  800421567d:	48 89 c2             	mov    %rax,%rdx
  8004215680:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215684:	48 89 50 40          	mov    %rdx,0x40(%rax)
		fde->fde_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004215688:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421568c:	48 8b 10             	mov    (%rax),%rdx
  800421568f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215693:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004215697:	48 01 d0             	add    %rdx,%rax
  800421569a:	48 89 c2             	mov    %rax,%rdx
  800421569d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042156a1:	48 89 50 48          	mov    %rdx,0x48(%rax)
		*off += fde->fde_auglen;
  80042156a5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042156a9:	48 8b 10             	mov    (%rax),%rdx
  80042156ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042156b0:	48 8b 40 40          	mov    0x40(%rax),%rax
  80042156b4:	48 01 c2             	add    %rax,%rdx
  80042156b7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042156bb:	48 89 10             	mov    %rdx,(%rax)
	}

	fde->fde_inst = (uint8_t *)dbg->dbg_eh_offset + *off;
  80042156be:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042156c2:	48 8b 10             	mov    (%rax),%rdx
  80042156c5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042156c9:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042156cd:	48 01 d0             	add    %rdx,%rax
  80042156d0:	48 89 c2             	mov    %rax,%rdx
  80042156d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042156d7:	48 89 50 50          	mov    %rdx,0x50(%rax)
	if (dwarf_size == 4)
  80042156db:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042156df:	75 2a                	jne    800421570b <_dwarf_frame_set_fde+0x39e>
		fde->fde_instlen = fde->fde_offset + 4 + length - *off;
  80042156e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042156e5:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042156e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042156ed:	48 01 c2             	add    %rax,%rdx
  80042156f0:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042156f4:	48 8b 00             	mov    (%rax),%rax
  80042156f7:	48 f7 d8             	neg    %rax
  80042156fa:	48 01 d0             	add    %rdx,%rax
  80042156fd:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004215701:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215705:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004215709:	eb 28                	jmp    8004215733 <_dwarf_frame_set_fde+0x3c6>
	else
		fde->fde_instlen = fde->fde_offset + 12 + length - *off;
  800421570b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421570f:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215713:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215717:	48 01 c2             	add    %rax,%rdx
  800421571a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421571e:	48 8b 00             	mov    (%rax),%rax
  8004215721:	48 f7 d8             	neg    %rax
  8004215724:	48 01 d0             	add    %rdx,%rax
  8004215727:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  800421572b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421572f:	48 89 50 58          	mov    %rdx,0x58(%rax)

	*off += fde->fde_instlen;
  8004215733:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215737:	48 8b 10             	mov    (%rax),%rdx
  800421573a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421573e:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004215742:	48 01 c2             	add    %rax,%rdx
  8004215745:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215749:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  800421574c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215751:	c9                   	leaveq 
  8004215752:	c3                   	retq   

0000008004215753 <_dwarf_frame_interal_table_init>:


int
_dwarf_frame_interal_table_init(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004215753:	55                   	push   %rbp
  8004215754:	48 89 e5             	mov    %rsp,%rbp
  8004215757:	48 83 ec 20          	sub    $0x20,%rsp
  800421575b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421575f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	Dwarf_Regtable3 *rt = &global_rt_table;
  8004215763:	48 b8 a0 16 4e 04 80 	movabs $0x80044e16a0,%rax
  800421576a:	00 00 00 
  800421576d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if (dbg->dbg_internal_reg_table != NULL)
  8004215771:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215775:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004215779:	48 85 c0             	test   %rax,%rax
  800421577c:	74 07                	je     8004215785 <_dwarf_frame_interal_table_init+0x32>
		return (DW_DLE_NONE);
  800421577e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215783:	eb 33                	jmp    80042157b8 <_dwarf_frame_interal_table_init+0x65>

	rt->rt3_reg_table_size = dbg->dbg_frame_rule_table_size;
  8004215785:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215789:	0f b7 50 48          	movzwl 0x48(%rax),%edx
  800421578d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215791:	66 89 50 18          	mov    %dx,0x18(%rax)
	rt->rt3_rules = global_rules;
  8004215795:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215799:	48 b9 40 fe 6d 04 80 	movabs $0x80046dfe40,%rcx
  80042157a0:	00 00 00 
  80042157a3:	48 89 48 20          	mov    %rcx,0x20(%rax)

	dbg->dbg_internal_reg_table = rt;
  80042157a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042157ab:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042157af:	48 89 50 58          	mov    %rdx,0x58(%rax)

	return (DW_DLE_NONE);
  80042157b3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042157b8:	c9                   	leaveq 
  80042157b9:	c3                   	retq   

00000080042157ba <_dwarf_get_next_fde>:

static int
_dwarf_get_next_fde(Dwarf_Debug dbg,
		    int eh_frame, Dwarf_Error *error, Dwarf_Fde ret_fde)
{
  80042157ba:	55                   	push   %rbp
  80042157bb:	48 89 e5             	mov    %rsp,%rbp
  80042157be:	48 83 ec 50          	sub    $0x50,%rsp
  80042157c2:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042157c6:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  80042157c9:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042157cd:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	Dwarf_Section *ds = &debug_frame_sec; 
  80042157d1:	48 b8 a0 66 23 04 80 	movabs $0x80042366a0,%rax
  80042157d8:	00 00 00 
  80042157db:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint64_t length, offset, cie_id, entry_off;
	int dwarf_size, i, ret=-1;
  80042157df:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%rbp)

	offset = dbg->curr_off_eh;
  80042157e6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042157ea:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042157ee:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	if (offset < dbg->dbg_eh_size) {
  80042157f2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042157f6:	48 8b 50 40          	mov    0x40(%rax),%rdx
  80042157fa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042157fe:	48 39 c2             	cmp    %rax,%rdx
  8004215801:	0f 86 04 02 00 00    	jbe    8004215a0b <_dwarf_get_next_fde+0x251>
		entry_off = offset;
  8004215807:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421580b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 4);
  800421580f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215813:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215817:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421581b:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421581f:	48 89 d7             	mov    %rdx,%rdi
  8004215822:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004215826:	ba 04 00 00 00       	mov    $0x4,%edx
  800421582b:	48 89 ce             	mov    %rcx,%rsi
  800421582e:	ff d0                	callq  *%rax
  8004215830:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (length == 0xffffffff) {
  8004215834:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004215839:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421583d:	75 2e                	jne    800421586d <_dwarf_get_next_fde+0xb3>
			dwarf_size = 8;
  800421583f:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
			length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 8);
  8004215846:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421584a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421584e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004215852:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004215856:	48 89 d7             	mov    %rdx,%rdi
  8004215859:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800421585d:	ba 08 00 00 00       	mov    $0x8,%edx
  8004215862:	48 89 ce             	mov    %rcx,%rsi
  8004215865:	ff d0                	callq  *%rax
  8004215867:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421586b:	eb 07                	jmp    8004215874 <_dwarf_get_next_fde+0xba>
		} else
			dwarf_size = 4;
  800421586d:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

		if (length > dbg->dbg_eh_size - offset || (length == 0 && !eh_frame)) {
  8004215874:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215878:	48 8b 50 40          	mov    0x40(%rax),%rdx
  800421587c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215880:	48 29 c2             	sub    %rax,%rdx
  8004215883:	48 89 d0             	mov    %rdx,%rax
  8004215886:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800421588a:	72 0d                	jb     8004215899 <_dwarf_get_next_fde+0xdf>
  800421588c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004215891:	75 10                	jne    80042158a3 <_dwarf_get_next_fde+0xe9>
  8004215893:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004215897:	75 0a                	jne    80042158a3 <_dwarf_get_next_fde+0xe9>
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_DEBUG_FRAME_LENGTH_BAD);
			return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004215899:	b8 12 00 00 00       	mov    $0x12,%eax
  800421589e:	e9 6d 01 00 00       	jmpq   8004215a10 <_dwarf_get_next_fde+0x256>
		}

		/* Check terminator for .eh_frame */
		if (eh_frame && length == 0)
  80042158a3:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80042158a7:	74 11                	je     80042158ba <_dwarf_get_next_fde+0x100>
  80042158a9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042158ae:	75 0a                	jne    80042158ba <_dwarf_get_next_fde+0x100>
			return(-1);
  80042158b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042158b5:	e9 56 01 00 00       	jmpq   8004215a10 <_dwarf_get_next_fde+0x256>

		cie_id = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, dwarf_size);
  80042158ba:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042158be:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042158c2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042158c6:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042158ca:	48 89 d7             	mov    %rdx,%rdi
  80042158cd:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042158d0:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  80042158d4:	48 89 ce             	mov    %rcx,%rsi
  80042158d7:	ff d0                	callq  *%rax
  80042158d9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

		if (eh_frame) {
  80042158dd:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80042158e1:	74 7c                	je     800421595f <_dwarf_get_next_fde+0x1a5>
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
  80042158e3:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042158e8:	75 32                	jne    800421591c <_dwarf_get_next_fde+0x162>
				ret = _dwarf_frame_set_cie(dbg, ds,
  80042158ea:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042158ee:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042158f2:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042158f6:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80042158fa:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  80042158fe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215902:	49 89 f8             	mov    %rdi,%r8
  8004215905:	48 89 c7             	mov    %rax,%rdi
  8004215908:	48 b8 e9 4e 21 04 80 	movabs $0x8004214ee9,%rax
  800421590f:	00 00 00 
  8004215912:	ff d0                	callq  *%rax
  8004215914:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004215917:	e9 ce 00 00 00       	jmpq   80042159ea <_dwarf_get_next_fde+0x230>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
  800421591c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215920:	48 8b 78 08          	mov    0x8(%rax),%rdi
  8004215924:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  8004215928:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421592c:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004215930:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215934:	48 83 ec 08          	sub    $0x8,%rsp
  8004215938:	ff 75 b8             	pushq  -0x48(%rbp)
  800421593b:	49 89 f9             	mov    %rdi,%r9
  800421593e:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8004215944:	48 89 c7             	mov    %rax,%rdi
  8004215947:	48 b8 6d 53 21 04 80 	movabs $0x800421536d,%rax
  800421594e:	00 00 00 
  8004215951:	ff d0                	callq  *%rax
  8004215953:	48 83 c4 10          	add    $0x10,%rsp
  8004215957:	89 45 f0             	mov    %eax,-0x10(%rbp)
  800421595a:	e9 8b 00 00 00       	jmpq   80042159ea <_dwarf_get_next_fde+0x230>
							   &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
  800421595f:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004215963:	75 0b                	jne    8004215970 <_dwarf_get_next_fde+0x1b6>
  8004215965:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421596a:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  800421596e:	74 0d                	je     800421597d <_dwarf_get_next_fde+0x1c3>
  8004215970:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  8004215974:	75 36                	jne    80042159ac <_dwarf_get_next_fde+0x1f2>
			    (dwarf_size == 8 && cie_id == ~0ULL))
  8004215976:	48 83 7d e0 ff       	cmpq   $0xffffffffffffffff,-0x20(%rbp)
  800421597b:	75 2f                	jne    80042159ac <_dwarf_get_next_fde+0x1f2>
				ret = _dwarf_frame_set_cie(dbg, ds,
  800421597d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215981:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004215985:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004215989:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800421598d:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8004215991:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215995:	49 89 f8             	mov    %rdi,%r8
  8004215998:	48 89 c7             	mov    %rax,%rdi
  800421599b:	48 b8 e9 4e 21 04 80 	movabs $0x8004214ee9,%rax
  80042159a2:	00 00 00 
  80042159a5:	ff d0                	callq  *%rax
  80042159a7:	89 45 f0             	mov    %eax,-0x10(%rbp)
  80042159aa:	eb 3e                	jmp    80042159ea <_dwarf_get_next_fde+0x230>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
  80042159ac:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042159b0:	48 8b 78 08          	mov    0x8(%rax),%rdi
  80042159b4:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80042159b8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042159bc:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80042159c0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042159c4:	48 83 ec 08          	sub    $0x8,%rsp
  80042159c8:	ff 75 b8             	pushq  -0x48(%rbp)
  80042159cb:	49 89 f9             	mov    %rdi,%r9
  80042159ce:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80042159d4:	48 89 c7             	mov    %rax,%rdi
  80042159d7:	48 b8 6d 53 21 04 80 	movabs $0x800421536d,%rax
  80042159de:	00 00 00 
  80042159e1:	ff d0                	callq  *%rax
  80042159e3:	48 83 c4 10          	add    $0x10,%rsp
  80042159e7:	89 45 f0             	mov    %eax,-0x10(%rbp)
							   &entry_off, 0, ret_fde->fde_cie, error);
		}

		if (ret != DW_DLE_NONE)
  80042159ea:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  80042159ee:	74 07                	je     80042159f7 <_dwarf_get_next_fde+0x23d>
			return(-1);
  80042159f0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042159f5:	eb 19                	jmp    8004215a10 <_dwarf_get_next_fde+0x256>

		offset = entry_off;
  80042159f7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042159fb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		dbg->curr_off_eh = offset;
  80042159ff:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215a03:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215a07:	48 89 50 30          	mov    %rdx,0x30(%rax)
	}

	return (0);
  8004215a0b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215a10:	c9                   	leaveq 
  8004215a11:	c3                   	retq   

0000008004215a12 <dwarf_set_frame_cfa_value>:

Dwarf_Half
dwarf_set_frame_cfa_value(Dwarf_Debug dbg, Dwarf_Half value)
{
  8004215a12:	55                   	push   %rbp
  8004215a13:	48 89 e5             	mov    %rsp,%rbp
  8004215a16:	48 83 ec 20          	sub    $0x20,%rsp
  8004215a1a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004215a1e:	89 f0                	mov    %esi,%eax
  8004215a20:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Half old_value;

	old_value = dbg->dbg_frame_cfa_value;
  8004215a24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215a28:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004215a2c:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
	dbg->dbg_frame_cfa_value = value;
  8004215a30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215a34:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  8004215a38:	66 89 50 4c          	mov    %dx,0x4c(%rax)

	return (old_value);
  8004215a3c:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
  8004215a40:	c9                   	leaveq 
  8004215a41:	c3                   	retq   

0000008004215a42 <dwarf_init_eh_section>:

int dwarf_init_eh_section(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004215a42:	55                   	push   %rbp
  8004215a43:	48 89 e5             	mov    %rsp,%rbp
  8004215a46:	48 83 ec 10          	sub    $0x10,%rsp
  8004215a4a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004215a4e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	Dwarf_Section *section;

	if (dbg == NULL) {
  8004215a52:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004215a57:	75 0a                	jne    8004215a63 <dwarf_init_eh_section+0x21>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  8004215a59:	b8 01 00 00 00       	mov    $0x1,%eax
  8004215a5e:	e9 85 00 00 00       	jmpq   8004215ae8 <dwarf_init_eh_section+0xa6>
	}

	if (dbg->dbg_internal_reg_table == NULL) {
  8004215a63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215a67:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004215a6b:	48 85 c0             	test   %rax,%rax
  8004215a6e:	75 25                	jne    8004215a95 <dwarf_init_eh_section+0x53>
		if (_dwarf_frame_interal_table_init(dbg, error) != DW_DLE_NONE)
  8004215a70:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004215a74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215a78:	48 89 d6             	mov    %rdx,%rsi
  8004215a7b:	48 89 c7             	mov    %rax,%rdi
  8004215a7e:	48 b8 53 57 21 04 80 	movabs $0x8004215753,%rax
  8004215a85:	00 00 00 
  8004215a88:	ff d0                	callq  *%rax
  8004215a8a:	85 c0                	test   %eax,%eax
  8004215a8c:	74 07                	je     8004215a95 <dwarf_init_eh_section+0x53>
			return (DW_DLV_ERROR);
  8004215a8e:	b8 01 00 00 00       	mov    $0x1,%eax
  8004215a93:	eb 53                	jmp    8004215ae8 <dwarf_init_eh_section+0xa6>
	}

	_dwarf_find_section_enhanced(&debug_frame_sec);
  8004215a95:	48 bf a0 66 23 04 80 	movabs $0x80042366a0,%rdi
  8004215a9c:	00 00 00 
  8004215a9f:	48 b8 ac 34 21 04 80 	movabs $0x80042134ac,%rax
  8004215aa6:	00 00 00 
  8004215aa9:	ff d0                	callq  *%rax

	dbg->curr_off_eh = 0;
  8004215aab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215aaf:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  8004215ab6:	00 
	dbg->dbg_eh_offset = debug_frame_sec.ds_addr;
  8004215ab7:	48 b8 a0 66 23 04 80 	movabs $0x80042366a0,%rax
  8004215abe:	00 00 00 
  8004215ac1:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004215ac5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215ac9:	48 89 50 38          	mov    %rdx,0x38(%rax)
	dbg->dbg_eh_size = debug_frame_sec.ds_size;
  8004215acd:	48 b8 a0 66 23 04 80 	movabs $0x80042366a0,%rax
  8004215ad4:	00 00 00 
  8004215ad7:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215adb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215adf:	48 89 50 40          	mov    %rdx,0x40(%rax)

	return (DW_DLV_OK);
  8004215ae3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215ae8:	c9                   	leaveq 
  8004215ae9:	c3                   	retq   

0000008004215aea <_dwarf_lineno_run_program>:
int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

static int
_dwarf_lineno_run_program(Dwarf_CU *cu, Dwarf_LineInfo li, uint8_t *p,
			  uint8_t *pe, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004215aea:	55                   	push   %rbp
  8004215aeb:	48 89 e5             	mov    %rsp,%rbp
  8004215aee:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  8004215af5:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  8004215af9:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  8004215afd:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  8004215b01:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  8004215b05:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  8004215b0c:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
	uint64_t address, file, line, column, isa, opsize;
	int is_stmt, basic_block, end_sequence;
	int prologue_end, epilogue_begin;
	int ret;

	ln = &li->li_line;
  8004215b13:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215b17:	48 83 c0 48          	add    $0x48,%rax
  8004215b1b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	/*
	 *   ln->ln_li     = li;             \
	 * Set registers to their default values.
	 */
	RESET_REGISTERS;
  8004215b1f:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004215b26:	00 
  8004215b27:	48 c7 45 f0 01 00 00 	movq   $0x1,-0x10(%rbp)
  8004215b2e:	00 
  8004215b2f:	48 c7 45 e8 01 00 00 	movq   $0x1,-0x18(%rbp)
  8004215b36:	00 
  8004215b37:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004215b3e:	00 
  8004215b3f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215b43:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004215b47:	0f b6 c0             	movzbl %al,%eax
  8004215b4a:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004215b4d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
  8004215b54:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  8004215b5b:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004215b62:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  8004215b69:	e9 b4 04 00 00       	jmpq   8004216022 <_dwarf_lineno_run_program+0x538>
		if (*p == 0) {
  8004215b6e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215b72:	0f b6 00             	movzbl (%rax),%eax
  8004215b75:	84 c0                	test   %al,%al
  8004215b77:	0f 85 4c 01 00 00    	jne    8004215cc9 <_dwarf_lineno_run_program+0x1df>

			/*
			 * Extended Opcodes.
			 */

			p++;
  8004215b7d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215b81:	48 83 c0 01          	add    $0x1,%rax
  8004215b85:	48 89 45 88          	mov    %rax,-0x78(%rbp)
			opsize = _dwarf_decode_uleb128(&p);
  8004215b89:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  8004215b8d:	48 89 c7             	mov    %rax,%rdi
  8004215b90:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  8004215b97:	00 00 00 
  8004215b9a:	ff d0                	callq  *%rax
  8004215b9c:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			switch (*p) {
  8004215ba0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215ba4:	0f b6 00             	movzbl (%rax),%eax
  8004215ba7:	0f b6 c0             	movzbl %al,%eax
  8004215baa:	83 f8 02             	cmp    $0x2,%eax
  8004215bad:	74 74                	je     8004215c23 <_dwarf_lineno_run_program+0x139>
  8004215baf:	83 f8 03             	cmp    $0x3,%eax
  8004215bb2:	0f 84 a7 00 00 00    	je     8004215c5f <_dwarf_lineno_run_program+0x175>
  8004215bb8:	83 f8 01             	cmp    $0x1,%eax
  8004215bbb:	0f 85 ee 00 00 00    	jne    8004215caf <_dwarf_lineno_run_program+0x1c5>
			case DW_LNE_end_sequence:
				p++;
  8004215bc1:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215bc5:	48 83 c0 01          	add    $0x1,%rax
  8004215bc9:	48 89 45 88          	mov    %rax,-0x78(%rbp)
				end_sequence = 1;
  8004215bcd:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
				RESET_REGISTERS;
  8004215bd4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004215bdb:	00 
  8004215bdc:	48 c7 45 f0 01 00 00 	movq   $0x1,-0x10(%rbp)
  8004215be3:	00 
  8004215be4:	48 c7 45 e8 01 00 00 	movq   $0x1,-0x18(%rbp)
  8004215beb:	00 
  8004215bec:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004215bf3:	00 
  8004215bf4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215bf8:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004215bfc:	0f b6 c0             	movzbl %al,%eax
  8004215bff:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004215c02:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
  8004215c09:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  8004215c10:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004215c17:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
				break;
  8004215c1e:	e9 ff 03 00 00       	jmpq   8004216022 <_dwarf_lineno_run_program+0x538>
			case DW_LNE_set_address:
				p++;
  8004215c23:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215c27:	48 83 c0 01          	add    $0x1,%rax
  8004215c2b:	48 89 45 88          	mov    %rax,-0x78(%rbp)
				address = dbg->decode(&p, cu->addr_size);
  8004215c2f:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  8004215c36:	00 00 00 
  8004215c39:	48 8b 00             	mov    (%rax),%rax
  8004215c3c:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215c40:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004215c44:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004215c48:	0f b6 ca             	movzbl %dl,%ecx
  8004215c4b:	48 8d 55 88          	lea    -0x78(%rbp),%rdx
  8004215c4f:	89 ce                	mov    %ecx,%esi
  8004215c51:	48 89 d7             	mov    %rdx,%rdi
  8004215c54:	ff d0                	callq  *%rax
  8004215c56:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				break;
  8004215c5a:	e9 c3 03 00 00       	jmpq   8004216022 <_dwarf_lineno_run_program+0x538>
			case DW_LNE_define_file:
				p++;
  8004215c5f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215c63:	48 83 c0 01          	add    $0x1,%rax
  8004215c67:	48 89 45 88          	mov    %rax,-0x78(%rbp)
				ret = _dwarf_lineno_add_file(li, &p, NULL,
  8004215c6b:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  8004215c72:	00 00 00 
  8004215c75:	48 8b 08             	mov    (%rax),%rcx
  8004215c78:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004215c7f:	48 8d 75 88          	lea    -0x78(%rbp),%rsi
  8004215c83:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215c87:	49 89 c8             	mov    %rcx,%r8
  8004215c8a:	48 89 d1             	mov    %rdx,%rcx
  8004215c8d:	ba 00 00 00 00       	mov    $0x0,%edx
  8004215c92:	48 89 c7             	mov    %rax,%rdi
  8004215c95:	48 b8 3c 60 21 04 80 	movabs $0x800421603c,%rax
  8004215c9c:	00 00 00 
  8004215c9f:	ff d0                	callq  *%rax
  8004215ca1:	89 45 b4             	mov    %eax,-0x4c(%rbp)
							     error, dbg);
				if (ret != DW_DLE_NONE)
  8004215ca4:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  8004215ca8:	74 19                	je     8004215cc3 <_dwarf_lineno_run_program+0x1d9>
					goto prog_fail;
  8004215caa:	e9 88 03 00 00       	jmpq   8004216037 <_dwarf_lineno_run_program+0x54d>
				break;
			default:
				/* Unrecognized extened opcodes. */
				p += opsize;
  8004215caf:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  8004215cb3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215cb7:	48 01 d0             	add    %rdx,%rax
  8004215cba:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004215cbe:	e9 5f 03 00 00       	jmpq   8004216022 <_dwarf_lineno_run_program+0x538>
				p++;
				ret = _dwarf_lineno_add_file(li, &p, NULL,
							     error, dbg);
				if (ret != DW_DLE_NONE)
					goto prog_fail;
				break;
  8004215cc3:	90                   	nop
  8004215cc4:	e9 59 03 00 00       	jmpq   8004216022 <_dwarf_lineno_run_program+0x538>
			default:
				/* Unrecognized extened opcodes. */
				p += opsize;
			}

		} else if (*p > 0 && *p < li->li_opbase) {
  8004215cc9:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215ccd:	0f b6 00             	movzbl (%rax),%eax
  8004215cd0:	84 c0                	test   %al,%al
  8004215cd2:	0f 84 24 02 00 00    	je     8004215efc <_dwarf_lineno_run_program+0x412>
  8004215cd8:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215cdc:	0f b6 10             	movzbl (%rax),%edx
  8004215cdf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215ce3:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004215ce7:	38 c2                	cmp    %al,%dl
  8004215ce9:	0f 83 0d 02 00 00    	jae    8004215efc <_dwarf_lineno_run_program+0x412>

			/*
			 * Standard Opcodes.
			 */

			switch (*p++) {
  8004215cef:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215cf3:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004215cf7:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  8004215cfb:	0f b6 00             	movzbl (%rax),%eax
  8004215cfe:	0f b6 c0             	movzbl %al,%eax
  8004215d01:	83 f8 0c             	cmp    $0xc,%eax
  8004215d04:	0f 87 ec 01 00 00    	ja     8004215ef6 <_dwarf_lineno_run_program+0x40c>
  8004215d0a:	89 c0                	mov    %eax,%eax
  8004215d0c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004215d13:	00 
  8004215d14:	48 b8 a8 18 22 04 80 	movabs $0x80042218a8,%rax
  8004215d1b:	00 00 00 
  8004215d1e:	48 01 d0             	add    %rdx,%rax
  8004215d21:	48 8b 00             	mov    (%rax),%rax
  8004215d24:	ff e0                	jmpq   *%rax
			case DW_LNS_copy:
				APPEND_ROW;
  8004215d26:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004215d2d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004215d31:	73 0a                	jae    8004215d3d <_dwarf_lineno_run_program+0x253>
  8004215d33:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215d38:	e9 fd 02 00 00       	jmpq   800421603a <_dwarf_lineno_run_program+0x550>
  8004215d3d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215d41:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215d45:	48 89 10             	mov    %rdx,(%rax)
  8004215d48:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215d4c:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004215d53:	00 
  8004215d54:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215d58:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004215d5c:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004215d60:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215d64:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215d68:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004215d6c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215d70:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215d74:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004215d78:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215d7c:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8004215d7f:	89 50 28             	mov    %edx,0x28(%rax)
  8004215d82:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215d86:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215d89:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004215d8c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215d90:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004215d93:	89 50 30             	mov    %edx,0x30(%rax)
  8004215d96:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215d9a:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004215da1:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004215da5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215da9:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
				basic_block = 0;
  8004215db0:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				prologue_end = 0;
  8004215db7:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
				epilogue_begin = 0;
  8004215dbe:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
				break;
  8004215dc5:	e9 2d 01 00 00       	jmpq   8004215ef7 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004215dca:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  8004215dce:	48 89 c7             	mov    %rax,%rdi
  8004215dd1:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  8004215dd8:	00 00 00 
  8004215ddb:	ff d0                	callq  *%rax
  8004215ddd:	48 89 c2             	mov    %rax,%rdx
					li->li_minlen;
  8004215de0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215de4:	0f b6 40 18          	movzbl 0x18(%rax),%eax
				basic_block = 0;
				prologue_end = 0;
				epilogue_begin = 0;
				break;
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004215de8:	0f b6 c0             	movzbl %al,%eax
  8004215deb:	48 0f af c2          	imul   %rdx,%rax
  8004215def:	48 01 45 f8          	add    %rax,-0x8(%rbp)
					li->li_minlen;
				break;
  8004215df3:	e9 ff 00 00 00       	jmpq   8004215ef7 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_advance_line:
				line += _dwarf_decode_sleb128(&p);
  8004215df8:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  8004215dfc:	48 89 c7             	mov    %rax,%rdi
  8004215dff:	48 b8 50 1d 21 04 80 	movabs $0x8004211d50,%rax
  8004215e06:	00 00 00 
  8004215e09:	ff d0                	callq  *%rax
  8004215e0b:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  8004215e0f:	e9 e3 00 00 00       	jmpq   8004215ef7 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_set_file:
				file = _dwarf_decode_uleb128(&p);
  8004215e14:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  8004215e18:	48 89 c7             	mov    %rax,%rdi
  8004215e1b:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  8004215e22:	00 00 00 
  8004215e25:	ff d0                	callq  *%rax
  8004215e27:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
				break;
  8004215e2b:	e9 c7 00 00 00       	jmpq   8004215ef7 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_set_column:
				column = _dwarf_decode_uleb128(&p);
  8004215e30:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  8004215e34:	48 89 c7             	mov    %rax,%rdi
  8004215e37:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  8004215e3e:	00 00 00 
  8004215e41:	ff d0                	callq  *%rax
  8004215e43:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				break;
  8004215e47:	e9 ab 00 00 00       	jmpq   8004215ef7 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_negate_stmt:
				is_stmt = !is_stmt;
  8004215e4c:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004215e50:	0f 94 c0             	sete   %al
  8004215e53:	0f b6 c0             	movzbl %al,%eax
  8004215e56:	89 45 dc             	mov    %eax,-0x24(%rbp)
				break;
  8004215e59:	e9 99 00 00 00       	jmpq   8004215ef7 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_set_basic_block:
				basic_block = 1;
  8004215e5e:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
				break;
  8004215e65:	e9 8d 00 00 00       	jmpq   8004215ef7 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_const_add_pc:
				address += ADDRESS(255);
  8004215e6a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215e6e:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004215e72:	0f b6 c0             	movzbl %al,%eax
  8004215e75:	ba ff 00 00 00       	mov    $0xff,%edx
  8004215e7a:	89 d1                	mov    %edx,%ecx
  8004215e7c:	29 c1                	sub    %eax,%ecx
  8004215e7e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215e82:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004215e86:	0f b6 f0             	movzbl %al,%esi
  8004215e89:	89 c8                	mov    %ecx,%eax
  8004215e8b:	99                   	cltd   
  8004215e8c:	f7 fe                	idiv   %esi
  8004215e8e:	89 c2                	mov    %eax,%edx
  8004215e90:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215e94:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004215e98:	0f b6 c0             	movzbl %al,%eax
  8004215e9b:	0f af c2             	imul   %edx,%eax
  8004215e9e:	48 98                	cltq   
  8004215ea0:	48 01 45 f8          	add    %rax,-0x8(%rbp)
				break;
  8004215ea4:	eb 51                	jmp    8004215ef7 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_fixed_advance_pc:
				address += dbg->decode(&p, 2);
  8004215ea6:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  8004215ead:	00 00 00 
  8004215eb0:	48 8b 00             	mov    (%rax),%rax
  8004215eb3:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215eb7:	48 8d 55 88          	lea    -0x78(%rbp),%rdx
  8004215ebb:	be 02 00 00 00       	mov    $0x2,%esi
  8004215ec0:	48 89 d7             	mov    %rdx,%rdi
  8004215ec3:	ff d0                	callq  *%rax
  8004215ec5:	48 01 45 f8          	add    %rax,-0x8(%rbp)
				break;
  8004215ec9:	eb 2c                	jmp    8004215ef7 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_set_prologue_end:
				prologue_end = 1;
  8004215ecb:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
				break;
  8004215ed2:	eb 23                	jmp    8004215ef7 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_set_epilogue_begin:
				epilogue_begin = 1;
  8004215ed4:	c7 45 c0 01 00 00 00 	movl   $0x1,-0x40(%rbp)
				break;
  8004215edb:	eb 1a                	jmp    8004215ef7 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_set_isa:
				isa = _dwarf_decode_uleb128(&p);
  8004215edd:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  8004215ee1:	48 89 c7             	mov    %rax,%rdi
  8004215ee4:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  8004215eeb:	00 00 00 
  8004215eee:	ff d0                	callq  *%rax
  8004215ef0:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
				break;
  8004215ef4:	eb 01                	jmp    8004215ef7 <_dwarf_lineno_run_program+0x40d>
			default:
				/* Unrecognized extened opcodes. What to do? */
				break;
  8004215ef6:	90                   	nop
			}

		} else {
  8004215ef7:	e9 26 01 00 00       	jmpq   8004216022 <_dwarf_lineno_run_program+0x538>

			/*
			 * Special Opcodes.
			 */

			line += LINE(*p);
  8004215efc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215f00:	0f b6 40 1a          	movzbl 0x1a(%rax),%eax
  8004215f04:	0f be c8             	movsbl %al,%ecx
  8004215f07:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215f0b:	0f b6 00             	movzbl (%rax),%eax
  8004215f0e:	0f b6 d0             	movzbl %al,%edx
  8004215f11:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215f15:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004215f19:	0f b6 c0             	movzbl %al,%eax
  8004215f1c:	29 c2                	sub    %eax,%edx
  8004215f1e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215f22:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004215f26:	0f b6 f0             	movzbl %al,%esi
  8004215f29:	89 d0                	mov    %edx,%eax
  8004215f2b:	99                   	cltd   
  8004215f2c:	f7 fe                	idiv   %esi
  8004215f2e:	89 d0                	mov    %edx,%eax
  8004215f30:	01 c8                	add    %ecx,%eax
  8004215f32:	48 98                	cltq   
  8004215f34:	48 01 45 e8          	add    %rax,-0x18(%rbp)
			address += ADDRESS(*p);
  8004215f38:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215f3c:	0f b6 00             	movzbl (%rax),%eax
  8004215f3f:	0f b6 d0             	movzbl %al,%edx
  8004215f42:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215f46:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004215f4a:	0f b6 c0             	movzbl %al,%eax
  8004215f4d:	89 d1                	mov    %edx,%ecx
  8004215f4f:	29 c1                	sub    %eax,%ecx
  8004215f51:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215f55:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004215f59:	0f b6 f0             	movzbl %al,%esi
  8004215f5c:	89 c8                	mov    %ecx,%eax
  8004215f5e:	99                   	cltd   
  8004215f5f:	f7 fe                	idiv   %esi
  8004215f61:	89 c2                	mov    %eax,%edx
  8004215f63:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215f67:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004215f6b:	0f b6 c0             	movzbl %al,%eax
  8004215f6e:	0f af c2             	imul   %edx,%eax
  8004215f71:	48 98                	cltq   
  8004215f73:	48 01 45 f8          	add    %rax,-0x8(%rbp)
			APPEND_ROW;
  8004215f77:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004215f7e:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004215f82:	73 0a                	jae    8004215f8e <_dwarf_lineno_run_program+0x4a4>
  8004215f84:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215f89:	e9 ac 00 00 00       	jmpq   800421603a <_dwarf_lineno_run_program+0x550>
  8004215f8e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215f92:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215f96:	48 89 10             	mov    %rdx,(%rax)
  8004215f99:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215f9d:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004215fa4:	00 
  8004215fa5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215fa9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004215fad:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004215fb1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215fb5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215fb9:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004215fbd:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215fc1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215fc5:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004215fc9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215fcd:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8004215fd0:	89 50 28             	mov    %edx,0x28(%rax)
  8004215fd3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215fd7:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215fda:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004215fdd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215fe1:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004215fe4:	89 50 30             	mov    %edx,0x30(%rax)
  8004215fe7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215feb:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004215ff2:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004215ff6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215ffa:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
			basic_block = 0;
  8004216001:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
			prologue_end = 0;
  8004216008:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
			epilogue_begin = 0;
  800421600f:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
			p++;
  8004216016:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421601a:	48 83 c0 01          	add    $0x1,%rax
  800421601e:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	RESET_REGISTERS;

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  8004216022:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216026:	48 3b 45 80          	cmp    -0x80(%rbp),%rax
  800421602a:	0f 82 3e fb ff ff    	jb     8004215b6e <_dwarf_lineno_run_program+0x84>
			epilogue_begin = 0;
			p++;
		}
	}

	return (DW_DLE_NONE);
  8004216030:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216035:	eb 03                	jmp    800421603a <_dwarf_lineno_run_program+0x550>

prog_fail:

	return (ret);
  8004216037:	8b 45 b4             	mov    -0x4c(%rbp),%eax

#undef  RESET_REGISTERS
#undef  APPEND_ROW
#undef  LINE
#undef  ADDRESS
}
  800421603a:	c9                   	leaveq 
  800421603b:	c3                   	retq   

000000800421603c <_dwarf_lineno_add_file>:

static int
_dwarf_lineno_add_file(Dwarf_LineInfo li, uint8_t **p, const char *compdir,
		       Dwarf_Error *error, Dwarf_Debug dbg)
{
  800421603c:	55                   	push   %rbp
  800421603d:	48 89 e5             	mov    %rsp,%rbp
  8004216040:	48 83 ec 40          	sub    $0x40,%rsp
  8004216044:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004216048:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421604c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004216050:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004216054:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
	char *fname;
	//const char *dirname;
	uint8_t *src;
	int slen;

	src = *p;
  8004216058:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421605c:	48 8b 00             	mov    (%rax),%rax
  800421605f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
  return (DW_DLE_MEMORY);
  }
*/  
	//lf->lf_fullpath = NULL;
	fname = (char *) src;
  8004216063:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216067:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	src += strlen(fname) + 1;
  800421606b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421606f:	48 89 c7             	mov    %rax,%rdi
  8004216072:	48 b8 b3 0e 21 04 80 	movabs $0x8004210eb3,%rax
  8004216079:	00 00 00 
  800421607c:	ff d0                	callq  *%rax
  800421607e:	83 c0 01             	add    $0x1,%eax
  8004216081:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004216085:	48 98                	cltq   
  8004216087:	48 01 d0             	add    %rdx,%rax
  800421608a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	_dwarf_decode_uleb128(&src);
  800421608e:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8004216092:	48 89 c7             	mov    %rax,%rdi
  8004216095:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  800421609c:	00 00 00 
  800421609f:	ff d0                	callq  *%rax
	   snprintf(lf->lf_fullpath, slen, "%s/%s", dirname,
	   lf->lf_fname);
	   }
	   }
	*/
	_dwarf_decode_uleb128(&src);
  80042160a1:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  80042160a5:	48 89 c7             	mov    %rax,%rdi
  80042160a8:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  80042160af:	00 00 00 
  80042160b2:	ff d0                	callq  *%rax
	_dwarf_decode_uleb128(&src);
  80042160b4:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  80042160b8:	48 89 c7             	mov    %rax,%rdi
  80042160bb:	48 b8 e2 1d 21 04 80 	movabs $0x8004211de2,%rax
  80042160c2:	00 00 00 
  80042160c5:	ff d0                	callq  *%rax
	//STAILQ_INSERT_TAIL(&li->li_lflist, lf, lf_next);
	//li->li_lflen++;

	*p = src;
  80042160c7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042160cb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042160cf:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  80042160d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042160d7:	c9                   	leaveq 
  80042160d8:	c3                   	retq   

00000080042160d9 <_dwarf_lineno_init>:

int     
_dwarf_lineno_init(Dwarf_Die *die, uint64_t offset, Dwarf_LineInfo linfo, Dwarf_Addr pc, Dwarf_Error *error)
{   
  80042160d9:	55                   	push   %rbp
  80042160da:	48 89 e5             	mov    %rsp,%rbp
  80042160dd:	53                   	push   %rbx
  80042160de:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  80042160e5:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  80042160ec:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  80042160f3:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  80042160fa:	48 89 8d 00 ff ff ff 	mov    %rcx,-0x100(%rbp)
  8004216101:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
	Dwarf_Section myds = {.ds_name = ".debug_line"};
  8004216108:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  800421610f:	00 
  8004216110:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  8004216117:	00 
  8004216118:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  800421611f:	00 
  8004216120:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004216127:	00 
  8004216128:	48 b8 10 19 22 04 80 	movabs $0x8004221910,%rax
  800421612f:	00 00 00 
  8004216132:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	Dwarf_Section *ds = &myds;
  8004216136:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800421613a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//Dwarf_LineFile lf, tlf;
	uint64_t length, hdroff, endoff;
	uint8_t *p;
	int dwarf_size, i, ret;
            
	cu = die->cu_header;
  800421613e:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004216145:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800421614c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	assert(cu != NULL); 
  8004216150:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004216155:	75 35                	jne    800421618c <_dwarf_lineno_init+0xb3>
  8004216157:	48 b9 1c 19 22 04 80 	movabs $0x800422191c,%rcx
  800421615e:	00 00 00 
  8004216161:	48 ba 27 19 22 04 80 	movabs $0x8004221927,%rdx
  8004216168:	00 00 00 
  800421616b:	be 13 01 00 00       	mov    $0x113,%esi
  8004216170:	48 bf 3c 19 22 04 80 	movabs $0x800422193c,%rdi
  8004216177:	00 00 00 
  800421617a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421617f:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004216186:	00 00 00 
  8004216189:	41 ff d0             	callq  *%r8
	assert(dbg != NULL);
  800421618c:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  8004216193:	00 00 00 
  8004216196:	48 8b 00             	mov    (%rax),%rax
  8004216199:	48 85 c0             	test   %rax,%rax
  800421619c:	75 35                	jne    80042161d3 <_dwarf_lineno_init+0xfa>
  800421619e:	48 b9 53 19 22 04 80 	movabs $0x8004221953,%rcx
  80042161a5:	00 00 00 
  80042161a8:	48 ba 27 19 22 04 80 	movabs $0x8004221927,%rdx
  80042161af:	00 00 00 
  80042161b2:	be 14 01 00 00       	mov    $0x114,%esi
  80042161b7:	48 bf 3c 19 22 04 80 	movabs $0x800422193c,%rdi
  80042161be:	00 00 00 
  80042161c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042161c6:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042161cd:	00 00 00 
  80042161d0:	41 ff d0             	callq  *%r8

	if ((_dwarf_find_section_enhanced(ds)) != 0)
  80042161d3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042161d7:	48 89 c7             	mov    %rax,%rdi
  80042161da:	48 b8 ac 34 21 04 80 	movabs $0x80042134ac,%rax
  80042161e1:	00 00 00 
  80042161e4:	ff d0                	callq  *%rax
  80042161e6:	85 c0                	test   %eax,%eax
  80042161e8:	74 0a                	je     80042161f4 <_dwarf_lineno_init+0x11b>
		return (DW_DLE_NONE);
  80042161ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80042161ef:	e9 51 04 00 00       	jmpq   8004216645 <_dwarf_lineno_init+0x56c>

	li = linfo;
  80042161f4:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  80042161fb:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	 break;
	 }
	 }
	*/

	length = dbg->read(ds->ds_data, &offset, 4);
  80042161ff:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  8004216206:	00 00 00 
  8004216209:	48 8b 00             	mov    (%rax),%rax
  800421620c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216210:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004216214:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004216218:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  800421621f:	ba 04 00 00 00       	mov    $0x4,%edx
  8004216224:	48 89 cf             	mov    %rcx,%rdi
  8004216227:	ff d0                	callq  *%rax
  8004216229:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (length == 0xffffffff) {
  800421622d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004216232:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004216236:	75 37                	jne    800421626f <_dwarf_lineno_init+0x196>
		dwarf_size = 8;
  8004216238:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
		length = dbg->read(ds->ds_data, &offset, 8);
  800421623f:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  8004216246:	00 00 00 
  8004216249:	48 8b 00             	mov    (%rax),%rax
  800421624c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216250:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004216254:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004216258:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  800421625f:	ba 08 00 00 00       	mov    $0x8,%edx
  8004216264:	48 89 cf             	mov    %rcx,%rdi
  8004216267:	ff d0                	callq  *%rax
  8004216269:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800421626d:	eb 07                	jmp    8004216276 <_dwarf_lineno_init+0x19d>
	} else
		dwarf_size = 4;
  800421626f:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)

	if (length > ds->ds_size - offset) {
  8004216276:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421627a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421627e:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004216285:	48 29 c2             	sub    %rax,%rdx
  8004216288:	48 89 d0             	mov    %rdx,%rax
  800421628b:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800421628f:	73 0a                	jae    800421629b <_dwarf_lineno_init+0x1c2>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_LINE_LENGTH_BAD);
		return (DW_DLE_DEBUG_LINE_LENGTH_BAD);
  8004216291:	b8 0f 00 00 00       	mov    $0xf,%eax
  8004216296:	e9 aa 03 00 00       	jmpq   8004216645 <_dwarf_lineno_init+0x56c>
	}
	/*
	 * Read in line number program header.
	 */
	li->li_length = length;
  800421629b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421629f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042162a3:	48 89 10             	mov    %rdx,(%rax)
	endoff = offset + length;
  80042162a6:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  80042162ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042162b1:	48 01 d0             	add    %rdx,%rax
  80042162b4:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	li->li_version = dbg->read(ds->ds_data, &offset, 2); /* FIXME: verify version */
  80042162b8:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  80042162bf:	00 00 00 
  80042162c2:	48 8b 00             	mov    (%rax),%rax
  80042162c5:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042162c9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042162cd:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042162d1:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042162d8:	ba 02 00 00 00       	mov    $0x2,%edx
  80042162dd:	48 89 cf             	mov    %rcx,%rdi
  80042162e0:	ff d0                	callq  *%rax
  80042162e2:	89 c2                	mov    %eax,%edx
  80042162e4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042162e8:	66 89 50 08          	mov    %dx,0x8(%rax)
	li->li_hdrlen = dbg->read(ds->ds_data, &offset, dwarf_size);
  80042162ec:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  80042162f3:	00 00 00 
  80042162f6:	48 8b 00             	mov    (%rax),%rax
  80042162f9:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042162fd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004216301:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004216305:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004216308:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  800421630f:	48 89 cf             	mov    %rcx,%rdi
  8004216312:	ff d0                	callq  *%rax
  8004216314:	48 89 c2             	mov    %rax,%rdx
  8004216317:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421631b:	48 89 50 10          	mov    %rdx,0x10(%rax)
	hdroff = offset;
  800421631f:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004216326:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	li->li_minlen = dbg->read(ds->ds_data, &offset, 1);
  800421632a:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  8004216331:	00 00 00 
  8004216334:	48 8b 00             	mov    (%rax),%rax
  8004216337:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421633b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421633f:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004216343:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  800421634a:	ba 01 00 00 00       	mov    $0x1,%edx
  800421634f:	48 89 cf             	mov    %rcx,%rdi
  8004216352:	ff d0                	callq  *%rax
  8004216354:	89 c2                	mov    %eax,%edx
  8004216356:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421635a:	88 50 18             	mov    %dl,0x18(%rax)
	li->li_defstmt = dbg->read(ds->ds_data, &offset, 1);
  800421635d:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  8004216364:	00 00 00 
  8004216367:	48 8b 00             	mov    (%rax),%rax
  800421636a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421636e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004216372:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004216376:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  800421637d:	ba 01 00 00 00       	mov    $0x1,%edx
  8004216382:	48 89 cf             	mov    %rcx,%rdi
  8004216385:	ff d0                	callq  *%rax
  8004216387:	89 c2                	mov    %eax,%edx
  8004216389:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421638d:	88 50 19             	mov    %dl,0x19(%rax)
	li->li_lbase = dbg->read(ds->ds_data, &offset, 1);
  8004216390:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  8004216397:	00 00 00 
  800421639a:	48 8b 00             	mov    (%rax),%rax
  800421639d:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042163a1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042163a5:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042163a9:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042163b0:	ba 01 00 00 00       	mov    $0x1,%edx
  80042163b5:	48 89 cf             	mov    %rcx,%rdi
  80042163b8:	ff d0                	callq  *%rax
  80042163ba:	89 c2                	mov    %eax,%edx
  80042163bc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042163c0:	88 50 1a             	mov    %dl,0x1a(%rax)
	li->li_lrange = dbg->read(ds->ds_data, &offset, 1);
  80042163c3:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  80042163ca:	00 00 00 
  80042163cd:	48 8b 00             	mov    (%rax),%rax
  80042163d0:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042163d4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042163d8:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042163dc:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042163e3:	ba 01 00 00 00       	mov    $0x1,%edx
  80042163e8:	48 89 cf             	mov    %rcx,%rdi
  80042163eb:	ff d0                	callq  *%rax
  80042163ed:	89 c2                	mov    %eax,%edx
  80042163ef:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042163f3:	88 50 1b             	mov    %dl,0x1b(%rax)
	li->li_opbase = dbg->read(ds->ds_data, &offset, 1);
  80042163f6:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  80042163fd:	00 00 00 
  8004216400:	48 8b 00             	mov    (%rax),%rax
  8004216403:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216407:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421640b:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800421640f:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004216416:	ba 01 00 00 00       	mov    $0x1,%edx
  800421641b:	48 89 cf             	mov    %rcx,%rdi
  800421641e:	ff d0                	callq  *%rax
  8004216420:	89 c2                	mov    %eax,%edx
  8004216422:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004216426:	88 50 1c             	mov    %dl,0x1c(%rax)
	//STAILQ_INIT(&li->li_lflist);
	//STAILQ_INIT(&li->li_lnlist);

	if ((int)li->li_hdrlen - 5 < li->li_opbase - 1) {
  8004216429:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421642d:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216431:	8d 50 fb             	lea    -0x5(%rax),%edx
  8004216434:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004216438:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  800421643c:	0f b6 c0             	movzbl %al,%eax
  800421643f:	83 e8 01             	sub    $0x1,%eax
  8004216442:	39 c2                	cmp    %eax,%edx
  8004216444:	7d 0c                	jge    8004216452 <_dwarf_lineno_init+0x379>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004216446:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  800421644d:	e9 f0 01 00 00       	jmpq   8004216642 <_dwarf_lineno_init+0x569>
	}

	li->li_oplen = global_std_op;
  8004216452:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004216456:	48 bb 80 04 6e 04 80 	movabs $0x80046e0480,%rbx
  800421645d:	00 00 00 
  8004216460:	48 89 58 20          	mov    %rbx,0x20(%rax)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004216464:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  800421646b:	eb 41                	jmp    80042164ae <_dwarf_lineno_init+0x3d5>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);
  800421646d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004216471:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216475:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004216478:	48 98                	cltq   
  800421647a:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800421647e:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  8004216485:	00 00 00 
  8004216488:	48 8b 00             	mov    (%rax),%rax
  800421648b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421648f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004216493:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004216497:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  800421649e:	ba 01 00 00 00       	mov    $0x1,%edx
  80042164a3:	48 89 cf             	mov    %rcx,%rdi
  80042164a6:	ff d0                	callq  *%rax
  80042164a8:	88 03                	mov    %al,(%rbx)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  80042164aa:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  80042164ae:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042164b2:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042164b6:	0f b6 c0             	movzbl %al,%eax
  80042164b9:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  80042164bc:	7f af                	jg     800421646d <_dwarf_lineno_init+0x394>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);

	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
  80042164be:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042164c5:	00 
	p = ds->ds_data + offset;
  80042164c6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042164ca:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042164ce:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042164d5:	48 01 d0             	add    %rdx,%rax
  80042164d8:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	while (*p != '\0') {
  80042164df:	eb 1f                	jmp    8004216500 <_dwarf_lineno_init+0x427>
		while (*p++ != '\0')
  80042164e1:	90                   	nop
  80042164e2:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042164e9:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042164ed:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
  80042164f4:	0f b6 00             	movzbl (%rax),%eax
  80042164f7:	84 c0                	test   %al,%al
  80042164f9:	75 e7                	jne    80042164e2 <_dwarf_lineno_init+0x409>
			;
		length++;
  80042164fb:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
	p = ds->ds_data + offset;
	while (*p != '\0') {
  8004216500:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004216507:	0f b6 00             	movzbl (%rax),%eax
  800421650a:	84 c0                	test   %al,%al
  800421650c:	75 d3                	jne    80042164e1 <_dwarf_lineno_init+0x408>
		while (*p++ != '\0')
			;
		length++;
	}
	li->li_inclen = length;
  800421650e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004216512:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004216516:	48 89 50 30          	mov    %rdx,0x30(%rax)

	/* Sanity check. */
	if (p - ds->ds_data > (int) ds->ds_size) {
  800421651a:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004216521:	48 89 c2             	mov    %rax,%rdx
  8004216524:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216528:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421652c:	48 29 c2             	sub    %rax,%rdx
  800421652f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216533:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216537:	48 98                	cltq   
  8004216539:	48 39 c2             	cmp    %rax,%rdx
  800421653c:	7e 0c                	jle    800421654a <_dwarf_lineno_init+0x471>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  800421653e:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004216545:	e9 f8 00 00 00       	jmpq   8004216642 <_dwarf_lineno_init+0x569>
	}
	p++;
  800421654a:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004216551:	48 83 c0 01          	add    $0x1,%rax
  8004216555:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  800421655c:	eb 3c                	jmp    800421659a <_dwarf_lineno_init+0x4c1>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
  800421655e:	48 b8 88 66 23 04 80 	movabs $0x8004236688,%rax
  8004216565:	00 00 00 
  8004216568:	48 8b 08             	mov    (%rax),%rcx
  800421656b:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004216572:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
  8004216579:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421657d:	49 89 c8             	mov    %rcx,%r8
  8004216580:	48 89 d1             	mov    %rdx,%rcx
  8004216583:	ba 00 00 00 00       	mov    $0x0,%edx
  8004216588:	48 89 c7             	mov    %rax,%rdi
  800421658b:	48 b8 3c 60 21 04 80 	movabs $0x800421603c,%rax
  8004216592:	00 00 00 
  8004216595:	ff d0                	callq  *%rax
  8004216597:	89 45 dc             	mov    %eax,-0x24(%rbp)
	p++;

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  800421659a:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042165a1:	0f b6 00             	movzbl (%rax),%eax
  80042165a4:	84 c0                	test   %al,%al
  80042165a6:	75 b6                	jne    800421655e <_dwarf_lineno_init+0x485>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
		//p++;
	}

	p++;
  80042165a8:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042165af:	48 83 c0 01          	add    $0x1,%rax
  80042165b3:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	/* Sanity check. */
	if (p - ds->ds_data - hdroff != li->li_hdrlen) {
  80042165ba:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042165c1:	48 89 c2             	mov    %rax,%rdx
  80042165c4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042165c8:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042165cc:	48 29 c2             	sub    %rax,%rdx
  80042165cf:	48 89 d0             	mov    %rdx,%rax
  80042165d2:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
  80042165d6:	48 89 c2             	mov    %rax,%rdx
  80042165d9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042165dd:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042165e1:	48 39 c2             	cmp    %rax,%rdx
  80042165e4:	74 09                	je     80042165ef <_dwarf_lineno_init+0x516>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  80042165e6:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  80042165ed:	eb 53                	jmp    8004216642 <_dwarf_lineno_init+0x569>
	}

	/*
	 * Process line number program.
	 */
	ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
  80042165ef:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042165f3:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042165f7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042165fb:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  80042165ff:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  8004216606:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
  800421660d:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
  8004216614:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004216618:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421661c:	4d 89 c1             	mov    %r8,%r9
  800421661f:	49 89 f8             	mov    %rdi,%r8
  8004216622:	48 89 c7             	mov    %rax,%rdi
  8004216625:	48 b8 ea 5a 21 04 80 	movabs $0x8004215aea,%rax
  800421662c:	00 00 00 
  800421662f:	ff d0                	callq  *%rax
  8004216631:	89 45 dc             	mov    %eax,-0x24(%rbp)
					error);
	if (ret != DW_DLE_NONE)
  8004216634:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004216638:	75 07                	jne    8004216641 <_dwarf_lineno_init+0x568>
		goto fail_cleanup;

	//cu->cu_lineinfo = li;

	return (DW_DLE_NONE);
  800421663a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421663f:	eb 04                	jmp    8004216645 <_dwarf_lineno_init+0x56c>
	 * Process line number program.
	 */
	ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
					error);
	if (ret != DW_DLE_NONE)
		goto fail_cleanup;
  8004216641:	90                   	nop
fail_cleanup:

	/*if (li->li_oplen)
	  free(li->li_oplen);*/

	return (ret);
  8004216642:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  8004216645:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  800421664c:	5b                   	pop    %rbx
  800421664d:	5d                   	pop    %rbp
  800421664e:	c3                   	retq   

000000800421664f <dwarf_srclines>:

int
dwarf_srclines(Dwarf_Die *die, Dwarf_Line linebuf, Dwarf_Addr pc, Dwarf_Error *error)
{
  800421664f:	55                   	push   %rbp
  8004216650:	48 89 e5             	mov    %rsp,%rbp
  8004216653:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  800421665a:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004216661:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004216668:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  800421666f:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
	_Dwarf_LineInfo li;
	Dwarf_Attribute *at;

	assert(die);
  8004216676:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  800421667d:	00 
  800421667e:	75 35                	jne    80042166b5 <dwarf_srclines+0x66>
  8004216680:	48 b9 5f 19 22 04 80 	movabs $0x800422195f,%rcx
  8004216687:	00 00 00 
  800421668a:	48 ba 27 19 22 04 80 	movabs $0x8004221927,%rdx
  8004216691:	00 00 00 
  8004216694:	be 9a 01 00 00       	mov    $0x19a,%esi
  8004216699:	48 bf 3c 19 22 04 80 	movabs $0x800422193c,%rdi
  80042166a0:	00 00 00 
  80042166a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042166a8:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042166af:	00 00 00 
  80042166b2:	41 ff d0             	callq  *%r8
	assert(linebuf);
  80042166b5:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  80042166bc:	00 
  80042166bd:	75 35                	jne    80042166f4 <dwarf_srclines+0xa5>
  80042166bf:	48 b9 63 19 22 04 80 	movabs $0x8004221963,%rcx
  80042166c6:	00 00 00 
  80042166c9:	48 ba 27 19 22 04 80 	movabs $0x8004221927,%rdx
  80042166d0:	00 00 00 
  80042166d3:	be 9b 01 00 00       	mov    $0x19b,%esi
  80042166d8:	48 bf 3c 19 22 04 80 	movabs $0x800422193c,%rdi
  80042166df:	00 00 00 
  80042166e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042166e7:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042166ee:	00 00 00 
  80042166f1:	41 ff d0             	callq  *%r8

	memset(&li, 0, sizeof(_Dwarf_LineInfo));
  80042166f4:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  80042166fb:	ba 88 00 00 00       	mov    $0x88,%edx
  8004216700:	be 00 00 00 00       	mov    $0x0,%esi
  8004216705:	48 89 c7             	mov    %rax,%rdi
  8004216708:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  800421670f:	00 00 00 
  8004216712:	ff d0                	callq  *%rax

	if ((at = _dwarf_attr_find(die, DW_AT_stmt_list)) == NULL) {
  8004216714:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421671b:	be 10 00 00 00       	mov    $0x10,%esi
  8004216720:	48 89 c7             	mov    %rax,%rdi
  8004216723:	48 b8 97 30 21 04 80 	movabs $0x8004213097,%rax
  800421672a:	00 00 00 
  800421672d:	ff d0                	callq  *%rax
  800421672f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004216733:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004216738:	75 0a                	jne    8004216744 <dwarf_srclines+0xf5>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  800421673a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421673f:	e9 84 00 00 00       	jmpq   80042167c8 <dwarf_srclines+0x179>
	}

	if (_dwarf_lineno_init(die, at->u[0].u64, &li, pc, error) !=
  8004216744:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216748:	48 8b 70 28          	mov    0x28(%rax),%rsi
  800421674c:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  8004216753:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  800421675a:	48 8d 95 70 ff ff ff 	lea    -0x90(%rbp),%rdx
  8004216761:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004216768:	49 89 f8             	mov    %rdi,%r8
  800421676b:	48 89 c7             	mov    %rax,%rdi
  800421676e:	48 b8 d9 60 21 04 80 	movabs $0x80042160d9,%rax
  8004216775:	00 00 00 
  8004216778:	ff d0                	callq  *%rax
  800421677a:	85 c0                	test   %eax,%eax
  800421677c:	74 07                	je     8004216785 <dwarf_srclines+0x136>
	    DW_DLE_NONE)
	{
		return (DW_DLV_ERROR);
  800421677e:	b8 01 00 00 00       	mov    $0x1,%eax
  8004216783:	eb 43                	jmp    80042167c8 <dwarf_srclines+0x179>
	}
	*linebuf = li.li_line;
  8004216785:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800421678c:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004216790:	48 89 10             	mov    %rdx,(%rax)
  8004216793:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004216797:	48 89 50 08          	mov    %rdx,0x8(%rax)
  800421679b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421679f:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80042167a3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042167a7:	48 89 50 18          	mov    %rdx,0x18(%rax)
  80042167ab:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042167af:	48 89 50 20          	mov    %rdx,0x20(%rax)
  80042167b3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042167b7:	48 89 50 28          	mov    %rdx,0x28(%rax)
  80042167bb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042167bf:	48 89 50 30          	mov    %rdx,0x30(%rax)

	return (DW_DLV_OK);
  80042167c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042167c8:	c9                   	leaveq 
  80042167c9:	c3                   	retq   

00000080042167ca <_dwarf_find_section>:
uintptr_t
read_section_headers(uintptr_t, uintptr_t);

Dwarf_Section *
_dwarf_find_section(const char *name)
{
  80042167ca:	55                   	push   %rbp
  80042167cb:	48 89 e5             	mov    %rsp,%rbp
  80042167ce:	48 83 ec 20          	sub    $0x20,%rsp
  80042167d2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *ret=NULL;
  80042167d6:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042167dd:	00 
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  80042167de:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042167e5:	eb 57                	jmp    800421683e <_dwarf_find_section+0x74>
		if(!strcmp(section_info[i].ds_name, name)) {
  80042167e7:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  80042167ee:	00 00 00 
  80042167f1:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042167f4:	48 63 d2             	movslq %edx,%rdx
  80042167f7:	48 c1 e2 05          	shl    $0x5,%rdx
  80042167fb:	48 01 d0             	add    %rdx,%rax
  80042167fe:	48 8b 00             	mov    (%rax),%rax
  8004216801:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004216805:	48 89 d6             	mov    %rdx,%rsi
  8004216808:	48 89 c7             	mov    %rax,%rdi
  800421680b:	48 b8 81 10 21 04 80 	movabs $0x8004211081,%rax
  8004216812:	00 00 00 
  8004216815:	ff d0                	callq  *%rax
  8004216817:	85 c0                	test   %eax,%eax
  8004216819:	75 1f                	jne    800421683a <_dwarf_find_section+0x70>
			ret = (section_info + i);
  800421681b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421681e:	48 98                	cltq   
  8004216820:	48 c1 e0 05          	shl    $0x5,%rax
  8004216824:	48 89 c2             	mov    %rax,%rdx
  8004216827:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  800421682e:	00 00 00 
  8004216831:	48 01 d0             	add    %rdx,%rax
  8004216834:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  8004216838:	eb 0a                	jmp    8004216844 <_dwarf_find_section+0x7a>
_dwarf_find_section(const char *name)
{
	Dwarf_Section *ret=NULL;
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  800421683a:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800421683e:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004216842:	7e a3                	jle    80042167e7 <_dwarf_find_section+0x1d>
			ret = (section_info + i);
			break;
		}
	}

	return ret;
  8004216844:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004216848:	c9                   	leaveq 
  8004216849:	c3                   	retq   

000000800421684a <find_debug_sections>:

void find_debug_sections(uintptr_t elf) 
{
  800421684a:	55                   	push   %rbp
  800421684b:	48 89 e5             	mov    %rsp,%rbp
  800421684e:	48 83 ec 40          	sub    $0x40,%rsp
  8004216852:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	Elf *ehdr = (Elf *)elf;
  8004216856:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421685a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uintptr_t debug_address = USTABDATA;
  800421685e:	48 c7 45 f8 00 00 20 	movq   $0x200000,-0x8(%rbp)
  8004216865:	00 
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
  8004216866:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421686a:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800421686e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216872:	48 01 d0             	add    %rdx,%rax
  8004216875:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
  8004216879:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421687d:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004216881:	0f b7 c0             	movzwl %ax,%eax
  8004216884:	48 c1 e0 06          	shl    $0x6,%rax
  8004216888:	48 89 c2             	mov    %rax,%rdx
  800421688b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421688f:	48 01 d0             	add    %rdx,%rax
  8004216892:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Secthdr* esh = sh + ehdr->e_shnum;
  8004216896:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421689a:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  800421689e:	0f b7 c0             	movzwl %ax,%eax
  80042168a1:	48 c1 e0 06          	shl    $0x6,%rax
  80042168a5:	48 89 c2             	mov    %rax,%rdx
  80042168a8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042168ac:	48 01 d0             	add    %rdx,%rax
  80042168af:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;sh < esh; sh++) {
  80042168b3:	e9 4b 02 00 00       	jmpq   8004216b03 <find_debug_sections+0x2b9>
		char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  80042168b8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042168bc:	8b 00                	mov    (%rax),%eax
  80042168be:	89 c1                	mov    %eax,%ecx
  80042168c0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042168c4:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042168c8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042168cc:	48 01 d0             	add    %rdx,%rax
  80042168cf:	48 01 c8             	add    %rcx,%rax
  80042168d2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!strcmp(name, ".debug_info")) {
  80042168d6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042168da:	48 be 6b 19 22 04 80 	movabs $0x800422196b,%rsi
  80042168e1:	00 00 00 
  80042168e4:	48 89 c7             	mov    %rax,%rdi
  80042168e7:	48 b8 81 10 21 04 80 	movabs $0x8004211081,%rax
  80042168ee:	00 00 00 
  80042168f1:	ff d0                	callq  *%rax
  80042168f3:	85 c0                	test   %eax,%eax
  80042168f5:	75 4b                	jne    8004216942 <find_debug_sections+0xf8>
			section_info[DEBUG_INFO].ds_data = (uint8_t*)debug_address;
  80042168f7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042168fb:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004216902:	00 00 00 
  8004216905:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = debug_address;
  8004216909:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004216910:	00 00 00 
  8004216913:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004216917:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = sh->sh_size;
  800421691b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421691f:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216923:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  800421692a:	00 00 00 
  800421692d:	48 89 50 18          	mov    %rdx,0x18(%rax)
			debug_address += sh->sh_size;
  8004216931:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216935:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004216939:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  800421693d:	e9 bc 01 00 00       	jmpq   8004216afe <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_abbrev")) {
  8004216942:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216946:	48 be 77 19 22 04 80 	movabs $0x8004221977,%rsi
  800421694d:	00 00 00 
  8004216950:	48 89 c7             	mov    %rax,%rdi
  8004216953:	48 b8 81 10 21 04 80 	movabs $0x8004211081,%rax
  800421695a:	00 00 00 
  800421695d:	ff d0                	callq  *%rax
  800421695f:	85 c0                	test   %eax,%eax
  8004216961:	75 4b                	jne    80042169ae <find_debug_sections+0x164>
			section_info[DEBUG_ABBREV].ds_data = (uint8_t*)debug_address;
  8004216963:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004216967:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  800421696e:	00 00 00 
  8004216971:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = debug_address;
  8004216975:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  800421697c:	00 00 00 
  800421697f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004216983:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = sh->sh_size;
  8004216987:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421698b:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421698f:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004216996:	00 00 00 
  8004216999:	48 89 50 38          	mov    %rdx,0x38(%rax)
			debug_address += sh->sh_size;
  800421699d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042169a1:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042169a5:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042169a9:	e9 50 01 00 00       	jmpq   8004216afe <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_line")){
  80042169ae:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042169b2:	48 be 8f 19 22 04 80 	movabs $0x800422198f,%rsi
  80042169b9:	00 00 00 
  80042169bc:	48 89 c7             	mov    %rax,%rdi
  80042169bf:	48 b8 81 10 21 04 80 	movabs $0x8004211081,%rax
  80042169c6:	00 00 00 
  80042169c9:	ff d0                	callq  *%rax
  80042169cb:	85 c0                	test   %eax,%eax
  80042169cd:	75 4b                	jne    8004216a1a <find_debug_sections+0x1d0>
			section_info[DEBUG_LINE].ds_data = (uint8_t*)debug_address;
  80042169cf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042169d3:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  80042169da:	00 00 00 
  80042169dd:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = debug_address;
  80042169e1:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  80042169e8:	00 00 00 
  80042169eb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042169ef:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = sh->sh_size;
  80042169f3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042169f7:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042169fb:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004216a02:	00 00 00 
  8004216a05:	48 89 50 78          	mov    %rdx,0x78(%rax)
			debug_address += sh->sh_size;
  8004216a09:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216a0d:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004216a11:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004216a15:	e9 e4 00 00 00       	jmpq   8004216afe <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".eh_frame")){
  8004216a1a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216a1e:	48 be 85 19 22 04 80 	movabs $0x8004221985,%rsi
  8004216a25:	00 00 00 
  8004216a28:	48 89 c7             	mov    %rax,%rdi
  8004216a2b:	48 b8 81 10 21 04 80 	movabs $0x8004211081,%rax
  8004216a32:	00 00 00 
  8004216a35:	ff d0                	callq  *%rax
  8004216a37:	85 c0                	test   %eax,%eax
  8004216a39:	75 53                	jne    8004216a8e <find_debug_sections+0x244>
			section_info[DEBUG_FRAME].ds_data = (uint8_t*)sh->sh_addr;
  8004216a3b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216a3f:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216a43:	48 89 c2             	mov    %rax,%rdx
  8004216a46:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004216a4d:	00 00 00 
  8004216a50:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = sh->sh_addr;
  8004216a54:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216a58:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004216a5c:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004216a63:	00 00 00 
  8004216a66:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = sh->sh_size;
  8004216a6a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216a6e:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216a72:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004216a79:	00 00 00 
  8004216a7c:	48 89 50 58          	mov    %rdx,0x58(%rax)
			debug_address += sh->sh_size;
  8004216a80:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216a84:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004216a88:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004216a8c:	eb 70                	jmp    8004216afe <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_str")) {
  8004216a8e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216a92:	48 be 9b 19 22 04 80 	movabs $0x800422199b,%rsi
  8004216a99:	00 00 00 
  8004216a9c:	48 89 c7             	mov    %rax,%rdi
  8004216a9f:	48 b8 81 10 21 04 80 	movabs $0x8004211081,%rax
  8004216aa6:	00 00 00 
  8004216aa9:	ff d0                	callq  *%rax
  8004216aab:	85 c0                	test   %eax,%eax
  8004216aad:	75 4f                	jne    8004216afe <find_debug_sections+0x2b4>
			section_info[DEBUG_STR].ds_data = (uint8_t*)debug_address;
  8004216aaf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004216ab3:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004216aba:	00 00 00 
  8004216abd:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = debug_address;
  8004216ac4:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004216acb:	00 00 00 
  8004216ace:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004216ad2:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = sh->sh_size;
  8004216ad9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216add:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216ae1:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004216ae8:	00 00 00 
  8004216aeb:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
			debug_address += sh->sh_size;
  8004216af2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216af6:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004216afa:	48 01 45 f8          	add    %rax,-0x8(%rbp)
	Elf *ehdr = (Elf *)elf;
	uintptr_t debug_address = USTABDATA;
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
	Secthdr* esh = sh + ehdr->e_shnum;
	for(;sh < esh; sh++) {
  8004216afe:	48 83 45 f0 40       	addq   $0x40,-0x10(%rbp)
  8004216b03:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216b07:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004216b0b:	0f 82 a7 fd ff ff    	jb     80042168b8 <find_debug_sections+0x6e>
			section_info[DEBUG_STR].ds_size = sh->sh_size;
			debug_address += sh->sh_size;
		}
	}

}
  8004216b11:	90                   	nop
  8004216b12:	c9                   	leaveq 
  8004216b13:	c3                   	retq   

0000008004216b14 <read_section_headers>:

uint64_t
read_section_headers(uintptr_t elfhdr, uintptr_t to_va)
{
  8004216b14:	55                   	push   %rbp
  8004216b15:	48 89 e5             	mov    %rsp,%rbp
  8004216b18:	48 81 ec 60 01 00 00 	sub    $0x160,%rsp
  8004216b1f:	48 89 bd a8 fe ff ff 	mov    %rdi,-0x158(%rbp)
  8004216b26:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
	Secthdr* secthdr_ptr[20] = {0};
  8004216b2d:	48 8d 95 c0 fe ff ff 	lea    -0x140(%rbp),%rdx
  8004216b34:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216b39:	b9 14 00 00 00       	mov    $0x14,%ecx
  8004216b3e:	48 89 d7             	mov    %rdx,%rdi
  8004216b41:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	char* kvbase = ROUNDUP((char*)to_va, SECTSIZE);
  8004216b44:	48 c7 45 e8 00 02 00 	movq   $0x200,-0x18(%rbp)
  8004216b4b:	00 
  8004216b4c:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  8004216b53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216b57:	48 01 d0             	add    %rdx,%rax
  8004216b5a:	48 83 e8 01          	sub    $0x1,%rax
  8004216b5e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004216b62:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216b66:	ba 00 00 00 00       	mov    $0x0,%edx
  8004216b6b:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004216b6f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216b73:	48 29 d0             	sub    %rdx,%rax
  8004216b76:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	uint64_t kvoffset = 0;
  8004216b7a:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  8004216b81:	00 00 00 00 
	char *orig_secthdr = (char*)kvbase;
  8004216b85:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216b89:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	char * secthdr = NULL;
  8004216b8d:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8004216b94:	00 
	uint64_t offset;
	if(elfhdr == KELFHDR)
  8004216b95:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  8004216b9c:	00 00 00 
  8004216b9f:	48 39 85 a8 fe ff ff 	cmp    %rax,-0x158(%rbp)
  8004216ba6:	75 11                	jne    8004216bb9 <read_section_headers+0xa5>
		offset = ((Elf*)elfhdr)->e_shoff;
  8004216ba8:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004216baf:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004216bb3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004216bb7:	eb 26                	jmp    8004216bdf <read_section_headers+0xcb>
	else
		offset = ((Elf*)elfhdr)->e_shoff + (elfhdr - KERNBASE);
  8004216bb9:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004216bc0:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004216bc4:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004216bcb:	48 01 c2             	add    %rax,%rdx
  8004216bce:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004216bd5:	ff ff ff 
  8004216bd8:	48 01 d0             	add    %rdx,%rax
  8004216bdb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	int numSectionHeaders = ((Elf*)elfhdr)->e_shnum;
  8004216bdf:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004216be6:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004216bea:	0f b7 c0             	movzwl %ax,%eax
  8004216bed:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	int sizeSections = ((Elf*)elfhdr)->e_shentsize;
  8004216bf0:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004216bf7:	0f b7 40 3a          	movzwl 0x3a(%rax),%eax
  8004216bfb:	0f b7 c0             	movzwl %ax,%eax
  8004216bfe:	89 45 c0             	mov    %eax,-0x40(%rbp)
	char *nametab;
	int i;
	uint64_t temp;
	char *name;

	Elf *ehdr = (Elf *)elfhdr;
  8004216c01:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004216c08:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
  8004216c0c:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004216c0f:	0f af 45 c0          	imul   -0x40(%rbp),%eax
  8004216c13:	48 63 f0             	movslq %eax,%rsi
  8004216c16:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216c1a:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004216c21:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004216c25:	48 89 c7             	mov    %rax,%rdi
  8004216c28:	48 b8 59 72 21 04 80 	movabs $0x8004217259,%rax
  8004216c2f:	00 00 00 
  8004216c32:	ff d0                	callq  *%rax
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
  8004216c34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216c38:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004216c3c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004216c40:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004216c46:	48 89 c2             	mov    %rax,%rdx
  8004216c49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216c4d:	48 29 d0             	sub    %rdx,%rax
  8004216c50:	48 89 c2             	mov    %rax,%rdx
  8004216c53:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216c57:	48 01 d0             	add    %rdx,%rax
  8004216c5a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < numSectionHeaders; i++)
  8004216c5e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004216c65:	eb 24                	jmp    8004216c8b <read_section_headers+0x177>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
  8004216c67:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216c6a:	48 98                	cltq   
  8004216c6c:	48 c1 e0 06          	shl    $0x6,%rax
  8004216c70:	48 89 c2             	mov    %rax,%rdx
  8004216c73:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004216c77:	48 01 c2             	add    %rax,%rdx
  8004216c7a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216c7d:	48 98                	cltq   
  8004216c7f:	48 89 94 c5 c0 fe ff 	mov    %rdx,-0x140(%rbp,%rax,8)
  8004216c86:	ff 
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
	for (i = 0; i < numSectionHeaders; i++)
  8004216c87:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216c8b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216c8e:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004216c91:	7c d4                	jl     8004216c67 <read_section_headers+0x153>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
  8004216c93:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004216c97:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004216c9b:	0f b7 c0             	movzwl %ax,%eax
  8004216c9e:	48 98                	cltq   
  8004216ca0:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216ca7:	ff 
  8004216ca8:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	temp = kvoffset;
  8004216cac:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004216cb3:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
  8004216cb7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004216cbb:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216cbf:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004216cc3:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004216cc7:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  8004216cce:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004216cd2:	48 01 f1             	add    %rsi,%rcx
  8004216cd5:	48 89 cf             	mov    %rcx,%rdi
  8004216cd8:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004216cdf:	48 89 c6             	mov    %rax,%rsi
  8004216ce2:	48 b8 59 72 21 04 80 	movabs $0x8004217259,%rax
  8004216ce9:	00 00 00 
  8004216cec:	ff d0                	callq  *%rax
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	
  8004216cee:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004216cf2:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216cf6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004216cfa:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216cfe:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  8004216d02:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004216d06:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004216d0c:	48 29 c2             	sub    %rax,%rdx
  8004216d0f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004216d13:	48 01 c2             	add    %rax,%rdx
  8004216d16:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216d1a:	48 01 d0             	add    %rdx,%rax
  8004216d1d:	48 89 45 90          	mov    %rax,-0x70(%rbp)

	for (i = 0; i < numSectionHeaders; i++)
  8004216d21:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004216d28:	e9 10 05 00 00       	jmpq   800421723d <read_section_headers+0x729>
	{
		name = (char *)(nametab + secthdr_ptr[i]->sh_name);
  8004216d2d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216d30:	48 98                	cltq   
  8004216d32:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216d39:	ff 
  8004216d3a:	8b 00                	mov    (%rax),%eax
  8004216d3c:	89 c2                	mov    %eax,%edx
  8004216d3e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004216d42:	48 01 d0             	add    %rdx,%rax
  8004216d45:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		assert(kvoffset % SECTSIZE == 0);
  8004216d49:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004216d50:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004216d55:	48 85 c0             	test   %rax,%rax
  8004216d58:	74 35                	je     8004216d8f <read_section_headers+0x27b>
  8004216d5a:	48 b9 a6 19 22 04 80 	movabs $0x80042219a6,%rcx
  8004216d61:	00 00 00 
  8004216d64:	48 ba bf 19 22 04 80 	movabs $0x80042219bf,%rdx
  8004216d6b:	00 00 00 
  8004216d6e:	be 88 00 00 00       	mov    $0x88,%esi
  8004216d73:	48 bf d4 19 22 04 80 	movabs $0x80042219d4,%rdi
  8004216d7a:	00 00 00 
  8004216d7d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216d82:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004216d89:	00 00 00 
  8004216d8c:	41 ff d0             	callq  *%r8
		temp = kvoffset;
  8004216d8f:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004216d96:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
  8004216d9a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216d9e:	48 be 6b 19 22 04 80 	movabs $0x800422196b,%rsi
  8004216da5:	00 00 00 
  8004216da8:	48 89 c7             	mov    %rax,%rdi
  8004216dab:	48 b8 81 10 21 04 80 	movabs $0x8004211081,%rax
  8004216db2:	00 00 00 
  8004216db5:	ff d0                	callq  *%rax
  8004216db7:	85 c0                	test   %eax,%eax
  8004216db9:	0f 85 db 00 00 00    	jne    8004216e9a <read_section_headers+0x386>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004216dbf:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216dc2:	48 98                	cltq   
  8004216dc4:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216dcb:	ff 
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004216dcc:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216dd0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216dd3:	48 98                	cltq   
  8004216dd5:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216ddc:	ff 
  8004216ddd:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004216de1:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  8004216de8:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004216dec:	48 01 f1             	add    %rsi,%rcx
  8004216def:	48 89 cf             	mov    %rcx,%rdi
  8004216df2:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004216df9:	48 89 c6             	mov    %rax,%rsi
  8004216dfc:	48 b8 59 72 21 04 80 	movabs $0x8004217259,%rax
  8004216e03:	00 00 00 
  8004216e06:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_INFO].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004216e08:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216e0b:	48 98                	cltq   
  8004216e0d:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216e14:	ff 
  8004216e15:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216e19:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216e1c:	48 98                	cltq   
  8004216e1e:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216e25:	ff 
  8004216e26:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216e2a:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  8004216e2e:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004216e32:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004216e38:	48 29 c2             	sub    %rax,%rdx
  8004216e3b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004216e3f:	48 01 c2             	add    %rax,%rdx
  8004216e42:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216e46:	48 01 c2             	add    %rax,%rdx
  8004216e49:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004216e50:	00 00 00 
  8004216e53:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
  8004216e57:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004216e5e:	00 00 00 
  8004216e61:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004216e65:	48 89 c2             	mov    %rax,%rdx
  8004216e68:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004216e6f:	00 00 00 
  8004216e72:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
  8004216e76:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216e79:	48 98                	cltq   
  8004216e7b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216e82:	ff 
  8004216e83:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216e87:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004216e8e:	00 00 00 
  8004216e91:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004216e95:	e9 9f 03 00 00       	jmpq   8004217239 <read_section_headers+0x725>
		}
		else if(!strcmp(name, ".debug_abbrev"))
  8004216e9a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216e9e:	48 be 77 19 22 04 80 	movabs $0x8004221977,%rsi
  8004216ea5:	00 00 00 
  8004216ea8:	48 89 c7             	mov    %rax,%rdi
  8004216eab:	48 b8 81 10 21 04 80 	movabs $0x8004211081,%rax
  8004216eb2:	00 00 00 
  8004216eb5:	ff d0                	callq  *%rax
  8004216eb7:	85 c0                	test   %eax,%eax
  8004216eb9:	0f 85 e1 00 00 00    	jne    8004216fa0 <read_section_headers+0x48c>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004216ebf:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216ec2:	48 98                	cltq   
  8004216ec4:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216ecb:	ff 
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_abbrev"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004216ecc:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216ed0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216ed3:	48 98                	cltq   
  8004216ed5:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216edc:	ff 
  8004216edd:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004216ee1:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  8004216ee8:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004216eec:	48 01 f1             	add    %rsi,%rcx
  8004216eef:	48 89 cf             	mov    %rcx,%rdi
  8004216ef2:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004216ef9:	48 89 c6             	mov    %rax,%rsi
  8004216efc:	48 b8 59 72 21 04 80 	movabs $0x8004217259,%rax
  8004216f03:	00 00 00 
  8004216f06:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_ABBREV].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004216f08:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216f0b:	48 98                	cltq   
  8004216f0d:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216f14:	ff 
  8004216f15:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216f19:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216f1c:	48 98                	cltq   
  8004216f1e:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216f25:	ff 
  8004216f26:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216f2a:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004216f31:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004216f38:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004216f3e:	48 29 c2             	sub    %rax,%rdx
  8004216f41:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004216f45:	48 01 c2             	add    %rax,%rdx
  8004216f48:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216f4c:	48 01 c2             	add    %rax,%rdx
  8004216f4f:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004216f56:	00 00 00 
  8004216f59:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
  8004216f5d:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004216f64:	00 00 00 
  8004216f67:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004216f6b:	48 89 c2             	mov    %rax,%rdx
  8004216f6e:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004216f75:	00 00 00 
  8004216f78:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
  8004216f7c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216f7f:	48 98                	cltq   
  8004216f81:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216f88:	ff 
  8004216f89:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216f8d:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004216f94:	00 00 00 
  8004216f97:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004216f9b:	e9 99 02 00 00       	jmpq   8004217239 <read_section_headers+0x725>
		}
		else if(!strcmp(name, ".debug_line"))
  8004216fa0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216fa4:	48 be 8f 19 22 04 80 	movabs $0x800422198f,%rsi
  8004216fab:	00 00 00 
  8004216fae:	48 89 c7             	mov    %rax,%rdi
  8004216fb1:	48 b8 81 10 21 04 80 	movabs $0x8004211081,%rax
  8004216fb8:	00 00 00 
  8004216fbb:	ff d0                	callq  *%rax
  8004216fbd:	85 c0                	test   %eax,%eax
  8004216fbf:	0f 85 e1 00 00 00    	jne    80042170a6 <read_section_headers+0x592>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004216fc5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216fc8:	48 98                	cltq   
  8004216fca:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216fd1:	ff 
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_line"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004216fd2:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216fd6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216fd9:	48 98                	cltq   
  8004216fdb:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216fe2:	ff 
  8004216fe3:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004216fe7:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  8004216fee:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004216ff2:	48 01 f1             	add    %rsi,%rcx
  8004216ff5:	48 89 cf             	mov    %rcx,%rdi
  8004216ff8:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004216fff:	48 89 c6             	mov    %rax,%rsi
  8004217002:	48 b8 59 72 21 04 80 	movabs $0x8004217259,%rax
  8004217009:	00 00 00 
  800421700c:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_LINE].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  800421700e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004217011:	48 98                	cltq   
  8004217013:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421701a:	ff 
  800421701b:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421701f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004217022:	48 98                	cltq   
  8004217024:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421702b:	ff 
  800421702c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004217030:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8004217037:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800421703e:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004217044:	48 29 c2             	sub    %rax,%rdx
  8004217047:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421704b:	48 01 c2             	add    %rax,%rdx
  800421704e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217052:	48 01 c2             	add    %rax,%rdx
  8004217055:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  800421705c:	00 00 00 
  800421705f:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = (uintptr_t)section_info[DEBUG_LINE].ds_data;
  8004217063:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  800421706a:	00 00 00 
  800421706d:	48 8b 40 68          	mov    0x68(%rax),%rax
  8004217071:	48 89 c2             	mov    %rax,%rdx
  8004217074:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  800421707b:	00 00 00 
  800421707e:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = secthdr_ptr[i]->sh_size;
  8004217082:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004217085:	48 98                	cltq   
  8004217087:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421708e:	ff 
  800421708f:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004217093:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  800421709a:	00 00 00 
  800421709d:	48 89 50 78          	mov    %rdx,0x78(%rax)
  80042170a1:	e9 93 01 00 00       	jmpq   8004217239 <read_section_headers+0x725>
		}
		else if(!strcmp(name, ".eh_frame"))
  80042170a6:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042170aa:	48 be 85 19 22 04 80 	movabs $0x8004221985,%rsi
  80042170b1:	00 00 00 
  80042170b4:	48 89 c7             	mov    %rax,%rdi
  80042170b7:	48 b8 81 10 21 04 80 	movabs $0x8004211081,%rax
  80042170be:	00 00 00 
  80042170c1:	ff d0                	callq  *%rax
  80042170c3:	85 c0                	test   %eax,%eax
  80042170c5:	75 65                	jne    800421712c <read_section_headers+0x618>
		{
			section_info[DEBUG_FRAME].ds_data = (uint8_t *)secthdr_ptr[i]->sh_addr;
  80042170c7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042170ca:	48 98                	cltq   
  80042170cc:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042170d3:	ff 
  80042170d4:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042170d8:	48 89 c2             	mov    %rax,%rdx
  80042170db:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  80042170e2:	00 00 00 
  80042170e5:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
  80042170e9:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  80042170f0:	00 00 00 
  80042170f3:	48 8b 40 48          	mov    0x48(%rax),%rax
  80042170f7:	48 89 c2             	mov    %rax,%rdx
  80042170fa:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004217101:	00 00 00 
  8004217104:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
  8004217108:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421710b:	48 98                	cltq   
  800421710d:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004217114:	ff 
  8004217115:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004217119:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  8004217120:	00 00 00 
  8004217123:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004217127:	e9 0d 01 00 00       	jmpq   8004217239 <read_section_headers+0x725>
		}
		else if(!strcmp(name, ".debug_str"))
  800421712c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004217130:	48 be 9b 19 22 04 80 	movabs $0x800422199b,%rsi
  8004217137:	00 00 00 
  800421713a:	48 89 c7             	mov    %rax,%rdi
  800421713d:	48 b8 81 10 21 04 80 	movabs $0x8004211081,%rax
  8004217144:	00 00 00 
  8004217147:	ff d0                	callq  *%rax
  8004217149:	85 c0                	test   %eax,%eax
  800421714b:	0f 85 e8 00 00 00    	jne    8004217239 <read_section_headers+0x725>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004217151:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004217154:	48 98                	cltq   
  8004217156:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421715d:	ff 
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_str"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  800421715e:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004217162:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004217165:	48 98                	cltq   
  8004217167:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421716e:	ff 
  800421716f:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004217173:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  800421717a:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421717e:	48 01 f1             	add    %rsi,%rcx
  8004217181:	48 89 cf             	mov    %rcx,%rdi
  8004217184:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421718b:	48 89 c6             	mov    %rax,%rsi
  800421718e:	48 b8 59 72 21 04 80 	movabs $0x8004217259,%rax
  8004217195:	00 00 00 
  8004217198:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_STR].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  800421719a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421719d:	48 98                	cltq   
  800421719f:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042171a6:	ff 
  80042171a7:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042171ab:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042171ae:	48 98                	cltq   
  80042171b0:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042171b7:	ff 
  80042171b8:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042171bc:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  80042171c3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042171ca:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042171d0:	48 29 c2             	sub    %rax,%rdx
  80042171d3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042171d7:	48 01 c2             	add    %rax,%rdx
  80042171da:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042171de:	48 01 c2             	add    %rax,%rdx
  80042171e1:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  80042171e8:	00 00 00 
  80042171eb:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
  80042171f2:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  80042171f9:	00 00 00 
  80042171fc:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004217203:	48 89 c2             	mov    %rax,%rdx
  8004217206:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  800421720d:	00 00 00 
  8004217210:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
  8004217217:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421721a:	48 98                	cltq   
  800421721c:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004217223:	ff 
  8004217224:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004217228:	48 b8 c0 66 23 04 80 	movabs $0x80042366c0,%rax
  800421722f:	00 00 00 
  8004217232:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	temp = kvoffset;
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	

	for (i = 0; i < numSectionHeaders; i++)
  8004217239:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800421723d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004217240:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004217243:	0f 8c e4 fa ff ff    	jl     8004216d2d <read_section_headers+0x219>
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
		}
	}
	
	return ((uintptr_t)kvbase + kvoffset);
  8004217249:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421724d:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004217254:	48 01 d0             	add    %rdx,%rax
}
  8004217257:	c9                   	leaveq 
  8004217258:	c3                   	retq   

0000008004217259 <readseg>:

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint64_t pa, uint64_t count, uint64_t offset, uint64_t* kvoffset)
{
  8004217259:	55                   	push   %rbp
  800421725a:	48 89 e5             	mov    %rsp,%rbp
  800421725d:	48 83 ec 30          	sub    $0x30,%rsp
  8004217261:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004217265:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004217269:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800421726d:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	uint64_t end_pa;
	uint64_t orgoff = offset;
  8004217271:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217275:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	end_pa = pa + count;
  8004217279:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421727d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217281:	48 01 d0             	add    %rdx,%rax
  8004217284:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	assert(pa % SECTSIZE == 0);	
  8004217288:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421728c:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004217291:	48 85 c0             	test   %rax,%rax
  8004217294:	74 35                	je     80042172cb <readseg+0x72>
  8004217296:	48 b9 e2 19 22 04 80 	movabs $0x80042219e2,%rcx
  800421729d:	00 00 00 
  80042172a0:	48 ba bf 19 22 04 80 	movabs $0x80042219bf,%rdx
  80042172a7:	00 00 00 
  80042172aa:	be c2 00 00 00       	mov    $0xc2,%esi
  80042172af:	48 bf d4 19 22 04 80 	movabs $0x80042219d4,%rdi
  80042172b6:	00 00 00 
  80042172b9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042172be:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042172c5:	00 00 00 
  80042172c8:	41 ff d0             	callq  *%r8
	// round down to sector boundary
	pa &= ~(SECTSIZE - 1);
  80042172cb:	48 81 65 e8 00 fe ff 	andq   $0xfffffffffffffe00,-0x18(%rbp)
  80042172d2:	ff 

	// translate from bytes to sectors, and kernel starts at sector 1
	offset = (offset / SECTSIZE) + 1;
  80042172d3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042172d7:	48 c1 e8 09          	shr    $0x9,%rax
  80042172db:	48 83 c0 01          	add    $0x1,%rax
  80042172df:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  80042172e3:	eb 3c                	jmp    8004217321 <readseg+0xc8>
		readsect((uint8_t*) pa, offset);
  80042172e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042172e9:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042172ed:	48 89 d6             	mov    %rdx,%rsi
  80042172f0:	48 89 c7             	mov    %rax,%rdi
  80042172f3:	48 b8 eb 73 21 04 80 	movabs $0x80042173eb,%rax
  80042172fa:	00 00 00 
  80042172fd:	ff d0                	callq  *%rax
		pa += SECTSIZE;
  80042172ff:	48 81 45 e8 00 02 00 	addq   $0x200,-0x18(%rbp)
  8004217306:	00 
		*kvoffset += SECTSIZE;
  8004217307:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421730b:	48 8b 00             	mov    (%rax),%rax
  800421730e:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004217315:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004217319:	48 89 10             	mov    %rdx,(%rax)
		offset++;
  800421731c:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	offset = (offset / SECTSIZE) + 1;

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004217321:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217325:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004217329:	72 ba                	jb     80042172e5 <readseg+0x8c>
		pa += SECTSIZE;
		*kvoffset += SECTSIZE;
		offset++;
	}

	if(((orgoff % SECTSIZE) + count) > SECTSIZE)
  800421732b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421732f:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004217334:	48 89 c2             	mov    %rax,%rdx
  8004217337:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421733b:	48 01 d0             	add    %rdx,%rax
  800421733e:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  8004217344:	76 2f                	jbe    8004217375 <readseg+0x11c>
	{
		readsect((uint8_t*) pa, offset);
  8004217346:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421734a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421734e:	48 89 d6             	mov    %rdx,%rsi
  8004217351:	48 89 c7             	mov    %rax,%rdi
  8004217354:	48 b8 eb 73 21 04 80 	movabs $0x80042173eb,%rax
  800421735b:	00 00 00 
  800421735e:	ff d0                	callq  *%rax
		*kvoffset += SECTSIZE;
  8004217360:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004217364:	48 8b 00             	mov    (%rax),%rax
  8004217367:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  800421736e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004217372:	48 89 10             	mov    %rdx,(%rax)
	}
	assert(*kvoffset % SECTSIZE == 0);
  8004217375:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004217379:	48 8b 00             	mov    (%rax),%rax
  800421737c:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004217381:	48 85 c0             	test   %rax,%rax
  8004217384:	74 35                	je     80042173bb <readseg+0x162>
  8004217386:	48 b9 f5 19 22 04 80 	movabs $0x80042219f5,%rcx
  800421738d:	00 00 00 
  8004217390:	48 ba bf 19 22 04 80 	movabs $0x80042219bf,%rdx
  8004217397:	00 00 00 
  800421739a:	be d8 00 00 00       	mov    $0xd8,%esi
  800421739f:	48 bf d4 19 22 04 80 	movabs $0x80042219d4,%rdi
  80042173a6:	00 00 00 
  80042173a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042173ae:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042173b5:	00 00 00 
  80042173b8:	41 ff d0             	callq  *%r8
}
  80042173bb:	90                   	nop
  80042173bc:	c9                   	leaveq 
  80042173bd:	c3                   	retq   

00000080042173be <waitdisk>:

void
waitdisk(void)
{
  80042173be:	55                   	push   %rbp
  80042173bf:	48 89 e5             	mov    %rsp,%rbp
  80042173c2:	48 83 ec 10          	sub    $0x10,%rsp
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
  80042173c6:	90                   	nop
  80042173c7:	c7 45 fc f7 01 00 00 	movl   $0x1f7,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042173ce:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042173d1:	89 c2                	mov    %eax,%edx
  80042173d3:	ec                   	in     (%dx),%al
  80042173d4:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  80042173d7:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042173db:	0f b6 c0             	movzbl %al,%eax
  80042173de:	25 c0 00 00 00       	and    $0xc0,%eax
  80042173e3:	83 f8 40             	cmp    $0x40,%eax
  80042173e6:	75 df                	jne    80042173c7 <waitdisk+0x9>
		/* do nothing */;
}
  80042173e8:	90                   	nop
  80042173e9:	c9                   	leaveq 
  80042173ea:	c3                   	retq   

00000080042173eb <readsect>:

void
readsect(void *dst, uint64_t offset)
{
  80042173eb:	55                   	push   %rbp
  80042173ec:	48 89 e5             	mov    %rsp,%rbp
  80042173ef:	48 83 ec 50          	sub    $0x50,%rsp
  80042173f3:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  80042173f7:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
	// wait for disk to be ready
	waitdisk();
  80042173fb:	48 b8 be 73 21 04 80 	movabs $0x80042173be,%rax
  8004217402:	00 00 00 
  8004217405:	ff d0                	callq  *%rax
  8004217407:	c7 45 fc f2 01 00 00 	movl   $0x1f2,-0x4(%rbp)
  800421740e:	c6 45 ce 01          	movb   $0x1,-0x32(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004217412:	0f b6 45 ce          	movzbl -0x32(%rbp),%eax
  8004217416:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004217419:	ee                   	out    %al,(%dx)

	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
  800421741a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421741e:	0f b6 c0             	movzbl %al,%eax
  8004217421:	c7 45 f8 f3 01 00 00 	movl   $0x1f3,-0x8(%rbp)
  8004217428:	88 45 cf             	mov    %al,-0x31(%rbp)
  800421742b:	0f b6 45 cf          	movzbl -0x31(%rbp),%eax
  800421742f:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004217432:	ee                   	out    %al,(%dx)
	outb(0x1F4, offset >> 8);
  8004217433:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004217437:	48 c1 e8 08          	shr    $0x8,%rax
  800421743b:	0f b6 c0             	movzbl %al,%eax
  800421743e:	c7 45 f4 f4 01 00 00 	movl   $0x1f4,-0xc(%rbp)
  8004217445:	88 45 d0             	mov    %al,-0x30(%rbp)
  8004217448:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
  800421744c:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421744f:	ee                   	out    %al,(%dx)
	outb(0x1F5, offset >> 16);
  8004217450:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004217454:	48 c1 e8 10          	shr    $0x10,%rax
  8004217458:	0f b6 c0             	movzbl %al,%eax
  800421745b:	c7 45 f0 f5 01 00 00 	movl   $0x1f5,-0x10(%rbp)
  8004217462:	88 45 d1             	mov    %al,-0x2f(%rbp)
  8004217465:	0f b6 45 d1          	movzbl -0x2f(%rbp),%eax
  8004217469:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800421746c:	ee                   	out    %al,(%dx)
	outb(0x1F6, (offset >> 24) | 0xE0);
  800421746d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004217471:	48 c1 e8 18          	shr    $0x18,%rax
  8004217475:	83 c8 e0             	or     $0xffffffe0,%eax
  8004217478:	0f b6 c0             	movzbl %al,%eax
  800421747b:	c7 45 ec f6 01 00 00 	movl   $0x1f6,-0x14(%rbp)
  8004217482:	88 45 d2             	mov    %al,-0x2e(%rbp)
  8004217485:	0f b6 45 d2          	movzbl -0x2e(%rbp),%eax
  8004217489:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421748c:	ee                   	out    %al,(%dx)
  800421748d:	c7 45 e8 f7 01 00 00 	movl   $0x1f7,-0x18(%rbp)
  8004217494:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
  8004217498:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  800421749c:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800421749f:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();
  80042174a0:	48 b8 be 73 21 04 80 	movabs $0x80042173be,%rax
  80042174a7:	00 00 00 
  80042174aa:	ff d0                	callq  *%rax
  80042174ac:	c7 45 e4 f0 01 00 00 	movl   $0x1f0,-0x1c(%rbp)
  80042174b3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042174b7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042174bb:	c7 45 d4 80 00 00 00 	movl   $0x80,-0x2c(%rbp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
  80042174c2:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042174c5:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042174c9:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80042174cc:	48 89 ce             	mov    %rcx,%rsi
  80042174cf:	48 89 f7             	mov    %rsi,%rdi
  80042174d2:	89 c1                	mov    %eax,%ecx
  80042174d4:	fc                   	cld    
  80042174d5:	f2 6d                	repnz insl (%dx),%es:(%rdi)
  80042174d7:	89 c8                	mov    %ecx,%eax
  80042174d9:	48 89 fe             	mov    %rdi,%rsi
  80042174dc:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  80042174e0:	89 45 d4             	mov    %eax,-0x2c(%rbp)

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}
  80042174e3:	90                   	nop
  80042174e4:	c9                   	leaveq 
  80042174e5:	c3                   	retq   
  80042174e6:	66 90                	xchg   %ax,%ax

00000080042174e8 <mpentry_start>:
.set pml4, pml4phys

.code16           
.globl mpentry_start
mpentry_start:
	cli
  80042174e8:	fa                   	cli    
	xorw    %ax, %ax
  80042174e9:	31 c0                	xor    %eax,%eax
	movw    %ax, %ds
  80042174eb:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  80042174ed:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  80042174ef:	8e d0                	mov    %eax,%ss
	
	
	lgdt    MPBOOTPHYS(gdt32desc)   // load 32 bit global descritor table
  80042174f1:	0f 01 16             	lgdt   (%rsi)
  80042174f4:	e0 70                	loopne 8004217566 <start64+0x10>
	movl    %cr0, %eax
  80042174f6:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  80042174f9:	66 83 c8 01          	or     $0x1,%ax
	movl    %eax, %cr0
  80042174fd:	0f 22 c0             	mov    %rax,%cr0
	ljmp	$(PROT_MODE_CSEG),$(MPBOOTPHYS(start32))
  8004217500:	ea                   	(bad)  
  8004217501:	1d                   	.byte 0x1d
  8004217502:	70 08                	jo     800421750c <start32+0x7>
	...

0000008004217505 <start32>:

.code32
start32:
	
	movw    $(PROT_MODE_DSEG), %ax
  8004217505:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004217509:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  800421750b:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  800421750d:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  800421750f:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004217513:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004217515:	8e e8                	mov    %eax,%gs

#ifndef VMM_GUEST
	movl $CR4_PAE,%eax
  8004217517:	b8 20 00 00 00       	mov    $0x20,%eax
#else
	movl $(CR4_PAE|CR4_VMXE),%eax
#endif

	movl %eax,%cr4
  800421751c:	0f 22 e0             	mov    %rax,%cr4
	
	lgdt    MPBOOTPHYS(gdtdesc)
  800421751f:	0f 01 15 c0 70 00 00 	lgdt   0x70c0(%rip)        # 800421e5e6 <handle_wrmsr+0x40>
	movl    %cr0, %eax
  8004217526:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004217529:	83 c8 01             	or     $0x1,%eax
	movl    %eax, %cr0
  800421752c:	0f 22 c0             	mov    %rax,%cr0
	
	# Set up initial page table. We cannot use kern_pgdir yet because
	# we are still running at a low EIP.
	movl    $pml4, %eax
  800421752f:	b8 00 20 10 00       	mov    $0x102000,%eax
	movl    %eax, %cr3
  8004217534:	0f 22 d8             	mov    %rax,%cr3
	
	# enable the long mode in MSR
	movl $EFER_MSR,%ecx
  8004217537:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
  800421753c:	0f 32                	rdmsr  
	btsl $EFER_LME,%eax
  800421753e:	0f ba e8 08          	bts    $0x8,%eax
	wrmsr
  8004217542:	0f 30                	wrmsr  
	
	# Turn on paging.
	movl    %cr0, %eax
  8004217544:	0f 20 c0             	mov    %cr0,%rax
	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
  8004217547:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl    %eax, %cr0
  800421754c:	0f 22 c0             	mov    %rax,%cr0
	

	ljmpl   $(LONG_MODE_CSEG), $(MPBOOTPHYS(start64))
  800421754f:	ea                   	(bad)  
  8004217550:	6e                   	outsb  %ds:(%rsi),(%dx)
  8004217551:	70 00                	jo     8004217553 <start32+0x4e>
  8004217553:	00 08                	add    %cl,(%rax)
	...

0000008004217556 <start64>:

.code64
start64:
	movw    $(LONG_MODE_DSEG), %ax
  8004217556:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  800421755a:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  800421755c:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  800421755e:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004217560:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004217564:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004217566:	8e e8                	mov    %eax,%gs

	# Switch to the per-cpu stack allocated in boot_aps()
	movabs    mpentry_kstack, %rax
  8004217568:	48 a1 e0 f5 6d 04 80 	movabs 0x80046df5e0,%rax
  800421756f:	00 00 00 
	movq    %rax,%rsp
  8004217572:	48 89 c4             	mov    %rax,%rsp
	movq    $0x0, %rbp       # nuke frame pointer
  8004217575:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movabs    $mp_main, %rax
  800421757c:	48 b8 0d 04 20 04 80 	movabs $0x800420040d,%rax
  8004217583:	00 00 00 
	call    *%rax
  8004217586:	ff d0                	callq  *%rax

0000008004217588 <spin>:

	# If mp_main returns (it shouldn't), loop.
spin:
	jmp     spin
  8004217588:	eb fe                	jmp    8004217588 <spin>
  800421758a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000008004217590 <gdt>:
	...
  8004217598:	ff                   	(bad)  
  8004217599:	ff 00                	incl   (%rax)
  800421759b:	00 00                	add    %al,(%rax)
  800421759d:	9a                   	(bad)  
  800421759e:	af                   	scas   %es:(%rdi),%eax
  800421759f:	00 ff                	add    %bh,%bh
  80042175a1:	ff 00                	incl   (%rax)
  80042175a3:	00 00                	add    %al,(%rax)
  80042175a5:	92                   	xchg   %eax,%edx
  80042175a6:	af                   	scas   %es:(%rdi),%eax
	...

00000080042175a8 <gdtdesc>:
  80042175a8:	17                   	(bad)  
  80042175a9:	00 a8 70 00 00 66    	add    %ch,0x66000070(%rax)
  80042175af:	90                   	nop

00000080042175b0 <gdt32>:
	...
  80042175b8:	ff                   	(bad)  
  80042175b9:	ff 00                	incl   (%rax)
  80042175bb:	00 00                	add    %al,(%rax)
  80042175bd:	9a                   	(bad)  
  80042175be:	cf                   	iret   
  80042175bf:	00 ff                	add    %bh,%bh
  80042175c1:	ff 00                	incl   (%rax)
  80042175c3:	00 00                	add    %al,(%rax)
  80042175c5:	92                   	xchg   %eax,%edx
  80042175c6:	cf                   	iret   
	...

00000080042175c8 <gdt32desc>:
  80042175c8:	17                   	(bad)  
  80042175c9:	00 c8                	add    %cl,%al
  80042175cb:	70 00                	jo     80042175cd <gdt32desc+0x5>
	...

00000080042175ce <mpentry_end>:
	.long   MPBOOTPHYS(gdt32)			# address gdt


.globl mpentry_end
mpentry_end:
	nop
  80042175ce:	90                   	nop

00000080042175cf <sum>:
#define MPIOINTR  0x03  // One per bus interrupt source
#define MPLINTR   0x04  // One per system interrupt source

static uint8_t
sum(void *addr, int len)
{
  80042175cf:	55                   	push   %rbp
  80042175d0:	48 89 e5             	mov    %rsp,%rbp
  80042175d3:	48 83 ec 20          	sub    $0x20,%rsp
  80042175d7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042175db:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int i, sum;

	sum = 0;
  80042175de:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < len; i++)
  80042175e5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042175ec:	eb 1a                	jmp    8004217608 <sum+0x39>
		sum += ((uint8_t *)addr)[i];
  80042175ee:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042175f1:	48 63 d0             	movslq %eax,%rdx
  80042175f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042175f8:	48 01 d0             	add    %rdx,%rax
  80042175fb:	0f b6 00             	movzbl (%rax),%eax
  80042175fe:	0f b6 c0             	movzbl %al,%eax
  8004217601:	01 45 f8             	add    %eax,-0x8(%rbp)
sum(void *addr, int len)
{
	int i, sum;

	sum = 0;
	for (i = 0; i < len; i++)
  8004217604:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004217608:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421760b:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  800421760e:	7c de                	jl     80042175ee <sum+0x1f>
		sum += ((uint8_t *)addr)[i];
	return sum;
  8004217610:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  8004217613:	c9                   	leaveq 
  8004217614:	c3                   	retq   

0000008004217615 <mpsearch1>:

// Look for an MP structure in the len bytes at physical address addr.
static struct mp *
mpsearch1(physaddr_t a, int len)
{
  8004217615:	55                   	push   %rbp
  8004217616:	48 89 e5             	mov    %rsp,%rbp
  8004217619:	48 83 ec 40          	sub    $0x40,%rsp
  800421761d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004217621:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	struct mp *mp = KADDR(a), *end = KADDR(a + len);
  8004217624:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004217628:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800421762c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004217630:	48 c1 e8 0c          	shr    $0xc,%rax
  8004217634:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004217637:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421763a:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004217641:	00 00 00 
  8004217644:	48 8b 00             	mov    (%rax),%rax
  8004217647:	48 39 c2             	cmp    %rax,%rdx
  800421764a:	72 32                	jb     800421767e <mpsearch1+0x69>
  800421764c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004217650:	48 89 c1             	mov    %rax,%rcx
  8004217653:	48 ba 10 1a 22 04 80 	movabs $0x8004221a10,%rdx
  800421765a:	00 00 00 
  800421765d:	be 5a 00 00 00       	mov    $0x5a,%esi
  8004217662:	48 bf 33 1a 22 04 80 	movabs $0x8004221a33,%rdi
  8004217669:	00 00 00 
  800421766c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217671:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004217678:	00 00 00 
  800421767b:	41 ff d0             	callq  *%r8
  800421767e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004217685:	00 00 00 
  8004217688:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421768c:	48 01 d0             	add    %rdx,%rax
  800421768f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004217693:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004217696:	48 63 d0             	movslq %eax,%rdx
  8004217699:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421769d:	48 01 d0             	add    %rdx,%rax
  80042176a0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042176a4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042176a8:	48 c1 e8 0c          	shr    $0xc,%rax
  80042176ac:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042176af:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042176b2:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  80042176b9:	00 00 00 
  80042176bc:	48 8b 00             	mov    (%rax),%rax
  80042176bf:	48 39 c2             	cmp    %rax,%rdx
  80042176c2:	72 32                	jb     80042176f6 <mpsearch1+0xe1>
  80042176c4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042176c8:	48 89 c1             	mov    %rax,%rcx
  80042176cb:	48 ba 10 1a 22 04 80 	movabs $0x8004221a10,%rdx
  80042176d2:	00 00 00 
  80042176d5:	be 5a 00 00 00       	mov    $0x5a,%esi
  80042176da:	48 bf 33 1a 22 04 80 	movabs $0x8004221a33,%rdi
  80042176e1:	00 00 00 
  80042176e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042176e9:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042176f0:	00 00 00 
  80042176f3:	41 ff d0             	callq  *%r8
  80042176f6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042176fd:	00 00 00 
  8004217700:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217704:	48 01 d0             	add    %rdx,%rax
  8004217707:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	for (; mp < end; mp++)
  800421770b:	eb 4d                	jmp    800421775a <mpsearch1+0x145>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  800421770d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217711:	ba 04 00 00 00       	mov    $0x4,%edx
  8004217716:	48 be 43 1a 22 04 80 	movabs $0x8004221a43,%rsi
  800421771d:	00 00 00 
  8004217720:	48 89 c7             	mov    %rax,%rdi
  8004217723:	48 b8 8f 13 21 04 80 	movabs $0x800421138f,%rax
  800421772a:	00 00 00 
  800421772d:	ff d0                	callq  *%rax
  800421772f:	85 c0                	test   %eax,%eax
  8004217731:	75 22                	jne    8004217755 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
  8004217733:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217737:	be 10 00 00 00       	mov    $0x10,%esi
  800421773c:	48 89 c7             	mov    %rax,%rdi
  800421773f:	48 b8 cf 75 21 04 80 	movabs $0x80042175cf,%rax
  8004217746:	00 00 00 
  8004217749:	ff d0                	callq  *%rax
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  800421774b:	84 c0                	test   %al,%al
  800421774d:	75 06                	jne    8004217755 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
  800421774f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217753:	eb 14                	jmp    8004217769 <mpsearch1+0x154>
static struct mp *
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
  8004217755:	48 83 45 f8 10       	addq   $0x10,-0x8(%rbp)
  800421775a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421775e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004217762:	72 a9                	jb     800421770d <mpsearch1+0xf8>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
	return NULL;
  8004217764:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004217769:	c9                   	leaveq 
  800421776a:	c3                   	retq   

000000800421776b <mpsearch>:
// 1) in the first KB of the EBDA;
// 2) if there is no EBDA, in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp *
mpsearch(void)
{
  800421776b:	55                   	push   %rbp
  800421776c:	48 89 e5             	mov    %rsp,%rbp
  800421776f:	48 83 ec 30          	sub    $0x30,%rsp
	struct mp *mp;

	//static_assert(sizeof(*mp) == 32);

	// The BIOS data area lives in 16-bit segment 0x40.
	bda = (uint8_t *) KADDR(0x40 << 4);
  8004217773:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  800421777a:	00 
  800421777b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421777f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004217783:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004217786:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004217789:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004217790:	00 00 00 
  8004217793:	48 8b 00             	mov    (%rax),%rax
  8004217796:	48 39 c2             	cmp    %rax,%rdx
  8004217799:	72 32                	jb     80042177cd <mpsearch+0x62>
  800421779b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421779f:	48 89 c1             	mov    %rax,%rcx
  80042177a2:	48 ba 10 1a 22 04 80 	movabs $0x8004221a10,%rdx
  80042177a9:	00 00 00 
  80042177ac:	be 72 00 00 00       	mov    $0x72,%esi
  80042177b1:	48 bf 33 1a 22 04 80 	movabs $0x8004221a33,%rdi
  80042177b8:	00 00 00 
  80042177bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042177c0:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042177c7:	00 00 00 
  80042177ca:	41 ff d0             	callq  *%r8
  80042177cd:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042177d4:	00 00 00 
  80042177d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042177db:	48 01 d0             	add    %rdx,%rax
  80042177de:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// [MP 4] The 16-bit segment of the EBDA is in the two bytes
	// starting at byte 0x0E of the BDA.  0 if not present.
	if ((p = *(uint16_t *) (bda + 0x0E))) {
  80042177e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042177e6:	48 83 c0 0e          	add    $0xe,%rax
  80042177ea:	0f b7 00             	movzwl (%rax),%eax
  80042177ed:	0f b7 c0             	movzwl %ax,%eax
  80042177f0:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  80042177f3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042177f7:	74 2c                	je     8004217825 <mpsearch+0xba>
		p <<= 4;	// Translate from segment to PA
  80042177f9:	c1 65 e4 04          	shll   $0x4,-0x1c(%rbp)
		if ((mp = mpsearch1(p, 1024)))
  80042177fd:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004217800:	be 00 04 00 00       	mov    $0x400,%esi
  8004217805:	48 89 c7             	mov    %rax,%rdi
  8004217808:	48 b8 15 76 21 04 80 	movabs $0x8004217615,%rax
  800421780f:	00 00 00 
  8004217812:	ff d0                	callq  *%rax
  8004217814:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004217818:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421781d:	74 49                	je     8004217868 <mpsearch+0xfd>
			return mp;
  800421781f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217823:	eb 59                	jmp    800421787e <mpsearch+0x113>
	} else {
		// The size of base memory, in KB is in the two bytes
		// starting at 0x13 of the BDA.
		p = *(uint16_t *) (bda + 0x13) * 1024;
  8004217825:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217829:	48 83 c0 13          	add    $0x13,%rax
  800421782d:	0f b7 00             	movzwl (%rax),%eax
  8004217830:	0f b7 c0             	movzwl %ax,%eax
  8004217833:	c1 e0 0a             	shl    $0xa,%eax
  8004217836:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if ((mp = mpsearch1(p - 1024, 1024)))
  8004217839:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421783c:	2d 00 04 00 00       	sub    $0x400,%eax
  8004217841:	89 c0                	mov    %eax,%eax
  8004217843:	be 00 04 00 00       	mov    $0x400,%esi
  8004217848:	48 89 c7             	mov    %rax,%rdi
  800421784b:	48 b8 15 76 21 04 80 	movabs $0x8004217615,%rax
  8004217852:	00 00 00 
  8004217855:	ff d0                	callq  *%rax
  8004217857:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800421785b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004217860:	74 06                	je     8004217868 <mpsearch+0xfd>
			return mp;
  8004217862:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217866:	eb 16                	jmp    800421787e <mpsearch+0x113>
	}
	return mpsearch1(0xF0000, 0x10000);
  8004217868:	be 00 00 01 00       	mov    $0x10000,%esi
  800421786d:	bf 00 00 0f 00       	mov    $0xf0000,%edi
  8004217872:	48 b8 15 76 21 04 80 	movabs $0x8004217615,%rax
  8004217879:	00 00 00 
  800421787c:	ff d0                	callq  *%rax
}
  800421787e:	c9                   	leaveq 
  800421787f:	c3                   	retq   

0000008004217880 <mpconfig>:
// Search for an MP configuration table.  For now, don't accept the
// default configurations (physaddr == 0).
// Check for the correct signature, checksum, and version.
static struct mpconf *
mpconfig(struct mp **pmp)
{
  8004217880:	55                   	push   %rbp
  8004217881:	48 89 e5             	mov    %rsp,%rbp
  8004217884:	48 83 ec 30          	sub    $0x30,%rsp
  8004217888:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	struct mpconf *conf;
	struct mp *mp;

	if ((mp = mpsearch()) == 0)
  800421788c:	48 b8 6b 77 21 04 80 	movabs $0x800421776b,%rax
  8004217893:	00 00 00 
  8004217896:	ff d0                	callq  *%rax
  8004217898:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421789c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042178a1:	75 0a                	jne    80042178ad <mpconfig+0x2d>
		return NULL;
  80042178a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042178a8:	e9 f8 01 00 00       	jmpq   8004217aa5 <mpconfig+0x225>
	if (mp->physaddr == 0 || mp->type != 0) {
  80042178ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042178b1:	8b 40 04             	mov    0x4(%rax),%eax
  80042178b4:	85 c0                	test   %eax,%eax
  80042178b6:	74 0c                	je     80042178c4 <mpconfig+0x44>
  80042178b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042178bc:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  80042178c0:	84 c0                	test   %al,%al
  80042178c2:	74 25                	je     80042178e9 <mpconfig+0x69>
		cprintf("SMP: Default configurations not implemented\n");
  80042178c4:	48 bf 48 1a 22 04 80 	movabs $0x8004221a48,%rdi
  80042178cb:	00 00 00 
  80042178ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80042178d3:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  80042178da:	00 00 00 
  80042178dd:	ff d2                	callq  *%rdx
		return NULL;
  80042178df:	b8 00 00 00 00       	mov    $0x0,%eax
  80042178e4:	e9 bc 01 00 00       	jmpq   8004217aa5 <mpconfig+0x225>
	}
	conf = (struct mpconf *) KADDR(mp->physaddr);
  80042178e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042178ed:	8b 40 04             	mov    0x4(%rax),%eax
  80042178f0:	89 c0                	mov    %eax,%eax
  80042178f2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042178f6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042178fa:	48 c1 e8 0c          	shr    $0xc,%rax
  80042178fe:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004217901:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004217904:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  800421790b:	00 00 00 
  800421790e:	48 8b 00             	mov    (%rax),%rax
  8004217911:	48 39 c2             	cmp    %rax,%rdx
  8004217914:	72 32                	jb     8004217948 <mpconfig+0xc8>
  8004217916:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421791a:	48 89 c1             	mov    %rax,%rcx
  800421791d:	48 ba 10 1a 22 04 80 	movabs $0x8004221a10,%rdx
  8004217924:	00 00 00 
  8004217927:	be 93 00 00 00       	mov    $0x93,%esi
  800421792c:	48 bf 33 1a 22 04 80 	movabs $0x8004221a33,%rdi
  8004217933:	00 00 00 
  8004217936:	b8 00 00 00 00       	mov    $0x0,%eax
  800421793b:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004217942:	00 00 00 
  8004217945:	41 ff d0             	callq  *%r8
  8004217948:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421794f:	00 00 00 
  8004217952:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004217956:	48 01 d0             	add    %rdx,%rax
  8004217959:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (memcmp(conf, "PCMP", 4) != 0) {
  800421795d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217961:	ba 04 00 00 00       	mov    $0x4,%edx
  8004217966:	48 be 75 1a 22 04 80 	movabs $0x8004221a75,%rsi
  800421796d:	00 00 00 
  8004217970:	48 89 c7             	mov    %rax,%rdi
  8004217973:	48 b8 8f 13 21 04 80 	movabs $0x800421138f,%rax
  800421797a:	00 00 00 
  800421797d:	ff d0                	callq  *%rax
  800421797f:	85 c0                	test   %eax,%eax
  8004217981:	74 25                	je     80042179a8 <mpconfig+0x128>
		cprintf("SMP: Incorrect MP configuration table signature\n");
  8004217983:	48 bf 80 1a 22 04 80 	movabs $0x8004221a80,%rdi
  800421798a:	00 00 00 
  800421798d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217992:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004217999:	00 00 00 
  800421799c:	ff d2                	callq  *%rdx
		return NULL;
  800421799e:	b8 00 00 00 00       	mov    $0x0,%eax
  80042179a3:	e9 fd 00 00 00       	jmpq   8004217aa5 <mpconfig+0x225>
	}
	if (sum(conf, conf->length) != 0) {
  80042179a8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042179ac:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  80042179b0:	0f b7 d0             	movzwl %ax,%edx
  80042179b3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042179b7:	89 d6                	mov    %edx,%esi
  80042179b9:	48 89 c7             	mov    %rax,%rdi
  80042179bc:	48 b8 cf 75 21 04 80 	movabs $0x80042175cf,%rax
  80042179c3:	00 00 00 
  80042179c6:	ff d0                	callq  *%rax
  80042179c8:	84 c0                	test   %al,%al
  80042179ca:	74 25                	je     80042179f1 <mpconfig+0x171>
		cprintf("SMP: Bad MP configuration checksum\n");
  80042179cc:	48 bf b8 1a 22 04 80 	movabs $0x8004221ab8,%rdi
  80042179d3:	00 00 00 
  80042179d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042179db:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  80042179e2:	00 00 00 
  80042179e5:	ff d2                	callq  *%rdx
		return NULL;
  80042179e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042179ec:	e9 b4 00 00 00       	jmpq   8004217aa5 <mpconfig+0x225>
	}
	if (conf->version != 1 && conf->version != 4) {
  80042179f1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042179f5:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042179f9:	3c 01                	cmp    $0x1,%al
  80042179fb:	74 3b                	je     8004217a38 <mpconfig+0x1b8>
  80042179fd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217a01:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004217a05:	3c 04                	cmp    $0x4,%al
  8004217a07:	74 2f                	je     8004217a38 <mpconfig+0x1b8>
		cprintf("SMP: Unsupported MP version %d\n", conf->version);
  8004217a09:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217a0d:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004217a11:	0f b6 c0             	movzbl %al,%eax
  8004217a14:	89 c6                	mov    %eax,%esi
  8004217a16:	48 bf e0 1a 22 04 80 	movabs $0x8004221ae0,%rdi
  8004217a1d:	00 00 00 
  8004217a20:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217a25:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004217a2c:	00 00 00 
  8004217a2f:	ff d2                	callq  *%rdx
		return NULL;
  8004217a31:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217a36:	eb 6d                	jmp    8004217aa5 <mpconfig+0x225>
	}
	if (sum((uint8_t *)conf + conf->length, conf->xlength) != conf->xchecksum) {
  8004217a38:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217a3c:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  8004217a40:	0f b7 c0             	movzwl %ax,%eax
  8004217a43:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004217a47:	0f b7 52 04          	movzwl 0x4(%rdx),%edx
  8004217a4b:	0f b7 ca             	movzwl %dx,%ecx
  8004217a4e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004217a52:	48 01 ca             	add    %rcx,%rdx
  8004217a55:	89 c6                	mov    %eax,%esi
  8004217a57:	48 89 d7             	mov    %rdx,%rdi
  8004217a5a:	48 b8 cf 75 21 04 80 	movabs $0x80042175cf,%rax
  8004217a61:	00 00 00 
  8004217a64:	ff d0                	callq  *%rax
  8004217a66:	89 c2                	mov    %eax,%edx
  8004217a68:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217a6c:	0f b6 40 2a          	movzbl 0x2a(%rax),%eax
  8004217a70:	38 c2                	cmp    %al,%dl
  8004217a72:	74 22                	je     8004217a96 <mpconfig+0x216>
		cprintf("SMP: Bad MP configuration extended checksum\n");
  8004217a74:	48 bf 00 1b 22 04 80 	movabs $0x8004221b00,%rdi
  8004217a7b:	00 00 00 
  8004217a7e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217a83:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004217a8a:	00 00 00 
  8004217a8d:	ff d2                	callq  *%rdx
		return NULL;
  8004217a8f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217a94:	eb 0f                	jmp    8004217aa5 <mpconfig+0x225>
	}
	*pmp = mp;
  8004217a96:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217a9a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004217a9e:	48 89 10             	mov    %rdx,(%rax)
	return conf;
  8004217aa1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  8004217aa5:	c9                   	leaveq 
  8004217aa6:	c3                   	retq   

0000008004217aa7 <mp_init>:

void
mp_init(void)
{
  8004217aa7:	55                   	push   %rbp
  8004217aa8:	48 89 e5             	mov    %rsp,%rbp
  8004217aab:	48 83 ec 40          	sub    $0x40,%rsp
	struct mpconf *conf;
	struct mpproc *proc;
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
  8004217aaf:	48 b8 40 12 6e 04 80 	movabs $0x80046e1240,%rax
  8004217ab6:	00 00 00 
  8004217ab9:	48 be 20 10 6e 04 80 	movabs $0x80046e1020,%rsi
  8004217ac0:	00 00 00 
  8004217ac3:	48 89 30             	mov    %rsi,(%rax)
	if ((conf = mpconfig(&mp)) == 0)
  8004217ac6:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  8004217aca:	48 89 c7             	mov    %rax,%rdi
  8004217acd:	48 b8 80 78 21 04 80 	movabs $0x8004217880,%rax
  8004217ad4:	00 00 00 
  8004217ad7:	ff d0                	callq  *%rax
  8004217ad9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004217add:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004217ae2:	0f 84 d3 03 00 00    	je     8004217ebb <mp_init+0x414>
		return;
	ismp = 1;
  8004217ae8:	48 b8 00 10 6e 04 80 	movabs $0x80046e1000,%rax
  8004217aef:	00 00 00 
  8004217af2:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	lapicaddr = conf->lapicaddr;
  8004217af8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217afc:	8b 40 24             	mov    0x24(%rax),%eax
  8004217aff:	89 c2                	mov    %eax,%edx
  8004217b01:	48 b8 00 20 72 04 80 	movabs $0x8004722000,%rax
  8004217b08:	00 00 00 
  8004217b0b:	48 89 10             	mov    %rdx,(%rax)

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  8004217b0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217b12:	48 83 c0 2c          	add    $0x2c,%rax
  8004217b16:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004217b1a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004217b21:	e9 17 02 00 00       	jmpq   8004217d3d <mp_init+0x296>
		switch (*p) {
  8004217b26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217b2a:	0f b6 00             	movzbl (%rax),%eax
  8004217b2d:	0f b6 c0             	movzbl %al,%eax
  8004217b30:	85 c0                	test   %eax,%eax
  8004217b32:	74 16                	je     8004217b4a <mp_init+0xa3>
  8004217b34:	85 c0                	test   %eax,%eax
  8004217b36:	0f 88 b8 01 00 00    	js     8004217cf4 <mp_init+0x24d>
  8004217b3c:	83 f8 04             	cmp    $0x4,%eax
  8004217b3f:	0f 8f af 01 00 00    	jg     8004217cf4 <mp_init+0x24d>
  8004217b45:	e9 a3 01 00 00       	jmpq   8004217ced <mp_init+0x246>
		case MPPROC:
			proc = (struct mpproc *)p;
  8004217b4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217b4e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
			if (proc->flags & MPPROC_BOOT) {
  8004217b52:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217b56:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  8004217b5a:	0f b6 c0             	movzbl %al,%eax
  8004217b5d:	83 e0 02             	and    $0x2,%eax
  8004217b60:	85 c0                	test   %eax,%eax
  8004217b62:	74 51                	je     8004217bb5 <mp_init+0x10e>
				bootcpu = &cpus[ncpu];
  8004217b64:	48 b8 48 12 6e 04 80 	movabs $0x80046e1248,%rax
  8004217b6b:	00 00 00 
  8004217b6e:	8b 00                	mov    (%rax),%eax
  8004217b70:	48 98                	cltq   
  8004217b72:	48 c1 e0 03          	shl    $0x3,%rax
  8004217b76:	48 89 c2             	mov    %rax,%rdx
  8004217b79:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217b7d:	48 01 d0             	add    %rdx,%rax
  8004217b80:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  8004217b87:	00 00 00 
  8004217b8a:	48 01 c2             	add    %rax,%rdx
  8004217b8d:	48 b8 40 12 6e 04 80 	movabs $0x80046e1240,%rax
  8004217b94:	00 00 00 
  8004217b97:	48 89 10             	mov    %rdx,(%rax)
				cprintf("Found boot cpu..\n");
  8004217b9a:	48 bf 2d 1b 22 04 80 	movabs $0x8004221b2d,%rdi
  8004217ba1:	00 00 00 
  8004217ba4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217ba9:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004217bb0:	00 00 00 
  8004217bb3:	ff d2                	callq  *%rdx
			}
			if (ncpu < NCPU) {
  8004217bb5:	48 b8 48 12 6e 04 80 	movabs $0x80046e1248,%rax
  8004217bbc:	00 00 00 
  8004217bbf:	8b 00                	mov    (%rax),%eax
  8004217bc1:	83 f8 03             	cmp    $0x3,%eax
  8004217bc4:	0f 8f f4 00 00 00    	jg     8004217cbe <mp_init+0x217>
				cprintf("type: %d apicid:%d version:%d signature:%x feature:%x flags:%x reserved:%x\n", proc->type, proc->apicid, proc->version, proc->signature, proc->feature, proc->flags, proc->reserved);
  8004217bca:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217bce:	4c 8d 40 0c          	lea    0xc(%rax),%r8
  8004217bd2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217bd6:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  8004217bda:	0f b6 f0             	movzbl %al,%esi
  8004217bdd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217be1:	8b 78 08             	mov    0x8(%rax),%edi
  8004217be4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217be8:	4c 8d 50 04          	lea    0x4(%rax),%r10
  8004217bec:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217bf0:	0f b6 40 02          	movzbl 0x2(%rax),%eax
  8004217bf4:	0f b6 c8             	movzbl %al,%ecx
  8004217bf7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217bfb:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8004217bff:	0f b6 d0             	movzbl %al,%edx
  8004217c02:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217c06:	0f b6 00             	movzbl (%rax),%eax
  8004217c09:	0f b6 c0             	movzbl %al,%eax
  8004217c0c:	41 50                	push   %r8
  8004217c0e:	56                   	push   %rsi
  8004217c0f:	41 89 f9             	mov    %edi,%r9d
  8004217c12:	4d 89 d0             	mov    %r10,%r8
  8004217c15:	89 c6                	mov    %eax,%esi
  8004217c17:	48 bf 40 1b 22 04 80 	movabs $0x8004221b40,%rdi
  8004217c1e:	00 00 00 
  8004217c21:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217c26:	49 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%r10
  8004217c2d:	00 00 00 
  8004217c30:	41 ff d2             	callq  *%r10
  8004217c33:	48 83 c4 10          	add    $0x10,%rsp
				if (proc->flags & MPROC_EN) {
  8004217c37:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217c3b:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  8004217c3f:	0f b6 c0             	movzbl %al,%eax
  8004217c42:	83 e0 01             	and    $0x1,%eax
  8004217c45:	85 c0                	test   %eax,%eax
  8004217c47:	74 58                	je     8004217ca1 <mp_init+0x1fa>
					cpus[ncpu].cpu_id = ncpu;
  8004217c49:	48 b8 48 12 6e 04 80 	movabs $0x80046e1248,%rax
  8004217c50:	00 00 00 
  8004217c53:	8b 08                	mov    (%rax),%ecx
  8004217c55:	48 b8 48 12 6e 04 80 	movabs $0x80046e1248,%rax
  8004217c5c:	00 00 00 
  8004217c5f:	8b 00                	mov    (%rax),%eax
  8004217c61:	89 c6                	mov    %eax,%esi
  8004217c63:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  8004217c6a:	00 00 00 
  8004217c6d:	48 63 c1             	movslq %ecx,%rax
  8004217c70:	48 c1 e0 03          	shl    $0x3,%rax
  8004217c74:	48 89 c1             	mov    %rax,%rcx
  8004217c77:	48 c1 e1 04          	shl    $0x4,%rcx
  8004217c7b:	48 01 c8             	add    %rcx,%rax
  8004217c7e:	48 01 d0             	add    %rdx,%rax
  8004217c81:	40 88 30             	mov    %sil,(%rax)
					ncpu++;
  8004217c84:	48 b8 48 12 6e 04 80 	movabs $0x80046e1248,%rax
  8004217c8b:	00 00 00 
  8004217c8e:	8b 00                	mov    (%rax),%eax
  8004217c90:	8d 50 01             	lea    0x1(%rax),%edx
  8004217c93:	48 b8 48 12 6e 04 80 	movabs $0x80046e1248,%rax
  8004217c9a:	00 00 00 
  8004217c9d:	89 10                	mov    %edx,(%rax)
  8004217c9f:	eb 45                	jmp    8004217ce6 <mp_init+0x23f>
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
  8004217ca1:	48 bf 90 1b 22 04 80 	movabs $0x8004221b90,%rdi
  8004217ca8:	00 00 00 
  8004217cab:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217cb0:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004217cb7:	00 00 00 
  8004217cba:	ff d2                	callq  *%rdx
  8004217cbc:	eb 28                	jmp    8004217ce6 <mp_init+0x23f>
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
					proc->apicid);
  8004217cbe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217cc2:	0f b6 40 01          	movzbl 0x1(%rax),%eax
					ncpu++;
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
  8004217cc6:	0f b6 c0             	movzbl %al,%eax
  8004217cc9:	89 c6                	mov    %eax,%esi
  8004217ccb:	48 bf c0 1b 22 04 80 	movabs $0x8004221bc0,%rdi
  8004217cd2:	00 00 00 
  8004217cd5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217cda:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004217ce1:	00 00 00 
  8004217ce4:	ff d2                	callq  *%rdx
					proc->apicid);
			}
			p += sizeof(struct mpproc);
  8004217ce6:	48 83 45 f8 14       	addq   $0x14,-0x8(%rbp)
			continue;
  8004217ceb:	eb 4c                	jmp    8004217d39 <mp_init+0x292>
		case MPBUS:
		case MPIOAPIC:
		case MPIOINTR:
		case MPLINTR:

		p += 8;
  8004217ced:	48 83 45 f8 08       	addq   $0x8,-0x8(%rbp)
		continue;
  8004217cf2:	eb 45                	jmp    8004217d39 <mp_init+0x292>
		default:
			cprintf("mpinit: unknown config type %x\n", *p);
  8004217cf4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217cf8:	0f b6 00             	movzbl (%rax),%eax
  8004217cfb:	0f b6 c0             	movzbl %al,%eax
  8004217cfe:	89 c6                	mov    %eax,%esi
  8004217d00:	48 bf e8 1b 22 04 80 	movabs $0x8004221be8,%rdi
  8004217d07:	00 00 00 
  8004217d0a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217d0f:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004217d16:	00 00 00 
  8004217d19:	ff d2                	callq  *%rdx
			ismp = 0;
  8004217d1b:	48 b8 00 10 6e 04 80 	movabs $0x80046e1000,%rax
  8004217d22:	00 00 00 
  8004217d25:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
			i = conf->entry;
  8004217d2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217d2f:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004217d33:	0f b7 c0             	movzwl %ax,%eax
  8004217d36:	89 45 f4             	mov    %eax,-0xc(%rbp)
	if ((conf = mpconfig(&mp)) == 0)
		return;
	ismp = 1;
	lapicaddr = conf->lapicaddr;

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  8004217d39:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004217d3d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217d41:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004217d45:	0f b7 c0             	movzwl %ax,%eax
  8004217d48:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8004217d4b:	0f 87 d5 fd ff ff    	ja     8004217b26 <mp_init+0x7f>
			i = conf->entry;
		}
	}


	for (i=0; i< NCPU; ++i) {
  8004217d51:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004217d58:	eb 52                	jmp    8004217dac <mp_init+0x305>
		cpus[i].is_vmx_root = false;
  8004217d5a:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  8004217d61:	00 00 00 
  8004217d64:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004217d67:	48 c1 e0 03          	shl    $0x3,%rax
  8004217d6b:	48 89 c1             	mov    %rax,%rcx
  8004217d6e:	48 c1 e1 04          	shl    $0x4,%rcx
  8004217d72:	48 01 c8             	add    %rcx,%rax
  8004217d75:	48 01 d0             	add    %rdx,%rax
  8004217d78:	48 83 c0 78          	add    $0x78,%rax
  8004217d7c:	c6 00 00             	movb   $0x0,(%rax)
		cpus[i].vmxon_region = 0;
  8004217d7f:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  8004217d86:	00 00 00 
  8004217d89:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004217d8c:	48 c1 e0 03          	shl    $0x3,%rax
  8004217d90:	48 89 c1             	mov    %rax,%rcx
  8004217d93:	48 c1 e1 04          	shl    $0x4,%rcx
  8004217d97:	48 01 c8             	add    %rcx,%rax
  8004217d9a:	48 01 d0             	add    %rdx,%rax
  8004217d9d:	48 83 e8 80          	sub    $0xffffffffffffff80,%rax
  8004217da1:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			i = conf->entry;
		}
	}


	for (i=0; i< NCPU; ++i) {
  8004217da8:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004217dac:	83 7d f4 03          	cmpl   $0x3,-0xc(%rbp)
  8004217db0:	76 a8                	jbe    8004217d5a <mp_init+0x2b3>
		cpus[i].is_vmx_root = false;
		cpus[i].vmxon_region = 0;
	}


	bootcpu->cpu_status = CPU_STARTED;
  8004217db2:	48 b8 40 12 6e 04 80 	movabs $0x80046e1240,%rax
  8004217db9:	00 00 00 
  8004217dbc:	48 8b 00             	mov    (%rax),%rax
  8004217dbf:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
	if (!ismp) {
  8004217dc6:	48 b8 00 10 6e 04 80 	movabs $0x80046e1000,%rax
  8004217dcd:	00 00 00 
  8004217dd0:	8b 00                	mov    (%rax),%eax
  8004217dd2:	85 c0                	test   %eax,%eax
  8004217dd4:	75 41                	jne    8004217e17 <mp_init+0x370>
		// Didn't like what we found; fall back to no MP.
		ncpu = 1;
  8004217dd6:	48 b8 48 12 6e 04 80 	movabs $0x80046e1248,%rax
  8004217ddd:	00 00 00 
  8004217de0:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
		lapicaddr = 0;
  8004217de6:	48 b8 00 20 72 04 80 	movabs $0x8004722000,%rax
  8004217ded:	00 00 00 
  8004217df0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		cprintf("SMP: configuration not found, SMP disabled\n");
  8004217df7:	48 bf 08 1c 22 04 80 	movabs $0x8004221c08,%rdi
  8004217dfe:	00 00 00 
  8004217e01:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217e06:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004217e0d:	00 00 00 
  8004217e10:	ff d2                	callq  *%rdx
		return;
  8004217e12:	e9 a5 00 00 00       	jmpq   8004217ebc <mp_init+0x415>
	}
	cprintf("SMP: CPU %d found %d CPU(s)\n", bootcpu->cpu_id,  ncpu);
  8004217e17:	48 b8 48 12 6e 04 80 	movabs $0x80046e1248,%rax
  8004217e1e:	00 00 00 
  8004217e21:	8b 10                	mov    (%rax),%edx
  8004217e23:	48 b8 40 12 6e 04 80 	movabs $0x80046e1240,%rax
  8004217e2a:	00 00 00 
  8004217e2d:	48 8b 00             	mov    (%rax),%rax
  8004217e30:	0f b6 00             	movzbl (%rax),%eax
  8004217e33:	0f b6 c0             	movzbl %al,%eax
  8004217e36:	89 c6                	mov    %eax,%esi
  8004217e38:	48 bf 34 1c 22 04 80 	movabs $0x8004221c34,%rdi
  8004217e3f:	00 00 00 
  8004217e42:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217e47:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  8004217e4e:	00 00 00 
  8004217e51:	ff d1                	callq  *%rcx

	if (mp->imcrp) {
  8004217e53:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004217e57:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  8004217e5b:	84 c0                	test   %al,%al
  8004217e5d:	74 5d                	je     8004217ebc <mp_init+0x415>
		// [MP 3.2.6.1] If the hardware implements PIC mode,
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
  8004217e5f:	48 bf 58 1c 22 04 80 	movabs $0x8004221c58,%rdi
  8004217e66:	00 00 00 
  8004217e69:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217e6e:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004217e75:	00 00 00 
  8004217e78:	ff d2                	callq  *%rdx
  8004217e7a:	c7 45 dc 22 00 00 00 	movl   $0x22,-0x24(%rbp)
  8004217e81:	c6 45 d1 70          	movb   $0x70,-0x2f(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004217e85:	0f b6 45 d1          	movzbl -0x2f(%rbp),%eax
  8004217e89:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004217e8c:	ee                   	out    %al,(%dx)
  8004217e8d:	c7 45 d8 23 00 00 00 	movl   $0x23,-0x28(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004217e94:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8004217e97:	89 c2                	mov    %eax,%edx
  8004217e99:	ec                   	in     (%dx),%al
  8004217e9a:	88 45 d2             	mov    %al,-0x2e(%rbp)
	return data;
  8004217e9d:	0f b6 45 d2          	movzbl -0x2e(%rbp),%eax
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  8004217ea1:	83 c8 01             	or     $0x1,%eax
  8004217ea4:	0f b6 c0             	movzbl %al,%eax
  8004217ea7:	c7 45 d4 23 00 00 00 	movl   $0x23,-0x2c(%rbp)
  8004217eae:	88 45 d3             	mov    %al,-0x2d(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004217eb1:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004217eb5:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004217eb8:	ee                   	out    %al,(%dx)
  8004217eb9:	eb 01                	jmp    8004217ebc <mp_init+0x415>
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
	if ((conf = mpconfig(&mp)) == 0)
		return;
  8004217ebb:	90                   	nop
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
	}
}
  8004217ebc:	c9                   	leaveq 
  8004217ebd:	c3                   	retq   

0000008004217ebe <lapicw>:
physaddr_t lapicaddr;        // Initialized in mpconfig.c
volatile uint32_t *lapic;

static void
lapicw(int index, int value)
{
  8004217ebe:	55                   	push   %rbp
  8004217ebf:	48 89 e5             	mov    %rsp,%rbp
  8004217ec2:	48 83 ec 08          	sub    $0x8,%rsp
  8004217ec6:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004217ec9:	89 75 f8             	mov    %esi,-0x8(%rbp)
	lapic[index] = value;
  8004217ecc:	48 b8 08 20 72 04 80 	movabs $0x8004722008,%rax
  8004217ed3:	00 00 00 
  8004217ed6:	48 8b 00             	mov    (%rax),%rax
  8004217ed9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004217edc:	48 63 d2             	movslq %edx,%rdx
  8004217edf:	48 c1 e2 02          	shl    $0x2,%rdx
  8004217ee3:	48 01 c2             	add    %rax,%rdx
  8004217ee6:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004217ee9:	89 02                	mov    %eax,(%rdx)
	lapic[ID];  // wait for write to finish, by reading
  8004217eeb:	48 b8 08 20 72 04 80 	movabs $0x8004722008,%rax
  8004217ef2:	00 00 00 
  8004217ef5:	48 8b 00             	mov    (%rax),%rax
  8004217ef8:	48 83 c0 20          	add    $0x20,%rax
  8004217efc:	8b 00                	mov    (%rax),%eax
}
  8004217efe:	90                   	nop
  8004217eff:	c9                   	leaveq 
  8004217f00:	c3                   	retq   

0000008004217f01 <lapic_init>:

void
lapic_init(void)
{
  8004217f01:	55                   	push   %rbp
  8004217f02:	48 89 e5             	mov    %rsp,%rbp
	if (!lapicaddr)
  8004217f05:	48 b8 00 20 72 04 80 	movabs $0x8004722000,%rax
  8004217f0c:	00 00 00 
  8004217f0f:	48 8b 00             	mov    (%rax),%rax
  8004217f12:	48 85 c0             	test   %rax,%rax
  8004217f15:	0f 84 df 01 00 00    	je     80042180fa <lapic_init+0x1f9>
		return;

	// lapicaddr is the physical address of the LAPIC's 4K MMIO
	// region.  Map it in to virtual memory so we can access it.
	lapic = mmio_map_region(lapicaddr, 4096);
  8004217f1b:	48 b8 00 20 72 04 80 	movabs $0x8004722000,%rax
  8004217f22:	00 00 00 
  8004217f25:	48 8b 00             	mov    (%rax),%rax
  8004217f28:	be 00 10 00 00       	mov    $0x1000,%esi
  8004217f2d:	48 89 c7             	mov    %rax,%rdi
  8004217f30:	48 b8 76 3f 20 04 80 	movabs $0x8004203f76,%rax
  8004217f37:	00 00 00 
  8004217f3a:	ff d0                	callq  *%rax
  8004217f3c:	48 89 c2             	mov    %rax,%rdx
  8004217f3f:	48 b8 08 20 72 04 80 	movabs $0x8004722008,%rax
  8004217f46:	00 00 00 
  8004217f49:	48 89 10             	mov    %rdx,(%rax)

	// Enable local APIC; set spurious interrupt vector.
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));
  8004217f4c:	be 27 01 00 00       	mov    $0x127,%esi
  8004217f51:	bf 3c 00 00 00       	mov    $0x3c,%edi
  8004217f56:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  8004217f5d:	00 00 00 
  8004217f60:	ff d0                	callq  *%rax

	// The timer repeatedly counts down at bus frequency
	// from lapic[TICR] and then issues an interrupt.  
	// If we cared more about precise timekeeping,
	// TICR would be calibrated using an external time source.
	lapicw(TDCR, X1);
  8004217f62:	be 0b 00 00 00       	mov    $0xb,%esi
  8004217f67:	bf f8 00 00 00       	mov    $0xf8,%edi
  8004217f6c:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  8004217f73:	00 00 00 
  8004217f76:	ff d0                	callq  *%rax
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
  8004217f78:	be 20 00 02 00       	mov    $0x20020,%esi
  8004217f7d:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004217f82:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  8004217f89:	00 00 00 
  8004217f8c:	ff d0                	callq  *%rax
	lapicw(TICR, 10000000); 
  8004217f8e:	be 80 96 98 00       	mov    $0x989680,%esi
  8004217f93:	bf e0 00 00 00       	mov    $0xe0,%edi
  8004217f98:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  8004217f9f:	00 00 00 
  8004217fa2:	ff d0                	callq  *%rax
	//
	// According to Intel MP Specification, the BIOS should initialize
	// BSP's local APIC in Virtual Wire Mode, in which 8259A's
	// INTR is virtually connected to BSP's LINTIN0. In this mode,
	// we do not need to program the IOAPIC.
	if (thiscpu != bootcpu)
  8004217fa4:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  8004217fab:	00 00 00 
  8004217fae:	ff d0                	callq  *%rax
  8004217fb0:	48 98                	cltq   
  8004217fb2:	48 c1 e0 03          	shl    $0x3,%rax
  8004217fb6:	48 89 c2             	mov    %rax,%rdx
  8004217fb9:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217fbd:	48 01 d0             	add    %rdx,%rax
  8004217fc0:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  8004217fc7:	00 00 00 
  8004217fca:	48 01 c2             	add    %rax,%rdx
  8004217fcd:	48 b8 40 12 6e 04 80 	movabs $0x80046e1240,%rax
  8004217fd4:	00 00 00 
  8004217fd7:	48 8b 00             	mov    (%rax),%rax
  8004217fda:	48 39 c2             	cmp    %rax,%rdx
  8004217fdd:	74 16                	je     8004217ff5 <lapic_init+0xf4>
		lapicw(LINT0, MASKED);
  8004217fdf:	be 00 00 01 00       	mov    $0x10000,%esi
  8004217fe4:	bf d4 00 00 00       	mov    $0xd4,%edi
  8004217fe9:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  8004217ff0:	00 00 00 
  8004217ff3:	ff d0                	callq  *%rax

	// Disable NMI (LINT1) on all CPUs
	lapicw(LINT1, MASKED);
  8004217ff5:	be 00 00 01 00       	mov    $0x10000,%esi
  8004217ffa:	bf d8 00 00 00       	mov    $0xd8,%edi
  8004217fff:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  8004218006:	00 00 00 
  8004218009:	ff d0                	callq  *%rax

	// Disable performance counter overflow interrupts
	// on machines that provide that interrupt entry.
	if (((lapic[VER]>>16) & 0xFF) >= 4)
  800421800b:	48 b8 08 20 72 04 80 	movabs $0x8004722008,%rax
  8004218012:	00 00 00 
  8004218015:	48 8b 00             	mov    (%rax),%rax
  8004218018:	48 83 c0 30          	add    $0x30,%rax
  800421801c:	8b 00                	mov    (%rax),%eax
  800421801e:	c1 e8 10             	shr    $0x10,%eax
  8004218021:	0f b6 c0             	movzbl %al,%eax
  8004218024:	83 f8 03             	cmp    $0x3,%eax
  8004218027:	76 16                	jbe    800421803f <lapic_init+0x13e>
		lapicw(PCINT, MASKED);
  8004218029:	be 00 00 01 00       	mov    $0x10000,%esi
  800421802e:	bf d0 00 00 00       	mov    $0xd0,%edi
  8004218033:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  800421803a:	00 00 00 
  800421803d:	ff d0                	callq  *%rax

	// Map error interrupt to IRQ_ERROR.
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);
  800421803f:	be 33 00 00 00       	mov    $0x33,%esi
  8004218044:	bf dc 00 00 00       	mov    $0xdc,%edi
  8004218049:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  8004218050:	00 00 00 
  8004218053:	ff d0                	callq  *%rax

	// Clear error status register (requires back-to-back writes).
	lapicw(ESR, 0);
  8004218055:	be 00 00 00 00       	mov    $0x0,%esi
  800421805a:	bf a0 00 00 00       	mov    $0xa0,%edi
  800421805f:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  8004218066:	00 00 00 
  8004218069:	ff d0                	callq  *%rax
	lapicw(ESR, 0);
  800421806b:	be 00 00 00 00       	mov    $0x0,%esi
  8004218070:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004218075:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  800421807c:	00 00 00 
  800421807f:	ff d0                	callq  *%rax

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);
  8004218081:	be 00 00 00 00       	mov    $0x0,%esi
  8004218086:	bf 2c 00 00 00       	mov    $0x2c,%edi
  800421808b:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  8004218092:	00 00 00 
  8004218095:	ff d0                	callq  *%rax

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
  8004218097:	be 00 00 00 00       	mov    $0x0,%esi
  800421809c:	bf c4 00 00 00       	mov    $0xc4,%edi
  80042180a1:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  80042180a8:	00 00 00 
  80042180ab:	ff d0                	callq  *%rax
	lapicw(ICRLO, BCAST | INIT | LEVEL);
  80042180ad:	be 00 85 08 00       	mov    $0x88500,%esi
  80042180b2:	bf c0 00 00 00       	mov    $0xc0,%edi
  80042180b7:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  80042180be:	00 00 00 
  80042180c1:	ff d0                	callq  *%rax
	while(lapic[ICRLO] & DELIVS)
  80042180c3:	90                   	nop
  80042180c4:	48 b8 08 20 72 04 80 	movabs $0x8004722008,%rax
  80042180cb:	00 00 00 
  80042180ce:	48 8b 00             	mov    (%rax),%rax
  80042180d1:	48 05 00 03 00 00    	add    $0x300,%rax
  80042180d7:	8b 00                	mov    (%rax),%eax
  80042180d9:	25 00 10 00 00       	and    $0x1000,%eax
  80042180de:	85 c0                	test   %eax,%eax
  80042180e0:	75 e2                	jne    80042180c4 <lapic_init+0x1c3>
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
  80042180e2:	be 00 00 00 00       	mov    $0x0,%esi
  80042180e7:	bf 20 00 00 00       	mov    $0x20,%edi
  80042180ec:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  80042180f3:	00 00 00 
  80042180f6:	ff d0                	callq  *%rax
  80042180f8:	eb 01                	jmp    80042180fb <lapic_init+0x1fa>

void
lapic_init(void)
{
	if (!lapicaddr)
		return;
  80042180fa:	90                   	nop
	while(lapic[ICRLO] & DELIVS)
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
}
  80042180fb:	5d                   	pop    %rbp
  80042180fc:	c3                   	retq   

00000080042180fd <cpunum>:

int
cpunum(void)
{
  80042180fd:	55                   	push   %rbp
  80042180fe:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004218101:	48 b8 08 20 72 04 80 	movabs $0x8004722008,%rax
  8004218108:	00 00 00 
  800421810b:	48 8b 00             	mov    (%rax),%rax
  800421810e:	48 85 c0             	test   %rax,%rax
  8004218111:	74 18                	je     800421812b <cpunum+0x2e>
		return lapic[ID] >> 24;
  8004218113:	48 b8 08 20 72 04 80 	movabs $0x8004722008,%rax
  800421811a:	00 00 00 
  800421811d:	48 8b 00             	mov    (%rax),%rax
  8004218120:	48 83 c0 20          	add    $0x20,%rax
  8004218124:	8b 00                	mov    (%rax),%eax
  8004218126:	c1 e8 18             	shr    $0x18,%eax
  8004218129:	eb 05                	jmp    8004218130 <cpunum+0x33>
	return 0;
  800421812b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004218130:	5d                   	pop    %rbp
  8004218131:	c3                   	retq   

0000008004218132 <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  8004218132:	55                   	push   %rbp
  8004218133:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004218136:	48 b8 08 20 72 04 80 	movabs $0x8004722008,%rax
  800421813d:	00 00 00 
  8004218140:	48 8b 00             	mov    (%rax),%rax
  8004218143:	48 85 c0             	test   %rax,%rax
  8004218146:	74 16                	je     800421815e <lapic_eoi+0x2c>
		lapicw(EOI, 0);
  8004218148:	be 00 00 00 00       	mov    $0x0,%esi
  800421814d:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004218152:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  8004218159:	00 00 00 
  800421815c:	ff d0                	callq  *%rax
}
  800421815e:	90                   	nop
  800421815f:	5d                   	pop    %rbp
  8004218160:	c3                   	retq   

0000008004218161 <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  8004218161:	55                   	push   %rbp
  8004218162:	48 89 e5             	mov    %rsp,%rbp
  8004218165:	48 83 ec 08          	sub    $0x8,%rsp
  8004218169:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
  800421816c:	90                   	nop
  800421816d:	c9                   	leaveq 
  800421816e:	c3                   	retq   

000000800421816f <lapic_startap>:

// Start additional processor running entry code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uint8_t apicid, uint32_t addr)
{
  800421816f:	55                   	push   %rbp
  8004218170:	48 89 e5             	mov    %rsp,%rbp
  8004218173:	48 83 ec 40          	sub    $0x40,%rsp
  8004218177:	89 f8                	mov    %edi,%eax
  8004218179:	89 75 c8             	mov    %esi,-0x38(%rbp)
  800421817c:	88 45 cc             	mov    %al,-0x34(%rbp)
  800421817f:	c7 45 f8 70 00 00 00 	movl   $0x70,-0x8(%rbp)
  8004218186:	c6 45 da 0f          	movb   $0xf,-0x26(%rbp)
  800421818a:	0f b6 45 da          	movzbl -0x26(%rbp),%eax
  800421818e:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004218191:	ee                   	out    %al,(%dx)
  8004218192:	c7 45 dc 71 00 00 00 	movl   $0x71,-0x24(%rbp)
  8004218199:	c6 45 db 0a          	movb   $0xa,-0x25(%rbp)
  800421819d:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  80042181a1:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042181a4:	ee                   	out    %al,(%dx)
	// "The BSP must initialize CMOS shutdown code to 0AH
	// and the warm reset vector (DWORD based at 40:67) to point at
	// the AP startup code prior to the [universal startup algorithm]."
	outb(IO_RTC, 0xF);  // offset 0xF is shutdown code
	outb(IO_RTC+1, 0x0A);
	wrv = (uint16_t *)KADDR((0x40 << 4 | 0x67));  // Warm reset vector
  80042181a5:	48 c7 45 f0 67 04 00 	movq   $0x467,-0x10(%rbp)
  80042181ac:	00 
  80042181ad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042181b1:	48 c1 e8 0c          	shr    $0xc,%rax
  80042181b5:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042181b8:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042181bb:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  80042181c2:	00 00 00 
  80042181c5:	48 8b 00             	mov    (%rax),%rax
  80042181c8:	48 39 c2             	cmp    %rax,%rdx
  80042181cb:	72 32                	jb     80042181ff <lapic_startap+0x90>
  80042181cd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042181d1:	48 89 c1             	mov    %rax,%rcx
  80042181d4:	48 ba a0 1c 22 04 80 	movabs $0x8004221ca0,%rdx
  80042181db:	00 00 00 
  80042181de:	be 99 00 00 00       	mov    $0x99,%esi
  80042181e3:	48 bf c3 1c 22 04 80 	movabs $0x8004221cc3,%rdi
  80042181ea:	00 00 00 
  80042181ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042181f2:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  80042181f9:	00 00 00 
  80042181fc:	41 ff d0             	callq  *%r8
  80042181ff:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004218206:	00 00 00 
  8004218209:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421820d:	48 01 d0             	add    %rdx,%rax
  8004218210:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	wrv[0] = 0;
  8004218214:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218218:	66 c7 00 00 00       	movw   $0x0,(%rax)
	wrv[1] = addr >> 4;
  800421821d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218221:	48 83 c0 02          	add    $0x2,%rax
  8004218225:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004218228:	c1 ea 04             	shr    $0x4,%edx
  800421822b:	66 89 10             	mov    %dx,(%rax)

	// "Universal startup algorithm."
	// Send INIT (level-triggered) interrupt to reset other CPU.
	lapicw(ICRHI, apicid << 24);
  800421822e:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004218232:	c1 e0 18             	shl    $0x18,%eax
  8004218235:	89 c6                	mov    %eax,%esi
  8004218237:	bf c4 00 00 00       	mov    $0xc4,%edi
  800421823c:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  8004218243:	00 00 00 
  8004218246:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL | ASSERT);
  8004218248:	be 00 c5 00 00       	mov    $0xc500,%esi
  800421824d:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004218252:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  8004218259:	00 00 00 
  800421825c:	ff d0                	callq  *%rax
	microdelay(200);
  800421825e:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004218263:	48 b8 61 81 21 04 80 	movabs $0x8004218161,%rax
  800421826a:	00 00 00 
  800421826d:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL);
  800421826f:	be 00 85 00 00       	mov    $0x8500,%esi
  8004218274:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004218279:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  8004218280:	00 00 00 
  8004218283:	ff d0                	callq  *%rax
	microdelay(100);    // should be 10ms, but too slow in Bochs!
  8004218285:	bf 64 00 00 00       	mov    $0x64,%edi
  800421828a:	48 b8 61 81 21 04 80 	movabs $0x8004218161,%rax
  8004218291:	00 00 00 
  8004218294:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004218296:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421829d:	eb 4b                	jmp    80042182ea <lapic_startap+0x17b>
		lapicw(ICRHI, apicid << 24);
  800421829f:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  80042182a3:	c1 e0 18             	shl    $0x18,%eax
  80042182a6:	89 c6                	mov    %eax,%esi
  80042182a8:	bf c4 00 00 00       	mov    $0xc4,%edi
  80042182ad:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  80042182b4:	00 00 00 
  80042182b7:	ff d0                	callq  *%rax
		lapicw(ICRLO, STARTUP | (addr >> 12));
  80042182b9:	8b 45 c8             	mov    -0x38(%rbp),%eax
  80042182bc:	c1 e8 0c             	shr    $0xc,%eax
  80042182bf:	80 cc 06             	or     $0x6,%ah
  80042182c2:	89 c6                	mov    %eax,%esi
  80042182c4:	bf c0 00 00 00       	mov    $0xc0,%edi
  80042182c9:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  80042182d0:	00 00 00 
  80042182d3:	ff d0                	callq  *%rax
		microdelay(200);
  80042182d5:	bf c8 00 00 00       	mov    $0xc8,%edi
  80042182da:	48 b8 61 81 21 04 80 	movabs $0x8004218161,%rax
  80042182e1:	00 00 00 
  80042182e4:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  80042182e6:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042182ea:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  80042182ee:	7e af                	jle    800421829f <lapic_startap+0x130>
		lapicw(ICRHI, apicid << 24);
		lapicw(ICRLO, STARTUP | (addr >> 12));
		microdelay(200);
	}
}
  80042182f0:	90                   	nop
  80042182f1:	c9                   	leaveq 
  80042182f2:	c3                   	retq   

00000080042182f3 <lapic_ipi>:

void
lapic_ipi(int vector)
{
  80042182f3:	55                   	push   %rbp
  80042182f4:	48 89 e5             	mov    %rsp,%rbp
  80042182f7:	48 83 ec 08          	sub    $0x8,%rsp
  80042182fb:	89 7d fc             	mov    %edi,-0x4(%rbp)
	lapicw(ICRLO, OTHERS | FIXED | vector);
  80042182fe:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218301:	0d 00 00 0c 00       	or     $0xc0000,%eax
  8004218306:	89 c6                	mov    %eax,%esi
  8004218308:	bf c0 00 00 00       	mov    $0xc0,%edi
  800421830d:	48 b8 be 7e 21 04 80 	movabs $0x8004217ebe,%rax
  8004218314:	00 00 00 
  8004218317:	ff d0                	callq  *%rax
	while (lapic[ICRLO] & DELIVS)
  8004218319:	90                   	nop
  800421831a:	48 b8 08 20 72 04 80 	movabs $0x8004722008,%rax
  8004218321:	00 00 00 
  8004218324:	48 8b 00             	mov    (%rax),%rax
  8004218327:	48 05 00 03 00 00    	add    $0x300,%rax
  800421832d:	8b 00                	mov    (%rax),%eax
  800421832f:	25 00 10 00 00       	and    $0x1000,%eax
  8004218334:	85 c0                	test   %eax,%eax
  8004218336:	75 e2                	jne    800421831a <lapic_ipi+0x27>
		;
}
  8004218338:	90                   	nop
  8004218339:	c9                   	leaveq 
  800421833a:	c3                   	retq   

000000800421833b <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800421833b:	55                   	push   %rbp
  800421833c:	48 89 e5             	mov    %rsp,%rbp
  800421833f:	48 83 ec 20          	sub    $0x20,%rsp
  8004218343:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004218347:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800421834a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421834e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004218351:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004218355:	f0 87 02             	lock xchg %eax,(%rdx)
  8004218358:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800421835b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800421835e:	c9                   	leaveq 
  800421835f:	c3                   	retq   

0000008004218360 <get_caller_pcs>:

#ifdef DEBUG_SPINLOCK
// Record the current call stack in pcs[] by following the %ebp chain.
static void
get_caller_pcs(uint64_t pcs[])
{
  8004218360:	55                   	push   %rbp
  8004218361:	48 89 e5             	mov    %rsp,%rbp
  8004218364:	48 83 ec 28          	sub    $0x28,%rsp
  8004218368:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)

static __inline uint64_t
read_rbp(void)
{
	uint64_t rbp;
	__asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  800421836c:	48 89 e8             	mov    %rbp,%rax
  800421836f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	return rbp;
  8004218373:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
  8004218377:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (i = 0; i < 10; i++){
  800421837b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004218382:	eb 45                	jmp    80042183c9 <get_caller_pcs+0x69>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
  8004218384:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004218389:	74 65                	je     80042183f0 <get_caller_pcs+0x90>
  800421838b:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004218392:	00 00 00 
  8004218395:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004218399:	76 55                	jbe    80042183f0 <get_caller_pcs+0x90>
			break;
		pcs[i] = rbp[1];          // saved %rip
  800421839b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421839e:	48 98                	cltq   
  80042183a0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042183a7:	00 
  80042183a8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042183ac:	48 01 c2             	add    %rax,%rdx
  80042183af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042183b3:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042183b7:	48 89 02             	mov    %rax,(%rdx)
		rbp = (uint64_t *)rbp[0]; // saved %rbp
  80042183ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042183be:	48 8b 00             	mov    (%rax),%rax
  80042183c1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
{
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
	for (i = 0; i < 10; i++){
  80042183c5:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042183c9:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  80042183cd:	7e b5                	jle    8004218384 <get_caller_pcs+0x24>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  80042183cf:	eb 1f                	jmp    80042183f0 <get_caller_pcs+0x90>
		pcs[i] = 0;
  80042183d1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042183d4:	48 98                	cltq   
  80042183d6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042183dd:	00 
  80042183de:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042183e2:	48 01 d0             	add    %rdx,%rax
  80042183e5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  80042183ec:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042183f0:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  80042183f4:	7e db                	jle    80042183d1 <get_caller_pcs+0x71>
		pcs[i] = 0;
}
  80042183f6:	90                   	nop
  80042183f7:	c9                   	leaveq 
  80042183f8:	c3                   	retq   

00000080042183f9 <holding>:

// Check whether this CPU is holding the lock.
static int
holding(struct spinlock *lock)
{
  80042183f9:	55                   	push   %rbp
  80042183fa:	48 89 e5             	mov    %rsp,%rbp
  80042183fd:	53                   	push   %rbx
  80042183fe:	48 83 ec 18          	sub    $0x18,%rsp
  8004218402:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return lock->locked && lock->cpu == thiscpu;
  8004218406:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421840a:	8b 00                	mov    (%rax),%eax
  800421840c:	85 c0                	test   %eax,%eax
  800421840e:	74 3d                	je     800421844d <holding+0x54>
  8004218410:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218414:	48 8b 58 10          	mov    0x10(%rax),%rbx
  8004218418:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421841f:	00 00 00 
  8004218422:	ff d0                	callq  *%rax
  8004218424:	48 98                	cltq   
  8004218426:	48 c1 e0 03          	shl    $0x3,%rax
  800421842a:	48 89 c2             	mov    %rax,%rdx
  800421842d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218431:	48 01 d0             	add    %rdx,%rax
  8004218434:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421843b:	00 00 00 
  800421843e:	48 01 d0             	add    %rdx,%rax
  8004218441:	48 39 c3             	cmp    %rax,%rbx
  8004218444:	75 07                	jne    800421844d <holding+0x54>
  8004218446:	b8 01 00 00 00       	mov    $0x1,%eax
  800421844b:	eb 05                	jmp    8004218452 <holding+0x59>
  800421844d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004218452:	48 83 c4 18          	add    $0x18,%rsp
  8004218456:	5b                   	pop    %rbx
  8004218457:	5d                   	pop    %rbp
  8004218458:	c3                   	retq   

0000008004218459 <__spin_initlock>:
#endif

void
__spin_initlock(struct spinlock *lk, char *name)
{
  8004218459:	55                   	push   %rbp
  800421845a:	48 89 e5             	mov    %rsp,%rbp
  800421845d:	48 83 ec 10          	sub    $0x10,%rsp
  8004218461:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004218465:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	lk->locked = 0;
  8004218469:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421846d:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
#ifdef DEBUG_SPINLOCK
	lk->name = name;
  8004218473:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218477:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421847b:	48 89 50 08          	mov    %rdx,0x8(%rax)
	lk->cpu = 0;
  800421847f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218483:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800421848a:	00 
#endif
}
  800421848b:	90                   	nop
  800421848c:	c9                   	leaveq 
  800421848d:	c3                   	retq   

000000800421848e <spin_lock>:
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
spin_lock(struct spinlock *lk)
{
  800421848e:	55                   	push   %rbp
  800421848f:	48 89 e5             	mov    %rsp,%rbp
  8004218492:	53                   	push   %rbx
  8004218493:	48 83 ec 18          	sub    $0x18,%rsp
  8004218497:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef DEBUG_SPINLOCK
	if (holding(lk))
  800421849b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421849f:	48 89 c7             	mov    %rax,%rdi
  80042184a2:	48 b8 f9 83 21 04 80 	movabs $0x80042183f9,%rax
  80042184a9:	00 00 00 
  80042184ac:	ff d0                	callq  *%rax
  80042184ae:	85 c0                	test   %eax,%eax
  80042184b0:	74 46                	je     80042184f8 <spin_lock+0x6a>
		panic("CPU %d cannot acquire %s: already holding", cpunum(), lk->name);
  80042184b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042184b6:	48 8b 58 08          	mov    0x8(%rax),%rbx
  80042184ba:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  80042184c1:	00 00 00 
  80042184c4:	ff d0                	callq  *%rax
  80042184c6:	49 89 d8             	mov    %rbx,%r8
  80042184c9:	89 c1                	mov    %eax,%ecx
  80042184cb:	48 ba e0 1c 22 04 80 	movabs $0x8004221ce0,%rdx
  80042184d2:	00 00 00 
  80042184d5:	be 42 00 00 00       	mov    $0x42,%esi
  80042184da:	48 bf 0a 1d 22 04 80 	movabs $0x8004221d0a,%rdi
  80042184e1:	00 00 00 
  80042184e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042184e9:	49 b9 d3 04 20 04 80 	movabs $0x80042004d3,%r9
  80042184f0:	00 00 00 
  80042184f3:	41 ff d1             	callq  *%r9

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
		asm volatile ("pause");
  80042184f6:	f3 90                	pause  
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  80042184f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042184fc:	be 01 00 00 00       	mov    $0x1,%esi
  8004218501:	48 89 c7             	mov    %rax,%rdi
  8004218504:	48 b8 3b 83 21 04 80 	movabs $0x800421833b,%rax
  800421850b:	00 00 00 
  800421850e:	ff d0                	callq  *%rax
  8004218510:	85 c0                	test   %eax,%eax
  8004218512:	75 e2                	jne    80042184f6 <spin_lock+0x68>
		asm volatile ("pause");

	// Record info about lock acquisition for debugging.
#ifdef DEBUG_SPINLOCK
	lk->cpu = thiscpu;
  8004218514:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421851b:	00 00 00 
  800421851e:	ff d0                	callq  *%rax
  8004218520:	48 98                	cltq   
  8004218522:	48 c1 e0 03          	shl    $0x3,%rax
  8004218526:	48 89 c2             	mov    %rax,%rdx
  8004218529:	48 c1 e2 04          	shl    $0x4,%rdx
  800421852d:	48 01 d0             	add    %rdx,%rax
  8004218530:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  8004218537:	00 00 00 
  800421853a:	48 01 c2             	add    %rax,%rdx
  800421853d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218541:	48 89 50 10          	mov    %rdx,0x10(%rax)
	get_caller_pcs(lk->pcs);
  8004218545:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218549:	48 83 c0 18          	add    $0x18,%rax
  800421854d:	48 89 c7             	mov    %rax,%rdi
  8004218550:	48 b8 60 83 21 04 80 	movabs $0x8004218360,%rax
  8004218557:	00 00 00 
  800421855a:	ff d0                	callq  *%rax
#endif
}
  800421855c:	90                   	nop
  800421855d:	48 83 c4 18          	add    $0x18,%rsp
  8004218561:	5b                   	pop    %rbx
  8004218562:	5d                   	pop    %rbp
  8004218563:	c3                   	retq   

0000008004218564 <spin_unlock>:

// Release the lock.
void
spin_unlock(struct spinlock *lk)
{
  8004218564:	55                   	push   %rbp
  8004218565:	48 89 e5             	mov    %rsp,%rbp
  8004218568:	41 54                	push   %r12
  800421856a:	53                   	push   %rbx
  800421856b:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  8004218572:	48 89 bd d8 fa ff ff 	mov    %rdi,-0x528(%rbp)
#ifdef DEBUG_SPINLOCK
	if (!holding(lk)) {
  8004218579:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004218580:	48 89 c7             	mov    %rax,%rdi
  8004218583:	48 b8 f9 83 21 04 80 	movabs $0x80042183f9,%rax
  800421858a:	00 00 00 
  800421858d:	ff d0                	callq  *%rax
  800421858f:	85 c0                	test   %eax,%eax
  8004218591:	0f 85 d8 01 00 00    	jne    800421876f <spin_unlock+0x20b>
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
  8004218597:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  800421859e:	48 8d 48 18          	lea    0x18(%rax),%rcx
  80042185a2:	48 8d 85 e0 fa ff ff 	lea    -0x520(%rbp),%rax
  80042185a9:	ba 28 00 00 00       	mov    $0x28,%edx
  80042185ae:	48 89 ce             	mov    %rcx,%rsi
  80042185b1:	48 89 c7             	mov    %rax,%rdi
  80042185b4:	48 b8 44 12 21 04 80 	movabs $0x8004211244,%rax
  80042185bb:	00 00 00 
  80042185be:	ff d0                	callq  *%rax
		if (!lk->cpu) 
  80042185c0:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042185c7:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042185cb:	48 85 c0             	test   %rax,%rax
  80042185ce:	75 39                	jne    8004218609 <spin_unlock+0xa5>
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
  80042185d0:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042185d7:	48 8b 58 08          	mov    0x8(%rax),%rbx
  80042185db:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  80042185e2:	00 00 00 
  80042185e5:	ff d0                	callq  *%rax
  80042185e7:	48 89 da             	mov    %rbx,%rdx
  80042185ea:	89 c6                	mov    %eax,%esi
  80042185ec:	48 bf 20 1d 22 04 80 	movabs $0x8004221d20,%rdi
  80042185f3:	00 00 00 
  80042185f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042185fb:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  8004218602:	00 00 00 
  8004218605:	ff d1                	callq  *%rcx
  8004218607:	eb 4d                	jmp    8004218656 <spin_unlock+0xf2>
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
  8004218609:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004218610:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004218614:	0f b6 00             	movzbl (%rax),%eax
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  8004218617:	44 0f b6 e0          	movzbl %al,%r12d
  800421861b:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004218622:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004218626:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421862d:	00 00 00 
  8004218630:	ff d0                	callq  *%rax
  8004218632:	44 89 e1             	mov    %r12d,%ecx
  8004218635:	48 89 da             	mov    %rbx,%rdx
  8004218638:	89 c6                	mov    %eax,%esi
  800421863a:	48 bf 60 1d 22 04 80 	movabs $0x8004221d60,%rdi
  8004218641:	00 00 00 
  8004218644:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218649:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  8004218650:	00 00 00 
  8004218653:	41 ff d0             	callq  *%r8
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004218656:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  800421865d:	e9 c9 00 00 00       	jmpq   800421872b <spin_unlock+0x1c7>
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
  8004218662:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218665:	48 98                	cltq   
  8004218667:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  800421866e:	89 c2                	mov    %eax,%edx
  8004218670:	48 8d 85 10 fb ff ff 	lea    -0x4f0(%rbp),%rax
  8004218677:	48 89 c6             	mov    %rax,%rsi
  800421867a:	48 89 d7             	mov    %rdx,%rdi
  800421867d:	48 b8 54 fe 20 04 80 	movabs $0x800420fe54,%rax
  8004218684:	00 00 00 
  8004218687:	ff d0                	callq  *%rax
  8004218689:	85 c0                	test   %eax,%eax
  800421868b:	78 71                	js     80042186fe <spin_unlock+0x19a>
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  800421868d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218690:	48 98                	cltq   
  8004218692:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004218699:	89 c2                	mov    %eax,%edx
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  800421869b:	48 8b 85 30 fb ff ff 	mov    -0x4d0(%rbp),%rax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  80042186a2:	48 29 c2             	sub    %rax,%rdx
  80042186a5:	49 89 d0             	mov    %rdx,%r8
  80042186a8:	48 8b bd 20 fb ff ff 	mov    -0x4e0(%rbp),%rdi
  80042186af:	8b b5 28 fb ff ff    	mov    -0x4d8(%rbp),%esi
  80042186b5:	8b 8d 18 fb ff ff    	mov    -0x4e8(%rbp),%ecx
  80042186bb:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  80042186c2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042186c5:	48 98                	cltq   
  80042186c7:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  80042186ce:	48 83 ec 08          	sub    $0x8,%rsp
  80042186d2:	41 50                	push   %r8
  80042186d4:	49 89 f9             	mov    %rdi,%r9
  80042186d7:	41 89 f0             	mov    %esi,%r8d
  80042186da:	89 c6                	mov    %eax,%esi
  80042186dc:	48 bf 96 1d 22 04 80 	movabs $0x8004221d96,%rdi
  80042186e3:	00 00 00 
  80042186e6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042186eb:	49 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%r10
  80042186f2:	00 00 00 
  80042186f5:	41 ff d2             	callq  *%r10
  80042186f8:	48 83 c4 10          	add    $0x10,%rsp
  80042186fc:	eb 29                	jmp    8004218727 <spin_unlock+0x1c3>
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
  80042186fe:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218701:	48 98                	cltq   
  8004218703:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  800421870a:	89 c6                	mov    %eax,%esi
  800421870c:	48 bf ad 1d 22 04 80 	movabs $0x8004221dad,%rdi
  8004218713:	00 00 00 
  8004218716:	b8 00 00 00 00       	mov    $0x0,%eax
  800421871b:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004218722:	00 00 00 
  8004218725:	ff d2                	callq  *%rdx
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004218727:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  800421872b:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  800421872f:	7f 14                	jg     8004218745 <spin_unlock+0x1e1>
  8004218731:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218734:	48 98                	cltq   
  8004218736:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  800421873d:	85 c0                	test   %eax,%eax
  800421873f:	0f 85 1d ff ff ff    	jne    8004218662 <spin_unlock+0xfe>
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
		}
		panic("spin_unlock");
  8004218745:	48 ba b5 1d 22 04 80 	movabs $0x8004221db5,%rdx
  800421874c:	00 00 00 
  800421874f:	be 6c 00 00 00       	mov    $0x6c,%esi
  8004218754:	48 bf 0a 1d 22 04 80 	movabs $0x8004221d0a,%rdi
  800421875b:	00 00 00 
  800421875e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218763:	48 b9 d3 04 20 04 80 	movabs $0x80042004d3,%rcx
  800421876a:	00 00 00 
  800421876d:	ff d1                	callq  *%rcx
	}

	lk->pcs[0] = 0;
  800421876f:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004218776:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  800421877d:	00 
	lk->cpu = 0;
  800421877e:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004218785:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800421878c:	00 
	// But the 2007 Intel 64 Architecture Memory Ordering White
	// Paper says that Intel 64 and IA-32 will not move a load
	// after a store. So lock->locked = 0 would work here.
	// The xchg being asm volatile ensures gcc emits it after
	// the above assignments (and after the critical section).
	xchg(&lk->locked, 0);
  800421878d:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004218794:	be 00 00 00 00       	mov    $0x0,%esi
  8004218799:	48 89 c7             	mov    %rax,%rdi
  800421879c:	48 b8 3b 83 21 04 80 	movabs $0x800421833b,%rax
  80042187a3:	00 00 00 
  80042187a6:	ff d0                	callq  *%rax
}
  80042187a8:	90                   	nop
  80042187a9:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  80042187ad:	5b                   	pop    %rbx
  80042187ae:	41 5c                	pop    %r12
  80042187b0:	5d                   	pop    %rbp
  80042187b1:	c3                   	retq   

00000080042187b2 <e1000_attach>:
static struct rx_desc rx_ring[RX_RING_SIZE] __attribute__((aligned(16)));
static char rx_data[RX_RING_SIZE][2048];

int
e1000_attach(struct pci_func *pcif)
{
  80042187b2:	55                   	push   %rbp
  80042187b3:	48 89 e5             	mov    %rsp,%rbp
  80042187b6:	48 83 ec 40          	sub    $0x40,%rsp
  80042187ba:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	int i;

	pci_func_enable(pcif);
  80042187be:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042187c2:	48 89 c7             	mov    %rax,%rdi
  80042187c5:	48 b8 93 96 21 04 80 	movabs $0x8004219693,%rax
  80042187cc:	00 00 00 
  80042187cf:	ff d0                	callq  *%rax

	// [E1000 Table 4-2] BAR 0 gives the register base address.
	regs = mmio_map_region(pcif->reg_base[0], pcif->reg_size[0]);
  80042187d1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042187d5:	8b 40 30             	mov    0x30(%rax),%eax
  80042187d8:	89 c2                	mov    %eax,%edx
  80042187da:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042187de:	8b 40 18             	mov    0x18(%rax),%eax
  80042187e1:	89 c0                	mov    %eax,%eax
  80042187e3:	48 89 d6             	mov    %rdx,%rsi
  80042187e6:	48 89 c7             	mov    %rax,%rdi
  80042187e9:	48 b8 76 3f 20 04 80 	movabs $0x8004203f76,%rax
  80042187f0:	00 00 00 
  80042187f3:	ff d0                	callq  *%rax
  80042187f5:	48 89 c2             	mov    %rax,%rdx
  80042187f8:	48 b8 20 17 4e 04 80 	movabs $0x80044e1720,%rax
  80042187ff:	00 00 00 
  8004218802:	48 89 10             	mov    %rdx,(%rax)

	// [E1000 14.5] Transmit initialization
	for (i = 0; i < TX_RING_SIZE; i++) {
  8004218805:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421880c:	e9 ac 00 00 00       	jmpq   80042188bd <e1000_attach+0x10b>
		tx_ring[i].addr = PADDR(tx_data[i]);
  8004218811:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218814:	48 98                	cltq   
  8004218816:	48 69 d0 ee 05 00 00 	imul   $0x5ee,%rax,%rdx
  800421881d:	48 b8 40 18 4e 04 80 	movabs $0x80044e1840,%rax
  8004218824:	00 00 00 
  8004218827:	48 01 d0             	add    %rdx,%rax
  800421882a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800421882e:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004218835:	00 00 00 
  8004218838:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800421883c:	77 32                	ja     8004218870 <e1000_attach+0xbe>
  800421883e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004218842:	48 89 c1             	mov    %rax,%rcx
  8004218845:	48 ba c8 1d 22 04 80 	movabs $0x8004221dc8,%rdx
  800421884c:	00 00 00 
  800421884f:	be 97 00 00 00       	mov    $0x97,%esi
  8004218854:	48 bf ec 1d 22 04 80 	movabs $0x8004221dec,%rdi
  800421885b:	00 00 00 
  800421885e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218863:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421886a:	00 00 00 
  800421886d:	41 ff d0             	callq  *%r8
  8004218870:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004218877:	ff ff ff 
  800421887a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421887e:	48 01 c2             	add    %rax,%rdx
  8004218881:	48 b8 30 17 4e 04 80 	movabs $0x80044e1730,%rax
  8004218888:	00 00 00 
  800421888b:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800421888e:	48 63 c9             	movslq %ecx,%rcx
  8004218891:	48 c1 e1 04          	shl    $0x4,%rcx
  8004218895:	48 01 c8             	add    %rcx,%rax
  8004218898:	48 89 10             	mov    %rdx,(%rax)
		tx_ring[i].status = E1000_TXD_STAT_DD;
  800421889b:	48 b8 30 17 4e 04 80 	movabs $0x80044e1730,%rax
  80042188a2:	00 00 00 
  80042188a5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042188a8:	48 63 d2             	movslq %edx,%rdx
  80042188ab:	48 c1 e2 04          	shl    $0x4,%rdx
  80042188af:	48 01 d0             	add    %rdx,%rax
  80042188b2:	48 83 c0 0c          	add    $0xc,%rax
  80042188b6:	c6 00 01             	movb   $0x1,(%rax)

	// [E1000 Table 4-2] BAR 0 gives the register base address.
	regs = mmio_map_region(pcif->reg_base[0], pcif->reg_size[0]);

	// [E1000 14.5] Transmit initialization
	for (i = 0; i < TX_RING_SIZE; i++) {
  80042188b9:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042188bd:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  80042188c1:	0f 8e 4a ff ff ff    	jle    8004218811 <e1000_attach+0x5f>
		tx_ring[i].addr = PADDR(tx_data[i]);
		tx_ring[i].status = E1000_TXD_STAT_DD;
	}
	regs[E1000_TDBAL] = PADDR(tx_ring);
  80042188c7:	48 b8 20 17 4e 04 80 	movabs $0x80044e1720,%rax
  80042188ce:	00 00 00 
  80042188d1:	48 8b 00             	mov    (%rax),%rax
  80042188d4:	48 8d 90 00 38 00 00 	lea    0x3800(%rax),%rdx
  80042188db:	48 b8 30 17 4e 04 80 	movabs $0x80044e1730,%rax
  80042188e2:	00 00 00 
  80042188e5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042188e9:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042188f0:	00 00 00 
  80042188f3:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80042188f7:	77 32                	ja     800421892b <e1000_attach+0x179>
  80042188f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042188fd:	48 89 c1             	mov    %rax,%rcx
  8004218900:	48 ba c8 1d 22 04 80 	movabs $0x8004221dc8,%rdx
  8004218907:	00 00 00 
  800421890a:	be 9a 00 00 00       	mov    $0x9a,%esi
  800421890f:	48 bf ec 1d 22 04 80 	movabs $0x8004221dec,%rdi
  8004218916:	00 00 00 
  8004218919:	b8 00 00 00 00       	mov    $0x0,%eax
  800421891e:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004218925:	00 00 00 
  8004218928:	41 ff d0             	callq  *%r8
  800421892b:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004218932:	ff ff ff 
  8004218935:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218939:	48 01 c8             	add    %rcx,%rax
  800421893c:	89 02                	mov    %eax,(%rdx)
	static_assert(sizeof(tx_ring) % 128 == 0);
	regs[E1000_TDLEN] = sizeof(tx_ring);
  800421893e:	48 b8 20 17 4e 04 80 	movabs $0x80044e1720,%rax
  8004218945:	00 00 00 
  8004218948:	48 8b 00             	mov    (%rax),%rax
  800421894b:	48 05 08 38 00 00    	add    $0x3808,%rax
  8004218951:	c7 00 00 01 00 00    	movl   $0x100,(%rax)
	regs[E1000_TDH] = regs[E1000_TDT] = 0;
  8004218957:	48 b8 20 17 4e 04 80 	movabs $0x80044e1720,%rax
  800421895e:	00 00 00 
  8004218961:	48 8b 00             	mov    (%rax),%rax
  8004218964:	48 8d 90 10 38 00 00 	lea    0x3810(%rax),%rdx
  800421896b:	48 b8 20 17 4e 04 80 	movabs $0x80044e1720,%rax
  8004218972:	00 00 00 
  8004218975:	48 8b 00             	mov    (%rax),%rax
  8004218978:	48 8d 88 18 38 00 00 	lea    0x3818(%rax),%rcx
  800421897f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218984:	89 01                	mov    %eax,(%rcx)
  8004218986:	89 02                	mov    %eax,(%rdx)
	regs[E1000_TCTL] = (E1000_TCTL_EN | E1000_TCTL_PSP |
  8004218988:	48 b8 20 17 4e 04 80 	movabs $0x80044e1720,%rax
  800421898f:	00 00 00 
  8004218992:	48 8b 00             	mov    (%rax),%rax
  8004218995:	48 05 00 04 00 00    	add    $0x400,%rax
  800421899b:	c7 00 0a 01 04 00    	movl   $0x4010a,(%rax)
			    (0x10 << E1000_TCTL_CT_SHIFT) |
			    (0x40 << E1000_TCTL_COLD_SHIFT));
	regs[E1000_TIPG] = 10 | (8<<10) | (6<<20);
  80042189a1:	48 b8 20 17 4e 04 80 	movabs $0x80044e1720,%rax
  80042189a8:	00 00 00 
  80042189ab:	48 8b 00             	mov    (%rax),%rax
  80042189ae:	48 05 10 04 00 00    	add    $0x410,%rax
  80042189b4:	c7 00 0a 20 60 00    	movl   $0x60200a,(%rax)
	regs[E1000_RAH] = regs[E1000_EERD] >> 16;

	regs[E1000_RAH] |= 0x1 << 31;
#endif

	for (i = 0; i < RX_RING_SIZE; i++) {
  80042189ba:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042189c1:	e9 8e 00 00 00       	jmpq   8004218a54 <e1000_attach+0x2a2>
		rx_ring[i].addr = PADDR(rx_data[i]);
  80042189c6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042189c9:	48 98                	cltq   
  80042189cb:	48 c1 e0 0b          	shl    $0xb,%rax
  80042189cf:	48 89 c2             	mov    %rax,%rdx
  80042189d2:	48 b8 a0 b5 4e 04 80 	movabs $0x80044eb5a0,%rax
  80042189d9:	00 00 00 
  80042189dc:	48 01 d0             	add    %rdx,%rax
  80042189df:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042189e3:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042189ea:	00 00 00 
  80042189ed:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  80042189f1:	77 32                	ja     8004218a25 <e1000_attach+0x273>
  80042189f3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042189f7:	48 89 c1             	mov    %rax,%rcx
  80042189fa:	48 ba c8 1d 22 04 80 	movabs $0x8004221dc8,%rdx
  8004218a01:	00 00 00 
  8004218a04:	be b8 00 00 00       	mov    $0xb8,%esi
  8004218a09:	48 bf ec 1d 22 04 80 	movabs $0x8004221dec,%rdi
  8004218a10:	00 00 00 
  8004218a13:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218a18:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004218a1f:	00 00 00 
  8004218a22:	41 ff d0             	callq  *%r8
  8004218a25:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004218a2c:	ff ff ff 
  8004218a2f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218a33:	48 01 c2             	add    %rax,%rdx
  8004218a36:	48 b8 20 77 4e 04 80 	movabs $0x80044e7720,%rax
  8004218a3d:	00 00 00 
  8004218a40:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004218a43:	48 63 c9             	movslq %ecx,%rcx
  8004218a46:	48 c1 e1 04          	shl    $0x4,%rcx
  8004218a4a:	48 01 c8             	add    %rcx,%rax
  8004218a4d:	48 89 10             	mov    %rdx,(%rax)
	regs[E1000_RAH] = regs[E1000_EERD] >> 16;

	regs[E1000_RAH] |= 0x1 << 31;
#endif

	for (i = 0; i < RX_RING_SIZE; i++) {
  8004218a50:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004218a54:	81 7d fc e7 03 00 00 	cmpl   $0x3e7,-0x4(%rbp)
  8004218a5b:	0f 8e 65 ff ff ff    	jle    80042189c6 <e1000_attach+0x214>
		rx_ring[i].addr = PADDR(rx_data[i]);
	}
	regs[E1000_RDBAL] = PADDR(rx_ring);
  8004218a61:	48 b8 20 17 4e 04 80 	movabs $0x80044e1720,%rax
  8004218a68:	00 00 00 
  8004218a6b:	48 8b 00             	mov    (%rax),%rax
  8004218a6e:	48 8d 90 00 28 00 00 	lea    0x2800(%rax),%rdx
  8004218a75:	48 b8 20 77 4e 04 80 	movabs $0x80044e7720,%rax
  8004218a7c:	00 00 00 
  8004218a7f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004218a83:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004218a8a:	00 00 00 
  8004218a8d:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004218a91:	77 32                	ja     8004218ac5 <e1000_attach+0x313>
  8004218a93:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218a97:	48 89 c1             	mov    %rax,%rcx
  8004218a9a:	48 ba c8 1d 22 04 80 	movabs $0x8004221dc8,%rdx
  8004218aa1:	00 00 00 
  8004218aa4:	be ba 00 00 00       	mov    $0xba,%esi
  8004218aa9:	48 bf ec 1d 22 04 80 	movabs $0x8004221dec,%rdi
  8004218ab0:	00 00 00 
  8004218ab3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218ab8:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004218abf:	00 00 00 
  8004218ac2:	41 ff d0             	callq  *%r8
  8004218ac5:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004218acc:	ff ff ff 
  8004218acf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218ad3:	48 01 c8             	add    %rcx,%rax
  8004218ad6:	89 02                	mov    %eax,(%rdx)
	static_assert(sizeof(rx_ring) % 128 == 0);
	regs[E1000_RDLEN] = sizeof(rx_ring);
  8004218ad8:	48 b8 20 17 4e 04 80 	movabs $0x80044e1720,%rax
  8004218adf:	00 00 00 
  8004218ae2:	48 8b 00             	mov    (%rax),%rax
  8004218ae5:	48 05 08 28 00 00    	add    $0x2808,%rax
  8004218aeb:	c7 00 80 3e 00 00    	movl   $0x3e80,(%rax)
	regs[E1000_RDH] = 0;
  8004218af1:	48 b8 20 17 4e 04 80 	movabs $0x80044e1720,%rax
  8004218af8:	00 00 00 
  8004218afb:	48 8b 00             	mov    (%rax),%rax
  8004218afe:	48 05 10 28 00 00    	add    $0x2810,%rax
  8004218b04:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	regs[E1000_RDT] = RX_RING_SIZE - 1;
  8004218b0a:	48 b8 20 17 4e 04 80 	movabs $0x80044e1720,%rax
  8004218b11:	00 00 00 
  8004218b14:	48 8b 00             	mov    (%rax),%rax
  8004218b17:	48 05 18 28 00 00    	add    $0x2818,%rax
  8004218b1d:	c7 00 e7 03 00 00    	movl   $0x3e7,(%rax)
	// Strip CRC because that's what the grade script expects
	regs[E1000_RCTL] = E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_SZ_2048
  8004218b23:	48 b8 20 17 4e 04 80 	movabs $0x80044e1720,%rax
  8004218b2a:	00 00 00 
  8004218b2d:	48 8b 00             	mov    (%rax),%rax
  8004218b30:	48 05 00 01 00 00    	add    $0x100,%rax
  8004218b36:	c7 00 02 80 00 04    	movl   $0x4008002,(%rax)
		| E1000_RCTL_SECRC;

	return 0;
  8004218b3c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004218b41:	c9                   	leaveq 
  8004218b42:	c3                   	retq   

0000008004218b43 <e1000_transmit>:

int
e1000_transmit(const char *buf, unsigned int len)
{
  8004218b43:	55                   	push   %rbp
  8004218b44:	48 89 e5             	mov    %rsp,%rbp
  8004218b47:	48 83 ec 20          	sub    $0x20,%rsp
  8004218b4b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004218b4f:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	if (!regs || len > DATA_MAX)
  8004218b52:	48 b8 20 17 4e 04 80 	movabs $0x80044e1720,%rax
  8004218b59:	00 00 00 
  8004218b5c:	48 8b 00             	mov    (%rax),%rax
  8004218b5f:	48 85 c0             	test   %rax,%rax
  8004218b62:	74 09                	je     8004218b6d <e1000_transmit+0x2a>
  8004218b64:	81 7d e4 ee 05 00 00 	cmpl   $0x5ee,-0x1c(%rbp)
  8004218b6b:	76 0a                	jbe    8004218b77 <e1000_transmit+0x34>
		return -E_INVAL;
  8004218b6d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8004218b72:	e9 4a 01 00 00       	jmpq   8004218cc1 <e1000_transmit+0x17e>

	int tail = regs[E1000_TDT];
  8004218b77:	48 b8 20 17 4e 04 80 	movabs $0x80044e1720,%rax
  8004218b7e:	00 00 00 
  8004218b81:	48 8b 00             	mov    (%rax),%rax
  8004218b84:	48 05 18 38 00 00    	add    $0x3818,%rax
  8004218b8a:	8b 00                	mov    (%rax),%eax
  8004218b8c:	89 45 fc             	mov    %eax,-0x4(%rbp)

	// [E1000 3.3.3.2] Check if this descriptor is done.
	// According to [E1000 13.4.39], using TDH for this is not
	// reliable.
	if (!(tx_ring[tail].status & E1000_TXD_STAT_DD)) {
  8004218b8f:	48 b8 30 17 4e 04 80 	movabs $0x80044e1730,%rax
  8004218b96:	00 00 00 
  8004218b99:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004218b9c:	48 63 d2             	movslq %edx,%rdx
  8004218b9f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218ba3:	48 01 d0             	add    %rdx,%rax
  8004218ba6:	48 83 c0 0c          	add    $0xc,%rax
  8004218baa:	0f b6 00             	movzbl (%rax),%eax
  8004218bad:	0f b6 c0             	movzbl %al,%eax
  8004218bb0:	83 e0 01             	and    $0x1,%eax
  8004218bb3:	85 c0                	test   %eax,%eax
  8004218bb5:	75 25                	jne    8004218bdc <e1000_transmit+0x99>
		cprintf("TX ring overflow\n");
  8004218bb7:	48 bf f9 1d 22 04 80 	movabs $0x8004221df9,%rdi
  8004218bbe:	00 00 00 
  8004218bc1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218bc6:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004218bcd:	00 00 00 
  8004218bd0:	ff d2                	callq  *%rdx
		return 0;
  8004218bd2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218bd7:	e9 e5 00 00 00       	jmpq   8004218cc1 <e1000_transmit+0x17e>
	}

	// Fill in the next descriptor
	memmove(tx_data[tail], buf, len);
  8004218bdc:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004218bdf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218be2:	48 98                	cltq   
  8004218be4:	48 69 c8 ee 05 00 00 	imul   $0x5ee,%rax,%rcx
  8004218beb:	48 b8 40 18 4e 04 80 	movabs $0x80044e1840,%rax
  8004218bf2:	00 00 00 
  8004218bf5:	48 01 c1             	add    %rax,%rcx
  8004218bf8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218bfc:	48 89 c6             	mov    %rax,%rsi
  8004218bff:	48 89 cf             	mov    %rcx,%rdi
  8004218c02:	48 b8 44 12 21 04 80 	movabs $0x8004211244,%rax
  8004218c09:	00 00 00 
  8004218c0c:	ff d0                	callq  *%rax
	tx_ring[tail].length = len;
  8004218c0e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004218c11:	89 c1                	mov    %eax,%ecx
  8004218c13:	48 b8 30 17 4e 04 80 	movabs $0x80044e1730,%rax
  8004218c1a:	00 00 00 
  8004218c1d:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004218c20:	48 63 d2             	movslq %edx,%rdx
  8004218c23:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218c27:	48 01 d0             	add    %rdx,%rax
  8004218c2a:	48 83 c0 08          	add    $0x8,%rax
  8004218c2e:	66 89 08             	mov    %cx,(%rax)
	tx_ring[tail].status &= ~E1000_TXD_STAT_DD;
  8004218c31:	48 b8 30 17 4e 04 80 	movabs $0x80044e1730,%rax
  8004218c38:	00 00 00 
  8004218c3b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004218c3e:	48 63 d2             	movslq %edx,%rdx
  8004218c41:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218c45:	48 01 d0             	add    %rdx,%rax
  8004218c48:	48 83 c0 0c          	add    $0xc,%rax
  8004218c4c:	0f b6 00             	movzbl (%rax),%eax
  8004218c4f:	83 e0 fe             	and    $0xfffffffe,%eax
  8004218c52:	89 c2                	mov    %eax,%edx
  8004218c54:	48 b8 30 17 4e 04 80 	movabs $0x80044e1730,%rax
  8004218c5b:	00 00 00 
  8004218c5e:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004218c61:	48 63 c9             	movslq %ecx,%rcx
  8004218c64:	48 c1 e1 04          	shl    $0x4,%rcx
  8004218c68:	48 01 c8             	add    %rcx,%rax
  8004218c6b:	48 83 c0 0c          	add    $0xc,%rax
  8004218c6f:	88 10                	mov    %dl,(%rax)
	// Set EOP to actually send this packet.  Set RS to get DD
	// status bit when sent.
	tx_ring[tail].cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;
  8004218c71:	48 b8 30 17 4e 04 80 	movabs $0x80044e1730,%rax
  8004218c78:	00 00 00 
  8004218c7b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004218c7e:	48 63 d2             	movslq %edx,%rdx
  8004218c81:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218c85:	48 01 d0             	add    %rdx,%rax
  8004218c88:	48 83 c0 0b          	add    $0xb,%rax
  8004218c8c:	c6 00 09             	movb   $0x9,(%rax)

	// Move the tail pointer
	regs[E1000_TDT] = (tail + 1) % TX_RING_SIZE;
  8004218c8f:	48 b8 20 17 4e 04 80 	movabs $0x80044e1720,%rax
  8004218c96:	00 00 00 
  8004218c99:	48 8b 00             	mov    (%rax),%rax
  8004218c9c:	48 8d 88 18 38 00 00 	lea    0x3818(%rax),%rcx
  8004218ca3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218ca6:	8d 50 01             	lea    0x1(%rax),%edx
  8004218ca9:	89 d0                	mov    %edx,%eax
  8004218cab:	c1 f8 1f             	sar    $0x1f,%eax
  8004218cae:	c1 e8 1c             	shr    $0x1c,%eax
  8004218cb1:	01 c2                	add    %eax,%edx
  8004218cb3:	83 e2 0f             	and    $0xf,%edx
  8004218cb6:	29 c2                	sub    %eax,%edx
  8004218cb8:	89 d0                	mov    %edx,%eax
  8004218cba:	89 01                	mov    %eax,(%rcx)

	return 0;
  8004218cbc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004218cc1:	c9                   	leaveq 
  8004218cc2:	c3                   	retq   

0000008004218cc3 <e1000_receive>:

int
e1000_receive(char *buf, unsigned int len)
{
  8004218cc3:	55                   	push   %rbp
  8004218cc4:	48 89 e5             	mov    %rsp,%rbp
  8004218cc7:	48 83 ec 20          	sub    $0x20,%rsp
  8004218ccb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004218ccf:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	if (!regs)
  8004218cd2:	48 b8 20 17 4e 04 80 	movabs $0x80044e1720,%rax
  8004218cd9:	00 00 00 
  8004218cdc:	48 8b 00             	mov    (%rax),%rax
  8004218cdf:	48 85 c0             	test   %rax,%rax
  8004218ce2:	75 0a                	jne    8004218cee <e1000_receive+0x2b>
		return 0;
  8004218ce4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218ce9:	e9 65 01 00 00       	jmpq   8004218e53 <e1000_receive+0x190>

	int tail = (regs[E1000_RDT] + 1) % RX_RING_SIZE;
  8004218cee:	48 b8 20 17 4e 04 80 	movabs $0x80044e1720,%rax
  8004218cf5:	00 00 00 
  8004218cf8:	48 8b 00             	mov    (%rax),%rax
  8004218cfb:	48 05 18 28 00 00    	add    $0x2818,%rax
  8004218d01:	8b 00                	mov    (%rax),%eax
  8004218d03:	8d 48 01             	lea    0x1(%rax),%ecx
  8004218d06:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8004218d0b:	89 c8                	mov    %ecx,%eax
  8004218d0d:	f7 e2                	mul    %edx
  8004218d0f:	89 d0                	mov    %edx,%eax
  8004218d11:	c1 e8 06             	shr    $0x6,%eax
  8004218d14:	69 c0 e8 03 00 00    	imul   $0x3e8,%eax,%eax
  8004218d1a:	29 c1                	sub    %eax,%ecx
  8004218d1c:	89 c8                	mov    %ecx,%eax
  8004218d1e:	89 45 fc             	mov    %eax,-0x4(%rbp)

	// Check if the descriptor has been filled
	if (!(rx_ring[tail].status & E1000_RXD_STAT_DD))
  8004218d21:	48 b8 20 77 4e 04 80 	movabs $0x80044e7720,%rax
  8004218d28:	00 00 00 
  8004218d2b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004218d2e:	48 63 d2             	movslq %edx,%rdx
  8004218d31:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218d35:	48 01 d0             	add    %rdx,%rax
  8004218d38:	48 83 c0 0c          	add    $0xc,%rax
  8004218d3c:	0f b6 00             	movzbl (%rax),%eax
  8004218d3f:	0f b6 c0             	movzbl %al,%eax
  8004218d42:	83 e0 01             	and    $0x1,%eax
  8004218d45:	85 c0                	test   %eax,%eax
  8004218d47:	75 0a                	jne    8004218d53 <e1000_receive+0x90>
		return 0;
  8004218d49:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218d4e:	e9 00 01 00 00       	jmpq   8004218e53 <e1000_receive+0x190>
	assert(rx_ring[tail].status & E1000_RXD_STAT_EOP);
  8004218d53:	48 b8 20 77 4e 04 80 	movabs $0x80044e7720,%rax
  8004218d5a:	00 00 00 
  8004218d5d:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004218d60:	48 63 d2             	movslq %edx,%rdx
  8004218d63:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218d67:	48 01 d0             	add    %rdx,%rax
  8004218d6a:	48 83 c0 0c          	add    $0xc,%rax
  8004218d6e:	0f b6 00             	movzbl (%rax),%eax
  8004218d71:	0f b6 c0             	movzbl %al,%eax
  8004218d74:	83 e0 02             	and    $0x2,%eax
  8004218d77:	85 c0                	test   %eax,%eax
  8004218d79:	75 35                	jne    8004218db0 <e1000_receive+0xed>
  8004218d7b:	48 b9 10 1e 22 04 80 	movabs $0x8004221e10,%rcx
  8004218d82:	00 00 00 
  8004218d85:	48 ba 3a 1e 22 04 80 	movabs $0x8004221e3a,%rdx
  8004218d8c:	00 00 00 
  8004218d8f:	be ef 00 00 00       	mov    $0xef,%esi
  8004218d94:	48 bf ec 1d 22 04 80 	movabs $0x8004221dec,%rdi
  8004218d9b:	00 00 00 
  8004218d9e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218da3:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004218daa:	00 00 00 
  8004218dad:	41 ff d0             	callq  *%r8

	// Copy the packet data
	len = MIN(len, rx_ring[tail].length);
  8004218db0:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004218db3:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004218db6:	48 b8 20 77 4e 04 80 	movabs $0x80044e7720,%rax
  8004218dbd:	00 00 00 
  8004218dc0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004218dc3:	48 63 d2             	movslq %edx,%rdx
  8004218dc6:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218dca:	48 01 d0             	add    %rdx,%rax
  8004218dcd:	48 83 c0 08          	add    $0x8,%rax
  8004218dd1:	0f b7 00             	movzwl (%rax),%eax
  8004218dd4:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  8004218dd8:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004218ddc:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004218ddf:	39 c2                	cmp    %eax,%edx
  8004218de1:	0f 46 c2             	cmovbe %edx,%eax
  8004218de4:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	memmove(buf, rx_data[tail], len);
  8004218de7:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004218dea:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218ded:	48 98                	cltq   
  8004218def:	48 c1 e0 0b          	shl    $0xb,%rax
  8004218df3:	48 89 c1             	mov    %rax,%rcx
  8004218df6:	48 b8 a0 b5 4e 04 80 	movabs $0x80044eb5a0,%rax
  8004218dfd:	00 00 00 
  8004218e00:	48 01 c1             	add    %rax,%rcx
  8004218e03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218e07:	48 89 ce             	mov    %rcx,%rsi
  8004218e0a:	48 89 c7             	mov    %rax,%rdi
  8004218e0d:	48 b8 44 12 21 04 80 	movabs $0x8004211244,%rax
  8004218e14:	00 00 00 
  8004218e17:	ff d0                	callq  *%rax
	rx_ring[tail].status = 0;
  8004218e19:	48 b8 20 77 4e 04 80 	movabs $0x80044e7720,%rax
  8004218e20:	00 00 00 
  8004218e23:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004218e26:	48 63 d2             	movslq %edx,%rdx
  8004218e29:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218e2d:	48 01 d0             	add    %rdx,%rax
  8004218e30:	48 83 c0 0c          	add    $0xc,%rax
  8004218e34:	c6 00 00             	movb   $0x0,(%rax)

	// Move the tail pointer
	regs[E1000_RDT] = tail;
  8004218e37:	48 b8 20 17 4e 04 80 	movabs $0x80044e1720,%rax
  8004218e3e:	00 00 00 
  8004218e41:	48 8b 00             	mov    (%rax),%rax
  8004218e44:	48 8d 90 18 28 00 00 	lea    0x2818(%rax),%rdx
  8004218e4b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218e4e:	89 02                	mov    %eax,(%rdx)
	return len;
  8004218e50:	8b 45 e4             	mov    -0x1c(%rbp),%eax
}
  8004218e53:	c9                   	leaveq 
  8004218e54:	c3                   	retq   

0000008004218e55 <pci_conf1_set_addr>:
static void
pci_conf1_set_addr(uint32_t bus,
		   uint32_t dev,
		   uint32_t func,
		   uint32_t offset)
{
  8004218e55:	55                   	push   %rbp
  8004218e56:	48 89 e5             	mov    %rsp,%rbp
  8004218e59:	48 83 ec 20          	sub    $0x20,%rsp
  8004218e5d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004218e60:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8004218e63:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  8004218e66:	89 4d e0             	mov    %ecx,-0x20(%rbp)
	assert(bus < 256);
  8004218e69:	81 7d ec ff 00 00 00 	cmpl   $0xff,-0x14(%rbp)
  8004218e70:	76 35                	jbe    8004218ea7 <pci_conf1_set_addr+0x52>
  8004218e72:	48 b9 50 1e 22 04 80 	movabs $0x8004221e50,%rcx
  8004218e79:	00 00 00 
  8004218e7c:	48 ba 5a 1e 22 04 80 	movabs $0x8004221e5a,%rdx
  8004218e83:	00 00 00 
  8004218e86:	be 31 00 00 00       	mov    $0x31,%esi
  8004218e8b:	48 bf 6f 1e 22 04 80 	movabs $0x8004221e6f,%rdi
  8004218e92:	00 00 00 
  8004218e95:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218e9a:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004218ea1:	00 00 00 
  8004218ea4:	41 ff d0             	callq  *%r8
	assert(dev < 32);
  8004218ea7:	83 7d e8 1f          	cmpl   $0x1f,-0x18(%rbp)
  8004218eab:	76 35                	jbe    8004218ee2 <pci_conf1_set_addr+0x8d>
  8004218ead:	48 b9 7a 1e 22 04 80 	movabs $0x8004221e7a,%rcx
  8004218eb4:	00 00 00 
  8004218eb7:	48 ba 5a 1e 22 04 80 	movabs $0x8004221e5a,%rdx
  8004218ebe:	00 00 00 
  8004218ec1:	be 32 00 00 00       	mov    $0x32,%esi
  8004218ec6:	48 bf 6f 1e 22 04 80 	movabs $0x8004221e6f,%rdi
  8004218ecd:	00 00 00 
  8004218ed0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218ed5:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004218edc:	00 00 00 
  8004218edf:	41 ff d0             	callq  *%r8
	assert(func < 8);
  8004218ee2:	83 7d e4 07          	cmpl   $0x7,-0x1c(%rbp)
  8004218ee6:	76 35                	jbe    8004218f1d <pci_conf1_set_addr+0xc8>
  8004218ee8:	48 b9 83 1e 22 04 80 	movabs $0x8004221e83,%rcx
  8004218eef:	00 00 00 
  8004218ef2:	48 ba 5a 1e 22 04 80 	movabs $0x8004221e5a,%rdx
  8004218ef9:	00 00 00 
  8004218efc:	be 33 00 00 00       	mov    $0x33,%esi
  8004218f01:	48 bf 6f 1e 22 04 80 	movabs $0x8004221e6f,%rdi
  8004218f08:	00 00 00 
  8004218f0b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218f10:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004218f17:	00 00 00 
  8004218f1a:	41 ff d0             	callq  *%r8
	assert(offset < 256);
  8004218f1d:	81 7d e0 ff 00 00 00 	cmpl   $0xff,-0x20(%rbp)
  8004218f24:	76 35                	jbe    8004218f5b <pci_conf1_set_addr+0x106>
  8004218f26:	48 b9 8c 1e 22 04 80 	movabs $0x8004221e8c,%rcx
  8004218f2d:	00 00 00 
  8004218f30:	48 ba 5a 1e 22 04 80 	movabs $0x8004221e5a,%rdx
  8004218f37:	00 00 00 
  8004218f3a:	be 34 00 00 00       	mov    $0x34,%esi
  8004218f3f:	48 bf 6f 1e 22 04 80 	movabs $0x8004221e6f,%rdi
  8004218f46:	00 00 00 
  8004218f49:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218f4e:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004218f55:	00 00 00 
  8004218f58:	41 ff d0             	callq  *%r8
	assert((offset & 0x3) == 0);
  8004218f5b:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004218f5e:	83 e0 03             	and    $0x3,%eax
  8004218f61:	85 c0                	test   %eax,%eax
  8004218f63:	74 35                	je     8004218f9a <pci_conf1_set_addr+0x145>
  8004218f65:	48 b9 99 1e 22 04 80 	movabs $0x8004221e99,%rcx
  8004218f6c:	00 00 00 
  8004218f6f:	48 ba 5a 1e 22 04 80 	movabs $0x8004221e5a,%rdx
  8004218f76:	00 00 00 
  8004218f79:	be 35 00 00 00       	mov    $0x35,%esi
  8004218f7e:	48 bf 6f 1e 22 04 80 	movabs $0x8004221e6f,%rdi
  8004218f85:	00 00 00 
  8004218f88:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218f8d:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004218f94:	00 00 00 
  8004218f97:	41 ff d0             	callq  *%r8

	uint32_t v = (1 << 31) |		// config-space
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
  8004218f9a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218f9d:	c1 e0 10             	shl    $0x10,%eax
  8004218fa0:	89 c2                	mov    %eax,%edx
  8004218fa2:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004218fa5:	c1 e0 0b             	shl    $0xb,%eax
  8004218fa8:	09 c2                	or     %eax,%edx
  8004218faa:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004218fad:	c1 e0 08             	shl    $0x8,%eax
  8004218fb0:	09 d0                	or     %edx,%eax
  8004218fb2:	0b 45 e0             	or     -0x20(%rbp),%eax
	assert(dev < 32);
	assert(func < 8);
	assert(offset < 256);
	assert((offset & 0x3) == 0);

	uint32_t v = (1 << 31) |		// config-space
  8004218fb5:	0d 00 00 00 80       	or     $0x80000000,%eax
  8004218fba:	89 45 fc             	mov    %eax,-0x4(%rbp)
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
	outl(pci_conf1_addr_ioport, v);
  8004218fbd:	48 b8 e4 67 23 04 80 	movabs $0x80042367e4,%rax
  8004218fc4:	00 00 00 
  8004218fc7:	8b 00                	mov    (%rax),%eax
  8004218fc9:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004218fcc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218fcf:	89 45 f4             	mov    %eax,-0xc(%rbp)
}

static __inline void
outl(int port, uint32_t data)
{
	__asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  8004218fd2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004218fd5:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004218fd8:	ef                   	out    %eax,(%dx)
}
  8004218fd9:	90                   	nop
  8004218fda:	c9                   	leaveq 
  8004218fdb:	c3                   	retq   

0000008004218fdc <pci_conf_read>:

static uint32_t
pci_conf_read(struct pci_func *f, uint32_t off)
{
  8004218fdc:	55                   	push   %rbp
  8004218fdd:	48 89 e5             	mov    %rsp,%rbp
  8004218fe0:	48 83 ec 20          	sub    $0x20,%rsp
  8004218fe4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004218fe8:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  8004218feb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218fef:	8b 50 0c             	mov    0xc(%rax),%edx
  8004218ff2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218ff6:	8b 70 08             	mov    0x8(%rax),%esi
  8004218ff9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218ffd:	48 8b 00             	mov    (%rax),%rax
  8004219000:	8b 40 08             	mov    0x8(%rax),%eax
  8004219003:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004219006:	89 c7                	mov    %eax,%edi
  8004219008:	48 b8 55 8e 21 04 80 	movabs $0x8004218e55,%rax
  800421900f:	00 00 00 
  8004219012:	ff d0                	callq  *%rax
	return inl(pci_conf1_data_ioport);
  8004219014:	48 b8 e8 67 23 04 80 	movabs $0x80042367e8,%rax
  800421901b:	00 00 00 
  800421901e:	8b 00                	mov    (%rax),%eax
  8004219020:	89 45 fc             	mov    %eax,-0x4(%rbp)

static __inline uint32_t
inl(int port)
{
	uint32_t data;
	__asm __volatile("inl %w1,%0" : "=a" (data) : "d" (port));
  8004219023:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219026:	89 c2                	mov    %eax,%edx
  8004219028:	ed                   	in     (%dx),%eax
  8004219029:	89 45 f8             	mov    %eax,-0x8(%rbp)
	return data;
  800421902c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421902f:	90                   	nop
}
  8004219030:	c9                   	leaveq 
  8004219031:	c3                   	retq   

0000008004219032 <pci_conf_write>:

static void
pci_conf_write(struct pci_func *f, uint32_t off, uint32_t v)
{
  8004219032:	55                   	push   %rbp
  8004219033:	48 89 e5             	mov    %rsp,%rbp
  8004219036:	48 83 ec 20          	sub    $0x20,%rsp
  800421903a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421903e:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  8004219041:	89 55 e0             	mov    %edx,-0x20(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  8004219044:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219048:	8b 50 0c             	mov    0xc(%rax),%edx
  800421904b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421904f:	8b 70 08             	mov    0x8(%rax),%esi
  8004219052:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219056:	48 8b 00             	mov    (%rax),%rax
  8004219059:	8b 40 08             	mov    0x8(%rax),%eax
  800421905c:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800421905f:	89 c7                	mov    %eax,%edi
  8004219061:	48 b8 55 8e 21 04 80 	movabs $0x8004218e55,%rax
  8004219068:	00 00 00 
  800421906b:	ff d0                	callq  *%rax
	outl(pci_conf1_data_ioport, v);
  800421906d:	48 b8 e8 67 23 04 80 	movabs $0x80042367e8,%rax
  8004219074:	00 00 00 
  8004219077:	8b 00                	mov    (%rax),%eax
  8004219079:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800421907c:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421907f:	89 45 f8             	mov    %eax,-0x8(%rbp)
}

static __inline void
outl(int port, uint32_t data)
{
	__asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  8004219082:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004219085:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004219088:	ef                   	out    %eax,(%dx)
}
  8004219089:	90                   	nop
  800421908a:	c9                   	leaveq 
  800421908b:	c3                   	retq   

000000800421908c <pci_attach_match>:

static int __attribute__((warn_unused_result))
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
  800421908c:	55                   	push   %rbp
  800421908d:	48 89 e5             	mov    %rsp,%rbp
  8004219090:	48 83 ec 30          	sub    $0x30,%rsp
  8004219094:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004219097:	89 75 e8             	mov    %esi,-0x18(%rbp)
  800421909a:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  800421909e:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  80042190a2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042190a9:	e9 aa 00 00 00       	jmpq   8004219158 <pci_attach_match+0xcc>
		if (list[i].key1 == key1 && list[i].key2 == key2) {
  80042190ae:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042190b1:	48 c1 e0 04          	shl    $0x4,%rax
  80042190b5:	48 89 c2             	mov    %rax,%rdx
  80042190b8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042190bc:	48 01 d0             	add    %rdx,%rax
  80042190bf:	8b 00                	mov    (%rax),%eax
  80042190c1:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  80042190c4:	0f 85 8a 00 00 00    	jne    8004219154 <pci_attach_match+0xc8>
  80042190ca:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042190cd:	48 c1 e0 04          	shl    $0x4,%rax
  80042190d1:	48 89 c2             	mov    %rax,%rdx
  80042190d4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042190d8:	48 01 d0             	add    %rdx,%rax
  80042190db:	8b 40 04             	mov    0x4(%rax),%eax
  80042190de:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  80042190e1:	75 71                	jne    8004219154 <pci_attach_match+0xc8>
			int r = list[i].attachfn(pcif);
  80042190e3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042190e6:	48 c1 e0 04          	shl    $0x4,%rax
  80042190ea:	48 89 c2             	mov    %rax,%rdx
  80042190ed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042190f1:	48 01 d0             	add    %rdx,%rax
  80042190f4:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042190f8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042190fc:	48 89 d7             	mov    %rdx,%rdi
  80042190ff:	ff d0                	callq  *%rax
  8004219101:	89 45 f8             	mov    %eax,-0x8(%rbp)
			if (r > 0)
  8004219104:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004219108:	7e 05                	jle    800421910f <pci_attach_match+0x83>
				return r;
  800421910a:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421910d:	eb 6c                	jmp    800421917b <pci_attach_match+0xef>
			if (r < 0)
  800421910f:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004219113:	79 3f                	jns    8004219154 <pci_attach_match+0xc8>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
  8004219115:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219118:	48 c1 e0 04          	shl    $0x4,%rax
  800421911c:	48 89 c2             	mov    %rax,%rdx
  800421911f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219123:	48 01 d0             	add    %rdx,%rax
		if (list[i].key1 == key1 && list[i].key2 == key2) {
			int r = list[i].attachfn(pcif);
			if (r > 0)
				return r;
			if (r < 0)
				cprintf("pci_attach_match: attaching "
  8004219126:	48 8b 48 08          	mov    0x8(%rax),%rcx
  800421912a:	8b 75 f8             	mov    -0x8(%rbp),%esi
  800421912d:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004219130:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004219133:	41 89 f0             	mov    %esi,%r8d
  8004219136:	89 c6                	mov    %eax,%esi
  8004219138:	48 bf b0 1e 22 04 80 	movabs $0x8004221eb0,%rdi
  800421913f:	00 00 00 
  8004219142:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219147:	49 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%r9
  800421914e:	00 00 00 
  8004219151:	41 ff d1             	callq  *%r9
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  8004219154:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004219158:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421915b:	48 c1 e0 04          	shl    $0x4,%rax
  800421915f:	48 89 c2             	mov    %rax,%rdx
  8004219162:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219166:	48 01 d0             	add    %rdx,%rax
  8004219169:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421916d:	48 85 c0             	test   %rax,%rax
  8004219170:	0f 85 38 ff ff ff    	jne    80042190ae <pci_attach_match+0x22>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
		}
	}
	return 0;
  8004219176:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421917b:	c9                   	leaveq 
  800421917c:	c3                   	retq   

000000800421917d <pci_attach>:

static int
pci_attach(struct pci_func *f)
{
  800421917d:	55                   	push   %rbp
  800421917e:	48 89 e5             	mov    %rsp,%rbp
  8004219181:	48 83 ec 10          	sub    $0x10,%rsp
  8004219185:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
  8004219189:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421918d:	8b 40 14             	mov    0x14(%rax),%eax
  8004219190:	c1 e8 10             	shr    $0x10,%eax

static int
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
  8004219193:	0f b6 c0             	movzbl %al,%eax
  8004219196:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421919a:	8b 52 14             	mov    0x14(%rdx),%edx
  800421919d:	89 d7                	mov    %edx,%edi
  800421919f:	c1 ef 18             	shr    $0x18,%edi
  80042191a2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042191a6:	48 89 d1             	mov    %rdx,%rcx
  80042191a9:	48 ba 00 68 23 04 80 	movabs $0x8004236800,%rdx
  80042191b0:	00 00 00 
  80042191b3:	89 c6                	mov    %eax,%esi
  80042191b5:	48 b8 8c 90 21 04 80 	movabs $0x800421908c,%rax
  80042191bc:	00 00 00 
  80042191bf:	ff d0                	callq  *%rax
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
  80042191c1:	85 c0                	test   %eax,%eax
  80042191c3:	75 39                	jne    80042191fe <pci_attach+0x81>
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
  80042191c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042191c9:	8b 40 10             	mov    0x10(%rax),%eax
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
		pci_attach_match(PCI_VENDOR(f->dev_id),
  80042191cc:	c1 e8 10             	shr    $0x10,%eax
  80042191cf:	89 c6                	mov    %eax,%esi
  80042191d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042191d5:	8b 40 10             	mov    0x10(%rax),%eax
  80042191d8:	0f b7 c0             	movzwl %ax,%eax
  80042191db:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042191df:	48 89 d1             	mov    %rdx,%rcx
  80042191e2:	48 ba 20 68 23 04 80 	movabs $0x8004236820,%rdx
  80042191e9:	00 00 00 
  80042191ec:	89 c7                	mov    %eax,%edi
  80042191ee:	48 b8 8c 90 21 04 80 	movabs $0x800421908c,%rax
  80042191f5:	00 00 00 
  80042191f8:	ff d0                	callq  *%rax
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
  80042191fa:	85 c0                	test   %eax,%eax
  80042191fc:	74 07                	je     8004219205 <pci_attach+0x88>
  80042191fe:	b8 01 00 00 00       	mov    $0x1,%eax
  8004219203:	eb 05                	jmp    800421920a <pci_attach+0x8d>
  8004219205:	b8 00 00 00 00       	mov    $0x0,%eax
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
				 &pci_attach_vendor[0], f);
}
  800421920a:	c9                   	leaveq 
  800421920b:	c3                   	retq   

000000800421920c <pci_print_func>:
	[0x6] = "Bridge device",
};

static void
pci_print_func(struct pci_func *f)
{
  800421920c:	55                   	push   %rbp
  800421920d:	48 89 e5             	mov    %rsp,%rbp
  8004219210:	48 83 ec 20          	sub    $0x20,%rsp
  8004219214:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	const char *class = pci_class[0];
  8004219218:	48 b8 40 68 23 04 80 	movabs $0x8004236840,%rax
  800421921f:	00 00 00 
  8004219222:	48 8b 00             	mov    (%rax),%rax
  8004219225:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
  8004219229:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421922d:	8b 40 14             	mov    0x14(%rax),%eax
  8004219230:	c1 e8 18             	shr    $0x18,%eax
  8004219233:	83 f8 06             	cmp    $0x6,%eax
  8004219236:	77 20                	ja     8004219258 <pci_print_func+0x4c>
		class = pci_class[PCI_CLASS(f->dev_class)];
  8004219238:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421923c:	8b 40 14             	mov    0x14(%rax),%eax
  800421923f:	c1 e8 18             	shr    $0x18,%eax
  8004219242:	89 c2                	mov    %eax,%edx
  8004219244:	48 b8 40 68 23 04 80 	movabs $0x8004236840,%rax
  800421924b:	00 00 00 
  800421924e:	89 d2                	mov    %edx,%edx
  8004219250:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004219254:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
  8004219258:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421925c:	0f b6 40 48          	movzbl 0x48(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004219260:	0f b6 f8             	movzbl %al,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  8004219263:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219267:	8b 40 14             	mov    0x14(%rax),%eax
  800421926a:	c1 e8 10             	shr    $0x10,%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  800421926d:	0f b6 f0             	movzbl %al,%esi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  8004219270:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219274:	8b 40 14             	mov    0x14(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004219277:	c1 e8 18             	shr    $0x18,%eax
  800421927a:	41 89 c1             	mov    %eax,%r9d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  800421927d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219281:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004219284:	c1 e8 10             	shr    $0x10,%eax
  8004219287:	41 89 c2             	mov    %eax,%r10d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  800421928a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421928e:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004219291:	44 0f b7 c0          	movzwl %ax,%r8d
  8004219295:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219299:	8b 48 0c             	mov    0xc(%rax),%ecx
  800421929c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042192a0:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  80042192a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042192a7:	48 8b 00             	mov    (%rax),%rax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  80042192aa:	8b 40 08             	mov    0x8(%rax),%eax
  80042192ad:	57                   	push   %rdi
  80042192ae:	ff 75 f8             	pushq  -0x8(%rbp)
  80042192b1:	56                   	push   %rsi
  80042192b2:	41 51                	push   %r9
  80042192b4:	45 89 d1             	mov    %r10d,%r9d
  80042192b7:	89 c6                	mov    %eax,%esi
  80042192b9:	48 bf 50 1f 22 04 80 	movabs $0x8004221f50,%rdi
  80042192c0:	00 00 00 
  80042192c3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042192c8:	49 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%r10
  80042192cf:	00 00 00 
  80042192d2:	41 ff d2             	callq  *%r10
  80042192d5:	48 83 c4 20          	add    $0x20,%rsp
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
}
  80042192d9:	90                   	nop
  80042192da:	c9                   	leaveq 
  80042192db:	c3                   	retq   

00000080042192dc <pci_scan_bus>:

static int
pci_scan_bus(struct pci_bus *bus)
{
  80042192dc:	55                   	push   %rbp
  80042192dd:	48 89 e5             	mov    %rsp,%rbp
  80042192e0:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  80042192e7:	48 89 bd f8 fe ff ff 	mov    %rdi,-0x108(%rbp)
	int totaldev = 0;
  80042192ee:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct pci_func df;
	memset(&df, 0, sizeof(df));
  80042192f5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042192f9:	ba 50 00 00 00       	mov    $0x50,%edx
  80042192fe:	be 00 00 00 00       	mov    $0x0,%esi
  8004219303:	48 89 c7             	mov    %rax,%rdi
  8004219306:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  800421930d:	00 00 00 
  8004219310:	ff d0                	callq  *%rax
	df.bus = bus;
  8004219312:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004219319:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

	for (df.dev = 0; df.dev < 32; df.dev++) {
  800421931d:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%rbp)
  8004219324:	e9 29 02 00 00       	jmpq   8004219552 <pci_scan_bus+0x276>
		uint32_t bhlc = pci_conf_read(&df, PCI_BHLC_REG);
  8004219329:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421932d:	be 0c 00 00 00       	mov    $0xc,%esi
  8004219332:	48 89 c7             	mov    %rax,%rdi
  8004219335:	48 b8 dc 8f 21 04 80 	movabs $0x8004218fdc,%rax
  800421933c:	00 00 00 
  800421933f:	ff d0                	callq  *%rax
  8004219341:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (PCI_HDRTYPE_TYPE(bhlc) > 1)	    // Unsupported or no device
  8004219344:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004219347:	c1 e8 10             	shr    $0x10,%eax
  800421934a:	83 e0 7f             	and    $0x7f,%eax
  800421934d:	83 f8 01             	cmp    $0x1,%eax
  8004219350:	0f 87 f2 01 00 00    	ja     8004219548 <pci_scan_bus+0x26c>
			continue;

		totaldev++;
  8004219356:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)

		struct pci_func f = df;
  800421935a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421935e:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  8004219365:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004219369:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  8004219370:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004219374:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  800421937b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421937f:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  8004219386:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421938a:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  8004219391:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004219395:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  800421939c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042193a0:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  80042193a7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042193ab:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  80042193b2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042193b6:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042193bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042193c1:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  80042193c8:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%rbp)
  80042193cf:	00 00 00 
  80042193d2:	e9 48 01 00 00       	jmpq   800421951f <pci_scan_bus+0x243>
		     f.func++) {
			struct pci_func af = f;
  80042193d7:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  80042193de:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  80042193e5:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  80042193ec:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  80042193f3:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042193fa:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  8004219401:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004219408:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  800421940f:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  8004219416:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  800421941d:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004219424:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  800421942b:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  8004219432:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  8004219436:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  800421943d:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004219441:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004219448:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  800421944c:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004219453:	48 89 45 98          	mov    %rax,-0x68(%rbp)

			af.dev_id = pci_conf_read(&f, PCI_ID_REG);
  8004219457:	48 8d 85 00 ff ff ff 	lea    -0x100(%rbp),%rax
  800421945e:	be 00 00 00 00       	mov    $0x0,%esi
  8004219463:	48 89 c7             	mov    %rax,%rdi
  8004219466:	48 b8 dc 8f 21 04 80 	movabs $0x8004218fdc,%rax
  800421946d:	00 00 00 
  8004219470:	ff d0                	callq  *%rax
  8004219472:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
			if (PCI_VENDOR(af.dev_id) == 0xffff)
  8004219478:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
  800421947e:	0f b7 c0             	movzwl %ax,%eax
  8004219481:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004219486:	0f 84 83 00 00 00    	je     800421950f <pci_scan_bus+0x233>
				continue;

			uint32_t intr = pci_conf_read(&af, PCI_INTERRUPT_REG);
  800421948c:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004219493:	be 3c 00 00 00       	mov    $0x3c,%esi
  8004219498:	48 89 c7             	mov    %rax,%rdi
  800421949b:	48 b8 dc 8f 21 04 80 	movabs $0x8004218fdc,%rax
  80042194a2:	00 00 00 
  80042194a5:	ff d0                	callq  *%rax
  80042194a7:	89 45 f4             	mov    %eax,-0xc(%rbp)
			af.irq_line = PCI_INTERRUPT_LINE(intr);
  80042194aa:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042194ad:	88 45 98             	mov    %al,-0x68(%rbp)

			af.dev_class = pci_conf_read(&af, PCI_CLASS_REG);
  80042194b0:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042194b7:	be 08 00 00 00       	mov    $0x8,%esi
  80042194bc:	48 89 c7             	mov    %rax,%rdi
  80042194bf:	48 b8 dc 8f 21 04 80 	movabs $0x8004218fdc,%rax
  80042194c6:	00 00 00 
  80042194c9:	ff d0                	callq  *%rax
  80042194cb:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%rbp)
			if (pci_show_devs)
  80042194d1:	48 b8 e0 67 23 04 80 	movabs $0x80042367e0,%rax
  80042194d8:	00 00 00 
  80042194db:	8b 00                	mov    (%rax),%eax
  80042194dd:	85 c0                	test   %eax,%eax
  80042194df:	74 16                	je     80042194f7 <pci_scan_bus+0x21b>
				pci_print_func(&af);
  80042194e1:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042194e8:	48 89 c7             	mov    %rax,%rdi
  80042194eb:	48 b8 0c 92 21 04 80 	movabs $0x800421920c,%rax
  80042194f2:	00 00 00 
  80042194f5:	ff d0                	callq  *%rax
			pci_attach(&af);
  80042194f7:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042194fe:	48 89 c7             	mov    %rax,%rdi
  8004219501:	48 b8 7d 91 21 04 80 	movabs $0x800421917d,%rax
  8004219508:	00 00 00 
  800421950b:	ff d0                	callq  *%rax
  800421950d:	eb 01                	jmp    8004219510 <pci_scan_bus+0x234>
		     f.func++) {
			struct pci_func af = f;

			af.dev_id = pci_conf_read(&f, PCI_ID_REG);
			if (PCI_VENDOR(af.dev_id) == 0xffff)
				continue;
  800421950f:	90                   	nop

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
		     f.func++) {
  8004219510:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  8004219516:	83 c0 01             	add    $0x1,%eax
  8004219519:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
			continue;

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  800421951f:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  8004219525:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004219528:	81 e2 00 00 80 00    	and    $0x800000,%edx
  800421952e:	85 d2                	test   %edx,%edx
  8004219530:	74 07                	je     8004219539 <pci_scan_bus+0x25d>
  8004219532:	ba 08 00 00 00       	mov    $0x8,%edx
  8004219537:	eb 05                	jmp    800421953e <pci_scan_bus+0x262>
  8004219539:	ba 01 00 00 00       	mov    $0x1,%edx
  800421953e:	39 d0                	cmp    %edx,%eax
  8004219540:	0f 82 91 fe ff ff    	jb     80042193d7 <pci_scan_bus+0xfb>
  8004219546:	eb 01                	jmp    8004219549 <pci_scan_bus+0x26d>
	df.bus = bus;

	for (df.dev = 0; df.dev < 32; df.dev++) {
		uint32_t bhlc = pci_conf_read(&df, PCI_BHLC_REG);
		if (PCI_HDRTYPE_TYPE(bhlc) > 1)	    // Unsupported or no device
			continue;
  8004219548:	90                   	nop
	int totaldev = 0;
	struct pci_func df;
	memset(&df, 0, sizeof(df));
	df.bus = bus;

	for (df.dev = 0; df.dev < 32; df.dev++) {
  8004219549:	8b 45 a8             	mov    -0x58(%rbp),%eax
  800421954c:	83 c0 01             	add    $0x1,%eax
  800421954f:	89 45 a8             	mov    %eax,-0x58(%rbp)
  8004219552:	8b 45 a8             	mov    -0x58(%rbp),%eax
  8004219555:	83 f8 1f             	cmp    $0x1f,%eax
  8004219558:	0f 86 cb fd ff ff    	jbe    8004219329 <pci_scan_bus+0x4d>
				pci_print_func(&af);
			pci_attach(&af);
		}
	}

	return totaldev;
  800421955e:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004219561:	c9                   	leaveq 
  8004219562:	c3                   	retq   

0000008004219563 <pci_bridge_attach>:

static int
pci_bridge_attach(struct pci_func *pcif)
{
  8004219563:	55                   	push   %rbp
  8004219564:	48 89 e5             	mov    %rsp,%rbp
  8004219567:	48 83 ec 30          	sub    $0x30,%rsp
  800421956b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
  800421956f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219573:	be 1c 00 00 00       	mov    $0x1c,%esi
  8004219578:	48 89 c7             	mov    %rax,%rdi
  800421957b:	48 b8 dc 8f 21 04 80 	movabs $0x8004218fdc,%rax
  8004219582:	00 00 00 
  8004219585:	ff d0                	callq  *%rax
  8004219587:	89 45 fc             	mov    %eax,-0x4(%rbp)
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);
  800421958a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421958e:	be 18 00 00 00       	mov    $0x18,%esi
  8004219593:	48 89 c7             	mov    %rax,%rdi
  8004219596:	48 b8 dc 8f 21 04 80 	movabs $0x8004218fdc,%rax
  800421959d:	00 00 00 
  80042195a0:	ff d0                	callq  *%rax
  80042195a2:	89 45 f8             	mov    %eax,-0x8(%rbp)

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
  80042195a5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042195a8:	83 e0 0f             	and    $0xf,%eax
  80042195ab:	83 f8 01             	cmp    $0x1,%eax
  80042195ae:	75 40                	jne    80042195f0 <pci_bridge_attach+0x8d>
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  80042195b0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042195b4:	8b 48 0c             	mov    0xc(%rax),%ecx
  80042195b7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042195bb:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func);
  80042195be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042195c2:	48 8b 00             	mov    (%rax),%rax
{
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  80042195c5:	8b 40 08             	mov    0x8(%rax),%eax
  80042195c8:	89 c6                	mov    %eax,%esi
  80042195ca:	48 bf 90 1f 22 04 80 	movabs $0x8004221f90,%rdi
  80042195d1:	00 00 00 
  80042195d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042195d9:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  80042195e0:	00 00 00 
  80042195e3:	41 ff d0             	callq  *%r8
			pcif->bus->busno, pcif->dev, pcif->func);
		return 0;
  80042195e6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042195eb:	e9 a1 00 00 00       	jmpq   8004219691 <pci_bridge_attach+0x12e>
	}

	struct pci_bus nbus;
	memset(&nbus, 0, sizeof(nbus));
  80042195f0:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80042195f4:	ba 10 00 00 00       	mov    $0x10,%edx
  80042195f9:	be 00 00 00 00       	mov    $0x0,%esi
  80042195fe:	48 89 c7             	mov    %rax,%rdi
  8004219601:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  8004219608:	00 00 00 
  800421960b:	ff d0                	callq  *%rax
	nbus.parent_bridge = pcif;
  800421960d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219611:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;
  8004219615:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004219618:	c1 e8 08             	shr    $0x8,%eax
  800421961b:	0f b6 c0             	movzbl %al,%eax
  800421961e:	89 45 e8             	mov    %eax,-0x18(%rbp)

	if (pci_show_devs)
  8004219621:	48 b8 e0 67 23 04 80 	movabs $0x80042367e0,%rax
  8004219628:	00 00 00 
  800421962b:	8b 00                	mov    (%rax),%eax
  800421962d:	85 c0                	test   %eax,%eax
  800421962f:	74 48                	je     8004219679 <pci_bridge_attach+0x116>
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);
  8004219631:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004219634:	c1 e8 10             	shr    $0x10,%eax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  8004219637:	0f b6 f8             	movzbl %al,%edi
  800421963a:	8b 75 e8             	mov    -0x18(%rbp),%esi
  800421963d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219641:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004219644:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219648:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func,
  800421964b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421964f:	48 8b 00             	mov    (%rax),%rax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  8004219652:	8b 40 08             	mov    0x8(%rax),%eax
  8004219655:	41 89 f9             	mov    %edi,%r9d
  8004219658:	41 89 f0             	mov    %esi,%r8d
  800421965b:	89 c6                	mov    %eax,%esi
  800421965d:	48 bf c8 1f 22 04 80 	movabs $0x8004221fc8,%rdi
  8004219664:	00 00 00 
  8004219667:	b8 00 00 00 00       	mov    $0x0,%eax
  800421966c:	49 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%r10
  8004219673:	00 00 00 
  8004219676:	41 ff d2             	callq  *%r10
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);

	pci_scan_bus(&nbus);
  8004219679:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800421967d:	48 89 c7             	mov    %rax,%rdi
  8004219680:	48 b8 dc 92 21 04 80 	movabs $0x80042192dc,%rax
  8004219687:	00 00 00 
  800421968a:	ff d0                	callq  *%rax
	return 1;
  800421968c:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004219691:	c9                   	leaveq 
  8004219692:	c3                   	retq   

0000008004219693 <pci_func_enable>:

// External PCI subsystem interface

void
pci_func_enable(struct pci_func *f)
{
  8004219693:	55                   	push   %rbp
  8004219694:	48 89 e5             	mov    %rsp,%rbp
  8004219697:	48 83 ec 30          	sub    $0x30,%rsp
  800421969b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	pci_conf_write(f, PCI_COMMAND_STATUS_REG,
  800421969f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042196a3:	ba 07 00 00 00       	mov    $0x7,%edx
  80042196a8:	be 04 00 00 00       	mov    $0x4,%esi
  80042196ad:	48 89 c7             	mov    %rax,%rdi
  80042196b0:	48 b8 32 90 21 04 80 	movabs $0x8004219032,%rax
  80042196b7:	00 00 00 
  80042196ba:	ff d0                	callq  *%rax
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  80042196bc:	c7 45 f8 10 00 00 00 	movl   $0x10,-0x8(%rbp)
  80042196c3:	e9 f0 01 00 00       	jmpq   80042198b8 <pci_func_enable+0x225>
	     bar += bar_width)
	{
		uint32_t oldv = pci_conf_read(f, bar);
  80042196c8:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80042196cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042196cf:	89 d6                	mov    %edx,%esi
  80042196d1:	48 89 c7             	mov    %rax,%rdi
  80042196d4:	48 b8 dc 8f 21 04 80 	movabs $0x8004218fdc,%rax
  80042196db:	00 00 00 
  80042196de:	ff d0                	callq  *%rax
  80042196e0:	89 45 ec             	mov    %eax,-0x14(%rbp)

		bar_width = 4;
  80042196e3:	c7 45 fc 04 00 00 00 	movl   $0x4,-0x4(%rbp)
		pci_conf_write(f, bar, 0xffffffff);
  80042196ea:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  80042196ed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042196f1:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80042196f6:	89 ce                	mov    %ecx,%esi
  80042196f8:	48 89 c7             	mov    %rax,%rdi
  80042196fb:	48 b8 32 90 21 04 80 	movabs $0x8004219032,%rax
  8004219702:	00 00 00 
  8004219705:	ff d0                	callq  *%rax
		uint32_t rv = pci_conf_read(f, bar);
  8004219707:	8b 55 f8             	mov    -0x8(%rbp),%edx
  800421970a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421970e:	89 d6                	mov    %edx,%esi
  8004219710:	48 89 c7             	mov    %rax,%rdi
  8004219713:	48 b8 dc 8f 21 04 80 	movabs $0x8004218fdc,%rax
  800421971a:	00 00 00 
  800421971d:	ff d0                	callq  *%rax
  800421971f:	89 45 e8             	mov    %eax,-0x18(%rbp)

		if (rv == 0)
  8004219722:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  8004219726:	0f 84 85 01 00 00    	je     80042198b1 <pci_func_enable+0x21e>
			continue;

		int regnum = PCI_MAPREG_NUM(bar);
  800421972c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421972f:	83 e8 10             	sub    $0x10,%eax
  8004219732:	c1 e8 02             	shr    $0x2,%eax
  8004219735:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		uint32_t base, size;
		if (PCI_MAPREG_TYPE(rv) == PCI_MAPREG_TYPE_MEM) {
  8004219738:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421973b:	83 e0 01             	and    $0x1,%eax
  800421973e:	85 c0                	test   %eax,%eax
  8004219740:	75 65                	jne    80042197a7 <pci_func_enable+0x114>
			if (PCI_MAPREG_MEM_TYPE(rv) == PCI_MAPREG_MEM_TYPE_64BIT)
  8004219742:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004219745:	83 e0 06             	and    $0x6,%eax
  8004219748:	83 f8 04             	cmp    $0x4,%eax
  800421974b:	75 07                	jne    8004219754 <pci_func_enable+0xc1>
				bar_width = 8;
  800421974d:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%rbp)

			size = PCI_MAPREG_MEM_SIZE(rv);
  8004219754:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004219757:	83 e0 f0             	and    $0xfffffff0,%eax
  800421975a:	f7 d8                	neg    %eax
  800421975c:	23 45 e8             	and    -0x18(%rbp),%eax
  800421975f:	83 e0 f0             	and    $0xfffffff0,%eax
  8004219762:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_MEM_ADDR(oldv);
  8004219765:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004219768:	83 e0 f0             	and    $0xfffffff0,%eax
  800421976b:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  800421976e:	48 b8 a0 f5 6d 04 80 	movabs $0x80046df5a0,%rax
  8004219775:	00 00 00 
  8004219778:	8b 00                	mov    (%rax),%eax
  800421977a:	85 c0                	test   %eax,%eax
  800421977c:	74 7a                	je     80042197f8 <pci_func_enable+0x165>
				cprintf("  mem region %d: %d bytes at 0x%x\n",
  800421977e:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004219781:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004219784:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004219787:	89 c6                	mov    %eax,%esi
  8004219789:	48 bf f8 1f 22 04 80 	movabs $0x8004221ff8,%rdi
  8004219790:	00 00 00 
  8004219793:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219798:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421979f:	00 00 00 
  80042197a2:	41 ff d0             	callq  *%r8
  80042197a5:	eb 51                	jmp    80042197f8 <pci_func_enable+0x165>
					regnum, size, base);
		} else {
			size = PCI_MAPREG_IO_SIZE(rv);
  80042197a7:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042197aa:	83 e0 fc             	and    $0xfffffffc,%eax
  80042197ad:	f7 d8                	neg    %eax
  80042197af:	23 45 e8             	and    -0x18(%rbp),%eax
  80042197b2:	83 e0 fc             	and    $0xfffffffc,%eax
  80042197b5:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_IO_ADDR(oldv);
  80042197b8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042197bb:	83 e0 fc             	and    $0xfffffffc,%eax
  80042197be:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  80042197c1:	48 b8 a0 f5 6d 04 80 	movabs $0x80046df5a0,%rax
  80042197c8:	00 00 00 
  80042197cb:	8b 00                	mov    (%rax),%eax
  80042197cd:	85 c0                	test   %eax,%eax
  80042197cf:	74 27                	je     80042197f8 <pci_func_enable+0x165>
				cprintf("  io region %d: %d bytes at 0x%x\n",
  80042197d1:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80042197d4:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042197d7:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042197da:	89 c6                	mov    %eax,%esi
  80042197dc:	48 bf 20 20 22 04 80 	movabs $0x8004222020,%rdi
  80042197e3:	00 00 00 
  80042197e6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042197eb:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  80042197f2:	00 00 00 
  80042197f5:	41 ff d0             	callq  *%r8
					regnum, size, base);
		}

		pci_conf_write(f, bar, oldv);
  80042197f8:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042197fb:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  80042197fe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219802:	89 ce                	mov    %ecx,%esi
  8004219804:	48 89 c7             	mov    %rax,%rdi
  8004219807:	48 b8 32 90 21 04 80 	movabs $0x8004219032,%rax
  800421980e:	00 00 00 
  8004219811:	ff d0                	callq  *%rax
		f->reg_base[regnum] = base;
  8004219813:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219817:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800421981a:	48 63 d2             	movslq %edx,%rdx
  800421981d:	48 8d 4a 04          	lea    0x4(%rdx),%rcx
  8004219821:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004219824:	89 54 88 08          	mov    %edx,0x8(%rax,%rcx,4)
		f->reg_size[regnum] = size;
  8004219828:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421982c:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800421982f:	48 63 d2             	movslq %edx,%rdx
  8004219832:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  8004219836:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004219839:	89 14 88             	mov    %edx,(%rax,%rcx,4)

		if (size && !base)
  800421983c:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8004219840:	74 70                	je     80042198b2 <pci_func_enable+0x21f>
  8004219842:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004219846:	75 6a                	jne    80042198b2 <pci_func_enable+0x21f>
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004219848:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421984c:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  800421984f:	c1 e8 10             	shr    $0x10,%eax
  8004219852:	41 89 c0             	mov    %eax,%r8d
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004219855:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219859:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  800421985c:	0f b7 f8             	movzwl %ax,%edi
  800421985f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219863:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004219866:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421986a:	8b 50 08             	mov    0x8(%rax),%edx
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
  800421986d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219871:	48 8b 00             	mov    (%rax),%rax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004219874:	8b 40 08             	mov    0x8(%rax),%eax
  8004219877:	48 83 ec 08          	sub    $0x8,%rsp
  800421987b:	8b 75 f0             	mov    -0x10(%rbp),%esi
  800421987e:	56                   	push   %rsi
  800421987f:	8b 75 f4             	mov    -0xc(%rbp),%esi
  8004219882:	56                   	push   %rsi
  8004219883:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  8004219886:	56                   	push   %rsi
  8004219887:	45 89 c1             	mov    %r8d,%r9d
  800421988a:	41 89 f8             	mov    %edi,%r8d
  800421988d:	89 c6                	mov    %eax,%esi
  800421988f:	48 bf 48 20 22 04 80 	movabs $0x8004222048,%rdi
  8004219896:	00 00 00 
  8004219899:	b8 00 00 00 00       	mov    $0x0,%eax
  800421989e:	49 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%r10
  80042198a5:	00 00 00 
  80042198a8:	41 ff d2             	callq  *%r10
  80042198ab:	48 83 c4 20          	add    $0x20,%rsp
  80042198af:	eb 01                	jmp    80042198b2 <pci_func_enable+0x21f>
		bar_width = 4;
		pci_conf_write(f, bar, 0xffffffff);
		uint32_t rv = pci_conf_read(f, bar);

		if (rv == 0)
			continue;
  80042198b1:	90                   	nop
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
	     bar += bar_width)
  80042198b2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042198b5:	01 45 f8             	add    %eax,-0x8(%rbp)
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  80042198b8:	83 7d f8 27          	cmpl   $0x27,-0x8(%rbp)
  80042198bc:	0f 86 06 fe ff ff    	jbe    80042196c8 <pci_func_enable+0x35>
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  80042198c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042198c6:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  80042198c9:	c1 e8 10             	shr    $0x10,%eax
  80042198cc:	89 c7                	mov    %eax,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  80042198ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042198d2:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  80042198d5:	0f b7 f0             	movzwl %ax,%esi
  80042198d8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042198dc:	8b 48 0c             	mov    0xc(%rax),%ecx
  80042198df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042198e3:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  80042198e6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042198ea:	48 8b 00             	mov    (%rax),%rax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  80042198ed:	8b 40 08             	mov    0x8(%rax),%eax
  80042198f0:	41 89 f9             	mov    %edi,%r9d
  80042198f3:	41 89 f0             	mov    %esi,%r8d
  80042198f6:	89 c6                	mov    %eax,%esi
  80042198f8:	48 bf a8 20 22 04 80 	movabs $0x80042220a8,%rdi
  80042198ff:	00 00 00 
  8004219902:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219907:	49 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%r10
  800421990e:	00 00 00 
  8004219911:	41 ff d2             	callq  *%r10
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
}
  8004219914:	90                   	nop
  8004219915:	c9                   	leaveq 
  8004219916:	c3                   	retq   

0000008004219917 <pci_init>:

int
pci_init(void)
{
  8004219917:	55                   	push   %rbp
  8004219918:	48 89 e5             	mov    %rsp,%rbp
	static struct pci_bus root_bus;
	memset(&root_bus, 0, sizeof(root_bus));
  800421991b:	ba 10 00 00 00       	mov    $0x10,%edx
  8004219920:	be 00 00 00 00       	mov    $0x0,%esi
  8004219925:	48 bf b0 f5 6d 04 80 	movabs $0x80046df5b0,%rdi
  800421992c:	00 00 00 
  800421992f:	48 b8 b9 11 21 04 80 	movabs $0x80042111b9,%rax
  8004219936:	00 00 00 
  8004219939:	ff d0                	callq  *%rax

	return pci_scan_bus(&root_bus);
  800421993b:	48 bf b0 f5 6d 04 80 	movabs $0x80046df5b0,%rdi
  8004219942:	00 00 00 
  8004219945:	48 b8 dc 92 21 04 80 	movabs $0x80042192dc,%rax
  800421994c:	00 00 00 
  800421994f:	ff d0                	callq  *%rax
}
  8004219951:	5d                   	pop    %rbp
  8004219952:	c3                   	retq   

0000008004219953 <time_init>:

static unsigned int ticks;

void
time_init(void)
{
  8004219953:	55                   	push   %rbp
  8004219954:	48 89 e5             	mov    %rsp,%rbp
	ticks = 0;
  8004219957:	48 b8 c0 f5 6d 04 80 	movabs $0x80046df5c0,%rax
  800421995e:	00 00 00 
  8004219961:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
  8004219967:	90                   	nop
  8004219968:	5d                   	pop    %rbp
  8004219969:	c3                   	retq   

000000800421996a <time_tick>:

// This should be called once per timer interrupt.  A timer interrupt
// fires every 10 ms.
void
time_tick(void)
{
  800421996a:	55                   	push   %rbp
  800421996b:	48 89 e5             	mov    %rsp,%rbp
	ticks++;
  800421996e:	48 b8 c0 f5 6d 04 80 	movabs $0x80046df5c0,%rax
  8004219975:	00 00 00 
  8004219978:	8b 00                	mov    (%rax),%eax
  800421997a:	8d 50 01             	lea    0x1(%rax),%edx
  800421997d:	48 b8 c0 f5 6d 04 80 	movabs $0x80046df5c0,%rax
  8004219984:	00 00 00 
  8004219987:	89 10                	mov    %edx,(%rax)
	if (ticks * 10 < ticks)
  8004219989:	48 b8 c0 f5 6d 04 80 	movabs $0x80046df5c0,%rax
  8004219990:	00 00 00 
  8004219993:	8b 10                	mov    (%rax),%edx
  8004219995:	89 d0                	mov    %edx,%eax
  8004219997:	c1 e0 02             	shl    $0x2,%eax
  800421999a:	01 d0                	add    %edx,%eax
  800421999c:	01 c0                	add    %eax,%eax
  800421999e:	89 c2                	mov    %eax,%edx
  80042199a0:	48 b8 c0 f5 6d 04 80 	movabs $0x80046df5c0,%rax
  80042199a7:	00 00 00 
  80042199aa:	8b 00                	mov    (%rax),%eax
  80042199ac:	39 c2                	cmp    %eax,%edx
  80042199ae:	73 2a                	jae    80042199da <time_tick+0x70>
		panic("time_tick: time overflowed");
  80042199b0:	48 ba d7 20 22 04 80 	movabs $0x80042220d7,%rdx
  80042199b7:	00 00 00 
  80042199ba:	be 14 00 00 00       	mov    $0x14,%esi
  80042199bf:	48 bf f2 20 22 04 80 	movabs $0x80042220f2,%rdi
  80042199c6:	00 00 00 
  80042199c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042199ce:	48 b9 d3 04 20 04 80 	movabs $0x80042004d3,%rcx
  80042199d5:	00 00 00 
  80042199d8:	ff d1                	callq  *%rcx
}
  80042199da:	90                   	nop
  80042199db:	5d                   	pop    %rbp
  80042199dc:	c3                   	retq   

00000080042199dd <time_msec>:

unsigned int
time_msec(void)
{
  80042199dd:	55                   	push   %rbp
  80042199de:	48 89 e5             	mov    %rsp,%rbp
	return ticks * 10;
  80042199e1:	48 b8 c0 f5 6d 04 80 	movabs $0x80046df5c0,%rax
  80042199e8:	00 00 00 
  80042199eb:	8b 10                	mov    (%rax),%edx
  80042199ed:	89 d0                	mov    %edx,%eax
  80042199ef:	c1 e0 02             	shl    $0x2,%eax
  80042199f2:	01 d0                	add    %edx,%eax
  80042199f4:	01 c0                	add    %eax,%eax
}
  80042199f6:	5d                   	pop    %rbp
  80042199f7:	c3                   	retq   

00000080042199f8 <page2ppn>:
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);


static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  80042199f8:	55                   	push   %rbp
  80042199f9:	48 89 e5             	mov    %rsp,%rbp
  80042199fc:	48 83 ec 08          	sub    $0x8,%rsp
  8004219a00:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004219a04:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004219a08:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  8004219a0f:	00 00 00 
  8004219a12:	48 8b 00             	mov    (%rax),%rax
  8004219a15:	48 29 c2             	sub    %rax,%rdx
  8004219a18:	48 89 d0             	mov    %rdx,%rax
  8004219a1b:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004219a1f:	c9                   	leaveq 
  8004219a20:	c3                   	retq   

0000008004219a21 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004219a21:	55                   	push   %rbp
  8004219a22:	48 89 e5             	mov    %rsp,%rbp
  8004219a25:	48 83 ec 08          	sub    $0x8,%rsp
  8004219a29:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004219a2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004219a31:	48 89 c7             	mov    %rax,%rdi
  8004219a34:	48 b8 f8 99 21 04 80 	movabs $0x80042199f8,%rax
  8004219a3b:	00 00 00 
  8004219a3e:	ff d0                	callq  *%rax
  8004219a40:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004219a44:	c9                   	leaveq 
  8004219a45:	c3                   	retq   

0000008004219a46 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004219a46:	55                   	push   %rbp
  8004219a47:	48 89 e5             	mov    %rsp,%rbp
  8004219a4a:	48 83 ec 10          	sub    $0x10,%rsp
  8004219a4e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004219a52:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004219a56:	48 c1 e8 0c          	shr    $0xc,%rax
  8004219a5a:	48 89 c2             	mov    %rax,%rdx
  8004219a5d:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004219a64:	00 00 00 
  8004219a67:	48 8b 00             	mov    (%rax),%rax
  8004219a6a:	48 39 c2             	cmp    %rax,%rdx
  8004219a6d:	72 2a                	jb     8004219a99 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004219a6f:	48 ba 00 21 22 04 80 	movabs $0x8004222100,%rdx
  8004219a76:	00 00 00 
  8004219a79:	be 5a 00 00 00       	mov    $0x5a,%esi
  8004219a7e:	48 bf 1f 21 22 04 80 	movabs $0x800422211f,%rdi
  8004219a85:	00 00 00 
  8004219a88:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219a8d:	48 b9 d3 04 20 04 80 	movabs $0x80042004d3,%rcx
  8004219a94:	00 00 00 
  8004219a97:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004219a99:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  8004219aa0:	00 00 00 
  8004219aa3:	48 8b 00             	mov    (%rax),%rax
  8004219aa6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004219aaa:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004219aae:	48 c1 e2 04          	shl    $0x4,%rdx
  8004219ab2:	48 01 d0             	add    %rdx,%rax
}
  8004219ab5:	c9                   	leaveq 
  8004219ab6:	c3                   	retq   

0000008004219ab7 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004219ab7:	55                   	push   %rbp
  8004219ab8:	48 89 e5             	mov    %rsp,%rbp
  8004219abb:	48 83 ec 20          	sub    $0x20,%rsp
  8004219abf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004219ac3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219ac7:	48 89 c7             	mov    %rax,%rdi
  8004219aca:	48 b8 21 9a 21 04 80 	movabs $0x8004219a21,%rax
  8004219ad1:	00 00 00 
  8004219ad4:	ff d0                	callq  *%rax
  8004219ad6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004219ada:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004219ade:	48 c1 e8 0c          	shr    $0xc,%rax
  8004219ae2:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004219ae5:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004219ae8:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004219aef:	00 00 00 
  8004219af2:	48 8b 00             	mov    (%rax),%rax
  8004219af5:	48 39 c2             	cmp    %rax,%rdx
  8004219af8:	72 32                	jb     8004219b2c <page2kva+0x75>
  8004219afa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004219afe:	48 89 c1             	mov    %rax,%rcx
  8004219b01:	48 ba 30 21 22 04 80 	movabs $0x8004222130,%rdx
  8004219b08:	00 00 00 
  8004219b0b:	be 61 00 00 00       	mov    $0x61,%esi
  8004219b10:	48 bf 1f 21 22 04 80 	movabs $0x800422211f,%rdi
  8004219b17:	00 00 00 
  8004219b1a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219b1f:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004219b26:	00 00 00 
  8004219b29:	41 ff d0             	callq  *%r8
  8004219b2c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004219b33:	00 00 00 
  8004219b36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004219b3a:	48 01 d0             	add    %rdx,%rax
}
  8004219b3d:	c9                   	leaveq 
  8004219b3e:	c3                   	retq   

0000008004219b3f <epte_addr>:
#include <kern/pmap.h>
#include <inc/string.h>

// Return the physical address of an ept entry
static inline uintptr_t epte_addr(epte_t epte)
{
  8004219b3f:	55                   	push   %rbp
  8004219b40:	48 89 e5             	mov    %rsp,%rbp
  8004219b43:	48 83 ec 08          	sub    $0x8,%rsp
  8004219b47:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return (epte & EPTE_ADDR);
  8004219b4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004219b4f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  8004219b55:	c9                   	leaveq 
  8004219b56:	c3                   	retq   

0000008004219b57 <epte_present>:
	return (epte & EPTE_FLAGS);
}

// Return true if an ept entry's mapping is present
static inline int epte_present(epte_t epte)
{
  8004219b57:	55                   	push   %rbp
  8004219b58:	48 89 e5             	mov    %rsp,%rbp
  8004219b5b:	48 83 ec 08          	sub    $0x8,%rsp
  8004219b5f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return (epte & __EPTE_FULL) > 0;
  8004219b63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004219b67:	83 e0 07             	and    $0x7,%eax
  8004219b6a:	48 85 c0             	test   %rax,%rax
  8004219b6d:	0f 95 c0             	setne  %al
  8004219b70:	0f b6 c0             	movzbl %al,%eax
}
  8004219b73:	c9                   	leaveq 
  8004219b74:	c3                   	retq   

0000008004219b75 <ept_lookup_gpa>:
//
// Hint: Set the permissions of intermediate ept entries to __EPTE_FULL.
//       The hardware ANDs the permissions at each level, so removing a permission
//       bit at the last level entry is sufficient (and the bookkeeping is much simpler).
static int ept_lookup_gpa(epte_t* eptrt, void *gpa, 
			  int create, epte_t **epte_out) {
  8004219b75:	55                   	push   %rbp
  8004219b76:	48 89 e5             	mov    %rsp,%rbp
  8004219b79:	48 83 ec 30          	sub    $0x30,%rsp
  8004219b7d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004219b81:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004219b85:	89 55 dc             	mov    %edx,-0x24(%rbp)
  8004219b88:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
    	/* Your code here */
	
	if (eptrt == NULL) 
  8004219b8c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004219b91:	75 07                	jne    8004219b9a <ept_lookup_gpa+0x25>
		return -E_INVAL;
  8004219b93:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8004219b98:	eb 60                	jmp    8004219bfa <ept_lookup_gpa+0x85>

	epte_t *epte = pml4e_walk(eptrt, gpa, create);
  8004219b9a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004219b9d:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004219ba1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219ba5:	48 89 ce             	mov    %rcx,%rsi
  8004219ba8:	48 89 c7             	mov    %rax,%rdi
  8004219bab:	48 b8 29 30 20 04 80 	movabs $0x8004203029,%rax
  8004219bb2:	00 00 00 
  8004219bb5:	ff d0                	callq  *%rax
  8004219bb7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	
	if (epte == NULL && create)
  8004219bbb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004219bc0:	75 0d                	jne    8004219bcf <ept_lookup_gpa+0x5a>
  8004219bc2:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004219bc6:	74 07                	je     8004219bcf <ept_lookup_gpa+0x5a>
		return -E_NO_MEM;
  8004219bc8:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004219bcd:	eb 2b                	jmp    8004219bfa <ept_lookup_gpa+0x85>

	if (epte == NULL && create == 0)
  8004219bcf:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004219bd4:	75 0d                	jne    8004219be3 <ept_lookup_gpa+0x6e>
  8004219bd6:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004219bda:	75 07                	jne    8004219be3 <ept_lookup_gpa+0x6e>
		return -E_NO_ENT;
  8004219bdc:	b8 eb ff ff ff       	mov    $0xffffffeb,%eax
  8004219be1:	eb 17                	jmp    8004219bfa <ept_lookup_gpa+0x85>

	if (epte_out)
  8004219be3:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004219be8:	74 0b                	je     8004219bf5 <ept_lookup_gpa+0x80>
		*epte_out = epte;
  8004219bea:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004219bee:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004219bf2:	48 89 10             	mov    %rdx,(%rax)
	
   	return 0;
  8004219bf5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004219bfa:	c9                   	leaveq 
  8004219bfb:	c3                   	retq   

0000008004219bfc <ept_gpa2hva>:

void ept_gpa2hva(epte_t* eptrt, void *gpa, void **hva) {
  8004219bfc:	55                   	push   %rbp
  8004219bfd:	48 89 e5             	mov    %rsp,%rbp
  8004219c00:	48 83 ec 40          	sub    $0x40,%rsp
  8004219c04:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004219c08:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004219c0c:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    epte_t* pte;
    int ret = ept_lookup_gpa(eptrt, gpa, 0, &pte);
  8004219c10:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  8004219c14:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004219c18:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219c1c:	48 89 d1             	mov    %rdx,%rcx
  8004219c1f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004219c24:	48 89 c7             	mov    %rax,%rdi
  8004219c27:	48 b8 75 9b 21 04 80 	movabs $0x8004219b75,%rax
  8004219c2e:	00 00 00 
  8004219c31:	ff d0                	callq  *%rax
  8004219c33:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if(ret < 0) {
  8004219c36:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004219c3a:	79 10                	jns    8004219c4c <ept_gpa2hva+0x50>
        *hva = NULL;
  8004219c3c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004219c40:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
           *hva = NULL;
        } else {
           *hva = KADDR(epte_addr(*pte));
        }
    }
}
  8004219c47:	e9 b1 00 00 00       	jmpq   8004219cfd <ept_gpa2hva+0x101>
    epte_t* pte;
    int ret = ept_lookup_gpa(eptrt, gpa, 0, &pte);
    if(ret < 0) {
        *hva = NULL;
    } else {
        if(!epte_present(*pte)) {
  8004219c4c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219c50:	48 8b 00             	mov    (%rax),%rax
  8004219c53:	48 89 c7             	mov    %rax,%rdi
  8004219c56:	48 b8 57 9b 21 04 80 	movabs $0x8004219b57,%rax
  8004219c5d:	00 00 00 
  8004219c60:	ff d0                	callq  *%rax
  8004219c62:	85 c0                	test   %eax,%eax
  8004219c64:	75 10                	jne    8004219c76 <ept_gpa2hva+0x7a>
           *hva = NULL;
  8004219c66:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004219c6a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        } else {
           *hva = KADDR(epte_addr(*pte));
        }
    }
}
  8004219c71:	e9 87 00 00 00       	jmpq   8004219cfd <ept_gpa2hva+0x101>
        *hva = NULL;
    } else {
        if(!epte_present(*pte)) {
           *hva = NULL;
        } else {
           *hva = KADDR(epte_addr(*pte));
  8004219c76:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219c7a:	48 8b 00             	mov    (%rax),%rax
  8004219c7d:	48 89 c7             	mov    %rax,%rdi
  8004219c80:	48 b8 3f 9b 21 04 80 	movabs $0x8004219b3f,%rax
  8004219c87:	00 00 00 
  8004219c8a:	ff d0                	callq  *%rax
  8004219c8c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004219c90:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004219c94:	48 c1 e8 0c          	shr    $0xc,%rax
  8004219c98:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004219c9b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004219c9e:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004219ca5:	00 00 00 
  8004219ca8:	48 8b 00             	mov    (%rax),%rax
  8004219cab:	48 39 c2             	cmp    %rax,%rdx
  8004219cae:	72 32                	jb     8004219ce2 <ept_gpa2hva+0xe6>
  8004219cb0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004219cb4:	48 89 c1             	mov    %rax,%rcx
  8004219cb7:	48 ba 30 21 22 04 80 	movabs $0x8004222130,%rdx
  8004219cbe:	00 00 00 
  8004219cc1:	be 4f 00 00 00       	mov    $0x4f,%esi
  8004219cc6:	48 bf 53 21 22 04 80 	movabs $0x8004222153,%rdi
  8004219ccd:	00 00 00 
  8004219cd0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219cd5:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004219cdc:	00 00 00 
  8004219cdf:	41 ff d0             	callq  *%r8
  8004219ce2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004219ce9:	00 00 00 
  8004219cec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004219cf0:	48 01 d0             	add    %rdx,%rax
  8004219cf3:	48 89 c2             	mov    %rax,%rdx
  8004219cf6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004219cfa:	48 89 10             	mov    %rdx,(%rax)
        }
    }
}
  8004219cfd:	90                   	nop
  8004219cfe:	c9                   	leaveq 
  8004219cff:	c3                   	retq   

0000008004219d00 <free_ept_level>:

static void free_ept_level(epte_t* eptrt, int level) {
  8004219d00:	55                   	push   %rbp
  8004219d01:	48 89 e5             	mov    %rsp,%rbp
  8004219d04:	48 83 ec 40          	sub    $0x40,%rsp
  8004219d08:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004219d0c:	89 75 c4             	mov    %esi,-0x3c(%rbp)
    epte_t* dir = eptrt;
  8004219d0f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004219d13:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    int i;

    for(i=0; i<NPTENTRIES; ++i) {
  8004219d17:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004219d1e:	e9 82 01 00 00       	jmpq   8004219ea5 <free_ept_level+0x1a5>
        if(level != 0) {
  8004219d23:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004219d27:	0f 84 fe 00 00 00    	je     8004219e2b <free_ept_level+0x12b>
            if(epte_present(dir[i])) {
  8004219d2d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219d30:	48 98                	cltq   
  8004219d32:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004219d39:	00 
  8004219d3a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004219d3e:	48 01 d0             	add    %rdx,%rax
  8004219d41:	48 8b 00             	mov    (%rax),%rax
  8004219d44:	48 89 c7             	mov    %rax,%rdi
  8004219d47:	48 b8 57 9b 21 04 80 	movabs $0x8004219b57,%rax
  8004219d4e:	00 00 00 
  8004219d51:	ff d0                	callq  *%rax
  8004219d53:	85 c0                	test   %eax,%eax
  8004219d55:	0f 84 46 01 00 00    	je     8004219ea1 <free_ept_level+0x1a1>
                physaddr_t pa = epte_addr(dir[i]);
  8004219d5b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219d5e:	48 98                	cltq   
  8004219d60:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004219d67:	00 
  8004219d68:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004219d6c:	48 01 d0             	add    %rdx,%rax
  8004219d6f:	48 8b 00             	mov    (%rax),%rax
  8004219d72:	48 89 c7             	mov    %rax,%rdi
  8004219d75:	48 b8 3f 9b 21 04 80 	movabs $0x8004219b3f,%rax
  8004219d7c:	00 00 00 
  8004219d7f:	ff d0                	callq  *%rax
  8004219d81:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                free_ept_level((epte_t*) KADDR(pa), level-1);
  8004219d85:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004219d88:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004219d8b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219d8f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004219d93:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219d97:	48 c1 e8 0c          	shr    $0xc,%rax
  8004219d9b:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004219d9e:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  8004219da1:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  8004219da8:	00 00 00 
  8004219dab:	48 8b 00             	mov    (%rax),%rax
  8004219dae:	48 39 c1             	cmp    %rax,%rcx
  8004219db1:	72 32                	jb     8004219de5 <free_ept_level+0xe5>
  8004219db3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219db7:	48 89 c1             	mov    %rax,%rcx
  8004219dba:	48 ba 30 21 22 04 80 	movabs $0x8004222130,%rdx
  8004219dc1:	00 00 00 
  8004219dc4:	be 5c 00 00 00       	mov    $0x5c,%esi
  8004219dc9:	48 bf 53 21 22 04 80 	movabs $0x8004222153,%rdi
  8004219dd0:	00 00 00 
  8004219dd3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219dd8:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  8004219ddf:	00 00 00 
  8004219de2:	41 ff d0             	callq  *%r8
  8004219de5:	48 b9 00 00 00 04 80 	movabs $0x8004000000,%rcx
  8004219dec:	00 00 00 
  8004219def:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219df3:	48 01 c8             	add    %rcx,%rax
  8004219df6:	89 d6                	mov    %edx,%esi
  8004219df8:	48 89 c7             	mov    %rax,%rdi
  8004219dfb:	48 b8 00 9d 21 04 80 	movabs $0x8004219d00,%rax
  8004219e02:	00 00 00 
  8004219e05:	ff d0                	callq  *%rax
                // free the table.
                page_decref(pa2page(pa));
  8004219e07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219e0b:	48 89 c7             	mov    %rax,%rdi
  8004219e0e:	48 b8 46 9a 21 04 80 	movabs $0x8004219a46,%rax
  8004219e15:	00 00 00 
  8004219e18:	ff d0                	callq  *%rax
  8004219e1a:	48 89 c7             	mov    %rax,%rdi
  8004219e1d:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  8004219e24:	00 00 00 
  8004219e27:	ff d0                	callq  *%rax
  8004219e29:	eb 76                	jmp    8004219ea1 <free_ept_level+0x1a1>
            }
        } else {
            // Last level, free the guest physical page.
            if(epte_present(dir[i])) {
  8004219e2b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219e2e:	48 98                	cltq   
  8004219e30:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004219e37:	00 
  8004219e38:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004219e3c:	48 01 d0             	add    %rdx,%rax
  8004219e3f:	48 8b 00             	mov    (%rax),%rax
  8004219e42:	48 89 c7             	mov    %rax,%rdi
  8004219e45:	48 b8 57 9b 21 04 80 	movabs $0x8004219b57,%rax
  8004219e4c:	00 00 00 
  8004219e4f:	ff d0                	callq  *%rax
  8004219e51:	85 c0                	test   %eax,%eax
  8004219e53:	74 4c                	je     8004219ea1 <free_ept_level+0x1a1>
                physaddr_t pa = epte_addr(dir[i]);                
  8004219e55:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219e58:	48 98                	cltq   
  8004219e5a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004219e61:	00 
  8004219e62:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004219e66:	48 01 d0             	add    %rdx,%rax
  8004219e69:	48 8b 00             	mov    (%rax),%rax
  8004219e6c:	48 89 c7             	mov    %rax,%rdi
  8004219e6f:	48 b8 3f 9b 21 04 80 	movabs $0x8004219b3f,%rax
  8004219e76:	00 00 00 
  8004219e79:	ff d0                	callq  *%rax
  8004219e7b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                page_decref(pa2page(pa));
  8004219e7f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004219e83:	48 89 c7             	mov    %rax,%rdi
  8004219e86:	48 b8 46 9a 21 04 80 	movabs $0x8004219a46,%rax
  8004219e8d:	00 00 00 
  8004219e90:	ff d0                	callq  *%rax
  8004219e92:	48 89 c7             	mov    %rax,%rdi
  8004219e95:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  8004219e9c:	00 00 00 
  8004219e9f:	ff d0                	callq  *%rax

static void free_ept_level(epte_t* eptrt, int level) {
    epte_t* dir = eptrt;
    int i;

    for(i=0; i<NPTENTRIES; ++i) {
  8004219ea1:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004219ea5:	81 7d fc ff 01 00 00 	cmpl   $0x1ff,-0x4(%rbp)
  8004219eac:	0f 8e 71 fe ff ff    	jle    8004219d23 <free_ept_level+0x23>
                physaddr_t pa = epte_addr(dir[i]);                
                page_decref(pa2page(pa));
            }
        }
    }
    return;
  8004219eb2:	90                   	nop
}
  8004219eb3:	c9                   	leaveq 
  8004219eb4:	c3                   	retq   

0000008004219eb5 <free_guest_mem>:

// Free the EPT table entries and the EPT tables.
// NOTE: Does not deallocate EPT PML4 page.
void free_guest_mem(epte_t* eptrt) {
  8004219eb5:	55                   	push   %rbp
  8004219eb6:	48 89 e5             	mov    %rsp,%rbp
  8004219eb9:	48 83 ec 20          	sub    $0x20,%rsp
  8004219ebd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    free_ept_level(eptrt, EPT_LEVELS - 1);
  8004219ec1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219ec5:	be 03 00 00 00       	mov    $0x3,%esi
  8004219eca:	48 89 c7             	mov    %rax,%rdi
  8004219ecd:	48 b8 00 9d 21 04 80 	movabs $0x8004219d00,%rax
  8004219ed4:	00 00 00 
  8004219ed7:	ff d0                	callq  *%rax

static __inline void
tlbflush(void)
{
	uint64_t cr3;
	__asm __volatile("movq %%cr3,%0" : "=r" (cr3));
  8004219ed9:	0f 20 d8             	mov    %cr3,%rax
  8004219edc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	__asm __volatile("movq %0,%%cr3" : : "r" (cr3));
  8004219ee0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004219ee4:	0f 22 d8             	mov    %rax,%cr3
    tlbflush();
}
  8004219ee7:	90                   	nop
  8004219ee8:	c9                   	leaveq 
  8004219ee9:	c3                   	retq   

0000008004219eea <ept_page_insert>:
//   successful insert.  If you overwrite a mapping, your code should
//   decrement the reference count of the old mapping.
// 
// Return 0 on success, <0 on failure.
//
int ept_page_insert(epte_t* eptrt, struct PageInfo* pp, void* gpa, int perm) {
  8004219eea:	55                   	push   %rbp
  8004219eeb:	48 89 e5             	mov    %rsp,%rbp
  8004219eee:	53                   	push   %rbx
  8004219eef:	48 83 ec 38          	sub    $0x38,%rsp
  8004219ef3:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004219ef7:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004219efb:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004219eff:	89 4d c4             	mov    %ecx,-0x3c(%rbp)

	/* Your code here */
	epte_t *pte;
	int r;

	if((r = ept_lookup_gpa(eptrt, gpa, 1, &pte)) < 0) {
  8004219f02:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  8004219f06:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8004219f0a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219f0e:	48 89 d1             	mov    %rdx,%rcx
  8004219f11:	ba 01 00 00 00       	mov    $0x1,%edx
  8004219f16:	48 89 c7             	mov    %rax,%rdi
  8004219f19:	48 b8 75 9b 21 04 80 	movabs $0x8004219b75,%rax
  8004219f20:	00 00 00 
  8004219f23:	ff d0                	callq  *%rax
  8004219f25:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004219f28:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8004219f2c:	79 1b                	jns    8004219f49 <ept_page_insert+0x5f>
		cprintf("ept page insert: failed\n");
  8004219f2e:	48 bf 5d 21 22 04 80 	movabs $0x800422215d,%rdi
  8004219f35:	00 00 00 
  8004219f38:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219f3d:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  8004219f44:	00 00 00 
  8004219f47:	ff d2                	callq  *%rdx
	}

	if (epte_present(*pte))
  8004219f49:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219f4d:	48 8b 00             	mov    (%rax),%rax
  8004219f50:	48 89 c7             	mov    %rax,%rdi
  8004219f53:	48 b8 57 9b 21 04 80 	movabs $0x8004219b57,%rax
  8004219f5a:	00 00 00 
  8004219f5d:	ff d0                	callq  *%rax
  8004219f5f:	85 c0                	test   %eax,%eax
  8004219f61:	74 25                	je     8004219f88 <ept_page_insert+0x9e>
		page_decref(pa2page(*pte));
  8004219f63:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219f67:	48 8b 00             	mov    (%rax),%rax
  8004219f6a:	48 89 c7             	mov    %rax,%rdi
  8004219f6d:	48 b8 46 9a 21 04 80 	movabs $0x8004219a46,%rax
  8004219f74:	00 00 00 
  8004219f77:	ff d0                	callq  *%rax
  8004219f79:	48 89 c7             	mov    %rax,%rdi
  8004219f7c:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  8004219f83:	00 00 00 
  8004219f86:	ff d0                	callq  *%rax
	
	*pte = page2pa(pp) | perm;
  8004219f88:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  8004219f8c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004219f90:	48 89 c7             	mov    %rax,%rdi
  8004219f93:	48 b8 21 9a 21 04 80 	movabs $0x8004219a21,%rax
  8004219f9a:	00 00 00 
  8004219f9d:	ff d0                	callq  *%rax
  8004219f9f:	48 89 c2             	mov    %rax,%rdx
  8004219fa2:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004219fa5:	48 98                	cltq   
  8004219fa7:	48 09 d0             	or     %rdx,%rax
  8004219faa:	48 89 03             	mov    %rax,(%rbx)
	pp->pp_ref += 1;	
  8004219fad:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004219fb1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004219fb5:	8d 50 01             	lea    0x1(%rax),%edx
  8004219fb8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004219fbc:	66 89 50 08          	mov    %dx,0x8(%rax)

    	return 0;
  8004219fc0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004219fc5:	48 83 c4 38          	add    $0x38,%rsp
  8004219fc9:	5b                   	pop    %rbx
  8004219fca:	5d                   	pop    %rbp
  8004219fcb:	c3                   	retq   

0000008004219fcc <ept_map_hva2gpa>:
// 
// Hint: use ept_lookup_gpa to create the intermediate 
//       ept levels, and return the final epte_t pointer.
//       You should set the type to EPTE_TYPE_WB and set __EPTE_IPAT flag.
int ept_map_hva2gpa(epte_t* eptrt, void* hva, void* gpa, int perm, 
        int overwrite) {
  8004219fcc:	55                   	push   %rbp
  8004219fcd:	48 89 e5             	mov    %rsp,%rbp
  8004219fd0:	48 83 ec 40          	sub    $0x40,%rsp
  8004219fd4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004219fd8:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004219fdc:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004219fe0:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
  8004219fe3:	44 89 45 c0          	mov    %r8d,-0x40(%rbp)
	epte_t *epte;
	pte_t *pte;
	int ret = ept_lookup_gpa(eptrt, gpa, 1, &epte);
  8004219fe7:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  8004219feb:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8004219fef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219ff3:	48 89 d1             	mov    %rdx,%rcx
  8004219ff6:	ba 01 00 00 00       	mov    $0x1,%edx
  8004219ffb:	48 89 c7             	mov    %rax,%rdi
  8004219ffe:	48 b8 75 9b 21 04 80 	movabs $0x8004219b75,%rax
  800421a005:	00 00 00 
  800421a008:	ff d0                	callq  *%rax
  800421a00a:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if (ret == 0) {
  800421a00d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800421a011:	0f 85 9d 00 00 00    	jne    800421a0b4 <ept_map_hva2gpa+0xe8>
		if (epte_present(*epte) && overwrite == 0)
  800421a017:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a01b:	48 8b 00             	mov    (%rax),%rax
  800421a01e:	48 89 c7             	mov    %rax,%rdi
  800421a021:	48 b8 57 9b 21 04 80 	movabs $0x8004219b57,%rax
  800421a028:	00 00 00 
  800421a02b:	ff d0                	callq  *%rax
  800421a02d:	85 c0                	test   %eax,%eax
  800421a02f:	74 0d                	je     800421a03e <ept_map_hva2gpa+0x72>
  800421a031:	83 7d c0 00          	cmpl   $0x0,-0x40(%rbp)
  800421a035:	75 07                	jne    800421a03e <ept_map_hva2gpa+0x72>
			return -E_INVAL;
  800421a037:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800421a03c:	eb 7b                	jmp    800421a0b9 <ept_map_hva2gpa+0xed>
		*epte = PADDR(hva)|perm|__EPTE_IPAT|__EPTE_TYPE(EPTE_TYPE_WB);
  800421a03e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a042:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421a046:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  800421a04a:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  800421a051:	00 00 00 
  800421a054:	48 39 55 f0          	cmp    %rdx,-0x10(%rbp)
  800421a058:	77 32                	ja     800421a08c <ept_map_hva2gpa+0xc0>
  800421a05a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421a05e:	48 89 c1             	mov    %rax,%rcx
  800421a061:	48 ba 78 21 22 04 80 	movabs $0x8004222178,%rdx
  800421a068:	00 00 00 
  800421a06b:	be a3 00 00 00       	mov    $0xa3,%esi
  800421a070:	48 bf 53 21 22 04 80 	movabs $0x8004222153,%rdi
  800421a077:	00 00 00 
  800421a07a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a07f:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421a086:	00 00 00 
  800421a089:	41 ff d0             	callq  *%r8
  800421a08c:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  800421a093:	ff ff ff 
  800421a096:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421a09a:	48 01 d1             	add    %rdx,%rcx
  800421a09d:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  800421a0a0:	48 63 d2             	movslq %edx,%rdx
  800421a0a3:	48 09 ca             	or     %rcx,%rdx
  800421a0a6:	48 83 ca 70          	or     $0x70,%rdx
  800421a0aa:	48 89 10             	mov    %rdx,(%rax)
	} else 
		return -E_NO_MEM;

    	return 0;
  800421a0ad:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a0b2:	eb 05                	jmp    800421a0b9 <ept_map_hva2gpa+0xed>
	if (ret == 0) {
		if (epte_present(*epte) && overwrite == 0)
			return -E_INVAL;
		*epte = PADDR(hva)|perm|__EPTE_IPAT|__EPTE_TYPE(EPTE_TYPE_WB);
	} else 
		return -E_NO_MEM;
  800421a0b4:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax

    	return 0;
}
  800421a0b9:	c9                   	leaveq 
  800421a0ba:	c3                   	retq   

000000800421a0bb <ept_alloc_static>:

int ept_alloc_static(epte_t *eptrt, struct VmxGuestInfo *ginfo) {
  800421a0bb:	55                   	push   %rbp
  800421a0bc:	48 89 e5             	mov    %rsp,%rbp
  800421a0bf:	53                   	push   %rbx
  800421a0c0:	48 83 ec 48          	sub    $0x48,%rsp
  800421a0c4:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800421a0c8:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
    physaddr_t i;
    
    for(i=0x0; i < 0xA0000; i+=PGSIZE) {
  800421a0cc:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800421a0d3:	00 
  800421a0d4:	eb 6e                	jmp    800421a144 <ept_alloc_static+0x89>
        struct PageInfo *p = page_alloc(0);
  800421a0d6:	bf 00 00 00 00       	mov    $0x0,%edi
  800421a0db:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  800421a0e2:	00 00 00 
  800421a0e5:	ff d0                	callq  *%rax
  800421a0e7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        p->pp_ref += 1;
  800421a0eb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421a0ef:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800421a0f3:	8d 50 01             	lea    0x1(%rax),%edx
  800421a0f6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421a0fa:	66 89 50 08          	mov    %dx,0x8(%rax)
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
  800421a0fe:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
  800421a102:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421a106:	48 89 c7             	mov    %rax,%rdi
  800421a109:	48 b8 b7 9a 21 04 80 	movabs $0x8004219ab7,%rax
  800421a110:	00 00 00 
  800421a113:	ff d0                	callq  *%rax
  800421a115:	48 89 c6             	mov    %rax,%rsi
  800421a118:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421a11c:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800421a122:	b9 07 00 00 00       	mov    $0x7,%ecx
  800421a127:	48 89 da             	mov    %rbx,%rdx
  800421a12a:	48 89 c7             	mov    %rax,%rdi
  800421a12d:	48 b8 cc 9f 21 04 80 	movabs $0x8004219fcc,%rax
  800421a134:	00 00 00 
  800421a137:	ff d0                	callq  *%rax
  800421a139:	89 45 dc             	mov    %eax,-0x24(%rbp)
}

int ept_alloc_static(epte_t *eptrt, struct VmxGuestInfo *ginfo) {
    physaddr_t i;
    
    for(i=0x0; i < 0xA0000; i+=PGSIZE) {
  800421a13c:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  800421a143:	00 
  800421a144:	48 81 7d e8 ff ff 09 	cmpq   $0x9ffff,-0x18(%rbp)
  800421a14b:	00 
  800421a14c:	76 88                	jbe    800421a0d6 <ept_alloc_static+0x1b>
        struct PageInfo *p = page_alloc(0);
        p->pp_ref += 1;
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
    }

    for(i=0x100000; i < ginfo->phys_sz; i+=PGSIZE) {
  800421a14e:	48 c7 45 e8 00 00 10 	movq   $0x100000,-0x18(%rbp)
  800421a155:	00 
  800421a156:	eb 6e                	jmp    800421a1c6 <ept_alloc_static+0x10b>
        struct PageInfo *p = page_alloc(0);
  800421a158:	bf 00 00 00 00       	mov    $0x0,%edi
  800421a15d:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  800421a164:	00 00 00 
  800421a167:	ff d0                	callq  *%rax
  800421a169:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        p->pp_ref += 1;
  800421a16d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421a171:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800421a175:	8d 50 01             	lea    0x1(%rax),%edx
  800421a178:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421a17c:	66 89 50 08          	mov    %dx,0x8(%rax)
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
  800421a180:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
  800421a184:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421a188:	48 89 c7             	mov    %rax,%rdi
  800421a18b:	48 b8 b7 9a 21 04 80 	movabs $0x8004219ab7,%rax
  800421a192:	00 00 00 
  800421a195:	ff d0                	callq  *%rax
  800421a197:	48 89 c6             	mov    %rax,%rsi
  800421a19a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421a19e:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800421a1a4:	b9 07 00 00 00       	mov    $0x7,%ecx
  800421a1a9:	48 89 da             	mov    %rbx,%rdx
  800421a1ac:	48 89 c7             	mov    %rax,%rdi
  800421a1af:	48 b8 cc 9f 21 04 80 	movabs $0x8004219fcc,%rax
  800421a1b6:	00 00 00 
  800421a1b9:	ff d0                	callq  *%rax
  800421a1bb:	89 45 cc             	mov    %eax,-0x34(%rbp)
        struct PageInfo *p = page_alloc(0);
        p->pp_ref += 1;
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
    }

    for(i=0x100000; i < ginfo->phys_sz; i+=PGSIZE) {
  800421a1be:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  800421a1c5:	00 
  800421a1c6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421a1ca:	48 8b 00             	mov    (%rax),%rax
  800421a1cd:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800421a1d1:	77 85                	ja     800421a158 <ept_alloc_static+0x9d>
        struct PageInfo *p = page_alloc(0);
        p->pp_ref += 1;
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
    }
    return 0;
  800421a1d3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421a1d8:	48 83 c4 48          	add    $0x48,%rsp
  800421a1dc:	5b                   	pop    %rbx
  800421a1dd:	5d                   	pop    %rbp
  800421a1de:	c3                   	retq   

000000800421a1df <vmcs_writel>:
#define IA32_VMX_EPT_VPID_CAP 0x48C
#define IA32_FEATURE_CONTROL 0x03A

#define BIT( val, x ) ( ( val >> x ) & 0x1 )

static __inline uint8_t vmcs_writel( uint32_t field, uint64_t value) {
  800421a1df:	55                   	push   %rbp
  800421a1e0:	48 89 e5             	mov    %rsp,%rbp
  800421a1e3:	48 83 ec 20          	sub    $0x20,%rsp
  800421a1e7:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800421a1ea:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint8_t error;

	__asm __volatile ( "clc; vmwrite %%rax, %%rdx; setna %0"
  800421a1ee:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421a1f2:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421a1f5:	f8                   	clc    
  800421a1f6:	0f 79 d0             	vmwrite %rax,%rdx
  800421a1f9:	0f 96 c0             	setbe  %al
  800421a1fc:	88 45 ff             	mov    %al,-0x1(%rbp)
		       : "=q"( error ) : "a"( value ), "d"( field ) : "cc");
    return error;
  800421a1ff:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  800421a203:	c9                   	leaveq 
  800421a204:	c3                   	retq   

000000800421a205 <vmcs_readl>:
static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
}

static __inline uint64_t vmcs_readl(uint32_t field)
{
  800421a205:	55                   	push   %rbp
  800421a206:	48 89 e5             	mov    %rsp,%rbp
  800421a209:	48 83 ec 18          	sub    $0x18,%rsp
  800421a20d:	89 7d ec             	mov    %edi,-0x14(%rbp)
	uint64_t value;

	__asm __volatile ( "vmread %%rdx, %%rax;"
  800421a210:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421a213:	89 c2                	mov    %eax,%edx
  800421a215:	0f 78 d0             	vmread %rdx,%rax
  800421a218:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		      : "=a"(value) : "d"(field) : "cc");
	return value;
  800421a21c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421a220:	c9                   	leaveq 
  800421a221:	c3                   	retq   

000000800421a222 <cpuid>:

#define read_rip(var) __asm __volatile("leaq (%%rip), %0" : "=r" (var)::"cc","memory")

static __inline void
cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)
{
  800421a222:	55                   	push   %rbp
  800421a223:	48 89 e5             	mov    %rsp,%rbp
  800421a226:	53                   	push   %rbx
  800421a227:	48 83 ec 38          	sub    $0x38,%rsp
  800421a22b:	89 7d e4             	mov    %edi,-0x1c(%rbp)
  800421a22e:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  800421a232:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800421a236:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  800421a23a:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
	uint32_t eax, ebx, ecx, edx;
	asm volatile("cpuid" 
  800421a23e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421a241:	0f a2                	cpuid  
  800421a243:	89 de                	mov    %ebx,%esi
  800421a245:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800421a248:	89 75 f0             	mov    %esi,-0x10(%rbp)
  800421a24b:	89 4d ec             	mov    %ecx,-0x14(%rbp)
  800421a24e:	89 55 e8             	mov    %edx,-0x18(%rbp)
			 : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
			 : "a" (info));
	if (eaxp)
  800421a251:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421a256:	74 09                	je     800421a261 <cpuid+0x3f>
		*eaxp = eax;
  800421a258:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421a25c:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421a25f:	89 10                	mov    %edx,(%rax)
	if (ebxp)
  800421a261:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800421a266:	74 09                	je     800421a271 <cpuid+0x4f>
		*ebxp = ebx;
  800421a268:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421a26c:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800421a26f:	89 10                	mov    %edx,(%rax)
	if (ecxp)
  800421a271:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800421a276:	74 09                	je     800421a281 <cpuid+0x5f>
		*ecxp = ecx;
  800421a278:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421a27c:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421a27f:	89 10                	mov    %edx,(%rax)
	if (edxp)
  800421a281:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800421a286:	74 09                	je     800421a291 <cpuid+0x6f>
		*edxp = edx;
  800421a288:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421a28c:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800421a28f:	89 10                	mov    %edx,(%rax)
}
  800421a291:	90                   	nop
  800421a292:	48 83 c4 38          	add    $0x38,%rsp
  800421a296:	5b                   	pop    %rbx
  800421a297:	5d                   	pop    %rbp
  800421a298:	c3                   	retq   

000000800421a299 <page2ppn>:
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);


static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  800421a299:	55                   	push   %rbp
  800421a29a:	48 89 e5             	mov    %rsp,%rbp
  800421a29d:	48 83 ec 08          	sub    $0x8,%rsp
  800421a2a1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  800421a2a5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421a2a9:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  800421a2b0:	00 00 00 
  800421a2b3:	48 8b 00             	mov    (%rax),%rax
  800421a2b6:	48 29 c2             	sub    %rax,%rdx
  800421a2b9:	48 89 d0             	mov    %rdx,%rax
  800421a2bc:	48 c1 f8 04          	sar    $0x4,%rax
}
  800421a2c0:	c9                   	leaveq 
  800421a2c1:	c3                   	retq   

000000800421a2c2 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  800421a2c2:	55                   	push   %rbp
  800421a2c3:	48 89 e5             	mov    %rsp,%rbp
  800421a2c6:	48 83 ec 08          	sub    $0x8,%rsp
  800421a2ca:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  800421a2ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421a2d2:	48 89 c7             	mov    %rax,%rdi
  800421a2d5:	48 b8 99 a2 21 04 80 	movabs $0x800421a299,%rax
  800421a2dc:	00 00 00 
  800421a2df:	ff d0                	callq  *%rax
  800421a2e1:	48 c1 e0 0c          	shl    $0xc,%rax
}
  800421a2e5:	c9                   	leaveq 
  800421a2e6:	c3                   	retq   

000000800421a2e7 <page2kva>:
	return &pages[PPN(pa)];
}

static inline void*
page2kva(struct PageInfo *pp)
{
  800421a2e7:	55                   	push   %rbp
  800421a2e8:	48 89 e5             	mov    %rsp,%rbp
  800421a2eb:	48 83 ec 20          	sub    $0x20,%rsp
  800421a2ef:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  800421a2f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a2f7:	48 89 c7             	mov    %rax,%rdi
  800421a2fa:	48 b8 c2 a2 21 04 80 	movabs $0x800421a2c2,%rax
  800421a301:	00 00 00 
  800421a304:	ff d0                	callq  *%rax
  800421a306:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421a30a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421a30e:	48 c1 e8 0c          	shr    $0xc,%rax
  800421a312:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800421a315:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421a318:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  800421a31f:	00 00 00 
  800421a322:	48 8b 00             	mov    (%rax),%rax
  800421a325:	48 39 c2             	cmp    %rax,%rdx
  800421a328:	72 32                	jb     800421a35c <page2kva+0x75>
  800421a32a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421a32e:	48 89 c1             	mov    %rax,%rcx
  800421a331:	48 ba a0 21 22 04 80 	movabs $0x80042221a0,%rdx
  800421a338:	00 00 00 
  800421a33b:	be 61 00 00 00       	mov    $0x61,%esi
  800421a340:	48 bf c3 21 22 04 80 	movabs $0x80042221c3,%rdi
  800421a347:	00 00 00 
  800421a34a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a34f:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421a356:	00 00 00 
  800421a359:	41 ff d0             	callq  *%r8
  800421a35c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421a363:	00 00 00 
  800421a366:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421a36a:	48 01 d0             	add    %rdx,%rax
}
  800421a36d:	c9                   	leaveq 
  800421a36e:	c3                   	retq   

000000800421a36f <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  800421a36f:	55                   	push   %rbp
  800421a370:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  800421a373:	48 bf 60 67 23 04 80 	movabs $0x8004236760,%rdi
  800421a37a:	00 00 00 
  800421a37d:	48 b8 8e 84 21 04 80 	movabs $0x800421848e,%rax
  800421a384:	00 00 00 
  800421a387:	ff d0                	callq  *%rax
}
  800421a389:	90                   	nop
  800421a38a:	5d                   	pop    %rbp
  800421a38b:	c3                   	retq   

000000800421a38c <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800421a38c:	55                   	push   %rbp
  800421a38d:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800421a390:	48 bf 60 67 23 04 80 	movabs $0x8004236760,%rdi
  800421a397:	00 00 00 
  800421a39a:	48 b8 64 85 21 04 80 	movabs $0x8004218564,%rax
  800421a3a1:	00 00 00 
  800421a3a4:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800421a3a6:	f3 90                	pause  
}
  800421a3a8:	90                   	nop
  800421a3a9:	5d                   	pop    %rbp
  800421a3aa:	c3                   	retq   

000000800421a3ab <vmx_list_vms>:
#include <kern/console.h>
#include <kern/spinlock.h>
#include <kern/macro.h>


void vmx_list_vms() {
  800421a3ab:	55                   	push   %rbp
  800421a3ac:	48 89 e5             	mov    %rsp,%rbp
  800421a3af:	48 83 ec 10          	sub    $0x10,%rsp
	//findout how many VMs there
	int i;
	int vm_count = 0;
  800421a3b3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < NENV; ++i) {
  800421a3ba:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421a3c1:	e9 96 00 00 00       	jmpq   800421a45c <vmx_list_vms+0xb1>
		if (envs[i].env_type == ENV_TYPE_GUEST) {
  800421a3c6:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  800421a3cd:	00 00 00 
  800421a3d0:	48 8b 10             	mov    (%rax),%rdx
  800421a3d3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421a3d6:	48 98                	cltq   
  800421a3d8:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800421a3df:	48 01 d0             	add    %rdx,%rax
  800421a3e2:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800421a3e8:	83 f8 03             	cmp    $0x3,%eax
  800421a3eb:	75 6b                	jne    800421a458 <vmx_list_vms+0xad>
			if (vm_count == 0) {
  800421a3ed:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800421a3f1:	75 1b                	jne    800421a40e <vmx_list_vms+0x63>
				cprintf("Running VMs:\n");
  800421a3f3:	48 bf d1 21 22 04 80 	movabs $0x80042221d1,%rdi
  800421a3fa:	00 00 00 
  800421a3fd:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a402:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421a409:	00 00 00 
  800421a40c:	ff d2                	callq  *%rdx
			}
			vm_count++;
  800421a40e:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
			cprintf("%d.[%x]vm%d\n", vm_count, envs[i].env_id, vm_count);
  800421a412:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  800421a419:	00 00 00 
  800421a41c:	48 8b 10             	mov    (%rax),%rdx
  800421a41f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421a422:	48 98                	cltq   
  800421a424:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800421a42b:	48 01 d0             	add    %rdx,%rax
  800421a42e:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800421a434:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  800421a437:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421a43a:	89 c6                	mov    %eax,%esi
  800421a43c:	48 bf df 21 22 04 80 	movabs $0x80042221df,%rdi
  800421a443:	00 00 00 
  800421a446:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a44b:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421a452:	00 00 00 
  800421a455:	41 ff d0             	callq  *%r8

void vmx_list_vms() {
	//findout how many VMs there
	int i;
	int vm_count = 0;
	for (i = 0; i < NENV; ++i) {
  800421a458:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421a45c:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800421a463:	0f 8e 5d ff ff ff    	jle    800421a3c6 <vmx_list_vms+0x1b>
			}
			vm_count++;
			cprintf("%d.[%x]vm%d\n", vm_count, envs[i].env_id, vm_count);
		}
	}
}
  800421a469:	90                   	nop
  800421a46a:	c9                   	leaveq 
  800421a46b:	c3                   	retq   

000000800421a46c <vmx_sel_resume>:

bool vmx_sel_resume(int num) {
  800421a46c:	55                   	push   %rbp
  800421a46d:	48 89 e5             	mov    %rsp,%rbp
  800421a470:	48 83 ec 20          	sub    $0x20,%rsp
  800421a474:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int i;
	int vm_count = 0;
  800421a477:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < NENV; ++i) {
  800421a47e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421a485:	e9 84 00 00 00       	jmpq   800421a50e <vmx_sel_resume+0xa2>
		if (envs[i].env_type == ENV_TYPE_GUEST) {
  800421a48a:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  800421a491:	00 00 00 
  800421a494:	48 8b 10             	mov    (%rax),%rdx
  800421a497:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421a49a:	48 98                	cltq   
  800421a49c:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800421a4a3:	48 01 d0             	add    %rdx,%rax
  800421a4a6:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800421a4ac:	83 f8 03             	cmp    $0x3,%eax
  800421a4af:	75 59                	jne    800421a50a <vmx_sel_resume+0x9e>
			vm_count++;
  800421a4b1:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
			if (vm_count == num) {
  800421a4b5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421a4b8:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800421a4bb:	75 4d                	jne    800421a50a <vmx_sel_resume+0x9e>
				cprintf("Resume vm.%d\n", num);	
  800421a4bd:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421a4c0:	89 c6                	mov    %eax,%esi
  800421a4c2:	48 bf ec 21 22 04 80 	movabs $0x80042221ec,%rdi
  800421a4c9:	00 00 00 
  800421a4cc:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a4d1:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421a4d8:	00 00 00 
  800421a4db:	ff d2                	callq  *%rdx
				envs[i].env_status = ENV_RUNNABLE;
  800421a4dd:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  800421a4e4:	00 00 00 
  800421a4e7:	48 8b 10             	mov    (%rax),%rdx
  800421a4ea:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421a4ed:	48 98                	cltq   
  800421a4ef:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800421a4f6:	48 01 d0             	add    %rdx,%rax
  800421a4f9:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800421a500:	00 00 00 
				return true;
  800421a503:	b8 01 00 00 00       	mov    $0x1,%eax
  800421a508:	eb 36                	jmp    800421a540 <vmx_sel_resume+0xd4>
}

bool vmx_sel_resume(int num) {
	int i;
	int vm_count = 0;
	for (i = 0; i < NENV; ++i) {
  800421a50a:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421a50e:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800421a515:	0f 8e 6f ff ff ff    	jle    800421a48a <vmx_sel_resume+0x1e>
				envs[i].env_status = ENV_RUNNABLE;
				return true;
			}
		}
	}
	cprintf("Selected VM(No.%d VM) not found.\n", num);	
  800421a51b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421a51e:	89 c6                	mov    %eax,%esi
  800421a520:	48 bf 00 22 22 04 80 	movabs $0x8004222200,%rdi
  800421a527:	00 00 00 
  800421a52a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a52f:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421a536:	00 00 00 
  800421a539:	ff d2                	callq  *%rdx
	return false;
  800421a53b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421a540:	c9                   	leaveq 
  800421a541:	c3                   	retq   

000000800421a542 <vmx_check_support>:
 * See Section 23.6 of the Intel manual.
 * 
 * Hint: the TA solution uses the BIT() macro 
 *  to simplify the implementation.
 */
bool vmx_check_support() {
  800421a542:	55                   	push   %rbp
  800421a543:	48 89 e5             	mov    %rsp,%rbp
  800421a546:	48 83 ec 10          	sub    $0x10,%rsp
	uint32_t eax, ebx, ecx, edx;
	cpuid( 1, &eax, &ebx, &ecx, &edx );
  800421a54a:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800421a54e:	48 8d 4d f4          	lea    -0xc(%rbp),%rcx
  800421a552:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  800421a556:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  800421a55a:	49 89 f0             	mov    %rsi,%r8
  800421a55d:	48 89 c6             	mov    %rax,%rsi
  800421a560:	bf 01 00 00 00       	mov    $0x1,%edi
  800421a565:	48 b8 22 a2 21 04 80 	movabs $0x800421a222,%rax
  800421a56c:	00 00 00 
  800421a56f:	ff d0                	callq  *%rax
    return true;	
  800421a571:	b8 01 00 00 00       	mov    $0x1,%eax
	if (BIT(ecx, 5) == 1)
		return true;

	cprintf("[VMM] VMX extension not supported.\n");
	return false;
}
  800421a576:	c9                   	leaveq 
  800421a577:	c3                   	retq   

000000800421a578 <vmx_check_ept>:
 *
 * Hint: This needs to check two MSR bits---first verifying
 *   that secondary VMX controls are enabled, and then that
 *   EPT is available.
 */
bool vmx_check_ept() {
  800421a578:	55                   	push   %rbp
  800421a579:	48 89 e5             	mov    %rsp,%rbp
  800421a57c:	48 83 ec 30          	sub    $0x30,%rsp
  800421a580:	c7 45 f8 82 04 00 00 	movl   $0x482,-0x8(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421a587:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421a58a:	89 c1                	mov    %eax,%ecx
  800421a58c:	0f 32                	rdmsr  
  800421a58e:	89 55 dc             	mov    %edx,-0x24(%rbp)
  800421a591:	89 45 d8             	mov    %eax,-0x28(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421a594:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  800421a59b:	00 
	ret = edx;
  800421a59c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421a59f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	ret = ret << 32;
  800421a5a3:	48 c1 65 d0 20       	shlq   $0x20,-0x30(%rbp)
	ret |= eax;
  800421a5a8:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421a5ab:	48 09 45 d0          	or     %rax,-0x30(%rbp)

	return ret;
  800421a5af:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
	/* Your code here */
	uint32_t vm_primary_msr = (uint32_t) (read_msr(IA32_VMX_PROCBASED_CTLS) >> 32); 
  800421a5b3:	48 c1 e8 20          	shr    $0x20,%rax
  800421a5b7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800421a5ba:	c7 45 f0 8b 04 00 00 	movl   $0x48b,-0x10(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421a5c1:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800421a5c4:	89 c1                	mov    %eax,%ecx
  800421a5c6:	0f 32                	rdmsr  
  800421a5c8:	89 55 ec             	mov    %edx,-0x14(%rbp)
  800421a5cb:	89 45 e8             	mov    %eax,-0x18(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421a5ce:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800421a5d5:	00 
	ret = edx;
  800421a5d6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421a5d9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	ret = ret << 32;
  800421a5dd:	48 c1 65 e0 20       	shlq   $0x20,-0x20(%rbp)
	ret |= eax;
  800421a5e2:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421a5e5:	48 09 45 e0          	or     %rax,-0x20(%rbp)

	return ret;
  800421a5e9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
	uint32_t vm_secondary_msr = (uint32_t) (read_msr(IA32_VMX_PROCBASED_CTLS2) >> 32);	
  800421a5ed:	48 c1 e8 20          	shr    $0x20,%rax
  800421a5f1:	89 45 f4             	mov    %eax,-0xc(%rbp)

    return true;
  800421a5f4:	b8 01 00 00 00       	mov    $0x1,%eax
	if (BIT(vm_primary_msr, 31) == 1 && BIT(vm_secondary_msr, 1) == 1)
		return true;

	cprintf("[VMM] EPT extension not supported.\n");
	return false;
}
  800421a5f9:	c9                   	leaveq 
  800421a5fa:	c3                   	retq   

000000800421a5fb <check_fixed_bits>:

/* Checks if curr_val is compatible with fixed0 and fixed1 
 * (allowed values read from the MSR). This is to ensure current processor
 * operating mode meets the required fixed bit requirement of VMX.  
 */
bool check_fixed_bits( uint64_t curr_val, uint64_t fixed0, uint64_t fixed1 ) {
  800421a5fb:	55                   	push   %rbp
  800421a5fc:	48 89 e5             	mov    %rsp,%rbp
  800421a5ff:	48 83 ec 30          	sub    $0x30,%rsp
  800421a603:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421a607:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421a60b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// TODO: Simplify this code.
	int i;
	for( i = 0 ; i < sizeof( curr_val ) * 8 ; ++i ) {
  800421a60f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421a616:	e9 96 00 00 00       	jmpq   800421a6b1 <check_fixed_bits+0xb6>
		int bit = BIT( curr_val, i );
  800421a61b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421a61e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421a622:	89 c1                	mov    %eax,%ecx
  800421a624:	48 d3 ea             	shr    %cl,%rdx
  800421a627:	48 89 d0             	mov    %rdx,%rax
  800421a62a:	83 e0 01             	and    $0x1,%eax
  800421a62d:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if ( bit == 1 ) {
  800421a630:	83 7d f8 01          	cmpl   $0x1,-0x8(%rbp)
  800421a634:	75 1e                	jne    800421a654 <check_fixed_bits+0x59>
			// Check if this bit is fixed to 0.
			if ( BIT( fixed1, i ) == 0 ) {
  800421a636:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421a639:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421a63d:	89 c1                	mov    %eax,%ecx
  800421a63f:	48 d3 ea             	shr    %cl,%rdx
  800421a642:	48 89 d0             	mov    %rdx,%rax
  800421a645:	83 e0 01             	and    $0x1,%eax
  800421a648:	48 85 c0             	test   %rax,%rax
  800421a64b:	75 60                	jne    800421a6ad <check_fixed_bits+0xb2>
				return false;
  800421a64d:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a652:	eb 6e                	jmp    800421a6c2 <check_fixed_bits+0xc7>
			}
		} else if ( bit == 0 ) {
  800421a654:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800421a658:	75 1e                	jne    800421a678 <check_fixed_bits+0x7d>
			// Check if this bit is fixed to 1.
			if ( BIT( fixed0, i ) == 1 ) {
  800421a65a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421a65d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421a661:	89 c1                	mov    %eax,%ecx
  800421a663:	48 d3 ea             	shr    %cl,%rdx
  800421a666:	48 89 d0             	mov    %rdx,%rax
  800421a669:	83 e0 01             	and    $0x1,%eax
  800421a66c:	48 85 c0             	test   %rax,%rax
  800421a66f:	74 3c                	je     800421a6ad <check_fixed_bits+0xb2>
				return false;
  800421a671:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a676:	eb 4a                	jmp    800421a6c2 <check_fixed_bits+0xc7>
			}
		} else {
			assert(false);
  800421a678:	48 b9 22 22 22 04 80 	movabs $0x8004222222,%rcx
  800421a67f:	00 00 00 
  800421a682:	48 ba 28 22 22 04 80 	movabs $0x8004222228,%rdx
  800421a689:	00 00 00 
  800421a68c:	be 78 00 00 00       	mov    $0x78,%esi
  800421a691:	48 bf 3d 22 22 04 80 	movabs $0x800422223d,%rdi
  800421a698:	00 00 00 
  800421a69b:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a6a0:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421a6a7:	00 00 00 
  800421a6aa:	41 ff d0             	callq  *%r8
 * operating mode meets the required fixed bit requirement of VMX.  
 */
bool check_fixed_bits( uint64_t curr_val, uint64_t fixed0, uint64_t fixed1 ) {
	// TODO: Simplify this code.
	int i;
	for( i = 0 ; i < sizeof( curr_val ) * 8 ; ++i ) {
  800421a6ad:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421a6b1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421a6b4:	83 f8 3f             	cmp    $0x3f,%eax
  800421a6b7:	0f 86 5e ff ff ff    	jbe    800421a61b <check_fixed_bits+0x20>
			}
		} else {
			assert(false);
		}
	}
	return true;
  800421a6bd:	b8 01 00 00 00       	mov    $0x1,%eax
}
  800421a6c2:	c9                   	leaveq 
  800421a6c3:	c3                   	retq   

000000800421a6c4 <vmx_init_vmcs>:

/* 
 * Allocate a page for the VMCS region and write the VMCS Rev. ID in the first 
 * 31 bits.
 */
struct PageInfo * vmx_init_vmcs() {
  800421a6c4:	55                   	push   %rbp
  800421a6c5:	48 89 e5             	mov    %rsp,%rbp
  800421a6c8:	48 83 ec 40          	sub    $0x40,%rsp
  800421a6cc:	c7 45 dc 80 04 00 00 	movl   $0x480,-0x24(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421a6d3:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421a6d6:	89 c1                	mov    %eax,%ecx
  800421a6d8:	0f 32                	rdmsr  
  800421a6da:	89 55 d8             	mov    %edx,-0x28(%rbp)
  800421a6dd:	89 45 d4             	mov    %eax,-0x2c(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421a6e0:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  800421a6e7:	00 
	ret = edx;
  800421a6e8:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421a6eb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	ret = ret << 32;
  800421a6ef:	48 c1 65 c8 20       	shlq   $0x20,-0x38(%rbp)
	ret |= eax;
  800421a6f4:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421a6f7:	48 09 45 c8          	or     %rax,-0x38(%rbp)

	return ret;
  800421a6fb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
	// Read the VMX_BASIC MSR.
	uint64_t vmx_basic_msr =  read_msr( IA32_VMX_BASIC );
  800421a6ff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	uint32_t vmcs_rev_id = (uint32_t) vmx_basic_msr; // Bits 30:0, Bit 31 is always 0.
  800421a703:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421a707:	89 45 c4             	mov    %eax,-0x3c(%rbp)

	uint32_t vmcs_num_bytes =  ( vmx_basic_msr >> 32 ) & 0xfff; // Bits 44:32.
  800421a70a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421a70e:	48 c1 e8 20          	shr    $0x20,%rax
  800421a712:	25 ff 0f 00 00       	and    $0xfff,%eax
  800421a717:	89 45 f4             	mov    %eax,-0xc(%rbp)
	assert( vmcs_num_bytes <= 4096 ); // VMCS can have a max size of 4096.
  800421a71a:	81 7d f4 00 10 00 00 	cmpl   $0x1000,-0xc(%rbp)
  800421a721:	76 35                	jbe    800421a758 <vmx_init_vmcs+0x94>
  800421a723:	48 b9 47 22 22 04 80 	movabs $0x8004222247,%rcx
  800421a72a:	00 00 00 
  800421a72d:	48 ba 28 22 22 04 80 	movabs $0x8004222228,%rdx
  800421a734:	00 00 00 
  800421a737:	be 88 00 00 00       	mov    $0x88,%esi
  800421a73c:	48 bf 3d 22 22 04 80 	movabs $0x800422223d,%rdi
  800421a743:	00 00 00 
  800421a746:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a74b:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421a752:	00 00 00 
  800421a755:	41 ff d0             	callq  *%r8

	//Alocate mem for VMCS region.
	struct PageInfo *p_vmxon_region = page_alloc( ALLOC_ZERO );
  800421a758:	bf 01 00 00 00       	mov    $0x1,%edi
  800421a75d:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  800421a764:	00 00 00 
  800421a767:	ff d0                	callq  *%rax
  800421a769:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if(!p_vmxon_region) {
  800421a76d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800421a772:	75 07                	jne    800421a77b <vmx_init_vmcs+0xb7>
		return NULL;
  800421a774:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a779:	eb 4d                	jmp    800421a7c8 <vmx_init_vmcs+0x104>
	}
	p_vmxon_region->pp_ref += 1; 
  800421a77b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a77f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800421a783:	8d 50 01             	lea    0x1(%rax),%edx
  800421a786:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a78a:	66 89 50 08          	mov    %dx,0x8(%rax)
    
	unsigned char* vmxon_region = (unsigned char *) page2kva( p_vmxon_region );
  800421a78e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a792:	48 89 c7             	mov    %rax,%rdi
  800421a795:	48 b8 e7 a2 21 04 80 	movabs $0x800421a2e7,%rax
  800421a79c:	00 00 00 
  800421a79f:	ff d0                	callq  *%rax
  800421a7a1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memcpy( vmxon_region, &vmcs_rev_id, sizeof( vmcs_rev_id ) );
  800421a7a5:	48 8d 4d c4          	lea    -0x3c(%rbp),%rcx
  800421a7a9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421a7ad:	ba 04 00 00 00       	mov    $0x4,%edx
  800421a7b2:	48 89 ce             	mov    %rcx,%rsi
  800421a7b5:	48 89 c7             	mov    %rax,%rdi
  800421a7b8:	48 b8 5b 13 21 04 80 	movabs $0x800421135b,%rax
  800421a7bf:	00 00 00 
  800421a7c2:	ff d0                	callq  *%rax

	return p_vmxon_region;
  800421a7c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800421a7c8:	c9                   	leaveq 
  800421a7c9:	c3                   	retq   

000000800421a7ca <vmx_init_vmxon>:

/* 
 * Sets up a VMXON region and executes VMXON to put the processor in VMX root 
 * operation. Returns a >=0 value if VMX root operation is achieved.
 */
int vmx_init_vmxon() {
  800421a7ca:	55                   	push   %rbp
  800421a7cb:	48 89 e5             	mov    %rsp,%rbp
  800421a7ce:	53                   	push   %rbx
  800421a7cf:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
    
	//Alocate mem and init the VMXON region.
	struct PageInfo *p_vmxon_region = vmx_init_vmcs();
  800421a7d6:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a7db:	48 ba c4 a6 21 04 80 	movabs $0x800421a6c4,%rdx
  800421a7e2:	00 00 00 
  800421a7e5:	ff d2                	callq  *%rdx
  800421a7e7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if(!p_vmxon_region)
  800421a7eb:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800421a7f0:	75 0a                	jne    800421a7fc <vmx_init_vmxon+0x32>
		return -E_NO_MEM;
  800421a7f2:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800421a7f7:	e9 6b 04 00 00       	jmpq   800421ac67 <vmx_init_vmxon+0x49d>

static __inline uint64_t
rcr0(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr0,%0" : "=r" (val));
  800421a7fc:	0f 20 c0             	mov    %cr0,%rax
  800421a7ff:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	return val;
  800421a803:	48 8b 45 c8          	mov    -0x38(%rbp),%rax

	uint64_t cr0 = rcr0();
  800421a807:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

static __inline uint64_t
rcr4(void)
{
	uint64_t cr4;
	__asm __volatile("movq %%cr4,%0" : "=r" (cr4));
  800421a80b:	0f 20 e0             	mov    %cr4,%rax
  800421a80e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	return cr4;
  800421a812:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
	uint64_t cr4 = rcr4();
  800421a816:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	// Paging and protected mode are enabled in JOS.
    
	// FIXME: Workaround for CR0.NE (bochs needs this to be set to 1)
	cr0 = cr0 | CR0_NE;
  800421a81a:	48 83 4d d0 20       	orq    $0x20,-0x30(%rbp)
  800421a81f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421a823:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
}

static __inline void
lcr0(uint64_t val)
{
	__asm __volatile("movq %0,%%cr0" : : "r" (val));
  800421a827:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421a82b:	0f 22 c0             	mov    %rax,%cr0
  800421a82e:	c7 45 ac 87 04 00 00 	movl   $0x487,-0x54(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421a835:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800421a838:	89 c1                	mov    %eax,%ecx
  800421a83a:	0f 32                	rdmsr  
  800421a83c:	89 95 6c ff ff ff    	mov    %edx,-0x94(%rbp)
  800421a842:	89 85 68 ff ff ff    	mov    %eax,-0x98(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421a848:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
  800421a84f:	00 00 00 00 
	ret = edx;
  800421a853:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
  800421a859:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
	ret = ret << 32;
  800421a860:	48 c1 a5 60 ff ff ff 	shlq   $0x20,-0xa0(%rbp)
  800421a867:	20 
	ret |= eax;
  800421a868:	8b 85 68 ff ff ff    	mov    -0x98(%rbp),%eax
  800421a86e:	48 09 85 60 ff ff ff 	or     %rax,-0xa0(%rbp)

	return ret;
  800421a875:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421a87c:	c7 45 80 86 04 00 00 	movl   $0x486,-0x80(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421a883:	8b 45 80             	mov    -0x80(%rbp),%eax
  800421a886:	89 c1                	mov    %eax,%ecx
  800421a888:	0f 32                	rdmsr  
  800421a88a:	89 95 7c ff ff ff    	mov    %edx,-0x84(%rbp)
  800421a890:	89 85 78 ff ff ff    	mov    %eax,-0x88(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421a896:	48 c7 85 70 ff ff ff 	movq   $0x0,-0x90(%rbp)
  800421a89d:	00 00 00 00 
	ret = edx;
  800421a8a1:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
  800421a8a7:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	ret = ret << 32;
  800421a8ae:	48 c1 a5 70 ff ff ff 	shlq   $0x20,-0x90(%rbp)
  800421a8b5:	20 
	ret |= eax;
  800421a8b6:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
  800421a8bc:	48 09 85 70 ff ff ff 	or     %rax,-0x90(%rbp)

	return ret;
  800421a8c3:	48 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%rcx
	lcr0( cr0 );

	bool ret =  check_fixed_bits( cr0,
  800421a8ca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421a8ce:	48 89 f2             	mov    %rsi,%rdx
  800421a8d1:	48 89 ce             	mov    %rcx,%rsi
  800421a8d4:	48 89 c7             	mov    %rax,%rdi
  800421a8d7:	48 b8 fb a5 21 04 80 	movabs $0x800421a5fb,%rax
  800421a8de:	00 00 00 
  800421a8e1:	ff d0                	callq  *%rax
  800421a8e3:	88 45 ab             	mov    %al,-0x55(%rbp)
				      read_msr( IA32_VMX_CR0_FIXED0 ), 
				      read_msr( IA32_VMX_CR0_FIXED1 ) );
	if ( !ret ) {
  800421a8e6:	0f b6 45 ab          	movzbl -0x55(%rbp),%eax
  800421a8ea:	83 f0 01             	xor    $0x1,%eax
  800421a8ed:	84 c0                	test   %al,%al
  800421a8ef:	74 1d                	je     800421a90e <vmx_init_vmxon+0x144>
		page_decref( p_vmxon_region );
  800421a8f1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421a8f5:	48 89 c7             	mov    %rax,%rdi
  800421a8f8:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  800421a8ff:	00 00 00 
  800421a902:	ff d0                	callq  *%rax
		return -E_VMX_ON;
  800421a904:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
  800421a909:	e9 59 03 00 00       	jmpq   800421ac67 <vmx_init_vmxon+0x49d>
	}
	// Enable VMX in CR4.
	cr4 = cr4 | CR4_VMXE;
  800421a90e:	48 81 4d c0 00 20 00 	orq    $0x2000,-0x40(%rbp)
  800421a915:	00 
  800421a916:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421a91a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
}

static __inline void
lcr4(uint64_t val)
{
	__asm __volatile("movq %0,%%cr4" : : "r" (val));
  800421a91e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421a922:	0f 22 e0             	mov    %rax,%cr4
  800421a925:	c7 45 94 89 04 00 00 	movl   $0x489,-0x6c(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421a92c:	8b 45 94             	mov    -0x6c(%rbp),%eax
  800421a92f:	89 c1                	mov    %eax,%ecx
  800421a931:	0f 32                	rdmsr  
  800421a933:	89 95 4c ff ff ff    	mov    %edx,-0xb4(%rbp)
  800421a939:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421a93f:	48 c7 85 40 ff ff ff 	movq   $0x0,-0xc0(%rbp)
  800421a946:	00 00 00 00 
	ret = edx;
  800421a94a:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
  800421a950:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	ret = ret << 32;
  800421a957:	48 c1 a5 40 ff ff ff 	shlq   $0x20,-0xc0(%rbp)
  800421a95e:	20 
	ret |= eax;
  800421a95f:	8b 85 48 ff ff ff    	mov    -0xb8(%rbp),%eax
  800421a965:	48 09 85 40 ff ff ff 	or     %rax,-0xc0(%rbp)

	return ret;
  800421a96c:	48 8b b5 40 ff ff ff 	mov    -0xc0(%rbp),%rsi
  800421a973:	c7 45 dc 88 04 00 00 	movl   $0x488,-0x24(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421a97a:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421a97d:	89 c1                	mov    %eax,%ecx
  800421a97f:	0f 32                	rdmsr  
  800421a981:	89 95 5c ff ff ff    	mov    %edx,-0xa4(%rbp)
  800421a987:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421a98d:	48 c7 85 50 ff ff ff 	movq   $0x0,-0xb0(%rbp)
  800421a994:	00 00 00 00 
	ret = edx;
  800421a998:	8b 85 5c ff ff ff    	mov    -0xa4(%rbp),%eax
  800421a99e:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
	ret = ret << 32;
  800421a9a5:	48 c1 a5 50 ff ff ff 	shlq   $0x20,-0xb0(%rbp)
  800421a9ac:	20 
	ret |= eax;
  800421a9ad:	8b 85 58 ff ff ff    	mov    -0xa8(%rbp),%eax
  800421a9b3:	48 09 85 50 ff ff ff 	or     %rax,-0xb0(%rbp)

	return ret;
  800421a9ba:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
	lcr4( cr4 );
	ret =  check_fixed_bits( cr4,
  800421a9c1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421a9c5:	48 89 f2             	mov    %rsi,%rdx
  800421a9c8:	48 89 ce             	mov    %rcx,%rsi
  800421a9cb:	48 89 c7             	mov    %rax,%rdi
  800421a9ce:	48 b8 fb a5 21 04 80 	movabs $0x800421a5fb,%rax
  800421a9d5:	00 00 00 
  800421a9d8:	ff d0                	callq  *%rax
  800421a9da:	88 45 ab             	mov    %al,-0x55(%rbp)
				 read_msr( IA32_VMX_CR4_FIXED0 ), 
				 read_msr( IA32_VMX_CR4_FIXED1 ) );
	if ( !ret ) {
  800421a9dd:	0f b6 45 ab          	movzbl -0x55(%rbp),%eax
  800421a9e1:	83 f0 01             	xor    $0x1,%eax
  800421a9e4:	84 c0                	test   %al,%al
  800421a9e6:	74 1d                	je     800421aa05 <vmx_init_vmxon+0x23b>
		page_decref( p_vmxon_region );
  800421a9e8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421a9ec:	48 89 c7             	mov    %rax,%rdi
  800421a9ef:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  800421a9f6:	00 00 00 
  800421a9f9:	ff d0                	callq  *%rax
		return -E_VMX_ON;
  800421a9fb:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
  800421aa00:	e9 62 02 00 00       	jmpq   800421ac67 <vmx_init_vmxon+0x49d>
  800421aa05:	c7 45 a4 3a 00 00 00 	movl   $0x3a,-0x5c(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421aa0c:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800421aa0f:	89 c1                	mov    %eax,%ecx
  800421aa11:	0f 32                	rdmsr  
  800421aa13:	89 95 3c ff ff ff    	mov    %edx,-0xc4(%rbp)
  800421aa19:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421aa1f:	48 c7 85 30 ff ff ff 	movq   $0x0,-0xd0(%rbp)
  800421aa26:	00 00 00 00 
	ret = edx;
  800421aa2a:	8b 85 3c ff ff ff    	mov    -0xc4(%rbp),%eax
  800421aa30:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
	ret = ret << 32;
  800421aa37:	48 c1 a5 30 ff ff ff 	shlq   $0x20,-0xd0(%rbp)
  800421aa3e:	20 
	ret |= eax;
  800421aa3f:	8b 85 38 ff ff ff    	mov    -0xc8(%rbp),%eax
  800421aa45:	48 09 85 30 ff ff ff 	or     %rax,-0xd0(%rbp)

	return ret;
  800421aa4c:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
	}
	// Ensure that IA32_FEATURE_CONTROL MSR has been properly programmed and 
	// and that it's lock bit has been set.
	uint64_t feature_control = read_msr( IA32_FEATURE_CONTROL );
  800421aa53:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if ( !BIT( feature_control, 2 )) {
  800421aa57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421aa5b:	83 e0 04             	and    $0x4,%eax
  800421aa5e:	48 85 c0             	test   %rax,%rax
  800421aa61:	0f 85 dc 00 00 00    	jne    800421ab43 <vmx_init_vmxon+0x379>
		// DEP 1/14/17: qemu does not appear to properly implement a VMX-compatible BIOS.
		//   Assuming we will be running on qemu, let's just set the MSR bit in the vmm,
		//   which is how the qemu authors read the Intel manual.
		feature_control |= 0x4;
  800421aa67:	48 83 4d e8 04       	orq    $0x4,-0x18(%rbp)
  800421aa6c:	c7 45 88 3a 00 00 00 	movl   $0x3a,-0x78(%rbp)
  800421aa73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421aa77:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
}

static __inline void
write_msr( uint32_t ecx, uint64_t val ) {
	uint32_t edx, eax;
	eax = (uint32_t) val;
  800421aa7e:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800421aa85:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
	edx = (uint32_t) ( val >> 32 );
  800421aa8b:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800421aa92:	48 c1 e8 20          	shr    $0x20,%rax
  800421aa96:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%rbp)
	__asm __volatile("wrmsr"
  800421aa9c:	8b 4d 88             	mov    -0x78(%rbp),%ecx
  800421aa9f:	8b 95 10 ff ff ff    	mov    -0xf0(%rbp),%edx
  800421aaa5:	8b 85 14 ff ff ff    	mov    -0xec(%rbp),%eax
  800421aaab:	0f 30                	wrmsr  
  800421aaad:	c7 45 90 3a 00 00 00 	movl   $0x3a,-0x70(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421aab4:	8b 45 90             	mov    -0x70(%rbp),%eax
  800421aab7:	89 c1                	mov    %eax,%ecx
  800421aab9:	0f 32                	rdmsr  
  800421aabb:	89 95 2c ff ff ff    	mov    %edx,-0xd4(%rbp)
  800421aac1:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421aac7:	48 c7 85 20 ff ff ff 	movq   $0x0,-0xe0(%rbp)
  800421aace:	00 00 00 00 
	ret = edx;
  800421aad2:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
  800421aad8:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
	ret = ret << 32;
  800421aadf:	48 c1 a5 20 ff ff ff 	shlq   $0x20,-0xe0(%rbp)
  800421aae6:	20 
	ret |= eax;
  800421aae7:	8b 85 28 ff ff ff    	mov    -0xd8(%rbp),%eax
  800421aaed:	48 09 85 20 ff ff ff 	or     %rax,-0xe0(%rbp)

	return ret;
  800421aaf4:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
		write_msr( IA32_FEATURE_CONTROL, feature_control );   
		// See if the attempt "took"
		feature_control = read_msr( IA32_FEATURE_CONTROL );
  800421aafb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if ( !BIT( feature_control, 2 )) {
  800421aaff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421ab03:	83 e0 04             	and    $0x4,%eax
  800421ab06:	48 85 c0             	test   %rax,%rax
  800421ab09:	75 38                	jne    800421ab43 <vmx_init_vmxon+0x379>
			page_decref( p_vmxon_region );
  800421ab0b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421ab0f:	48 89 c7             	mov    %rax,%rdi
  800421ab12:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  800421ab19:	00 00 00 
  800421ab1c:	ff d0                	callq  *%rax
			// VMX disabled in BIOS.
			cprintf("Unable to start VMM: VMX disabled in BIOS\n");
  800421ab1e:	48 bf 60 22 22 04 80 	movabs $0x8004222260,%rdi
  800421ab25:	00 00 00 
  800421ab28:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ab2d:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421ab34:	00 00 00 
  800421ab37:	ff d2                	callq  *%rdx
			return -E_NO_VMX;
  800421ab39:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
  800421ab3e:	e9 24 01 00 00       	jmpq   800421ac67 <vmx_init_vmxon+0x49d>
		}
	}
	if ( !BIT( feature_control, 0 )) {
  800421ab43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421ab47:	83 e0 01             	and    $0x1,%eax
  800421ab4a:	48 85 c0             	test   %rax,%rax
  800421ab4d:	75 46                	jne    800421ab95 <vmx_init_vmxon+0x3cb>
		// Lock bit not set, try setting it.
		feature_control |= 0x1;
  800421ab4f:	48 83 4d e8 01       	orq    $0x1,-0x18(%rbp)
  800421ab54:	c7 45 8c 3a 00 00 00 	movl   $0x3a,-0x74(%rbp)
  800421ab5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421ab5f:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
}

static __inline void
write_msr( uint32_t ecx, uint64_t val ) {
	uint32_t edx, eax;
	eax = (uint32_t) val;
  800421ab66:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800421ab6d:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%rbp)
	edx = (uint32_t) ( val >> 32 );
  800421ab73:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800421ab7a:	48 c1 e8 20          	shr    $0x20,%rax
  800421ab7e:	89 85 00 ff ff ff    	mov    %eax,-0x100(%rbp)
	__asm __volatile("wrmsr"
  800421ab84:	8b 4d 8c             	mov    -0x74(%rbp),%ecx
  800421ab87:	8b 95 00 ff ff ff    	mov    -0x100(%rbp),%edx
  800421ab8d:	8b 85 04 ff ff ff    	mov    -0xfc(%rbp),%eax
  800421ab93:	0f 30                	wrmsr  
		write_msr( IA32_FEATURE_CONTROL, feature_control );   
	}
    
	uint8_t error = vmxon( (physaddr_t) page2pa( p_vmxon_region ) );
  800421ab95:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421ab99:	48 89 c7             	mov    %rax,%rdi
  800421ab9c:	48 b8 c2 a2 21 04 80 	movabs $0x800421a2c2,%rax
  800421aba3:	00 00 00 
  800421aba6:	ff d0                	callq  *%rax
  800421aba8:	48 89 85 f8 fe ff ff 	mov    %rax,-0x108(%rbp)
static __inline uint8_t vmptrld( physaddr_t vmcs_region ) __attribute((always_inline));


static __inline uint8_t
vmxon( physaddr_t vmxon_region ) {
	uint8_t error = 0;
  800421abaf:	c6 45 87 00          	movb   $0x0,-0x79(%rbp)

    __asm __volatile("clc; vmxon %1; setna %0"
  800421abb3:	f8                   	clc    
  800421abb4:	f3 0f c7 b5 f8 fe ff 	vmxon  -0x108(%rbp)
  800421abbb:	ff 
  800421abbc:	0f 96 c0             	setbe  %al
  800421abbf:	88 45 87             	mov    %al,-0x79(%rbp)
            : "=q"( error ) : "m" ( vmxon_region ): "cc" );
    return error;
  800421abc2:	0f b6 45 87          	movzbl -0x79(%rbp),%eax
  800421abc6:	88 45 86             	mov    %al,-0x7a(%rbp)
	if ( error ) { 
  800421abc9:	80 7d 86 00          	cmpb   $0x0,-0x7a(%rbp)
  800421abcd:	74 1a                	je     800421abe9 <vmx_init_vmxon+0x41f>
		page_decref( p_vmxon_region );
  800421abcf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421abd3:	48 89 c7             	mov    %rax,%rdi
  800421abd6:	48 b8 e7 2f 20 04 80 	movabs $0x8004202fe7,%rax
  800421abdd:	00 00 00 
  800421abe0:	ff d0                	callq  *%rax
		return -E_VMX_ON; 
  800421abe2:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
  800421abe7:	eb 7e                	jmp    800421ac67 <vmx_init_vmxon+0x49d>
	}

	thiscpu->is_vmx_root = true;
  800421abe9:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421abf0:	00 00 00 
  800421abf3:	ff d0                	callq  *%rax
  800421abf5:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421abfc:	00 00 00 
  800421abff:	48 98                	cltq   
  800421ac01:	48 c1 e0 03          	shl    $0x3,%rax
  800421ac05:	48 89 c1             	mov    %rax,%rcx
  800421ac08:	48 c1 e1 04          	shl    $0x4,%rcx
  800421ac0c:	48 01 c8             	add    %rcx,%rax
  800421ac0f:	48 01 d0             	add    %rdx,%rax
  800421ac12:	48 83 c0 78          	add    $0x78,%rax
  800421ac16:	c6 00 01             	movb   $0x1,(%rax)
	thiscpu->vmxon_region = (uintptr_t) page2kva( p_vmxon_region );
  800421ac19:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421ac20:	00 00 00 
  800421ac23:	ff d0                	callq  *%rax
  800421ac25:	89 c3                	mov    %eax,%ebx
  800421ac27:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421ac2b:	48 89 c7             	mov    %rax,%rdi
  800421ac2e:	48 b8 e7 a2 21 04 80 	movabs $0x800421a2e7,%rax
  800421ac35:	00 00 00 
  800421ac38:	ff d0                	callq  *%rax
  800421ac3a:	48 89 c6             	mov    %rax,%rsi
  800421ac3d:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421ac44:	00 00 00 
  800421ac47:	48 63 c3             	movslq %ebx,%rax
  800421ac4a:	48 c1 e0 03          	shl    $0x3,%rax
  800421ac4e:	48 89 c1             	mov    %rax,%rcx
  800421ac51:	48 c1 e1 04          	shl    $0x4,%rcx
  800421ac55:	48 01 c8             	add    %rcx,%rax
  800421ac58:	48 01 d0             	add    %rdx,%rax
  800421ac5b:	48 83 e8 80          	sub    $0xffffffffffffff80,%rax
  800421ac5f:	48 89 30             	mov    %rsi,(%rax)

	return 0;
  800421ac62:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421ac67:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  800421ac6e:	5b                   	pop    %rbx
  800421ac6f:	5d                   	pop    %rbp
  800421ac70:	c3                   	retq   

000000800421ac71 <vmcs_host_init>:

void vmcs_host_init() {
  800421ac71:	55                   	push   %rbp
  800421ac72:	48 89 e5             	mov    %rsp,%rbp
  800421ac75:	48 81 ec 20 01 00 00 	sub    $0x120,%rsp

static __inline uint64_t
rcr0(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr0,%0" : "=r" (val));
  800421ac7c:	0f 20 c0             	mov    %cr0,%rax
  800421ac7f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return val;
  800421ac83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421ac87:	c7 45 f4 00 6c 00 00 	movl   $0x6c00,-0xc(%rbp)
  800421ac8e:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421ac95:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800421ac9c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421ac9f:	48 89 d6             	mov    %rdx,%rsi
  800421aca2:	89 c7                	mov    %eax,%edi
  800421aca4:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421acab:	00 00 00 
  800421acae:	ff d0                	callq  *%rax

static __inline uint64_t
rcr3(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr3,%0" : "=r" (val));
  800421acb0:	0f 20 d8             	mov    %cr3,%rax
  800421acb3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	return val;
  800421acb7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421acbb:	c7 45 e4 02 6c 00 00 	movl   $0x6c02,-0x1c(%rbp)
  800421acc2:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  800421acc9:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
  800421acd0:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421acd3:	48 89 d6             	mov    %rdx,%rsi
  800421acd6:	89 c7                	mov    %eax,%edi
  800421acd8:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421acdf:	00 00 00 
  800421ace2:	ff d0                	callq  *%rax

static __inline uint64_t
rcr4(void)
{
	uint64_t cr4;
	__asm __volatile("movq %%cr4,%0" : "=r" (cr4));
  800421ace4:	0f 20 e0             	mov    %cr4,%rax
  800421ace7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	return cr4;
  800421aceb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421acef:	c7 45 d4 04 6c 00 00 	movl   $0x6c04,-0x2c(%rbp)
  800421acf6:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  800421acfd:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  800421ad04:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421ad07:	48 89 d6             	mov    %rdx,%rsi
  800421ad0a:	89 c7                	mov    %eax,%edi
  800421ad0c:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421ad13:	00 00 00 
  800421ad16:	ff d0                	callq  *%rax
  800421ad18:	c7 45 d0 00 0c 00 00 	movl   $0xc00,-0x30(%rbp)
  800421ad1f:	66 c7 85 32 ff ff ff 	movw   $0x10,-0xce(%rbp)
  800421ad26:	10 00 
		       : "=q"( error ) : "a"( value ), "d"( field ) : "cc");
    return error;
}

static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
  800421ad28:	0f b7 95 32 ff ff ff 	movzwl -0xce(%rbp),%edx
  800421ad2f:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800421ad32:	48 89 d6             	mov    %rdx,%rsi
  800421ad35:	89 c7                	mov    %eax,%edi
  800421ad37:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421ad3e:	00 00 00 
  800421ad41:	ff d0                	callq  *%rax
  800421ad43:	c7 45 cc 04 0c 00 00 	movl   $0xc04,-0x34(%rbp)
  800421ad4a:	66 c7 85 34 ff ff ff 	movw   $0x10,-0xcc(%rbp)
  800421ad51:	10 00 
  800421ad53:	0f b7 95 34 ff ff ff 	movzwl -0xcc(%rbp),%edx
  800421ad5a:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421ad5d:	48 89 d6             	mov    %rdx,%rsi
  800421ad60:	89 c7                	mov    %eax,%edi
  800421ad62:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421ad69:	00 00 00 
  800421ad6c:	ff d0                	callq  *%rax
  800421ad6e:	c7 45 c8 06 0c 00 00 	movl   $0xc06,-0x38(%rbp)
  800421ad75:	66 c7 85 36 ff ff ff 	movw   $0x10,-0xca(%rbp)
  800421ad7c:	10 00 
  800421ad7e:	0f b7 95 36 ff ff ff 	movzwl -0xca(%rbp),%edx
  800421ad85:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421ad88:	48 89 d6             	mov    %rdx,%rsi
  800421ad8b:	89 c7                	mov    %eax,%edi
  800421ad8d:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421ad94:	00 00 00 
  800421ad97:	ff d0                	callq  *%rax
  800421ad99:	c7 45 c4 08 0c 00 00 	movl   $0xc08,-0x3c(%rbp)
  800421ada0:	66 c7 85 38 ff ff ff 	movw   $0x10,-0xc8(%rbp)
  800421ada7:	10 00 
  800421ada9:	0f b7 95 38 ff ff ff 	movzwl -0xc8(%rbp),%edx
  800421adb0:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421adb3:	48 89 d6             	mov    %rdx,%rsi
  800421adb6:	89 c7                	mov    %eax,%edi
  800421adb8:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421adbf:	00 00 00 
  800421adc2:	ff d0                	callq  *%rax
  800421adc4:	c7 45 c0 0a 0c 00 00 	movl   $0xc0a,-0x40(%rbp)
  800421adcb:	66 c7 85 3a ff ff ff 	movw   $0x10,-0xc6(%rbp)
  800421add2:	10 00 
  800421add4:	0f b7 95 3a ff ff ff 	movzwl -0xc6(%rbp),%edx
  800421addb:	8b 45 c0             	mov    -0x40(%rbp),%eax
  800421adde:	48 89 d6             	mov    %rdx,%rsi
  800421ade1:	89 c7                	mov    %eax,%edi
  800421ade3:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421adea:	00 00 00 
  800421aded:	ff d0                	callq  *%rax
  800421adef:	c7 45 b8 02 0c 00 00 	movl   $0xc02,-0x48(%rbp)
  800421adf6:	66 c7 85 3c ff ff ff 	movw   $0x8,-0xc4(%rbp)
  800421adfd:	08 00 
  800421adff:	0f b7 95 3c ff ff ff 	movzwl -0xc4(%rbp),%edx
  800421ae06:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800421ae09:	48 89 d6             	mov    %rdx,%rsi
  800421ae0c:	89 c7                	mov    %eax,%edi
  800421ae0e:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421ae15:	00 00 00 
  800421ae18:	ff d0                	callq  *%rax
	vmcs_write16( VMCS_16BIT_HOST_DS_SELECTOR, GD_KD );
	vmcs_write16( VMCS_16BIT_HOST_FS_SELECTOR, GD_KD );
	vmcs_write16( VMCS_16BIT_HOST_GS_SELECTOR, GD_KD );
	vmcs_write16( VMCS_16BIT_HOST_CS_SELECTOR, GD_KT );

	int gd_tss = (GD_TSS0 >> 3) + thiscpu->cpu_id*2;
  800421ae1a:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421ae21:	00 00 00 
  800421ae24:	ff d0                	callq  *%rax
  800421ae26:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421ae2d:	00 00 00 
  800421ae30:	48 98                	cltq   
  800421ae32:	48 c1 e0 03          	shl    $0x3,%rax
  800421ae36:	48 89 c1             	mov    %rax,%rcx
  800421ae39:	48 c1 e1 04          	shl    $0x4,%rcx
  800421ae3d:	48 01 c8             	add    %rcx,%rax
  800421ae40:	48 01 d0             	add    %rdx,%rax
  800421ae43:	0f b6 00             	movzbl (%rax),%eax
  800421ae46:	0f b6 c0             	movzbl %al,%eax
  800421ae49:	01 c0                	add    %eax,%eax
  800421ae4b:	83 c0 05             	add    $0x5,%eax
  800421ae4e:	89 45 bc             	mov    %eax,-0x44(%rbp)
	vmcs_write16( VMCS_16BIT_HOST_TR_SELECTOR, gd_tss << 3 );
  800421ae51:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800421ae54:	c1 e0 03             	shl    $0x3,%eax
  800421ae57:	0f b7 c0             	movzwl %ax,%eax
  800421ae5a:	c7 45 b4 0c 0c 00 00 	movl   $0xc0c,-0x4c(%rbp)
  800421ae61:	66 89 85 3e ff ff ff 	mov    %ax,-0xc2(%rbp)
  800421ae68:	0f b7 95 3e ff ff ff 	movzwl -0xc2(%rbp),%edx
  800421ae6f:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800421ae72:	48 89 d6             	mov    %rdx,%rsi
  800421ae75:	89 c7                	mov    %eax,%edi
  800421ae77:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421ae7e:	00 00 00 
  800421ae81:	ff d0                	callq  *%rax
  800421ae83:	48 8d 85 08 ff ff ff 	lea    -0xf8(%rbp),%rax
  800421ae8a:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  800421ae8e:	48 8d 85 16 ff ff ff 	lea    -0xea(%rbp),%rax
  800421ae95:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
static __inline void
read_idtr (uint64_t *idtbase, uint16_t *idtlimit)
{
	struct Pseudodesc idtr;

	asm volatile ("sidt %0"
  800421ae9c:	0f 01 8d f0 fe ff ff 	sidt   -0x110(%rbp)
			: "=m" (idtr));
	*idtbase = idtr.pd_base;
  800421aea3:	48 8b 95 f2 fe ff ff 	mov    -0x10e(%rbp),%rdx
  800421aeaa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421aeae:	48 89 10             	mov    %rdx,(%rax)
	*idtlimit = idtr.pd_lim;
  800421aeb1:	0f b7 95 f0 fe ff ff 	movzwl -0x110(%rbp),%edx
  800421aeb8:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  800421aebf:	66 89 10             	mov    %dx,(%rax)
    
	uint16_t xdtr_limit;
	uint64_t xdtr_base;
	read_idtr( &xdtr_base, &xdtr_limit );
	vmcs_write64( VMCS_HOST_IDTR_BASE, xdtr_base );
  800421aec2:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800421aec9:	c7 45 a4 0e 6c 00 00 	movl   $0x6c0e,-0x5c(%rbp)
  800421aed0:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421aed7:	48 8b 95 48 ff ff ff 	mov    -0xb8(%rbp),%rdx
  800421aede:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800421aee1:	48 89 d6             	mov    %rdx,%rsi
  800421aee4:	89 c7                	mov    %eax,%edi
  800421aee6:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421aeed:	00 00 00 
  800421aef0:	ff d0                	callq  *%rax
  800421aef2:	48 8d 85 08 ff ff ff 	lea    -0xf8(%rbp),%rax
  800421aef9:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  800421aefd:	48 8d 85 16 ff ff ff 	lea    -0xea(%rbp),%rax
  800421af04:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
static __inline void
read_gdtr (uint64_t *gdtbase, uint16_t *gdtlimit)
{
	struct Pseudodesc gdtr;

	asm volatile ("sgdt %0"
  800421af0b:	0f 01 85 e0 fe ff ff 	sgdt   -0x120(%rbp)
			: "=m" (gdtr));
	*gdtbase = gdtr.pd_base;
  800421af12:	48 8b 95 e2 fe ff ff 	mov    -0x11e(%rbp),%rdx
  800421af19:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421af1d:	48 89 10             	mov    %rdx,(%rax)
	*gdtlimit = gdtr.pd_lim;
  800421af20:	0f b7 95 e0 fe ff ff 	movzwl -0x120(%rbp),%edx
  800421af27:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800421af2e:	66 89 10             	mov    %dx,(%rax)

	read_gdtr( &xdtr_base, &xdtr_limit );
	vmcs_write64( VMCS_HOST_GDTR_BASE, xdtr_base );
  800421af31:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800421af38:	c7 45 94 0c 6c 00 00 	movl   $0x6c0c,-0x6c(%rbp)
  800421af3f:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  800421af46:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800421af4d:	8b 45 94             	mov    -0x6c(%rbp),%eax
  800421af50:	48 89 d6             	mov    %rdx,%rsi
  800421af53:	89 c7                	mov    %eax,%edi
  800421af55:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421af5c:	00 00 00 
  800421af5f:	ff d0                	callq  *%rax
  800421af61:	c7 45 90 06 6c 00 00 	movl   $0x6c06,-0x70(%rbp)
  800421af68:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
  800421af6f:	00 00 00 00 
  800421af73:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421af7a:	8b 45 90             	mov    -0x70(%rbp),%eax
  800421af7d:	48 89 d6             	mov    %rdx,%rsi
  800421af80:	89 c7                	mov    %eax,%edi
  800421af82:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421af89:	00 00 00 
  800421af8c:	ff d0                	callq  *%rax
  800421af8e:	c7 45 8c 08 6c 00 00 	movl   $0x6c08,-0x74(%rbp)
  800421af95:	48 c7 85 68 ff ff ff 	movq   $0x0,-0x98(%rbp)
  800421af9c:	00 00 00 00 
  800421afa0:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  800421afa7:	8b 45 8c             	mov    -0x74(%rbp),%eax
  800421afaa:	48 89 d6             	mov    %rdx,%rsi
  800421afad:	89 c7                	mov    %eax,%edi
  800421afaf:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421afb6:	00 00 00 
  800421afb9:	ff d0                	callq  *%rax

	vmcs_write64( VMCS_HOST_FS_BASE, 0x0 );
	vmcs_write64( VMCS_HOST_GS_BASE, 0x0 );
	vmcs_write64( VMCS_HOST_TR_BASE, (uint64_t) &thiscpu->cpu_ts );
  800421afbb:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421afc2:	00 00 00 
  800421afc5:	ff d0                	callq  *%rax
  800421afc7:	48 98                	cltq   
  800421afc9:	48 c1 e0 03          	shl    $0x3,%rax
  800421afcd:	48 89 c2             	mov    %rax,%rdx
  800421afd0:	48 c1 e2 04          	shl    $0x4,%rdx
  800421afd4:	48 01 d0             	add    %rdx,%rax
  800421afd7:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800421afdb:	48 b8 20 10 6e 04 80 	movabs $0x80046e1020,%rax
  800421afe2:	00 00 00 
  800421afe5:	48 01 d0             	add    %rdx,%rax
  800421afe8:	c7 85 7c ff ff ff 0a 	movl   $0x6c0a,-0x84(%rbp)
  800421afef:	6c 00 00 
  800421aff2:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  800421aff9:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800421b000:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
  800421b006:	48 89 d6             	mov    %rdx,%rsi
  800421b009:	89 c7                	mov    %eax,%edi
  800421b00b:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b012:	00 00 00 
  800421b015:	ff d0                	callq  *%rax

	uint64_t tmpl;
	asm("movabs $.Lvmx_return, %0" : "=r"(tmpl));
  800421b017:	48 b8 ef da 21 04 80 	movabs $0x800421daef,%rax
  800421b01e:	00 00 00 
  800421b021:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	vmcs_writel(VMCS_HOST_RIP, tmpl);
  800421b025:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421b029:	48 89 c6             	mov    %rax,%rsi
  800421b02c:	bf 16 6c 00 00       	mov    $0x6c16,%edi
  800421b031:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b038:	00 00 00 
  800421b03b:	ff d0                	callq  *%rax
}
  800421b03d:	90                   	nop
  800421b03e:	c9                   	leaveq 
  800421b03f:	c3                   	retq   

000000800421b040 <vmcs_guest_init>:

void vmcs_guest_init() {
  800421b040:	55                   	push   %rbp
  800421b041:	48 89 e5             	mov    %rsp,%rbp
  800421b044:	48 81 ec a0 01 00 00 	sub    $0x1a0,%rsp
  800421b04b:	c7 45 fc 02 08 00 00 	movl   $0x802,-0x4(%rbp)
  800421b052:	66 c7 85 60 fe ff ff 	movw   $0x0,-0x1a0(%rbp)
  800421b059:	00 00 
		       : "=q"( error ) : "a"( value ), "d"( field ) : "cc");
    return error;
}

static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
  800421b05b:	0f b7 95 60 fe ff ff 	movzwl -0x1a0(%rbp),%edx
  800421b062:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421b065:	48 89 d6             	mov    %rdx,%rsi
  800421b068:	89 c7                	mov    %eax,%edi
  800421b06a:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b071:	00 00 00 
  800421b074:	ff d0                	callq  *%rax
  800421b076:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%rbp)
  800421b07d:	66 c7 85 62 fe ff ff 	movw   $0x0,-0x19e(%rbp)
  800421b084:	00 00 
  800421b086:	0f b7 95 62 fe ff ff 	movzwl -0x19e(%rbp),%edx
  800421b08d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421b090:	48 89 d6             	mov    %rdx,%rsi
  800421b093:	89 c7                	mov    %eax,%edi
  800421b095:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b09c:	00 00 00 
  800421b09f:	ff d0                	callq  *%rax
  800421b0a1:	c7 45 f4 04 08 00 00 	movl   $0x804,-0xc(%rbp)
  800421b0a8:	66 c7 85 64 fe ff ff 	movw   $0x0,-0x19c(%rbp)
  800421b0af:	00 00 
  800421b0b1:	0f b7 95 64 fe ff ff 	movzwl -0x19c(%rbp),%edx
  800421b0b8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421b0bb:	48 89 d6             	mov    %rdx,%rsi
  800421b0be:	89 c7                	mov    %eax,%edi
  800421b0c0:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b0c7:	00 00 00 
  800421b0ca:	ff d0                	callq  *%rax
  800421b0cc:	c7 45 f0 06 08 00 00 	movl   $0x806,-0x10(%rbp)
  800421b0d3:	66 c7 85 66 fe ff ff 	movw   $0x0,-0x19a(%rbp)
  800421b0da:	00 00 
  800421b0dc:	0f b7 95 66 fe ff ff 	movzwl -0x19a(%rbp),%edx
  800421b0e3:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800421b0e6:	48 89 d6             	mov    %rdx,%rsi
  800421b0e9:	89 c7                	mov    %eax,%edi
  800421b0eb:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b0f2:	00 00 00 
  800421b0f5:	ff d0                	callq  *%rax
  800421b0f7:	c7 45 ec 08 08 00 00 	movl   $0x808,-0x14(%rbp)
  800421b0fe:	66 c7 85 68 fe ff ff 	movw   $0x0,-0x198(%rbp)
  800421b105:	00 00 
  800421b107:	0f b7 95 68 fe ff ff 	movzwl -0x198(%rbp),%edx
  800421b10e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421b111:	48 89 d6             	mov    %rdx,%rsi
  800421b114:	89 c7                	mov    %eax,%edi
  800421b116:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b11d:	00 00 00 
  800421b120:	ff d0                	callq  *%rax
  800421b122:	c7 45 e8 0a 08 00 00 	movl   $0x80a,-0x18(%rbp)
  800421b129:	66 c7 85 6a fe ff ff 	movw   $0x0,-0x196(%rbp)
  800421b130:	00 00 
  800421b132:	0f b7 95 6a fe ff ff 	movzwl -0x196(%rbp),%edx
  800421b139:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421b13c:	48 89 d6             	mov    %rdx,%rsi
  800421b13f:	89 c7                	mov    %eax,%edi
  800421b141:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b148:	00 00 00 
  800421b14b:	ff d0                	callq  *%rax
  800421b14d:	c7 45 e4 0e 08 00 00 	movl   $0x80e,-0x1c(%rbp)
  800421b154:	66 c7 85 6c fe ff ff 	movw   $0x0,-0x194(%rbp)
  800421b15b:	00 00 
  800421b15d:	0f b7 95 6c fe ff ff 	movzwl -0x194(%rbp),%edx
  800421b164:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421b167:	48 89 d6             	mov    %rdx,%rsi
  800421b16a:	89 c7                	mov    %eax,%edi
  800421b16c:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b173:	00 00 00 
  800421b176:	ff d0                	callq  *%rax
  800421b178:	c7 45 e0 0c 08 00 00 	movl   $0x80c,-0x20(%rbp)
  800421b17f:	66 c7 85 6e fe ff ff 	movw   $0x0,-0x192(%rbp)
  800421b186:	00 00 
  800421b188:	0f b7 95 6e fe ff ff 	movzwl -0x192(%rbp),%edx
  800421b18f:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421b192:	48 89 d6             	mov    %rdx,%rsi
  800421b195:	89 c7                	mov    %eax,%edi
  800421b197:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b19e:	00 00 00 
  800421b1a1:	ff d0                	callq  *%rax
  800421b1a3:	c7 45 dc 08 68 00 00 	movl   $0x6808,-0x24(%rbp)
  800421b1aa:	48 c7 85 70 fe ff ff 	movq   $0x0,-0x190(%rbp)
  800421b1b1:	00 00 00 00 
static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421b1b5:	48 8b 95 70 fe ff ff 	mov    -0x190(%rbp),%rdx
  800421b1bc:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421b1bf:	48 89 d6             	mov    %rdx,%rsi
  800421b1c2:	89 c7                	mov    %eax,%edi
  800421b1c4:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b1cb:	00 00 00 
  800421b1ce:	ff d0                	callq  *%rax
  800421b1d0:	c7 45 d8 06 68 00 00 	movl   $0x6806,-0x28(%rbp)
  800421b1d7:	48 c7 85 78 fe ff ff 	movq   $0x0,-0x188(%rbp)
  800421b1de:	00 00 00 00 
  800421b1e2:	48 8b 95 78 fe ff ff 	mov    -0x188(%rbp),%rdx
  800421b1e9:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421b1ec:	48 89 d6             	mov    %rdx,%rsi
  800421b1ef:	89 c7                	mov    %eax,%edi
  800421b1f1:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b1f8:	00 00 00 
  800421b1fb:	ff d0                	callq  *%rax
  800421b1fd:	c7 45 d4 0a 68 00 00 	movl   $0x680a,-0x2c(%rbp)
  800421b204:	48 c7 85 80 fe ff ff 	movq   $0x0,-0x180(%rbp)
  800421b20b:	00 00 00 00 
  800421b20f:	48 8b 95 80 fe ff ff 	mov    -0x180(%rbp),%rdx
  800421b216:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421b219:	48 89 d6             	mov    %rdx,%rsi
  800421b21c:	89 c7                	mov    %eax,%edi
  800421b21e:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b225:	00 00 00 
  800421b228:	ff d0                	callq  *%rax
  800421b22a:	c7 45 d0 0c 68 00 00 	movl   $0x680c,-0x30(%rbp)
  800421b231:	48 c7 85 88 fe ff ff 	movq   $0x0,-0x178(%rbp)
  800421b238:	00 00 00 00 
  800421b23c:	48 8b 95 88 fe ff ff 	mov    -0x178(%rbp),%rdx
  800421b243:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800421b246:	48 89 d6             	mov    %rdx,%rsi
  800421b249:	89 c7                	mov    %eax,%edi
  800421b24b:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b252:	00 00 00 
  800421b255:	ff d0                	callq  *%rax
  800421b257:	c7 45 cc 0e 68 00 00 	movl   $0x680e,-0x34(%rbp)
  800421b25e:	48 c7 85 90 fe ff ff 	movq   $0x0,-0x170(%rbp)
  800421b265:	00 00 00 00 
  800421b269:	48 8b 95 90 fe ff ff 	mov    -0x170(%rbp),%rdx
  800421b270:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421b273:	48 89 d6             	mov    %rdx,%rsi
  800421b276:	89 c7                	mov    %eax,%edi
  800421b278:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b27f:	00 00 00 
  800421b282:	ff d0                	callq  *%rax
  800421b284:	c7 45 c8 10 68 00 00 	movl   $0x6810,-0x38(%rbp)
  800421b28b:	48 c7 85 98 fe ff ff 	movq   $0x0,-0x168(%rbp)
  800421b292:	00 00 00 00 
  800421b296:	48 8b 95 98 fe ff ff 	mov    -0x168(%rbp),%rdx
  800421b29d:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421b2a0:	48 89 d6             	mov    %rdx,%rsi
  800421b2a3:	89 c7                	mov    %eax,%edi
  800421b2a5:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b2ac:	00 00 00 
  800421b2af:	ff d0                	callq  *%rax
  800421b2b1:	c7 45 c4 12 68 00 00 	movl   $0x6812,-0x3c(%rbp)
  800421b2b8:	48 c7 85 a0 fe ff ff 	movq   $0x0,-0x160(%rbp)
  800421b2bf:	00 00 00 00 
  800421b2c3:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  800421b2ca:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421b2cd:	48 89 d6             	mov    %rdx,%rsi
  800421b2d0:	89 c7                	mov    %eax,%edi
  800421b2d2:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b2d9:	00 00 00 
  800421b2dc:	ff d0                	callq  *%rax
  800421b2de:	c7 45 c0 16 68 00 00 	movl   $0x6816,-0x40(%rbp)
  800421b2e5:	48 c7 85 a8 fe ff ff 	movq   $0x0,-0x158(%rbp)
  800421b2ec:	00 00 00 00 
  800421b2f0:	48 8b 95 a8 fe ff ff 	mov    -0x158(%rbp),%rdx
  800421b2f7:	8b 45 c0             	mov    -0x40(%rbp),%eax
  800421b2fa:	48 89 d6             	mov    %rdx,%rsi
  800421b2fd:	89 c7                	mov    %eax,%edi
  800421b2ff:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b306:	00 00 00 
  800421b309:	ff d0                	callq  *%rax
  800421b30b:	c7 45 bc 18 68 00 00 	movl   $0x6818,-0x44(%rbp)
  800421b312:	48 c7 85 b0 fe ff ff 	movq   $0x0,-0x150(%rbp)
  800421b319:	00 00 00 00 
  800421b31d:	48 8b 95 b0 fe ff ff 	mov    -0x150(%rbp),%rdx
  800421b324:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800421b327:	48 89 d6             	mov    %rdx,%rsi
  800421b32a:	89 c7                	mov    %eax,%edi
  800421b32c:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b333:	00 00 00 
  800421b336:	ff d0                	callq  *%rax
  800421b338:	c7 45 b8 14 68 00 00 	movl   $0x6814,-0x48(%rbp)
  800421b33f:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  800421b346:	00 00 00 00 
  800421b34a:	48 8b 95 b8 fe ff ff 	mov    -0x148(%rbp),%rdx
  800421b351:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800421b354:	48 89 d6             	mov    %rdx,%rsi
  800421b357:	89 c7                	mov    %eax,%edi
  800421b359:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b360:	00 00 00 
  800421b363:	ff d0                	callq  *%rax
  800421b365:	c7 45 b4 02 48 00 00 	movl   $0x4802,-0x4c(%rbp)
  800421b36c:	c7 85 c0 fe ff ff ff 	movl   $0xffff,-0x140(%rbp)
  800421b373:	ff 00 00 
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421b376:	8b 95 c0 fe ff ff    	mov    -0x140(%rbp),%edx
  800421b37c:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800421b37f:	48 89 d6             	mov    %rdx,%rsi
  800421b382:	89 c7                	mov    %eax,%edi
  800421b384:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b38b:	00 00 00 
  800421b38e:	ff d0                	callq  *%rax
  800421b390:	c7 45 b0 00 48 00 00 	movl   $0x4800,-0x50(%rbp)
  800421b397:	c7 85 c4 fe ff ff ff 	movl   $0xffff,-0x13c(%rbp)
  800421b39e:	ff 00 00 
  800421b3a1:	8b 95 c4 fe ff ff    	mov    -0x13c(%rbp),%edx
  800421b3a7:	8b 45 b0             	mov    -0x50(%rbp),%eax
  800421b3aa:	48 89 d6             	mov    %rdx,%rsi
  800421b3ad:	89 c7                	mov    %eax,%edi
  800421b3af:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b3b6:	00 00 00 
  800421b3b9:	ff d0                	callq  *%rax
  800421b3bb:	c7 45 ac 04 48 00 00 	movl   $0x4804,-0x54(%rbp)
  800421b3c2:	c7 85 c8 fe ff ff ff 	movl   $0xffff,-0x138(%rbp)
  800421b3c9:	ff 00 00 
  800421b3cc:	8b 95 c8 fe ff ff    	mov    -0x138(%rbp),%edx
  800421b3d2:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800421b3d5:	48 89 d6             	mov    %rdx,%rsi
  800421b3d8:	89 c7                	mov    %eax,%edi
  800421b3da:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b3e1:	00 00 00 
  800421b3e4:	ff d0                	callq  *%rax
  800421b3e6:	c7 45 a8 06 48 00 00 	movl   $0x4806,-0x58(%rbp)
  800421b3ed:	c7 85 cc fe ff ff ff 	movl   $0xffff,-0x134(%rbp)
  800421b3f4:	ff 00 00 
  800421b3f7:	8b 95 cc fe ff ff    	mov    -0x134(%rbp),%edx
  800421b3fd:	8b 45 a8             	mov    -0x58(%rbp),%eax
  800421b400:	48 89 d6             	mov    %rdx,%rsi
  800421b403:	89 c7                	mov    %eax,%edi
  800421b405:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b40c:	00 00 00 
  800421b40f:	ff d0                	callq  *%rax
  800421b411:	c7 45 a4 08 48 00 00 	movl   $0x4808,-0x5c(%rbp)
  800421b418:	c7 85 d0 fe ff ff ff 	movl   $0xffff,-0x130(%rbp)
  800421b41f:	ff 00 00 
  800421b422:	8b 95 d0 fe ff ff    	mov    -0x130(%rbp),%edx
  800421b428:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800421b42b:	48 89 d6             	mov    %rdx,%rsi
  800421b42e:	89 c7                	mov    %eax,%edi
  800421b430:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b437:	00 00 00 
  800421b43a:	ff d0                	callq  *%rax
  800421b43c:	c7 45 a0 0a 48 00 00 	movl   $0x480a,-0x60(%rbp)
  800421b443:	c7 85 d4 fe ff ff ff 	movl   $0xffff,-0x12c(%rbp)
  800421b44a:	ff 00 00 
  800421b44d:	8b 95 d4 fe ff ff    	mov    -0x12c(%rbp),%edx
  800421b453:	8b 45 a0             	mov    -0x60(%rbp),%eax
  800421b456:	48 89 d6             	mov    %rdx,%rsi
  800421b459:	89 c7                	mov    %eax,%edi
  800421b45b:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b462:	00 00 00 
  800421b465:	ff d0                	callq  *%rax
  800421b467:	c7 45 9c 0c 48 00 00 	movl   $0x480c,-0x64(%rbp)
  800421b46e:	c7 85 d8 fe ff ff ff 	movl   $0xffff,-0x128(%rbp)
  800421b475:	ff 00 00 
  800421b478:	8b 95 d8 fe ff ff    	mov    -0x128(%rbp),%edx
  800421b47e:	8b 45 9c             	mov    -0x64(%rbp),%eax
  800421b481:	48 89 d6             	mov    %rdx,%rsi
  800421b484:	89 c7                	mov    %eax,%edi
  800421b486:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b48d:	00 00 00 
  800421b490:	ff d0                	callq  *%rax
  800421b492:	c7 45 98 0e 48 00 00 	movl   $0x480e,-0x68(%rbp)
  800421b499:	c7 85 dc fe ff ff ff 	movl   $0xfffff,-0x124(%rbp)
  800421b4a0:	ff 0f 00 
  800421b4a3:	8b 95 dc fe ff ff    	mov    -0x124(%rbp),%edx
  800421b4a9:	8b 45 98             	mov    -0x68(%rbp),%eax
  800421b4ac:	48 89 d6             	mov    %rdx,%rsi
  800421b4af:	89 c7                	mov    %eax,%edi
  800421b4b1:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b4b8:	00 00 00 
  800421b4bb:	ff d0                	callq  *%rax
  800421b4bd:	c7 45 94 10 48 00 00 	movl   $0x4810,-0x6c(%rbp)
  800421b4c4:	c7 85 e0 fe ff ff 30 	movl   $0x30,-0x120(%rbp)
  800421b4cb:	00 00 00 
  800421b4ce:	8b 95 e0 fe ff ff    	mov    -0x120(%rbp),%edx
  800421b4d4:	8b 45 94             	mov    -0x6c(%rbp),%eax
  800421b4d7:	48 89 d6             	mov    %rdx,%rsi
  800421b4da:	89 c7                	mov    %eax,%edi
  800421b4dc:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b4e3:	00 00 00 
  800421b4e6:	ff d0                	callq  *%rax
  800421b4e8:	c7 45 90 12 48 00 00 	movl   $0x4812,-0x70(%rbp)
  800421b4ef:	c7 85 e4 fe ff ff ff 	movl   $0x3ff,-0x11c(%rbp)
  800421b4f6:	03 00 00 
  800421b4f9:	8b 95 e4 fe ff ff    	mov    -0x11c(%rbp),%edx
  800421b4ff:	8b 45 90             	mov    -0x70(%rbp),%eax
  800421b502:	48 89 d6             	mov    %rdx,%rsi
  800421b505:	89 c7                	mov    %eax,%edi
  800421b507:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b50e:	00 00 00 
  800421b511:	ff d0                	callq  *%rax
  800421b513:	c7 45 8c 16 48 00 00 	movl   $0x4816,-0x74(%rbp)
  800421b51a:	c7 85 e8 fe ff ff 93 	movl   $0x93,-0x118(%rbp)
  800421b521:	00 00 00 
  800421b524:	8b 95 e8 fe ff ff    	mov    -0x118(%rbp),%edx
  800421b52a:	8b 45 8c             	mov    -0x74(%rbp),%eax
  800421b52d:	48 89 d6             	mov    %rdx,%rsi
  800421b530:	89 c7                	mov    %eax,%edi
  800421b532:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b539:	00 00 00 
  800421b53c:	ff d0                	callq  *%rax
  800421b53e:	c7 45 88 14 48 00 00 	movl   $0x4814,-0x78(%rbp)
  800421b545:	c7 85 ec fe ff ff 93 	movl   $0x93,-0x114(%rbp)
  800421b54c:	00 00 00 
  800421b54f:	8b 95 ec fe ff ff    	mov    -0x114(%rbp),%edx
  800421b555:	8b 45 88             	mov    -0x78(%rbp),%eax
  800421b558:	48 89 d6             	mov    %rdx,%rsi
  800421b55b:	89 c7                	mov    %eax,%edi
  800421b55d:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b564:	00 00 00 
  800421b567:	ff d0                	callq  *%rax
  800421b569:	c7 45 84 18 48 00 00 	movl   $0x4818,-0x7c(%rbp)
  800421b570:	c7 85 f0 fe ff ff 93 	movl   $0x93,-0x110(%rbp)
  800421b577:	00 00 00 
  800421b57a:	8b 95 f0 fe ff ff    	mov    -0x110(%rbp),%edx
  800421b580:	8b 45 84             	mov    -0x7c(%rbp),%eax
  800421b583:	48 89 d6             	mov    %rdx,%rsi
  800421b586:	89 c7                	mov    %eax,%edi
  800421b588:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b58f:	00 00 00 
  800421b592:	ff d0                	callq  *%rax
  800421b594:	c7 45 80 1a 48 00 00 	movl   $0x481a,-0x80(%rbp)
  800421b59b:	c7 85 f4 fe ff ff 93 	movl   $0x93,-0x10c(%rbp)
  800421b5a2:	00 00 00 
  800421b5a5:	8b 95 f4 fe ff ff    	mov    -0x10c(%rbp),%edx
  800421b5ab:	8b 45 80             	mov    -0x80(%rbp),%eax
  800421b5ae:	48 89 d6             	mov    %rdx,%rsi
  800421b5b1:	89 c7                	mov    %eax,%edi
  800421b5b3:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b5ba:	00 00 00 
  800421b5bd:	ff d0                	callq  *%rax
  800421b5bf:	c7 85 7c ff ff ff 1c 	movl   $0x481c,-0x84(%rbp)
  800421b5c6:	48 00 00 
  800421b5c9:	c7 85 f8 fe ff ff 93 	movl   $0x93,-0x108(%rbp)
  800421b5d0:	00 00 00 
  800421b5d3:	8b 95 f8 fe ff ff    	mov    -0x108(%rbp),%edx
  800421b5d9:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
  800421b5df:	48 89 d6             	mov    %rdx,%rsi
  800421b5e2:	89 c7                	mov    %eax,%edi
  800421b5e4:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b5eb:	00 00 00 
  800421b5ee:	ff d0                	callq  *%rax
  800421b5f0:	c7 85 78 ff ff ff 1e 	movl   $0x481e,-0x88(%rbp)
  800421b5f7:	48 00 00 
  800421b5fa:	c7 85 fc fe ff ff 93 	movl   $0x93,-0x104(%rbp)
  800421b601:	00 00 00 
  800421b604:	8b 95 fc fe ff ff    	mov    -0x104(%rbp),%edx
  800421b60a:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
  800421b610:	48 89 d6             	mov    %rdx,%rsi
  800421b613:	89 c7                	mov    %eax,%edi
  800421b615:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b61c:	00 00 00 
  800421b61f:	ff d0                	callq  *%rax
  800421b621:	c7 85 74 ff ff ff 20 	movl   $0x4820,-0x8c(%rbp)
  800421b628:	48 00 00 
  800421b62b:	c7 85 00 ff ff ff 82 	movl   $0x82,-0x100(%rbp)
  800421b632:	00 00 00 
  800421b635:	8b 95 00 ff ff ff    	mov    -0x100(%rbp),%edx
  800421b63b:	8b 85 74 ff ff ff    	mov    -0x8c(%rbp),%eax
  800421b641:	48 89 d6             	mov    %rdx,%rsi
  800421b644:	89 c7                	mov    %eax,%edi
  800421b646:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b64d:	00 00 00 
  800421b650:	ff d0                	callq  *%rax
  800421b652:	c7 85 70 ff ff ff 22 	movl   $0x4822,-0x90(%rbp)
  800421b659:	48 00 00 
  800421b65c:	c7 85 04 ff ff ff 8b 	movl   $0x8b,-0xfc(%rbp)
  800421b663:	00 00 00 
  800421b666:	8b 95 04 ff ff ff    	mov    -0xfc(%rbp),%edx
  800421b66c:	8b 85 70 ff ff ff    	mov    -0x90(%rbp),%eax
  800421b672:	48 89 d6             	mov    %rdx,%rsi
  800421b675:	89 c7                	mov    %eax,%edi
  800421b677:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b67e:	00 00 00 
  800421b681:	ff d0                	callq  *%rax
  800421b683:	c7 85 6c ff ff ff 26 	movl   $0x4826,-0x94(%rbp)
  800421b68a:	48 00 00 
  800421b68d:	c7 85 08 ff ff ff 00 	movl   $0x0,-0xf8(%rbp)
  800421b694:	00 00 00 
  800421b697:	8b 95 08 ff ff ff    	mov    -0xf8(%rbp),%edx
  800421b69d:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
  800421b6a3:	48 89 d6             	mov    %rdx,%rsi
  800421b6a6:	89 c7                	mov    %eax,%edi
  800421b6a8:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b6af:	00 00 00 
  800421b6b2:	ff d0                	callq  *%rax
  800421b6b4:	c7 85 68 ff ff ff 24 	movl   $0x4824,-0x98(%rbp)
  800421b6bb:	48 00 00 
  800421b6be:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%rbp)
  800421b6c5:	00 00 00 
  800421b6c8:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  800421b6ce:	8b 85 68 ff ff ff    	mov    -0x98(%rbp),%eax
  800421b6d4:	48 89 d6             	mov    %rdx,%rsi
  800421b6d7:	89 c7                	mov    %eax,%edi
  800421b6d9:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b6e0:	00 00 00 
  800421b6e3:	ff d0                	callq  *%rax
  800421b6e5:	c7 85 64 ff ff ff 02 	movl   $0x6802,-0x9c(%rbp)
  800421b6ec:	68 00 00 
  800421b6ef:	48 c7 85 10 ff ff ff 	movq   $0x0,-0xf0(%rbp)
  800421b6f6:	00 00 00 00 
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421b6fa:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  800421b701:	8b 85 64 ff ff ff    	mov    -0x9c(%rbp),%eax
  800421b707:	48 89 d6             	mov    %rdx,%rsi
  800421b70a:	89 c7                	mov    %eax,%edi
  800421b70c:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b713:	00 00 00 
  800421b716:	ff d0                	callq  *%rax
  800421b718:	c7 85 60 ff ff ff 00 	movl   $0x6800,-0xa0(%rbp)
  800421b71f:	68 00 00 
  800421b722:	48 c7 85 18 ff ff ff 	movq   $0x20,-0xe8(%rbp)
  800421b729:	20 00 00 00 
  800421b72d:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800421b734:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
  800421b73a:	48 89 d6             	mov    %rdx,%rsi
  800421b73d:	89 c7                	mov    %eax,%edi
  800421b73f:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b746:	00 00 00 
  800421b749:	ff d0                	callq  *%rax
  800421b74b:	c7 85 5c ff ff ff 04 	movl   $0x6804,-0xa4(%rbp)
  800421b752:	68 00 00 
  800421b755:	48 c7 85 20 ff ff ff 	movq   $0x2000,-0xe0(%rbp)
  800421b75c:	00 20 00 00 
  800421b760:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
  800421b767:	8b 85 5c ff ff ff    	mov    -0xa4(%rbp),%eax
  800421b76d:	48 89 d6             	mov    %rdx,%rsi
  800421b770:	89 c7                	mov    %eax,%edi
  800421b772:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b779:	00 00 00 
  800421b77c:	ff d0                	callq  *%rax
  800421b77e:	c7 85 58 ff ff ff 00 	movl   $0x2800,-0xa8(%rbp)
  800421b785:	28 00 00 
  800421b788:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421b78d:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  800421b794:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  800421b79b:	8b 85 58 ff ff ff    	mov    -0xa8(%rbp),%eax
  800421b7a1:	48 89 d6             	mov    %rdx,%rsi
  800421b7a4:	89 c7                	mov    %eax,%edi
  800421b7a6:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b7ad:	00 00 00 
  800421b7b0:	ff d0                	callq  *%rax
  800421b7b2:	c7 85 54 ff ff ff 01 	movl   $0x2801,-0xac(%rbp)
  800421b7b9:	28 00 00 
  800421b7bc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421b7c1:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  800421b7c8:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
  800421b7cf:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
  800421b7d5:	48 89 d6             	mov    %rdx,%rsi
  800421b7d8:	89 c7                	mov    %eax,%edi
  800421b7da:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b7e1:	00 00 00 
  800421b7e4:	ff d0                	callq  *%rax
  800421b7e6:	c7 85 50 ff ff ff 1a 	movl   $0x681a,-0xb0(%rbp)
  800421b7ed:	68 00 00 
  800421b7f0:	48 c7 85 38 ff ff ff 	movq   $0x0,-0xc8(%rbp)
  800421b7f7:	00 00 00 00 
  800421b7fb:	48 8b 95 38 ff ff ff 	mov    -0xc8(%rbp),%rdx
  800421b802:	8b 85 50 ff ff ff    	mov    -0xb0(%rbp),%eax
  800421b808:	48 89 d6             	mov    %rdx,%rsi
  800421b80b:	89 c7                	mov    %eax,%edi
  800421b80d:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b814:	00 00 00 
  800421b817:	ff d0                	callq  *%rax
  800421b819:	c7 85 4c ff ff ff 20 	movl   $0x6820,-0xb4(%rbp)
  800421b820:	68 00 00 
  800421b823:	48 c7 85 40 ff ff ff 	movq   $0x2,-0xc0(%rbp)
  800421b82a:	02 00 00 00 
  800421b82e:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
  800421b835:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
  800421b83b:	48 89 d6             	mov    %rdx,%rsi
  800421b83e:	89 c7                	mov    %eax,%edi
  800421b840:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b847:	00 00 00 
  800421b84a:	ff d0                	callq  *%rax
	vmcs_write64( VMCS_64BIT_GUEST_LINK_POINTER, 0xffffffff );
	vmcs_write64( VMCS_64BIT_GUEST_LINK_POINTER_HI, 0xffffffff ); 
	vmcs_write64( VMCS_GUEST_DR7, 0x0 );
	vmcs_write64( VMCS_GUEST_RFLAGS, 0x2 );

}
  800421b84c:	90                   	nop
  800421b84d:	c9                   	leaveq 
  800421b84e:	c3                   	retq   

000000800421b84f <vmx_read_capability_msr>:

void vmx_read_capability_msr( uint32_t msr, uint32_t* hi, uint32_t* lo ) {
  800421b84f:	55                   	push   %rbp
  800421b850:	48 89 e5             	mov    %rsp,%rbp
  800421b853:	48 83 ec 38          	sub    $0x38,%rsp
  800421b857:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800421b85a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421b85e:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800421b862:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421b865:	89 45 f4             	mov    %eax,-0xc(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421b868:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421b86b:	89 c1                	mov    %eax,%ecx
  800421b86d:	0f 32                	rdmsr  
  800421b86f:	89 55 f0             	mov    %edx,-0x10(%rbp)
  800421b872:	89 45 ec             	mov    %eax,-0x14(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421b875:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800421b87c:	00 
	ret = edx;
  800421b87d:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800421b880:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	ret = ret << 32;
  800421b884:	48 c1 65 e0 20       	shlq   $0x20,-0x20(%rbp)
	ret |= eax;
  800421b889:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421b88c:	48 09 45 e0          	or     %rax,-0x20(%rbp)

	return ret;
  800421b890:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
	uint64_t msr_val = read_msr( msr );
  800421b894:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	*hi = (uint32_t)( msr_val >> 32 );
  800421b898:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421b89c:	48 c1 e8 20          	shr    $0x20,%rax
  800421b8a0:	89 c2                	mov    %eax,%edx
  800421b8a2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421b8a6:	89 10                	mov    %edx,(%rax)
	*lo = (uint32_t)( msr_val );
  800421b8a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421b8ac:	89 c2                	mov    %eax,%edx
  800421b8ae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421b8b2:	89 10                	mov    %edx,(%rax)
}
  800421b8b4:	90                   	nop
  800421b8b5:	c9                   	leaveq 
  800421b8b6:	c3                   	retq   

000000800421b8b7 <vmcs_ctls_init>:

static void 
vmcs_ctls_init( struct Env* e ) {
  800421b8b7:	55                   	push   %rbp
  800421b8b8:	48 89 e5             	mov    %rsp,%rbp
  800421b8bb:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800421b8c2:	48 89 bd f8 fe ff ff 	mov    %rdi,-0x108(%rbp)
	// Set pin based vm exec controls.
	uint32_t pinbased_ctls_or, pinbased_ctls_and;
	vmx_read_capability_msr( IA32_VMX_PINBASED_CTLS, 
  800421b8c9:	48 8d 95 2c ff ff ff 	lea    -0xd4(%rbp),%rdx
  800421b8d0:	48 8d 85 28 ff ff ff 	lea    -0xd8(%rbp),%rax
  800421b8d7:	48 89 c6             	mov    %rax,%rsi
  800421b8da:	bf 81 04 00 00       	mov    $0x481,%edi
  800421b8df:	48 b8 4f b8 21 04 80 	movabs $0x800421b84f,%rax
  800421b8e6:	00 00 00 
  800421b8e9:	ff d0                	callq  *%rax
				 &pinbased_ctls_and, &pinbased_ctls_or );

	//enable the guest external interrupt exit    
	pinbased_ctls_or |= VMCS_PIN_BASED_VMEXEC_CTL_EXINTEXIT;
  800421b8eb:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
  800421b8f1:	83 c8 01             	or     $0x1,%eax
  800421b8f4:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
	vmcs_write32( VMCS_32BIT_CONTROL_PIN_BASED_EXEC_CONTROLS, 
  800421b8fa:	8b 95 2c ff ff ff    	mov    -0xd4(%rbp),%edx
  800421b900:	8b 85 28 ff ff ff    	mov    -0xd8(%rbp),%eax
  800421b906:	21 d0                	and    %edx,%eax
  800421b908:	c7 45 8c 00 40 00 00 	movl   $0x4000,-0x74(%rbp)
  800421b90f:	89 45 88             	mov    %eax,-0x78(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421b912:	8b 55 88             	mov    -0x78(%rbp),%edx
  800421b915:	8b 45 8c             	mov    -0x74(%rbp),%eax
  800421b918:	48 89 d6             	mov    %rdx,%rsi
  800421b91b:	89 c7                	mov    %eax,%edi
  800421b91d:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b924:	00 00 00 
  800421b927:	ff d0                	callq  *%rax
		      pinbased_ctls_or & pinbased_ctls_and );

	// Set proc-based controls.
	uint32_t procbased_ctls_or, procbased_ctls_and;
	vmx_read_capability_msr( IA32_VMX_PROCBASED_CTLS, 
  800421b929:	48 8d 95 24 ff ff ff 	lea    -0xdc(%rbp),%rdx
  800421b930:	48 8d 85 20 ff ff ff 	lea    -0xe0(%rbp),%rax
  800421b937:	48 89 c6             	mov    %rax,%rsi
  800421b93a:	bf 82 04 00 00       	mov    $0x482,%edi
  800421b93f:	48 b8 4f b8 21 04 80 	movabs $0x800421b84f,%rax
  800421b946:	00 00 00 
  800421b949:	ff d0                	callq  *%rax
				 &procbased_ctls_and, &procbased_ctls_or );
	// Make sure there are secondary controls.
	assert( BIT( procbased_ctls_and, 31 ) == 0x1 ); 
  800421b94b:	8b 85 20 ff ff ff    	mov    -0xe0(%rbp),%eax
  800421b951:	c1 e8 1f             	shr    $0x1f,%eax
  800421b954:	83 f8 01             	cmp    $0x1,%eax
  800421b957:	74 35                	je     800421b98e <vmcs_ctls_init+0xd7>
  800421b959:	48 b9 90 22 22 04 80 	movabs $0x8004222290,%rcx
  800421b960:	00 00 00 
  800421b963:	48 ba 28 22 22 04 80 	movabs $0x8004222228,%rdx
  800421b96a:	00 00 00 
  800421b96d:	be 4f 01 00 00       	mov    $0x14f,%esi
  800421b972:	48 bf 3d 22 22 04 80 	movabs $0x800422223d,%rdi
  800421b979:	00 00 00 
  800421b97c:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b981:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421b988:	00 00 00 
  800421b98b:	41 ff d0             	callq  *%r8
   
	procbased_ctls_or |= VMCS_PROC_BASED_VMEXEC_CTL_ACTIVESECCTL; 
  800421b98e:	8b 85 24 ff ff ff    	mov    -0xdc(%rbp),%eax
  800421b994:	0d 00 00 00 80       	or     $0x80000000,%eax
  800421b999:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
	procbased_ctls_or |= VMCS_PROC_BASED_VMEXEC_CTL_HLTEXIT;
  800421b99f:	8b 85 24 ff ff ff    	mov    -0xdc(%rbp),%eax
  800421b9a5:	0c 80                	or     $0x80,%al
  800421b9a7:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
	procbased_ctls_or |= VMCS_PROC_BASED_VMEXEC_CTL_USEIOBMP;
  800421b9ad:	8b 85 24 ff ff ff    	mov    -0xdc(%rbp),%eax
  800421b9b3:	0d 00 00 00 02       	or     $0x2000000,%eax
  800421b9b8:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
	/* CR3 accesses and invlpg don't need to cause VM Exits when EPT
	   enabled */
	procbased_ctls_or &= ~( VMCS_PROC_BASED_VMEXEC_CTL_CR3LOADEXIT |
  800421b9be:	8b 85 24 ff ff ff    	mov    -0xdc(%rbp),%eax
  800421b9c4:	25 ff 7d fe ff       	and    $0xfffe7dff,%eax
  800421b9c9:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
				VMCS_PROC_BASED_VMEXEC_CTL_CR3STOREXIT | 
				VMCS_PROC_BASED_VMEXEC_CTL_INVLPGEXIT );

	vmcs_write32( VMCS_32BIT_CONTROL_PROCESSOR_BASED_VMEXEC_CONTROLS, 
  800421b9cf:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  800421b9d5:	8b 85 20 ff ff ff    	mov    -0xe0(%rbp),%eax
  800421b9db:	21 d0                	and    %edx,%eax
  800421b9dd:	c7 45 f4 02 40 00 00 	movl   $0x4002,-0xc(%rbp)
  800421b9e4:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
  800421b9ea:	8b 95 7c ff ff ff    	mov    -0x84(%rbp),%edx
  800421b9f0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421b9f3:	48 89 d6             	mov    %rdx,%rsi
  800421b9f6:	89 c7                	mov    %eax,%edi
  800421b9f8:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421b9ff:	00 00 00 
  800421ba02:	ff d0                	callq  *%rax
		      procbased_ctls_or & procbased_ctls_and );

	// Set Proc based secondary controls.
	uint32_t procbased_ctls2_or, procbased_ctls2_and;
	vmx_read_capability_msr( IA32_VMX_PROCBASED_CTLS2, 
  800421ba04:	48 8d 95 1c ff ff ff 	lea    -0xe4(%rbp),%rdx
  800421ba0b:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800421ba12:	48 89 c6             	mov    %rax,%rsi
  800421ba15:	bf 8b 04 00 00       	mov    $0x48b,%edi
  800421ba1a:	48 b8 4f b8 21 04 80 	movabs $0x800421b84f,%rax
  800421ba21:	00 00 00 
  800421ba24:	ff d0                	callq  *%rax
				 &procbased_ctls2_and, &procbased_ctls2_or );
    
	// Enable EPT.
	procbased_ctls2_or |= VMCS_SECONDARY_VMEXEC_CTL_ENABLE_EPT;
  800421ba26:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
  800421ba2c:	83 c8 02             	or     $0x2,%eax
  800421ba2f:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
	procbased_ctls2_or |= VMCS_SECONDARY_VMEXEC_CTL_UNRESTRICTED_GUEST;
  800421ba35:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
  800421ba3b:	0c 80                	or     $0x80,%al
  800421ba3d:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
	vmcs_write32( VMCS_32BIT_CONTROL_SECONDARY_VMEXEC_CONTROLS, 
  800421ba43:	8b 95 1c ff ff ff    	mov    -0xe4(%rbp),%edx
  800421ba49:	8b 85 18 ff ff ff    	mov    -0xe8(%rbp),%eax
  800421ba4f:	21 d0                	and    %edx,%eax
  800421ba51:	c7 45 f0 1e 40 00 00 	movl   $0x401e,-0x10(%rbp)
  800421ba58:	89 45 80             	mov    %eax,-0x80(%rbp)
  800421ba5b:	8b 55 80             	mov    -0x80(%rbp),%edx
  800421ba5e:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800421ba61:	48 89 d6             	mov    %rdx,%rsi
  800421ba64:	89 c7                	mov    %eax,%edi
  800421ba66:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421ba6d:	00 00 00 
  800421ba70:	ff d0                	callq  *%rax
		      procbased_ctls2_or & procbased_ctls2_and );

	// Set VM exit controls.
	uint32_t exit_ctls_or, exit_ctls_and;
	vmx_read_capability_msr( IA32_VMX_EXIT_CTLS, 
  800421ba72:	48 8d 95 14 ff ff ff 	lea    -0xec(%rbp),%rdx
  800421ba79:	48 8d 85 10 ff ff ff 	lea    -0xf0(%rbp),%rax
  800421ba80:	48 89 c6             	mov    %rax,%rsi
  800421ba83:	bf 83 04 00 00       	mov    $0x483,%edi
  800421ba88:	48 b8 4f b8 21 04 80 	movabs $0x800421b84f,%rax
  800421ba8f:	00 00 00 
  800421ba92:	ff d0                	callq  *%rax
				 &exit_ctls_and, &exit_ctls_or );

	exit_ctls_or |= VMCS_VMEXIT_HOST_ADDR_SIZE;
  800421ba94:	8b 85 14 ff ff ff    	mov    -0xec(%rbp),%eax
  800421ba9a:	80 cc 02             	or     $0x2,%ah
  800421ba9d:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
	exit_ctls_or |= VMCS_VMEXIT_GUEST_ACK_INTR_ON_EXIT;	
  800421baa3:	8b 85 14 ff ff ff    	mov    -0xec(%rbp),%eax
  800421baa9:	80 cc 80             	or     $0x80,%ah
  800421baac:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
	vmcs_write32( VMCS_32BIT_CONTROL_VMEXIT_CONTROLS, 
  800421bab2:	8b 95 14 ff ff ff    	mov    -0xec(%rbp),%edx
  800421bab8:	8b 85 10 ff ff ff    	mov    -0xf0(%rbp),%eax
  800421babe:	21 d0                	and    %edx,%eax
  800421bac0:	c7 45 fc 0c 40 00 00 	movl   $0x400c,-0x4(%rbp)
  800421bac7:	89 45 84             	mov    %eax,-0x7c(%rbp)
  800421baca:	8b 55 84             	mov    -0x7c(%rbp),%edx
  800421bacd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421bad0:	48 89 d6             	mov    %rdx,%rsi
  800421bad3:	89 c7                	mov    %eax,%edi
  800421bad5:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421badc:	00 00 00 
  800421badf:	ff d0                	callq  *%rax
		      exit_ctls_or & exit_ctls_and );

	vmcs_write64( VMCS_64BIT_CONTROL_VMEXIT_MSR_STORE_ADDR,
		      PADDR(e->env_vmxinfo.msr_guest_area));
  800421bae1:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421bae8:	48 8b 80 58 01 00 00 	mov    0x158(%rax),%rax
  800421baef:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800421baf3:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421bafa:	00 00 00 
  800421bafd:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800421bb01:	77 32                	ja     800421bb35 <vmcs_ctls_init+0x27e>
  800421bb03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421bb07:	48 89 c1             	mov    %rax,%rcx
  800421bb0a:	48 ba b8 22 22 04 80 	movabs $0x80042222b8,%rdx
  800421bb11:	00 00 00 
  800421bb14:	be 73 01 00 00       	mov    $0x173,%esi
  800421bb19:	48 bf 3d 22 22 04 80 	movabs $0x800422223d,%rdi
  800421bb20:	00 00 00 
  800421bb23:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bb28:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421bb2f:	00 00 00 
  800421bb32:	41 ff d0             	callq  *%r8
  800421bb35:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421bb3c:	ff ff ff 
  800421bb3f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421bb43:	48 01 d0             	add    %rdx,%rax
  800421bb46:	c7 45 e0 06 20 00 00 	movl   $0x2006,-0x20(%rbp)
  800421bb4d:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421bb54:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800421bb5b:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421bb5e:	48 89 d6             	mov    %rdx,%rsi
  800421bb61:	89 c7                	mov    %eax,%edi
  800421bb63:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421bb6a:	00 00 00 
  800421bb6d:	ff d0                	callq  *%rax
	vmcs_write32( VMCS_32BIT_CONTROL_VMEXIT_MSR_STORE_COUNT,
		      e->env_vmxinfo.msr_count);
  800421bb6f:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421bb76:	8b 80 48 01 00 00    	mov    0x148(%rax),%eax
  800421bb7c:	c7 45 f8 0e 40 00 00 	movl   $0x400e,-0x8(%rbp)
  800421bb83:	89 85 78 ff ff ff    	mov    %eax,-0x88(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421bb89:	8b 95 78 ff ff ff    	mov    -0x88(%rbp),%edx
  800421bb8f:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421bb92:	48 89 d6             	mov    %rdx,%rsi
  800421bb95:	89 c7                	mov    %eax,%edi
  800421bb97:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421bb9e:	00 00 00 
  800421bba1:	ff d0                	callq  *%rax
	vmcs_write64( VMCS_64BIT_CONTROL_VMEXIT_MSR_LOAD_ADDR,
		      PADDR(e->env_vmxinfo.msr_host_area));
  800421bba3:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421bbaa:	48 8b 80 50 01 00 00 	mov    0x150(%rax),%rax
  800421bbb1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800421bbb5:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421bbbc:	00 00 00 
  800421bbbf:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  800421bbc3:	77 32                	ja     800421bbf7 <vmcs_ctls_init+0x340>
  800421bbc5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421bbc9:	48 89 c1             	mov    %rax,%rcx
  800421bbcc:	48 ba b8 22 22 04 80 	movabs $0x80042222b8,%rdx
  800421bbd3:	00 00 00 
  800421bbd6:	be 77 01 00 00       	mov    $0x177,%esi
  800421bbdb:	48 bf 3d 22 22 04 80 	movabs $0x800422223d,%rdi
  800421bbe2:	00 00 00 
  800421bbe5:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bbea:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421bbf1:	00 00 00 
  800421bbf4:	41 ff d0             	callq  *%r8
  800421bbf7:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421bbfe:	ff ff ff 
  800421bc01:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421bc05:	48 01 d0             	add    %rdx,%rax
  800421bc08:	c7 45 d0 08 20 00 00 	movl   $0x2008,-0x30(%rbp)
  800421bc0f:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421bc16:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421bc1d:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800421bc20:	48 89 d6             	mov    %rdx,%rsi
  800421bc23:	89 c7                	mov    %eax,%edi
  800421bc25:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421bc2c:	00 00 00 
  800421bc2f:	ff d0                	callq  *%rax
	vmcs_write32( VMCS_32BIT_CONTROL_VMEXIT_MSR_LOAD_COUNT,
		      e->env_vmxinfo.msr_count);
  800421bc31:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421bc38:	8b 80 48 01 00 00    	mov    0x148(%rax),%eax
  800421bc3e:	c7 45 e4 10 40 00 00 	movl   $0x4010,-0x1c(%rbp)
  800421bc45:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421bc4b:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  800421bc51:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421bc54:	48 89 d6             	mov    %rdx,%rsi
  800421bc57:	89 c7                	mov    %eax,%edi
  800421bc59:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421bc60:	00 00 00 
  800421bc63:	ff d0                	callq  *%rax

	// Set VM entry controls.
	uint32_t entry_ctls_or, entry_ctls_and;
	vmx_read_capability_msr( IA32_VMX_ENTRY_CTLS, 
  800421bc65:	48 8d 95 0c ff ff ff 	lea    -0xf4(%rbp),%rdx
  800421bc6c:	48 8d 85 08 ff ff ff 	lea    -0xf8(%rbp),%rax
  800421bc73:	48 89 c6             	mov    %rax,%rsi
  800421bc76:	bf 84 04 00 00       	mov    $0x484,%edi
  800421bc7b:	48 b8 4f b8 21 04 80 	movabs $0x800421b84f,%rax
  800421bc82:	00 00 00 
  800421bc85:	ff d0                	callq  *%rax
				 &entry_ctls_and, &entry_ctls_or );

	vmcs_write64( VMCS_64BIT_CONTROL_VMENTRY_MSR_LOAD_ADDR,
		      PADDR(e->env_vmxinfo.msr_guest_area));
  800421bc87:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421bc8e:	48 8b 80 58 01 00 00 	mov    0x158(%rax),%rax
  800421bc95:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  800421bc99:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421bca0:	00 00 00 
  800421bca3:	48 39 45 c8          	cmp    %rax,-0x38(%rbp)
  800421bca7:	77 32                	ja     800421bcdb <vmcs_ctls_init+0x424>
  800421bca9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421bcad:	48 89 c1             	mov    %rax,%rcx
  800421bcb0:	48 ba b8 22 22 04 80 	movabs $0x80042222b8,%rdx
  800421bcb7:	00 00 00 
  800421bcba:	be 81 01 00 00       	mov    $0x181,%esi
  800421bcbf:	48 bf 3d 22 22 04 80 	movabs $0x800422223d,%rdi
  800421bcc6:	00 00 00 
  800421bcc9:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bcce:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421bcd5:	00 00 00 
  800421bcd8:	41 ff d0             	callq  *%r8
  800421bcdb:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421bce2:	ff ff ff 
  800421bce5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421bce9:	48 01 d0             	add    %rdx,%rax
  800421bcec:	c7 45 c0 0a 20 00 00 	movl   $0x200a,-0x40(%rbp)
  800421bcf3:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421bcfa:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
  800421bd01:	8b 45 c0             	mov    -0x40(%rbp),%eax
  800421bd04:	48 89 d6             	mov    %rdx,%rsi
  800421bd07:	89 c7                	mov    %eax,%edi
  800421bd09:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421bd10:	00 00 00 
  800421bd13:	ff d0                	callq  *%rax
	vmcs_write32( VMCS_32BIT_CONTROL_VMENTRY_MSR_LOAD_COUNT,
		      e->env_vmxinfo.msr_count);
  800421bd15:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421bd1c:	8b 80 48 01 00 00    	mov    0x148(%rax),%eax
  800421bd22:	c7 45 bc 14 40 00 00 	movl   $0x4014,-0x44(%rbp)
  800421bd29:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421bd2f:	8b 95 48 ff ff ff    	mov    -0xb8(%rbp),%edx
  800421bd35:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800421bd38:	48 89 d6             	mov    %rdx,%rsi
  800421bd3b:	89 c7                	mov    %eax,%edi
  800421bd3d:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421bd44:	00 00 00 
  800421bd47:	ff d0                	callq  *%rax

	vmcs_write32( VMCS_32BIT_CONTROL_VMENTRY_CONTROLS, 
  800421bd49:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  800421bd4f:	8b 85 08 ff ff ff    	mov    -0xf8(%rbp),%eax
  800421bd55:	21 d0                	and    %edx,%eax
  800421bd57:	c7 45 ac 12 40 00 00 	movl   $0x4012,-0x54(%rbp)
  800421bd5e:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
  800421bd64:	8b 95 4c ff ff ff    	mov    -0xb4(%rbp),%edx
  800421bd6a:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800421bd6d:	48 89 d6             	mov    %rdx,%rsi
  800421bd70:	89 c7                	mov    %eax,%edi
  800421bd72:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421bd79:	00 00 00 
  800421bd7c:	ff d0                	callq  *%rax
		      entry_ctls_or & entry_ctls_and );
    
	uint64_t ept_ptr = e->env_cr3 | ( ( EPT_LEVELS - 1 ) << 3 );
  800421bd7e:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421bd85:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  800421bd8c:	48 83 c8 18          	or     $0x18,%rax
  800421bd90:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	vmcs_write64( VMCS_64BIT_CONTROL_EPTPTR, ept_ptr 
  800421bd94:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421bd98:	48 83 c8 1e          	or     $0x1e,%rax
  800421bd9c:	c7 45 a8 1a 20 00 00 	movl   $0x201a,-0x58(%rbp)
  800421bda3:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421bdaa:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  800421bdb1:	8b 45 a8             	mov    -0x58(%rbp),%eax
  800421bdb4:	48 89 d6             	mov    %rdx,%rsi
  800421bdb7:	89 c7                	mov    %eax,%edi
  800421bdb9:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421bdc0:	00 00 00 
  800421bdc3:	ff d0                	callq  *%rax
        	    	| VMX_EPT_DEFAULT_MT
        	    	| (VMX_EPT_DEFAULT_GAW << VMX_EPT_GAW_EPTP_SHIFT) );

	vmcs_write32( VMCS_32BIT_CONTROL_EXCEPTION_BITMAP, 
  800421bdc5:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421bdcc:	8b 80 30 01 00 00    	mov    0x130(%rax),%eax
  800421bdd2:	c7 45 d4 04 40 00 00 	movl   $0x4004,-0x2c(%rbp)
  800421bdd9:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421bddf:	8b 95 5c ff ff ff    	mov    -0xa4(%rbp),%edx
  800421bde5:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421bde8:	48 89 d6             	mov    %rdx,%rsi
  800421bdeb:	89 c7                	mov    %eax,%edi
  800421bded:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421bdf4:	00 00 00 
  800421bdf7:	ff d0                	callq  *%rax
		      e->env_vmxinfo.exception_bmap);
	vmcs_write64( VMCS_64BIT_CONTROL_IO_BITMAP_A,
		      PADDR(e->env_vmxinfo.io_bmap_a));
  800421bdf9:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421be00:	48 8b 80 38 01 00 00 	mov    0x138(%rax),%rax
  800421be07:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  800421be0b:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421be12:	00 00 00 
  800421be15:	48 39 45 a0          	cmp    %rax,-0x60(%rbp)
  800421be19:	77 32                	ja     800421be4d <vmcs_ctls_init+0x596>
  800421be1b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421be1f:	48 89 c1             	mov    %rax,%rcx
  800421be22:	48 ba b8 22 22 04 80 	movabs $0x80042222b8,%rdx
  800421be29:	00 00 00 
  800421be2c:	be 90 01 00 00       	mov    $0x190,%esi
  800421be31:	48 bf 3d 22 22 04 80 	movabs $0x800422223d,%rdi
  800421be38:	00 00 00 
  800421be3b:	b8 00 00 00 00       	mov    $0x0,%eax
  800421be40:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421be47:	00 00 00 
  800421be4a:	41 ff d0             	callq  *%r8
  800421be4d:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421be54:	ff ff ff 
  800421be57:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421be5b:	48 01 d0             	add    %rdx,%rax
  800421be5e:	c7 45 c4 00 20 00 00 	movl   $0x2000,-0x3c(%rbp)
  800421be65:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421be6c:	48 8b 95 38 ff ff ff 	mov    -0xc8(%rbp),%rdx
  800421be73:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421be76:	48 89 d6             	mov    %rdx,%rsi
  800421be79:	89 c7                	mov    %eax,%edi
  800421be7b:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421be82:	00 00 00 
  800421be85:	ff d0                	callq  *%rax
	vmcs_write64( VMCS_64BIT_CONTROL_IO_BITMAP_B,
		      PADDR(e->env_vmxinfo.io_bmap_b));
  800421be87:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421be8e:	48 8b 80 40 01 00 00 	mov    0x140(%rax),%rax
  800421be95:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  800421be99:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421bea0:	00 00 00 
  800421bea3:	48 39 45 90          	cmp    %rax,-0x70(%rbp)
  800421bea7:	77 32                	ja     800421bedb <vmcs_ctls_init+0x624>
  800421bea9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421bead:	48 89 c1             	mov    %rax,%rcx
  800421beb0:	48 ba b8 22 22 04 80 	movabs $0x80042222b8,%rdx
  800421beb7:	00 00 00 
  800421beba:	be 92 01 00 00       	mov    $0x192,%esi
  800421bebf:	48 bf 3d 22 22 04 80 	movabs $0x800422223d,%rdi
  800421bec6:	00 00 00 
  800421bec9:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bece:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421bed5:	00 00 00 
  800421bed8:	41 ff d0             	callq  *%r8
  800421bedb:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421bee2:	ff ff ff 
  800421bee5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421bee9:	48 01 d0             	add    %rdx,%rax
  800421beec:	c7 45 9c 02 20 00 00 	movl   $0x2002,-0x64(%rbp)
  800421bef3:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  800421befa:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
  800421bf01:	8b 45 9c             	mov    -0x64(%rbp),%eax
  800421bf04:	48 89 d6             	mov    %rdx,%rsi
  800421bf07:	89 c7                	mov    %eax,%edi
  800421bf09:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421bf10:	00 00 00 
  800421bf13:	ff d0                	callq  *%rax

}
  800421bf15:	90                   	nop
  800421bf16:	c9                   	leaveq 
  800421bf17:	c3                   	retq   

000000800421bf18 <vmcs_dump_cpu>:

void vmcs_dump_cpu() {
  800421bf18:	55                   	push   %rbp
  800421bf19:	48 89 e5             	mov    %rsp,%rbp
  800421bf1c:	53                   	push   %rbx
  800421bf1d:	48 83 ec 28          	sub    $0x28,%rsp
	uint64_t flags = vmcs_readl(VMCS_GUEST_RFLAGS);
  800421bf21:	bf 20 68 00 00       	mov    $0x6820,%edi
  800421bf26:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421bf2d:	00 00 00 
  800421bf30:	ff d0                	callq  *%rax
  800421bf32:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// TODO: print all the regs.
	cprintf( "vmx: --- Begin VCPU Dump ---\n");
  800421bf36:	48 bf dc 22 22 04 80 	movabs $0x80042222dc,%rdi
  800421bf3d:	00 00 00 
  800421bf40:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bf45:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421bf4c:	00 00 00 
  800421bf4f:	ff d2                	callq  *%rdx
  800421bf51:	c7 45 e4 1c 68 00 00 	movl   $0x681c,-0x1c(%rbp)
	return vmcs_readl(field);
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421bf58:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421bf5b:	89 c7                	mov    %eax,%edi
  800421bf5d:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421bf64:	00 00 00 
  800421bf67:	ff d0                	callq  *%rax
  800421bf69:	48 89 c3             	mov    %rax,%rbx
  800421bf6c:	c7 45 e0 1e 68 00 00 	movl   $0x681e,-0x20(%rbp)
  800421bf73:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421bf76:	89 c7                	mov    %eax,%edi
  800421bf78:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421bf7f:	00 00 00 
  800421bf82:	ff d0                	callq  *%rax
  800421bf84:	48 89 c6             	mov    %rax,%rsi
	cprintf( "vmx: RIP 0x%016llx RSP 0x%016llx RFLAGS 0x%016llx\n",
  800421bf87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421bf8b:	48 89 c1             	mov    %rax,%rcx
  800421bf8e:	48 89 da             	mov    %rbx,%rdx
  800421bf91:	48 bf 00 23 22 04 80 	movabs $0x8004222300,%rdi
  800421bf98:	00 00 00 
  800421bf9b:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bfa0:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421bfa7:	00 00 00 
  800421bfaa:	41 ff d0             	callq  *%r8
  800421bfad:	c7 45 dc 02 68 00 00 	movl   $0x6802,-0x24(%rbp)
  800421bfb4:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421bfb7:	89 c7                	mov    %eax,%edi
  800421bfb9:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421bfc0:	00 00 00 
  800421bfc3:	ff d0                	callq  *%rax
  800421bfc5:	48 89 c3             	mov    %rax,%rbx
  800421bfc8:	c7 45 d8 00 68 00 00 	movl   $0x6800,-0x28(%rbp)
  800421bfcf:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421bfd2:	89 c7                	mov    %eax,%edi
  800421bfd4:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421bfdb:	00 00 00 
  800421bfde:	ff d0                	callq  *%rax
		 vmcs_read64( VMCS_GUEST_RIP ) , vmcs_read64( VMCS_GUEST_RSP ), flags);
	cprintf( "vmx: CR0 0x%016llx CR3 0x%016llx\n",
  800421bfe0:	48 89 da             	mov    %rbx,%rdx
  800421bfe3:	48 89 c6             	mov    %rax,%rsi
  800421bfe6:	48 bf 38 23 22 04 80 	movabs $0x8004222338,%rdi
  800421bfed:	00 00 00 
  800421bff0:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bff5:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421bffc:	00 00 00 
  800421bfff:	ff d1                	callq  *%rcx
  800421c001:	c7 45 d4 04 68 00 00 	movl   $0x6804,-0x2c(%rbp)
  800421c008:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421c00b:	89 c7                	mov    %eax,%edi
  800421c00d:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c014:	00 00 00 
  800421c017:	ff d0                	callq  *%rax
		 vmcs_read64( VMCS_GUEST_CR0 ), vmcs_read64( VMCS_GUEST_CR3 ) );
	cprintf( "vmx: CR4 0x%016llx \n",
  800421c019:	48 89 c6             	mov    %rax,%rsi
  800421c01c:	48 bf 5a 23 22 04 80 	movabs $0x800422235a,%rdi
  800421c023:	00 00 00 
  800421c026:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c02b:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421c032:	00 00 00 
  800421c035:	ff d2                	callq  *%rdx
		 vmcs_read64( VMCS_GUEST_CR4 ) );

	cprintf( "vmx: --- End VCPU Dump ---\n");
  800421c037:	48 bf 6f 23 22 04 80 	movabs $0x800422236f,%rdi
  800421c03e:	00 00 00 
  800421c041:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c046:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421c04d:	00 00 00 
  800421c050:	ff d2                	callq  *%rdx

}
  800421c052:	90                   	nop
  800421c053:	48 83 c4 28          	add    $0x28,%rsp
  800421c057:	5b                   	pop    %rbx
  800421c058:	5d                   	pop    %rbp
  800421c059:	c3                   	retq   

000000800421c05a <vmx_dump_sel>:

static void vmx_dump_sel(char *name, uint32_t sel)
{
  800421c05a:	55                   	push   %rbp
  800421c05b:	48 89 e5             	mov    %rsp,%rbp
  800421c05e:	41 55                	push   %r13
  800421c060:	41 54                	push   %r12
  800421c062:	53                   	push   %rbx
  800421c063:	48 83 ec 28          	sub    $0x28,%rsp
  800421c067:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421c06b:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	cprintf("%s sel=0x%04x, attr=0x%05x, limit=0x%08x, base=0x%016lx\n",
  800421c06e:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421c071:	05 06 60 00 00       	add    $0x6006,%eax
  800421c076:	89 c7                	mov    %eax,%edi
  800421c078:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c07f:	00 00 00 
  800421c082:	ff d0                	callq  *%rax
  800421c084:	49 89 c4             	mov    %rax,%r12
  800421c087:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421c08a:	05 00 40 00 00       	add    $0x4000,%eax
  800421c08f:	89 45 dc             	mov    %eax,-0x24(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421c092:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421c095:	89 c7                	mov    %eax,%edi
  800421c097:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c09e:	00 00 00 
  800421c0a1:	ff d0                	callq  *%rax
  800421c0a3:	41 89 c5             	mov    %eax,%r13d
  800421c0a6:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421c0a9:	05 14 40 00 00       	add    $0x4014,%eax
  800421c0ae:	89 45 d8             	mov    %eax,-0x28(%rbp)
  800421c0b1:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421c0b4:	89 c7                	mov    %eax,%edi
  800421c0b6:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c0bd:	00 00 00 
  800421c0c0:	ff d0                	callq  *%rax
  800421c0c2:	89 c3                	mov    %eax,%ebx
  800421c0c4:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421c0c7:	89 45 d4             	mov    %eax,-0x2c(%rbp)
	return value;
}

static __inline uint16_t vmcs_read16(uint32_t field)
{
	return vmcs_readl(field);
  800421c0ca:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421c0cd:	89 c7                	mov    %eax,%edi
  800421c0cf:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c0d6:	00 00 00 
  800421c0d9:	ff d0                	callq  *%rax
  800421c0db:	0f b7 d0             	movzwl %ax,%edx
  800421c0de:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421c0e2:	4d 89 e1             	mov    %r12,%r9
  800421c0e5:	45 89 e8             	mov    %r13d,%r8d
  800421c0e8:	89 d9                	mov    %ebx,%ecx
  800421c0ea:	48 89 c6             	mov    %rax,%rsi
  800421c0ed:	48 bf 90 23 22 04 80 	movabs $0x8004222390,%rdi
  800421c0f4:	00 00 00 
  800421c0f7:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c0fc:	49 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%r10
  800421c103:	00 00 00 
  800421c106:	41 ff d2             	callq  *%r10
			name, vmcs_read16(sel),
			vmcs_read32(sel + VMCS_32BIT_GUEST_ES_ACCESS_RIGHTS - VMCS_16BIT_GUEST_ES_SELECTOR ),
			vmcs_read32(sel + VMCS_32BIT_GUEST_ES_LIMIT - VMCS_16BIT_GUEST_ES_SELECTOR),
			vmcs_readl(sel + VMCS_GUEST_ES_BASE - VMCS_16BIT_GUEST_ES_SELECTOR));
}
  800421c109:	90                   	nop
  800421c10a:	48 83 c4 28          	add    $0x28,%rsp
  800421c10e:	5b                   	pop    %rbx
  800421c10f:	41 5c                	pop    %r12
  800421c111:	41 5d                	pop    %r13
  800421c113:	5d                   	pop    %rbp
  800421c114:	c3                   	retq   

000000800421c115 <vmx_dump_dtsel>:

static void vmx_dump_dtsel(char *name, uint32_t limit)
{
  800421c115:	55                   	push   %rbp
  800421c116:	48 89 e5             	mov    %rsp,%rbp
  800421c119:	53                   	push   %rbx
  800421c11a:	48 83 ec 28          	sub    $0x28,%rsp
  800421c11e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421c122:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	cprintf("%slimit=0x%08x, base=0x%016lx\n",
  800421c125:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421c128:	05 06 20 00 00       	add    $0x2006,%eax
  800421c12d:	89 c7                	mov    %eax,%edi
  800421c12f:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c136:	00 00 00 
  800421c139:	ff d0                	callq  *%rax
  800421c13b:	48 89 c3             	mov    %rax,%rbx
  800421c13e:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421c141:	89 45 ec             	mov    %eax,-0x14(%rbp)
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421c144:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421c147:	89 c7                	mov    %eax,%edi
  800421c149:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c150:	00 00 00 
  800421c153:	ff d0                	callq  *%rax
  800421c155:	89 c2                	mov    %eax,%edx
  800421c157:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421c15b:	48 89 d9             	mov    %rbx,%rcx
  800421c15e:	48 89 c6             	mov    %rax,%rsi
  800421c161:	48 bf d0 23 22 04 80 	movabs $0x80042223d0,%rdi
  800421c168:	00 00 00 
  800421c16b:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c170:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421c177:	00 00 00 
  800421c17a:	41 ff d0             	callq  *%r8
			name, vmcs_read32(limit),
			vmcs_readl(limit + VMCS_GUEST_GDTR_BASE - VMCS_32BIT_GUEST_GDTR_LIMIT));
}
  800421c17d:	90                   	nop
  800421c17e:	48 83 c4 28          	add    $0x28,%rsp
  800421c182:	5b                   	pop    %rbx
  800421c183:	5d                   	pop    %rbp
  800421c184:	c3                   	retq   

000000800421c185 <vmcs_dump_cpu_1>:

void vmcs_dump_cpu_1()
{
  800421c185:	55                   	push   %rbp
  800421c186:	48 89 e5             	mov    %rsp,%rbp
  800421c189:	41 57                	push   %r15
  800421c18b:	41 56                	push   %r14
  800421c18d:	41 55                	push   %r13
  800421c18f:	41 54                	push   %r12
  800421c191:	53                   	push   %rbx
  800421c192:	48 81 ec 38 01 00 00 	sub    $0x138,%rsp
  800421c199:	c7 45 c4 12 40 00 00 	movl   $0x4012,-0x3c(%rbp)
  800421c1a0:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421c1a3:	89 c7                	mov    %eax,%edi
  800421c1a5:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c1ac:	00 00 00 
  800421c1af:	ff d0                	callq  *%rax
	uint32_t vmentry_ctl = vmcs_read32(VMCS_32BIT_CONTROL_VMENTRY_CONTROLS);
  800421c1b1:	89 45 c8             	mov    %eax,-0x38(%rbp)
  800421c1b4:	c7 45 bc 0c 40 00 00 	movl   $0x400c,-0x44(%rbp)
  800421c1bb:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800421c1be:	89 c7                	mov    %eax,%edi
  800421c1c0:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c1c7:	00 00 00 
  800421c1ca:	ff d0                	callq  *%rax
	uint32_t vmexit_ctl = vmcs_read32(VMCS_32BIT_CONTROL_VMEXIT_CONTROLS);
  800421c1cc:	89 45 c0             	mov    %eax,-0x40(%rbp)
  800421c1cf:	c7 45 b4 02 40 00 00 	movl   $0x4002,-0x4c(%rbp)
  800421c1d6:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800421c1d9:	89 c7                	mov    %eax,%edi
  800421c1db:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c1e2:	00 00 00 
  800421c1e5:	ff d0                	callq  *%rax
	uint32_t cpu_based_exec_ctrl = vmcs_read32(VMCS_32BIT_CONTROL_PROCESSOR_BASED_VMEXEC_CONTROLS);
  800421c1e7:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800421c1ea:	c7 45 9c 00 40 00 00 	movl   $0x4000,-0x64(%rbp)
  800421c1f1:	8b 45 9c             	mov    -0x64(%rbp),%eax
  800421c1f4:	89 c7                	mov    %eax,%edi
  800421c1f6:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c1fd:	00 00 00 
  800421c200:	ff d0                	callq  *%rax
	uint32_t pin_based_exec_ctrl = vmcs_read32(VMCS_32BIT_CONTROL_PIN_BASED_EXEC_CONTROLS);
  800421c202:	89 45 b0             	mov    %eax,-0x50(%rbp)
	uint32_t secondary_exec_control = 0;
  800421c205:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%rbp)
	unsigned long cr4 = vmcs_readl(VMCS_GUEST_CR4);
  800421c20c:	bf 04 68 00 00       	mov    $0x6804,%edi
  800421c211:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c218:	00 00 00 
  800421c21b:	ff d0                	callq  *%rax
  800421c21d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  800421c221:	c7 45 8c 06 28 00 00 	movl   $0x2806,-0x74(%rbp)
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421c228:	8b 45 8c             	mov    -0x74(%rbp),%eax
  800421c22b:	89 c7                	mov    %eax,%edi
  800421c22d:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c234:	00 00 00 
  800421c237:	ff d0                	callq  *%rax
	uint64_t efer = vmcs_read64(VMCS_64BIT_GUEST_IA32_EFER);
  800421c239:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  800421c23d:	c7 45 88 1e 40 00 00 	movl   $0x401e,-0x78(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421c244:	8b 45 88             	mov    -0x78(%rbp),%eax
  800421c247:	89 c7                	mov    %eax,%edi
  800421c249:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c250:	00 00 00 
  800421c253:	ff d0                	callq  *%rax
	int i, n;

	secondary_exec_control = vmcs_read32(VMCS_32BIT_CONTROL_SECONDARY_VMEXEC_CONTROLS);
  800421c255:	89 45 ac             	mov    %eax,-0x54(%rbp)

	cprintf("\n*** Guest State ***\n");
  800421c258:	48 bf ef 23 22 04 80 	movabs $0x80042223ef,%rdi
  800421c25f:	00 00 00 
  800421c262:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c267:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421c26e:	00 00 00 
  800421c271:	ff d2                	callq  *%rdx
	cprintf("CR0: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\n",
  800421c273:	bf 00 60 00 00       	mov    $0x6000,%edi
  800421c278:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c27f:	00 00 00 
  800421c282:	ff d0                	callq  *%rax
  800421c284:	49 89 c4             	mov    %rax,%r12
  800421c287:	bf 04 60 00 00       	mov    $0x6004,%edi
  800421c28c:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c293:	00 00 00 
  800421c296:	ff d0                	callq  *%rax
  800421c298:	48 89 c3             	mov    %rax,%rbx
  800421c29b:	bf 00 68 00 00       	mov    $0x6800,%edi
  800421c2a0:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c2a7:	00 00 00 
  800421c2aa:	ff d0                	callq  *%rax
  800421c2ac:	4c 89 e1             	mov    %r12,%rcx
  800421c2af:	48 89 da             	mov    %rbx,%rdx
  800421c2b2:	48 89 c6             	mov    %rax,%rsi
  800421c2b5:	48 bf 08 24 22 04 80 	movabs $0x8004222408,%rdi
  800421c2bc:	00 00 00 
  800421c2bf:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c2c4:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421c2cb:	00 00 00 
  800421c2ce:	41 ff d0             	callq  *%r8
			vmcs_readl(VMCS_GUEST_CR0), vmcs_readl(VMCS_CONTROL_CR0_READ_SHADOW),
			vmcs_readl(VMCS_CONTROL_CR0_GUEST_HOST_MASK));
	cprintf("CR4: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\n",
  800421c2d1:	bf 02 60 00 00       	mov    $0x6002,%edi
  800421c2d6:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c2dd:	00 00 00 
  800421c2e0:	ff d0                	callq  *%rax
  800421c2e2:	48 89 c3             	mov    %rax,%rbx
  800421c2e5:	bf 06 60 00 00       	mov    $0x6006,%edi
  800421c2ea:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c2f1:	00 00 00 
  800421c2f4:	ff d0                	callq  *%rax
  800421c2f6:	48 89 c2             	mov    %rax,%rdx
  800421c2f9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421c2fd:	48 89 d9             	mov    %rbx,%rcx
  800421c300:	48 89 c6             	mov    %rax,%rsi
  800421c303:	48 bf 40 24 22 04 80 	movabs $0x8004222440,%rdi
  800421c30a:	00 00 00 
  800421c30d:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c312:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421c319:	00 00 00 
  800421c31c:	41 ff d0             	callq  *%r8
			cr4, vmcs_readl(VMCS_CONTROL_CR4_READ_SHADOW), vmcs_readl(VMCS_CONTROL_CR4_GUEST_HOST_MASK));
	cprintf("CR3 = 0x%016lx\n", vmcs_readl(VMCS_GUEST_CR3));
  800421c31f:	bf 02 68 00 00       	mov    $0x6802,%edi
  800421c324:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c32b:	00 00 00 
  800421c32e:	ff d0                	callq  *%rax
  800421c330:	48 89 c6             	mov    %rax,%rsi
  800421c333:	48 bf 77 24 22 04 80 	movabs $0x8004222477,%rdi
  800421c33a:	00 00 00 
  800421c33d:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c342:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421c349:	00 00 00 
  800421c34c:	ff d2                	callq  *%rdx
	cprintf("RSP = 0x%016lx  RIP = 0x%016lx\n",
  800421c34e:	bf 1e 68 00 00       	mov    $0x681e,%edi
  800421c353:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c35a:	00 00 00 
  800421c35d:	ff d0                	callq  *%rax
  800421c35f:	48 89 c3             	mov    %rax,%rbx
  800421c362:	bf 1c 68 00 00       	mov    $0x681c,%edi
  800421c367:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c36e:	00 00 00 
  800421c371:	ff d0                	callq  *%rax
  800421c373:	48 89 da             	mov    %rbx,%rdx
  800421c376:	48 89 c6             	mov    %rax,%rsi
  800421c379:	48 bf 88 24 22 04 80 	movabs $0x8004222488,%rdi
  800421c380:	00 00 00 
  800421c383:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c388:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421c38f:	00 00 00 
  800421c392:	ff d1                	callq  *%rcx
			vmcs_readl(VMCS_GUEST_RSP), vmcs_readl(VMCS_GUEST_RIP));
	cprintf("RFLAGS=0x%08lx         DR7 = 0x%016lx\n",
  800421c394:	bf 1a 68 00 00       	mov    $0x681a,%edi
  800421c399:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c3a0:	00 00 00 
  800421c3a3:	ff d0                	callq  *%rax
  800421c3a5:	48 89 c3             	mov    %rax,%rbx
  800421c3a8:	bf 20 68 00 00       	mov    $0x6820,%edi
  800421c3ad:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c3b4:	00 00 00 
  800421c3b7:	ff d0                	callq  *%rax
  800421c3b9:	48 89 da             	mov    %rbx,%rdx
  800421c3bc:	48 89 c6             	mov    %rax,%rsi
  800421c3bf:	48 bf a8 24 22 04 80 	movabs $0x80042224a8,%rdi
  800421c3c6:	00 00 00 
  800421c3c9:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c3ce:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421c3d5:	00 00 00 
  800421c3d8:	ff d1                	callq  *%rcx
			vmcs_readl(VMCS_GUEST_RFLAGS), vmcs_readl(VMCS_GUEST_DR7));
	cprintf("Sysenter RSP=%016lx CS:RIP=%04x:%016lx\n",
  800421c3da:	bf 26 68 00 00       	mov    $0x6826,%edi
  800421c3df:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c3e6:	00 00 00 
  800421c3e9:	ff d0                	callq  *%rax
  800421c3eb:	49 89 c4             	mov    %rax,%r12
  800421c3ee:	c7 85 b8 fe ff ff 2a 	movl   $0x482a,-0x148(%rbp)
  800421c3f5:	48 00 00 
  800421c3f8:	8b 85 b8 fe ff ff    	mov    -0x148(%rbp),%eax
  800421c3fe:	89 c7                	mov    %eax,%edi
  800421c400:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c407:	00 00 00 
  800421c40a:	ff d0                	callq  *%rax
  800421c40c:	89 c3                	mov    %eax,%ebx
  800421c40e:	bf 24 68 00 00       	mov    $0x6824,%edi
  800421c413:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c41a:	00 00 00 
  800421c41d:	ff d0                	callq  *%rax
  800421c41f:	4c 89 e1             	mov    %r12,%rcx
  800421c422:	89 da                	mov    %ebx,%edx
  800421c424:	48 89 c6             	mov    %rax,%rsi
  800421c427:	48 bf d0 24 22 04 80 	movabs $0x80042224d0,%rdi
  800421c42e:	00 00 00 
  800421c431:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c436:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421c43d:	00 00 00 
  800421c440:	41 ff d0             	callq  *%r8
			vmcs_readl(VMCS_GUEST_IA32_SYSENTER_ESP_MSR),
			vmcs_read32(VMCS_32BIT_GUEST_IA32_SYSENTER_CS_MSR), vmcs_readl(VMCS_GUEST_IA32_SYSENTER_EIP_MSR));
	vmx_dump_sel("CS:  ", VMCS_16BIT_GUEST_CS_SELECTOR);
  800421c443:	be 02 08 00 00       	mov    $0x802,%esi
  800421c448:	48 bf f8 24 22 04 80 	movabs $0x80042224f8,%rdi
  800421c44f:	00 00 00 
  800421c452:	48 b8 5a c0 21 04 80 	movabs $0x800421c05a,%rax
  800421c459:	00 00 00 
  800421c45c:	ff d0                	callq  *%rax
	vmx_dump_sel("DS:  ", VMCS_16BIT_GUEST_DS_SELECTOR);
  800421c45e:	be 06 08 00 00       	mov    $0x806,%esi
  800421c463:	48 bf fe 24 22 04 80 	movabs $0x80042224fe,%rdi
  800421c46a:	00 00 00 
  800421c46d:	48 b8 5a c0 21 04 80 	movabs $0x800421c05a,%rax
  800421c474:	00 00 00 
  800421c477:	ff d0                	callq  *%rax
	vmx_dump_sel("SS:  ", VMCS_16BIT_GUEST_SS_SELECTOR);
  800421c479:	be 04 08 00 00       	mov    $0x804,%esi
  800421c47e:	48 bf 04 25 22 04 80 	movabs $0x8004222504,%rdi
  800421c485:	00 00 00 
  800421c488:	48 b8 5a c0 21 04 80 	movabs $0x800421c05a,%rax
  800421c48f:	00 00 00 
  800421c492:	ff d0                	callq  *%rax
	vmx_dump_sel("ES:  ", VMCS_16BIT_GUEST_ES_SELECTOR);
  800421c494:	be 00 08 00 00       	mov    $0x800,%esi
  800421c499:	48 bf 0a 25 22 04 80 	movabs $0x800422250a,%rdi
  800421c4a0:	00 00 00 
  800421c4a3:	48 b8 5a c0 21 04 80 	movabs $0x800421c05a,%rax
  800421c4aa:	00 00 00 
  800421c4ad:	ff d0                	callq  *%rax
	vmx_dump_sel("FS:  ", VMCS_16BIT_GUEST_FS_SELECTOR);
  800421c4af:	be 08 08 00 00       	mov    $0x808,%esi
  800421c4b4:	48 bf 10 25 22 04 80 	movabs $0x8004222510,%rdi
  800421c4bb:	00 00 00 
  800421c4be:	48 b8 5a c0 21 04 80 	movabs $0x800421c05a,%rax
  800421c4c5:	00 00 00 
  800421c4c8:	ff d0                	callq  *%rax
	vmx_dump_sel("GS:  ", VMCS_16BIT_GUEST_GS_SELECTOR);
  800421c4ca:	be 0a 08 00 00       	mov    $0x80a,%esi
  800421c4cf:	48 bf 16 25 22 04 80 	movabs $0x8004222516,%rdi
  800421c4d6:	00 00 00 
  800421c4d9:	48 b8 5a c0 21 04 80 	movabs $0x800421c05a,%rax
  800421c4e0:	00 00 00 
  800421c4e3:	ff d0                	callq  *%rax
	vmx_dump_dtsel("GDTR:", VMCS_32BIT_GUEST_GDTR_LIMIT);
  800421c4e5:	be 10 48 00 00       	mov    $0x4810,%esi
  800421c4ea:	48 bf 1c 25 22 04 80 	movabs $0x800422251c,%rdi
  800421c4f1:	00 00 00 
  800421c4f4:	48 b8 15 c1 21 04 80 	movabs $0x800421c115,%rax
  800421c4fb:	00 00 00 
  800421c4fe:	ff d0                	callq  *%rax
	vmx_dump_sel("LDTR:", VMCS_16BIT_GUEST_LDTR_SELECTOR);                                                                                                                               
  800421c500:	be 0c 08 00 00       	mov    $0x80c,%esi
  800421c505:	48 bf 22 25 22 04 80 	movabs $0x8004222522,%rdi
  800421c50c:	00 00 00 
  800421c50f:	48 b8 5a c0 21 04 80 	movabs $0x800421c05a,%rax
  800421c516:	00 00 00 
  800421c519:	ff d0                	callq  *%rax
	vmx_dump_dtsel("IDTR:", VMCS_32BIT_GUEST_IDTR_LIMIT);
  800421c51b:	be 12 48 00 00       	mov    $0x4812,%esi
  800421c520:	48 bf 28 25 22 04 80 	movabs $0x8004222528,%rdi
  800421c527:	00 00 00 
  800421c52a:	48 b8 15 c1 21 04 80 	movabs $0x800421c115,%rax
  800421c531:	00 00 00 
  800421c534:	ff d0                	callq  *%rax
	vmx_dump_sel("TR:  ", VMCS_16BIT_GUEST_TR_SELECTOR);
  800421c536:	be 0e 08 00 00       	mov    $0x80e,%esi
  800421c53b:	48 bf 2e 25 22 04 80 	movabs $0x800422252e,%rdi
  800421c542:	00 00 00 
  800421c545:	48 b8 5a c0 21 04 80 	movabs $0x800421c05a,%rax
  800421c54c:	00 00 00 
  800421c54f:	ff d0                	callq  *%rax
	if ((vmexit_ctl & (0x0040000 | 0x0010000)) ||
  800421c551:	8b 45 c0             	mov    -0x40(%rbp),%eax
  800421c554:	25 00 00 05 00       	and    $0x50000,%eax
  800421c559:	85 c0                	test   %eax,%eax
  800421c55b:	75 0c                	jne    800421c569 <vmcs_dump_cpu_1+0x3e4>
			(vmentry_ctl & (0x00004000 | 0x00008000)))
  800421c55d:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421c560:	25 00 c0 00 00       	and    $0xc000,%eax
	vmx_dump_sel("GS:  ", VMCS_16BIT_GUEST_GS_SELECTOR);
	vmx_dump_dtsel("GDTR:", VMCS_32BIT_GUEST_GDTR_LIMIT);
	vmx_dump_sel("LDTR:", VMCS_16BIT_GUEST_LDTR_SELECTOR);                                                                                                                               
	vmx_dump_dtsel("IDTR:", VMCS_32BIT_GUEST_IDTR_LIMIT);
	vmx_dump_sel("TR:  ", VMCS_16BIT_GUEST_TR_SELECTOR);
	if ((vmexit_ctl & (0x0040000 | 0x0010000)) ||
  800421c565:	85 c0                	test   %eax,%eax
  800421c567:	74 3d                	je     800421c5a6 <vmcs_dump_cpu_1+0x421>
  800421c569:	c7 45 cc 04 28 00 00 	movl   $0x2804,-0x34(%rbp)
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421c570:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421c573:	89 c7                	mov    %eax,%edi
  800421c575:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c57c:	00 00 00 
  800421c57f:	ff d0                	callq  *%rax
  800421c581:	48 89 c2             	mov    %rax,%rdx
			(vmentry_ctl & (0x00004000 | 0x00008000)))
		cprintf("EFER =     0x%016llx  PAT = 0x%016llx\n",
  800421c584:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421c588:	48 89 c6             	mov    %rax,%rsi
  800421c58b:	48 bf 38 25 22 04 80 	movabs $0x8004222538,%rdi
  800421c592:	00 00 00 
  800421c595:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c59a:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421c5a1:	00 00 00 
  800421c5a4:	ff d1                	callq  *%rcx
				efer, vmcs_read64(VMCS_64BIT_GUEST_IA32_PAT));
	cprintf("DebugCtl = 0x%016llx  DebugExceptions = 0x%016lx\n",
  800421c5a6:	bf 22 68 00 00       	mov    $0x6822,%edi
  800421c5ab:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c5b2:	00 00 00 
  800421c5b5:	ff d0                	callq  *%rax
  800421c5b7:	48 89 c3             	mov    %rax,%rbx
  800421c5ba:	c7 45 84 02 28 00 00 	movl   $0x2802,-0x7c(%rbp)
  800421c5c1:	8b 45 84             	mov    -0x7c(%rbp),%eax
  800421c5c4:	89 c7                	mov    %eax,%edi
  800421c5c6:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c5cd:	00 00 00 
  800421c5d0:	ff d0                	callq  *%rax
  800421c5d2:	48 89 da             	mov    %rbx,%rdx
  800421c5d5:	48 89 c6             	mov    %rax,%rsi
  800421c5d8:	48 bf 60 25 22 04 80 	movabs $0x8004222560,%rdi
  800421c5df:	00 00 00 
  800421c5e2:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c5e7:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421c5ee:	00 00 00 
  800421c5f1:	ff d1                	callq  *%rcx
			vmcs_read64(VMCS_64BIT_GUEST_IA32_DEBUGCTL),
			vmcs_readl(VMCS_GUEST_PENDING_DBG_EXCEPTIONS));
	if(vmentry_ctl & 0x000100000)
  800421c5f3:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421c5f6:	25 00 00 10 00       	and    $0x100000,%eax
  800421c5fb:	85 c0                	test   %eax,%eax
  800421c5fd:	74 36                	je     800421c635 <vmcs_dump_cpu_1+0x4b0>
  800421c5ff:	c7 45 80 12 28 00 00 	movl   $0x2812,-0x80(%rbp)
  800421c606:	8b 45 80             	mov    -0x80(%rbp),%eax
  800421c609:	89 c7                	mov    %eax,%edi
  800421c60b:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c612:	00 00 00 
  800421c615:	ff d0                	callq  *%rax
		cprintf("BndCfgS = 0x%016llx\n", vmcs_read64(0x00002812));
  800421c617:	48 89 c6             	mov    %rax,%rsi
  800421c61a:	48 bf 92 25 22 04 80 	movabs $0x8004222592,%rdi
  800421c621:	00 00 00 
  800421c624:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c629:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421c630:	00 00 00 
  800421c633:	ff d2                	callq  *%rdx
  800421c635:	c7 85 74 ff ff ff 26 	movl   $0x4826,-0x8c(%rbp)
  800421c63c:	48 00 00 
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421c63f:	8b 85 74 ff ff ff    	mov    -0x8c(%rbp),%eax
  800421c645:	89 c7                	mov    %eax,%edi
  800421c647:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c64e:	00 00 00 
  800421c651:	ff d0                	callq  *%rax
  800421c653:	89 c3                	mov    %eax,%ebx
  800421c655:	c7 85 7c ff ff ff 24 	movl   $0x4824,-0x84(%rbp)
  800421c65c:	48 00 00 
  800421c65f:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
  800421c665:	89 c7                	mov    %eax,%edi
  800421c667:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c66e:	00 00 00 
  800421c671:	ff d0                	callq  *%rax
	cprintf("Interruptibility = %08x  ActivityState = %08x\n",
  800421c673:	89 da                	mov    %ebx,%edx
  800421c675:	89 c6                	mov    %eax,%esi
  800421c677:	48 bf a8 25 22 04 80 	movabs $0x80042225a8,%rdi
  800421c67e:	00 00 00 
  800421c681:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c686:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421c68d:	00 00 00 
  800421c690:	ff d1                	callq  *%rcx
			vmcs_read32(VMCS_32BIT_GUEST_INTERRUPTIBILITY_STATE),
			vmcs_read32(VMCS_32BIT_GUEST_ACTIVITY_STATE));
	if (secondary_exec_control & 0x00000200)
  800421c692:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800421c695:	25 00 02 00 00       	and    $0x200,%eax
  800421c69a:	85 c0                	test   %eax,%eax
  800421c69c:	74 3e                	je     800421c6dc <vmcs_dump_cpu_1+0x557>
  800421c69e:	c7 85 78 ff ff ff 10 	movl   $0x810,-0x88(%rbp)
  800421c6a5:	08 00 00 
	return value;
}

static __inline uint16_t vmcs_read16(uint32_t field)
{
	return vmcs_readl(field);
  800421c6a8:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
  800421c6ae:	89 c7                	mov    %eax,%edi
  800421c6b0:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c6b7:	00 00 00 
  800421c6ba:	ff d0                	callq  *%rax
		cprintf("InterruptStatus = %04x\n",
  800421c6bc:	0f b7 c0             	movzwl %ax,%eax
  800421c6bf:	89 c6                	mov    %eax,%esi
  800421c6c1:	48 bf d7 25 22 04 80 	movabs $0x80042225d7,%rdi
  800421c6c8:	00 00 00 
  800421c6cb:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c6d0:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421c6d7:	00 00 00 
  800421c6da:	ff d2                	callq  *%rdx
				vmcs_read16(VMCS_16BIT_GUEST_INTERRUPT_STATUS));

	cprintf("\n*** Host State ***\n");
  800421c6dc:	48 bf ef 25 22 04 80 	movabs $0x80042225ef,%rdi
  800421c6e3:	00 00 00 
  800421c6e6:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c6eb:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421c6f2:	00 00 00 
  800421c6f5:	ff d2                	callq  *%rdx
	cprintf("RIP = 0x%016lx  RSP = 0x%016lx\n",
  800421c6f7:	bf 14 6c 00 00       	mov    $0x6c14,%edi
  800421c6fc:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c703:	00 00 00 
  800421c706:	ff d0                	callq  *%rax
  800421c708:	48 89 c3             	mov    %rax,%rbx
  800421c70b:	bf 16 6c 00 00       	mov    $0x6c16,%edi
  800421c710:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c717:	00 00 00 
  800421c71a:	ff d0                	callq  *%rax
  800421c71c:	48 89 da             	mov    %rbx,%rdx
  800421c71f:	48 89 c6             	mov    %rax,%rsi
  800421c722:	48 bf 08 26 22 04 80 	movabs $0x8004222608,%rdi
  800421c729:	00 00 00 
  800421c72c:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c731:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421c738:	00 00 00 
  800421c73b:	ff d1                	callq  *%rcx
  800421c73d:	c7 85 68 ff ff ff 0c 	movl   $0xc0c,-0x98(%rbp)
  800421c744:	0c 00 00 
  800421c747:	8b 85 68 ff ff ff    	mov    -0x98(%rbp),%eax
  800421c74d:	89 c7                	mov    %eax,%edi
  800421c74f:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c756:	00 00 00 
  800421c759:	ff d0                	callq  *%rax
			vmcs_readl(VMCS_HOST_RIP), vmcs_readl(VMCS_HOST_RSP));
	cprintf("CS=%04x SS=%04x DS=%04x ES=%04x FS=%04x GS=%04x TR=%04x\n",
  800421c75b:	44 0f b7 f0          	movzwl %ax,%r14d
  800421c75f:	c7 85 64 ff ff ff 0a 	movl   $0xc0a,-0x9c(%rbp)
  800421c766:	0c 00 00 
  800421c769:	8b 85 64 ff ff ff    	mov    -0x9c(%rbp),%eax
  800421c76f:	89 c7                	mov    %eax,%edi
  800421c771:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c778:	00 00 00 
  800421c77b:	ff d0                	callq  *%rax
  800421c77d:	44 0f b7 e8          	movzwl %ax,%r13d
  800421c781:	c7 85 60 ff ff ff 08 	movl   $0xc08,-0xa0(%rbp)
  800421c788:	0c 00 00 
  800421c78b:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
  800421c791:	89 c7                	mov    %eax,%edi
  800421c793:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c79a:	00 00 00 
  800421c79d:	ff d0                	callq  *%rax
  800421c79f:	0f b7 c0             	movzwl %ax,%eax
  800421c7a2:	89 85 ac fe ff ff    	mov    %eax,-0x154(%rbp)
  800421c7a8:	c7 85 5c ff ff ff 00 	movl   $0xc00,-0xa4(%rbp)
  800421c7af:	0c 00 00 
  800421c7b2:	8b 85 5c ff ff ff    	mov    -0xa4(%rbp),%eax
  800421c7b8:	89 c7                	mov    %eax,%edi
  800421c7ba:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c7c1:	00 00 00 
  800421c7c4:	ff d0                	callq  *%rax
  800421c7c6:	44 0f b7 f8          	movzwl %ax,%r15d
  800421c7ca:	c7 85 58 ff ff ff 06 	movl   $0xc06,-0xa8(%rbp)
  800421c7d1:	0c 00 00 
  800421c7d4:	8b 85 58 ff ff ff    	mov    -0xa8(%rbp),%eax
  800421c7da:	89 c7                	mov    %eax,%edi
  800421c7dc:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c7e3:	00 00 00 
  800421c7e6:	ff d0                	callq  *%rax
  800421c7e8:	44 0f b7 e0          	movzwl %ax,%r12d
  800421c7ec:	c7 85 54 ff ff ff 04 	movl   $0xc04,-0xac(%rbp)
  800421c7f3:	0c 00 00 
  800421c7f6:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
  800421c7fc:	89 c7                	mov    %eax,%edi
  800421c7fe:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c805:	00 00 00 
  800421c808:	ff d0                	callq  *%rax
  800421c80a:	0f b7 d8             	movzwl %ax,%ebx
  800421c80d:	c7 85 50 ff ff ff 02 	movl   $0xc02,-0xb0(%rbp)
  800421c814:	0c 00 00 
  800421c817:	8b 85 50 ff ff ff    	mov    -0xb0(%rbp),%eax
  800421c81d:	89 c7                	mov    %eax,%edi
  800421c81f:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c826:	00 00 00 
  800421c829:	ff d0                	callq  *%rax
  800421c82b:	0f b7 c0             	movzwl %ax,%eax
  800421c82e:	41 56                	push   %r14
  800421c830:	41 55                	push   %r13
  800421c832:	44 8b 8d ac fe ff ff 	mov    -0x154(%rbp),%r9d
  800421c839:	45 89 f8             	mov    %r15d,%r8d
  800421c83c:	44 89 e1             	mov    %r12d,%ecx
  800421c83f:	89 da                	mov    %ebx,%edx
  800421c841:	89 c6                	mov    %eax,%esi
  800421c843:	48 bf 28 26 22 04 80 	movabs $0x8004222628,%rdi
  800421c84a:	00 00 00 
  800421c84d:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c852:	49 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%r10
  800421c859:	00 00 00 
  800421c85c:	41 ff d2             	callq  *%r10
  800421c85f:	48 83 c4 10          	add    $0x10,%rsp
			vmcs_read16(VMCS_16BIT_HOST_CS_SELECTOR), vmcs_read16(VMCS_16BIT_HOST_SS_SELECTOR),
			vmcs_read16(VMCS_16BIT_HOST_DS_SELECTOR), vmcs_read16(VMCS_16BIT_HOST_ES_SELECTOR),
			vmcs_read16(VMCS_16BIT_HOST_FS_SELECTOR), vmcs_read16(VMCS_16BIT_HOST_GS_SELECTOR),
			vmcs_read16(VMCS_16BIT_HOST_TR_SELECTOR));
	cprintf("FSBase=%016lx GSBase=%016lx TRBase=%016lx\n",
  800421c863:	bf 0a 6c 00 00       	mov    $0x6c0a,%edi
  800421c868:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c86f:	00 00 00 
  800421c872:	ff d0                	callq  *%rax
  800421c874:	49 89 c4             	mov    %rax,%r12
  800421c877:	bf 08 6c 00 00       	mov    $0x6c08,%edi
  800421c87c:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c883:	00 00 00 
  800421c886:	ff d0                	callq  *%rax
  800421c888:	48 89 c3             	mov    %rax,%rbx
  800421c88b:	bf 06 6c 00 00       	mov    $0x6c06,%edi
  800421c890:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c897:	00 00 00 
  800421c89a:	ff d0                	callq  *%rax
  800421c89c:	4c 89 e1             	mov    %r12,%rcx
  800421c89f:	48 89 da             	mov    %rbx,%rdx
  800421c8a2:	48 89 c6             	mov    %rax,%rsi
  800421c8a5:	48 bf 68 26 22 04 80 	movabs $0x8004222668,%rdi
  800421c8ac:	00 00 00 
  800421c8af:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c8b4:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421c8bb:	00 00 00 
  800421c8be:	41 ff d0             	callq  *%r8
			vmcs_readl(VMCS_HOST_FS_BASE), vmcs_readl(VMCS_HOST_GS_BASE),
			vmcs_readl(VMCS_HOST_TR_BASE));
	cprintf("GDTBase=%016lx IDTBase=%016lx\n",
  800421c8c1:	bf 0e 6c 00 00       	mov    $0x6c0e,%edi
  800421c8c6:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c8cd:	00 00 00 
  800421c8d0:	ff d0                	callq  *%rax
  800421c8d2:	48 89 c3             	mov    %rax,%rbx
  800421c8d5:	bf 0c 6c 00 00       	mov    $0x6c0c,%edi
  800421c8da:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c8e1:	00 00 00 
  800421c8e4:	ff d0                	callq  *%rax
  800421c8e6:	48 89 da             	mov    %rbx,%rdx
  800421c8e9:	48 89 c6             	mov    %rax,%rsi
  800421c8ec:	48 bf 98 26 22 04 80 	movabs $0x8004222698,%rdi
  800421c8f3:	00 00 00 
  800421c8f6:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c8fb:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421c902:	00 00 00 
  800421c905:	ff d1                	callq  *%rcx
			vmcs_readl(VMCS_HOST_GDTR_BASE), vmcs_readl(VMCS_HOST_IDTR_BASE));
	cprintf("CR0=%016lx CR3=%016lx CR4=%016lx\n",
  800421c907:	bf 04 6c 00 00       	mov    $0x6c04,%edi
  800421c90c:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c913:	00 00 00 
  800421c916:	ff d0                	callq  *%rax
  800421c918:	49 89 c4             	mov    %rax,%r12
  800421c91b:	bf 02 6c 00 00       	mov    $0x6c02,%edi
  800421c920:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c927:	00 00 00 
  800421c92a:	ff d0                	callq  *%rax
  800421c92c:	48 89 c3             	mov    %rax,%rbx
  800421c92f:	bf 00 6c 00 00       	mov    $0x6c00,%edi
  800421c934:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c93b:	00 00 00 
  800421c93e:	ff d0                	callq  *%rax
  800421c940:	4c 89 e1             	mov    %r12,%rcx
  800421c943:	48 89 da             	mov    %rbx,%rdx
  800421c946:	48 89 c6             	mov    %rax,%rsi
  800421c949:	48 bf b8 26 22 04 80 	movabs $0x80042226b8,%rdi
  800421c950:	00 00 00 
  800421c953:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c958:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421c95f:	00 00 00 
  800421c962:	41 ff d0             	callq  *%r8
			vmcs_readl(VMCS_HOST_CR0), vmcs_readl(VMCS_HOST_CR3),
			vmcs_readl(VMCS_HOST_CR4));
	cprintf("Sysenter RSP=%016lx CS:RIP=%04x:%016lx\n",
  800421c965:	bf 12 6c 00 00       	mov    $0x6c12,%edi
  800421c96a:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c971:	00 00 00 
  800421c974:	ff d0                	callq  *%rax
  800421c976:	49 89 c4             	mov    %rax,%r12
  800421c979:	c7 85 70 ff ff ff 00 	movl   $0x4c00,-0x90(%rbp)
  800421c980:	4c 00 00 
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421c983:	8b 85 70 ff ff ff    	mov    -0x90(%rbp),%eax
  800421c989:	89 c7                	mov    %eax,%edi
  800421c98b:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c992:	00 00 00 
  800421c995:	ff d0                	callq  *%rax
  800421c997:	89 c3                	mov    %eax,%ebx
  800421c999:	bf 10 6c 00 00       	mov    $0x6c10,%edi
  800421c99e:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c9a5:	00 00 00 
  800421c9a8:	ff d0                	callq  *%rax
  800421c9aa:	4c 89 e1             	mov    %r12,%rcx
  800421c9ad:	89 da                	mov    %ebx,%edx
  800421c9af:	48 89 c6             	mov    %rax,%rsi
  800421c9b2:	48 bf d0 24 22 04 80 	movabs $0x80042224d0,%rdi
  800421c9b9:	00 00 00 
  800421c9bc:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c9c1:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421c9c8:	00 00 00 
  800421c9cb:	41 ff d0             	callq  *%r8
			vmcs_readl (VMCS_HOST_IA32_SYSENTER_ESP_MSR),
			vmcs_read32(VMCS_32BIT_HOST_IA32_SYSENTER_CS_MSR),
			vmcs_readl (VMCS_HOST_IA32_SYSENTER_EIP_MSR));
	if (vmexit_ctl & (0x00080000 | 0x00200000))
  800421c9ce:	8b 45 c0             	mov    -0x40(%rbp),%eax
  800421c9d1:	25 00 00 28 00       	and    $0x280000,%eax
  800421c9d6:	85 c0                	test   %eax,%eax
  800421c9d8:	74 60                	je     800421ca3a <vmcs_dump_cpu_1+0x8b5>
  800421c9da:	c7 85 48 ff ff ff 00 	movl   $0x2c00,-0xb8(%rbp)
  800421c9e1:	2c 00 00 
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421c9e4:	8b 85 48 ff ff ff    	mov    -0xb8(%rbp),%eax
  800421c9ea:	89 c7                	mov    %eax,%edi
  800421c9ec:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421c9f3:	00 00 00 
  800421c9f6:	ff d0                	callq  *%rax
  800421c9f8:	48 89 c3             	mov    %rax,%rbx
  800421c9fb:	c7 85 6c ff ff ff 02 	movl   $0x2c02,-0x94(%rbp)
  800421ca02:	2c 00 00 
  800421ca05:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
  800421ca0b:	89 c7                	mov    %eax,%edi
  800421ca0d:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421ca14:	00 00 00 
  800421ca17:	ff d0                	callq  *%rax
		cprintf("EFER = 0x%016llx  PAT = 0x%016llx\n",
  800421ca19:	48 89 da             	mov    %rbx,%rdx
  800421ca1c:	48 89 c6             	mov    %rax,%rsi
  800421ca1f:	48 bf e0 26 22 04 80 	movabs $0x80042226e0,%rdi
  800421ca26:	00 00 00 
  800421ca29:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ca2e:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421ca35:	00 00 00 
  800421ca38:	ff d1                	callq  *%rcx
				vmcs_read64(VMCS_64BIT_HOST_IA32_EFER),
				vmcs_read64(VMCS_64BIT_HOST_IA32_PAT));

	cprintf("\n*** Control State ***\n");
  800421ca3a:	48 bf 03 27 22 04 80 	movabs $0x8004222703,%rdi
  800421ca41:	00 00 00 
  800421ca44:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ca49:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421ca50:	00 00 00 
  800421ca53:	ff d2                	callq  *%rdx
	cprintf("PinBased=%08x CPUBased=%08x SecondaryExec=%08x\n",
  800421ca55:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  800421ca58:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800421ca5b:	8b 45 b0             	mov    -0x50(%rbp),%eax
  800421ca5e:	89 c6                	mov    %eax,%esi
  800421ca60:	48 bf 20 27 22 04 80 	movabs $0x8004222720,%rdi
  800421ca67:	00 00 00 
  800421ca6a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ca6f:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421ca76:	00 00 00 
  800421ca79:	41 ff d0             	callq  *%r8
			pin_based_exec_ctrl, cpu_based_exec_ctrl, secondary_exec_control);
	cprintf("EntryControls=%08x ExitControls=%08x\n", vmentry_ctl, vmexit_ctl);
  800421ca7c:	8b 55 c0             	mov    -0x40(%rbp),%edx
  800421ca7f:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421ca82:	89 c6                	mov    %eax,%esi
  800421ca84:	48 bf 50 27 22 04 80 	movabs $0x8004222750,%rdi
  800421ca8b:	00 00 00 
  800421ca8e:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ca93:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421ca9a:	00 00 00 
  800421ca9d:	ff d1                	callq  *%rcx
  800421ca9f:	c7 85 40 ff ff ff 08 	movl   $0x4008,-0xc0(%rbp)
  800421caa6:	40 00 00 
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421caa9:	8b 85 40 ff ff ff    	mov    -0xc0(%rbp),%eax
  800421caaf:	89 c7                	mov    %eax,%edi
  800421cab1:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cab8:	00 00 00 
  800421cabb:	ff d0                	callq  *%rax
  800421cabd:	41 89 c4             	mov    %eax,%r12d
  800421cac0:	c7 85 3c ff ff ff 06 	movl   $0x4006,-0xc4(%rbp)
  800421cac7:	40 00 00 
  800421caca:	8b 85 3c ff ff ff    	mov    -0xc4(%rbp),%eax
  800421cad0:	89 c7                	mov    %eax,%edi
  800421cad2:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cad9:	00 00 00 
  800421cadc:	ff d0                	callq  *%rax
  800421cade:	89 c3                	mov    %eax,%ebx
  800421cae0:	c7 85 38 ff ff ff 04 	movl   $0x4004,-0xc8(%rbp)
  800421cae7:	40 00 00 
  800421caea:	8b 85 38 ff ff ff    	mov    -0xc8(%rbp),%eax
  800421caf0:	89 c7                	mov    %eax,%edi
  800421caf2:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421caf9:	00 00 00 
  800421cafc:	ff d0                	callq  *%rax
	cprintf("ExceptionBitmap=%08x PFECmask=%08x PFECmatch=%08x\n",
  800421cafe:	44 89 e1             	mov    %r12d,%ecx
  800421cb01:	89 da                	mov    %ebx,%edx
  800421cb03:	89 c6                	mov    %eax,%esi
  800421cb05:	48 bf 78 27 22 04 80 	movabs $0x8004222778,%rdi
  800421cb0c:	00 00 00 
  800421cb0f:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cb14:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421cb1b:	00 00 00 
  800421cb1e:	41 ff d0             	callq  *%r8
  800421cb21:	c7 85 34 ff ff ff 1a 	movl   $0x401a,-0xcc(%rbp)
  800421cb28:	40 00 00 
  800421cb2b:	8b 85 34 ff ff ff    	mov    -0xcc(%rbp),%eax
  800421cb31:	89 c7                	mov    %eax,%edi
  800421cb33:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cb3a:	00 00 00 
  800421cb3d:	ff d0                	callq  *%rax
  800421cb3f:	41 89 c4             	mov    %eax,%r12d
  800421cb42:	c7 85 30 ff ff ff 18 	movl   $0x4018,-0xd0(%rbp)
  800421cb49:	40 00 00 
  800421cb4c:	8b 85 30 ff ff ff    	mov    -0xd0(%rbp),%eax
  800421cb52:	89 c7                	mov    %eax,%edi
  800421cb54:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cb5b:	00 00 00 
  800421cb5e:	ff d0                	callq  *%rax
  800421cb60:	89 c3                	mov    %eax,%ebx
  800421cb62:	c7 85 2c ff ff ff 16 	movl   $0x4016,-0xd4(%rbp)
  800421cb69:	40 00 00 
  800421cb6c:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
  800421cb72:	89 c7                	mov    %eax,%edi
  800421cb74:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cb7b:	00 00 00 
  800421cb7e:	ff d0                	callq  *%rax
			vmcs_read32(VMCS_32BIT_CONTROL_EXCEPTION_BITMAP),
			vmcs_read32(VMCS_32BIT_CONTROL_PAGE_FAULT_ERR_CODE_MASK),
			vmcs_read32(VMCS_32BIT_CONTROL_PAGE_FAULT_ERR_CODE_MATCH));
	cprintf("VMEntry: intr_info=%08x errcode=%08x ilen=%08x\n",
  800421cb80:	44 89 e1             	mov    %r12d,%ecx
  800421cb83:	89 da                	mov    %ebx,%edx
  800421cb85:	89 c6                	mov    %eax,%esi
  800421cb87:	48 bf b0 27 22 04 80 	movabs $0x80042227b0,%rdi
  800421cb8e:	00 00 00 
  800421cb91:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cb96:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421cb9d:	00 00 00 
  800421cba0:	41 ff d0             	callq  *%r8
  800421cba3:	c7 85 28 ff ff ff 0c 	movl   $0x440c,-0xd8(%rbp)
  800421cbaa:	44 00 00 
  800421cbad:	8b 85 28 ff ff ff    	mov    -0xd8(%rbp),%eax
  800421cbb3:	89 c7                	mov    %eax,%edi
  800421cbb5:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cbbc:	00 00 00 
  800421cbbf:	ff d0                	callq  *%rax
  800421cbc1:	41 89 c4             	mov    %eax,%r12d
  800421cbc4:	c7 85 24 ff ff ff 06 	movl   $0x4406,-0xdc(%rbp)
  800421cbcb:	44 00 00 
  800421cbce:	8b 85 24 ff ff ff    	mov    -0xdc(%rbp),%eax
  800421cbd4:	89 c7                	mov    %eax,%edi
  800421cbd6:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cbdd:	00 00 00 
  800421cbe0:	ff d0                	callq  *%rax
  800421cbe2:	89 c3                	mov    %eax,%ebx
  800421cbe4:	c7 85 20 ff ff ff 04 	movl   $0x4404,-0xe0(%rbp)
  800421cbeb:	44 00 00 
  800421cbee:	8b 85 20 ff ff ff    	mov    -0xe0(%rbp),%eax
  800421cbf4:	89 c7                	mov    %eax,%edi
  800421cbf6:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cbfd:	00 00 00 
  800421cc00:	ff d0                	callq  *%rax
			vmcs_read32(VMCS_32BIT_CONTROL_VMENTRY_INTERRUPTION_INFO),
			vmcs_read32(VMCS_32BIT_CONTROL_VMENTRY_EXCEPTION_ERR_CODE),
			vmcs_read32(VMCS_32BIT_CONTROL_VMENTRY_INSTRUCTION_LENGTH));
	cprintf("VMExit: intr_info=%08x errcode=%08x ilen=%08x\n",
  800421cc02:	44 89 e1             	mov    %r12d,%ecx
  800421cc05:	89 da                	mov    %ebx,%edx
  800421cc07:	89 c6                	mov    %eax,%esi
  800421cc09:	48 bf e0 27 22 04 80 	movabs $0x80042227e0,%rdi
  800421cc10:	00 00 00 
  800421cc13:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cc18:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421cc1f:	00 00 00 
  800421cc22:	41 ff d0             	callq  *%r8
			vmcs_read32(VMCS_32BIT_VMEXIT_INTERRUPTION_INFO),
			vmcs_read32(VMCS_32BIT_VMEXIT_INTERRUPTION_ERR_CODE),
			vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH));
	cprintf("        reason=%08x qualification=%016lx\n",
  800421cc25:	bf 00 64 00 00       	mov    $0x6400,%edi
  800421cc2a:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cc31:	00 00 00 
  800421cc34:	ff d0                	callq  *%rax
  800421cc36:	48 89 c3             	mov    %rax,%rbx
  800421cc39:	c7 85 4c ff ff ff 02 	movl   $0x4402,-0xb4(%rbp)
  800421cc40:	44 00 00 
  800421cc43:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
  800421cc49:	89 c7                	mov    %eax,%edi
  800421cc4b:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cc52:	00 00 00 
  800421cc55:	ff d0                	callq  *%rax
  800421cc57:	48 89 da             	mov    %rbx,%rdx
  800421cc5a:	89 c6                	mov    %eax,%esi
  800421cc5c:	48 bf 10 28 22 04 80 	movabs $0x8004222810,%rdi
  800421cc63:	00 00 00 
  800421cc66:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cc6b:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421cc72:	00 00 00 
  800421cc75:	ff d1                	callq  *%rcx
			vmcs_read32(VMCS_32BIT_VMEXIT_REASON), vmcs_readl(VMCS_VMEXIT_QUALIFICATION));
	if ((vmexit_ctl & (0x0040000 | 0x0010000)) ||
  800421cc77:	8b 45 c0             	mov    -0x40(%rbp),%eax
  800421cc7a:	25 00 00 05 00       	and    $0x50000,%eax
  800421cc7f:	85 c0                	test   %eax,%eax
  800421cc81:	75 0c                	jne    800421cc8f <vmcs_dump_cpu_1+0xb0a>
			(vmentry_ctl & (0x00004000 | 0x00008000)))
  800421cc83:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421cc86:	25 00 c0 00 00       	and    $0xc000,%eax
			vmcs_read32(VMCS_32BIT_VMEXIT_INTERRUPTION_INFO),
			vmcs_read32(VMCS_32BIT_VMEXIT_INTERRUPTION_ERR_CODE),
			vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH));
	cprintf("        reason=%08x qualification=%016lx\n",
			vmcs_read32(VMCS_32BIT_VMEXIT_REASON), vmcs_readl(VMCS_VMEXIT_QUALIFICATION));
	if ((vmexit_ctl & (0x0040000 | 0x0010000)) ||
  800421cc8b:	85 c0                	test   %eax,%eax
  800421cc8d:	74 43                	je     800421ccd2 <vmcs_dump_cpu_1+0xb4d>
  800421cc8f:	c7 85 44 ff ff ff 04 	movl   $0x2804,-0xbc(%rbp)
  800421cc96:	28 00 00 
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421cc99:	8b 85 44 ff ff ff    	mov    -0xbc(%rbp),%eax
  800421cc9f:	89 c7                	mov    %eax,%edi
  800421cca1:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cca8:	00 00 00 
  800421ccab:	ff d0                	callq  *%rax
  800421ccad:	48 89 c2             	mov    %rax,%rdx
			(vmentry_ctl & (0x00004000 | 0x00008000)))
		cprintf("EFER =     0x%016llx  PAT = 0x%016llx\n",
  800421ccb0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421ccb4:	48 89 c6             	mov    %rax,%rsi
  800421ccb7:	48 bf 38 25 22 04 80 	movabs $0x8004222538,%rdi
  800421ccbe:	00 00 00 
  800421ccc1:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ccc6:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421cccd:	00 00 00 
  800421ccd0:	ff d1                	callq  *%rcx
				efer, vmcs_read64(VMCS_64BIT_GUEST_IA32_PAT));
	cprintf("DebugCtl = 0x%016llx  DebugExceptions = 0x%016lx\n",
  800421ccd2:	bf 22 68 00 00       	mov    $0x6822,%edi
  800421ccd7:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421ccde:	00 00 00 
  800421cce1:	ff d0                	callq  *%rax
  800421cce3:	48 89 c3             	mov    %rax,%rbx
  800421cce6:	c7 85 1c ff ff ff 02 	movl   $0x2802,-0xe4(%rbp)
  800421cced:	28 00 00 
  800421ccf0:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
  800421ccf6:	89 c7                	mov    %eax,%edi
  800421ccf8:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421ccff:	00 00 00 
  800421cd02:	ff d0                	callq  *%rax
  800421cd04:	48 89 da             	mov    %rbx,%rdx
  800421cd07:	48 89 c6             	mov    %rax,%rsi
  800421cd0a:	48 bf 60 25 22 04 80 	movabs $0x8004222560,%rdi
  800421cd11:	00 00 00 
  800421cd14:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cd19:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421cd20:	00 00 00 
  800421cd23:	ff d1                	callq  *%rcx
			vmcs_read64(VMCS_64BIT_GUEST_IA32_DEBUGCTL),
			vmcs_readl(VMCS_GUEST_PENDING_DBG_EXCEPTIONS));
	if(vmentry_ctl & 0x000100000)
  800421cd25:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421cd28:	25 00 00 10 00       	and    $0x100000,%eax
  800421cd2d:	85 c0                	test   %eax,%eax
  800421cd2f:	74 3c                	je     800421cd6d <vmcs_dump_cpu_1+0xbe8>
  800421cd31:	c7 85 18 ff ff ff 12 	movl   $0x2812,-0xe8(%rbp)
  800421cd38:	28 00 00 
  800421cd3b:	8b 85 18 ff ff ff    	mov    -0xe8(%rbp),%eax
  800421cd41:	89 c7                	mov    %eax,%edi
  800421cd43:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cd4a:	00 00 00 
  800421cd4d:	ff d0                	callq  *%rax
		cprintf("BndCfgS = 0x%016llx\n", vmcs_read64(0x00002812));
  800421cd4f:	48 89 c6             	mov    %rax,%rsi
  800421cd52:	48 bf 92 25 22 04 80 	movabs $0x8004222592,%rdi
  800421cd59:	00 00 00 
  800421cd5c:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cd61:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421cd68:	00 00 00 
  800421cd6b:	ff d2                	callq  *%rdx
  800421cd6d:	c7 85 0c ff ff ff 26 	movl   $0x4826,-0xf4(%rbp)
  800421cd74:	48 00 00 
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421cd77:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  800421cd7d:	89 c7                	mov    %eax,%edi
  800421cd7f:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cd86:	00 00 00 
  800421cd89:	ff d0                	callq  *%rax
  800421cd8b:	89 c3                	mov    %eax,%ebx
  800421cd8d:	c7 85 14 ff ff ff 24 	movl   $0x4824,-0xec(%rbp)
  800421cd94:	48 00 00 
  800421cd97:	8b 85 14 ff ff ff    	mov    -0xec(%rbp),%eax
  800421cd9d:	89 c7                	mov    %eax,%edi
  800421cd9f:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cda6:	00 00 00 
  800421cda9:	ff d0                	callq  *%rax
	cprintf("Interruptibility = %08x  ActivityState = %08x\n",
  800421cdab:	89 da                	mov    %ebx,%edx
  800421cdad:	89 c6                	mov    %eax,%esi
  800421cdaf:	48 bf a8 25 22 04 80 	movabs $0x80042225a8,%rdi
  800421cdb6:	00 00 00 
  800421cdb9:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cdbe:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421cdc5:	00 00 00 
  800421cdc8:	ff d1                	callq  *%rcx
			vmcs_read32(VMCS_32BIT_GUEST_INTERRUPTIBILITY_STATE),
			vmcs_read32(VMCS_32BIT_GUEST_ACTIVITY_STATE));
	if (secondary_exec_control & 0x00000200)
  800421cdca:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800421cdcd:	25 00 02 00 00       	and    $0x200,%eax
  800421cdd2:	85 c0                	test   %eax,%eax
  800421cdd4:	74 3e                	je     800421ce14 <vmcs_dump_cpu_1+0xc8f>
  800421cdd6:	c7 85 10 ff ff ff 10 	movl   $0x810,-0xf0(%rbp)
  800421cddd:	08 00 00 
	return value;
}

static __inline uint16_t vmcs_read16(uint32_t field)
{
	return vmcs_readl(field);
  800421cde0:	8b 85 10 ff ff ff    	mov    -0xf0(%rbp),%eax
  800421cde6:	89 c7                	mov    %eax,%edi
  800421cde8:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cdef:	00 00 00 
  800421cdf2:	ff d0                	callq  *%rax
		cprintf("InterruptStatus = %04x\n",
  800421cdf4:	0f b7 c0             	movzwl %ax,%eax
  800421cdf7:	89 c6                	mov    %eax,%esi
  800421cdf9:	48 bf d7 25 22 04 80 	movabs $0x80042225d7,%rdi
  800421ce00:	00 00 00 
  800421ce03:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ce08:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421ce0f:	00 00 00 
  800421ce12:	ff d2                	callq  *%rdx
				vmcs_read16(VMCS_16BIT_GUEST_INTERRUPT_STATUS));

	cprintf("\n*** Host State ***\n");
  800421ce14:	48 bf ef 25 22 04 80 	movabs $0x80042225ef,%rdi
  800421ce1b:	00 00 00 
  800421ce1e:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ce23:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421ce2a:	00 00 00 
  800421ce2d:	ff d2                	callq  *%rdx
	cprintf("RIP = 0x%016lx  RSP = 0x%016lx\n",
  800421ce2f:	bf 14 6c 00 00       	mov    $0x6c14,%edi
  800421ce34:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421ce3b:	00 00 00 
  800421ce3e:	ff d0                	callq  *%rax
  800421ce40:	48 89 c3             	mov    %rax,%rbx
  800421ce43:	bf 16 6c 00 00       	mov    $0x6c16,%edi
  800421ce48:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421ce4f:	00 00 00 
  800421ce52:	ff d0                	callq  *%rax
  800421ce54:	48 89 da             	mov    %rbx,%rdx
  800421ce57:	48 89 c6             	mov    %rax,%rsi
  800421ce5a:	48 bf 08 26 22 04 80 	movabs $0x8004222608,%rdi
  800421ce61:	00 00 00 
  800421ce64:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ce69:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421ce70:	00 00 00 
  800421ce73:	ff d1                	callq  *%rcx
  800421ce75:	c7 85 00 ff ff ff 0c 	movl   $0xc0c,-0x100(%rbp)
  800421ce7c:	0c 00 00 
  800421ce7f:	8b 85 00 ff ff ff    	mov    -0x100(%rbp),%eax
  800421ce85:	89 c7                	mov    %eax,%edi
  800421ce87:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421ce8e:	00 00 00 
  800421ce91:	ff d0                	callq  *%rax
			vmcs_readl(VMCS_HOST_RIP), vmcs_readl(VMCS_HOST_RSP));
	cprintf("CS=%04x SS=%04x DS=%04x ES=%04x FS=%04x GS=%04x TR=%04x\n",
  800421ce93:	44 0f b7 f0          	movzwl %ax,%r14d
  800421ce97:	c7 85 fc fe ff ff 0a 	movl   $0xc0a,-0x104(%rbp)
  800421ce9e:	0c 00 00 
  800421cea1:	8b 85 fc fe ff ff    	mov    -0x104(%rbp),%eax
  800421cea7:	89 c7                	mov    %eax,%edi
  800421cea9:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421ceb0:	00 00 00 
  800421ceb3:	ff d0                	callq  *%rax
  800421ceb5:	44 0f b7 e8          	movzwl %ax,%r13d
  800421ceb9:	c7 85 f8 fe ff ff 08 	movl   $0xc08,-0x108(%rbp)
  800421cec0:	0c 00 00 
  800421cec3:	8b 85 f8 fe ff ff    	mov    -0x108(%rbp),%eax
  800421cec9:	89 c7                	mov    %eax,%edi
  800421cecb:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421ced2:	00 00 00 
  800421ced5:	ff d0                	callq  *%rax
  800421ced7:	0f b7 c0             	movzwl %ax,%eax
  800421ceda:	89 85 ac fe ff ff    	mov    %eax,-0x154(%rbp)
  800421cee0:	c7 85 f4 fe ff ff 00 	movl   $0xc00,-0x10c(%rbp)
  800421cee7:	0c 00 00 
  800421ceea:	8b 85 f4 fe ff ff    	mov    -0x10c(%rbp),%eax
  800421cef0:	89 c7                	mov    %eax,%edi
  800421cef2:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cef9:	00 00 00 
  800421cefc:	ff d0                	callq  *%rax
  800421cefe:	44 0f b7 f8          	movzwl %ax,%r15d
  800421cf02:	c7 85 f0 fe ff ff 06 	movl   $0xc06,-0x110(%rbp)
  800421cf09:	0c 00 00 
  800421cf0c:	8b 85 f0 fe ff ff    	mov    -0x110(%rbp),%eax
  800421cf12:	89 c7                	mov    %eax,%edi
  800421cf14:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cf1b:	00 00 00 
  800421cf1e:	ff d0                	callq  *%rax
  800421cf20:	44 0f b7 e0          	movzwl %ax,%r12d
  800421cf24:	c7 85 ec fe ff ff 04 	movl   $0xc04,-0x114(%rbp)
  800421cf2b:	0c 00 00 
  800421cf2e:	8b 85 ec fe ff ff    	mov    -0x114(%rbp),%eax
  800421cf34:	89 c7                	mov    %eax,%edi
  800421cf36:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cf3d:	00 00 00 
  800421cf40:	ff d0                	callq  *%rax
  800421cf42:	0f b7 d8             	movzwl %ax,%ebx
  800421cf45:	c7 85 e8 fe ff ff 02 	movl   $0xc02,-0x118(%rbp)
  800421cf4c:	0c 00 00 
  800421cf4f:	8b 85 e8 fe ff ff    	mov    -0x118(%rbp),%eax
  800421cf55:	89 c7                	mov    %eax,%edi
  800421cf57:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cf5e:	00 00 00 
  800421cf61:	ff d0                	callq  *%rax
  800421cf63:	0f b7 c0             	movzwl %ax,%eax
  800421cf66:	41 56                	push   %r14
  800421cf68:	41 55                	push   %r13
  800421cf6a:	44 8b 8d ac fe ff ff 	mov    -0x154(%rbp),%r9d
  800421cf71:	45 89 f8             	mov    %r15d,%r8d
  800421cf74:	44 89 e1             	mov    %r12d,%ecx
  800421cf77:	89 da                	mov    %ebx,%edx
  800421cf79:	89 c6                	mov    %eax,%esi
  800421cf7b:	48 bf 28 26 22 04 80 	movabs $0x8004222628,%rdi
  800421cf82:	00 00 00 
  800421cf85:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cf8a:	49 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%r10
  800421cf91:	00 00 00 
  800421cf94:	41 ff d2             	callq  *%r10
  800421cf97:	48 83 c4 10          	add    $0x10,%rsp
			vmcs_read16(VMCS_16BIT_HOST_CS_SELECTOR), vmcs_read16(VMCS_16BIT_HOST_SS_SELECTOR),
			vmcs_read16(VMCS_16BIT_HOST_DS_SELECTOR), vmcs_read16(VMCS_16BIT_HOST_ES_SELECTOR),
			vmcs_read16(VMCS_16BIT_HOST_FS_SELECTOR), vmcs_read16(VMCS_16BIT_HOST_GS_SELECTOR),
			vmcs_read16(VMCS_16BIT_HOST_TR_SELECTOR));
	cprintf("FSBase=%016lx GSBase=%016lx TRBase=%016lx\n",
  800421cf9b:	bf 0a 6c 00 00       	mov    $0x6c0a,%edi
  800421cfa0:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cfa7:	00 00 00 
  800421cfaa:	ff d0                	callq  *%rax
  800421cfac:	49 89 c4             	mov    %rax,%r12
  800421cfaf:	bf 08 6c 00 00       	mov    $0x6c08,%edi
  800421cfb4:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cfbb:	00 00 00 
  800421cfbe:	ff d0                	callq  *%rax
  800421cfc0:	48 89 c3             	mov    %rax,%rbx
  800421cfc3:	bf 06 6c 00 00       	mov    $0x6c06,%edi
  800421cfc8:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421cfcf:	00 00 00 
  800421cfd2:	ff d0                	callq  *%rax
  800421cfd4:	4c 89 e1             	mov    %r12,%rcx
  800421cfd7:	48 89 da             	mov    %rbx,%rdx
  800421cfda:	48 89 c6             	mov    %rax,%rsi
  800421cfdd:	48 bf 68 26 22 04 80 	movabs $0x8004222668,%rdi
  800421cfe4:	00 00 00 
  800421cfe7:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cfec:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421cff3:	00 00 00 
  800421cff6:	41 ff d0             	callq  *%r8
			vmcs_readl(VMCS_HOST_FS_BASE), vmcs_readl(VMCS_HOST_GS_BASE),
			vmcs_readl(VMCS_HOST_TR_BASE));
	cprintf("GDTBase=%016lx IDTBase=%016lx\n",
  800421cff9:	bf 0e 6c 00 00       	mov    $0x6c0e,%edi
  800421cffe:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d005:	00 00 00 
  800421d008:	ff d0                	callq  *%rax
  800421d00a:	48 89 c3             	mov    %rax,%rbx
  800421d00d:	bf 0c 6c 00 00       	mov    $0x6c0c,%edi
  800421d012:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d019:	00 00 00 
  800421d01c:	ff d0                	callq  *%rax
  800421d01e:	48 89 da             	mov    %rbx,%rdx
  800421d021:	48 89 c6             	mov    %rax,%rsi
  800421d024:	48 bf 98 26 22 04 80 	movabs $0x8004222698,%rdi
  800421d02b:	00 00 00 
  800421d02e:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d033:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421d03a:	00 00 00 
  800421d03d:	ff d1                	callq  *%rcx
			vmcs_readl(VMCS_HOST_GDTR_BASE), vmcs_readl(VMCS_HOST_IDTR_BASE));
	cprintf("CR0=%016lx CR3=%016lx CR4=%016lx\n",
  800421d03f:	bf 04 6c 00 00       	mov    $0x6c04,%edi
  800421d044:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d04b:	00 00 00 
  800421d04e:	ff d0                	callq  *%rax
  800421d050:	49 89 c4             	mov    %rax,%r12
  800421d053:	bf 02 6c 00 00       	mov    $0x6c02,%edi
  800421d058:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d05f:	00 00 00 
  800421d062:	ff d0                	callq  *%rax
  800421d064:	48 89 c3             	mov    %rax,%rbx
  800421d067:	bf 00 6c 00 00       	mov    $0x6c00,%edi
  800421d06c:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d073:	00 00 00 
  800421d076:	ff d0                	callq  *%rax
  800421d078:	4c 89 e1             	mov    %r12,%rcx
  800421d07b:	48 89 da             	mov    %rbx,%rdx
  800421d07e:	48 89 c6             	mov    %rax,%rsi
  800421d081:	48 bf b8 26 22 04 80 	movabs $0x80042226b8,%rdi
  800421d088:	00 00 00 
  800421d08b:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d090:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421d097:	00 00 00 
  800421d09a:	41 ff d0             	callq  *%r8
			vmcs_readl(VMCS_HOST_CR0), vmcs_readl(VMCS_HOST_CR3),
			vmcs_readl(VMCS_HOST_CR4));
	cprintf("Sysenter RSP=%016lx CS:RIP=%04x:%016lx\n",
  800421d09d:	bf 12 6c 00 00       	mov    $0x6c12,%edi
  800421d0a2:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d0a9:	00 00 00 
  800421d0ac:	ff d0                	callq  *%rax
  800421d0ae:	49 89 c4             	mov    %rax,%r12
  800421d0b1:	c7 85 08 ff ff ff 00 	movl   $0x4c00,-0xf8(%rbp)
  800421d0b8:	4c 00 00 
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421d0bb:	8b 85 08 ff ff ff    	mov    -0xf8(%rbp),%eax
  800421d0c1:	89 c7                	mov    %eax,%edi
  800421d0c3:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d0ca:	00 00 00 
  800421d0cd:	ff d0                	callq  *%rax
  800421d0cf:	89 c3                	mov    %eax,%ebx
  800421d0d1:	bf 10 6c 00 00       	mov    $0x6c10,%edi
  800421d0d6:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d0dd:	00 00 00 
  800421d0e0:	ff d0                	callq  *%rax
  800421d0e2:	4c 89 e1             	mov    %r12,%rcx
  800421d0e5:	89 da                	mov    %ebx,%edx
  800421d0e7:	48 89 c6             	mov    %rax,%rsi
  800421d0ea:	48 bf d0 24 22 04 80 	movabs $0x80042224d0,%rdi
  800421d0f1:	00 00 00 
  800421d0f4:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d0f9:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421d100:	00 00 00 
  800421d103:	41 ff d0             	callq  *%r8
			vmcs_readl (VMCS_HOST_IA32_SYSENTER_ESP_MSR),
			vmcs_read32(VMCS_32BIT_HOST_IA32_SYSENTER_CS_MSR),
			vmcs_readl (VMCS_HOST_IA32_SYSENTER_EIP_MSR));
	if (vmexit_ctl & (0x00080000 | 0x00200000))
  800421d106:	8b 45 c0             	mov    -0x40(%rbp),%eax
  800421d109:	25 00 00 28 00       	and    $0x280000,%eax
  800421d10e:	85 c0                	test   %eax,%eax
  800421d110:	74 60                	je     800421d172 <vmcs_dump_cpu_1+0xfed>
  800421d112:	c7 85 e0 fe ff ff 00 	movl   $0x2c00,-0x120(%rbp)
  800421d119:	2c 00 00 
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421d11c:	8b 85 e0 fe ff ff    	mov    -0x120(%rbp),%eax
  800421d122:	89 c7                	mov    %eax,%edi
  800421d124:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d12b:	00 00 00 
  800421d12e:	ff d0                	callq  *%rax
  800421d130:	48 89 c3             	mov    %rax,%rbx
  800421d133:	c7 85 04 ff ff ff 02 	movl   $0x2c02,-0xfc(%rbp)
  800421d13a:	2c 00 00 
  800421d13d:	8b 85 04 ff ff ff    	mov    -0xfc(%rbp),%eax
  800421d143:	89 c7                	mov    %eax,%edi
  800421d145:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d14c:	00 00 00 
  800421d14f:	ff d0                	callq  *%rax
		cprintf("EFER = 0x%016llx  PAT = 0x%016llx\n",
  800421d151:	48 89 da             	mov    %rbx,%rdx
  800421d154:	48 89 c6             	mov    %rax,%rsi
  800421d157:	48 bf e0 26 22 04 80 	movabs $0x80042226e0,%rdi
  800421d15e:	00 00 00 
  800421d161:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d166:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421d16d:	00 00 00 
  800421d170:	ff d1                	callq  *%rcx
				vmcs_read64(VMCS_64BIT_HOST_IA32_EFER),
				vmcs_read64(VMCS_64BIT_HOST_IA32_PAT));

	cprintf("\n*** Control State ***\n");
  800421d172:	48 bf 03 27 22 04 80 	movabs $0x8004222703,%rdi
  800421d179:	00 00 00 
  800421d17c:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d181:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421d188:	00 00 00 
  800421d18b:	ff d2                	callq  *%rdx
	cprintf("PinBased=%08x CPUBased=%08x SecondaryExec=%08x\n",
  800421d18d:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  800421d190:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800421d193:	8b 45 b0             	mov    -0x50(%rbp),%eax
  800421d196:	89 c6                	mov    %eax,%esi
  800421d198:	48 bf 20 27 22 04 80 	movabs $0x8004222720,%rdi
  800421d19f:	00 00 00 
  800421d1a2:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d1a7:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421d1ae:	00 00 00 
  800421d1b1:	41 ff d0             	callq  *%r8
			pin_based_exec_ctrl, cpu_based_exec_ctrl, secondary_exec_control);
	cprintf("EntryControls=%08x ExitControls=%08x\n", vmentry_ctl, vmexit_ctl);
  800421d1b4:	8b 55 c0             	mov    -0x40(%rbp),%edx
  800421d1b7:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421d1ba:	89 c6                	mov    %eax,%esi
  800421d1bc:	48 bf 50 27 22 04 80 	movabs $0x8004222750,%rdi
  800421d1c3:	00 00 00 
  800421d1c6:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d1cb:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421d1d2:	00 00 00 
  800421d1d5:	ff d1                	callq  *%rcx
  800421d1d7:	c7 85 dc fe ff ff 08 	movl   $0x4008,-0x124(%rbp)
  800421d1de:	40 00 00 
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421d1e1:	8b 85 dc fe ff ff    	mov    -0x124(%rbp),%eax
  800421d1e7:	89 c7                	mov    %eax,%edi
  800421d1e9:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d1f0:	00 00 00 
  800421d1f3:	ff d0                	callq  *%rax
  800421d1f5:	41 89 c4             	mov    %eax,%r12d
  800421d1f8:	c7 85 d8 fe ff ff 06 	movl   $0x4006,-0x128(%rbp)
  800421d1ff:	40 00 00 
  800421d202:	8b 85 d8 fe ff ff    	mov    -0x128(%rbp),%eax
  800421d208:	89 c7                	mov    %eax,%edi
  800421d20a:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d211:	00 00 00 
  800421d214:	ff d0                	callq  *%rax
  800421d216:	89 c3                	mov    %eax,%ebx
  800421d218:	c7 85 d4 fe ff ff 04 	movl   $0x4004,-0x12c(%rbp)
  800421d21f:	40 00 00 
  800421d222:	8b 85 d4 fe ff ff    	mov    -0x12c(%rbp),%eax
  800421d228:	89 c7                	mov    %eax,%edi
  800421d22a:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d231:	00 00 00 
  800421d234:	ff d0                	callq  *%rax
	cprintf("ExceptionBitmap=%08x PFECmask=%08x PFECmatch=%08x\n",
  800421d236:	44 89 e1             	mov    %r12d,%ecx
  800421d239:	89 da                	mov    %ebx,%edx
  800421d23b:	89 c6                	mov    %eax,%esi
  800421d23d:	48 bf 78 27 22 04 80 	movabs $0x8004222778,%rdi
  800421d244:	00 00 00 
  800421d247:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d24c:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421d253:	00 00 00 
  800421d256:	41 ff d0             	callq  *%r8
  800421d259:	c7 85 d0 fe ff ff 1a 	movl   $0x401a,-0x130(%rbp)
  800421d260:	40 00 00 
  800421d263:	8b 85 d0 fe ff ff    	mov    -0x130(%rbp),%eax
  800421d269:	89 c7                	mov    %eax,%edi
  800421d26b:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d272:	00 00 00 
  800421d275:	ff d0                	callq  *%rax
  800421d277:	41 89 c4             	mov    %eax,%r12d
  800421d27a:	c7 85 cc fe ff ff 18 	movl   $0x4018,-0x134(%rbp)
  800421d281:	40 00 00 
  800421d284:	8b 85 cc fe ff ff    	mov    -0x134(%rbp),%eax
  800421d28a:	89 c7                	mov    %eax,%edi
  800421d28c:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d293:	00 00 00 
  800421d296:	ff d0                	callq  *%rax
  800421d298:	89 c3                	mov    %eax,%ebx
  800421d29a:	c7 85 c8 fe ff ff 16 	movl   $0x4016,-0x138(%rbp)
  800421d2a1:	40 00 00 
  800421d2a4:	8b 85 c8 fe ff ff    	mov    -0x138(%rbp),%eax
  800421d2aa:	89 c7                	mov    %eax,%edi
  800421d2ac:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d2b3:	00 00 00 
  800421d2b6:	ff d0                	callq  *%rax
			vmcs_read32(VMCS_32BIT_CONTROL_EXCEPTION_BITMAP),
			vmcs_read32(VMCS_32BIT_CONTROL_PAGE_FAULT_ERR_CODE_MASK),
			vmcs_read32(VMCS_32BIT_CONTROL_PAGE_FAULT_ERR_CODE_MATCH));
	cprintf("VMEntry: intr_info=%08x errcode=%08x ilen=%08x\n",
  800421d2b8:	44 89 e1             	mov    %r12d,%ecx
  800421d2bb:	89 da                	mov    %ebx,%edx
  800421d2bd:	89 c6                	mov    %eax,%esi
  800421d2bf:	48 bf b0 27 22 04 80 	movabs $0x80042227b0,%rdi
  800421d2c6:	00 00 00 
  800421d2c9:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d2ce:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421d2d5:	00 00 00 
  800421d2d8:	41 ff d0             	callq  *%r8
  800421d2db:	c7 85 c4 fe ff ff 0c 	movl   $0x440c,-0x13c(%rbp)
  800421d2e2:	44 00 00 
  800421d2e5:	8b 85 c4 fe ff ff    	mov    -0x13c(%rbp),%eax
  800421d2eb:	89 c7                	mov    %eax,%edi
  800421d2ed:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d2f4:	00 00 00 
  800421d2f7:	ff d0                	callq  *%rax
  800421d2f9:	41 89 c4             	mov    %eax,%r12d
  800421d2fc:	c7 85 c0 fe ff ff 06 	movl   $0x4406,-0x140(%rbp)
  800421d303:	44 00 00 
  800421d306:	8b 85 c0 fe ff ff    	mov    -0x140(%rbp),%eax
  800421d30c:	89 c7                	mov    %eax,%edi
  800421d30e:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d315:	00 00 00 
  800421d318:	ff d0                	callq  *%rax
  800421d31a:	89 c3                	mov    %eax,%ebx
  800421d31c:	c7 85 bc fe ff ff 04 	movl   $0x4404,-0x144(%rbp)
  800421d323:	44 00 00 
  800421d326:	8b 85 bc fe ff ff    	mov    -0x144(%rbp),%eax
  800421d32c:	89 c7                	mov    %eax,%edi
  800421d32e:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d335:	00 00 00 
  800421d338:	ff d0                	callq  *%rax
			vmcs_read32(VMCS_32BIT_CONTROL_VMENTRY_INTERRUPTION_INFO),
			vmcs_read32(VMCS_32BIT_CONTROL_VMENTRY_EXCEPTION_ERR_CODE),
			vmcs_read32(VMCS_32BIT_CONTROL_VMENTRY_INSTRUCTION_LENGTH));
	cprintf("VMExit: intr_info=%08x errcode=%08x ilen=%08x\n",
  800421d33a:	44 89 e1             	mov    %r12d,%ecx
  800421d33d:	89 da                	mov    %ebx,%edx
  800421d33f:	89 c6                	mov    %eax,%esi
  800421d341:	48 bf e0 27 22 04 80 	movabs $0x80042227e0,%rdi
  800421d348:	00 00 00 
  800421d34b:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d350:	49 b8 eb 9c 20 04 80 	movabs $0x8004209ceb,%r8
  800421d357:	00 00 00 
  800421d35a:	41 ff d0             	callq  *%r8
			vmcs_read32(VMCS_32BIT_VMEXIT_INTERRUPTION_INFO),
			vmcs_read32(VMCS_32BIT_VMEXIT_INTERRUPTION_ERR_CODE),
			vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH));
	cprintf("        reason=%08x qualification=%016lx\n",
  800421d35d:	bf 00 64 00 00       	mov    $0x6400,%edi
  800421d362:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d369:	00 00 00 
  800421d36c:	ff d0                	callq  *%rax
  800421d36e:	48 89 c3             	mov    %rax,%rbx
  800421d371:	c7 85 e4 fe ff ff 02 	movl   $0x4402,-0x11c(%rbp)
  800421d378:	44 00 00 
  800421d37b:	8b 85 e4 fe ff ff    	mov    -0x11c(%rbp),%eax
  800421d381:	89 c7                	mov    %eax,%edi
  800421d383:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d38a:	00 00 00 
  800421d38d:	ff d0                	callq  *%rax
  800421d38f:	48 89 da             	mov    %rbx,%rdx
  800421d392:	89 c6                	mov    %eax,%esi
  800421d394:	48 bf 10 28 22 04 80 	movabs $0x8004222810,%rdi
  800421d39b:	00 00 00 
  800421d39e:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d3a3:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421d3aa:	00 00 00 
  800421d3ad:	ff d1                	callq  *%rcx
			vmcs_read32(VMCS_32BIT_VMEXIT_REASON), vmcs_readl(VMCS_VMEXIT_QUALIFICATION));
}
  800421d3af:	90                   	nop
  800421d3b0:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  800421d3b4:	5b                   	pop    %rbx
  800421d3b5:	41 5c                	pop    %r12
  800421d3b7:	41 5d                	pop    %r13
  800421d3b9:	41 5e                	pop    %r14
  800421d3bb:	41 5f                	pop    %r15
  800421d3bd:	5d                   	pop    %rbp
  800421d3be:	c3                   	retq   

000000800421d3bf <vmexit>:


void vmexit() {
  800421d3bf:	55                   	push   %rbp
  800421d3c0:	48 89 e5             	mov    %rsp,%rbp
  800421d3c3:	41 54                	push   %r12
  800421d3c5:	53                   	push   %rbx
  800421d3c6:	48 83 ec 10          	sub    $0x10,%rsp
	int exit_reason = -1;
  800421d3ca:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%rbp)
	bool exit_handled = false;
  800421d3d1:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  800421d3d5:	c7 45 e0 02 44 00 00 	movl   $0x4402,-0x20(%rbp)
  800421d3dc:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421d3df:	89 c7                	mov    %eax,%edi
  800421d3e1:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d3e8:	00 00 00 
  800421d3eb:	ff d0                	callq  *%rax
	static uint32_t host_vector;
	
	// Get the reason for VMEXIT from the VMCS.
	exit_reason = vmcs_read32(VMCS_32BIT_VMEXIT_REASON);
  800421d3ed:	89 45 e8             	mov    %eax,-0x18(%rbp)
	cprintf( "---VMEXIT Reason: %x---\n", exit_reason ); 
  800421d3f0:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421d3f3:	89 c6                	mov    %eax,%esi
  800421d3f5:	48 bf 3a 28 22 04 80 	movabs $0x800422283a,%rdi
  800421d3fc:	00 00 00 
  800421d3ff:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d404:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421d40b:	00 00 00 
  800421d40e:	ff d2                	callq  *%rdx

	//print_trapframe(&curenv->env_tf);

	switch(exit_reason & EXIT_REASON_MASK) {
  800421d410:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421d413:	0f b7 c0             	movzwl %ax,%eax
  800421d416:	83 f8 30             	cmp    $0x30,%eax
  800421d419:	0f 87 03 05 00 00    	ja     800421d922 <vmexit+0x563>
  800421d41f:	89 c0                	mov    %eax,%eax
  800421d421:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421d428:	00 
  800421d429:	48 b8 a0 28 22 04 80 	movabs $0x80042228a0,%rax
  800421d430:	00 00 00 
  800421d433:	48 01 d0             	add    %rdx,%rax
  800421d436:	48 8b 00             	mov    (%rax),%rax
  800421d439:	ff e0                	jmpq   *%rax
  800421d43b:	c7 45 e4 04 44 00 00 	movl   $0x4404,-0x1c(%rbp)
  800421d442:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421d445:	89 c7                	mov    %eax,%edi
  800421d447:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421d44e:	00 00 00 
  800421d451:	ff d0                	callq  *%rax
  800421d453:	89 c2                	mov    %eax,%edx
    	case EXIT_REASON_EXTERNAL_INT:
    		host_vector = vmcs_read32(VMCS_32BIT_VMEXIT_INTERRUPTION_INFO);
  800421d455:	48 b8 c4 f5 6d 04 80 	movabs $0x80046df5c4,%rax
  800421d45c:	00 00 00 
  800421d45f:	89 10                	mov    %edx,(%rax)
    		exit_handled = handle_interrupts(&curenv->env_tf, &curenv->env_vmxinfo, host_vector);
  800421d461:	48 b8 c4 f5 6d 04 80 	movabs $0x80046df5c4,%rax
  800421d468:	00 00 00 
  800421d46b:	8b 18                	mov    (%rax),%ebx
  800421d46d:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d474:	00 00 00 
  800421d477:	ff d0                	callq  *%rax
  800421d479:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d480:	00 00 00 
  800421d483:	48 98                	cltq   
  800421d485:	48 c1 e0 03          	shl    $0x3,%rax
  800421d489:	48 89 c1             	mov    %rax,%rcx
  800421d48c:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d490:	48 01 c8             	add    %rcx,%rax
  800421d493:	48 01 d0             	add    %rdx,%rax
  800421d496:	48 83 c0 08          	add    $0x8,%rax
  800421d49a:	48 8b 00             	mov    (%rax),%rax
  800421d49d:	4c 8d a0 20 01 00 00 	lea    0x120(%rax),%r12
  800421d4a4:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d4ab:	00 00 00 
  800421d4ae:	ff d0                	callq  *%rax
  800421d4b0:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d4b7:	00 00 00 
  800421d4ba:	48 98                	cltq   
  800421d4bc:	48 c1 e0 03          	shl    $0x3,%rax
  800421d4c0:	48 89 c1             	mov    %rax,%rcx
  800421d4c3:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d4c7:	48 01 c8             	add    %rcx,%rax
  800421d4ca:	48 01 d0             	add    %rdx,%rax
  800421d4cd:	48 83 c0 08          	add    $0x8,%rax
  800421d4d1:	48 8b 00             	mov    (%rax),%rax
  800421d4d4:	89 da                	mov    %ebx,%edx
  800421d4d6:	4c 89 e6             	mov    %r12,%rsi
  800421d4d9:	48 89 c7             	mov    %rax,%rdi
  800421d4dc:	48 b8 ea e3 21 04 80 	movabs $0x800421e3ea,%rax
  800421d4e3:	00 00 00 
  800421d4e6:	ff d0                	callq  *%rax
  800421d4e8:	88 45 ef             	mov    %al,-0x11(%rbp)
    		break;
  800421d4eb:	e9 32 04 00 00       	jmpq   800421d922 <vmexit+0x563>
    	case EXIT_REASON_INTERRUPT_WINDOW:
    		exit_handled = handle_interrupt_window(&curenv->env_tf, &curenv->env_vmxinfo, host_vector);
  800421d4f0:	48 b8 c4 f5 6d 04 80 	movabs $0x80046df5c4,%rax
  800421d4f7:	00 00 00 
  800421d4fa:	8b 18                	mov    (%rax),%ebx
  800421d4fc:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d503:	00 00 00 
  800421d506:	ff d0                	callq  *%rax
  800421d508:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d50f:	00 00 00 
  800421d512:	48 98                	cltq   
  800421d514:	48 c1 e0 03          	shl    $0x3,%rax
  800421d518:	48 89 c1             	mov    %rax,%rcx
  800421d51b:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d51f:	48 01 c8             	add    %rcx,%rax
  800421d522:	48 01 d0             	add    %rdx,%rax
  800421d525:	48 83 c0 08          	add    $0x8,%rax
  800421d529:	48 8b 00             	mov    (%rax),%rax
  800421d52c:	4c 8d a0 20 01 00 00 	lea    0x120(%rax),%r12
  800421d533:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d53a:	00 00 00 
  800421d53d:	ff d0                	callq  *%rax
  800421d53f:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d546:	00 00 00 
  800421d549:	48 98                	cltq   
  800421d54b:	48 c1 e0 03          	shl    $0x3,%rax
  800421d54f:	48 89 c1             	mov    %rax,%rcx
  800421d552:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d556:	48 01 c8             	add    %rcx,%rax
  800421d559:	48 01 d0             	add    %rdx,%rax
  800421d55c:	48 83 c0 08          	add    $0x8,%rax
  800421d560:	48 8b 00             	mov    (%rax),%rax
  800421d563:	89 da                	mov    %ebx,%edx
  800421d565:	4c 89 e6             	mov    %r12,%rsi
  800421d568:	48 89 c7             	mov    %rax,%rdi
  800421d56b:	48 b8 69 e3 21 04 80 	movabs $0x800421e369,%rax
  800421d572:	00 00 00 
  800421d575:	ff d0                	callq  *%rax
  800421d577:	88 45 ef             	mov    %al,-0x11(%rbp)
    		break;
  800421d57a:	e9 a3 03 00 00       	jmpq   800421d922 <vmexit+0x563>
        case EXIT_REASON_RDMSR:
		exit_handled = handle_rdmsr(&curenv->env_tf, &curenv->env_vmxinfo);
  800421d57f:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d586:	00 00 00 
  800421d589:	ff d0                	callq  *%rax
  800421d58b:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d592:	00 00 00 
  800421d595:	48 98                	cltq   
  800421d597:	48 c1 e0 03          	shl    $0x3,%rax
  800421d59b:	48 89 c1             	mov    %rax,%rcx
  800421d59e:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d5a2:	48 01 c8             	add    %rcx,%rax
  800421d5a5:	48 01 d0             	add    %rdx,%rax
  800421d5a8:	48 83 c0 08          	add    $0x8,%rax
  800421d5ac:	48 8b 00             	mov    (%rax),%rax
  800421d5af:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421d5b6:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d5bd:	00 00 00 
  800421d5c0:	ff d0                	callq  *%rax
  800421d5c2:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d5c9:	00 00 00 
  800421d5cc:	48 98                	cltq   
  800421d5ce:	48 c1 e0 03          	shl    $0x3,%rax
  800421d5d2:	48 89 c1             	mov    %rax,%rcx
  800421d5d5:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d5d9:	48 01 c8             	add    %rcx,%rax
  800421d5dc:	48 01 d0             	add    %rdx,%rax
  800421d5df:	48 83 c0 08          	add    $0x8,%rax
  800421d5e3:	48 8b 00             	mov    (%rax),%rax
  800421d5e6:	48 89 de             	mov    %rbx,%rsi
  800421d5e9:	48 89 c7             	mov    %rax,%rdi
  800421d5ec:	48 b8 97 e4 21 04 80 	movabs $0x800421e497,%rax
  800421d5f3:	00 00 00 
  800421d5f6:	ff d0                	callq  *%rax
  800421d5f8:	88 45 ef             	mov    %al,-0x11(%rbp)
		break;
  800421d5fb:	e9 22 03 00 00       	jmpq   800421d922 <vmexit+0x563>
        case EXIT_REASON_WRMSR:
		exit_handled = handle_wrmsr(&curenv->env_tf, &curenv->env_vmxinfo);
  800421d600:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d607:	00 00 00 
  800421d60a:	ff d0                	callq  *%rax
  800421d60c:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d613:	00 00 00 
  800421d616:	48 98                	cltq   
  800421d618:	48 c1 e0 03          	shl    $0x3,%rax
  800421d61c:	48 89 c1             	mov    %rax,%rcx
  800421d61f:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d623:	48 01 c8             	add    %rcx,%rax
  800421d626:	48 01 d0             	add    %rdx,%rax
  800421d629:	48 83 c0 08          	add    $0x8,%rax
  800421d62d:	48 8b 00             	mov    (%rax),%rax
  800421d630:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421d637:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d63e:	00 00 00 
  800421d641:	ff d0                	callq  *%rax
  800421d643:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d64a:	00 00 00 
  800421d64d:	48 98                	cltq   
  800421d64f:	48 c1 e0 03          	shl    $0x3,%rax
  800421d653:	48 89 c1             	mov    %rax,%rcx
  800421d656:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d65a:	48 01 c8             	add    %rcx,%rax
  800421d65d:	48 01 d0             	add    %rdx,%rax
  800421d660:	48 83 c0 08          	add    $0x8,%rax
  800421d664:	48 8b 00             	mov    (%rax),%rax
  800421d667:	48 89 de             	mov    %rbx,%rsi
  800421d66a:	48 89 c7             	mov    %rax,%rdi
  800421d66d:	48 b8 a6 e5 21 04 80 	movabs $0x800421e5a6,%rax
  800421d674:	00 00 00 
  800421d677:	ff d0                	callq  *%rax
  800421d679:	88 45 ef             	mov    %al,-0x11(%rbp)
		break;
  800421d67c:	e9 a1 02 00 00       	jmpq   800421d922 <vmexit+0x563>
        case EXIT_REASON_EPT_VIOLATION:
		exit_handled = handle_eptviolation(curenv->env_pml4e, &curenv->env_vmxinfo);
  800421d681:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d688:	00 00 00 
  800421d68b:	ff d0                	callq  *%rax
  800421d68d:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d694:	00 00 00 
  800421d697:	48 98                	cltq   
  800421d699:	48 c1 e0 03          	shl    $0x3,%rax
  800421d69d:	48 89 c1             	mov    %rax,%rcx
  800421d6a0:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d6a4:	48 01 c8             	add    %rcx,%rax
  800421d6a7:	48 01 d0             	add    %rdx,%rax
  800421d6aa:	48 83 c0 08          	add    $0x8,%rax
  800421d6ae:	48 8b 00             	mov    (%rax),%rax
  800421d6b1:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421d6b8:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d6bf:	00 00 00 
  800421d6c2:	ff d0                	callq  *%rax
  800421d6c4:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d6cb:	00 00 00 
  800421d6ce:	48 98                	cltq   
  800421d6d0:	48 c1 e0 03          	shl    $0x3,%rax
  800421d6d4:	48 89 c1             	mov    %rax,%rcx
  800421d6d7:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d6db:	48 01 c8             	add    %rcx,%rax
  800421d6de:	48 01 d0             	add    %rdx,%rax
  800421d6e1:	48 83 c0 08          	add    $0x8,%rax
  800421d6e5:	48 8b 00             	mov    (%rax),%rax
  800421d6e8:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800421d6ef:	48 89 de             	mov    %rbx,%rsi
  800421d6f2:	48 89 c7             	mov    %rax,%rdi
  800421d6f5:	48 b8 10 e7 21 04 80 	movabs $0x800421e710,%rax
  800421d6fc:	00 00 00 
  800421d6ff:	ff d0                	callq  *%rax
  800421d701:	88 45 ef             	mov    %al,-0x11(%rbp)
		break;
  800421d704:	e9 19 02 00 00       	jmpq   800421d922 <vmexit+0x563>
        case EXIT_REASON_IO_INSTRUCTION:
		exit_handled = handle_ioinstr(&curenv->env_tf, &curenv->env_vmxinfo);
  800421d709:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d710:	00 00 00 
  800421d713:	ff d0                	callq  *%rax
  800421d715:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d71c:	00 00 00 
  800421d71f:	48 98                	cltq   
  800421d721:	48 c1 e0 03          	shl    $0x3,%rax
  800421d725:	48 89 c1             	mov    %rax,%rcx
  800421d728:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d72c:	48 01 c8             	add    %rcx,%rax
  800421d72f:	48 01 d0             	add    %rdx,%rax
  800421d732:	48 83 c0 08          	add    $0x8,%rax
  800421d736:	48 8b 00             	mov    (%rax),%rax
  800421d739:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421d740:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d747:	00 00 00 
  800421d74a:	ff d0                	callq  *%rax
  800421d74c:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d753:	00 00 00 
  800421d756:	48 98                	cltq   
  800421d758:	48 c1 e0 03          	shl    $0x3,%rax
  800421d75c:	48 89 c1             	mov    %rax,%rcx
  800421d75f:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d763:	48 01 c8             	add    %rcx,%rax
  800421d766:	48 01 d0             	add    %rdx,%rax
  800421d769:	48 83 c0 08          	add    $0x8,%rax
  800421d76d:	48 8b 00             	mov    (%rax),%rax
  800421d770:	48 89 de             	mov    %rbx,%rsi
  800421d773:	48 89 c7             	mov    %rax,%rdi
  800421d776:	48 b8 02 e9 21 04 80 	movabs $0x800421e902,%rax
  800421d77d:	00 00 00 
  800421d780:	ff d0                	callq  *%rax
  800421d782:	88 45 ef             	mov    %al,-0x11(%rbp)
		break;
  800421d785:	e9 98 01 00 00       	jmpq   800421d922 <vmexit+0x563>
        case EXIT_REASON_CPUID:
		exit_handled = handle_cpuid(&curenv->env_tf, &curenv->env_vmxinfo);
  800421d78a:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d791:	00 00 00 
  800421d794:	ff d0                	callq  *%rax
  800421d796:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d79d:	00 00 00 
  800421d7a0:	48 98                	cltq   
  800421d7a2:	48 c1 e0 03          	shl    $0x3,%rax
  800421d7a6:	48 89 c1             	mov    %rax,%rcx
  800421d7a9:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d7ad:	48 01 c8             	add    %rcx,%rax
  800421d7b0:	48 01 d0             	add    %rdx,%rax
  800421d7b3:	48 83 c0 08          	add    $0x8,%rax
  800421d7b7:	48 8b 00             	mov    (%rax),%rax
  800421d7ba:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421d7c1:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d7c8:	00 00 00 
  800421d7cb:	ff d0                	callq  *%rax
  800421d7cd:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d7d4:	00 00 00 
  800421d7d7:	48 98                	cltq   
  800421d7d9:	48 c1 e0 03          	shl    $0x3,%rax
  800421d7dd:	48 89 c1             	mov    %rax,%rcx
  800421d7e0:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d7e4:	48 01 c8             	add    %rcx,%rax
  800421d7e7:	48 01 d0             	add    %rdx,%rax
  800421d7ea:	48 83 c0 08          	add    $0x8,%rax
  800421d7ee:	48 8b 00             	mov    (%rax),%rax
  800421d7f1:	48 89 de             	mov    %rbx,%rsi
  800421d7f4:	48 89 c7             	mov    %rax,%rdi
  800421d7f7:	48 b8 dc ea 21 04 80 	movabs $0x800421eadc,%rax
  800421d7fe:	00 00 00 
  800421d801:	ff d0                	callq  *%rax
  800421d803:	88 45 ef             	mov    %al,-0x11(%rbp)
		break;
  800421d806:	e9 17 01 00 00       	jmpq   800421d922 <vmexit+0x563>
	case EXIT_REASON_VMCALL:
		exit_handled = handle_vmcall(&curenv->env_tf, &curenv->env_vmxinfo,
		curenv->env_pml4e);
  800421d80b:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d812:	00 00 00 
  800421d815:	ff d0                	callq  *%rax
  800421d817:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d81e:	00 00 00 
  800421d821:	48 98                	cltq   
  800421d823:	48 c1 e0 03          	shl    $0x3,%rax
  800421d827:	48 89 c1             	mov    %rax,%rcx
  800421d82a:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d82e:	48 01 c8             	add    %rcx,%rax
  800421d831:	48 01 d0             	add    %rdx,%rax
  800421d834:	48 83 c0 08          	add    $0x8,%rax
  800421d838:	48 8b 00             	mov    (%rax),%rax
  800421d83b:	48 8b 98 e0 00 00 00 	mov    0xe0(%rax),%rbx
		break;
        case EXIT_REASON_CPUID:
		exit_handled = handle_cpuid(&curenv->env_tf, &curenv->env_vmxinfo);
		break;
	case EXIT_REASON_VMCALL:
		exit_handled = handle_vmcall(&curenv->env_tf, &curenv->env_vmxinfo,
  800421d842:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d849:	00 00 00 
  800421d84c:	ff d0                	callq  *%rax
  800421d84e:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d855:	00 00 00 
  800421d858:	48 98                	cltq   
  800421d85a:	48 c1 e0 03          	shl    $0x3,%rax
  800421d85e:	48 89 c1             	mov    %rax,%rcx
  800421d861:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d865:	48 01 c8             	add    %rcx,%rax
  800421d868:	48 01 d0             	add    %rdx,%rax
  800421d86b:	48 83 c0 08          	add    $0x8,%rax
  800421d86f:	48 8b 00             	mov    (%rax),%rax
  800421d872:	4c 8d a0 20 01 00 00 	lea    0x120(%rax),%r12
  800421d879:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d880:	00 00 00 
  800421d883:	ff d0                	callq  *%rax
  800421d885:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d88c:	00 00 00 
  800421d88f:	48 98                	cltq   
  800421d891:	48 c1 e0 03          	shl    $0x3,%rax
  800421d895:	48 89 c1             	mov    %rax,%rcx
  800421d898:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d89c:	48 01 c8             	add    %rcx,%rax
  800421d89f:	48 01 d0             	add    %rdx,%rax
  800421d8a2:	48 83 c0 08          	add    $0x8,%rax
  800421d8a6:	48 8b 00             	mov    (%rax),%rax
  800421d8a9:	48 89 da             	mov    %rbx,%rdx
  800421d8ac:	4c 89 e6             	mov    %r12,%rsi
  800421d8af:	48 89 c7             	mov    %rax,%rdi
  800421d8b2:	48 b8 a9 eb 21 04 80 	movabs $0x800421eba9,%rax
  800421d8b9:	00 00 00 
  800421d8bc:	ff d0                	callq  *%rax
  800421d8be:	88 45 ef             	mov    %al,-0x11(%rbp)
		curenv->env_pml4e);
		break;
  800421d8c1:	eb 5f                	jmp    800421d922 <vmexit+0x563>
	case EXIT_REASON_HLT:
		cprintf("\nHLT in guest, exiting guest.\n");
  800421d8c3:	48 bf 58 28 22 04 80 	movabs $0x8004222858,%rdi
  800421d8ca:	00 00 00 
  800421d8cd:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d8d2:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421d8d9:	00 00 00 
  800421d8dc:	ff d2                	callq  *%rdx
		env_destroy(curenv);
  800421d8de:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d8e5:	00 00 00 
  800421d8e8:	ff d0                	callq  *%rax
  800421d8ea:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d8f1:	00 00 00 
  800421d8f4:	48 98                	cltq   
  800421d8f6:	48 c1 e0 03          	shl    $0x3,%rax
  800421d8fa:	48 89 c1             	mov    %rax,%rcx
  800421d8fd:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d901:	48 01 c8             	add    %rcx,%rax
  800421d904:	48 01 d0             	add    %rdx,%rax
  800421d907:	48 83 c0 08          	add    $0x8,%rax
  800421d90b:	48 8b 00             	mov    (%rax),%rax
  800421d90e:	48 89 c7             	mov    %rax,%rdi
  800421d911:	48 b8 81 95 20 04 80 	movabs $0x8004209581,%rax
  800421d918:	00 00 00 
  800421d91b:	ff d0                	callq  *%rax
		exit_handled = true;
  800421d91d:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
		break;
  800421d921:	90                   	nop
	}
	if(!exit_handled) {
  800421d922:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800421d926:	83 f0 01             	xor    $0x1,%eax
  800421d929:	84 c0                	test   %al,%al
  800421d92b:	74 6b                	je     800421d998 <vmexit+0x5d9>
		cprintf( "Unhandled VMEXIT, aborting guest.\n" );
  800421d92d:	48 bf 78 28 22 04 80 	movabs $0x8004222878,%rdi
  800421d934:	00 00 00 
  800421d937:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d93c:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421d943:	00 00 00 
  800421d946:	ff d2                	callq  *%rdx
		vmcs_dump_cpu();
  800421d948:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d94d:	48 ba 18 bf 21 04 80 	movabs $0x800421bf18,%rdx
  800421d954:	00 00 00 
  800421d957:	ff d2                	callq  *%rdx
		env_destroy(curenv);
  800421d959:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d960:	00 00 00 
  800421d963:	ff d0                	callq  *%rax
  800421d965:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d96c:	00 00 00 
  800421d96f:	48 98                	cltq   
  800421d971:	48 c1 e0 03          	shl    $0x3,%rax
  800421d975:	48 89 c1             	mov    %rax,%rcx
  800421d978:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d97c:	48 01 c8             	add    %rcx,%rax
  800421d97f:	48 01 d0             	add    %rdx,%rax
  800421d982:	48 83 c0 08          	add    $0x8,%rax
  800421d986:	48 8b 00             	mov    (%rax),%rax
  800421d989:	48 89 c7             	mov    %rax,%rdi
  800421d98c:	48 b8 81 95 20 04 80 	movabs $0x8004209581,%rax
  800421d993:	00 00 00 
  800421d996:	ff d0                	callq  *%rax
	}
	sched_yield();
  800421d998:	48 b8 a6 da 20 04 80 	movabs $0x800420daa6,%rax
  800421d99f:	00 00 00 
  800421d9a2:	ff d0                	callq  *%rax

000000800421d9a4 <asm_vmrun>:
}

void asm_vmrun(struct Trapframe *tf) {
  800421d9a4:	55                   	push   %rbp
  800421d9a5:	48 89 e5             	mov    %rsp,%rbp
  800421d9a8:	41 57                	push   %r15
  800421d9aa:	41 56                	push   %r14
  800421d9ac:	41 55                	push   %r13
  800421d9ae:	41 54                	push   %r12
  800421d9b0:	53                   	push   %rbx
  800421d9b1:	48 83 ec 28          	sub    $0x28,%rsp
  800421d9b5:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
	// NOTE: Since we re-use Trapframe structure, tf.tf_err contains the value
	// of cr2 of the guest.
	//cprintf("asm_run %x\n",curenv->env_runs);
	tf->tf_ds = curenv->env_runs;
  800421d9b9:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421d9c0:	00 00 00 
  800421d9c3:	ff d0                	callq  *%rax
  800421d9c5:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421d9cc:	00 00 00 
  800421d9cf:	48 98                	cltq   
  800421d9d1:	48 c1 e0 03          	shl    $0x3,%rax
  800421d9d5:	48 89 c1             	mov    %rax,%rcx
  800421d9d8:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d9dc:	48 01 c8             	add    %rcx,%rax
  800421d9df:	48 01 d0             	add    %rdx,%rax
  800421d9e2:	48 83 c0 08          	add    $0x8,%rax
  800421d9e6:	48 8b 00             	mov    (%rax),%rax
  800421d9e9:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  800421d9ef:	89 c2                	mov    %eax,%edx
  800421d9f1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421d9f5:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
	tf->tf_es = 0;
  800421d9fc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421da00:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)
	unlock_kernel();
  800421da06:	48 b8 8c a3 21 04 80 	movabs $0x800421a38c,%rax
  800421da0d:	00 00 00 
  800421da10:	ff d0                	callq  *%rax
	//vmcs_dump_cpu();
	asm(
  800421da12:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  800421da16:	ba 14 6c 00 00       	mov    $0x6c14,%edx
  800421da1b:	52                   	push   %rdx
  800421da1c:	55                   	push   %rbp
  800421da1d:	51                   	push   %rcx
  800421da1e:	51                   	push   %rcx
  800421da1f:	0f 79 d4             	vmwrite %rsp,%rdx
  800421da22:	48 8b 81 90 00 00 00 	mov    0x90(%rcx),%rax
  800421da29:	0f 20 d2             	mov    %cr2,%rdx
  800421da2c:	66 39 c2             	cmp    %ax,%dx
  800421da2f:	74 03                	je     800421da34 <asm_vmrun+0x90>
  800421da31:	0f 22 d0             	mov    %rax,%cr2
  800421da34:	48 8b 81 80 00 00 00 	mov    0x80(%rcx),%rax
  800421da3b:	48 c7 c2 01 00 00 00 	mov    $0x1,%rdx
  800421da42:	48 39 d0             	cmp    %rdx,%rax
  800421da45:	75 54                	jne    800421da9b <asm_vmrun+0xf7>
  800421da47:	48 89 cc             	mov    %rcx,%rsp
  800421da4a:	4c 8b 3c 24          	mov    (%rsp),%r15
  800421da4e:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  800421da53:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  800421da58:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  800421da5d:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  800421da62:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  800421da67:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  800421da6c:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  800421da71:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  800421da76:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  800421da7b:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  800421da80:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  800421da85:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800421da8a:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  800421da8f:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800421da94:	48 83 c4 78          	add    $0x78,%rsp
  800421da98:	0f 01 c2             	vmlaunch 
  800421da9b:	48 89 cc             	mov    %rcx,%rsp
  800421da9e:	4c 8b 3c 24          	mov    (%rsp),%r15
  800421daa2:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  800421daa7:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  800421daac:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  800421dab1:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  800421dab6:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  800421dabb:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  800421dac0:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  800421dac5:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  800421daca:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  800421dacf:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  800421dad4:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  800421dad9:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800421dade:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  800421dae3:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800421dae8:	48 83 c4 78          	add    $0x78,%rsp
  800421daec:	0f 01 c3             	vmresume 
  800421daef:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  800421daf4:	59                   	pop    %rcx
  800421daf5:	48 89 41 70          	mov    %rax,0x70(%rcx)
  800421daf9:	48 89 59 68          	mov    %rbx,0x68(%rcx)
  800421dafd:	48 89 51 58          	mov    %rdx,0x58(%rcx)
  800421db01:	48 89 69 50          	mov    %rbp,0x50(%rcx)
  800421db05:	48 89 79 48          	mov    %rdi,0x48(%rcx)
  800421db09:	48 89 71 40          	mov    %rsi,0x40(%rcx)
  800421db0d:	4c 89 41 38          	mov    %r8,0x38(%rcx)
  800421db11:	4c 89 49 30          	mov    %r9,0x30(%rcx)
  800421db15:	4c 89 51 28          	mov    %r10,0x28(%rcx)
  800421db19:	4c 89 59 20          	mov    %r11,0x20(%rcx)
  800421db1d:	4c 89 61 18          	mov    %r12,0x18(%rcx)
  800421db21:	4c 89 69 10          	mov    %r13,0x10(%rcx)
  800421db25:	4c 89 71 08          	mov    %r14,0x8(%rcx)
  800421db29:	4c 89 39             	mov    %r15,(%rcx)
  800421db2c:	0f 20 d0             	mov    %cr2,%rax
  800421db2f:	48 89 81 90 00 00 00 	mov    %rax,0x90(%rcx)
  800421db36:	58                   	pop    %rax
  800421db37:	48 89 41 60          	mov    %rax,0x60(%rcx)
  800421db3b:	5d                   	pop    %rbp
  800421db3c:	5a                   	pop    %rdx
  800421db3d:	0f 96 41 78          	setbe  0x78(%rcx)
		  [wordsize]"i"(sizeof(uint64_t)) 
                : "cc", "memory"
		  , "rax", "rbx", "rdi", "rsi"
		  , "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
	);
	lock_kernel();
  800421db41:	48 b8 6f a3 21 04 80 	movabs $0x800421a36f,%rax
  800421db48:	00 00 00 
  800421db4b:	ff d0                	callq  *%rax
	if(tf->tf_es) {
  800421db4d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421db51:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800421db55:	66 85 c0             	test   %ax,%ax
  800421db58:	74 20                	je     800421db7a <asm_vmrun+0x1d6>
		cprintf("Error during VMLAUNCH/VMRESUME\n");
  800421db5a:	48 bf 28 2a 22 04 80 	movabs $0x8004222a28,%rdi
  800421db61:	00 00 00 
  800421db64:	b8 00 00 00 00       	mov    $0x0,%eax
  800421db69:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421db70:	00 00 00 
  800421db73:	ff d2                	callq  *%rdx
	} else {
		curenv->env_tf.tf_rsp = vmcs_read64(VMCS_GUEST_RSP);
		curenv->env_tf.tf_rip = vmcs_read64(VMCS_GUEST_RIP);
		vmexit();
	}
}
  800421db75:	e9 af 00 00 00       	jmpq   800421dc29 <asm_vmrun+0x285>
	);
	lock_kernel();
	if(tf->tf_es) {
		cprintf("Error during VMLAUNCH/VMRESUME\n");
	} else {
		curenv->env_tf.tf_rsp = vmcs_read64(VMCS_GUEST_RSP);
  800421db7a:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421db81:	00 00 00 
  800421db84:	ff d0                	callq  *%rax
  800421db86:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421db8d:	00 00 00 
  800421db90:	48 98                	cltq   
  800421db92:	48 c1 e0 03          	shl    $0x3,%rax
  800421db96:	48 89 c1             	mov    %rax,%rcx
  800421db99:	48 c1 e1 04          	shl    $0x4,%rcx
  800421db9d:	48 01 c8             	add    %rcx,%rax
  800421dba0:	48 01 d0             	add    %rdx,%rax
  800421dba3:	48 83 c0 08          	add    $0x8,%rax
  800421dba7:	48 8b 18             	mov    (%rax),%rbx
  800421dbaa:	c7 45 cc 1c 68 00 00 	movl   $0x681c,-0x34(%rbp)
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421dbb1:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421dbb4:	89 c7                	mov    %eax,%edi
  800421dbb6:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421dbbd:	00 00 00 
  800421dbc0:	ff d0                	callq  *%rax
  800421dbc2:	48 89 83 b0 00 00 00 	mov    %rax,0xb0(%rbx)
		curenv->env_tf.tf_rip = vmcs_read64(VMCS_GUEST_RIP);
  800421dbc9:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421dbd0:	00 00 00 
  800421dbd3:	ff d0                	callq  *%rax
  800421dbd5:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421dbdc:	00 00 00 
  800421dbdf:	48 98                	cltq   
  800421dbe1:	48 c1 e0 03          	shl    $0x3,%rax
  800421dbe5:	48 89 c1             	mov    %rax,%rcx
  800421dbe8:	48 c1 e1 04          	shl    $0x4,%rcx
  800421dbec:	48 01 c8             	add    %rcx,%rax
  800421dbef:	48 01 d0             	add    %rdx,%rax
  800421dbf2:	48 83 c0 08          	add    $0x8,%rax
  800421dbf6:	48 8b 18             	mov    (%rax),%rbx
  800421dbf9:	c7 45 c8 1e 68 00 00 	movl   $0x681e,-0x38(%rbp)
  800421dc00:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421dc03:	89 c7                	mov    %eax,%edi
  800421dc05:	48 b8 05 a2 21 04 80 	movabs $0x800421a205,%rax
  800421dc0c:	00 00 00 
  800421dc0f:	ff d0                	callq  *%rax
  800421dc11:	48 89 83 98 00 00 00 	mov    %rax,0x98(%rbx)
		vmexit();
  800421dc18:	b8 00 00 00 00       	mov    $0x0,%eax
  800421dc1d:	48 ba bf d3 21 04 80 	movabs $0x800421d3bf,%rdx
  800421dc24:	00 00 00 
  800421dc27:	ff d2                	callq  *%rdx
	}
}
  800421dc29:	90                   	nop
  800421dc2a:	48 83 c4 28          	add    $0x28,%rsp
  800421dc2e:	5b                   	pop    %rbx
  800421dc2f:	41 5c                	pop    %r12
  800421dc31:	41 5d                	pop    %r13
  800421dc33:	41 5e                	pop    %r14
  800421dc35:	41 5f                	pop    %r15
  800421dc37:	5d                   	pop    %rbp
  800421dc38:	c3                   	retq   

000000800421dc39 <msr_setup>:

void
msr_setup(struct VmxGuestInfo *ginfo) {
  800421dc39:	55                   	push   %rbp
  800421dc3a:	48 89 e5             	mov    %rsp,%rbp
  800421dc3d:	48 83 ec 40          	sub    $0x40,%rsp
  800421dc41:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	struct vmx_msr_entry *entry;
	uint32_t idx[] = { EFER_MSR };
  800421dc45:	c7 45 d0 80 00 00 c0 	movl   $0xc0000080,-0x30(%rbp)
	int i, count = sizeof(idx) / sizeof(idx[0]);
  800421dc4c:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%rbp)

	assert(count <= MAX_MSR_COUNT);
  800421dc53:	81 7d f8 80 00 00 00 	cmpl   $0x80,-0x8(%rbp)
  800421dc5a:	7e 35                	jle    800421dc91 <msr_setup+0x58>
  800421dc5c:	48 b9 48 2a 22 04 80 	movabs $0x8004222a48,%rcx
  800421dc63:	00 00 00 
  800421dc66:	48 ba 28 22 22 04 80 	movabs $0x8004222228,%rdx
  800421dc6d:	00 00 00 
  800421dc70:	be 1a 03 00 00       	mov    $0x31a,%esi
  800421dc75:	48 bf 3d 22 22 04 80 	movabs $0x800422223d,%rdi
  800421dc7c:	00 00 00 
  800421dc7f:	b8 00 00 00 00       	mov    $0x0,%eax
  800421dc84:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421dc8b:	00 00 00 
  800421dc8e:	41 ff d0             	callq  *%r8
	ginfo->msr_count = count;
  800421dc91:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421dc95:	8b 55 f8             	mov    -0x8(%rbp),%edx
  800421dc98:	89 50 28             	mov    %edx,0x28(%rax)
    
	for(i=0; i<count; ++i) {
  800421dc9b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421dca2:	e9 94 00 00 00       	jmpq   800421dd3b <msr_setup+0x102>
		entry = ((struct vmx_msr_entry *)ginfo->msr_host_area) + i;
  800421dca7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421dcab:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421dcaf:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800421dcb2:	48 63 d2             	movslq %edx,%rdx
  800421dcb5:	48 c1 e2 04          	shl    $0x4,%rdx
  800421dcb9:	48 01 d0             	add    %rdx,%rax
  800421dcbc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		entry->msr_index = idx[i];
  800421dcc0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421dcc3:	48 98                	cltq   
  800421dcc5:	8b 54 85 d0          	mov    -0x30(%rbp,%rax,4),%edx
  800421dcc9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421dccd:	89 10                	mov    %edx,(%rax)
		entry->msr_value = read_msr(idx[i]);
  800421dccf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421dcd2:	48 98                	cltq   
  800421dcd4:	8b 44 85 d0          	mov    -0x30(%rbp,%rax,4),%eax
  800421dcd8:	89 45 ec             	mov    %eax,-0x14(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
	uint32_t edx, eax;
	__asm __volatile("rdmsr"
  800421dcdb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421dcde:	89 c1                	mov    %eax,%ecx
  800421dce0:	0f 32                	rdmsr  
  800421dce2:	89 55 e8             	mov    %edx,-0x18(%rbp)
  800421dce5:	89 45 e4             	mov    %eax,-0x1c(%rbp)
			: "=d" (edx), "=a" (eax)
			: "c" (ecx));
	uint64_t ret = 0;
  800421dce8:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  800421dcef:	00 
	ret = edx;
  800421dcf0:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421dcf3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	ret = ret << 32;
  800421dcf7:	48 c1 65 d8 20       	shlq   $0x20,-0x28(%rbp)
	ret |= eax;
  800421dcfc:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421dcff:	48 09 45 d8          	or     %rax,-0x28(%rbp)

	return ret;
  800421dd03:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421dd07:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421dd0b:	48 89 50 08          	mov    %rdx,0x8(%rax)
        
		entry = ((struct vmx_msr_entry *)ginfo->msr_guest_area) + i;
  800421dd0f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421dd13:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421dd17:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800421dd1a:	48 63 d2             	movslq %edx,%rdx
  800421dd1d:	48 c1 e2 04          	shl    $0x4,%rdx
  800421dd21:	48 01 d0             	add    %rdx,%rax
  800421dd24:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		entry->msr_index = idx[i];
  800421dd28:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421dd2b:	48 98                	cltq   
  800421dd2d:	8b 54 85 d0          	mov    -0x30(%rbp,%rax,4),%edx
  800421dd31:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421dd35:	89 10                	mov    %edx,(%rax)
	int i, count = sizeof(idx) / sizeof(idx[0]);

	assert(count <= MAX_MSR_COUNT);
	ginfo->msr_count = count;
    
	for(i=0; i<count; ++i) {
  800421dd37:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421dd3b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421dd3e:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  800421dd41:	0f 8c 60 ff ff ff    	jl     800421dca7 <msr_setup+0x6e>
		entry->msr_value = read_msr(idx[i]);
        
		entry = ((struct vmx_msr_entry *)ginfo->msr_guest_area) + i;
		entry->msr_index = idx[i];
	}
}
  800421dd47:	90                   	nop
  800421dd48:	c9                   	leaveq 
  800421dd49:	c3                   	retq   

000000800421dd4a <bitmap_setup>:

void
bitmap_setup(struct VmxGuestInfo *ginfo) {
  800421dd4a:	55                   	push   %rbp
  800421dd4b:	48 89 e5             	mov    %rsp,%rbp
  800421dd4e:	48 83 ec 30          	sub    $0x30,%rsp
  800421dd52:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)

	unsigned int io_ports[] = { IO_RTC, IO_RTC+1 };
  800421dd56:	c7 45 e0 70 00 00 00 	movl   $0x70,-0x20(%rbp)
  800421dd5d:	c7 45 e4 71 00 00 00 	movl   $0x71,-0x1c(%rbp)

	int i, count = sizeof(io_ports) / sizeof(io_ports[0]);
  800421dd64:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%rbp)
    
	for(i=0; i<count; ++i) {
  800421dd6b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421dd72:	e9 07 01 00 00       	jmpq   800421de7e <bitmap_setup+0x134>
		int idx = io_ports[i] / (sizeof(uint64_t) * 8);
  800421dd77:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421dd7a:	48 98                	cltq   
  800421dd7c:	8b 44 85 e0          	mov    -0x20(%rbp,%rax,4),%eax
  800421dd80:	c1 e8 06             	shr    $0x6,%eax
  800421dd83:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if(io_ports[i] < 0x7FFF) {
  800421dd86:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421dd89:	48 98                	cltq   
  800421dd8b:	8b 44 85 e0          	mov    -0x20(%rbp,%rax,4),%eax
  800421dd8f:	3d fe 7f 00 00       	cmp    $0x7ffe,%eax
  800421dd94:	77 51                	ja     800421dde7 <bitmap_setup+0x9d>
			ginfo->io_bmap_a[idx] |= ((0x1uL << (io_ports[i] & 0x3F)));
  800421dd96:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421dd9a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421dd9e:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421dda1:	48 63 d2             	movslq %edx,%rdx
  800421dda4:	48 c1 e2 03          	shl    $0x3,%rdx
  800421dda8:	48 01 c2             	add    %rax,%rdx
  800421ddab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421ddaf:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421ddb3:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  800421ddb6:	48 63 c9             	movslq %ecx,%rcx
  800421ddb9:	48 c1 e1 03          	shl    $0x3,%rcx
  800421ddbd:	48 01 c8             	add    %rcx,%rax
  800421ddc0:	48 8b 30             	mov    (%rax),%rsi
  800421ddc3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421ddc6:	48 98                	cltq   
  800421ddc8:	8b 44 85 e0          	mov    -0x20(%rbp,%rax,4),%eax
  800421ddcc:	83 e0 3f             	and    $0x3f,%eax
  800421ddcf:	bf 01 00 00 00       	mov    $0x1,%edi
  800421ddd4:	89 c1                	mov    %eax,%ecx
  800421ddd6:	48 d3 e7             	shl    %cl,%rdi
  800421ddd9:	48 89 f8             	mov    %rdi,%rax
  800421dddc:	48 09 f0             	or     %rsi,%rax
  800421dddf:	48 89 02             	mov    %rax,(%rdx)
  800421dde2:	e9 93 00 00 00       	jmpq   800421de7a <bitmap_setup+0x130>
		} else if (io_ports[i] < 0xFFFF) {
  800421dde7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421ddea:	48 98                	cltq   
  800421ddec:	8b 44 85 e0          	mov    -0x20(%rbp,%rax,4),%eax
  800421ddf0:	3d fe ff 00 00       	cmp    $0xfffe,%eax
  800421ddf5:	77 4e                	ja     800421de45 <bitmap_setup+0xfb>
			ginfo->io_bmap_b[idx] |= ((0x1uL << (io_ports[i] & 0x3F)));
  800421ddf7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421ddfb:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421ddff:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421de02:	48 63 d2             	movslq %edx,%rdx
  800421de05:	48 c1 e2 03          	shl    $0x3,%rdx
  800421de09:	48 01 c2             	add    %rax,%rdx
  800421de0c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421de10:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421de14:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  800421de17:	48 63 c9             	movslq %ecx,%rcx
  800421de1a:	48 c1 e1 03          	shl    $0x3,%rcx
  800421de1e:	48 01 c8             	add    %rcx,%rax
  800421de21:	48 8b 30             	mov    (%rax),%rsi
  800421de24:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421de27:	48 98                	cltq   
  800421de29:	8b 44 85 e0          	mov    -0x20(%rbp,%rax,4),%eax
  800421de2d:	83 e0 3f             	and    $0x3f,%eax
  800421de30:	bf 01 00 00 00       	mov    $0x1,%edi
  800421de35:	89 c1                	mov    %eax,%ecx
  800421de37:	48 d3 e7             	shl    %cl,%rdi
  800421de3a:	48 89 f8             	mov    %rdi,%rax
  800421de3d:	48 09 f0             	or     %rsi,%rax
  800421de40:	48 89 02             	mov    %rax,(%rdx)
  800421de43:	eb 35                	jmp    800421de7a <bitmap_setup+0x130>
		} else {
			assert(false);
  800421de45:	48 b9 22 22 22 04 80 	movabs $0x8004222222,%rcx
  800421de4c:	00 00 00 
  800421de4f:	48 ba 28 22 22 04 80 	movabs $0x8004222228,%rdx
  800421de56:	00 00 00 
  800421de59:	be 35 03 00 00       	mov    $0x335,%esi
  800421de5e:	48 bf 3d 22 22 04 80 	movabs $0x800422223d,%rdi
  800421de65:	00 00 00 
  800421de68:	b8 00 00 00 00       	mov    $0x0,%eax
  800421de6d:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421de74:	00 00 00 
  800421de77:	41 ff d0             	callq  *%r8

	unsigned int io_ports[] = { IO_RTC, IO_RTC+1 };

	int i, count = sizeof(io_ports) / sizeof(io_ports[0]);
    
	for(i=0; i<count; ++i) {
  800421de7a:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421de7e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421de81:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  800421de84:	0f 8c ed fe ff ff    	jl     800421dd77 <bitmap_setup+0x2d>
			ginfo->io_bmap_b[idx] |= ((0x1uL << (io_ports[i] & 0x3F)));
		} else {
			assert(false);
		}
	}
}
  800421de8a:	90                   	nop
  800421de8b:	c9                   	leaveq 
  800421de8c:	c3                   	retq   

000000800421de8d <vmx_vmrun>:

/* 
 * Processor must be in VMX root operation before executing this function.
 */
int vmx_vmrun( struct Env *e ) {
  800421de8d:	55                   	push   %rbp
  800421de8e:	48 89 e5             	mov    %rsp,%rbp
  800421de91:	48 83 ec 70          	sub    $0x70,%rsp
  800421de95:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
	if ( e->env_type != ENV_TYPE_GUEST ) {
  800421de99:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421de9d:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800421dea3:	83 f8 03             	cmp    $0x3,%eax
  800421dea6:	74 0a                	je     800421deb2 <vmx_vmrun+0x25>
		return -E_INVAL;
  800421dea8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800421dead:	e9 9a 02 00 00       	jmpq   800421e14c <vmx_vmrun+0x2bf>
	}
	uint8_t error;
	if( e->env_runs == 1 ) {
  800421deb2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421deb6:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  800421debc:	83 f8 01             	cmp    $0x1,%eax
  800421debf:	0f 85 2f 01 00 00    	jne    800421dff4 <vmx_vmrun+0x167>
		physaddr_t vmcs_phy_addr = PADDR(e->env_vmxinfo.vmcs);
  800421dec5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421dec9:	48 8b 80 28 01 00 00 	mov    0x128(%rax),%rax
  800421ded0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421ded4:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421dedb:	00 00 00 
  800421dede:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421dee2:	77 32                	ja     800421df16 <vmx_vmrun+0x89>
  800421dee4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421dee8:	48 89 c1             	mov    %rax,%rcx
  800421deeb:	48 ba b8 22 22 04 80 	movabs $0x80042222b8,%rdx
  800421def2:	00 00 00 
  800421def5:	be 43 03 00 00       	mov    $0x343,%esi
  800421defa:	48 bf 3d 22 22 04 80 	movabs $0x800422223d,%rdi
  800421df01:	00 00 00 
  800421df04:	b8 00 00 00 00       	mov    $0x0,%eax
  800421df09:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421df10:	00 00 00 
  800421df13:	41 ff d0             	callq  *%r8
  800421df16:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421df1d:	ff ff ff 
  800421df20:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421df24:	48 01 d0             	add    %rdx,%rax
  800421df27:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800421df2b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421df2f:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
}

static __inline uint8_t
vmclear( physaddr_t vmcs_region ) {
	uint8_t error = 0;
  800421df33:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)

    __asm __volatile("clc; vmclear %1; setna %0"
  800421df37:	f8                   	clc    
  800421df38:	66 0f c7 75 a8       	vmclear -0x58(%rbp)
  800421df3d:	0f 96 c0             	setbe  %al
  800421df40:	88 45 d7             	mov    %al,-0x29(%rbp)
            : "=q"( error ) : "m" ( vmcs_region ) : "cc");
    return error;
  800421df43:	0f b6 45 d7          	movzbl -0x29(%rbp),%eax
        
		// Call VMCLEAR on the VMCS region.
		error = vmclear(vmcs_phy_addr);
  800421df47:	88 45 ee             	mov    %al,-0x12(%rbp)
		// Check if VMCLEAR succeeded. ( RFLAGS.CF = 0 and RFLAGS.ZF = 0 )
		if ( error )
  800421df4a:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  800421df4e:	74 0a                	je     800421df5a <vmx_vmrun+0xcd>
			return -E_VMCS_INIT; 
  800421df50:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
  800421df55:	e9 f2 01 00 00       	jmpq   800421e14c <vmx_vmrun+0x2bf>
  800421df5a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421df5e:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
}

static __inline uint8_t
vmptrld( physaddr_t vmcs_region ) {
	uint8_t error = 0;
  800421df62:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    __asm __volatile("clc; vmptrld %1; setna %0"
  800421df66:	f8                   	clc    
  800421df67:	0f c7 75 b0          	vmptrld -0x50(%rbp)
  800421df6b:	0f 96 c0             	setbe  %al
  800421df6e:	88 45 ef             	mov    %al,-0x11(%rbp)
            : "=q"( error ) : "m" ( vmcs_region ) : "cc");
    return error;
  800421df71:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax

		// Make this VMCS working VMCS.
		error = vmptrld(vmcs_phy_addr);
  800421df75:	88 45 ee             	mov    %al,-0x12(%rbp)
		if ( error )
  800421df78:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  800421df7c:	74 0a                	je     800421df88 <vmx_vmrun+0xfb>
			return -E_VMCS_INIT; 
  800421df7e:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
  800421df83:	e9 c4 01 00 00       	jmpq   800421e14c <vmx_vmrun+0x2bf>

		vmcs_host_init();
  800421df88:	b8 00 00 00 00       	mov    $0x0,%eax
  800421df8d:	48 ba 71 ac 21 04 80 	movabs $0x800421ac71,%rdx
  800421df94:	00 00 00 
  800421df97:	ff d2                	callq  *%rdx
		vmcs_guest_init();
  800421df99:	b8 00 00 00 00       	mov    $0x0,%eax
  800421df9e:	48 ba 40 b0 21 04 80 	movabs $0x800421b040,%rdx
  800421dfa5:	00 00 00 
  800421dfa8:	ff d2                	callq  *%rdx
		// Setup IO and exception bitmaps.
		bitmap_setup(&e->env_vmxinfo);
  800421dfaa:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421dfae:	48 05 20 01 00 00    	add    $0x120,%rax
  800421dfb4:	48 89 c7             	mov    %rax,%rdi
  800421dfb7:	48 b8 4a dd 21 04 80 	movabs $0x800421dd4a,%rax
  800421dfbe:	00 00 00 
  800421dfc1:	ff d0                	callq  *%rax
		// Setup the msr load/store area
		msr_setup(&e->env_vmxinfo);
  800421dfc3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421dfc7:	48 05 20 01 00 00    	add    $0x120,%rax
  800421dfcd:	48 89 c7             	mov    %rax,%rdi
  800421dfd0:	48 b8 39 dc 21 04 80 	movabs $0x800421dc39,%rax
  800421dfd7:	00 00 00 
  800421dfda:	ff d0                	callq  *%rax
		vmcs_ctls_init(e);
  800421dfdc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421dfe0:	48 89 c7             	mov    %rax,%rdi
  800421dfe3:	48 b8 b7 b8 21 04 80 	movabs $0x800421b8b7,%rax
  800421dfea:	00 00 00 
  800421dfed:	ff d0                	callq  *%rax
  800421dfef:	e9 8c 00 00 00       	jmpq   800421e080 <vmx_vmrun+0x1f3>

		/* ept_alloc_static(e->env_pml4e, &e->env_vmxinfo); */

	} else {
		// Make this VMCS working VMCS.
		error = vmptrld(PADDR(e->env_vmxinfo.vmcs));
  800421dff4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421dff8:	48 8b 80 28 01 00 00 	mov    0x128(%rax),%rax
  800421dfff:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800421e003:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421e00a:	00 00 00 
  800421e00d:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  800421e011:	77 32                	ja     800421e045 <vmx_vmrun+0x1b8>
  800421e013:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421e017:	48 89 c1             	mov    %rax,%rcx
  800421e01a:	48 ba b8 22 22 04 80 	movabs $0x80042222b8,%rdx
  800421e021:	00 00 00 
  800421e024:	be 5c 03 00 00       	mov    $0x35c,%esi
  800421e029:	48 bf 3d 22 22 04 80 	movabs $0x800422223d,%rdi
  800421e030:	00 00 00 
  800421e033:	b8 00 00 00 00       	mov    $0x0,%eax
  800421e038:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421e03f:	00 00 00 
  800421e042:	41 ff d0             	callq  *%r8
  800421e045:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421e04c:	ff ff ff 
  800421e04f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421e053:	48 01 d0             	add    %rdx,%rax
  800421e056:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    return error;
}

static __inline uint8_t
vmptrld( physaddr_t vmcs_region ) {
	uint8_t error = 0;
  800421e05a:	c6 45 ed 00          	movb   $0x0,-0x13(%rbp)

    __asm __volatile("clc; vmptrld %1; setna %0"
  800421e05e:	f8                   	clc    
  800421e05f:	0f c7 75 b8          	vmptrld -0x48(%rbp)
  800421e063:	0f 96 c0             	setbe  %al
  800421e066:	88 45 ed             	mov    %al,-0x13(%rbp)
            : "=q"( error ) : "m" ( vmcs_region ) : "cc");
    return error;
  800421e069:	0f b6 45 ed          	movzbl -0x13(%rbp),%eax
  800421e06d:	88 45 ee             	mov    %al,-0x12(%rbp)
		if ( error ) {
  800421e070:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  800421e074:	74 0a                	je     800421e080 <vmx_vmrun+0x1f3>
			return -E_VMCS_INIT; 
  800421e076:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
  800421e07b:	e9 cc 00 00 00       	jmpq   800421e14c <vmx_vmrun+0x2bf>
		}
	}

	vmcs_write64( VMCS_GUEST_RSP, curenv->env_tf.tf_rsp  );
  800421e080:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421e087:	00 00 00 
  800421e08a:	ff d0                	callq  *%rax
  800421e08c:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421e093:	00 00 00 
  800421e096:	48 98                	cltq   
  800421e098:	48 c1 e0 03          	shl    $0x3,%rax
  800421e09c:	48 89 c1             	mov    %rax,%rcx
  800421e09f:	48 c1 e1 04          	shl    $0x4,%rcx
  800421e0a3:	48 01 c8             	add    %rcx,%rax
  800421e0a6:	48 01 d0             	add    %rdx,%rax
  800421e0a9:	48 83 c0 08          	add    $0x8,%rax
  800421e0ad:	48 8b 00             	mov    (%rax),%rax
  800421e0b0:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800421e0b7:	c7 45 d8 1c 68 00 00 	movl   $0x681c,-0x28(%rbp)
  800421e0be:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421e0c2:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421e0c6:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421e0c9:	48 89 d6             	mov    %rdx,%rsi
  800421e0cc:	89 c7                	mov    %eax,%edi
  800421e0ce:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421e0d5:	00 00 00 
  800421e0d8:	ff d0                	callq  *%rax
	vmcs_write64( VMCS_GUEST_RIP, curenv->env_tf.tf_rip );
  800421e0da:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421e0e1:	00 00 00 
  800421e0e4:	ff d0                	callq  *%rax
  800421e0e6:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421e0ed:	00 00 00 
  800421e0f0:	48 98                	cltq   
  800421e0f2:	48 c1 e0 03          	shl    $0x3,%rax
  800421e0f6:	48 89 c1             	mov    %rax,%rcx
  800421e0f9:	48 c1 e1 04          	shl    $0x4,%rcx
  800421e0fd:	48 01 c8             	add    %rcx,%rax
  800421e100:	48 01 d0             	add    %rdx,%rax
  800421e103:	48 83 c0 08          	add    $0x8,%rax
  800421e107:	48 8b 00             	mov    (%rax),%rax
  800421e10a:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800421e111:	c7 45 dc 1e 68 00 00 	movl   $0x681e,-0x24(%rbp)
  800421e118:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  800421e11c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421e120:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421e123:	48 89 d6             	mov    %rdx,%rsi
  800421e126:	89 c7                	mov    %eax,%edi
  800421e128:	48 b8 df a1 21 04 80 	movabs $0x800421a1df,%rax
  800421e12f:	00 00 00 
  800421e132:	ff d0                	callq  *%rax
	asm_vmrun( &e->env_tf );    
  800421e134:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421e138:	48 89 c7             	mov    %rax,%rdi
  800421e13b:	48 b8 a4 d9 21 04 80 	movabs $0x800421d9a4,%rax
  800421e142:	00 00 00 
  800421e145:	ff d0                	callq  *%rax
	return 0;
  800421e147:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421e14c:	c9                   	leaveq 
  800421e14d:	c3                   	retq   

000000800421e14e <vmcs_writel>:
#define IA32_VMX_EPT_VPID_CAP 0x48C
#define IA32_FEATURE_CONTROL 0x03A

#define BIT( val, x ) ( ( val >> x ) & 0x1 )

static __inline uint8_t vmcs_writel( uint32_t field, uint64_t value) {
  800421e14e:	55                   	push   %rbp
  800421e14f:	48 89 e5             	mov    %rsp,%rbp
  800421e152:	48 83 ec 20          	sub    $0x20,%rsp
  800421e156:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800421e159:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint8_t error;

	__asm __volatile ( "clc; vmwrite %%rax, %%rdx; setna %0"
  800421e15d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421e161:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421e164:	f8                   	clc    
  800421e165:	0f 79 d0             	vmwrite %rax,%rdx
  800421e168:	0f 96 c0             	setbe  %al
  800421e16b:	88 45 ff             	mov    %al,-0x1(%rbp)
		       : "=q"( error ) : "a"( value ), "d"( field ) : "cc");
    return error;
  800421e16e:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  800421e172:	c9                   	leaveq 
  800421e173:	c3                   	retq   

000000800421e174 <vmcs_readl>:
static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
}

static __inline uint64_t vmcs_readl(uint32_t field)
{
  800421e174:	55                   	push   %rbp
  800421e175:	48 89 e5             	mov    %rsp,%rbp
  800421e178:	48 83 ec 18          	sub    $0x18,%rsp
  800421e17c:	89 7d ec             	mov    %edi,-0x14(%rbp)
	uint64_t value;

	__asm __volatile ( "vmread %%rdx, %%rax;"
  800421e17f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421e182:	89 c2                	mov    %eax,%edx
  800421e184:	0f 78 d0             	vmread %rdx,%rax
  800421e187:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		      : "=a"(value) : "d"(field) : "cc");
	return value;
  800421e18b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421e18f:	c9                   	leaveq 
  800421e190:	c3                   	retq   

000000800421e191 <cpuid>:

#define read_rip(var) __asm __volatile("leaq (%%rip), %0" : "=r" (var)::"cc","memory")

static __inline void
cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)
{
  800421e191:	55                   	push   %rbp
  800421e192:	48 89 e5             	mov    %rsp,%rbp
  800421e195:	53                   	push   %rbx
  800421e196:	48 83 ec 38          	sub    $0x38,%rsp
  800421e19a:	89 7d e4             	mov    %edi,-0x1c(%rbp)
  800421e19d:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  800421e1a1:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800421e1a5:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  800421e1a9:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
	uint32_t eax, ebx, ecx, edx;
	asm volatile("cpuid" 
  800421e1ad:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421e1b0:	0f a2                	cpuid  
  800421e1b2:	89 de                	mov    %ebx,%esi
  800421e1b4:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800421e1b7:	89 75 f0             	mov    %esi,-0x10(%rbp)
  800421e1ba:	89 4d ec             	mov    %ecx,-0x14(%rbp)
  800421e1bd:	89 55 e8             	mov    %edx,-0x18(%rbp)
			 : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
			 : "a" (info));
	if (eaxp)
  800421e1c0:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421e1c5:	74 09                	je     800421e1d0 <cpuid+0x3f>
		*eaxp = eax;
  800421e1c7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e1cb:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421e1ce:	89 10                	mov    %edx,(%rax)
	if (ebxp)
  800421e1d0:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800421e1d5:	74 09                	je     800421e1e0 <cpuid+0x4f>
		*ebxp = ebx;
  800421e1d7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421e1db:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800421e1de:	89 10                	mov    %edx,(%rax)
	if (ecxp)
  800421e1e0:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800421e1e5:	74 09                	je     800421e1f0 <cpuid+0x5f>
		*ecxp = ecx;
  800421e1e7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421e1eb:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421e1ee:	89 10                	mov    %edx,(%rax)
	if (edxp)
  800421e1f0:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800421e1f5:	74 09                	je     800421e200 <cpuid+0x6f>
		*edxp = edx;
  800421e1f7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421e1fb:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800421e1fe:	89 10                	mov    %edx,(%rax)
}
  800421e200:	90                   	nop
  800421e201:	48 83 c4 38          	add    $0x38,%rsp
  800421e205:	5b                   	pop    %rbx
  800421e206:	5d                   	pop    %rbp
  800421e207:	c3                   	retq   

000000800421e208 <page2ppn>:
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);


static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  800421e208:	55                   	push   %rbp
  800421e209:	48 89 e5             	mov    %rsp,%rbp
  800421e20c:	48 83 ec 08          	sub    $0x8,%rsp
  800421e210:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  800421e214:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421e218:	48 b8 00 f6 6d 04 80 	movabs $0x80046df600,%rax
  800421e21f:	00 00 00 
  800421e222:	48 8b 00             	mov    (%rax),%rax
  800421e225:	48 29 c2             	sub    %rax,%rdx
  800421e228:	48 89 d0             	mov    %rdx,%rax
  800421e22b:	48 c1 f8 04          	sar    $0x4,%rax
}
  800421e22f:	c9                   	leaveq 
  800421e230:	c3                   	retq   

000000800421e231 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  800421e231:	55                   	push   %rbp
  800421e232:	48 89 e5             	mov    %rsp,%rbp
  800421e235:	48 83 ec 08          	sub    $0x8,%rsp
  800421e239:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  800421e23d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421e241:	48 89 c7             	mov    %rax,%rdi
  800421e244:	48 b8 08 e2 21 04 80 	movabs $0x800421e208,%rax
  800421e24b:	00 00 00 
  800421e24e:	ff d0                	callq  *%rax
  800421e250:	48 c1 e0 0c          	shl    $0xc,%rax
}
  800421e254:	c9                   	leaveq 
  800421e255:	c3                   	retq   

000000800421e256 <page2kva>:
	return &pages[PPN(pa)];
}

static inline void*
page2kva(struct PageInfo *pp)
{
  800421e256:	55                   	push   %rbp
  800421e257:	48 89 e5             	mov    %rsp,%rbp
  800421e25a:	48 83 ec 20          	sub    $0x20,%rsp
  800421e25e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  800421e262:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421e266:	48 89 c7             	mov    %rax,%rdi
  800421e269:	48 b8 31 e2 21 04 80 	movabs $0x800421e231,%rax
  800421e270:	00 00 00 
  800421e273:	ff d0                	callq  *%rax
  800421e275:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421e279:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421e27d:	48 c1 e8 0c          	shr    $0xc,%rax
  800421e281:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800421e284:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421e287:	48 b8 f8 f5 6d 04 80 	movabs $0x80046df5f8,%rax
  800421e28e:	00 00 00 
  800421e291:	48 8b 00             	mov    (%rax),%rax
  800421e294:	48 39 c2             	cmp    %rax,%rdx
  800421e297:	72 32                	jb     800421e2cb <page2kva+0x75>
  800421e299:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421e29d:	48 89 c1             	mov    %rax,%rcx
  800421e2a0:	48 ba 60 2a 22 04 80 	movabs $0x8004222a60,%rdx
  800421e2a7:	00 00 00 
  800421e2aa:	be 61 00 00 00       	mov    $0x61,%esi
  800421e2af:	48 bf 83 2a 22 04 80 	movabs $0x8004222a83,%rdi
  800421e2b6:	00 00 00 
  800421e2b9:	b8 00 00 00 00       	mov    $0x0,%eax
  800421e2be:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421e2c5:	00 00 00 
  800421e2c8:	41 ff d0             	callq  *%r8
  800421e2cb:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421e2d2:	00 00 00 
  800421e2d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421e2d9:	48 01 d0             	add    %rdx,%rax
}
  800421e2dc:	c9                   	leaveq 
  800421e2dd:	c3                   	retq   

000000800421e2de <vmx_get_vmdisk_number>:
#include <kern/trap.h>


static int vmdisk_number = 0;	//this number assign to the vm
int 
vmx_get_vmdisk_number() {
  800421e2de:	55                   	push   %rbp
  800421e2df:	48 89 e5             	mov    %rsp,%rbp
	return vmdisk_number;
  800421e2e2:	48 b8 c8 f5 6d 04 80 	movabs $0x80046df5c8,%rax
  800421e2e9:	00 00 00 
  800421e2ec:	8b 00                	mov    (%rax),%eax
}
  800421e2ee:	5d                   	pop    %rbp
  800421e2ef:	c3                   	retq   

000000800421e2f0 <vmx_incr_vmdisk_number>:

void
vmx_incr_vmdisk_number() {
  800421e2f0:	55                   	push   %rbp
  800421e2f1:	48 89 e5             	mov    %rsp,%rbp
	vmdisk_number++;
  800421e2f4:	48 b8 c8 f5 6d 04 80 	movabs $0x80046df5c8,%rax
  800421e2fb:	00 00 00 
  800421e2fe:	8b 00                	mov    (%rax),%eax
  800421e300:	8d 50 01             	lea    0x1(%rax),%edx
  800421e303:	48 b8 c8 f5 6d 04 80 	movabs $0x80046df5c8,%rax
  800421e30a:	00 00 00 
  800421e30d:	89 10                	mov    %edx,(%rax)
}
  800421e30f:	90                   	nop
  800421e310:	5d                   	pop    %rbp
  800421e311:	c3                   	retq   

000000800421e312 <find_msr_in_region>:
bool
find_msr_in_region(uint32_t msr_idx, uintptr_t *area, int area_sz, struct vmx_msr_entry **msr_entry) {
  800421e312:	55                   	push   %rbp
  800421e313:	48 89 e5             	mov    %rsp,%rbp
  800421e316:	48 83 ec 28          	sub    $0x28,%rsp
  800421e31a:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800421e31d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421e321:	89 55 e8             	mov    %edx,-0x18(%rbp)
  800421e324:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
	struct vmx_msr_entry *entry = (struct vmx_msr_entry *)area;
  800421e328:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421e32c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	int i;
	for(i=0; i<area_sz; ++i) {
  800421e330:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421e337:	eb 21                	jmp    800421e35a <find_msr_in_region+0x48>
		if(entry->msr_index == msr_idx) {
  800421e339:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421e33d:	8b 00                	mov    (%rax),%eax
  800421e33f:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800421e342:	75 12                	jne    800421e356 <find_msr_in_region+0x44>
			*msr_entry = entry;
  800421e344:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e348:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421e34c:	48 89 10             	mov    %rdx,(%rax)
			return true;
  800421e34f:	b8 01 00 00 00       	mov    $0x1,%eax
  800421e354:	eb 11                	jmp    800421e367 <find_msr_in_region+0x55>
}
bool
find_msr_in_region(uint32_t msr_idx, uintptr_t *area, int area_sz, struct vmx_msr_entry **msr_entry) {
	struct vmx_msr_entry *entry = (struct vmx_msr_entry *)area;
	int i;
	for(i=0; i<area_sz; ++i) {
  800421e356:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421e35a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421e35d:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  800421e360:	7c d7                	jl     800421e339 <find_msr_in_region+0x27>
		if(entry->msr_index == msr_idx) {
			*msr_entry = entry;
			return true;
		}
	}
	return false;
  800421e362:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421e367:	c9                   	leaveq 
  800421e368:	c3                   	retq   

000000800421e369 <handle_interrupt_window>:


bool
handle_interrupt_window(struct Trapframe *tf, struct VmxGuestInfo *ginfo, uint32_t host_vector) {
  800421e369:	55                   	push   %rbp
  800421e36a:	48 89 e5             	mov    %rsp,%rbp
  800421e36d:	48 83 ec 38          	sub    $0x38,%rsp
  800421e371:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421e375:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421e379:	89 55 cc             	mov    %edx,-0x34(%rbp)
  800421e37c:	c7 45 f8 02 40 00 00 	movl   $0x4002,-0x8(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421e383:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421e386:	89 c7                	mov    %eax,%edi
  800421e388:	48 b8 74 e1 21 04 80 	movabs $0x800421e174,%rax
  800421e38f:	00 00 00 
  800421e392:	ff d0                	callq  *%rax
	uint64_t rflags;
	uint32_t procbased_ctls_or;
	
	procbased_ctls_or = vmcs_read32( VMCS_32BIT_CONTROL_PROCESSOR_BASED_VMEXEC_CONTROLS );
  800421e394:	89 45 fc             	mov    %eax,-0x4(%rbp)
            
        //disable the interrupt window exiting
        procbased_ctls_or &= ~(VMCS_PROC_BASED_VMEXEC_CTL_INTRWINEXIT); 
  800421e397:	83 65 fc fb          	andl   $0xfffffffb,-0x4(%rbp)
  800421e39b:	c7 45 f4 02 40 00 00 	movl   $0x4002,-0xc(%rbp)
  800421e3a2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421e3a5:	89 45 e8             	mov    %eax,-0x18(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421e3a8:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800421e3ab:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421e3ae:	48 89 d6             	mov    %rdx,%rsi
  800421e3b1:	89 c7                	mov    %eax,%edi
  800421e3b3:	48 b8 4e e1 21 04 80 	movabs $0x800421e14e,%rax
  800421e3ba:	00 00 00 
  800421e3bd:	ff d0                	callq  *%rax
  800421e3bf:	c7 45 f0 16 40 00 00 	movl   $0x4016,-0x10(%rbp)
  800421e3c6:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421e3c9:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800421e3cc:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421e3cf:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800421e3d2:	48 89 d6             	mov    %rdx,%rsi
  800421e3d5:	89 c7                	mov    %eax,%edi
  800421e3d7:	48 b8 4e e1 21 04 80 	movabs $0x800421e14e,%rax
  800421e3de:	00 00 00 
  800421e3e1:	ff d0                	callq  *%rax
        
        vmcs_write32( VMCS_32BIT_CONTROL_PROCESSOR_BASED_VMEXEC_CONTROLS, 
		      procbased_ctls_or);
        //write back the host_vector, which can insert a virtual interrupt            
	vmcs_write32( VMCS_32BIT_CONTROL_VMENTRY_INTERRUPTION_INFO , host_vector);
	return true;
  800421e3e3:	b8 01 00 00 00       	mov    $0x1,%eax
}
  800421e3e8:	c9                   	leaveq 
  800421e3e9:	c3                   	retq   

000000800421e3ea <handle_interrupts>:
bool
handle_interrupts(struct Trapframe *tf, struct VmxGuestInfo *ginfo, uint32_t host_vector) {
  800421e3ea:	55                   	push   %rbp
  800421e3eb:	48 89 e5             	mov    %rsp,%rbp
  800421e3ee:	48 83 ec 48          	sub    $0x48,%rsp
  800421e3f2:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421e3f6:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421e3fa:	89 55 bc             	mov    %edx,-0x44(%rbp)
  800421e3fd:	c7 45 e0 20 68 00 00 	movl   $0x6820,-0x20(%rbp)
	return vmcs_readl(field);
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421e404:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421e407:	89 c7                	mov    %eax,%edi
  800421e409:	48 b8 74 e1 21 04 80 	movabs $0x800421e174,%rax
  800421e410:	00 00 00 
  800421e413:	ff d0                	callq  *%rax
	uint64_t rflags;
	uint32_t procbased_ctls_or;
	rflags = vmcs_read64(VMCS_GUEST_RFLAGS);
  800421e415:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	
	if ( !(rflags & (0x1 << 9)) ) {	//we have to wait the interrupt window open
  800421e419:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421e41d:	25 00 02 00 00       	and    $0x200,%eax
  800421e422:	48 85 c0             	test   %rax,%rax
  800421e425:	75 45                	jne    800421e46c <handle_interrupts+0x82>
  800421e427:	c7 45 e4 02 40 00 00 	movl   $0x4002,-0x1c(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421e42e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421e431:	89 c7                	mov    %eax,%edi
  800421e433:	48 b8 74 e1 21 04 80 	movabs $0x800421e174,%rax
  800421e43a:	00 00 00 
  800421e43d:	ff d0                	callq  *%rax
		//get the interrupt info
		
		procbased_ctls_or = vmcs_read32( VMCS_32BIT_CONTROL_PROCESSOR_BASED_VMEXEC_CONTROLS);
  800421e43f:	89 45 e8             	mov    %eax,-0x18(%rbp)
            
		//disable the interrupt window exiting
		procbased_ctls_or |= VMCS_PROC_BASED_VMEXEC_CTL_INTRWINEXIT; 
  800421e442:	83 4d e8 04          	orl    $0x4,-0x18(%rbp)
  800421e446:	c7 45 fc 02 40 00 00 	movl   $0x4002,-0x4(%rbp)
  800421e44d:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421e450:	89 45 dc             	mov    %eax,-0x24(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421e453:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800421e456:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421e459:	48 89 d6             	mov    %rdx,%rsi
  800421e45c:	89 c7                	mov    %eax,%edi
  800421e45e:	48 b8 4e e1 21 04 80 	movabs $0x800421e14e,%rax
  800421e465:	00 00 00 
  800421e468:	ff d0                	callq  *%rax
  800421e46a:	eb 24                	jmp    800421e490 <handle_interrupts+0xa6>
  800421e46c:	c7 45 ec 16 40 00 00 	movl   $0x4016,-0x14(%rbp)
  800421e473:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800421e476:	89 45 d8             	mov    %eax,-0x28(%rbp)
  800421e479:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800421e47c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421e47f:	48 89 d6             	mov    %rdx,%rsi
  800421e482:	89 c7                	mov    %eax,%edi
  800421e484:	48 b8 4e e1 21 04 80 	movabs $0x800421e14e,%rax
  800421e48b:	00 00 00 
  800421e48e:	ff d0                	callq  *%rax
		vmcs_write32( VMCS_32BIT_CONTROL_VMENTRY_INTERRUPTION_INFO , host_vector);
	}
	
	
	
	return true;
  800421e490:	b8 01 00 00 00       	mov    $0x1,%eax
}
  800421e495:	c9                   	leaveq 
  800421e496:	c3                   	retq   

000000800421e497 <handle_rdmsr>:

bool
handle_rdmsr(struct Trapframe *tf, struct VmxGuestInfo *ginfo) {
  800421e497:	55                   	push   %rbp
  800421e498:	48 89 e5             	mov    %rsp,%rbp
  800421e49b:	48 83 ec 40          	sub    $0x40,%rsp
  800421e49f:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421e4a3:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    uint64_t msr = tf->tf_regs.reg_rcx;
  800421e4a7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421e4ab:	48 8b 40 60          	mov    0x60(%rax),%rax
  800421e4af:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	msr = EFER_MSR;
  800421e4b3:	b8 80 00 00 c0       	mov    $0xc0000080,%eax
  800421e4b8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if(msr == EFER_MSR) {
  800421e4bc:	b8 80 00 00 c0       	mov    $0xc0000080,%eax
  800421e4c1:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421e4c5:	0f 85 d4 00 00 00    	jne    800421e59f <handle_rdmsr+0x108>
		// TODO: setup msr_bitmap to ignore EFER_MSR
		uint64_t val;
		struct vmx_msr_entry *entry;
		bool r = find_msr_in_region(msr, ginfo->msr_guest_area, ginfo->msr_count, &entry);
  800421e4cb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421e4cf:	8b 50 28             	mov    0x28(%rax),%edx
  800421e4d2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421e4d6:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421e4da:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800421e4de:	89 cf                	mov    %ecx,%edi
  800421e4e0:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800421e4e4:	48 89 c6             	mov    %rax,%rsi
  800421e4e7:	48 b8 12 e3 21 04 80 	movabs $0x800421e312,%rax
  800421e4ee:	00 00 00 
  800421e4f1:	ff d0                	callq  *%rax
  800421e4f3:	88 45 f7             	mov    %al,-0x9(%rbp)
		assert(r);
  800421e4f6:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  800421e4fa:	83 f0 01             	xor    $0x1,%eax
  800421e4fd:	84 c0                	test   %al,%al
  800421e4ff:	74 35                	je     800421e536 <handle_rdmsr+0x9f>
  800421e501:	48 b9 91 2a 22 04 80 	movabs $0x8004222a91,%rcx
  800421e508:	00 00 00 
  800421e50b:	48 ba 93 2a 22 04 80 	movabs $0x8004222a93,%rdx
  800421e512:	00 00 00 
  800421e515:	be 60 00 00 00       	mov    $0x60,%esi
  800421e51a:	48 bf a8 2a 22 04 80 	movabs $0x8004222aa8,%rdi
  800421e521:	00 00 00 
  800421e524:	b8 00 00 00 00       	mov    $0x0,%eax
  800421e529:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421e530:	00 00 00 
  800421e533:	41 ff d0             	callq  *%r8
		val = entry->msr_value;
  800421e536:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e53a:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421e53e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		tf->tf_regs.reg_rdx = val << 32;
  800421e542:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421e546:	48 c1 e0 20          	shl    $0x20,%rax
  800421e54a:	48 89 c2             	mov    %rax,%rdx
  800421e54d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421e551:	48 89 50 58          	mov    %rdx,0x58(%rax)
		tf->tf_regs.reg_rax = val & 0xFFFFFFFF;
  800421e555:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421e559:	89 c2                	mov    %eax,%edx
  800421e55b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421e55f:	48 89 50 70          	mov    %rdx,0x70(%rax)
  800421e563:	c7 45 e4 0c 44 00 00 	movl   $0x440c,-0x1c(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421e56a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421e56d:	89 c7                	mov    %eax,%edi
  800421e56f:	48 b8 74 e1 21 04 80 	movabs $0x800421e174,%rax
  800421e576:	00 00 00 
  800421e579:	ff d0                	callq  *%rax
  800421e57b:	89 c2                	mov    %eax,%edx

		tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH);
  800421e57d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421e581:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800421e588:	89 d2                	mov    %edx,%edx
  800421e58a:	48 01 c2             	add    %rax,%rdx
  800421e58d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421e591:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		return true;
  800421e598:	b8 01 00 00 00       	mov    $0x1,%eax
  800421e59d:	eb 05                	jmp    800421e5a4 <handle_rdmsr+0x10d>
	}
	return false;
  800421e59f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421e5a4:	c9                   	leaveq 
  800421e5a5:	c3                   	retq   

000000800421e5a6 <handle_wrmsr>:

bool 
handle_wrmsr(struct Trapframe *tf, struct VmxGuestInfo *ginfo) {
  800421e5a6:	55                   	push   %rbp
  800421e5a7:	48 89 e5             	mov    %rsp,%rbp
  800421e5aa:	48 83 ec 50          	sub    $0x50,%rsp
  800421e5ae:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800421e5b2:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
	uint64_t msr = tf->tf_regs.reg_rcx;
  800421e5b6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421e5ba:	48 8b 40 60          	mov    0x60(%rax),%rax
  800421e5be:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(msr == EFER_MSR) {
  800421e5c2:	b8 80 00 00 c0       	mov    $0xc0000080,%eax
  800421e5c7:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421e5cb:	0f 85 38 01 00 00    	jne    800421e709 <handle_wrmsr+0x163>

		uint64_t cur_val, new_val;
		struct vmx_msr_entry *entry;
		bool r = 
			find_msr_in_region(msr, ginfo->msr_guest_area, ginfo->msr_count, &entry);
  800421e5d1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421e5d5:	8b 50 28             	mov    0x28(%rax),%edx
  800421e5d8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421e5dc:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421e5e0:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800421e5e4:	89 cf                	mov    %ecx,%edi
	uint64_t msr = tf->tf_regs.reg_rcx;
	if(msr == EFER_MSR) {

		uint64_t cur_val, new_val;
		struct vmx_msr_entry *entry;
		bool r = 
  800421e5e6:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  800421e5ea:	48 89 c6             	mov    %rax,%rsi
  800421e5ed:	48 b8 12 e3 21 04 80 	movabs $0x800421e312,%rax
  800421e5f4:	00 00 00 
  800421e5f7:	ff d0                	callq  *%rax
  800421e5f9:	88 45 f7             	mov    %al,-0x9(%rbp)
			find_msr_in_region(msr, ginfo->msr_guest_area, ginfo->msr_count, &entry);
		assert(r);
  800421e5fc:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  800421e600:	83 f0 01             	xor    $0x1,%eax
  800421e603:	84 c0                	test   %al,%al
  800421e605:	74 35                	je     800421e63c <handle_wrmsr+0x96>
  800421e607:	48 b9 91 2a 22 04 80 	movabs $0x8004222a91,%rcx
  800421e60e:	00 00 00 
  800421e611:	48 ba 93 2a 22 04 80 	movabs $0x8004222a93,%rdx
  800421e618:	00 00 00 
  800421e61b:	be 75 00 00 00       	mov    $0x75,%esi
  800421e620:	48 bf a8 2a 22 04 80 	movabs $0x8004222aa8,%rdi
  800421e627:	00 00 00 
  800421e62a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421e62f:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421e636:	00 00 00 
  800421e639:	41 ff d0             	callq  *%r8
		cur_val = entry->msr_value;
  800421e63c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421e640:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421e644:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		new_val = (tf->tf_regs.reg_rdx << 32)|tf->tf_regs.reg_rax;
  800421e648:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421e64c:	48 8b 40 58          	mov    0x58(%rax),%rax
  800421e650:	48 c1 e0 20          	shl    $0x20,%rax
  800421e654:	48 89 c2             	mov    %rax,%rdx
  800421e657:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421e65b:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421e65f:	48 09 d0             	or     %rdx,%rax
  800421e662:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		if(BIT(cur_val, EFER_LME) == 0 && BIT(new_val, EFER_LME) == 1) {
  800421e666:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421e66a:	25 00 01 00 00       	and    $0x100,%eax
  800421e66f:	48 85 c0             	test   %rax,%rax
  800421e672:	75 4d                	jne    800421e6c1 <handle_wrmsr+0x11b>
  800421e674:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421e678:	25 00 01 00 00       	and    $0x100,%eax
  800421e67d:	48 85 c0             	test   %rax,%rax
  800421e680:	74 3f                	je     800421e6c1 <handle_wrmsr+0x11b>
  800421e682:	c7 45 d4 12 40 00 00 	movl   $0x4012,-0x2c(%rbp)
  800421e689:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421e68c:	89 c7                	mov    %eax,%edi
  800421e68e:	48 b8 74 e1 21 04 80 	movabs $0x800421e174,%rax
  800421e695:	00 00 00 
  800421e698:	ff d0                	callq  *%rax
			// Long mode enable.
			uint32_t entry_ctls = vmcs_read32( VMCS_32BIT_CONTROL_VMENTRY_CONTROLS );
  800421e69a:	89 45 d8             	mov    %eax,-0x28(%rbp)
  800421e69d:	c7 45 d0 12 40 00 00 	movl   $0x4012,-0x30(%rbp)
  800421e6a4:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421e6a7:	89 45 cc             	mov    %eax,-0x34(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421e6aa:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800421e6ad:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800421e6b0:	48 89 d6             	mov    %rdx,%rsi
  800421e6b3:	89 c7                	mov    %eax,%edi
  800421e6b5:	48 b8 4e e1 21 04 80 	movabs $0x800421e14e,%rax
  800421e6bc:	00 00 00 
  800421e6bf:	ff d0                	callq  *%rax
			vmcs_write32( VMCS_32BIT_CONTROL_VMENTRY_CONTROLS, 
				      entry_ctls );

		}

		entry->msr_value = new_val;
  800421e6c1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421e6c5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421e6c9:	48 89 50 08          	mov    %rdx,0x8(%rax)
  800421e6cd:	c7 45 dc 0c 44 00 00 	movl   $0x440c,-0x24(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421e6d4:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421e6d7:	89 c7                	mov    %eax,%edi
  800421e6d9:	48 b8 74 e1 21 04 80 	movabs $0x800421e174,%rax
  800421e6e0:	00 00 00 
  800421e6e3:	ff d0                	callq  *%rax
  800421e6e5:	89 c2                	mov    %eax,%edx
		tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH);
  800421e6e7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421e6eb:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800421e6f2:	89 d2                	mov    %edx,%edx
  800421e6f4:	48 01 c2             	add    %rax,%rdx
  800421e6f7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421e6fb:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		return true;
  800421e702:	b8 01 00 00 00       	mov    $0x1,%eax
  800421e707:	eb 05                	jmp    800421e70e <handle_wrmsr+0x168>
	}

	return false;
  800421e709:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421e70e:	c9                   	leaveq 
  800421e70f:	c3                   	retq   

000000800421e710 <handle_eptviolation>:

bool
handle_eptviolation(uint64_t *eptrt, struct VmxGuestInfo *ginfo) {
  800421e710:	55                   	push   %rbp
  800421e711:	48 89 e5             	mov    %rsp,%rbp
  800421e714:	53                   	push   %rbx
  800421e715:	48 83 ec 48          	sub    $0x48,%rsp
  800421e719:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800421e71d:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800421e721:	c7 45 cc 00 24 00 00 	movl   $0x2400,-0x34(%rbp)
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421e728:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421e72b:	89 c7                	mov    %eax,%edi
  800421e72d:	48 b8 74 e1 21 04 80 	movabs $0x800421e174,%rax
  800421e734:	00 00 00 
  800421e737:	ff d0                	callq  *%rax
	uint64_t gpa = vmcs_read64(VMCS_64BIT_GUEST_PHYSICAL_ADDR);
  800421e739:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	int r;

	if(gpa < 0xA0000 || (gpa >= 0x100000 && gpa < ginfo->phys_sz)) 
  800421e73d:	48 81 7d e8 ff ff 09 	cmpq   $0x9ffff,-0x18(%rbp)
  800421e744:	00 
  800421e745:	76 1f                	jbe    800421e766 <handle_eptviolation+0x56>
  800421e747:	48 81 7d e8 ff ff 0f 	cmpq   $0xfffff,-0x18(%rbp)
  800421e74e:	00 
  800421e74f:	0f 86 f9 00 00 00    	jbe    800421e84e <handle_eptviolation+0x13e>
  800421e755:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421e759:	48 8b 00             	mov    (%rax),%rax
  800421e75c:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800421e760:	0f 86 e8 00 00 00    	jbe    800421e84e <handle_eptviolation+0x13e>

	{
		// Allocate a new page to the guest.
		struct PageInfo *p = page_alloc(0);
  800421e766:	bf 00 00 00 00       	mov    $0x0,%edi
  800421e76b:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  800421e772:	00 00 00 
  800421e775:	ff d0                	callq  *%rax
  800421e777:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		if(!p) {
  800421e77b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421e780:	75 25                	jne    800421e7a7 <handle_eptviolation+0x97>
			cprintf("vmm: handle_eptviolation: Failed to allocate a page for guest---out of memory.\n");
  800421e782:	48 bf b8 2a 22 04 80 	movabs $0x8004222ab8,%rdi
  800421e789:	00 00 00 
  800421e78c:	b8 00 00 00 00       	mov    $0x0,%eax
  800421e791:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421e798:	00 00 00 
  800421e79b:	ff d2                	callq  *%rdx
			return false;
  800421e79d:	b8 00 00 00 00       	mov    $0x0,%eax
  800421e7a2:	e9 54 01 00 00       	jmpq   800421e8fb <handle_eptviolation+0x1eb>
		}
		p->pp_ref += 1;
  800421e7a7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e7ab:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800421e7af:	8d 50 01             	lea    0x1(%rax),%edx
  800421e7b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e7b6:	66 89 50 08          	mov    %dx,0x8(%rax)
		r = ept_map_hva2gpa(eptrt, 
				    page2kva(p), (void *)ROUNDDOWN(gpa, PGSIZE), __EPTE_FULL, 0);
  800421e7ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421e7be:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800421e7c2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421e7c6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
		if(!p) {
			cprintf("vmm: handle_eptviolation: Failed to allocate a page for guest---out of memory.\n");
			return false;
		}
		p->pp_ref += 1;
		r = ept_map_hva2gpa(eptrt, 
  800421e7cc:	48 89 c3             	mov    %rax,%rbx
  800421e7cf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e7d3:	48 89 c7             	mov    %rax,%rdi
  800421e7d6:	48 b8 56 e2 21 04 80 	movabs $0x800421e256,%rax
  800421e7dd:	00 00 00 
  800421e7e0:	ff d0                	callq  *%rax
  800421e7e2:	48 89 c6             	mov    %rax,%rsi
  800421e7e5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421e7e9:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800421e7ef:	b9 07 00 00 00       	mov    $0x7,%ecx
  800421e7f4:	48 89 da             	mov    %rbx,%rdx
  800421e7f7:	48 89 c7             	mov    %rax,%rdi
  800421e7fa:	48 b8 cc 9f 21 04 80 	movabs $0x8004219fcc,%rax
  800421e801:	00 00 00 
  800421e804:	ff d0                	callq  *%rax
  800421e806:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				    page2kva(p), (void *)ROUNDDOWN(gpa, PGSIZE), __EPTE_FULL, 0);
		assert(r >= 0);
  800421e809:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421e80d:	79 35                	jns    800421e844 <handle_eptviolation+0x134>
  800421e80f:	48 b9 08 2b 22 04 80 	movabs $0x8004222b08,%rcx
  800421e816:	00 00 00 
  800421e819:	48 ba 93 2a 22 04 80 	movabs $0x8004222a93,%rdx
  800421e820:	00 00 00 
  800421e823:	be 9b 00 00 00       	mov    $0x9b,%esi
  800421e828:	48 bf a8 2a 22 04 80 	movabs $0x8004222aa8,%rdi
  800421e82f:	00 00 00 
  800421e832:	b8 00 00 00 00       	mov    $0x0,%eax
  800421e837:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421e83e:	00 00 00 
  800421e841:	41 ff d0             	callq  *%r8

		//cprintf("EPT violation for gpa:%x mapped KVA:%x\n", gpa, page2kva(p));
		return true;
  800421e844:	b8 01 00 00 00       	mov    $0x1,%eax
  800421e849:	e9 ad 00 00 00       	jmpq   800421e8fb <handle_eptviolation+0x1eb>
	} else if (gpa >= CGA_BUF && gpa < CGA_BUF + PGSIZE) {
  800421e84e:	48 81 7d e8 ff 7f 0b 	cmpq   $0xb7fff,-0x18(%rbp)
  800421e855:	00 
  800421e856:	76 7c                	jbe    800421e8d4 <handle_eptviolation+0x1c4>
  800421e858:	48 81 7d e8 ff 8f 0b 	cmpq   $0xb8fff,-0x18(%rbp)
  800421e85f:	00 
  800421e860:	77 72                	ja     800421e8d4 <handle_eptviolation+0x1c4>
		// FIXME: This give direct access to VGA MMIO region.
		r = ept_map_hva2gpa(eptrt, 
  800421e862:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421e866:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800421e86c:	b9 07 00 00 00       	mov    $0x7,%ecx
  800421e871:	ba 00 80 0b 00       	mov    $0xb8000,%edx
  800421e876:	48 be 00 80 0b 04 80 	movabs $0x80040b8000,%rsi
  800421e87d:	00 00 00 
  800421e880:	48 89 c7             	mov    %rax,%rdi
  800421e883:	48 b8 cc 9f 21 04 80 	movabs $0x8004219fcc,%rax
  800421e88a:	00 00 00 
  800421e88d:	ff d0                	callq  *%rax
  800421e88f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				    (void *)(KERNBASE + CGA_BUF), (void *)CGA_BUF, __EPTE_FULL, 0);
		assert(r >= 0);
  800421e892:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421e896:	79 35                	jns    800421e8cd <handle_eptviolation+0x1bd>
  800421e898:	48 b9 08 2b 22 04 80 	movabs $0x8004222b08,%rcx
  800421e89f:	00 00 00 
  800421e8a2:	48 ba 93 2a 22 04 80 	movabs $0x8004222a93,%rdx
  800421e8a9:	00 00 00 
  800421e8ac:	be a3 00 00 00       	mov    $0xa3,%esi
  800421e8b1:	48 bf a8 2a 22 04 80 	movabs $0x8004222aa8,%rdi
  800421e8b8:	00 00 00 
  800421e8bb:	b8 00 00 00 00       	mov    $0x0,%eax
  800421e8c0:	49 b8 d3 04 20 04 80 	movabs $0x80042004d3,%r8
  800421e8c7:	00 00 00 
  800421e8ca:	41 ff d0             	callq  *%r8
		return true;
  800421e8cd:	b8 01 00 00 00       	mov    $0x1,%eax
  800421e8d2:	eb 27                	jmp    800421e8fb <handle_eptviolation+0x1eb>
	}
	cprintf("vmm: handle_eptviolation: Case 2, gpa %x\n", gpa);
  800421e8d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421e8d8:	48 89 c6             	mov    %rax,%rsi
  800421e8db:	48 bf 10 2b 22 04 80 	movabs $0x8004222b10,%rdi
  800421e8e2:	00 00 00 
  800421e8e5:	b8 00 00 00 00       	mov    $0x0,%eax
  800421e8ea:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421e8f1:	00 00 00 
  800421e8f4:	ff d2                	callq  *%rdx
	return false;
  800421e8f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421e8fb:	48 83 c4 48          	add    $0x48,%rsp
  800421e8ff:	5b                   	pop    %rbx
  800421e900:	5d                   	pop    %rbp
  800421e901:	c3                   	retq   

000000800421e902 <handle_ioinstr>:

bool
handle_ioinstr(struct Trapframe *tf, struct VmxGuestInfo *ginfo) {
  800421e902:	55                   	push   %rbp
  800421e903:	48 89 e5             	mov    %rsp,%rbp
  800421e906:	48 83 ec 30          	sub    $0x30,%rsp
  800421e90a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421e90e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421e912:	c7 45 e4 00 64 00 00 	movl   $0x6400,-0x1c(%rbp)
  800421e919:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421e91c:	89 c7                	mov    %eax,%edi
  800421e91e:	48 b8 74 e1 21 04 80 	movabs $0x800421e174,%rax
  800421e925:	00 00 00 
  800421e928:	ff d0                	callq  *%rax
	static int port_iortc;
	
	uint64_t qualification = vmcs_read64(VMCS_VMEXIT_QUALIFICATION);
  800421e92a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	int port_number = (qualification >> 16) & 0xFFFF;
  800421e92e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421e932:	48 c1 e8 10          	shr    $0x10,%rax
  800421e936:	25 ff ff 00 00       	and    $0xffff,%eax
  800421e93b:	89 45 ec             	mov    %eax,-0x14(%rbp)
	bool is_in = BIT(qualification, 3);
  800421e93e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421e942:	48 c1 e8 03          	shr    $0x3,%rax
  800421e946:	83 e0 01             	and    $0x1,%eax
  800421e949:	48 85 c0             	test   %rax,%rax
  800421e94c:	0f 95 c0             	setne  %al
  800421e94f:	88 45 eb             	mov    %al,-0x15(%rbp)
	bool handled = false;
  800421e952:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
	
	// handle reading physical memory from the CMOS.
	if(port_number == IO_RTC) {
  800421e956:	83 7d ec 70          	cmpl   $0x70,-0x14(%rbp)
  800421e95a:	75 2e                	jne    800421e98a <handle_ioinstr+0x88>
		if(!is_in) {
  800421e95c:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  800421e960:	83 f0 01             	xor    $0x1,%eax
  800421e963:	84 c0                	test   %al,%al
  800421e965:	0f 84 fa 00 00 00    	je     800421ea65 <handle_ioinstr+0x163>
			port_iortc = tf->tf_regs.reg_rax;
  800421e96b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e96f:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421e973:	89 c2                	mov    %eax,%edx
  800421e975:	48 b8 cc f5 6d 04 80 	movabs $0x80046df5cc,%rax
  800421e97c:	00 00 00 
  800421e97f:	89 10                	mov    %edx,(%rax)
			handled = true;
  800421e981:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  800421e985:	e9 db 00 00 00       	jmpq   800421ea65 <handle_ioinstr+0x163>
		}
	} else if (port_number == IO_RTC + 1) {
  800421e98a:	83 7d ec 71          	cmpl   $0x71,-0x14(%rbp)
  800421e98e:	0f 85 d1 00 00 00    	jne    800421ea65 <handle_ioinstr+0x163>
		if(is_in) {
  800421e994:	80 7d eb 00          	cmpb   $0x0,-0x15(%rbp)
  800421e998:	0f 84 c7 00 00 00    	je     800421ea65 <handle_ioinstr+0x163>
			if(port_iortc == NVRAM_BASELO) {
  800421e99e:	48 b8 cc f5 6d 04 80 	movabs $0x80046df5cc,%rax
  800421e9a5:	00 00 00 
  800421e9a8:	8b 00                	mov    (%rax),%eax
  800421e9aa:	83 f8 15             	cmp    $0x15,%eax
  800421e9ad:	75 15                	jne    800421e9c4 <handle_ioinstr+0xc2>
				tf->tf_regs.reg_rax = 640 & 0xFF;
  800421e9af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e9b3:	48 c7 40 70 80 00 00 	movq   $0x80,0x70(%rax)
  800421e9ba:	00 
				handled = true;
  800421e9bb:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  800421e9bf:	e9 a1 00 00 00       	jmpq   800421ea65 <handle_ioinstr+0x163>
			} else if (port_iortc == NVRAM_BASEHI) {
  800421e9c4:	48 b8 cc f5 6d 04 80 	movabs $0x80046df5cc,%rax
  800421e9cb:	00 00 00 
  800421e9ce:	8b 00                	mov    (%rax),%eax
  800421e9d0:	83 f8 16             	cmp    $0x16,%eax
  800421e9d3:	75 12                	jne    800421e9e7 <handle_ioinstr+0xe5>
				tf->tf_regs.reg_rax = (640 >> 8) & 0xFF;
  800421e9d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421e9d9:	48 c7 40 70 02 00 00 	movq   $0x2,0x70(%rax)
  800421e9e0:	00 
				handled = true;
  800421e9e1:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  800421e9e5:	eb 7e                	jmp    800421ea65 <handle_ioinstr+0x163>
			} else if (port_iortc == NVRAM_EXTLO) {
  800421e9e7:	48 b8 cc f5 6d 04 80 	movabs $0x80046df5cc,%rax
  800421e9ee:	00 00 00 
  800421e9f1:	8b 00                	mov    (%rax),%eax
  800421e9f3:	83 f8 17             	cmp    $0x17,%eax
  800421e9f6:	75 2a                	jne    800421ea22 <handle_ioinstr+0x120>
				tf->tf_regs.reg_rax = ((ginfo->phys_sz / 1024) - 1024) & 0xFF;
  800421e9f8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421e9fc:	48 8b 00             	mov    (%rax),%rax
  800421e9ff:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  800421ea06:	48 85 c0             	test   %rax,%rax
  800421ea09:	48 0f 48 c2          	cmovs  %rdx,%rax
  800421ea0d:	48 c1 f8 0a          	sar    $0xa,%rax
  800421ea11:	0f b6 d0             	movzbl %al,%edx
  800421ea14:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421ea18:	48 89 50 70          	mov    %rdx,0x70(%rax)
				handled = true;
  800421ea1c:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  800421ea20:	eb 43                	jmp    800421ea65 <handle_ioinstr+0x163>
			} else if (port_iortc == NVRAM_EXTHI) {
  800421ea22:	48 b8 cc f5 6d 04 80 	movabs $0x80046df5cc,%rax
  800421ea29:	00 00 00 
  800421ea2c:	8b 00                	mov    (%rax),%eax
  800421ea2e:	83 f8 18             	cmp    $0x18,%eax
  800421ea31:	75 32                	jne    800421ea65 <handle_ioinstr+0x163>
				tf->tf_regs.reg_rax = (((ginfo->phys_sz / 1024) - 1024) >> 8) & 0xFF;
  800421ea33:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421ea37:	48 8b 00             	mov    (%rax),%rax
  800421ea3a:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  800421ea41:	48 85 c0             	test   %rax,%rax
  800421ea44:	48 0f 48 c2          	cmovs  %rdx,%rax
  800421ea48:	48 c1 f8 0a          	sar    $0xa,%rax
  800421ea4c:	48 2d 00 04 00 00    	sub    $0x400,%rax
  800421ea52:	48 c1 f8 08          	sar    $0x8,%rax
  800421ea56:	0f b6 d0             	movzbl %al,%edx
  800421ea59:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421ea5d:	48 89 50 70          	mov    %rdx,0x70(%rax)
				handled = true;
  800421ea61:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
			}
		}
		
	} 

	if(handled) {
  800421ea65:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800421ea69:	74 3c                	je     800421eaa7 <handle_ioinstr+0x1a5>
  800421ea6b:	c7 45 f8 0c 44 00 00 	movl   $0x440c,-0x8(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421ea72:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421ea75:	89 c7                	mov    %eax,%edi
  800421ea77:	48 b8 74 e1 21 04 80 	movabs $0x800421e174,%rax
  800421ea7e:	00 00 00 
  800421ea81:	ff d0                	callq  *%rax
  800421ea83:	89 c2                	mov    %eax,%edx
		tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH);
  800421ea85:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421ea89:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800421ea90:	89 d2                	mov    %edx,%edx
  800421ea92:	48 01 c2             	add    %rax,%rdx
  800421ea95:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421ea99:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		return true;
  800421eaa0:	b8 01 00 00 00       	mov    $0x1,%eax
  800421eaa5:	eb 33                	jmp    800421eada <handle_ioinstr+0x1d8>
	} else {
		cprintf("%x %x\n", qualification, port_iortc);
  800421eaa7:	48 b8 cc f5 6d 04 80 	movabs $0x80046df5cc,%rax
  800421eaae:	00 00 00 
  800421eab1:	8b 10                	mov    (%rax),%edx
  800421eab3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421eab7:	48 89 c6             	mov    %rax,%rsi
  800421eaba:	48 bf 3a 2b 22 04 80 	movabs $0x8004222b3a,%rdi
  800421eac1:	00 00 00 
  800421eac4:	b8 00 00 00 00       	mov    $0x0,%eax
  800421eac9:	48 b9 eb 9c 20 04 80 	movabs $0x8004209ceb,%rcx
  800421ead0:	00 00 00 
  800421ead3:	ff d1                	callq  *%rcx
		return false;    
  800421ead5:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
  800421eada:	c9                   	leaveq 
  800421eadb:	c3                   	retq   

000000800421eadc <handle_cpuid>:
// Finally, you need to increment the program counter in the trap frame.
// 
// Hint: The TA's solution does not hard-code the length of the cpuid instruction.
bool
handle_cpuid(struct Trapframe *tf, struct VmxGuestInfo *ginfo)
{
  800421eadc:	55                   	push   %rbp
  800421eadd:	48 89 e5             	mov    %rsp,%rbp
  800421eae0:	48 83 ec 30          	sub    $0x30,%rsp
  800421eae4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421eae8:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint32_t eax, ebx, ecx, edx;	
	
	cpuid(tf->tf_regs.reg_rax, &eax, &ebx, &ecx, &edx);
  800421eaec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421eaf0:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421eaf4:	89 c7                	mov    %eax,%edi
  800421eaf6:	48 8d 75 ec          	lea    -0x14(%rbp),%rsi
  800421eafa:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800421eafe:	48 8d 55 f4          	lea    -0xc(%rbp),%rdx
  800421eb02:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  800421eb06:	49 89 f0             	mov    %rsi,%r8
  800421eb09:	48 89 c6             	mov    %rax,%rsi
  800421eb0c:	48 b8 91 e1 21 04 80 	movabs $0x800421e191,%rax
  800421eb13:	00 00 00 
  800421eb16:	ff d0                	callq  *%rax

	if (tf->tf_regs.reg_rax == 0x1){
  800421eb18:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421eb1c:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421eb20:	48 83 f8 01          	cmp    $0x1,%rax
  800421eb24:	75 13                	jne    800421eb39 <handle_cpuid+0x5d>
		if (ecx & 0x20)
  800421eb26:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800421eb29:	83 e0 20             	and    $0x20,%eax
  800421eb2c:	85 c0                	test   %eax,%eax
  800421eb2e:	74 09                	je     800421eb39 <handle_cpuid+0x5d>
			ecx -= 0x20; 
  800421eb30:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800421eb33:	83 e8 20             	sub    $0x20,%eax
  800421eb36:	89 45 f0             	mov    %eax,-0x10(%rbp)
	}

	tf->tf_regs.reg_rax = eax;
  800421eb39:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421eb3c:	89 c2                	mov    %eax,%edx
  800421eb3e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421eb42:	48 89 50 70          	mov    %rdx,0x70(%rax)
	tf->tf_regs.reg_rbx = ebx;
  800421eb46:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421eb49:	89 c2                	mov    %eax,%edx
  800421eb4b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421eb4f:	48 89 50 68          	mov    %rdx,0x68(%rax)
	tf->tf_regs.reg_rcx = ecx;
  800421eb53:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800421eb56:	89 c2                	mov    %eax,%edx
  800421eb58:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421eb5c:	48 89 50 60          	mov    %rdx,0x60(%rax)
	tf->tf_regs.reg_rdx = edx;
  800421eb60:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421eb63:	89 c2                	mov    %eax,%edx
  800421eb65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421eb69:	48 89 50 58          	mov    %rdx,0x58(%rax)
  800421eb6d:	c7 45 fc 0c 44 00 00 	movl   $0x440c,-0x4(%rbp)
  800421eb74:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421eb77:	89 c7                	mov    %eax,%edi
  800421eb79:	48 b8 74 e1 21 04 80 	movabs $0x800421e174,%rax
  800421eb80:	00 00 00 
  800421eb83:	ff d0                	callq  *%rax
  800421eb85:	89 c2                	mov    %eax,%edx

	tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH);
  800421eb87:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421eb8b:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800421eb92:	89 d2                	mov    %edx,%edx
  800421eb94:	48 01 c2             	add    %rax,%rdx
  800421eb97:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421eb9b:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	return true;
  800421eba2:	b8 01 00 00 00       	mov    $0x1,%eax
}
  800421eba7:	c9                   	leaveq 
  800421eba8:	c3                   	retq   

000000800421eba9 <handle_vmcall>:
// 
// Hint: The TA's solution does not hard-code the length of the cpuid instruction.//

bool
handle_vmcall(struct Trapframe *tf, struct VmxGuestInfo *gInfo, uint64_t *eptrt)
{
  800421eba9:	55                   	push   %rbp
  800421ebaa:	48 89 e5             	mov    %rsp,%rbp
  800421ebad:	48 83 ec 70          	sub    $0x70,%rsp
  800421ebb1:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800421ebb5:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800421ebb9:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
	bool handled = false;
  800421ebbd:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
	int perm, r, i;
	void *gpa_pg, *hva_pg;
	envid_t to_env;
	uint32_t val;
	// phys address of the multiboot map in the guest.
	uint64_t multiboot_map_addr = 0x6000;
  800421ebc1:	48 c7 45 e8 00 60 00 	movq   $0x6000,-0x18(%rbp)
  800421ebc8:	00 
	struct PageInfo *p;

	switch(tf->tf_regs.reg_rax) {
  800421ebc9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421ebcd:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421ebd1:	48 83 f8 06          	cmp    $0x6,%rax
  800421ebd5:	0f 87 b6 03 00 00    	ja     800421ef91 <handle_vmcall+0x3e8>
  800421ebdb:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421ebe2:	00 
  800421ebe3:	48 b8 a0 2b 22 04 80 	movabs $0x8004222ba0,%rax
  800421ebea:	00 00 00 
  800421ebed:	48 01 d0             	add    %rdx,%rax
  800421ebf0:	48 8b 00             	mov    (%rax),%rax
  800421ebf3:	ff e0                	jmpq   *%rax
		// Copy the mbinfo and memory_map_t (segment descriptions) into the guest page, and return
		//   a pointer to this region in rbx (as a guest physical address).
		/* Your code here */

		// check mapping exist
		ept_gpa2hva((void *)eptrt, (void *)multiboot_map_addr, &hva_pg);
  800421ebf5:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421ebf9:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  800421ebfd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421ec01:	48 89 ce             	mov    %rcx,%rsi
  800421ec04:	48 89 c7             	mov    %rax,%rdi
  800421ec07:	48 b8 fc 9b 21 04 80 	movabs $0x8004219bfc,%rax
  800421ec0e:	00 00 00 
  800421ec11:	ff d0                	callq  *%rax
		if (hva_pg == NULL){
  800421ec13:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421ec17:	48 85 c0             	test   %rax,%rax
  800421ec1a:	75 52                	jne    800421ec6e <handle_vmcall+0xc5>
			p = page_alloc(ALLOC_ZERO);
  800421ec1c:	bf 01 00 00 00       	mov    $0x1,%edi
  800421ec21:	48 b8 b2 2e 20 04 80 	movabs $0x8004202eb2,%rax
  800421ec28:	00 00 00 
  800421ec2b:	ff d0                	callq  *%rax
  800421ec2d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
			hva_pg = page2kva(p);
  800421ec31:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421ec35:	48 89 c7             	mov    %rax,%rdi
  800421ec38:	48 b8 56 e2 21 04 80 	movabs $0x800421e256,%rax
  800421ec3f:	00 00 00 
  800421ec42:	ff d0                	callq  *%rax
  800421ec44:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			ept_map_hva2gpa((void *)eptrt, hva_pg, (void *)multiboot_map_addr, __EPTE_FULL, 0);
  800421ec48:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421ec4c:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  800421ec50:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421ec54:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800421ec5a:	b9 07 00 00 00       	mov    $0x7,%ecx
  800421ec5f:	48 89 c7             	mov    %rax,%rdi
  800421ec62:	48 b8 cc 9f 21 04 80 	movabs $0x8004219fcc,%rax
  800421ec69:	00 00 00 
  800421ec6c:	ff d0                	callq  *%rax
		}
		
		mbinfo = (struct multiboot_info *)hva_pg;
  800421ec6e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421ec72:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		mbinfo->flags = MB_FLAG_MMAP;
  800421ec76:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421ec7a:	c7 00 40 00 00 00    	movl   $0x40,(%rax)
		mbinfo->mmap_addr = (uint64_t)(multiboot_map_addr + sizeof(struct multiboot_info));
  800421ec80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421ec84:	8d 50 34             	lea    0x34(%rax),%edx
  800421ec87:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421ec8b:	89 50 30             	mov    %edx,0x30(%rax)
		mbinfo->mmap_length = 3 * sizeof(memory_map_t);
  800421ec8e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421ec92:	c7 40 2c 48 00 00 00 	movl   $0x48,0x2c(%rax)

		mmap = (memory_map_t *)(hva_pg + sizeof(struct multiboot_info));
  800421ec99:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421ec9d:	48 83 c0 34          	add    $0x34,%rax
  800421eca1:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		mmap->size = 20;
  800421eca5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421eca9:	c7 00 14 00 00 00    	movl   $0x14,(%rax)
		mmap->base_addr_low = 0;
  800421ecaf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ecb3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
		mmap->base_addr_high = 0;
  800421ecba:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ecbe:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
		mmap->length_low = 0xA0000;
  800421ecc5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ecc9:	c7 40 0c 00 00 0a 00 	movl   $0xa0000,0xc(%rax)
		mmap->length_high = 0;	
  800421ecd0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ecd4:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
		mmap->type = MB_TYPE_USABLE;
  800421ecdb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ecdf:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%rax)

		mmap+=1;
  800421ece6:	48 83 45 c8 18       	addq   $0x18,-0x38(%rbp)
		mmap->size = 20;
  800421eceb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ecef:	c7 00 14 00 00 00    	movl   $0x14,(%rax)
		mmap->base_addr_low = 0xA0000;
  800421ecf5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ecf9:	c7 40 04 00 00 0a 00 	movl   $0xa0000,0x4(%rax)
		mmap->base_addr_high = 0;
  800421ed00:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ed04:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
		mmap->length_low = 0x60000;;
  800421ed0b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ed0f:	c7 40 0c 00 00 06 00 	movl   $0x60000,0xc(%rax)
		mmap->length_high = 0;
  800421ed16:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ed1a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
		mmap->type = MB_TYPE_RESERVED;
  800421ed21:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ed25:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)

		mmap+=1;
  800421ed2c:	48 83 45 c8 18       	addq   $0x18,-0x38(%rbp)
		mmap->size = 20; 
  800421ed31:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ed35:	c7 00 14 00 00 00    	movl   $0x14,(%rax)
		mmap->base_addr_low = 0x100000;
  800421ed3b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ed3f:	c7 40 04 00 00 10 00 	movl   $0x100000,0x4(%rax)
		mmap->base_addr_high = 0;
  800421ed46:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ed4a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
		mmap->length_low = gInfo->phys_sz - 0x100000;
  800421ed51:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421ed55:	48 8b 00             	mov    (%rax),%rax
  800421ed58:	8d 90 00 00 f0 ff    	lea    -0x100000(%rax),%edx
  800421ed5e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ed62:	89 50 0c             	mov    %edx,0xc(%rax)
		mmap->length_high = 0;
  800421ed65:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ed69:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
		mmap->type = MB_TYPE_USABLE;	
  800421ed70:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ed74:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%rax)

		tf->tf_regs.reg_rbx = multiboot_map_addr;		
  800421ed7b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421ed7f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421ed83:	48 89 50 68          	mov    %rdx,0x68(%rax)
		handled = true;
  800421ed87:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
		break;
  800421ed8b:	e9 01 02 00 00       	jmpq   800421ef91 <handle_vmcall+0x3e8>
		//  do this translation.
		//
		// The input should be a guest physical address; you will need to convert
		//  this to a host virtual address for the IPC to work properly.
		/* Your code here */
		ept_gpa2hva(eptrt, (void *)tf->tf_regs.reg_rdx, &hva_pg);
  800421ed90:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421ed94:	48 8b 40 58          	mov    0x58(%rax),%rax
  800421ed98:	48 89 c1             	mov    %rax,%rcx
  800421ed9b:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  800421ed9f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421eda3:	48 89 ce             	mov    %rcx,%rsi
  800421eda6:	48 89 c7             	mov    %rax,%rdi
  800421eda9:	48 b8 fc 9b 21 04 80 	movabs $0x8004219bfc,%rax
  800421edb0:	00 00 00 
  800421edb3:	ff d0                	callq  *%rax
		
		for (i = 0; i < NENV; i++) {
  800421edb5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  800421edbc:	eb 5c                	jmp    800421ee1a <handle_vmcall+0x271>
			if (envs[i].env_type == tf->tf_regs.reg_rbx){
  800421edbe:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  800421edc5:	00 00 00 
  800421edc8:	48 8b 10             	mov    (%rax),%rdx
  800421edcb:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421edce:	48 98                	cltq   
  800421edd0:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800421edd7:	48 01 d0             	add    %rdx,%rax
  800421edda:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800421ede0:	89 c2                	mov    %eax,%edx
  800421ede2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421ede6:	48 8b 40 68          	mov    0x68(%rax),%rax
  800421edea:	48 39 c2             	cmp    %rax,%rdx
  800421eded:	75 27                	jne    800421ee16 <handle_vmcall+0x26d>
				to_env =  envs[i].env_id;
  800421edef:	48 b8 58 02 4e 04 80 	movabs $0x80044e0258,%rax
  800421edf6:	00 00 00 
  800421edf9:	48 8b 10             	mov    (%rax),%rdx
  800421edfc:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421edff:	48 98                	cltq   
  800421ee01:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800421ee08:	48 01 d0             	add    %rdx,%rax
  800421ee0b:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800421ee11:	89 45 f4             	mov    %eax,-0xc(%rbp)
				break;
  800421ee14:	eb 0d                	jmp    800421ee23 <handle_vmcall+0x27a>
		// The input should be a guest physical address; you will need to convert
		//  this to a host virtual address for the IPC to work properly.
		/* Your code here */
		ept_gpa2hva(eptrt, (void *)tf->tf_regs.reg_rdx, &hva_pg);
		
		for (i = 0; i < NENV; i++) {
  800421ee16:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  800421ee1a:	81 7d f8 ff 03 00 00 	cmpl   $0x3ff,-0x8(%rbp)
  800421ee21:	7e 9b                	jle    800421edbe <handle_vmcall+0x215>
				to_env =  envs[i].env_id;
				break;
			}
		}
		
		tf->tf_regs.reg_rax = syscall(SYS_ipc_try_send,
  800421ee23:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421ee27:	48 89 c1             	mov    %rax,%rcx
  800421ee2a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421ee2e:	48 8b 50 60          	mov    0x60(%rax),%rdx
  800421ee32:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421ee35:	48 98                	cltq   
  800421ee37:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800421ee3d:	41 b8 07 00 00 00    	mov    $0x7,%r8d
  800421ee43:	48 89 c6             	mov    %rax,%rsi
  800421ee46:	bf 0c 00 00 00       	mov    $0xc,%edi
  800421ee4b:	48 b8 21 f4 20 04 80 	movabs $0x800420f421,%rax
  800421ee52:	00 00 00 
  800421ee55:	ff d0                	callq  *%rax
  800421ee57:	48 89 c2             	mov    %rax,%rdx
  800421ee5a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421ee5e:	48 89 50 70          	mov    %rdx,0x70(%rax)
						to_env,
						tf->tf_regs.reg_rcx, 
						(uint64_t)hva_pg,
						PTE_P | PTE_W | PTE_U,
						0);	
		handled = true;
  800421ee62:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
		break;
  800421ee66:	e9 26 01 00 00       	jmpq   800421ef91 <handle_vmcall+0x3e8>
  800421ee6b:	c7 45 c4 0c 44 00 00 	movl   $0x440c,-0x3c(%rbp)
  800421ee72:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421ee75:	89 c7                	mov    %eax,%edi
  800421ee77:	48 b8 74 e1 21 04 80 	movabs $0x800421e174,%rax
  800421ee7e:	00 00 00 
  800421ee81:	ff d0                	callq  *%rax
  800421ee83:	89 c2                	mov    %eax,%edx
	case VMX_VMCALL_IPCRECV:
		// Issue the sys_ipc_recv call for the guest.
		// NB: because recv can call schedule, clobbering the VMCS, 
		// you should go ahead and increment rip before this call.
		/* Your code here */
		tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH); 
  800421ee85:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421ee89:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800421ee90:	89 d2                	mov    %edx,%edx
  800421ee92:	48 01 c2             	add    %rax,%rdx
  800421ee95:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421ee99:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
			(uint64_t)hva_pg,
			0, 0, 0, 0);	
		*/
		
		tf->tf_regs.reg_rax = syscall(SYS_ipc_recv,
			(uint64_t)tf->tf_regs.reg_rbx,
  800421eea0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421eea4:	48 8b 40 68          	mov    0x68(%rax),%rax
		tf->tf_regs.reg_rax = syscall(SYS_ipc_recv,
			(uint64_t)hva_pg,
			0, 0, 0, 0);	
		*/
		
		tf->tf_regs.reg_rax = syscall(SYS_ipc_recv,
  800421eea8:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800421eeae:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800421eeb4:	b9 00 00 00 00       	mov    $0x0,%ecx
  800421eeb9:	ba 00 00 00 00       	mov    $0x0,%edx
  800421eebe:	48 89 c6             	mov    %rax,%rsi
  800421eec1:	bf 0d 00 00 00       	mov    $0xd,%edi
  800421eec6:	48 b8 21 f4 20 04 80 	movabs $0x800420f421,%rax
  800421eecd:	00 00 00 
  800421eed0:	ff d0                	callq  *%rax
  800421eed2:	48 89 c2             	mov    %rax,%rdx
  800421eed5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421eed9:	48 89 50 70          	mov    %rdx,0x70(%rax)
			(uint64_t)tf->tf_regs.reg_rbx,
			0, 0, 0, 0);	
		handled = true;
  800421eedd:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
		return handled;
  800421eee1:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  800421eee5:	e9 e6 00 00 00       	jmpq   800421efd0 <handle_vmcall+0x427>
	case VMX_VMCALL_LAPICEOI:
		lapic_eoi();
  800421eeea:	48 b8 32 81 21 04 80 	movabs $0x8004218132,%rax
  800421eef1:	00 00 00 
  800421eef4:	ff d0                	callq  *%rax
		handled = true;
  800421eef6:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
		break;
  800421eefa:	e9 92 00 00 00       	jmpq   800421ef91 <handle_vmcall+0x3e8>
	case VMX_VMCALL_BACKTOHOST:
		cprintf("Now back to the host, VM halt in the background, run vmmanager to resume the VM.\n");
  800421eeff:	48 bf 48 2b 22 04 80 	movabs $0x8004222b48,%rdi
  800421ef06:	00 00 00 
  800421ef09:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ef0e:	48 ba eb 9c 20 04 80 	movabs $0x8004209ceb,%rdx
  800421ef15:	00 00 00 
  800421ef18:	ff d2                	callq  *%rdx
		curenv->env_status = ENV_NOT_RUNNABLE;	//mark the guest not runable
  800421ef1a:	48 b8 fd 80 21 04 80 	movabs $0x80042180fd,%rax
  800421ef21:	00 00 00 
  800421ef24:	ff d0                	callq  *%rax
  800421ef26:	48 ba 20 10 6e 04 80 	movabs $0x80046e1020,%rdx
  800421ef2d:	00 00 00 
  800421ef30:	48 98                	cltq   
  800421ef32:	48 c1 e0 03          	shl    $0x3,%rax
  800421ef36:	48 89 c1             	mov    %rax,%rcx
  800421ef39:	48 c1 e1 04          	shl    $0x4,%rcx
  800421ef3d:	48 01 c8             	add    %rcx,%rax
  800421ef40:	48 01 d0             	add    %rdx,%rax
  800421ef43:	48 83 c0 08          	add    $0x8,%rax
  800421ef47:	48 8b 00             	mov    (%rax),%rax
  800421ef4a:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800421ef51:	00 00 00 
		ENV_CREATE(user_sh, ENV_TYPE_USER);	//create a new host shell
  800421ef54:	be 00 00 00 00       	mov    $0x0,%esi
  800421ef59:	48 bf 18 1c 4c 04 80 	movabs $0x80044c1c18,%rdi
  800421ef60:	00 00 00 
  800421ef63:	48 b8 1b 90 20 04 80 	movabs $0x800420901b,%rax
  800421ef6a:	00 00 00 
  800421ef6d:	ff d0                	callq  *%rax
		handled = true;
  800421ef6f:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
		break;	
  800421ef73:	eb 1c                	jmp    800421ef91 <handle_vmcall+0x3e8>
	case VMX_VMCALL_GETDISKIMGNUM:	//alloc a number to guest
		tf->tf_regs.reg_rax = vmdisk_number;
  800421ef75:	48 b8 c8 f5 6d 04 80 	movabs $0x80046df5c8,%rax
  800421ef7c:	00 00 00 
  800421ef7f:	8b 00                	mov    (%rax),%eax
  800421ef81:	48 63 d0             	movslq %eax,%rdx
  800421ef84:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421ef88:	48 89 50 70          	mov    %rdx,0x70(%rax)
		handled = true;
  800421ef8c:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
		break;
  800421ef90:	90                   	nop
         
	}
	if(handled) {
  800421ef91:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800421ef95:	74 35                	je     800421efcc <handle_vmcall+0x423>
  800421ef97:	c7 45 e4 0c 44 00 00 	movl   $0x440c,-0x1c(%rbp)
  800421ef9e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421efa1:	89 c7                	mov    %eax,%edi
  800421efa3:	48 b8 74 e1 21 04 80 	movabs $0x800421e174,%rax
  800421efaa:	00 00 00 
  800421efad:	ff d0                	callq  *%rax
  800421efaf:	89 c2                	mov    %eax,%edx
		/* Advance the program counter by the length of the vmcall instruction. 
		 * 
		 * Hint: The TA solution does not hard-code the length of the vmcall instruction.
		 */
		/* Your code here */
		tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH);
  800421efb1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421efb5:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800421efbc:	89 d2                	mov    %edx,%edx
  800421efbe:	48 01 c2             	add    %rax,%rdx
  800421efc1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421efc5:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	}
	return handled;
  800421efcc:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  800421efd0:	c9                   	leaveq 
  800421efd1:	c3                   	retq   
